
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis reference jinja - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#submission-name-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis reference jinja
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_reference">back to reference summary</a></p>
<h1 id="submission-name-reference">Submission Name: reference</h1>
<h1 id="repository-jinja">Repository: jinja</h1>
<h2 id="pytest-summary-tests">Pytest Summary: tests</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">851</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">851</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">851</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytest-outputs-tests">Failed pytest outputs: tests</h2>
<h3 id="patch-diff">Patch diff</h3>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/jinja2/_identifier.py b/src/jinja2/_identifier.py</span>
<span class="gh">index 503c0e8..928c150 100644</span>
<span class="gd">--- a/src/jinja2/_identifier.py</span>
<span class="gi">+++ b/src/jinja2/_identifier.py</span>
<span class="gu">@@ -1,4 +1,6 @@</span>
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="gi">+# generated by scripts/generate_identifier_pattern.py</span>
<span class="w"> </span>pattern = re.compile(
<span class="gd">-    &#39;[\\w·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣ৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣஂா-ூெ-ைொ-்ௗఀ-ఄా-ౄె-ైొ-్ౕౖౢౣಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣංඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ູົຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝᠋-᠍ᢅᢆᢩᤠ-ᤫᤰ-᤻ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼᪰-᪽ᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-ᮭ᯦-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭ᳲ-᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰℘℮⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꧥꨩ-ꨶꩃꩌꩍꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︯︳︴﹍-﹏＿𐇽𐋠𐍶-𐍺𐨁-𐨃𐨅𐨆𐨌-𐨏𐨸-𐨿𐨺𐫦𐫥𐴤-𐽆𐴧-𐽐𑀀-𑀂𑀸-𑁆𑁿-𑂂𑂰-𑂺𑄀-𑄂𑄧-𑄴𑅅𑅆𑅳𑆀-𑆂𑆳-𑇀𑇉-𑇌𑈬-𑈷𑈾𑋟-𑋪𑌀-𑌃𑌻𑌼𑌾-𑍄𑍇𑍈𑍋-𑍍𑍗𑍢𑍣𑍦-𑍬𑍰-𑍴𑐵-𑑆𑑞𑒰-𑓃𑖯-𑖵𑖸-𑗀𑗜𑗝𑘰-𑙀𑚫-𑚷𑜝-𑜫𑠬-𑠺𑨁-𑨊𑨳-𑨹𑨻-𑨾𑩇𑩑-𑩛𑪊-𑪙𑰯-𑰶𑰸-𑰿𑲒-𑲧𑲩-𑲶𑴱-𑴶𑴺𑴼𑴽𑴿-𑵅𑵇𑶊-𑶎𑶐𑶑𑶓-𑶗𑻳-𑻶𖫰-𖫴𖬰-𖬶𖽑-𖽾𖾏-𖾒𛲝𛲞𝅥-𝅩𝅭-𝅲𝅻-𝆂𝆅-𝆋𝆪-𝆭𝉂-𝉄𝨀-𝨶𝨻-𝩬𝩵𝪄𝪛-𝪟𝪡-𝪯𞀀-𞀆𞀈-𞀘𞀛-𞀡𞀣𞀤𞀦-𞣐𞀪-𞣖𞥄-𞥊󠄀-󠇯]+&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+    r&quot;[\w·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣ৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣஂா-ூெ-ைொ-்ௗఀ-ఄా-ౄె-ైొ-్ౕౖౢౣಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣංඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ູົຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝᠋-᠍ᢅᢆᢩᤠ-ᤫᤰ-᤻ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼᪰-᪽ᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-ᮭ᯦-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭ᳲ-᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰℘℮⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꧥꨩ-ꨶꩃꩌꩍꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︯︳︴﹍-﹏＿𐇽𐋠𐍶-𐍺𐨁-𐨃𐨅𐨆𐨌-𐨏𐨸-𐨿𐨺𐫦𐫥𐴤-𐽆𐴧-𐽐𑀀-𑀂𑀸-𑁆𑁿-𑂂𑂰-𑂺𑄀-𑄂𑄧-𑄴𑅅𑅆𑅳𑆀-𑆂𑆳-𑇀𑇉-𑇌𑈬-𑈷𑈾𑋟-𑋪𑌀-𑌃𑌻𑌼𑌾-𑍄𑍇𑍈𑍋-𑍍𑍗𑍢𑍣𑍦-𑍬𑍰-𑍴𑐵-𑑆𑑞𑒰-𑓃𑖯-𑖵𑖸-𑗀𑗜𑗝𑘰-𑙀𑚫-𑚷𑜝-𑜫𑠬-𑠺𑨁-𑨊𑨳-𑨹𑨻-𑨾𑩇𑩑-𑩛𑪊-𑪙𑰯-𑰶𑰸-𑰿𑲒-𑲧𑲩-𑲶𑴱-𑴶𑴺𑴼𑴽𑴿-𑵅𑵇𑶊-𑶎𑶐𑶑𑶓-𑶗𑻳-𑻶𖫰-𖫴𖬰-𖬶𖽑-𖽾𖾏-𖾒𛲝𛲞𝅥-𝅩𝅭-𝅲𝅻-𝆂𝆅-𝆋𝆪-𝆭𝉂-𝉄𝨀-𝨶𝨻-𝩬𝩵𝪄𝪛-𝪟𝪡-𝪯𞀀-𞀆𞀈-𞀘𞀛-𞀡𞀣𞀤𞀦-𞣐𞀪-𞣖𞥄-𞥊󠄀-󠇯]+&quot;  # noqa: B950</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/src/jinja2/async_utils.py b/src/jinja2/async_utils.py</span>
<span class="gh">index f60e3f3..e65219e 100644</span>
<span class="gd">--- a/src/jinja2/async_utils.py</span>
<span class="gi">+++ b/src/jinja2/async_utils.py</span>
<span class="gu">@@ -2,7 +2,83 @@ import inspect</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from functools import WRAPPER_ASSIGNMENTS
<span class="w"> </span>from functools import wraps
<span class="gi">+</span>
<span class="w"> </span>from .utils import _PassArg
<span class="w"> </span>from .utils import pass_eval_context
<span class="gd">-V = t.TypeVar(&#39;V&#39;)</span>
<span class="gi">+</span>
<span class="gi">+V = t.TypeVar(&quot;V&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def async_variant(normal_func):  # type: ignore</span>
<span class="gi">+    def decorator(async_func):  # type: ignore</span>
<span class="gi">+        pass_arg = _PassArg.from_obj(normal_func)</span>
<span class="gi">+        need_eval_context = pass_arg is None</span>
<span class="gi">+</span>
<span class="gi">+        if pass_arg is _PassArg.environment:</span>
<span class="gi">+</span>
<span class="gi">+            def is_async(args: t.Any) -&gt; bool:</span>
<span class="gi">+                return t.cast(bool, args[0].is_async)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def is_async(args: t.Any) -&gt; bool:</span>
<span class="gi">+                return t.cast(bool, args[0].environment.is_async)</span>
<span class="gi">+</span>
<span class="gi">+        # Take the doc and annotations from the sync function, but the</span>
<span class="gi">+        # name from the async function. Pallets-Sphinx-Themes</span>
<span class="gi">+        # build_function_directive expects __wrapped__ to point to the</span>
<span class="gi">+        # sync function.</span>
<span class="gi">+        async_func_attrs = (&quot;__module__&quot;, &quot;__name__&quot;, &quot;__qualname__&quot;)</span>
<span class="gi">+        normal_func_attrs = tuple(set(WRAPPER_ASSIGNMENTS).difference(async_func_attrs))</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(normal_func, assigned=normal_func_attrs)</span>
<span class="gi">+        @wraps(async_func, assigned=async_func_attrs, updated=())</span>
<span class="gi">+        def wrapper(*args, **kwargs):  # type: ignore</span>
<span class="gi">+            b = is_async(args)</span>
<span class="gi">+</span>
<span class="gi">+            if need_eval_context:</span>
<span class="gi">+                args = args[1:]</span>
<span class="gi">+</span>
<span class="gi">+            if b:</span>
<span class="gi">+                return async_func(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            return normal_func(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        if need_eval_context:</span>
<span class="gi">+            wrapper = pass_eval_context(wrapper)</span>
<span class="gi">+</span>
<span class="gi">+        wrapper.jinja_async_variant = True  # type: ignore[attr-defined]</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_common_primitives = {int, float, bool, str, list, dict, tuple, type(None)}
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def auto_await(value: t.Union[t.Awaitable[&quot;V&quot;], &quot;V&quot;]) -&gt; &quot;V&quot;:</span>
<span class="gi">+    # Avoid a costly call to isawaitable</span>
<span class="gi">+    if type(value) in _common_primitives:</span>
<span class="gi">+        return t.cast(&quot;V&quot;, value)</span>
<span class="gi">+</span>
<span class="gi">+    if inspect.isawaitable(value):</span>
<span class="gi">+        return await t.cast(&quot;t.Awaitable[V]&quot;, value)</span>
<span class="gi">+</span>
<span class="gi">+    return t.cast(&quot;V&quot;, value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def auto_aiter(</span>
<span class="gi">+    iterable: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+) -&gt; &quot;t.AsyncIterator[V]&quot;:</span>
<span class="gi">+    if hasattr(iterable, &quot;__aiter__&quot;):</span>
<span class="gi">+        async for item in t.cast(&quot;t.AsyncIterable[V]&quot;, iterable):</span>
<span class="gi">+            yield item</span>
<span class="gi">+    else:</span>
<span class="gi">+        for item in iterable:</span>
<span class="gi">+            yield item</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def auto_to_list(</span>
<span class="gi">+    value: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+) -&gt; t.List[&quot;V&quot;]:</span>
<span class="gi">+    return [x async for x in auto_aiter(value)]</span>
<span class="gh">diff --git a/src/jinja2/bccache.py b/src/jinja2/bccache.py</span>
<span class="gh">index ae575a3..ada8b09 100644</span>
<span class="gd">--- a/src/jinja2/bccache.py</span>
<span class="gi">+++ b/src/jinja2/bccache.py</span>
<span class="gu">@@ -5,6 +5,7 @@ slows down your application too much.</span>
<span class="w"> </span>Situations where this is useful are often forking web applications that
<span class="w"> </span>are initialized on the first request.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import errno
<span class="w"> </span>import fnmatch
<span class="w"> </span>import marshal
<span class="gu">@@ -17,16 +18,29 @@ import typing as t</span>
<span class="w"> </span>from hashlib import sha1
<span class="w"> </span>from io import BytesIO
<span class="w"> </span>from types import CodeType
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gd">-    from .environment import Environment</span>

<span class="gi">+    from .environment import Environment</span>

<span class="w"> </span>    class _MemcachedClient(te.Protocol):
<span class="gd">-        pass</span>
<span class="gi">+        def get(self, key: str) -&gt; bytes: ...</span>
<span class="gi">+</span>
<span class="gi">+        def set(</span>
<span class="gi">+            self, key: str, value: bytes, timeout: t.Optional[int] = None</span>
<span class="gi">+        ) -&gt; None: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>bc_version = 5
<span class="gd">-bc_magic = b&#39;j2&#39; + pickle.dumps(bc_version, 2) + pickle.dumps(sys.</span>
<span class="gd">-    version_info[0] &lt;&lt; 24 | sys.version_info[1], 2)</span>
<span class="gi">+# Magic bytes to identify Jinja bytecode cache files. Contains the</span>
<span class="gi">+# Python major and minor version to avoid loading incompatible bytecode</span>
<span class="gi">+# if a project upgrades its Python version.</span>
<span class="gi">+bc_magic = (</span>
<span class="gi">+    b&quot;j2&quot;</span>
<span class="gi">+    + pickle.dumps(bc_version, 2)</span>
<span class="gi">+    + pickle.dumps((sys.version_info[0] &lt;&lt; 24) | sys.version_info[1], 2)</span>
<span class="gi">+)</span>


<span class="w"> </span>class Bucket:
<span class="gu">@@ -38,32 +52,52 @@ class Bucket:</span>
<span class="w"> </span>    cache subclasses don&#39;t have to care about cache invalidation.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, environment: &#39;Environment&#39;, key: str, checksum: str</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, environment: &quot;Environment&quot;, key: str, checksum: str) -&gt; None:</span>
<span class="w"> </span>        self.environment = environment
<span class="w"> </span>        self.key = key
<span class="w"> </span>        self.checksum = checksum
<span class="w"> </span>        self.reset()

<span class="gd">-    def reset(self) -&gt;None:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets the bucket (unloads the bytecode).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.code: t.Optional[CodeType] = None</span>

<span class="gd">-    def load_bytecode(self, f: t.BinaryIO) -&gt;None:</span>
<span class="gi">+    def load_bytecode(self, f: t.BinaryIO) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Loads bytecode from a file or file like object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def write_bytecode(self, f: t.IO[bytes]) -&gt;None:</span>
<span class="gi">+        # make sure the magic header is correct</span>
<span class="gi">+        magic = f.read(len(bc_magic))</span>
<span class="gi">+        if magic != bc_magic:</span>
<span class="gi">+            self.reset()</span>
<span class="gi">+            return</span>
<span class="gi">+        # the source code of the file changed, we need to reload</span>
<span class="gi">+        checksum = pickle.load(f)</span>
<span class="gi">+        if self.checksum != checksum:</span>
<span class="gi">+            self.reset()</span>
<span class="gi">+            return</span>
<span class="gi">+        # if marshal_load fails then we need to reload</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.code = marshal.load(f)</span>
<span class="gi">+        except (EOFError, ValueError, TypeError):</span>
<span class="gi">+            self.reset()</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+    def write_bytecode(self, f: t.IO[bytes]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Dump the bytecode into the file or file like object passed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.code is None:</span>
<span class="gi">+            raise TypeError(&quot;can&#39;t write empty bucket&quot;)</span>
<span class="gi">+        f.write(bc_magic)</span>
<span class="gi">+        pickle.dump(self.checksum, f, 2)</span>
<span class="gi">+        marshal.dump(self.code, f)</span>

<span class="gd">-    def bytecode_from_string(self, string: bytes) -&gt;None:</span>
<span class="gi">+    def bytecode_from_string(self, string: bytes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load bytecode from bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.load_bytecode(BytesIO(string))</span>

<span class="gd">-    def bytecode_to_string(self) -&gt;bytes:</span>
<span class="gi">+    def bytecode_to_string(self) -&gt; bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the bytecode as bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        out = BytesIO()</span>
<span class="gi">+        self.write_bytecode(out)</span>
<span class="gi">+        return out.getvalue()</span>


<span class="w"> </span>class BytecodeCache:
<span class="gu">@@ -95,46 +129,60 @@ class BytecodeCache:</span>
<span class="w"> </span>    Jinja.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def load_bytecode(self, bucket: Bucket) -&gt;None:</span>
<span class="gi">+    def load_bytecode(self, bucket: Bucket) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Subclasses have to override this method to load bytecode into a
<span class="w"> </span>        bucket.  If they are not able to find code in the cache for the
<span class="w"> </span>        bucket, it must not do anything.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def dump_bytecode(self, bucket: Bucket) -&gt;None:</span>
<span class="gi">+    def dump_bytecode(self, bucket: Bucket) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Subclasses have to override this method to write the bytecode
<span class="w"> </span>        from a bucket back to the cache.  If it unable to do so it must not
<span class="w"> </span>        fail silently but raise an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def clear(self) -&gt;None:</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clears the cache.  This method is not used by Jinja but should be
<span class="w"> </span>        implemented to allow applications to clear the bytecode cache used
<span class="w"> </span>        by a particular environment.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_cache_key(self, name: str, filename: t.Optional[t.Union[str]]=None</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+    def get_cache_key(</span>
<span class="gi">+        self, name: str, filename: t.Optional[t.Union[str]] = None</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the unique hash key for this template name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hash = sha1(name.encode(&quot;utf-8&quot;))</span>

<span class="gd">-    def get_source_checksum(self, source: str) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;Returns a checksum for the source.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if filename is not None:</span>
<span class="gi">+            hash.update(f&quot;|{filename}&quot;.encode())</span>
<span class="gi">+</span>
<span class="gi">+        return hash.hexdigest()</span>

<span class="gd">-    def get_bucket(self, environment: &#39;Environment&#39;, name: str, filename: t</span>
<span class="gd">-        .Optional[str], source: str) -&gt;Bucket:</span>
<span class="gi">+    def get_source_checksum(self, source: str) -&gt; str:</span>
<span class="gi">+        &quot;&quot;&quot;Returns a checksum for the source.&quot;&quot;&quot;</span>
<span class="gi">+        return sha1(source.encode(&quot;utf-8&quot;)).hexdigest()</span>
<span class="gi">+</span>
<span class="gi">+    def get_bucket(</span>
<span class="gi">+        self,</span>
<span class="gi">+        environment: &quot;Environment&quot;,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        filename: t.Optional[str],</span>
<span class="gi">+        source: str,</span>
<span class="gi">+    ) -&gt; Bucket:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a cache bucket for the given template.  All arguments are
<span class="w"> </span>        mandatory but filename may be `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key = self.get_cache_key(name, filename)</span>
<span class="gi">+        checksum = self.get_source_checksum(source)</span>
<span class="gi">+        bucket = Bucket(environment, key, checksum)</span>
<span class="gi">+        self.load_bytecode(bucket)</span>
<span class="gi">+        return bucket</span>

<span class="gd">-    def set_bucket(self, bucket: Bucket) -&gt;None:</span>
<span class="gi">+    def set_bucket(self, bucket: Bucket) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Put the bucket into the cache.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.dump_bytecode(bucket)</span>


<span class="w"> </span>class FileSystemBytecodeCache(BytecodeCache):
<span class="gu">@@ -155,13 +203,130 @@ class FileSystemBytecodeCache(BytecodeCache):</span>
<span class="w"> </span>    This bytecode cache supports clearing of the cache using the clear method.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, directory: t.Optional[str]=None, pattern: str=</span>
<span class="gd">-        &#39;__jinja2_%s.cache&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, directory: t.Optional[str] = None, pattern: str = &quot;__jinja2_%s.cache&quot;</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if directory is None:
<span class="w"> </span>            directory = self._get_default_cache_dir()
<span class="w"> </span>        self.directory = directory
<span class="w"> </span>        self.pattern = pattern

<span class="gi">+    def _get_default_cache_dir(self) -&gt; str:</span>
<span class="gi">+        def _unsafe_dir() -&gt; &quot;te.NoReturn&quot;:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &quot;Cannot determine safe temp directory.  You &quot;</span>
<span class="gi">+                &quot;need to explicitly provide one.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        tmpdir = tempfile.gettempdir()</span>
<span class="gi">+</span>
<span class="gi">+        # On windows the temporary directory is used specific unless</span>
<span class="gi">+        # explicitly forced otherwise.  We can just use that.</span>
<span class="gi">+        if os.name == &quot;nt&quot;:</span>
<span class="gi">+            return tmpdir</span>
<span class="gi">+        if not hasattr(os, &quot;getuid&quot;):</span>
<span class="gi">+            _unsafe_dir()</span>
<span class="gi">+</span>
<span class="gi">+        dirname = f&quot;_jinja2-cache-{os.getuid()}&quot;</span>
<span class="gi">+        actual_dir = os.path.join(tmpdir, dirname)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.mkdir(actual_dir, stat.S_IRWXU)</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            if e.errno != errno.EEXIST:</span>
<span class="gi">+                raise</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.chmod(actual_dir, stat.S_IRWXU)</span>
<span class="gi">+            actual_dir_stat = os.lstat(actual_dir)</span>
<span class="gi">+            if (</span>
<span class="gi">+                actual_dir_stat.st_uid != os.getuid()</span>
<span class="gi">+                or not stat.S_ISDIR(actual_dir_stat.st_mode)</span>
<span class="gi">+                or stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU</span>
<span class="gi">+            ):</span>
<span class="gi">+                _unsafe_dir()</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            if e.errno != errno.EEXIST:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+        actual_dir_stat = os.lstat(actual_dir)</span>
<span class="gi">+        if (</span>
<span class="gi">+            actual_dir_stat.st_uid != os.getuid()</span>
<span class="gi">+            or not stat.S_ISDIR(actual_dir_stat.st_mode)</span>
<span class="gi">+            or stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU</span>
<span class="gi">+        ):</span>
<span class="gi">+            _unsafe_dir()</span>
<span class="gi">+</span>
<span class="gi">+        return actual_dir</span>
<span class="gi">+</span>
<span class="gi">+    def _get_cache_filename(self, bucket: Bucket) -&gt; str:</span>
<span class="gi">+        return os.path.join(self.directory, self.pattern % (bucket.key,))</span>
<span class="gi">+</span>
<span class="gi">+    def load_bytecode(self, bucket: Bucket) -&gt; None:</span>
<span class="gi">+        filename = self._get_cache_filename(bucket)</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t test for existence before opening the file, since the</span>
<span class="gi">+        # file could disappear after the test before the open.</span>
<span class="gi">+        try:</span>
<span class="gi">+            f = open(filename, &quot;rb&quot;)</span>
<span class="gi">+        except (FileNotFoundError, IsADirectoryError, PermissionError):</span>
<span class="gi">+            # PermissionError can occur on Windows when an operation is</span>
<span class="gi">+            # in progress, such as calling clear().</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        with f:</span>
<span class="gi">+            bucket.load_bytecode(f)</span>
<span class="gi">+</span>
<span class="gi">+    def dump_bytecode(self, bucket: Bucket) -&gt; None:</span>
<span class="gi">+        # Write to a temporary file, then rename to the real name after</span>
<span class="gi">+        # writing. This avoids another process reading the file before</span>
<span class="gi">+        # it is fully written.</span>
<span class="gi">+        name = self._get_cache_filename(bucket)</span>
<span class="gi">+        f = tempfile.NamedTemporaryFile(</span>
<span class="gi">+            mode=&quot;wb&quot;,</span>
<span class="gi">+            dir=os.path.dirname(name),</span>
<span class="gi">+            prefix=os.path.basename(name),</span>
<span class="gi">+            suffix=&quot;.tmp&quot;,</span>
<span class="gi">+            delete=False,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def remove_silent() -&gt; None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                os.remove(f.name)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # Another process may have called clear(). On Windows,</span>
<span class="gi">+                # another program may be holding the file open.</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            with f:</span>
<span class="gi">+                bucket.write_bytecode(f)</span>
<span class="gi">+        except BaseException:</span>
<span class="gi">+            remove_silent()</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            os.replace(f.name, name)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            # Another process may have called clear(). On Windows,</span>
<span class="gi">+            # another program may be holding the file open.</span>
<span class="gi">+            remove_silent()</span>
<span class="gi">+        except BaseException:</span>
<span class="gi">+            remove_silent()</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="gi">+        # imported lazily here because google app-engine doesn&#39;t support</span>
<span class="gi">+        # write access on the file system and the function does not exist</span>
<span class="gi">+        # normally.</span>
<span class="gi">+        from os import remove</span>
<span class="gi">+</span>
<span class="gi">+        files = fnmatch.filter(os.listdir(self.directory), self.pattern % (&quot;*&quot;,))</span>
<span class="gi">+        for filename in files:</span>
<span class="gi">+            try:</span>
<span class="gi">+                remove(os.path.join(self.directory, filename))</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>

<span class="w"> </span>class MemcachedBytecodeCache(BytecodeCache):
<span class="w"> </span>    &quot;&quot;&quot;This class implements a bytecode cache that uses a memcache cache for
<span class="gu">@@ -208,10 +373,36 @@ class MemcachedBytecodeCache(BytecodeCache):</span>
<span class="w"> </span>       `ignore_memcache_errors` parameter.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, client: &#39;_MemcachedClient&#39;, prefix: str=</span>
<span class="gd">-        &#39;jinja2/bytecode/&#39;, timeout: t.Optional[int]=None,</span>
<span class="gd">-        ignore_memcache_errors: bool=True):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        client: &quot;_MemcachedClient&quot;,</span>
<span class="gi">+        prefix: str = &quot;jinja2/bytecode/&quot;,</span>
<span class="gi">+        timeout: t.Optional[int] = None,</span>
<span class="gi">+        ignore_memcache_errors: bool = True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.client = client
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        self.timeout = timeout
<span class="w"> </span>        self.ignore_memcache_errors = ignore_memcache_errors
<span class="gi">+</span>
<span class="gi">+    def load_bytecode(self, bucket: Bucket) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            code = self.client.get(self.prefix + bucket.key)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if not self.ignore_memcache_errors:</span>
<span class="gi">+                raise</span>
<span class="gi">+        else:</span>
<span class="gi">+            bucket.bytecode_from_string(code)</span>
<span class="gi">+</span>
<span class="gi">+    def dump_bytecode(self, bucket: Bucket) -&gt; None:</span>
<span class="gi">+        key = self.prefix + bucket.key</span>
<span class="gi">+        value = bucket.bytecode_to_string()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.timeout is not None:</span>
<span class="gi">+                self.client.set(key, value, self.timeout)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.client.set(key, value)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if not self.ignore_memcache_errors:</span>
<span class="gi">+                raise</span>
<span class="gh">diff --git a/src/jinja2/compiler.py b/src/jinja2/compiler.py</span>
<span class="gh">index 32df45a..2740717 100644</span>
<span class="gd">--- a/src/jinja2/compiler.py</span>
<span class="gi">+++ b/src/jinja2/compiler.py</span>
<span class="gu">@@ -1,12 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Compiles nodes from the parser into Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from functools import update_wrapper
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from keyword import iskeyword as is_python_keyword
<span class="gi">+</span>
<span class="w"> </span>from markupsafe import escape
<span class="w"> </span>from markupsafe import Markup
<span class="gi">+</span>
<span class="w"> </span>from . import nodes
<span class="w"> </span>from .exceptions import TemplateAssertionError
<span class="w"> </span>from .idtracking import Symbols
<span class="gu">@@ -19,37 +22,140 @@ from .optimizer import Optimizer</span>
<span class="w"> </span>from .utils import _PassArg
<span class="w"> </span>from .utils import concat
<span class="w"> </span>from .visitor import NodeVisitor
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gi">+</span>
<span class="w"> </span>    from .environment import Environment
<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>
<span class="gd">-operators = {&#39;eq&#39;: &#39;==&#39;, &#39;ne&#39;: &#39;!=&#39;, &#39;gt&#39;: &#39;&gt;&#39;, &#39;gteq&#39;: &#39;&gt;=&#39;, &#39;lt&#39;: &#39;&lt;&#39;,</span>
<span class="gd">-    &#39;lteq&#39;: &#39;&lt;=&#39;, &#39;in&#39;: &#39;in&#39;, &#39;notin&#39;: &#39;not in&#39;}</span>

<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+</span>
<span class="gi">+operators = {</span>
<span class="gi">+    &quot;eq&quot;: &quot;==&quot;,</span>
<span class="gi">+    &quot;ne&quot;: &quot;!=&quot;,</span>
<span class="gi">+    &quot;gt&quot;: &quot;&gt;&quot;,</span>
<span class="gi">+    &quot;gteq&quot;: &quot;&gt;=&quot;,</span>
<span class="gi">+    &quot;lt&quot;: &quot;&lt;&quot;,</span>
<span class="gi">+    &quot;lteq&quot;: &quot;&lt;=&quot;,</span>
<span class="gi">+    &quot;in&quot;: &quot;in&quot;,</span>
<span class="gi">+    &quot;notin&quot;: &quot;not in&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def optimizeconst(f: F) -&gt; F:</span>
<span class="gi">+    def new_func(</span>
<span class="gi">+        self: &quot;CodeGenerator&quot;, node: nodes.Expr, frame: &quot;Frame&quot;, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        # Only optimize if the frame is not volatile</span>
<span class="gi">+        if self.optimizer is not None and not frame.eval_ctx.volatile:</span>
<span class="gi">+            new_node = self.optimizer.visit(node, frame.eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+            if new_node != node:</span>
<span class="gi">+                return self.visit(new_node, frame)</span>
<span class="gi">+</span>
<span class="gi">+        return f(self, node, frame, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return update_wrapper(t.cast(F, new_func), f)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_binop(op: str) -&gt; t.Callable[[&quot;CodeGenerator&quot;, nodes.BinExpr, &quot;Frame&quot;], None]:</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visitor(self: &quot;CodeGenerator&quot;, node: nodes.BinExpr, frame: Frame) -&gt; None:</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.environment.sandboxed and op in self.environment.intercepted_binops  # type: ignore</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.write(f&quot;environment.call_binop(context, {op!r}, &quot;)</span>
<span class="gi">+            self.visit(node.left, frame)</span>
<span class="gi">+            self.write(&quot;, &quot;)</span>
<span class="gi">+            self.visit(node.right, frame)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&quot;(&quot;)</span>
<span class="gi">+            self.visit(node.left, frame)</span>
<span class="gi">+            self.write(f&quot; {op} &quot;)</span>
<span class="gi">+            self.visit(node.right, frame)</span>
<span class="gi">+</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return visitor</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_unop(</span>
<span class="gi">+    op: str,</span>
<span class="gi">+) -&gt; t.Callable[[&quot;CodeGenerator&quot;, nodes.UnaryExpr, &quot;Frame&quot;], None]:</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visitor(self: &quot;CodeGenerator&quot;, node: nodes.UnaryExpr, frame: Frame) -&gt; None:</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.environment.sandboxed and op in self.environment.intercepted_unops  # type: ignore</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.write(f&quot;environment.call_unop(context, {op!r}, &quot;)</span>
<span class="gi">+            self.visit(node.node, frame)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&quot;(&quot; + op)</span>
<span class="gi">+            self.visit(node.node, frame)</span>
<span class="gi">+</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return visitor</span>

<span class="gd">-def generate(node: nodes.Template, environment: &#39;Environment&#39;, name: t.</span>
<span class="gd">-    Optional[str], filename: t.Optional[str], stream: t.Optional[t.TextIO]=</span>
<span class="gd">-    None, defer_init: bool=False, optimized: bool=True) -&gt;t.Optional[str]:</span>
<span class="gi">+</span>
<span class="gi">+def generate(</span>
<span class="gi">+    node: nodes.Template,</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    name: t.Optional[str],</span>
<span class="gi">+    filename: t.Optional[str],</span>
<span class="gi">+    stream: t.Optional[t.TextIO] = None,</span>
<span class="gi">+    defer_init: bool = False,</span>
<span class="gi">+    optimized: bool = True,</span>
<span class="gi">+) -&gt; t.Optional[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate the python source for a node tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(node, nodes.Template):</span>
<span class="gi">+        raise TypeError(&quot;Can&#39;t compile non template nodes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    generator = environment.code_generator_class(</span>
<span class="gi">+        environment, name, filename, stream, defer_init, optimized</span>
<span class="gi">+    )</span>
<span class="gi">+    generator.visit(node)</span>
<span class="gi">+</span>
<span class="gi">+    if stream is None:</span>
<span class="gi">+        return generator.stream.getvalue()  # type: ignore</span>

<span class="gi">+    return None</span>

<span class="gd">-def has_safe_repr(value: t.Any) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def has_safe_repr(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Does the node have a safe representation?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None or value is NotImplemented or value is Ellipsis:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if type(value) in {bool, int, float, complex, range, str, Markup}:</span>
<span class="gi">+        return True</span>

<span class="gi">+    if type(value) in {tuple, list, set, frozenset}:</span>
<span class="gi">+        return all(has_safe_repr(v) for v in value)</span>

<span class="gd">-def find_undeclared(nodes: t.Iterable[nodes.Node], names: t.Iterable[str]</span>
<span class="gd">-    ) -&gt;t.Set[str]:</span>
<span class="gi">+    if type(value) is dict:  # noqa E721</span>
<span class="gi">+        return all(has_safe_repr(k) and has_safe_repr(v) for k, v in value.items())</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_undeclared(</span>
<span class="gi">+    nodes: t.Iterable[nodes.Node], names: t.Iterable[str]</span>
<span class="gi">+) -&gt; t.Set[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the names passed are accessed undeclared.  The return value
<span class="w"> </span>    is a set of all the undeclared names from the sequence of names found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    visitor = UndeclaredNameVisitor(names)</span>
<span class="gi">+    try:</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            visitor.visit(node)</span>
<span class="gi">+    except VisitorExit:</span>
<span class="gi">+        pass</span>
<span class="gi">+    return visitor.undeclared</span>


<span class="w"> </span>class MacroRef:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, node: t.Union[nodes.Macro, nodes.CallBlock]) -&gt;None:</span>
<span class="gi">+    def __init__(self, node: t.Union[nodes.Macro, nodes.CallBlock]) -&gt; None:</span>
<span class="w"> </span>        self.node = node
<span class="w"> </span>        self.accesses_caller = False
<span class="w"> </span>        self.accesses_kwargs = False
<span class="gu">@@ -59,35 +165,71 @@ class MacroRef:</span>
<span class="w"> </span>class Frame:
<span class="w"> </span>    &quot;&quot;&quot;Holds compile time information for us.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, eval_ctx: EvalContext, parent: t.Optional[&#39;Frame&#39;]=</span>
<span class="gd">-        None, level: t.Optional[int]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        eval_ctx: EvalContext,</span>
<span class="gi">+        parent: t.Optional[&quot;Frame&quot;] = None,</span>
<span class="gi">+        level: t.Optional[int] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.eval_ctx = eval_ctx
<span class="gi">+</span>
<span class="gi">+        # the parent of this frame</span>
<span class="w"> </span>        self.parent = parent
<span class="gi">+</span>
<span class="w"> </span>        if parent is None:
<span class="w"> </span>            self.symbols = Symbols(level=level)
<span class="gi">+</span>
<span class="gi">+            # in some dynamic inheritance situations the compiler needs to add</span>
<span class="gi">+            # write tests around output statements.</span>
<span class="w"> </span>            self.require_output_check = False
<span class="gi">+</span>
<span class="gi">+            # inside some tags we are using a buffer rather than yield statements.</span>
<span class="gi">+            # this for example affects {% filter %} or {% macro %}.  If a frame</span>
<span class="gi">+            # is buffered this variable points to the name of the list used as</span>
<span class="gi">+            # buffer.</span>
<span class="w"> </span>            self.buffer: t.Optional[str] = None
<span class="gi">+</span>
<span class="gi">+            # the name of the block we&#39;re in, otherwise None.</span>
<span class="w"> </span>            self.block: t.Optional[str] = None
<span class="gi">+</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.symbols = Symbols(parent.symbols, level=level)
<span class="w"> </span>            self.require_output_check = parent.require_output_check
<span class="w"> </span>            self.buffer = parent.buffer
<span class="w"> </span>            self.block = parent.block
<span class="gi">+</span>
<span class="gi">+        # a toplevel frame is the root + soft frames such as if conditions.</span>
<span class="w"> </span>        self.toplevel = False
<span class="gi">+</span>
<span class="gi">+        # the root frame is basically just the outermost frame, so no if</span>
<span class="gi">+        # conditions.  This information is used to optimize inheritance</span>
<span class="gi">+        # situations.</span>
<span class="w"> </span>        self.rootlevel = False
<span class="gi">+</span>
<span class="gi">+        # variables set inside of loops and blocks should not affect outer frames,</span>
<span class="gi">+        # but they still needs to be kept track of as part of the active context.</span>
<span class="w"> </span>        self.loop_frame = False
<span class="w"> </span>        self.block_frame = False
<span class="gi">+</span>
<span class="gi">+        # track whether the frame is being used in an if-statement or conditional</span>
<span class="gi">+        # expression as it determines which errors should be raised during runtime</span>
<span class="gi">+        # or compile time.</span>
<span class="w"> </span>        self.soft_frame = False

<span class="gd">-    def copy(self) -&gt;&#39;Frame&#39;:</span>
<span class="gi">+    def copy(self) -&gt; &quot;Frame&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a copy of the current one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = object.__new__(self.__class__)</span>
<span class="gi">+        rv.__dict__.update(self.__dict__)</span>
<span class="gi">+        rv.symbols = self.symbols.copy()</span>
<span class="gi">+        return rv</span>

<span class="gd">-    def inner(self, isolated: bool=False) -&gt;&#39;Frame&#39;:</span>
<span class="gi">+    def inner(self, isolated: bool = False) -&gt; &quot;Frame&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an inner frame.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isolated:</span>
<span class="gi">+            return Frame(self.eval_ctx, level=self.symbols.level + 1)</span>
<span class="gi">+        return Frame(self.eval_ctx, self)</span>

<span class="gd">-    def soft(self) -&gt;&#39;Frame&#39;:</span>
<span class="gi">+    def soft(self) -&gt; &quot;Frame&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a soft frame.  A soft frame may not be modified as
<span class="w"> </span>        standalone thing as it shares the resources with the frame it
<span class="w"> </span>        was created of, but it&#39;s not a rootlevel frame any longer.
<span class="gu">@@ -95,7 +237,11 @@ class Frame:</span>
<span class="w"> </span>        This is only used to implement if-statements and conditional
<span class="w"> </span>        expressions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = self.copy()</span>
<span class="gi">+        rv.rootlevel = False</span>
<span class="gi">+        rv.soft_frame = True</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="w"> </span>    __copy__ = copy


<span class="gu">@@ -106,13 +252,20 @@ class VisitorExit(RuntimeError):</span>
<span class="w"> </span>class DependencyFinderVisitor(NodeVisitor):
<span class="w"> </span>    &quot;&quot;&quot;A visitor that collects filter and test calls.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.filters: t.Set[str] = set()
<span class="w"> </span>        self.tests: t.Set[str] = set()

<span class="gd">-    def visit_Block(self, node: nodes.Block) -&gt;None:</span>
<span class="gi">+    def visit_Filter(self, node: nodes.Filter) -&gt; None:</span>
<span class="gi">+        self.generic_visit(node)</span>
<span class="gi">+        self.filters.add(node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Test(self, node: nodes.Test) -&gt; None:</span>
<span class="gi">+        self.generic_visit(node)</span>
<span class="gi">+        self.tests.add(node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Block(self, node: nodes.Block) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class UndeclaredNameVisitor(NodeVisitor):
<span class="gu">@@ -121,13 +274,20 @@ class UndeclaredNameVisitor(NodeVisitor):</span>
<span class="w"> </span>    not stop at closure frames.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, names: t.Iterable[str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, names: t.Iterable[str]) -&gt; None:</span>
<span class="w"> </span>        self.names = set(names)
<span class="w"> </span>        self.undeclared: t.Set[str] = set()

<span class="gd">-    def visit_Block(self, node: nodes.Block) -&gt;None:</span>
<span class="gi">+    def visit_Name(self, node: nodes.Name) -&gt; None:</span>
<span class="gi">+        if node.ctx == &quot;load&quot; and node.name in self.names:</span>
<span class="gi">+            self.undeclared.add(node.name)</span>
<span class="gi">+            if self.undeclared == self.names:</span>
<span class="gi">+                raise VisitorExit()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.names.discard(node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Block(self, node: nodes.Block) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting a blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class CompilerExit(Exception):
<span class="gu">@@ -138,10 +298,15 @@ class CompilerExit(Exception):</span>


<span class="w"> </span>class CodeGenerator(NodeVisitor):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, environment: &#39;Environment&#39;, name: t.Optional[str],</span>
<span class="gd">-        filename: t.Optional[str], stream: t.Optional[t.TextIO]=None,</span>
<span class="gd">-        defer_init: bool=False, optimized: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        environment: &quot;Environment&quot;,</span>
<span class="gi">+        name: t.Optional[str],</span>
<span class="gi">+        filename: t.Optional[str],</span>
<span class="gi">+        stream: t.Optional[t.TextIO] = None,</span>
<span class="gi">+        defer_init: bool = False,</span>
<span class="gi">+        optimized: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if stream is None:
<span class="w"> </span>            stream = StringIO()
<span class="w"> </span>        self.environment = environment
<span class="gu">@@ -151,96 +316,226 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>        self.created_block_context = False
<span class="w"> </span>        self.defer_init = defer_init
<span class="w"> </span>        self.optimizer: t.Optional[Optimizer] = None
<span class="gi">+</span>
<span class="w"> </span>        if optimized:
<span class="w"> </span>            self.optimizer = Optimizer(environment)
<span class="gi">+</span>
<span class="gi">+        # aliases for imports</span>
<span class="w"> </span>        self.import_aliases: t.Dict[str, str] = {}
<span class="gi">+</span>
<span class="gi">+        # a registry for all blocks.  Because blocks are moved out</span>
<span class="gi">+        # into the global python scope they are registered here</span>
<span class="w"> </span>        self.blocks: t.Dict[str, nodes.Block] = {}
<span class="gi">+</span>
<span class="gi">+        # the number of extends statements so far</span>
<span class="w"> </span>        self.extends_so_far = 0
<span class="gi">+</span>
<span class="gi">+        # some templates have a rootlevel extends.  In this case we</span>
<span class="gi">+        # can safely assume that we&#39;re a child template and do some</span>
<span class="gi">+        # more optimizations.</span>
<span class="w"> </span>        self.has_known_extends = False
<span class="gi">+</span>
<span class="gi">+        # the current line number</span>
<span class="w"> </span>        self.code_lineno = 1
<span class="gi">+</span>
<span class="gi">+        # registry of all filters and tests (global, not block local)</span>
<span class="w"> </span>        self.tests: t.Dict[str, str] = {}
<span class="w"> </span>        self.filters: t.Dict[str, str] = {}
<span class="gi">+</span>
<span class="gi">+        # the debug information</span>
<span class="w"> </span>        self.debug_info: t.List[t.Tuple[int, int]] = []
<span class="w"> </span>        self._write_debug_info: t.Optional[int] = None
<span class="gi">+</span>
<span class="gi">+        # the number of new lines before the next write()</span>
<span class="w"> </span>        self._new_lines = 0
<span class="gi">+</span>
<span class="gi">+        # the line number of the last written statement</span>
<span class="w"> </span>        self._last_line = 0
<span class="gi">+</span>
<span class="gi">+        # true if nothing was written so far.</span>
<span class="w"> </span>        self._first_write = True
<span class="gi">+</span>
<span class="gi">+        # used by the `temporary_identifier` method to get new</span>
<span class="gi">+        # unique, temporary identifier</span>
<span class="w"> </span>        self._last_identifier = 0
<span class="gi">+</span>
<span class="gi">+        # the current indentation</span>
<span class="w"> </span>        self._indentation = 0
<span class="gi">+</span>
<span class="gi">+        # Tracks toplevel assignments</span>
<span class="w"> </span>        self._assign_stack: t.List[t.Set[str]] = []
<span class="gi">+</span>
<span class="gi">+        # Tracks parameter definition blocks</span>
<span class="w"> </span>        self._param_def_block: t.List[t.Set[str]] = []
<span class="gd">-        self._context_reference_stack = [&#39;context&#39;]</span>

<span class="gd">-    def fail(self, msg: str, lineno: int) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+        # Tracks the current context.</span>
<span class="gi">+        self._context_reference_stack = [&quot;context&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def optimized(self) -&gt; bool:</span>
<span class="gi">+        return self.optimizer is not None</span>
<span class="gi">+</span>
<span class="gi">+    # -- Various compilation helpers</span>
<span class="gi">+</span>
<span class="gi">+    def fail(self, msg: str, lineno: int) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fail with a :exc:`TemplateAssertionError`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise TemplateAssertionError(msg, lineno, self.name, self.filename)</span>

<span class="gd">-    def temporary_identifier(self) -&gt;str:</span>
<span class="gi">+    def temporary_identifier(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a new unique identifier.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._last_identifier += 1</span>
<span class="gi">+        return f&quot;t_{self._last_identifier}&quot;</span>

<span class="gd">-    def buffer(self, frame: Frame) -&gt;None:</span>
<span class="gi">+    def buffer(self, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Enable buffering for the frame from that point onwards.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        frame.buffer = self.temporary_identifier()</span>
<span class="gi">+        self.writeline(f&quot;{frame.buffer} = []&quot;)</span>

<span class="gd">-    def return_buffer_contents(self, frame: Frame, force_unescaped: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def return_buffer_contents(</span>
<span class="gi">+        self, frame: Frame, force_unescaped: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the buffer contents of the frame.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def indent(self) -&gt;None:</span>
<span class="gi">+        if not force_unescaped:</span>
<span class="gi">+            if frame.eval_ctx.volatile:</span>
<span class="gi">+                self.writeline(&quot;if context.eval_ctx.autoescape:&quot;)</span>
<span class="gi">+                self.indent()</span>
<span class="gi">+                self.writeline(f&quot;return Markup(concat({frame.buffer}))&quot;)</span>
<span class="gi">+                self.outdent()</span>
<span class="gi">+                self.writeline(&quot;else:&quot;)</span>
<span class="gi">+                self.indent()</span>
<span class="gi">+                self.writeline(f&quot;return concat({frame.buffer})&quot;)</span>
<span class="gi">+                self.outdent()</span>
<span class="gi">+                return</span>
<span class="gi">+            elif frame.eval_ctx.autoescape:</span>
<span class="gi">+                self.writeline(f&quot;return Markup(concat({frame.buffer}))&quot;)</span>
<span class="gi">+                return</span>
<span class="gi">+        self.writeline(f&quot;return concat({frame.buffer})&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def indent(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Indent by one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._indentation += 1</span>

<span class="gd">-    def outdent(self, step: int=1) -&gt;None:</span>
<span class="gi">+    def outdent(self, step: int = 1) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Outdent by step.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._indentation -= step</span>

<span class="gd">-    def start_write(self, frame: Frame, node: t.Optional[nodes.Node]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def start_write(self, frame: Frame, node: t.Optional[nodes.Node] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Yield or write into the frame buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if frame.buffer is None:</span>
<span class="gi">+            self.writeline(&quot;yield &quot;, node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.writeline(f&quot;{frame.buffer}.append(&quot;, node)</span>

<span class="gd">-    def end_write(self, frame: Frame) -&gt;None:</span>
<span class="gi">+    def end_write(self, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;End the writing process started by `start_write`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if frame.buffer is not None:</span>
<span class="gi">+            self.write(&quot;)&quot;)</span>

<span class="gd">-    def simple_write(self, s: str, frame: Frame, node: t.Optional[nodes.</span>
<span class="gd">-        Node]=None) -&gt;None:</span>
<span class="gi">+    def simple_write(</span>
<span class="gi">+        self, s: str, frame: Frame, node: t.Optional[nodes.Node] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Simple shortcut for start_write + write + end_write.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.start_write(frame, node)</span>
<span class="gi">+        self.write(s)</span>
<span class="gi">+        self.end_write(frame)</span>

<span class="gd">-    def blockvisit(self, nodes: t.Iterable[nodes.Node], frame: Frame) -&gt;None:</span>
<span class="gi">+    def blockvisit(self, nodes: t.Iterable[nodes.Node], frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit a list of nodes as block in a frame.  If the current frame
<span class="w"> </span>        is no buffer a dummy ``if 0: yield None`` is written automatically.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def write(self, x: str) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.writeline(&quot;pass&quot;)</span>
<span class="gi">+            for node in nodes:</span>
<span class="gi">+                self.visit(node, frame)</span>
<span class="gi">+        except CompilerExit:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, x: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a string into the output stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def writeline(self, x: str, node: t.Optional[nodes.Node]=None, extra: int=0</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        if self._new_lines:</span>
<span class="gi">+            if not self._first_write:</span>
<span class="gi">+                self.stream.write(&quot;\n&quot; * self._new_lines)</span>
<span class="gi">+                self.code_lineno += self._new_lines</span>
<span class="gi">+                if self._write_debug_info is not None:</span>
<span class="gi">+                    self.debug_info.append((self._write_debug_info, self.code_lineno))</span>
<span class="gi">+                    self._write_debug_info = None</span>
<span class="gi">+            self._first_write = False</span>
<span class="gi">+            self.stream.write(&quot;    &quot; * self._indentation)</span>
<span class="gi">+            self._new_lines = 0</span>
<span class="gi">+        self.stream.write(x)</span>
<span class="gi">+</span>
<span class="gi">+    def writeline(</span>
<span class="gi">+        self, x: str, node: t.Optional[nodes.Node] = None, extra: int = 0</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Combination of newline and write.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.newline(node, extra)</span>
<span class="gi">+        self.write(x)</span>

<span class="gd">-    def newline(self, node: t.Optional[nodes.Node]=None, extra: int=0) -&gt;None:</span>
<span class="gi">+    def newline(self, node: t.Optional[nodes.Node] = None, extra: int = 0) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add one or more newlines before the next write.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def signature(self, node: t.Union[nodes.Call, nodes.Filter, nodes.Test],</span>
<span class="gd">-        frame: Frame, extra_kwargs: t.Optional[t.Mapping[str, t.Any]]=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        self._new_lines = max(self._new_lines, 1 + extra)</span>
<span class="gi">+        if node is not None and node.lineno != self._last_line:</span>
<span class="gi">+            self._write_debug_info = node.lineno</span>
<span class="gi">+            self._last_line = node.lineno</span>
<span class="gi">+</span>
<span class="gi">+    def signature(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: t.Union[nodes.Call, nodes.Filter, nodes.Test],</span>
<span class="gi">+        frame: Frame,</span>
<span class="gi">+        extra_kwargs: t.Optional[t.Mapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes a function call to the stream for the current node.
<span class="w"> </span>        A leading comma is added automatically.  The extra keyword
<span class="w"> </span>        arguments may not include python keywords otherwise a syntax
<span class="w"> </span>        error could occur.  The extra keyword arguments should be given
<span class="w"> </span>        as python dict.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def pull_dependencies(self, nodes: t.Iterable[nodes.Node]) -&gt;None:</span>
<span class="gi">+        # if any of the given keyword arguments is a python keyword</span>
<span class="gi">+        # we have to make sure that no invalid call is created.</span>
<span class="gi">+        kwarg_workaround = any(</span>
<span class="gi">+            is_python_keyword(t.cast(str, k))</span>
<span class="gi">+            for k in chain((x.key for x in node.kwargs), extra_kwargs or ())</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        for arg in node.args:</span>
<span class="gi">+            self.write(&quot;, &quot;)</span>
<span class="gi">+            self.visit(arg, frame)</span>
<span class="gi">+</span>
<span class="gi">+        if not kwarg_workaround:</span>
<span class="gi">+            for kwarg in node.kwargs:</span>
<span class="gi">+                self.write(&quot;, &quot;)</span>
<span class="gi">+                self.visit(kwarg, frame)</span>
<span class="gi">+            if extra_kwargs is not None:</span>
<span class="gi">+                for key, value in extra_kwargs.items():</span>
<span class="gi">+                    self.write(f&quot;, {key}={value}&quot;)</span>
<span class="gi">+        if node.dyn_args:</span>
<span class="gi">+            self.write(&quot;, *&quot;)</span>
<span class="gi">+            self.visit(node.dyn_args, frame)</span>
<span class="gi">+</span>
<span class="gi">+        if kwarg_workaround:</span>
<span class="gi">+            if node.dyn_kwargs is not None:</span>
<span class="gi">+                self.write(&quot;, **dict({&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.write(&quot;, **{&quot;)</span>
<span class="gi">+            for kwarg in node.kwargs:</span>
<span class="gi">+                self.write(f&quot;{kwarg.key!r}: &quot;)</span>
<span class="gi">+                self.visit(kwarg.value, frame)</span>
<span class="gi">+                self.write(&quot;, &quot;)</span>
<span class="gi">+            if extra_kwargs is not None:</span>
<span class="gi">+                for key, value in extra_kwargs.items():</span>
<span class="gi">+                    self.write(f&quot;{key!r}: {value}, &quot;)</span>
<span class="gi">+            if node.dyn_kwargs is not None:</span>
<span class="gi">+                self.write(&quot;}, **&quot;)</span>
<span class="gi">+                self.visit(node.dyn_kwargs, frame)</span>
<span class="gi">+                self.write(&quot;)&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.write(&quot;}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        elif node.dyn_kwargs is not None:</span>
<span class="gi">+            self.write(&quot;, **&quot;)</span>
<span class="gi">+            self.visit(node.dyn_kwargs, frame)</span>
<span class="gi">+</span>
<span class="gi">+    def pull_dependencies(self, nodes: t.Iterable[nodes.Node]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find all filter and test names used in the template and
<span class="w"> </span>        assign them to variables in the compiled namespace. Checking
<span class="w"> </span>        that the names are registered with the environment is done when
<span class="gu">@@ -251,96 +546,837 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>            Filters and tests in If and CondExpr nodes are checked at
<span class="w"> </span>            runtime instead of compile time.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def macro_body(self, node: t.Union[nodes.Macro, nodes.CallBlock], frame:</span>
<span class="gd">-        Frame) -&gt;t.Tuple[Frame, MacroRef]:</span>
<span class="gi">+        visitor = DependencyFinderVisitor()</span>
<span class="gi">+</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            visitor.visit(node)</span>
<span class="gi">+</span>
<span class="gi">+        for id_map, names, dependency in (</span>
<span class="gi">+            (self.filters, visitor.filters, &quot;filters&quot;),</span>
<span class="gi">+            (</span>
<span class="gi">+                self.tests,</span>
<span class="gi">+                visitor.tests,</span>
<span class="gi">+                &quot;tests&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+        ):</span>
<span class="gi">+            for name in sorted(names):</span>
<span class="gi">+                if name not in id_map:</span>
<span class="gi">+                    id_map[name] = self.temporary_identifier()</span>
<span class="gi">+</span>
<span class="gi">+                # add check during runtime that dependencies used inside of executed</span>
<span class="gi">+                # blocks are defined, as this step may be skipped during compile time</span>
<span class="gi">+                self.writeline(&quot;try:&quot;)</span>
<span class="gi">+                self.indent()</span>
<span class="gi">+                self.writeline(f&quot;{id_map[name]} = environment.{dependency}[{name!r}]&quot;)</span>
<span class="gi">+                self.outdent()</span>
<span class="gi">+                self.writeline(&quot;except KeyError:&quot;)</span>
<span class="gi">+                self.indent()</span>
<span class="gi">+                self.writeline(&quot;@internalcode&quot;)</span>
<span class="gi">+                self.writeline(f&quot;def {id_map[name]}(*unused):&quot;)</span>
<span class="gi">+                self.indent()</span>
<span class="gi">+                self.writeline(</span>
<span class="gi">+                    f&#39;raise TemplateRuntimeError(&quot;No {dependency[:-1]}&#39;</span>
<span class="gi">+                    f&#39; named {name!r} found.&quot;)&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+                self.outdent()</span>
<span class="gi">+                self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+    def enter_frame(self, frame: Frame) -&gt; None:</span>
<span class="gi">+        undefs = []</span>
<span class="gi">+        for target, (action, param) in frame.symbols.loads.items():</span>
<span class="gi">+            if action == VAR_LOAD_PARAMETER:</span>
<span class="gi">+                pass</span>
<span class="gi">+            elif action == VAR_LOAD_RESOLVE:</span>
<span class="gi">+                self.writeline(f&quot;{target} = {self.get_resolve_func()}({param!r})&quot;)</span>
<span class="gi">+            elif action == VAR_LOAD_ALIAS:</span>
<span class="gi">+                self.writeline(f&quot;{target} = {param}&quot;)</span>
<span class="gi">+            elif action == VAR_LOAD_UNDEFINED:</span>
<span class="gi">+                undefs.append(target)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise NotImplementedError(&quot;unknown load instruction&quot;)</span>
<span class="gi">+        if undefs:</span>
<span class="gi">+            self.writeline(f&quot;{&#39; = &#39;.join(undefs)} = missing&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def leave_frame(self, frame: Frame, with_python_scope: bool = False) -&gt; None:</span>
<span class="gi">+        if not with_python_scope:</span>
<span class="gi">+            undefs = []</span>
<span class="gi">+            for target in frame.symbols.loads:</span>
<span class="gi">+                undefs.append(target)</span>
<span class="gi">+            if undefs:</span>
<span class="gi">+                self.writeline(f&quot;{&#39; = &#39;.join(undefs)} = missing&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def choose_async(self, async_value: str = &quot;async &quot;, sync_value: str = &quot;&quot;) -&gt; str:</span>
<span class="gi">+        return async_value if self.environment.is_async else sync_value</span>
<span class="gi">+</span>
<span class="gi">+    def func(self, name: str) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.choose_async()}def {name}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def macro_body(</span>
<span class="gi">+        self, node: t.Union[nodes.Macro, nodes.CallBlock], frame: Frame</span>
<span class="gi">+    ) -&gt; t.Tuple[Frame, MacroRef]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Dump the function def of a macro or call block.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def macro_def(self, macro_ref: MacroRef, frame: Frame) -&gt;None:</span>
<span class="gi">+        frame = frame.inner()</span>
<span class="gi">+        frame.symbols.analyze_node(node)</span>
<span class="gi">+        macro_ref = MacroRef(node)</span>
<span class="gi">+</span>
<span class="gi">+        explicit_caller = None</span>
<span class="gi">+        skip_special_params = set()</span>
<span class="gi">+        args = []</span>
<span class="gi">+</span>
<span class="gi">+        for idx, arg in enumerate(node.args):</span>
<span class="gi">+            if arg.name == &quot;caller&quot;:</span>
<span class="gi">+                explicit_caller = idx</span>
<span class="gi">+            if arg.name in (&quot;kwargs&quot;, &quot;varargs&quot;):</span>
<span class="gi">+                skip_special_params.add(arg.name)</span>
<span class="gi">+            args.append(frame.symbols.ref(arg.name))</span>
<span class="gi">+</span>
<span class="gi">+        undeclared = find_undeclared(node.body, (&quot;caller&quot;, &quot;kwargs&quot;, &quot;varargs&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;caller&quot; in undeclared:</span>
<span class="gi">+            # In older Jinja versions there was a bug that allowed caller</span>
<span class="gi">+            # to retain the special behavior even if it was mentioned in</span>
<span class="gi">+            # the argument list.  However thankfully this was only really</span>
<span class="gi">+            # working if it was the last argument.  So we are explicitly</span>
<span class="gi">+            # checking this now and error out if it is anywhere else in</span>
<span class="gi">+            # the argument list.</span>
<span class="gi">+            if explicit_caller is not None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    node.defaults[explicit_caller - len(node.args)]</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    self.fail(</span>
<span class="gi">+                        &quot;When defining macros or call blocks the &quot;</span>
<span class="gi">+                        &#39;special &quot;caller&quot; argument must be omitted &#39;</span>
<span class="gi">+                        &quot;or be given a default.&quot;,</span>
<span class="gi">+                        node.lineno,</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                args.append(frame.symbols.declare_parameter(&quot;caller&quot;))</span>
<span class="gi">+            macro_ref.accesses_caller = True</span>
<span class="gi">+        if &quot;kwargs&quot; in undeclared and &quot;kwargs&quot; not in skip_special_params:</span>
<span class="gi">+            args.append(frame.symbols.declare_parameter(&quot;kwargs&quot;))</span>
<span class="gi">+            macro_ref.accesses_kwargs = True</span>
<span class="gi">+        if &quot;varargs&quot; in undeclared and &quot;varargs&quot; not in skip_special_params:</span>
<span class="gi">+            args.append(frame.symbols.declare_parameter(&quot;varargs&quot;))</span>
<span class="gi">+            macro_ref.accesses_varargs = True</span>
<span class="gi">+</span>
<span class="gi">+        # macros are delayed, they never require output checks</span>
<span class="gi">+        frame.require_output_check = False</span>
<span class="gi">+        frame.symbols.analyze_node(node)</span>
<span class="gi">+        self.writeline(f&quot;{self.func(&#39;macro&#39;)}({&#39;, &#39;.join(args)}):&quot;, node)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+</span>
<span class="gi">+        self.buffer(frame)</span>
<span class="gi">+        self.enter_frame(frame)</span>
<span class="gi">+</span>
<span class="gi">+        self.push_parameter_definitions(frame)</span>
<span class="gi">+        for idx, arg in enumerate(node.args):</span>
<span class="gi">+            ref = frame.symbols.ref(arg.name)</span>
<span class="gi">+            self.writeline(f&quot;if {ref} is missing:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            try:</span>
<span class="gi">+                default = node.defaults[idx - len(node.args)]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                self.writeline(</span>
<span class="gi">+                    f&#39;{ref} = undefined(&quot;parameter {arg.name!r} was not provided&quot;,&#39;</span>
<span class="gi">+                    f&quot; name={arg.name!r})&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.writeline(f&quot;{ref} = &quot;)</span>
<span class="gi">+                self.visit(default, frame)</span>
<span class="gi">+            self.mark_parameter_stored(ref)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+        self.pop_parameter_definitions()</span>
<span class="gi">+</span>
<span class="gi">+        self.blockvisit(node.body, frame)</span>
<span class="gi">+        self.return_buffer_contents(frame, force_unescaped=True)</span>
<span class="gi">+        self.leave_frame(frame, with_python_scope=True)</span>
<span class="gi">+        self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+        return frame, macro_ref</span>
<span class="gi">+</span>
<span class="gi">+    def macro_def(self, macro_ref: MacroRef, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Dump the macro definition for the def created by macro_body.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def position(self, node: nodes.Node) -&gt;str:</span>
<span class="gi">+        arg_tuple = &quot;, &quot;.join(repr(x.name) for x in macro_ref.node.args)</span>
<span class="gi">+        name = getattr(macro_ref.node, &quot;name&quot;, None)</span>
<span class="gi">+        if len(macro_ref.node.args) == 1:</span>
<span class="gi">+            arg_tuple += &quot;,&quot;</span>
<span class="gi">+        self.write(</span>
<span class="gi">+            f&quot;Macro(environment, macro, {name!r}, ({arg_tuple}),&quot;</span>
<span class="gi">+            f&quot; {macro_ref.accesses_kwargs!r}, {macro_ref.accesses_varargs!r},&quot;</span>
<span class="gi">+            f&quot; {macro_ref.accesses_caller!r}, context.eval_ctx.autoescape)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def position(self, node: nodes.Node) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a human readable position for the node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def write_commons(self) -&gt;None:</span>
<span class="gi">+        rv = f&quot;line {node.lineno}&quot;</span>
<span class="gi">+        if self.name is not None:</span>
<span class="gi">+            rv = f&quot;{rv} in {self.name!r}&quot;</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def dump_local_context(self, frame: Frame) -&gt; str:</span>
<span class="gi">+        items_kv = &quot;, &quot;.join(</span>
<span class="gi">+            f&quot;{name!r}: {target}&quot;</span>
<span class="gi">+            for name, target in frame.symbols.dump_stores().items()</span>
<span class="gi">+        )</span>
<span class="gi">+        return f&quot;{{{items_kv}}}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def write_commons(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Writes a common preamble that is used by root and block functions.
<span class="w"> </span>        Primarily this sets up common local helpers and enforces a generator
<span class="w"> </span>        through a dead branch.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def push_parameter_definitions(self, frame: Frame) -&gt;None:</span>
<span class="gi">+        self.writeline(&quot;resolve = context.resolve_or_missing&quot;)</span>
<span class="gi">+        self.writeline(&quot;undefined = environment.undefined&quot;)</span>
<span class="gi">+        self.writeline(&quot;concat = environment.concat&quot;)</span>
<span class="gi">+        # always use the standard Undefined class for the implicit else of</span>
<span class="gi">+        # conditional expressions</span>
<span class="gi">+        self.writeline(&quot;cond_expr_undefined = Undefined&quot;)</span>
<span class="gi">+        self.writeline(&quot;if 0: yield None&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def push_parameter_definitions(self, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Pushes all parameter targets from the given frame into a local
<span class="w"> </span>        stack that permits tracking of yet to be assigned parameters.  In
<span class="w"> </span>        particular this enables the optimization from `visit_Name` to skip
<span class="w"> </span>        undefined expressions for parameters in macros as macros can reference
<span class="w"> </span>        otherwise unbound parameters.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._param_def_block.append(frame.symbols.dump_param_targets())</span>

<span class="gd">-    def pop_parameter_definitions(self) -&gt;None:</span>
<span class="gi">+    def pop_parameter_definitions(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Pops the current parameter definitions set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._param_def_block.pop()</span>

<span class="gd">-    def mark_parameter_stored(self, target: str) -&gt;None:</span>
<span class="gi">+    def mark_parameter_stored(self, target: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Marks a parameter in the current parameter definitions as stored.
<span class="w"> </span>        This will skip the enforced undefined checks.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._param_def_block:</span>
<span class="gi">+            self._param_def_block[-1].discard(target)</span>
<span class="gi">+</span>
<span class="gi">+    def push_context_reference(self, target: str) -&gt; None:</span>
<span class="gi">+        self._context_reference_stack.append(target)</span>
<span class="gi">+</span>
<span class="gi">+    def pop_context_reference(self) -&gt; None:</span>
<span class="gi">+        self._context_reference_stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def get_context_ref(self) -&gt; str:</span>
<span class="gi">+        return self._context_reference_stack[-1]</span>
<span class="gi">+</span>
<span class="gi">+    def get_resolve_func(self) -&gt; str:</span>
<span class="gi">+        target = self._context_reference_stack[-1]</span>
<span class="gi">+        if target == &quot;context&quot;:</span>
<span class="gi">+            return &quot;resolve&quot;</span>
<span class="gi">+        return f&quot;{target}.resolve&quot;</span>

<span class="gd">-    def parameter_is_undeclared(self, target: str) -&gt;bool:</span>
<span class="gi">+    def derive_context(self, frame: Frame) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.get_context_ref()}.derived({self.dump_local_context(frame)})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def parameter_is_undeclared(self, target: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks if a given target is an undeclared parameter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._param_def_block:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return target in self._param_def_block[-1]</span>

<span class="gd">-    def push_assign_tracking(self) -&gt;None:</span>
<span class="gi">+    def push_assign_tracking(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Pushes a new layer for assignment tracking.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._assign_stack.append(set())</span>

<span class="gd">-    def pop_assign_tracking(self, frame: Frame) -&gt;None:</span>
<span class="gi">+    def pop_assign_tracking(self, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Pops the topmost level for assignment tracking and updates the
<span class="w"> </span>        context variables if necessary.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_Block(self, node: nodes.Block, frame: Frame) -&gt;None:</span>
<span class="gi">+        vars = self._assign_stack.pop()</span>
<span class="gi">+        if (</span>
<span class="gi">+            not frame.block_frame</span>
<span class="gi">+            and not frame.loop_frame</span>
<span class="gi">+            and not frame.toplevel</span>
<span class="gi">+            or not vars</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        public_names = [x for x in vars if x[:1] != &quot;_&quot;]</span>
<span class="gi">+        if len(vars) == 1:</span>
<span class="gi">+            name = next(iter(vars))</span>
<span class="gi">+            ref = frame.symbols.ref(name)</span>
<span class="gi">+            if frame.loop_frame:</span>
<span class="gi">+                self.writeline(f&quot;_loop_vars[{name!r}] = {ref}&quot;)</span>
<span class="gi">+                return</span>
<span class="gi">+            if frame.block_frame:</span>
<span class="gi">+                self.writeline(f&quot;_block_vars[{name!r}] = {ref}&quot;)</span>
<span class="gi">+                return</span>
<span class="gi">+            self.writeline(f&quot;context.vars[{name!r}] = {ref}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if frame.loop_frame:</span>
<span class="gi">+                self.writeline(&quot;_loop_vars.update({&quot;)</span>
<span class="gi">+            elif frame.block_frame:</span>
<span class="gi">+                self.writeline(&quot;_block_vars.update({&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.writeline(&quot;context.vars.update({&quot;)</span>
<span class="gi">+            for idx, name in enumerate(vars):</span>
<span class="gi">+                if idx:</span>
<span class="gi">+                    self.write(&quot;, &quot;)</span>
<span class="gi">+                ref = frame.symbols.ref(name)</span>
<span class="gi">+                self.write(f&quot;{name!r}: {ref}&quot;)</span>
<span class="gi">+            self.write(&quot;})&quot;)</span>
<span class="gi">+        if not frame.block_frame and not frame.loop_frame and public_names:</span>
<span class="gi">+            if len(public_names) == 1:</span>
<span class="gi">+                self.writeline(f&quot;context.exported_vars.add({public_names[0]!r})&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                names_str = &quot;, &quot;.join(map(repr, public_names))</span>
<span class="gi">+                self.writeline(f&quot;context.exported_vars.update(({names_str}))&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # -- Statement Visitors</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Template(</span>
<span class="gi">+        self, node: nodes.Template, frame: t.Optional[Frame] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert frame is None, &quot;no root frame allowed&quot;</span>
<span class="gi">+        eval_ctx = EvalContext(self.environment, self.name)</span>
<span class="gi">+</span>
<span class="gi">+        from .runtime import async_exported</span>
<span class="gi">+        from .runtime import exported</span>
<span class="gi">+</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            exported_names = sorted(exported + async_exported)</span>
<span class="gi">+        else:</span>
<span class="gi">+            exported_names = sorted(exported)</span>
<span class="gi">+</span>
<span class="gi">+        self.writeline(&quot;from jinja2.runtime import &quot; + &quot;, &quot;.join(exported_names))</span>
<span class="gi">+</span>
<span class="gi">+        # if we want a deferred initialization we cannot move the</span>
<span class="gi">+        # environment into a local name</span>
<span class="gi">+        envenv = &quot;&quot; if self.defer_init else &quot;, environment=environment&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # do we have an extends tag at all?  If not, we can save some</span>
<span class="gi">+        # overhead by just not processing any inheritance code.</span>
<span class="gi">+        have_extends = node.find(nodes.Extends) is not None</span>
<span class="gi">+</span>
<span class="gi">+        # find all blocks</span>
<span class="gi">+        for block in node.find_all(nodes.Block):</span>
<span class="gi">+            if block.name in self.blocks:</span>
<span class="gi">+                self.fail(f&quot;block {block.name!r} defined twice&quot;, block.lineno)</span>
<span class="gi">+            self.blocks[block.name] = block</span>
<span class="gi">+</span>
<span class="gi">+        # find all imports and import them</span>
<span class="gi">+        for import_ in node.find_all(nodes.ImportedName):</span>
<span class="gi">+            if import_.importname not in self.import_aliases:</span>
<span class="gi">+                imp = import_.importname</span>
<span class="gi">+                self.import_aliases[imp] = alias = self.temporary_identifier()</span>
<span class="gi">+                if &quot;.&quot; in imp:</span>
<span class="gi">+                    module, obj = imp.rsplit(&quot;.&quot;, 1)</span>
<span class="gi">+                    self.writeline(f&quot;from {module} import {obj} as {alias}&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.writeline(f&quot;import {imp} as {alias}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # add the load name</span>
<span class="gi">+        self.writeline(f&quot;name = {self.name!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # generate the root render function.</span>
<span class="gi">+        self.writeline(</span>
<span class="gi">+            f&quot;{self.func(&#39;root&#39;)}(context, missing=missing{envenv}):&quot;, extra=1</span>
<span class="gi">+        )</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        self.write_commons()</span>
<span class="gi">+</span>
<span class="gi">+        # process the root</span>
<span class="gi">+        frame = Frame(eval_ctx)</span>
<span class="gi">+        if &quot;self&quot; in find_undeclared(node.body, (&quot;self&quot;,)):</span>
<span class="gi">+            ref = frame.symbols.declare_parameter(&quot;self&quot;)</span>
<span class="gi">+            self.writeline(f&quot;{ref} = TemplateReference(context)&quot;)</span>
<span class="gi">+        frame.symbols.analyze_node(node)</span>
<span class="gi">+        frame.toplevel = frame.rootlevel = True</span>
<span class="gi">+        frame.require_output_check = have_extends and not self.has_known_extends</span>
<span class="gi">+        if have_extends:</span>
<span class="gi">+            self.writeline(&quot;parent_template = None&quot;)</span>
<span class="gi">+        self.enter_frame(frame)</span>
<span class="gi">+        self.pull_dependencies(node.body)</span>
<span class="gi">+        self.blockvisit(node.body, frame)</span>
<span class="gi">+        self.leave_frame(frame, with_python_scope=True)</span>
<span class="gi">+        self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+        # make sure that the parent root is called.</span>
<span class="gi">+        if have_extends:</span>
<span class="gi">+            if not self.has_known_extends:</span>
<span class="gi">+                self.indent()</span>
<span class="gi">+                self.writeline(&quot;if parent_template is not None:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            if not self.environment.is_async:</span>
<span class="gi">+                self.writeline(&quot;yield from parent_template.root_render_func(context)&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.writeline(</span>
<span class="gi">+                    &quot;async for event in parent_template.root_render_func(context):&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                self.indent()</span>
<span class="gi">+                self.writeline(&quot;yield event&quot;)</span>
<span class="gi">+                self.outdent()</span>
<span class="gi">+            self.outdent(1 + (not self.has_known_extends))</span>
<span class="gi">+</span>
<span class="gi">+        # at this point we now have the blocks collected and can visit them too.</span>
<span class="gi">+        for name, block in self.blocks.items():</span>
<span class="gi">+            self.writeline(</span>
<span class="gi">+                f&quot;{self.func(&#39;block_&#39; + name)}(context, missing=missing{envenv}):&quot;,</span>
<span class="gi">+                block,</span>
<span class="gi">+                1,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.write_commons()</span>
<span class="gi">+            # It&#39;s important that we do not make this frame a child of the</span>
<span class="gi">+            # toplevel template.  This would cause a variety of</span>
<span class="gi">+            # interesting issues with identifier tracking.</span>
<span class="gi">+            block_frame = Frame(eval_ctx)</span>
<span class="gi">+            block_frame.block_frame = True</span>
<span class="gi">+            undeclared = find_undeclared(block.body, (&quot;self&quot;, &quot;super&quot;))</span>
<span class="gi">+            if &quot;self&quot; in undeclared:</span>
<span class="gi">+                ref = block_frame.symbols.declare_parameter(&quot;self&quot;)</span>
<span class="gi">+                self.writeline(f&quot;{ref} = TemplateReference(context)&quot;)</span>
<span class="gi">+            if &quot;super&quot; in undeclared:</span>
<span class="gi">+                ref = block_frame.symbols.declare_parameter(&quot;super&quot;)</span>
<span class="gi">+                self.writeline(f&quot;{ref} = context.super({name!r}, block_{name})&quot;)</span>
<span class="gi">+            block_frame.symbols.analyze_node(block)</span>
<span class="gi">+            block_frame.block = name</span>
<span class="gi">+            self.writeline(&quot;_block_vars = {}&quot;)</span>
<span class="gi">+            self.enter_frame(block_frame)</span>
<span class="gi">+            self.pull_dependencies(block.body)</span>
<span class="gi">+            self.blockvisit(block.body, block_frame)</span>
<span class="gi">+            self.leave_frame(block_frame, with_python_scope=True)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+        blocks_kv_str = &quot;, &quot;.join(f&quot;{x!r}: block_{x}&quot; for x in self.blocks)</span>
<span class="gi">+        self.writeline(f&quot;blocks = {{{blocks_kv_str}}}&quot;, extra=1)</span>
<span class="gi">+        debug_kv_str = &quot;&amp;&quot;.join(f&quot;{k}={v}&quot; for k, v in self.debug_info)</span>
<span class="gi">+        self.writeline(f&quot;debug_info = {debug_kv_str!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Block(self, node: nodes.Block, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call a block and register it for the template.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_Extends(self, node: nodes.Extends, frame: Frame) -&gt;None:</span>
<span class="gi">+        level = 0</span>
<span class="gi">+        if frame.toplevel:</span>
<span class="gi">+            # if we know that we are a child template, there is no need to</span>
<span class="gi">+            # check if we are one</span>
<span class="gi">+            if self.has_known_extends:</span>
<span class="gi">+                return</span>
<span class="gi">+            if self.extends_so_far &gt; 0:</span>
<span class="gi">+                self.writeline(&quot;if parent_template is None:&quot;)</span>
<span class="gi">+                self.indent()</span>
<span class="gi">+                level += 1</span>
<span class="gi">+</span>
<span class="gi">+        if node.scoped:</span>
<span class="gi">+            context = self.derive_context(frame)</span>
<span class="gi">+        else:</span>
<span class="gi">+            context = self.get_context_ref()</span>
<span class="gi">+</span>
<span class="gi">+        if node.required:</span>
<span class="gi">+            self.writeline(f&quot;if len(context.blocks[{node.name!r}]) &lt;= 1:&quot;, node)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.writeline(</span>
<span class="gi">+                f&#39;raise TemplateRuntimeError(&quot;Required block {node.name!r} not found&quot;)&#39;,</span>
<span class="gi">+                node,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+        if not self.environment.is_async and frame.buffer is None:</span>
<span class="gi">+            self.writeline(</span>
<span class="gi">+                f&quot;yield from context.blocks[{node.name!r}][0]({context})&quot;, node</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.writeline(</span>
<span class="gi">+                f&quot;{self.choose_async()}for event in&quot;</span>
<span class="gi">+                f&quot; context.blocks[{node.name!r}][0]({context}):&quot;,</span>
<span class="gi">+                node,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.simple_write(&quot;event&quot;, frame)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+        self.outdent(level)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Extends(self, node: nodes.Extends, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Calls the extender.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_Include(self, node: nodes.Include, frame: Frame) -&gt;None:</span>
<span class="gi">+        if not frame.toplevel:</span>
<span class="gi">+            self.fail(&quot;cannot use extend from a non top-level scope&quot;, node.lineno)</span>
<span class="gi">+</span>
<span class="gi">+        # if the number of extends statements in general is zero so</span>
<span class="gi">+        # far, we don&#39;t have to add a check if something extended</span>
<span class="gi">+        # the template before this one.</span>
<span class="gi">+        if self.extends_so_far &gt; 0:</span>
<span class="gi">+            # if we have a known extends we just add a template runtime</span>
<span class="gi">+            # error into the generated code.  We could catch that at compile</span>
<span class="gi">+            # time too, but i welcome it not to confuse users by throwing the</span>
<span class="gi">+            # same error at different times just &quot;because we can&quot;.</span>
<span class="gi">+            if not self.has_known_extends:</span>
<span class="gi">+                self.writeline(&quot;if parent_template is not None:&quot;)</span>
<span class="gi">+                self.indent()</span>
<span class="gi">+            self.writeline(&#39;raise TemplateRuntimeError(&quot;extended multiple times&quot;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            # if we have a known extends already we don&#39;t need that code here</span>
<span class="gi">+            # as we know that the template execution will end here.</span>
<span class="gi">+            if self.has_known_extends:</span>
<span class="gi">+                raise CompilerExit()</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+        self.writeline(&quot;parent_template = environment.get_template(&quot;, node)</span>
<span class="gi">+        self.visit(node.template, frame)</span>
<span class="gi">+        self.write(f&quot;, {self.name!r})&quot;)</span>
<span class="gi">+        self.writeline(&quot;for name, parent_block in parent_template.blocks.items():&quot;)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        self.writeline(&quot;context.blocks.setdefault(name, []).append(parent_block)&quot;)</span>
<span class="gi">+        self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+        # if this extends statement was in the root level we can take</span>
<span class="gi">+        # advantage of that information and simplify the generated code</span>
<span class="gi">+        # in the top level from this point onwards</span>
<span class="gi">+        if frame.rootlevel:</span>
<span class="gi">+            self.has_known_extends = True</span>
<span class="gi">+</span>
<span class="gi">+        # and now we have one more</span>
<span class="gi">+        self.extends_so_far += 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Include(self, node: nodes.Include, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles includes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.ignore_missing:</span>
<span class="gi">+            self.writeline(&quot;try:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+</span>
<span class="gi">+        func_name = &quot;get_or_select_template&quot;</span>
<span class="gi">+        if isinstance(node.template, nodes.Const):</span>
<span class="gi">+            if isinstance(node.template.value, str):</span>
<span class="gi">+                func_name = &quot;get_template&quot;</span>
<span class="gi">+            elif isinstance(node.template.value, (tuple, list)):</span>
<span class="gi">+                func_name = &quot;select_template&quot;</span>
<span class="gi">+        elif isinstance(node.template, (nodes.Tuple, nodes.List)):</span>
<span class="gi">+            func_name = &quot;select_template&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self.writeline(f&quot;template = environment.{func_name}(&quot;, node)</span>
<span class="gi">+        self.visit(node.template, frame)</span>
<span class="gi">+        self.write(f&quot;, {self.name!r})&quot;)</span>
<span class="gi">+        if node.ignore_missing:</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+            self.writeline(&quot;except TemplateNotFound:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.writeline(&quot;pass&quot;)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+            self.writeline(&quot;else:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+</span>
<span class="gi">+        skip_event_yield = False</span>
<span class="gi">+        if node.with_context:</span>
<span class="gi">+            self.writeline(</span>
<span class="gi">+                f&quot;{self.choose_async()}for event in template.root_render_func(&quot;</span>
<span class="gi">+                &quot;template.new_context(context.get_all(), True,&quot;</span>
<span class="gi">+                f&quot; {self.dump_local_context(frame)})):&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        elif self.environment.is_async:</span>
<span class="gi">+            self.writeline(</span>
<span class="gi">+                &quot;for event in (await template._get_default_module_async())&quot;</span>
<span class="gi">+                &quot;._body_stream:&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.writeline(&quot;yield from template._get_default_module()._body_stream&quot;)</span>
<span class="gi">+            skip_event_yield = True</span>
<span class="gi">+</span>
<span class="gi">+        if not skip_event_yield:</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.simple_write(&quot;event&quot;, frame)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+        if node.ignore_missing:</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+    def _import_common(</span>
<span class="gi">+        self, node: t.Union[nodes.Import, nodes.FromImport], frame: Frame</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.write(f&quot;{self.choose_async(&#39;await &#39;)}environment.get_template(&quot;)</span>
<span class="gi">+        self.visit(node.template, frame)</span>
<span class="gi">+        self.write(f&quot;, {self.name!r}).&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if node.with_context:</span>
<span class="gi">+            f_name = f&quot;make_module{self.choose_async(&#39;_async&#39;)}&quot;</span>
<span class="gi">+            self.write(</span>
<span class="gi">+                f&quot;{f_name}(context.get_all(), True, {self.dump_local_context(frame)})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(f&quot;_get_default_module{self.choose_async(&#39;_async&#39;)}(context)&quot;)</span>

<span class="gd">-    def visit_Import(self, node: nodes.Import, frame: Frame) -&gt;None:</span>
<span class="gi">+    def visit_Import(self, node: nodes.Import, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit regular imports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.writeline(f&quot;{frame.symbols.ref(node.target)} = &quot;, node)</span>
<span class="gi">+        if frame.toplevel:</span>
<span class="gi">+            self.write(f&quot;context.vars[{node.target!r}] = &quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._import_common(node, frame)</span>

<span class="gd">-    def visit_FromImport(self, node: nodes.FromImport, frame: Frame) -&gt;None:</span>
<span class="gi">+        if frame.toplevel and not node.target.startswith(&quot;_&quot;):</span>
<span class="gi">+            self.writeline(f&quot;context.exported_vars.discard({node.target!r})&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_FromImport(self, node: nodes.FromImport, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit named imports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.newline(node)</span>
<span class="gi">+        self.write(&quot;included_template = &quot;)</span>
<span class="gi">+        self._import_common(node, frame)</span>
<span class="gi">+        var_names = []</span>
<span class="gi">+        discarded_names = []</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            if isinstance(name, tuple):</span>
<span class="gi">+                name, alias = name</span>
<span class="gi">+            else:</span>
<span class="gi">+                alias = name</span>
<span class="gi">+            self.writeline(</span>
<span class="gi">+                f&quot;{frame.symbols.ref(alias)} =&quot;</span>
<span class="gi">+                f&quot; getattr(included_template, {name!r}, missing)&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.writeline(f&quot;if {frame.symbols.ref(alias)} is missing:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            message = (</span>
<span class="gi">+                &quot;the template {included_template.__name__!r}&quot;</span>
<span class="gi">+                f&quot; (imported on {self.position(node)})&quot;</span>
<span class="gi">+                f&quot; does not export the requested name {name!r}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.writeline(</span>
<span class="gi">+                f&quot;{frame.symbols.ref(alias)} = undefined(f{message!r}, name={name!r})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+            if frame.toplevel:</span>
<span class="gi">+                var_names.append(alias)</span>
<span class="gi">+                if not alias.startswith(&quot;_&quot;):</span>
<span class="gi">+                    discarded_names.append(alias)</span>
<span class="gi">+</span>
<span class="gi">+        if var_names:</span>
<span class="gi">+            if len(var_names) == 1:</span>
<span class="gi">+                name = var_names[0]</span>
<span class="gi">+                self.writeline(f&quot;context.vars[{name!r}] = {frame.symbols.ref(name)}&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                names_kv = &quot;, &quot;.join(</span>
<span class="gi">+                    f&quot;{name!r}: {frame.symbols.ref(name)}&quot; for name in var_names</span>
<span class="gi">+                )</span>
<span class="gi">+                self.writeline(f&quot;context.vars.update({{{names_kv}}})&quot;)</span>
<span class="gi">+        if discarded_names:</span>
<span class="gi">+            if len(discarded_names) == 1:</span>
<span class="gi">+                self.writeline(f&quot;context.exported_vars.discard({discarded_names[0]!r})&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                names_str = &quot;, &quot;.join(map(repr, discarded_names))</span>
<span class="gi">+                self.writeline(</span>
<span class="gi">+                    f&quot;context.exported_vars.difference_update(({names_str}))&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_For(self, node: nodes.For, frame: Frame) -&gt; None:</span>
<span class="gi">+        loop_frame = frame.inner()</span>
<span class="gi">+        loop_frame.loop_frame = True</span>
<span class="gi">+        test_frame = frame.inner()</span>
<span class="gi">+        else_frame = frame.inner()</span>
<span class="gi">+</span>
<span class="gi">+        # try to figure out if we have an extended loop.  An extended loop</span>
<span class="gi">+        # is necessary if the loop is in recursive mode if the special loop</span>
<span class="gi">+        # variable is accessed in the body if the body is a scoped block.</span>
<span class="gi">+        extended_loop = (</span>
<span class="gi">+            node.recursive</span>
<span class="gi">+            or &quot;loop&quot;</span>
<span class="gi">+            in find_undeclared(node.iter_child_nodes(only=(&quot;body&quot;,)), (&quot;loop&quot;,))</span>
<span class="gi">+            or any(block.scoped for block in node.find_all(nodes.Block))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        loop_ref = None</span>
<span class="gi">+        if extended_loop:</span>
<span class="gi">+            loop_ref = loop_frame.symbols.declare_parameter(&quot;loop&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        loop_frame.symbols.analyze_node(node, for_branch=&quot;body&quot;)</span>
<span class="gi">+        if node.else_:</span>
<span class="gi">+            else_frame.symbols.analyze_node(node, for_branch=&quot;else&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if node.test:</span>
<span class="gi">+            loop_filter_func = self.temporary_identifier()</span>
<span class="gi">+            test_frame.symbols.analyze_node(node, for_branch=&quot;test&quot;)</span>
<span class="gi">+            self.writeline(f&quot;{self.func(loop_filter_func)}(fiter):&quot;, node.test)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.enter_frame(test_frame)</span>
<span class="gi">+            self.writeline(self.choose_async(&quot;async for &quot;, &quot;for &quot;))</span>
<span class="gi">+            self.visit(node.target, loop_frame)</span>
<span class="gi">+            self.write(&quot; in &quot;)</span>
<span class="gi">+            self.write(self.choose_async(&quot;auto_aiter(fiter)&quot;, &quot;fiter&quot;))</span>
<span class="gi">+            self.write(&quot;:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.writeline(&quot;if &quot;, node.test)</span>
<span class="gi">+            self.visit(node.test, test_frame)</span>
<span class="gi">+            self.write(&quot;:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.writeline(&quot;yield &quot;)</span>
<span class="gi">+            self.visit(node.target, loop_frame)</span>
<span class="gi">+            self.outdent(3)</span>
<span class="gi">+            self.leave_frame(test_frame, with_python_scope=True)</span>
<span class="gi">+</span>
<span class="gi">+        # if we don&#39;t have an recursive loop we have to find the shadowed</span>
<span class="gi">+        # variables at that point.  Because loops can be nested but the loop</span>
<span class="gi">+        # variable is a special one we have to enforce aliasing for it.</span>
<span class="gi">+        if node.recursive:</span>
<span class="gi">+            self.writeline(</span>
<span class="gi">+                f&quot;{self.func(&#39;loop&#39;)}(reciter, loop_render_func, depth=0):&quot;, node</span>
<span class="gi">+            )</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.buffer(loop_frame)</span>
<span class="gi">+</span>
<span class="gi">+            # Use the same buffer for the else frame</span>
<span class="gi">+            else_frame.buffer = loop_frame.buffer</span>
<span class="gi">+</span>
<span class="gi">+        # make sure the loop variable is a special one and raise a template</span>
<span class="gi">+        # assertion error if a loop tries to write to loop</span>
<span class="gi">+        if extended_loop:</span>
<span class="gi">+            self.writeline(f&quot;{loop_ref} = missing&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for name in node.find_all(nodes.Name):</span>
<span class="gi">+            if name.ctx == &quot;store&quot; and name.name == &quot;loop&quot;:</span>
<span class="gi">+                self.fail(</span>
<span class="gi">+                    &quot;Can&#39;t assign to special loop variable in for-loop target&quot;,</span>
<span class="gi">+                    name.lineno,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if node.else_:</span>
<span class="gi">+            iteration_indicator = self.temporary_identifier()</span>
<span class="gi">+            self.writeline(f&quot;{iteration_indicator} = 1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.writeline(self.choose_async(&quot;async for &quot;, &quot;for &quot;), node)</span>
<span class="gi">+        self.visit(node.target, loop_frame)</span>
<span class="gi">+        if extended_loop:</span>
<span class="gi">+            self.write(f&quot;, {loop_ref} in {self.choose_async(&#39;Async&#39;)}LoopContext(&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&quot; in &quot;)</span>

<span class="gi">+        if node.test:</span>
<span class="gi">+            self.write(f&quot;{loop_filter_func}(&quot;)</span>
<span class="gi">+        if node.recursive:</span>
<span class="gi">+            self.write(&quot;reciter&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.environment.is_async and not extended_loop:</span>
<span class="gi">+                self.write(&quot;auto_aiter(&quot;)</span>
<span class="gi">+            self.visit(node.iter, frame)</span>
<span class="gi">+            if self.environment.is_async and not extended_loop:</span>
<span class="gi">+                self.write(&quot;)&quot;)</span>
<span class="gi">+        if node.test:</span>
<span class="gi">+            self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if node.recursive:</span>
<span class="gi">+            self.write(&quot;, undefined, loop_render_func, depth):&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&quot;, undefined):&quot; if extended_loop else &quot;:&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        self.enter_frame(loop_frame)</span>
<span class="gi">+</span>
<span class="gi">+        self.writeline(&quot;_loop_vars = {}&quot;)</span>
<span class="gi">+        self.blockvisit(node.body, loop_frame)</span>
<span class="gi">+        if node.else_:</span>
<span class="gi">+            self.writeline(f&quot;{iteration_indicator} = 0&quot;)</span>
<span class="gi">+        self.outdent()</span>
<span class="gi">+        self.leave_frame(</span>
<span class="gi">+            loop_frame, with_python_scope=node.recursive and not node.else_</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if node.else_:</span>
<span class="gi">+            self.writeline(f&quot;if {iteration_indicator}:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.enter_frame(else_frame)</span>
<span class="gi">+            self.blockvisit(node.else_, else_frame)</span>
<span class="gi">+            self.leave_frame(else_frame)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+        # if the node was recursive we have to return the buffer contents</span>
<span class="gi">+        # and start the iteration code</span>
<span class="gi">+        if node.recursive:</span>
<span class="gi">+            self.return_buffer_contents(loop_frame)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+            self.start_write(frame, node)</span>
<span class="gi">+            self.write(f&quot;{self.choose_async(&#39;await &#39;)}loop(&quot;)</span>
<span class="gi">+            if self.environment.is_async:</span>
<span class="gi">+                self.write(&quot;auto_aiter(&quot;)</span>
<span class="gi">+            self.visit(node.iter, frame)</span>
<span class="gi">+            if self.environment.is_async:</span>
<span class="gi">+                self.write(&quot;)&quot;)</span>
<span class="gi">+            self.write(&quot;, loop)&quot;)</span>
<span class="gi">+            self.end_write(frame)</span>
<span class="gi">+</span>
<span class="gi">+        # at the end of the iteration, clear any assignments made in the</span>
<span class="gi">+        # loop from the top level</span>
<span class="gi">+        if self._assign_stack:</span>
<span class="gi">+            self._assign_stack[-1].difference_update(loop_frame.symbols.stores)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_If(self, node: nodes.If, frame: Frame) -&gt; None:</span>
<span class="gi">+        if_frame = frame.soft()</span>
<span class="gi">+        self.writeline(&quot;if &quot;, node)</span>
<span class="gi">+        self.visit(node.test, if_frame)</span>
<span class="gi">+        self.write(&quot;:&quot;)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        self.blockvisit(node.body, if_frame)</span>
<span class="gi">+        self.outdent()</span>
<span class="gi">+        for elif_ in node.elif_:</span>
<span class="gi">+            self.writeline(&quot;elif &quot;, elif_)</span>
<span class="gi">+            self.visit(elif_.test, if_frame)</span>
<span class="gi">+            self.write(&quot;:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.blockvisit(elif_.body, if_frame)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+        if node.else_:</span>
<span class="gi">+            self.writeline(&quot;else:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+            self.blockvisit(node.else_, if_frame)</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Macro(self, node: nodes.Macro, frame: Frame) -&gt; None:</span>
<span class="gi">+        macro_frame, macro_ref = self.macro_body(node, frame)</span>
<span class="gi">+        self.newline()</span>
<span class="gi">+        if frame.toplevel:</span>
<span class="gi">+            if not node.name.startswith(&quot;_&quot;):</span>
<span class="gi">+                self.write(f&quot;context.exported_vars.add({node.name!r})&quot;)</span>
<span class="gi">+            self.writeline(f&quot;context.vars[{node.name!r}] = &quot;)</span>
<span class="gi">+        self.write(f&quot;{frame.symbols.ref(node.name)} = &quot;)</span>
<span class="gi">+        self.macro_def(macro_ref, macro_frame)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_CallBlock(self, node: nodes.CallBlock, frame: Frame) -&gt; None:</span>
<span class="gi">+        call_frame, macro_ref = self.macro_body(node, frame)</span>
<span class="gi">+        self.writeline(&quot;caller = &quot;)</span>
<span class="gi">+        self.macro_def(macro_ref, call_frame)</span>
<span class="gi">+        self.start_write(frame, node)</span>
<span class="gi">+        self.visit_Call(node.call, frame, forward_caller=True)</span>
<span class="gi">+        self.end_write(frame)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_FilterBlock(self, node: nodes.FilterBlock, frame: Frame) -&gt; None:</span>
<span class="gi">+        filter_frame = frame.inner()</span>
<span class="gi">+        filter_frame.symbols.analyze_node(node)</span>
<span class="gi">+        self.enter_frame(filter_frame)</span>
<span class="gi">+        self.buffer(filter_frame)</span>
<span class="gi">+        self.blockvisit(node.body, filter_frame)</span>
<span class="gi">+        self.start_write(frame, node)</span>
<span class="gi">+        self.visit_Filter(node.filter, filter_frame)</span>
<span class="gi">+        self.end_write(frame)</span>
<span class="gi">+        self.leave_frame(filter_frame)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_With(self, node: nodes.With, frame: Frame) -&gt; None:</span>
<span class="gi">+        with_frame = frame.inner()</span>
<span class="gi">+        with_frame.symbols.analyze_node(node)</span>
<span class="gi">+        self.enter_frame(with_frame)</span>
<span class="gi">+        for target, expr in zip(node.targets, node.values):</span>
<span class="gi">+            self.newline()</span>
<span class="gi">+            self.visit(target, with_frame)</span>
<span class="gi">+            self.write(&quot; = &quot;)</span>
<span class="gi">+            self.visit(expr, frame)</span>
<span class="gi">+        self.blockvisit(node.body, with_frame)</span>
<span class="gi">+        self.leave_frame(with_frame)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_ExprStmt(self, node: nodes.ExprStmt, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.newline(node)</span>
<span class="gi">+        self.visit(node.node, frame)</span>

<span class="w"> </span>    class _FinalizeInfo(t.NamedTuple):
<span class="w"> </span>        const: t.Optional[t.Callable[..., str]]
<span class="w"> </span>        src: t.Optional[str]

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _default_finalize(value: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def _default_finalize(value: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;The default finalize function if the environment isn&#39;t
<span class="w"> </span>        configured with one. Or, if the environment has one, this is
<span class="w"> </span>        called on that function&#39;s output for constants.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return str(value)</span>
<span class="gi">+</span>
<span class="w"> </span>    _finalize: t.Optional[_FinalizeInfo] = None

<span class="gd">-    def _make_finalize(self) -&gt;_FinalizeInfo:</span>
<span class="gi">+    def _make_finalize(self) -&gt; _FinalizeInfo:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build the finalize function to be used on constants and at
<span class="w"> </span>        runtime. Cached so it&#39;s only created once for all output nodes.

<span class="gu">@@ -353,17 +1389,51 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>            Source code to output around nodes to be evaluated at
<span class="w"> </span>            runtime.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._finalize is not None:</span>
<span class="gi">+            return self._finalize</span>
<span class="gi">+</span>
<span class="gi">+        finalize: t.Optional[t.Callable[..., t.Any]]</span>
<span class="gi">+        finalize = default = self._default_finalize</span>
<span class="gi">+        src = None</span>
<span class="gi">+</span>
<span class="gi">+        if self.environment.finalize:</span>
<span class="gi">+            src = &quot;environment.finalize(&quot;</span>
<span class="gi">+            env_finalize = self.environment.finalize</span>
<span class="gi">+            pass_arg = {</span>
<span class="gi">+                _PassArg.context: &quot;context&quot;,</span>
<span class="gi">+                _PassArg.eval_context: &quot;context.eval_ctx&quot;,</span>
<span class="gi">+                _PassArg.environment: &quot;environment&quot;,</span>
<span class="gi">+            }.get(</span>
<span class="gi">+                _PassArg.from_obj(env_finalize)  # type: ignore</span>
<span class="gi">+            )</span>
<span class="gi">+            finalize = None</span>
<span class="gi">+</span>
<span class="gi">+            if pass_arg is None:</span>
<span class="gi">+</span>
<span class="gi">+                def finalize(value: t.Any) -&gt; t.Any:  # noqa: F811</span>
<span class="gi">+                    return default(env_finalize(value))</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                src = f&quot;{src}{pass_arg}, &quot;</span>

<span class="gd">-    def _output_const_repr(self, group: t.Iterable[t.Any]) -&gt;str:</span>
<span class="gi">+                if pass_arg == &quot;environment&quot;:</span>
<span class="gi">+</span>
<span class="gi">+                    def finalize(value: t.Any) -&gt; t.Any:  # noqa: F811</span>
<span class="gi">+                        return default(env_finalize(self.environment, value))</span>
<span class="gi">+</span>
<span class="gi">+        self._finalize = self._FinalizeInfo(finalize, src)</span>
<span class="gi">+        return self._finalize</span>
<span class="gi">+</span>
<span class="gi">+    def _output_const_repr(self, group: t.Iterable[t.Any]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a group of constant values converted from ``Output``
<span class="w"> </span>        child nodes, produce a string to write to the template module
<span class="w"> </span>        source.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return repr(concat(group))</span>

<span class="gd">-    def _output_child_to_const(self, node: nodes.Expr, frame: Frame,</span>
<span class="gd">-        finalize: _FinalizeInfo) -&gt;str:</span>
<span class="gi">+    def _output_child_to_const(</span>
<span class="gi">+        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to optimize a child of an ``Output`` node by trying to
<span class="w"> </span>        convert it to constant, finalized data at compile time.

<span class="gu">@@ -371,30 +1441,520 @@ class CodeGenerator(NodeVisitor):</span>
<span class="w"> </span>        will be evaluated at runtime. Any other exception will also be
<span class="w"> </span>        evaluated at runtime for easier debugging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        const = node.as_const(frame.eval_ctx)</span>

<span class="gd">-    def _output_child_pre(self, node: nodes.Expr, frame: Frame, finalize:</span>
<span class="gd">-        _FinalizeInfo) -&gt;None:</span>
<span class="gi">+        if frame.eval_ctx.autoescape:</span>
<span class="gi">+            const = escape(const)</span>
<span class="gi">+</span>
<span class="gi">+        # Template data doesn&#39;t go through finalize.</span>
<span class="gi">+        if isinstance(node, nodes.TemplateData):</span>
<span class="gi">+            return str(const)</span>
<span class="gi">+</span>
<span class="gi">+        return finalize.const(const)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def _output_child_pre(</span>
<span class="gi">+        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Output extra source code before visiting a child of an
<span class="w"> </span>        ``Output`` node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if frame.eval_ctx.volatile:</span>
<span class="gi">+            self.write(&quot;(escape if context.eval_ctx.autoescape else str)(&quot;)</span>
<span class="gi">+        elif frame.eval_ctx.autoescape:</span>
<span class="gi">+            self.write(&quot;escape(&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&quot;str(&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if finalize.src is not None:</span>
<span class="gi">+            self.write(finalize.src)</span>

<span class="gd">-    def _output_child_post(self, node: nodes.Expr, frame: Frame, finalize:</span>
<span class="gd">-        _FinalizeInfo) -&gt;None:</span>
<span class="gi">+    def _output_child_post(</span>
<span class="gi">+        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Output extra source code after visiting a child of an
<span class="w"> </span>        ``Output`` node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    visit_Add = _make_binop(&#39;+&#39;)</span>
<span class="gd">-    visit_Sub = _make_binop(&#39;-&#39;)</span>
<span class="gd">-    visit_Mul = _make_binop(&#39;*&#39;)</span>
<span class="gd">-    visit_Div = _make_binop(&#39;/&#39;)</span>
<span class="gd">-    visit_FloorDiv = _make_binop(&#39;//&#39;)</span>
<span class="gd">-    visit_Pow = _make_binop(&#39;**&#39;)</span>
<span class="gd">-    visit_Mod = _make_binop(&#39;%&#39;)</span>
<span class="gd">-    visit_And = _make_binop(&#39;and&#39;)</span>
<span class="gd">-    visit_Or = _make_binop(&#39;or&#39;)</span>
<span class="gd">-    visit_Pos = _make_unop(&#39;+&#39;)</span>
<span class="gd">-    visit_Neg = _make_unop(&#39;-&#39;)</span>
<span class="gd">-    visit_Not = _make_unop(&#39;not &#39;)</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if finalize.src is not None:</span>
<span class="gi">+            self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Output(self, node: nodes.Output, frame: Frame) -&gt; None:</span>
<span class="gi">+        # If an extends is active, don&#39;t render outside a block.</span>
<span class="gi">+        if frame.require_output_check:</span>
<span class="gi">+            # A top-level extends is known to exist at compile time.</span>
<span class="gi">+            if self.has_known_extends:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self.writeline(&quot;if parent_template is None:&quot;)</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+</span>
<span class="gi">+        finalize = self._make_finalize()</span>
<span class="gi">+        body: t.List[t.Union[t.List[t.Any], nodes.Expr]] = []</span>
<span class="gi">+</span>
<span class="gi">+        # Evaluate constants at compile time if possible. Each item in</span>
<span class="gi">+        # body will be either a list of static data or a node to be</span>
<span class="gi">+        # evaluated at runtime.</span>
<span class="gi">+        for child in node.nodes:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if not (</span>
<span class="gi">+                    # If the finalize function requires runtime context,</span>
<span class="gi">+                    # constants can&#39;t be evaluated at compile time.</span>
<span class="gi">+                    finalize.const</span>
<span class="gi">+                    # Unless it&#39;s basic template data that won&#39;t be</span>
<span class="gi">+                    # finalized anyway.</span>
<span class="gi">+                    or isinstance(child, nodes.TemplateData)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    raise nodes.Impossible()</span>
<span class="gi">+</span>
<span class="gi">+                const = self._output_child_to_const(child, frame, finalize)</span>
<span class="gi">+            except (nodes.Impossible, Exception):</span>
<span class="gi">+                # The node was not constant and needs to be evaluated at</span>
<span class="gi">+                # runtime. Or another error was raised, which is easier</span>
<span class="gi">+                # to debug at runtime.</span>
<span class="gi">+                body.append(child)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if body and isinstance(body[-1], list):</span>
<span class="gi">+                body[-1].append(const)</span>
<span class="gi">+            else:</span>
<span class="gi">+                body.append([const])</span>
<span class="gi">+</span>
<span class="gi">+        if frame.buffer is not None:</span>
<span class="gi">+            if len(body) == 1:</span>
<span class="gi">+                self.writeline(f&quot;{frame.buffer}.append(&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.writeline(f&quot;{frame.buffer}.extend((&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            self.indent()</span>
<span class="gi">+</span>
<span class="gi">+        for item in body:</span>
<span class="gi">+            if isinstance(item, list):</span>
<span class="gi">+                # A group of constant data to join and output.</span>
<span class="gi">+                val = self._output_const_repr(item)</span>
<span class="gi">+</span>
<span class="gi">+                if frame.buffer is None:</span>
<span class="gi">+                    self.writeline(&quot;yield &quot; + val)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.writeline(val + &quot;,&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if frame.buffer is None:</span>
<span class="gi">+                    self.writeline(&quot;yield &quot;, item)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.newline(item)</span>
<span class="gi">+</span>
<span class="gi">+                # A node to be evaluated at runtime.</span>
<span class="gi">+                self._output_child_pre(item, frame, finalize)</span>
<span class="gi">+                self.visit(item, frame)</span>
<span class="gi">+                self._output_child_post(item, frame, finalize)</span>
<span class="gi">+</span>
<span class="gi">+                if frame.buffer is not None:</span>
<span class="gi">+                    self.write(&quot;,&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if frame.buffer is not None:</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+            self.writeline(&quot;)&quot; if len(body) == 1 else &quot;))&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if frame.require_output_check:</span>
<span class="gi">+            self.outdent()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Assign(self, node: nodes.Assign, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.push_assign_tracking()</span>
<span class="gi">+        self.newline(node)</span>
<span class="gi">+        self.visit(node.target, frame)</span>
<span class="gi">+        self.write(&quot; = &quot;)</span>
<span class="gi">+        self.visit(node.node, frame)</span>
<span class="gi">+        self.pop_assign_tracking(frame)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_AssignBlock(self, node: nodes.AssignBlock, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.push_assign_tracking()</span>
<span class="gi">+        block_frame = frame.inner()</span>
<span class="gi">+        # This is a special case.  Since a set block always captures we</span>
<span class="gi">+        # will disable output checks.  This way one can use set blocks</span>
<span class="gi">+        # toplevel even in extended templates.</span>
<span class="gi">+        block_frame.require_output_check = False</span>
<span class="gi">+        block_frame.symbols.analyze_node(node)</span>
<span class="gi">+        self.enter_frame(block_frame)</span>
<span class="gi">+        self.buffer(block_frame)</span>
<span class="gi">+        self.blockvisit(node.body, block_frame)</span>
<span class="gi">+        self.newline(node)</span>
<span class="gi">+        self.visit(node.target, frame)</span>
<span class="gi">+        self.write(&quot; = (Markup if context.eval_ctx.autoescape else identity)(&quot;)</span>
<span class="gi">+        if node.filter is not None:</span>
<span class="gi">+            self.visit_Filter(node.filter, block_frame)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(f&quot;concat({block_frame.buffer})&quot;)</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+        self.pop_assign_tracking(frame)</span>
<span class="gi">+        self.leave_frame(block_frame)</span>
<span class="gi">+</span>
<span class="gi">+    # -- Expression Visitors</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Name(self, node: nodes.Name, frame: Frame) -&gt; None:</span>
<span class="gi">+        if node.ctx == &quot;store&quot; and (</span>
<span class="gi">+            frame.toplevel or frame.loop_frame or frame.block_frame</span>
<span class="gi">+        ):</span>
<span class="gi">+            if self._assign_stack:</span>
<span class="gi">+                self._assign_stack[-1].add(node.name)</span>
<span class="gi">+        ref = frame.symbols.ref(node.name)</span>
<span class="gi">+</span>
<span class="gi">+        # If we are looking up a variable we might have to deal with the</span>
<span class="gi">+        # case where it&#39;s undefined.  We can skip that case if the load</span>
<span class="gi">+        # instruction indicates a parameter which are always defined.</span>
<span class="gi">+        if node.ctx == &quot;load&quot;:</span>
<span class="gi">+            load = frame.symbols.find_load(ref)</span>
<span class="gi">+            if not (</span>
<span class="gi">+                load is not None</span>
<span class="gi">+                and load[0] == VAR_LOAD_PARAMETER</span>
<span class="gi">+                and not self.parameter_is_undeclared(ref)</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.write(</span>
<span class="gi">+                    f&quot;(undefined(name={node.name!r}) if {ref} is missing else {ref})&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        self.write(ref)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_NSRef(self, node: nodes.NSRef, frame: Frame) -&gt; None:</span>
<span class="gi">+        # NSRefs can only be used to store values; since they use the normal</span>
<span class="gi">+        # `foo.bar` notation they will be parsed as a normal attribute access</span>
<span class="gi">+        # when used anywhere but in a `set` context</span>
<span class="gi">+        ref = frame.symbols.ref(node.name)</span>
<span class="gi">+        self.writeline(f&quot;if not isinstance({ref}, Namespace):&quot;)</span>
<span class="gi">+        self.indent()</span>
<span class="gi">+        self.writeline(</span>
<span class="gi">+            &quot;raise TemplateRuntimeError&quot;</span>
<span class="gi">+            &#39;(&quot;cannot assign attribute on non-namespace object&quot;)&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+        self.outdent()</span>
<span class="gi">+        self.writeline(f&quot;{ref}[{node.attr!r}]&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Const(self, node: nodes.Const, frame: Frame) -&gt; None:</span>
<span class="gi">+        val = node.as_const(frame.eval_ctx)</span>
<span class="gi">+        if isinstance(val, float):</span>
<span class="gi">+            self.write(str(val))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(repr(val))</span>
<span class="gi">+</span>
<span class="gi">+    def visit_TemplateData(self, node: nodes.TemplateData, frame: Frame) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.write(repr(node.as_const(frame.eval_ctx)))</span>
<span class="gi">+        except nodes.Impossible:</span>
<span class="gi">+            self.write(</span>
<span class="gi">+                f&quot;(Markup if context.eval_ctx.autoescape else identity)({node.data!r})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Tuple(self, node: nodes.Tuple, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(&quot;(&quot;)</span>
<span class="gi">+        idx = -1</span>
<span class="gi">+        for idx, item in enumerate(node.items):</span>
<span class="gi">+            if idx:</span>
<span class="gi">+                self.write(&quot;, &quot;)</span>
<span class="gi">+            self.visit(item, frame)</span>
<span class="gi">+        self.write(&quot;,)&quot; if idx == 0 else &quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_List(self, node: nodes.List, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(&quot;[&quot;)</span>
<span class="gi">+        for idx, item in enumerate(node.items):</span>
<span class="gi">+            if idx:</span>
<span class="gi">+                self.write(&quot;, &quot;)</span>
<span class="gi">+            self.visit(item, frame)</span>
<span class="gi">+        self.write(&quot;]&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Dict(self, node: nodes.Dict, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(&quot;{&quot;)</span>
<span class="gi">+        for idx, item in enumerate(node.items):</span>
<span class="gi">+            if idx:</span>
<span class="gi">+                self.write(&quot;, &quot;)</span>
<span class="gi">+            self.visit(item.key, frame)</span>
<span class="gi">+            self.write(&quot;: &quot;)</span>
<span class="gi">+            self.visit(item.value, frame)</span>
<span class="gi">+        self.write(&quot;}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    visit_Add = _make_binop(&quot;+&quot;)</span>
<span class="gi">+    visit_Sub = _make_binop(&quot;-&quot;)</span>
<span class="gi">+    visit_Mul = _make_binop(&quot;*&quot;)</span>
<span class="gi">+    visit_Div = _make_binop(&quot;/&quot;)</span>
<span class="gi">+    visit_FloorDiv = _make_binop(&quot;//&quot;)</span>
<span class="gi">+    visit_Pow = _make_binop(&quot;**&quot;)</span>
<span class="gi">+    visit_Mod = _make_binop(&quot;%&quot;)</span>
<span class="gi">+    visit_And = _make_binop(&quot;and&quot;)</span>
<span class="gi">+    visit_Or = _make_binop(&quot;or&quot;)</span>
<span class="gi">+    visit_Pos = _make_unop(&quot;+&quot;)</span>
<span class="gi">+    visit_Neg = _make_unop(&quot;-&quot;)</span>
<span class="gi">+    visit_Not = _make_unop(&quot;not &quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visit_Concat(self, node: nodes.Concat, frame: Frame) -&gt; None:</span>
<span class="gi">+        if frame.eval_ctx.volatile:</span>
<span class="gi">+            func_name = &quot;(markup_join if context.eval_ctx.volatile else str_join)&quot;</span>
<span class="gi">+        elif frame.eval_ctx.autoescape:</span>
<span class="gi">+            func_name = &quot;markup_join&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            func_name = &quot;str_join&quot;</span>
<span class="gi">+        self.write(f&quot;{func_name}((&quot;)</span>
<span class="gi">+        for arg in node.nodes:</span>
<span class="gi">+            self.visit(arg, frame)</span>
<span class="gi">+            self.write(&quot;, &quot;)</span>
<span class="gi">+        self.write(&quot;))&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visit_Compare(self, node: nodes.Compare, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(&quot;(&quot;)</span>
<span class="gi">+        self.visit(node.expr, frame)</span>
<span class="gi">+        for op in node.ops:</span>
<span class="gi">+            self.visit(op, frame)</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Operand(self, node: nodes.Operand, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(f&quot; {operators[node.op]} &quot;)</span>
<span class="gi">+        self.visit(node.expr, frame)</span>
<span class="gi">+</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visit_Getattr(self, node: nodes.Getattr, frame: Frame) -&gt; None:</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            self.write(&quot;(await auto_await(&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.write(&quot;environment.getattr(&quot;)</span>
<span class="gi">+        self.visit(node.node, frame)</span>
<span class="gi">+        self.write(f&quot;, {node.attr!r})&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            self.write(&quot;))&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visit_Getitem(self, node: nodes.Getitem, frame: Frame) -&gt; None:</span>
<span class="gi">+        # slices bypass the environment getitem method.</span>
<span class="gi">+        if isinstance(node.arg, nodes.Slice):</span>
<span class="gi">+            self.visit(node.node, frame)</span>
<span class="gi">+            self.write(&quot;[&quot;)</span>
<span class="gi">+            self.visit(node.arg, frame)</span>
<span class="gi">+            self.write(&quot;]&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.environment.is_async:</span>
<span class="gi">+                self.write(&quot;(await auto_await(&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            self.write(&quot;environment.getitem(&quot;)</span>
<span class="gi">+            self.visit(node.node, frame)</span>
<span class="gi">+            self.write(&quot;, &quot;)</span>
<span class="gi">+            self.visit(node.arg, frame)</span>
<span class="gi">+            self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if self.environment.is_async:</span>
<span class="gi">+                self.write(&quot;))&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Slice(self, node: nodes.Slice, frame: Frame) -&gt; None:</span>
<span class="gi">+        if node.start is not None:</span>
<span class="gi">+            self.visit(node.start, frame)</span>
<span class="gi">+        self.write(&quot;:&quot;)</span>
<span class="gi">+        if node.stop is not None:</span>
<span class="gi">+            self.visit(node.stop, frame)</span>
<span class="gi">+        if node.step is not None:</span>
<span class="gi">+            self.write(&quot;:&quot;)</span>
<span class="gi">+            self.visit(node.step, frame)</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def _filter_test_common(</span>
<span class="gi">+        self, node: t.Union[nodes.Filter, nodes.Test], frame: Frame, is_filter: bool</span>
<span class="gi">+    ) -&gt; t.Iterator[None]:</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            self.write(&quot;(await auto_await(&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if is_filter:</span>
<span class="gi">+            self.write(f&quot;{self.filters[node.name]}(&quot;)</span>
<span class="gi">+            func = self.environment.filters.get(node.name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(f&quot;{self.tests[node.name]}(&quot;)</span>
<span class="gi">+            func = self.environment.tests.get(node.name)</span>
<span class="gi">+</span>
<span class="gi">+        # When inside an If or CondExpr frame, allow the filter to be</span>
<span class="gi">+        # undefined at compile time and only raise an error if it&#39;s</span>
<span class="gi">+        # actually called at runtime. See pull_dependencies.</span>
<span class="gi">+        if func is None and not frame.soft_frame:</span>
<span class="gi">+            type_name = &quot;filter&quot; if is_filter else &quot;test&quot;</span>
<span class="gi">+            self.fail(f&quot;No {type_name} named {node.name!r}.&quot;, node.lineno)</span>
<span class="gi">+</span>
<span class="gi">+        pass_arg = {</span>
<span class="gi">+            _PassArg.context: &quot;context&quot;,</span>
<span class="gi">+            _PassArg.eval_context: &quot;context.eval_ctx&quot;,</span>
<span class="gi">+            _PassArg.environment: &quot;environment&quot;,</span>
<span class="gi">+        }.get(</span>
<span class="gi">+            _PassArg.from_obj(func)  # type: ignore</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if pass_arg is not None:</span>
<span class="gi">+            self.write(f&quot;{pass_arg}, &quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Back to the visitor function to handle visiting the target of</span>
<span class="gi">+        # the filter or test.</span>
<span class="gi">+        yield</span>
<span class="gi">+</span>
<span class="gi">+        self.signature(node, frame)</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            self.write(&quot;))&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visit_Filter(self, node: nodes.Filter, frame: Frame) -&gt; None:</span>
<span class="gi">+        with self._filter_test_common(node, frame, True):</span>
<span class="gi">+            # if the filter node is None we are inside a filter block</span>
<span class="gi">+            # and want to write to the current buffer</span>
<span class="gi">+            if node.node is not None:</span>
<span class="gi">+                self.visit(node.node, frame)</span>
<span class="gi">+            elif frame.eval_ctx.volatile:</span>
<span class="gi">+                self.write(</span>
<span class="gi">+                    f&quot;(Markup(concat({frame.buffer}))&quot;</span>
<span class="gi">+                    f&quot; if context.eval_ctx.autoescape else concat({frame.buffer}))&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            elif frame.eval_ctx.autoescape:</span>
<span class="gi">+                self.write(f&quot;Markup(concat({frame.buffer}))&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.write(f&quot;concat({frame.buffer})&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visit_Test(self, node: nodes.Test, frame: Frame) -&gt; None:</span>
<span class="gi">+        with self._filter_test_common(node, frame, False):</span>
<span class="gi">+            self.visit(node.node, frame)</span>
<span class="gi">+</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visit_CondExpr(self, node: nodes.CondExpr, frame: Frame) -&gt; None:</span>
<span class="gi">+        frame = frame.soft()</span>
<span class="gi">+</span>
<span class="gi">+        def write_expr2() -&gt; None:</span>
<span class="gi">+            if node.expr2 is not None:</span>
<span class="gi">+                self.visit(node.expr2, frame)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self.write(</span>
<span class="gi">+                f&#39;cond_expr_undefined(&quot;the inline if-expression on&#39;</span>
<span class="gi">+                f&quot; {self.position(node)} evaluated to false and no else&quot;</span>
<span class="gi">+                f&#39; section was defined.&quot;)&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        self.write(&quot;(&quot;)</span>
<span class="gi">+        self.visit(node.expr1, frame)</span>
<span class="gi">+        self.write(&quot; if &quot;)</span>
<span class="gi">+        self.visit(node.test, frame)</span>
<span class="gi">+        self.write(&quot; else &quot;)</span>
<span class="gi">+        write_expr2()</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @optimizeconst</span>
<span class="gi">+    def visit_Call(</span>
<span class="gi">+        self, node: nodes.Call, frame: Frame, forward_caller: bool = False</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            self.write(&quot;(await auto_await(&quot;)</span>
<span class="gi">+        if self.environment.sandboxed:</span>
<span class="gi">+            self.write(&quot;environment.call(context, &quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.write(&quot;context.call(&quot;)</span>
<span class="gi">+        self.visit(node.node, frame)</span>
<span class="gi">+        extra_kwargs = {&quot;caller&quot;: &quot;caller&quot;} if forward_caller else None</span>
<span class="gi">+        loop_kwargs = {&quot;_loop_vars&quot;: &quot;_loop_vars&quot;} if frame.loop_frame else {}</span>
<span class="gi">+        block_kwargs = {&quot;_block_vars&quot;: &quot;_block_vars&quot;} if frame.block_frame else {}</span>
<span class="gi">+        if extra_kwargs:</span>
<span class="gi">+            extra_kwargs.update(loop_kwargs, **block_kwargs)</span>
<span class="gi">+        elif loop_kwargs or block_kwargs:</span>
<span class="gi">+            extra_kwargs = dict(loop_kwargs, **block_kwargs)</span>
<span class="gi">+        self.signature(node, frame, extra_kwargs)</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            self.write(&quot;))&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Keyword(self, node: nodes.Keyword, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(node.key + &quot;=&quot;)</span>
<span class="gi">+        self.visit(node.value, frame)</span>
<span class="gi">+</span>
<span class="gi">+    # -- Unused nodes for extensions</span>
<span class="gi">+</span>
<span class="gi">+    def visit_MarkSafe(self, node: nodes.MarkSafe, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(&quot;Markup(&quot;)</span>
<span class="gi">+        self.visit(node.expr, frame)</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_MarkSafeIfAutoescape(</span>
<span class="gi">+        self, node: nodes.MarkSafeIfAutoescape, frame: Frame</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.write(&quot;(Markup if context.eval_ctx.autoescape else identity)(&quot;)</span>
<span class="gi">+        self.visit(node.expr, frame)</span>
<span class="gi">+        self.write(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_EnvironmentAttribute(</span>
<span class="gi">+        self, node: nodes.EnvironmentAttribute, frame: Frame</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.write(&quot;environment.&quot; + node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_ExtensionAttribute(</span>
<span class="gi">+        self, node: nodes.ExtensionAttribute, frame: Frame</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.write(f&quot;environment.extensions[{node.identifier!r}].{node.name}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_ImportedName(self, node: nodes.ImportedName, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(self.import_aliases[node.importname])</span>
<span class="gi">+</span>
<span class="gi">+    def visit_InternalName(self, node: nodes.InternalName, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.write(node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_ContextReference(</span>
<span class="gi">+        self, node: nodes.ContextReference, frame: Frame</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.write(&quot;context&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_DerivedContextReference(</span>
<span class="gi">+        self, node: nodes.DerivedContextReference, frame: Frame</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.write(self.derive_context(frame))</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Continue(self, node: nodes.Continue, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.writeline(&quot;continue&quot;, node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Break(self, node: nodes.Break, frame: Frame) -&gt; None:</span>
<span class="gi">+        self.writeline(&quot;break&quot;, node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Scope(self, node: nodes.Scope, frame: Frame) -&gt; None:</span>
<span class="gi">+        scope_frame = frame.inner()</span>
<span class="gi">+        scope_frame.symbols.analyze_node(node)</span>
<span class="gi">+        self.enter_frame(scope_frame)</span>
<span class="gi">+        self.blockvisit(node.body, scope_frame)</span>
<span class="gi">+        self.leave_frame(scope_frame)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_OverlayScope(self, node: nodes.OverlayScope, frame: Frame) -&gt; None:</span>
<span class="gi">+        ctx = self.temporary_identifier()</span>
<span class="gi">+        self.writeline(f&quot;{ctx} = {self.derive_context(frame)}&quot;)</span>
<span class="gi">+        self.writeline(f&quot;{ctx}.vars = &quot;)</span>
<span class="gi">+        self.visit(node.context, frame)</span>
<span class="gi">+        self.push_context_reference(ctx)</span>
<span class="gi">+</span>
<span class="gi">+        scope_frame = frame.inner(isolated=True)</span>
<span class="gi">+        scope_frame.symbols.analyze_node(node)</span>
<span class="gi">+        self.enter_frame(scope_frame)</span>
<span class="gi">+        self.blockvisit(node.body, scope_frame)</span>
<span class="gi">+        self.leave_frame(scope_frame)</span>
<span class="gi">+        self.pop_context_reference()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_EvalContextModifier(</span>
<span class="gi">+        self, node: nodes.EvalContextModifier, frame: Frame</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        for keyword in node.options:</span>
<span class="gi">+            self.writeline(f&quot;context.eval_ctx.{keyword.key} = &quot;)</span>
<span class="gi">+            self.visit(keyword.value, frame)</span>
<span class="gi">+            try:</span>
<span class="gi">+                val = keyword.value.as_const(frame.eval_ctx)</span>
<span class="gi">+            except nodes.Impossible:</span>
<span class="gi">+                frame.eval_ctx.volatile = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                setattr(frame.eval_ctx, keyword.key, val)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_ScopedEvalContextModifier(</span>
<span class="gi">+        self, node: nodes.ScopedEvalContextModifier, frame: Frame</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        old_ctx_name = self.temporary_identifier()</span>
<span class="gi">+        saved_ctx = frame.eval_ctx.save()</span>
<span class="gi">+        self.writeline(f&quot;{old_ctx_name} = context.eval_ctx.save()&quot;)</span>
<span class="gi">+        self.visit_EvalContextModifier(node, frame)</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            self.visit(child, frame)</span>
<span class="gi">+        frame.eval_ctx.revert(saved_ctx)</span>
<span class="gi">+        self.writeline(f&quot;context.eval_ctx.revert({old_ctx_name})&quot;)</span>
<span class="gh">diff --git a/src/jinja2/constants.py b/src/jinja2/constants.py</span>
<span class="gh">index e3262f1..41a1c23 100644</span>
<span class="gd">--- a/src/jinja2/constants.py</span>
<span class="gi">+++ b/src/jinja2/constants.py</span>
<span class="gu">@@ -1,4 +1,6 @@</span>
<span class="gd">-LOREM_IPSUM_WORDS = &quot;&quot;&quot;a ac accumsan ad adipiscing aenean aliquam aliquet amet ante aptent arcu at</span>
<span class="gi">+#: list of lorem ipsum words used by the lipsum() helper function</span>
<span class="gi">+LOREM_IPSUM_WORDS = &quot;&quot;&quot;\</span>
<span class="gi">+a ac accumsan ad adipiscing aenean aliquam aliquet amet ante aptent arcu at</span>
<span class="w"> </span>auctor augue bibendum blandit class commodo condimentum congue consectetuer
<span class="w"> </span>consequat conubia convallis cras cubilia cum curabitur curae cursus dapibus
<span class="w"> </span>diam dictum dictumst dignissim dis dolor donec dui duis egestas eget eleifend
<span class="gh">diff --git a/src/jinja2/debug.py b/src/jinja2/debug.py</span>
<span class="gh">index 412f2c2..7ed7e92 100644</span>
<span class="gd">--- a/src/jinja2/debug.py</span>
<span class="gi">+++ b/src/jinja2/debug.py</span>
<span class="gu">@@ -2,14 +2,16 @@ import sys</span>
<span class="w"> </span>import typing as t
<span class="w"> </span>from types import CodeType
<span class="w"> </span>from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>from .exceptions import TemplateSyntaxError
<span class="w"> </span>from .utils import internal_code
<span class="w"> </span>from .utils import missing
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from .runtime import Context


<span class="gd">-def rewrite_traceback_stack(source: t.Optional[str]=None) -&gt;BaseException:</span>
<span class="gi">+def rewrite_traceback_stack(source: t.Optional[str] = None) -&gt; BaseException:</span>
<span class="w"> </span>    &quot;&quot;&quot;Rewrite the current exception to replace any tracebacks from
<span class="w"> </span>    within compiled template code with tracebacks that look like they
<span class="w"> </span>    came from the template source.
<span class="gu">@@ -20,11 +22,60 @@ def rewrite_traceback_stack(source: t.Optional[str]=None) -&gt;BaseException:</span>
<span class="w"> </span>        known.
<span class="w"> </span>    :return: The original exception with the rewritten traceback.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _, exc_value, tb = sys.exc_info()</span>
<span class="gi">+    exc_value = t.cast(BaseException, exc_value)</span>
<span class="gi">+    tb = t.cast(TracebackType, tb)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(exc_value, TemplateSyntaxError) and not exc_value.translated:</span>
<span class="gi">+        exc_value.translated = True</span>
<span class="gi">+        exc_value.source = source</span>
<span class="gi">+        # Remove the old traceback, otherwise the frames from the</span>
<span class="gi">+        # compiler still show up.</span>
<span class="gi">+        exc_value.with_traceback(None)</span>
<span class="gi">+        # Outside of runtime, so the frame isn&#39;t executing template</span>
<span class="gi">+        # code, but it still needs to point at the template.</span>
<span class="gi">+        tb = fake_traceback(</span>
<span class="gi">+            exc_value, None, exc_value.filename or &quot;&lt;unknown&gt;&quot;, exc_value.lineno</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Skip the frame for the render function.</span>
<span class="gi">+        tb = tb.tb_next</span>
<span class="gi">+</span>
<span class="gi">+    stack = []</span>
<span class="gi">+</span>
<span class="gi">+    # Build the stack of traceback object, replacing any in template</span>
<span class="gi">+    # code with the source file and line information.</span>
<span class="gi">+    while tb is not None:</span>
<span class="gi">+        # Skip frames decorated with @internalcode. These are internal</span>
<span class="gi">+        # calls that aren&#39;t useful in template debugging output.</span>
<span class="gi">+        if tb.tb_frame.f_code in internal_code:</span>
<span class="gi">+            tb = tb.tb_next</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        template = tb.tb_frame.f_globals.get(&quot;__jinja_template__&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if template is not None:</span>
<span class="gi">+            lineno = template.get_corresponding_lineno(tb.tb_lineno)</span>
<span class="gi">+            fake_tb = fake_traceback(exc_value, tb, template.filename, lineno)</span>
<span class="gi">+            stack.append(fake_tb)</span>
<span class="gi">+        else:</span>
<span class="gi">+            stack.append(tb)</span>

<span class="gi">+        tb = tb.tb_next</span>

<span class="gd">-def fake_traceback(exc_value: BaseException, tb: t.Optional[TracebackType],</span>
<span class="gd">-    filename: str, lineno: int) -&gt;TracebackType:</span>
<span class="gi">+    tb_next = None</span>
<span class="gi">+</span>
<span class="gi">+    # Assign tb_next in reverse to avoid circular references.</span>
<span class="gi">+    for tb in reversed(stack):</span>
<span class="gi">+        tb.tb_next = tb_next</span>
<span class="gi">+        tb_next = tb</span>
<span class="gi">+</span>
<span class="gi">+    return exc_value.with_traceback(tb_next)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def fake_traceback(  # type: ignore</span>
<span class="gi">+    exc_value: BaseException, tb: t.Optional[TracebackType], filename: str, lineno: int</span>
<span class="gi">+) -&gt; TracebackType:</span>
<span class="w"> </span>    &quot;&quot;&quot;Produce a new traceback object that looks like it came from the
<span class="w"> </span>    template source instead of the compiled code. The filename, line
<span class="w"> </span>    number, and location name will point to the template, and the local
<span class="gu">@@ -37,12 +88,104 @@ def fake_traceback(exc_value: BaseException, tb: t.Optional[TracebackType],</span>
<span class="w"> </span>    :param filename: The template filename.
<span class="w"> </span>    :param lineno: The line number in the template source.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if tb is not None:</span>
<span class="gi">+        # Replace the real locals with the context that would be</span>
<span class="gi">+        # available at that point in the template.</span>
<span class="gi">+        locals = get_template_locals(tb.tb_frame.f_locals)</span>
<span class="gi">+        locals.pop(&quot;__jinja_exception__&quot;, None)</span>
<span class="gi">+    else:</span>
<span class="gi">+        locals = {}</span>
<span class="gi">+</span>
<span class="gi">+    globals = {</span>
<span class="gi">+        &quot;__name__&quot;: filename,</span>
<span class="gi">+        &quot;__file__&quot;: filename,</span>
<span class="gi">+        &quot;__jinja_exception__&quot;: exc_value,</span>
<span class="gi">+    }</span>
<span class="gi">+    # Raise an exception at the correct line number.</span>
<span class="gi">+    code: CodeType = compile(</span>
<span class="gi">+        &quot;\n&quot; * (lineno - 1) + &quot;raise __jinja_exception__&quot;, filename, &quot;exec&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Build a new code object that points to the template file and</span>
<span class="gi">+    # replaces the location with a block name.</span>
<span class="gi">+    location = &quot;template&quot;</span>

<span class="gi">+    if tb is not None:</span>
<span class="gi">+        function = tb.tb_frame.f_code.co_name</span>

<span class="gd">-def get_template_locals(real_locals: t.Mapping[str, t.Any]) -&gt;t.Dict[str, t.Any</span>
<span class="gd">-    ]:</span>
<span class="gi">+        if function == &quot;root&quot;:</span>
<span class="gi">+            location = &quot;top-level template code&quot;</span>
<span class="gi">+        elif function.startswith(&quot;block_&quot;):</span>
<span class="gi">+            location = f&quot;block {function[6:]!r}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if sys.version_info &gt;= (3, 8):</span>
<span class="gi">+        code = code.replace(co_name=location)</span>
<span class="gi">+    else:</span>
<span class="gi">+        code = CodeType(</span>
<span class="gi">+            code.co_argcount,</span>
<span class="gi">+            code.co_kwonlyargcount,</span>
<span class="gi">+            code.co_nlocals,</span>
<span class="gi">+            code.co_stacksize,</span>
<span class="gi">+            code.co_flags,</span>
<span class="gi">+            code.co_code,</span>
<span class="gi">+            code.co_consts,</span>
<span class="gi">+            code.co_names,</span>
<span class="gi">+            code.co_varnames,</span>
<span class="gi">+            code.co_filename,</span>
<span class="gi">+            location,</span>
<span class="gi">+            code.co_firstlineno,</span>
<span class="gi">+            code.co_lnotab,</span>
<span class="gi">+            code.co_freevars,</span>
<span class="gi">+            code.co_cellvars,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Execute the new code, which is guaranteed to raise, and return</span>
<span class="gi">+    # the new traceback without this frame.</span>
<span class="gi">+    try:</span>
<span class="gi">+        exec(code, globals, locals)</span>
<span class="gi">+    except BaseException:</span>
<span class="gi">+        return sys.exc_info()[2].tb_next  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_template_locals(real_locals: t.Mapping[str, t.Any]) -&gt; t.Dict[str, t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Based on the runtime locals, get the context that would be
<span class="w"> </span>    available at that point in the template.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Start with the current template context.</span>
<span class="gi">+    ctx: &quot;t.Optional[Context]&quot; = real_locals.get(&quot;context&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if ctx is not None:</span>
<span class="gi">+        data: t.Dict[str, t.Any] = ctx.get_all().copy()</span>
<span class="gi">+    else:</span>
<span class="gi">+        data = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Might be in a derived context that only sets local variables</span>
<span class="gi">+    # rather than pushing a context. Local variables follow the scheme</span>
<span class="gi">+    # l_depth_name. Find the highest-depth local that has a value for</span>
<span class="gi">+    # each name.</span>
<span class="gi">+    local_overrides: t.Dict[str, t.Tuple[int, t.Any]] = {}</span>
<span class="gi">+</span>
<span class="gi">+    for name, value in real_locals.items():</span>
<span class="gi">+        if not name.startswith(&quot;l_&quot;) or value is missing:</span>
<span class="gi">+            # Not a template variable, or no longer relevant.</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            _, depth_str, name = name.split(&quot;_&quot;, 2)</span>
<span class="gi">+            depth = int(depth_str)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        cur_depth = local_overrides.get(name, (-1,))[0]</span>
<span class="gi">+</span>
<span class="gi">+        if cur_depth &lt; depth:</span>
<span class="gi">+            local_overrides[name] = (depth, value)</span>
<span class="gi">+</span>
<span class="gi">+    # Modify the context with any derived context.</span>
<span class="gi">+    for name, (_, value) in local_overrides.items():</span>
<span class="gi">+        if value is missing:</span>
<span class="gi">+            data.pop(name, None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            data[name] = value</span>
<span class="gi">+</span>
<span class="gi">+    return data</span>
<span class="gh">diff --git a/src/jinja2/defaults.py b/src/jinja2/defaults.py</span>
<span class="gh">index 07ecd67..638cad3 100644</span>
<span class="gd">--- a/src/jinja2/defaults.py</span>
<span class="gi">+++ b/src/jinja2/defaults.py</span>
<span class="gu">@@ -1,28 +1,48 @@</span>
<span class="w"> </span>import typing as t
<span class="gd">-from .filters import FILTERS as DEFAULT_FILTERS</span>
<span class="gd">-from .tests import TESTS as DEFAULT_TESTS</span>
<span class="gi">+</span>
<span class="gi">+from .filters import FILTERS as DEFAULT_FILTERS  # noqa: F401</span>
<span class="gi">+from .tests import TESTS as DEFAULT_TESTS  # noqa: F401</span>
<span class="w"> </span>from .utils import Cycler
<span class="w"> </span>from .utils import generate_lorem_ipsum
<span class="w"> </span>from .utils import Joiner
<span class="w"> </span>from .utils import Namespace
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gd">-BLOCK_START_STRING = &#39;{%&#39;</span>
<span class="gd">-BLOCK_END_STRING = &#39;%}&#39;</span>
<span class="gd">-VARIABLE_START_STRING = &#39;{{&#39;</span>
<span class="gd">-VARIABLE_END_STRING = &#39;}}&#39;</span>
<span class="gd">-COMMENT_START_STRING = &#39;{#&#39;</span>
<span class="gd">-COMMENT_END_STRING = &#39;#}&#39;</span>
<span class="gi">+</span>
<span class="gi">+# defaults for the parser / lexer</span>
<span class="gi">+BLOCK_START_STRING = &quot;{%&quot;</span>
<span class="gi">+BLOCK_END_STRING = &quot;%}&quot;</span>
<span class="gi">+VARIABLE_START_STRING = &quot;{{&quot;</span>
<span class="gi">+VARIABLE_END_STRING = &quot;}}&quot;</span>
<span class="gi">+COMMENT_START_STRING = &quot;{#&quot;</span>
<span class="gi">+COMMENT_END_STRING = &quot;#}&quot;</span>
<span class="w"> </span>LINE_STATEMENT_PREFIX: t.Optional[str] = None
<span class="w"> </span>LINE_COMMENT_PREFIX: t.Optional[str] = None
<span class="w"> </span>TRIM_BLOCKS = False
<span class="w"> </span>LSTRIP_BLOCKS = False
<span class="gd">-NEWLINE_SEQUENCE: &quot;te.Literal[&#39;\\n&#39;, &#39;\\r\\n&#39;, &#39;\\r&#39;]&quot; = &#39;\n&#39;</span>
<span class="gi">+NEWLINE_SEQUENCE: &quot;te.Literal[&#39;\\n&#39;, &#39;\\r\\n&#39;, &#39;\\r&#39;]&quot; = &quot;\n&quot;</span>
<span class="w"> </span>KEEP_TRAILING_NEWLINE = False
<span class="gd">-DEFAULT_NAMESPACE = {&#39;range&#39;: range, &#39;dict&#39;: dict, &#39;lipsum&#39;:</span>
<span class="gd">-    generate_lorem_ipsum, &#39;cycler&#39;: Cycler, &#39;joiner&#39;: Joiner, &#39;namespace&#39;:</span>
<span class="gd">-    Namespace}</span>
<span class="gd">-DEFAULT_POLICIES: t.Dict[str, t.Any] = {&#39;compiler.ascii_str&#39;: True,</span>
<span class="gd">-    &#39;urlize.rel&#39;: &#39;noopener&#39;, &#39;urlize.target&#39;: None, &#39;urlize.extra_schemes&#39;:</span>
<span class="gd">-    None, &#39;truncate.leeway&#39;: 5, &#39;json.dumps_function&#39;: None,</span>
<span class="gd">-    &#39;json.dumps_kwargs&#39;: {&#39;sort_keys&#39;: True}, &#39;ext.i18n.trimmed&#39;: False}</span>
<span class="gi">+</span>
<span class="gi">+# default filters, tests and namespace</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_NAMESPACE = {</span>
<span class="gi">+    &quot;range&quot;: range,</span>
<span class="gi">+    &quot;dict&quot;: dict,</span>
<span class="gi">+    &quot;lipsum&quot;: generate_lorem_ipsum,</span>
<span class="gi">+    &quot;cycler&quot;: Cycler,</span>
<span class="gi">+    &quot;joiner&quot;: Joiner,</span>
<span class="gi">+    &quot;namespace&quot;: Namespace,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+# default policies</span>
<span class="gi">+DEFAULT_POLICIES: t.Dict[str, t.Any] = {</span>
<span class="gi">+    &quot;compiler.ascii_str&quot;: True,</span>
<span class="gi">+    &quot;urlize.rel&quot;: &quot;noopener&quot;,</span>
<span class="gi">+    &quot;urlize.target&quot;: None,</span>
<span class="gi">+    &quot;urlize.extra_schemes&quot;: None,</span>
<span class="gi">+    &quot;truncate.leeway&quot;: 5,</span>
<span class="gi">+    &quot;json.dumps_function&quot;: None,</span>
<span class="gi">+    &quot;json.dumps_kwargs&quot;: {&quot;sort_keys&quot;: True},</span>
<span class="gi">+    &quot;ext.i18n.trimmed&quot;: False,</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/src/jinja2/environment.py b/src/jinja2/environment.py</span>
<span class="gh">index aae9f98..1d3be0b 100644</span>
<span class="gd">--- a/src/jinja2/environment.py</span>
<span class="gi">+++ b/src/jinja2/environment.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Classes for managing templates and their runtime and compile time
<span class="w"> </span>options.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import typing
<span class="w"> </span>import typing as t
<span class="gu">@@ -10,7 +11,9 @@ from functools import lru_cache</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from functools import reduce
<span class="w"> </span>from types import CodeType
<span class="gi">+</span>
<span class="w"> </span>from markupsafe import Markup
<span class="gi">+</span>
<span class="w"> </span>from . import nodes
<span class="w"> </span>from .compiler import CodeGenerator
<span class="w"> </span>from .compiler import generate
<span class="gu">@@ -18,10 +21,10 @@ from .defaults import BLOCK_END_STRING</span>
<span class="w"> </span>from .defaults import BLOCK_START_STRING
<span class="w"> </span>from .defaults import COMMENT_END_STRING
<span class="w"> </span>from .defaults import COMMENT_START_STRING
<span class="gd">-from .defaults import DEFAULT_FILTERS</span>
<span class="gi">+from .defaults import DEFAULT_FILTERS  # type: ignore[attr-defined]</span>
<span class="w"> </span>from .defaults import DEFAULT_NAMESPACE
<span class="w"> </span>from .defaults import DEFAULT_POLICIES
<span class="gd">-from .defaults import DEFAULT_TESTS</span>
<span class="gi">+from .defaults import DEFAULT_TESTS  # type: ignore[attr-defined]</span>
<span class="w"> </span>from .defaults import KEEP_TRAILING_NEWLINE
<span class="w"> </span>from .defaults import LINE_COMMENT_PREFIX
<span class="w"> </span>from .defaults import LINE_STATEMENT_PREFIX
<span class="gu">@@ -50,17 +53,20 @@ from .utils import import_string</span>
<span class="w"> </span>from .utils import internalcode
<span class="w"> </span>from .utils import LRUCache
<span class="w"> </span>from .utils import missing
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gi">+</span>
<span class="w"> </span>    from .bccache import BytecodeCache
<span class="w"> </span>    from .ext import Extension
<span class="w"> </span>    from .loaders import BaseLoader
<span class="gd">-_env_bound = t.TypeVar(&#39;_env_bound&#39;, bound=&#39;Environment&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_env_bound = t.TypeVar(&quot;_env_bound&quot;, bound=&quot;Environment&quot;)</span>


<span class="gi">+# for direct template usage we have up to ten living environments</span>
<span class="w"> </span>@lru_cache(maxsize=10)
<span class="gd">-def get_spontaneous_environment(cls: t.Type[_env_bound], *args: t.Any</span>
<span class="gd">-    ) -&gt;_env_bound:</span>
<span class="gi">+def get_spontaneous_environment(cls: t.Type[_env_bound], *args: t.Any) -&gt; _env_bound:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a new spontaneous environment. A spontaneous environment
<span class="w"> </span>    is used for templates created directly rather than through an
<span class="w"> </span>    existing environment.
<span class="gu">@@ -68,36 +74,75 @@ def get_spontaneous_environment(cls: t.Type[_env_bound], *args: t.Any</span>
<span class="w"> </span>    :param cls: Environment class to create.
<span class="w"> </span>    :param args: Positional arguments passed to environment.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    env = cls(*args)</span>
<span class="gi">+    env.shared = True</span>
<span class="gi">+    return env</span>


<span class="gd">-def create_cache(size: int) -&gt;t.Optional[t.MutableMapping[t.Tuple[</span>
<span class="gd">-    &#39;weakref.ref[t.Any]&#39;, str], &#39;Template&#39;]]:</span>
<span class="gi">+def create_cache(</span>
<span class="gi">+    size: int,</span>
<span class="gi">+) -&gt; t.Optional[t.MutableMapping[t.Tuple[&quot;weakref.ref[t.Any]&quot;, str], &quot;Template&quot;]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the cache class for the given size.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if size == 0:</span>
<span class="gi">+        return None</span>

<span class="gi">+    if size &lt; 0:</span>
<span class="gi">+        return {}</span>

<span class="gd">-def copy_cache(cache: t.Optional[t.MutableMapping[t.Any, t.Any]]) -&gt;t.Optional[</span>
<span class="gd">-    t.MutableMapping[t.Tuple[&#39;weakref.ref[t.Any]&#39;, str], &#39;Template&#39;]]:</span>
<span class="gi">+    return LRUCache(size)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def copy_cache(</span>
<span class="gi">+    cache: t.Optional[t.MutableMapping[t.Any, t.Any]],</span>
<span class="gi">+) -&gt; t.Optional[t.MutableMapping[t.Tuple[&quot;weakref.ref[t.Any]&quot;, str], &quot;Template&quot;]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an empty copy of the given cache.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cache is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if type(cache) is dict:  # noqa E721</span>
<span class="gi">+        return {}</span>

<span class="gi">+    return LRUCache(cache.capacity)  # type: ignore</span>

<span class="gd">-def load_extensions(environment: &#39;Environment&#39;, extensions: t.Sequence[t.</span>
<span class="gd">-    Union[str, t.Type[&#39;Extension&#39;]]]) -&gt;t.Dict[str, &#39;Extension&#39;]:</span>
<span class="gi">+</span>
<span class="gi">+def load_extensions(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    extensions: t.Sequence[t.Union[str, t.Type[&quot;Extension&quot;]]],</span>
<span class="gi">+) -&gt; t.Dict[str, &quot;Extension&quot;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Load the extensions from the list and bind it to the environment.
<span class="w"> </span>    Returns a dict of instantiated extensions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {}</span>
<span class="gi">+</span>
<span class="gi">+    for extension in extensions:</span>
<span class="gi">+        if isinstance(extension, str):</span>
<span class="gi">+            extension = t.cast(t.Type[&quot;Extension&quot;], import_string(extension))</span>
<span class="gi">+</span>
<span class="gi">+        result[extension.identifier] = extension(environment)</span>

<span class="gi">+    return result</span>

<span class="gd">-def _environment_config_check(environment: &#39;Environment&#39;) -&gt;&#39;Environment&#39;:</span>
<span class="gi">+</span>
<span class="gi">+def _environment_config_check(environment: &quot;Environment&quot;) -&gt; &quot;Environment&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Perform a sanity check on the environment.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert issubclass(</span>
<span class="gi">+        environment.undefined, Undefined</span>
<span class="gi">+    ), &quot;&#39;undefined&#39; must be a subclass of &#39;jinja2.Undefined&#39;.&quot;</span>
<span class="gi">+    assert (</span>
<span class="gi">+        environment.block_start_string</span>
<span class="gi">+        != environment.variable_start_string</span>
<span class="gi">+        != environment.comment_start_string</span>
<span class="gi">+    ), &quot;block, variable and comment start strings must be different.&quot;</span>
<span class="gi">+    assert environment.newline_sequence in {</span>
<span class="gi">+        &quot;\r&quot;,</span>
<span class="gi">+        &quot;\r\n&quot;,</span>
<span class="gi">+        &quot;\n&quot;,</span>
<span class="gi">+    }, &quot;&#39;newline_sequence&#39; must be one of &#39;\\n&#39;, &#39;\\r\\n&#39;, or &#39;\\r&#39;.&quot;</span>
<span class="gi">+    return environment</span>


<span class="w"> </span>class Environment:
<span class="gd">-    &quot;&quot;&quot;The core component of Jinja is the `Environment`.  It contains</span>
<span class="gi">+    r&quot;&quot;&quot;The core component of Jinja is the `Environment`.  It contains</span>
<span class="w"> </span>    important shared variables like configuration, filters, tests,
<span class="w"> </span>    globals and others.  Instances of this class may be modified if
<span class="w"> </span>    they are not shared and if no template was loaded so far.
<span class="gu">@@ -145,8 +190,8 @@ class Environment:</span>
<span class="w"> </span>            from the start of a line to a block.  Defaults to `False`.

<span class="w"> </span>        `newline_sequence`
<span class="gd">-            The sequence that starts a newline.  Must be one of ``&#39;\\r&#39;``,</span>
<span class="gd">-            ``&#39;\\n&#39;`` or ``&#39;\\r\\n&#39;``.  The default is ``&#39;\\n&#39;`` which is a</span>
<span class="gi">+            The sequence that starts a newline.  Must be one of ``&#39;\r&#39;``,</span>
<span class="gi">+            ``&#39;\n&#39;`` or ``&#39;\r\n&#39;``.  The default is ``&#39;\n&#39;`` which is a</span>
<span class="w"> </span>            useful default for Linux and OS X systems as well as web
<span class="w"> </span>            applications.

<span class="gu">@@ -217,31 +262,72 @@ class Environment:</span>
<span class="w"> </span>            If set to true this enables async template execution which
<span class="w"> </span>            allows using async functions and generators.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: if this environment is sandboxed.  Modifying this variable won&#39;t make</span>
<span class="gi">+    #: the environment sandboxed though.  For a real sandboxed environment</span>
<span class="gi">+    #: have a look at jinja2.sandbox.  This flag alone controls the code</span>
<span class="gi">+    #: generation by the compiler.</span>
<span class="w"> </span>    sandboxed = False
<span class="gi">+</span>
<span class="gi">+    #: True if the environment is just an overlay</span>
<span class="w"> </span>    overlayed = False
<span class="gd">-    linked_to: t.Optional[&#39;Environment&#39;] = None</span>
<span class="gi">+</span>
<span class="gi">+    #: the environment this environment is linked to if it is an overlay</span>
<span class="gi">+    linked_to: t.Optional[&quot;Environment&quot;] = None</span>
<span class="gi">+</span>
<span class="gi">+    #: shared environments have this set to `True`.  A shared environment</span>
<span class="gi">+    #: must not be modified</span>
<span class="w"> </span>    shared = False
<span class="gd">-    code_generator_class: t.Type[&#39;CodeGenerator&#39;] = CodeGenerator</span>
<span class="gd">-    concat = &#39;&#39;.join</span>
<span class="gi">+</span>
<span class="gi">+    #: the class that is used for code generation.  See</span>
<span class="gi">+    #: :class:`~jinja2.compiler.CodeGenerator` for more information.</span>
<span class="gi">+    code_generator_class: t.Type[&quot;CodeGenerator&quot;] = CodeGenerator</span>
<span class="gi">+</span>
<span class="gi">+    concat = &quot;&quot;.join</span>
<span class="gi">+</span>
<span class="gi">+    #: the context class that is used for templates.  See</span>
<span class="gi">+    #: :class:`~jinja2.runtime.Context` for more information.</span>
<span class="w"> </span>    context_class: t.Type[Context] = Context
<span class="gd">-    template_class: t.Type[&#39;Template&#39;]</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, block_start_string: str=BLOCK_START_STRING,</span>
<span class="gd">-        block_end_string: str=BLOCK_END_STRING, variable_start_string: str=</span>
<span class="gd">-        VARIABLE_START_STRING, variable_end_string: str=VARIABLE_END_STRING,</span>
<span class="gd">-        comment_start_string: str=COMMENT_START_STRING, comment_end_string:</span>
<span class="gd">-        str=COMMENT_END_STRING, line_statement_prefix: t.Optional[str]=</span>
<span class="gd">-        LINE_STATEMENT_PREFIX, line_comment_prefix: t.Optional[str]=</span>
<span class="gd">-        LINE_COMMENT_PREFIX, trim_blocks: bool=TRIM_BLOCKS, lstrip_blocks:</span>
<span class="gd">-        bool=LSTRIP_BLOCKS, newline_sequence:</span>
<span class="gd">-        &quot;te.Literal[&#39;\\n&#39;, &#39;\\r\\n&#39;, &#39;\\r&#39;]&quot;=NEWLINE_SEQUENCE,</span>
<span class="gd">-        keep_trailing_newline: bool=KEEP_TRAILING_NEWLINE, extensions: t.</span>
<span class="gd">-        Sequence[t.Union[str, t.Type[&#39;Extension&#39;]]]=(), optimized: bool=</span>
<span class="gd">-        True, undefined: t.Type[Undefined]=Undefined, finalize: t.Optional[</span>
<span class="gd">-        t.Callable[..., t.Any]]=None, autoescape: t.Union[bool, t.Callable[</span>
<span class="gd">-        [t.Optional[str]], bool]]=False, loader: t.Optional[&#39;BaseLoader&#39;]=</span>
<span class="gd">-        None, cache_size: int=400, auto_reload: bool=True, bytecode_cache:</span>
<span class="gd">-        t.Optional[&#39;BytecodeCache&#39;]=None, enable_async: bool=False):</span>
<span class="gi">+</span>
<span class="gi">+    template_class: t.Type[&quot;Template&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        block_start_string: str = BLOCK_START_STRING,</span>
<span class="gi">+        block_end_string: str = BLOCK_END_STRING,</span>
<span class="gi">+        variable_start_string: str = VARIABLE_START_STRING,</span>
<span class="gi">+        variable_end_string: str = VARIABLE_END_STRING,</span>
<span class="gi">+        comment_start_string: str = COMMENT_START_STRING,</span>
<span class="gi">+        comment_end_string: str = COMMENT_END_STRING,</span>
<span class="gi">+        line_statement_prefix: t.Optional[str] = LINE_STATEMENT_PREFIX,</span>
<span class="gi">+        line_comment_prefix: t.Optional[str] = LINE_COMMENT_PREFIX,</span>
<span class="gi">+        trim_blocks: bool = TRIM_BLOCKS,</span>
<span class="gi">+        lstrip_blocks: bool = LSTRIP_BLOCKS,</span>
<span class="gi">+        newline_sequence: &quot;te.Literal[&#39;\\n&#39;, &#39;\\r\\n&#39;, &#39;\\r&#39;]&quot; = NEWLINE_SEQUENCE,</span>
<span class="gi">+        keep_trailing_newline: bool = KEEP_TRAILING_NEWLINE,</span>
<span class="gi">+        extensions: t.Sequence[t.Union[str, t.Type[&quot;Extension&quot;]]] = (),</span>
<span class="gi">+        optimized: bool = True,</span>
<span class="gi">+        undefined: t.Type[Undefined] = Undefined,</span>
<span class="gi">+        finalize: t.Optional[t.Callable[..., t.Any]] = None,</span>
<span class="gi">+        autoescape: t.Union[bool, t.Callable[[t.Optional[str]], bool]] = False,</span>
<span class="gi">+        loader: t.Optional[&quot;BaseLoader&quot;] = None,</span>
<span class="gi">+        cache_size: int = 400,</span>
<span class="gi">+        auto_reload: bool = True,</span>
<span class="gi">+        bytecode_cache: t.Optional[&quot;BytecodeCache&quot;] = None,</span>
<span class="gi">+        enable_async: bool = False,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # !!Important notice!!</span>
<span class="gi">+        #   The constructor accepts quite a few arguments that should be</span>
<span class="gi">+        #   passed by keyword rather than position.  However it&#39;s important to</span>
<span class="gi">+        #   not change the order of arguments because it&#39;s used at least</span>
<span class="gi">+        #   internally in those cases:</span>
<span class="gi">+        #       -   spontaneous environments (i18n extension and Template)</span>
<span class="gi">+        #       -   unittests</span>
<span class="gi">+        #   If parameter changes are required only add parameters at the end</span>
<span class="gi">+        #   and don&#39;t change the arguments (or the defaults!) of the arguments</span>
<span class="gi">+        #   existing already.</span>
<span class="gi">+</span>
<span class="gi">+        # lexer / parser information</span>
<span class="w"> </span>        self.block_start_string = block_start_string
<span class="w"> </span>        self.block_end_string = block_end_string
<span class="w"> </span>        self.variable_start_string = variable_start_string
<span class="gu">@@ -254,52 +340,74 @@ class Environment:</span>
<span class="w"> </span>        self.lstrip_blocks = lstrip_blocks
<span class="w"> </span>        self.newline_sequence = newline_sequence
<span class="w"> </span>        self.keep_trailing_newline = keep_trailing_newline
<span class="gi">+</span>
<span class="gi">+        # runtime information</span>
<span class="w"> </span>        self.undefined: t.Type[Undefined] = undefined
<span class="w"> </span>        self.optimized = optimized
<span class="w"> </span>        self.finalize = finalize
<span class="w"> </span>        self.autoescape = autoescape
<span class="gi">+</span>
<span class="gi">+        # defaults</span>
<span class="w"> </span>        self.filters = DEFAULT_FILTERS.copy()
<span class="w"> </span>        self.tests = DEFAULT_TESTS.copy()
<span class="w"> </span>        self.globals = DEFAULT_NAMESPACE.copy()
<span class="gi">+</span>
<span class="gi">+        # set the loader provided</span>
<span class="w"> </span>        self.loader = loader
<span class="w"> </span>        self.cache = create_cache(cache_size)
<span class="w"> </span>        self.bytecode_cache = bytecode_cache
<span class="w"> </span>        self.auto_reload = auto_reload
<span class="gi">+</span>
<span class="gi">+        # configurable policies</span>
<span class="w"> </span>        self.policies = DEFAULT_POLICIES.copy()
<span class="gi">+</span>
<span class="gi">+        # load extensions</span>
<span class="w"> </span>        self.extensions = load_extensions(self, extensions)
<span class="gi">+</span>
<span class="w"> </span>        self.is_async = enable_async
<span class="w"> </span>        _environment_config_check(self)

<span class="gd">-    def add_extension(self, extension: t.Union[str, t.Type[&#39;Extension&#39;]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def add_extension(self, extension: t.Union[str, t.Type[&quot;Extension&quot;]]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds an extension after the environment was created.

<span class="w"> </span>        .. versionadded:: 2.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.extensions.update(load_extensions(self, [extension]))</span>

<span class="gd">-    def extend(self, **attributes: t.Any) -&gt;None:</span>
<span class="gi">+    def extend(self, **attributes: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add the items to the instance of the environment if they do not exist
<span class="w"> </span>        yet.  This is used by :ref:`extensions &lt;writing-extensions&gt;` to register
<span class="w"> </span>        callbacks and configuration values without breaking inheritance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def overlay(self, block_start_string: str=missing, block_end_string:</span>
<span class="gd">-        str=missing, variable_start_string: str=missing,</span>
<span class="gd">-        variable_end_string: str=missing, comment_start_string: str=missing,</span>
<span class="gd">-        comment_end_string: str=missing, line_statement_prefix: t.Optional[</span>
<span class="gd">-        str]=missing, line_comment_prefix: t.Optional[str]=missing,</span>
<span class="gd">-        trim_blocks: bool=missing, lstrip_blocks: bool=missing,</span>
<span class="gd">-        newline_sequence: &quot;te.Literal[&#39;\\n&#39;, &#39;\\r\\n&#39;, &#39;\\r&#39;]&quot;=missing,</span>
<span class="gd">-        keep_trailing_newline: bool=missing, extensions: t.Sequence[t.Union</span>
<span class="gd">-        [str, t.Type[&#39;Extension&#39;]]]=missing, optimized: bool=missing,</span>
<span class="gd">-        undefined: t.Type[Undefined]=missing, finalize: t.Optional[t.</span>
<span class="gd">-        Callable[..., t.Any]]=missing, autoescape: t.Union[bool, t.Callable</span>
<span class="gd">-        [[t.Optional[str]], bool]]=missing, loader: t.Optional[&#39;BaseLoader&#39;</span>
<span class="gd">-        ]=missing, cache_size: int=missing, auto_reload: bool=missing,</span>
<span class="gd">-        bytecode_cache: t.Optional[&#39;BytecodeCache&#39;]=missing, enable_async:</span>
<span class="gd">-        bool=False) -&gt;&#39;Environment&#39;:</span>
<span class="gi">+        for key, value in attributes.items():</span>
<span class="gi">+            if not hasattr(self, key):</span>
<span class="gi">+                setattr(self, key, value)</span>
<span class="gi">+</span>
<span class="gi">+    def overlay(</span>
<span class="gi">+        self,</span>
<span class="gi">+        block_start_string: str = missing,</span>
<span class="gi">+        block_end_string: str = missing,</span>
<span class="gi">+        variable_start_string: str = missing,</span>
<span class="gi">+        variable_end_string: str = missing,</span>
<span class="gi">+        comment_start_string: str = missing,</span>
<span class="gi">+        comment_end_string: str = missing,</span>
<span class="gi">+        line_statement_prefix: t.Optional[str] = missing,</span>
<span class="gi">+        line_comment_prefix: t.Optional[str] = missing,</span>
<span class="gi">+        trim_blocks: bool = missing,</span>
<span class="gi">+        lstrip_blocks: bool = missing,</span>
<span class="gi">+        newline_sequence: &quot;te.Literal[&#39;\\n&#39;, &#39;\\r\\n&#39;, &#39;\\r&#39;]&quot; = missing,</span>
<span class="gi">+        keep_trailing_newline: bool = missing,</span>
<span class="gi">+        extensions: t.Sequence[t.Union[str, t.Type[&quot;Extension&quot;]]] = missing,</span>
<span class="gi">+        optimized: bool = missing,</span>
<span class="gi">+        undefined: t.Type[Undefined] = missing,</span>
<span class="gi">+        finalize: t.Optional[t.Callable[..., t.Any]] = missing,</span>
<span class="gi">+        autoescape: t.Union[bool, t.Callable[[t.Optional[str]], bool]] = missing,</span>
<span class="gi">+        loader: t.Optional[&quot;BaseLoader&quot;] = missing,</span>
<span class="gi">+        cache_size: int = missing,</span>
<span class="gi">+        auto_reload: bool = missing,</span>
<span class="gi">+        bytecode_cache: t.Optional[&quot;BytecodeCache&quot;] = missing,</span>
<span class="gi">+        enable_async: bool = False,</span>
<span class="gi">+    ) -&gt; &quot;Environment&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new overlay environment that shares all the data with the
<span class="w"> </span>        current environment except for cache and the overridden attributes.
<span class="w"> </span>        Extensions cannot be removed for an overlayed environment.  An overlayed
<span class="gu">@@ -315,32 +423,138 @@ class Environment:</span>
<span class="w"> </span>            Added the ``newline_sequence``,, ``keep_trailing_newline``,
<span class="w"> </span>            and ``enable_async`` parameters to match ``__init__``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        args = dict(locals())</span>
<span class="gi">+        del args[&quot;self&quot;], args[&quot;cache_size&quot;], args[&quot;extensions&quot;], args[&quot;enable_async&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        rv = object.__new__(self.__class__)</span>
<span class="gi">+        rv.__dict__.update(self.__dict__)</span>
<span class="gi">+        rv.overlayed = True</span>
<span class="gi">+        rv.linked_to = self</span>
<span class="gi">+</span>
<span class="gi">+        for key, value in args.items():</span>
<span class="gi">+            if value is not missing:</span>
<span class="gi">+                setattr(rv, key, value)</span>
<span class="gi">+</span>
<span class="gi">+        if cache_size is not missing:</span>
<span class="gi">+            rv.cache = create_cache(cache_size)</span>
<span class="gi">+        else:</span>
<span class="gi">+            rv.cache = copy_cache(self.cache)</span>
<span class="gi">+</span>
<span class="gi">+        rv.extensions = {}</span>
<span class="gi">+        for key, value in self.extensions.items():</span>
<span class="gi">+            rv.extensions[key] = value.bind(rv)</span>
<span class="gi">+        if extensions is not missing:</span>
<span class="gi">+            rv.extensions.update(load_extensions(rv, extensions))</span>
<span class="gi">+</span>
<span class="gi">+        if enable_async is not missing:</span>
<span class="gi">+            rv.is_async = enable_async</span>
<span class="gi">+</span>
<span class="gi">+        return _environment_config_check(rv)</span>

<span class="w"> </span>    @property
<span class="gd">-    def lexer(self) -&gt;Lexer:</span>
<span class="gi">+    def lexer(self) -&gt; Lexer:</span>
<span class="w"> </span>        &quot;&quot;&quot;The lexer for this environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return get_lexer(self)</span>

<span class="gd">-    def iter_extensions(self) -&gt;t.Iterator[&#39;Extension&#39;]:</span>
<span class="gi">+    def iter_extensions(self) -&gt; t.Iterator[&quot;Extension&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterates over the extensions by priority.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return iter(sorted(self.extensions.values(), key=lambda x: x.priority))</span>

<span class="gd">-    def getitem(self, obj: t.Any, argument: t.Union[str, t.Any]) -&gt;t.Union[</span>
<span class="gd">-        t.Any, Undefined]:</span>
<span class="gi">+    def getitem(</span>
<span class="gi">+        self, obj: t.Any, argument: t.Union[str, t.Any]</span>
<span class="gi">+    ) -&gt; t.Union[t.Any, Undefined]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get an item or attribute of an object but prefer the item.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def getattr(self, obj: t.Any, attribute: str) -&gt;t.Any:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return obj[argument]</span>
<span class="gi">+        except (AttributeError, TypeError, LookupError):</span>
<span class="gi">+            if isinstance(argument, str):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    attr = str(argument)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        return getattr(obj, attr)</span>
<span class="gi">+                    except AttributeError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+            return self.undefined(obj=obj, name=argument)</span>
<span class="gi">+</span>
<span class="gi">+    def getattr(self, obj: t.Any, attribute: str) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get an item or attribute of an object but prefer the attribute.
<span class="w"> </span>        Unlike :meth:`getitem` the attribute *must* be a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def call_filter(self, name: str, value: t.Any, args: t.Optional[t.</span>
<span class="gd">-        Sequence[t.Any]]=None, kwargs: t.Optional[t.Mapping[str, t.Any]]=</span>
<span class="gd">-        None, context: t.Optional[Context]=None, eval_ctx: t.Optional[</span>
<span class="gd">-        EvalContext]=None) -&gt;t.Any:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return getattr(obj, attribute)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return obj[attribute]</span>
<span class="gi">+        except (TypeError, LookupError, AttributeError):</span>
<span class="gi">+            return self.undefined(obj=obj, name=attribute)</span>
<span class="gi">+</span>
<span class="gi">+    def _filter_test_common(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: t.Union[str, Undefined],</span>
<span class="gi">+        value: t.Any,</span>
<span class="gi">+        args: t.Optional[t.Sequence[t.Any]],</span>
<span class="gi">+        kwargs: t.Optional[t.Mapping[str, t.Any]],</span>
<span class="gi">+        context: t.Optional[Context],</span>
<span class="gi">+        eval_ctx: t.Optional[EvalContext],</span>
<span class="gi">+        is_filter: bool,</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        if is_filter:</span>
<span class="gi">+            env_map = self.filters</span>
<span class="gi">+            type_name = &quot;filter&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            env_map = self.tests</span>
<span class="gi">+            type_name = &quot;test&quot;</span>
<span class="gi">+</span>
<span class="gi">+        func = env_map.get(name)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        if func is None:</span>
<span class="gi">+            msg = f&quot;No {type_name} named {name!r}.&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(name, Undefined):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    name._fail_with_undefined_error()</span>
<span class="gi">+                except Exception as e:</span>
<span class="gi">+                    msg = f&quot;{msg} ({e}; did you forget to quote the callable name?)&quot;</span>
<span class="gi">+</span>
<span class="gi">+            raise TemplateRuntimeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        args = [value, *(args if args is not None else ())]</span>
<span class="gi">+        kwargs = kwargs if kwargs is not None else {}</span>
<span class="gi">+        pass_arg = _PassArg.from_obj(func)</span>
<span class="gi">+</span>
<span class="gi">+        if pass_arg is _PassArg.context:</span>
<span class="gi">+            if context is None:</span>
<span class="gi">+                raise TemplateRuntimeError(</span>
<span class="gi">+                    f&quot;Attempted to invoke a context {type_name} without context.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            args.insert(0, context)</span>
<span class="gi">+        elif pass_arg is _PassArg.eval_context:</span>
<span class="gi">+            if eval_ctx is None:</span>
<span class="gi">+                if context is not None:</span>
<span class="gi">+                    eval_ctx = context.eval_ctx</span>
<span class="gi">+                else:</span>
<span class="gi">+                    eval_ctx = EvalContext(self)</span>
<span class="gi">+</span>
<span class="gi">+            args.insert(0, eval_ctx)</span>
<span class="gi">+        elif pass_arg is _PassArg.environment:</span>
<span class="gi">+            args.insert(0, self)</span>
<span class="gi">+</span>
<span class="gi">+        return func(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def call_filter(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        value: t.Any,</span>
<span class="gi">+        args: t.Optional[t.Sequence[t.Any]] = None,</span>
<span class="gi">+        kwargs: t.Optional[t.Mapping[str, t.Any]] = None,</span>
<span class="gi">+        context: t.Optional[Context] = None,</span>
<span class="gi">+        eval_ctx: t.Optional[EvalContext] = None,</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invoke a filter on a value the same way the compiler does.

<span class="w"> </span>        This might return a coroutine if the filter is running from an
<span class="gu">@@ -349,12 +563,19 @@ class Environment:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def call_test(self, name: str, value: t.Any, args: t.Optional[t.</span>
<span class="gd">-        Sequence[t.Any]]=None, kwargs: t.Optional[t.Mapping[str, t.Any]]=</span>
<span class="gd">-        None, context: t.Optional[Context]=None, eval_ctx: t.Optional[</span>
<span class="gd">-        EvalContext]=None) -&gt;t.Any:</span>
<span class="gi">+        return self._filter_test_common(</span>
<span class="gi">+            name, value, args, kwargs, context, eval_ctx, True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def call_test(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        value: t.Any,</span>
<span class="gi">+        args: t.Optional[t.Sequence[t.Any]] = None,</span>
<span class="gi">+        kwargs: t.Optional[t.Mapping[str, t.Any]] = None,</span>
<span class="gi">+        context: t.Optional[Context] = None,</span>
<span class="gi">+        eval_ctx: t.Optional[EvalContext] = None,</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invoke a test on a value the same way the compiler does.

<span class="w"> </span>        This might return a coroutine if the test is running from an
<span class="gu">@@ -367,11 +588,17 @@ class Environment:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._filter_test_common(</span>
<span class="gi">+            name, value, args, kwargs, context, eval_ctx, False</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def parse(self, source: str, name: t.Optional[str]=None, filename: t.</span>
<span class="gd">-        Optional[str]=None) -&gt;nodes.Template:</span>
<span class="gi">+    def parse(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: str,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; nodes.Template:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the sourcecode and return the abstract syntax tree.  This
<span class="w"> </span>        tree of nodes is used by the compiler to convert the template into
<span class="w"> </span>        executable source- or bytecode.  This is useful for debugging or to
<span class="gu">@@ -380,15 +607,23 @@ class Environment:</span>
<span class="w"> </span>        If you are :ref:`developing Jinja extensions &lt;writing-extensions&gt;`
<span class="w"> </span>        this gives you a good overview of the node tree generated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _parse(self, source: str, name: t.Optional[str], filename: t.</span>
<span class="gd">-        Optional[str]) -&gt;nodes.Template:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._parse(source, name, filename)</span>
<span class="gi">+        except TemplateSyntaxError:</span>
<span class="gi">+            self.handle_exception(source=source)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse(</span>
<span class="gi">+        self, source: str, name: t.Optional[str], filename: t.Optional[str]</span>
<span class="gi">+    ) -&gt; nodes.Template:</span>
<span class="w"> </span>        &quot;&quot;&quot;Internal parsing function used by `parse` and `compile`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def lex(self, source: str, name: t.Optional[str]=None, filename: t.</span>
<span class="gd">-        Optional[str]=None) -&gt;t.Iterator[t.Tuple[int, str, str]]:</span>
<span class="gi">+        return Parser(self, source, name, filename).parse()</span>
<span class="gi">+</span>
<span class="gi">+    def lex(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: str,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; t.Iterator[t.Tuple[int, str, str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Lex the given sourcecode and return a generator that yields
<span class="w"> </span>        tokens as tuples in the form ``(lineno, token_type, value)``.
<span class="w"> </span>        This can be useful for :ref:`extension development &lt;writing-extensions&gt;`
<span class="gu">@@ -398,44 +633,107 @@ class Environment:</span>
<span class="w"> </span>        of the extensions to be applied you have to filter source through
<span class="w"> </span>        the :meth:`preprocess` method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def preprocess(self, source: str, name: t.Optional[str]=None, filename:</span>
<span class="gd">-        t.Optional[str]=None) -&gt;str:</span>
<span class="gi">+        source = str(source)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.lexer.tokeniter(source, name, filename)</span>
<span class="gi">+        except TemplateSyntaxError:</span>
<span class="gi">+            self.handle_exception(source=source)</span>
<span class="gi">+</span>
<span class="gi">+    def preprocess(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: str,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Preprocesses the source with all extensions.  This is automatically
<span class="w"> </span>        called for all parsing and compiling methods but *not* for :meth:`lex`
<span class="w"> </span>        because there you usually only want the actual source tokenized.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _tokenize(self, source: str, name: t.Optional[str], filename: t.</span>
<span class="gd">-        Optional[str]=None, state: t.Optional[str]=None) -&gt;TokenStream:</span>
<span class="gi">+        return reduce(</span>
<span class="gi">+            lambda s, e: e.preprocess(s, name, filename),</span>
<span class="gi">+            self.iter_extensions(),</span>
<span class="gi">+            str(source),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _tokenize(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: str,</span>
<span class="gi">+        name: t.Optional[str],</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+        state: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; TokenStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by the parser to do the preprocessing and filtering
<span class="w"> </span>        for all the extensions.  Returns a :class:`~jinja2.lexer.TokenStream`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        source = self.preprocess(source, name, filename)</span>
<span class="gi">+        stream = self.lexer.tokenize(source, name, filename, state)</span>

<span class="gd">-    def _generate(self, source: nodes.Template, name: t.Optional[str],</span>
<span class="gd">-        filename: t.Optional[str], defer_init: bool=False) -&gt;str:</span>
<span class="gi">+        for ext in self.iter_extensions():</span>
<span class="gi">+            stream = ext.filter_stream(stream)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+            if not isinstance(stream, TokenStream):</span>
<span class="gi">+                stream = TokenStream(stream, name, filename)</span>
<span class="gi">+</span>
<span class="gi">+        return stream</span>
<span class="gi">+</span>
<span class="gi">+    def _generate(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: nodes.Template,</span>
<span class="gi">+        name: t.Optional[str],</span>
<span class="gi">+        filename: t.Optional[str],</span>
<span class="gi">+        defer_init: bool = False,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Internal hook that can be overridden to hook a different generate
<span class="w"> </span>        method in.

<span class="w"> </span>        .. versionadded:: 2.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _compile(self, source: str, filename: str) -&gt;CodeType:</span>
<span class="gi">+        return generate(  # type: ignore</span>
<span class="gi">+            source,</span>
<span class="gi">+            self,</span>
<span class="gi">+            name,</span>
<span class="gi">+            filename,</span>
<span class="gi">+            defer_init=defer_init,</span>
<span class="gi">+            optimized=self.optimized,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _compile(self, source: str, filename: str) -&gt; CodeType:</span>
<span class="w"> </span>        &quot;&quot;&quot;Internal hook that can be overridden to hook a different compile
<span class="w"> </span>        method in.

<span class="w"> </span>        .. versionadded:: 2.5
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return compile(source, filename, &quot;exec&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @typing.overload</span>
<span class="gi">+    def compile(  # type: ignore</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: t.Union[str, nodes.Template],</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+        raw: &quot;te.Literal[False]&quot; = False,</span>
<span class="gi">+        defer_init: bool = False,</span>
<span class="gi">+    ) -&gt; CodeType: ...</span>
<span class="gi">+</span>
<span class="gi">+    @typing.overload</span>
<span class="gi">+    def compile(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: t.Union[str, nodes.Template],</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+        raw: &quot;te.Literal[True]&quot; = ...,</span>
<span class="gi">+        defer_init: bool = False,</span>
<span class="gi">+    ) -&gt; str: ...</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def compile(self, source: t.Union[str, nodes.Template], name: t.</span>
<span class="gd">-        Optional[str]=None, filename: t.Optional[str]=None, raw: bool=False,</span>
<span class="gd">-        defer_init: bool=False) -&gt;t.Union[str, CodeType]:</span>
<span class="gi">+    def compile(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: t.Union[str, nodes.Template],</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+        raw: bool = False,</span>
<span class="gi">+        defer_init: bool = False,</span>
<span class="gi">+    ) -&gt; t.Union[str, CodeType]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compile a node or template source code.  The `name` parameter is
<span class="w"> </span>        the load name of the template after it was joined using
<span class="w"> </span>        :meth:`join_path` if necessary, not the filename on the file system.
<span class="gu">@@ -455,10 +753,23 @@ class Environment:</span>
<span class="w"> </span>        .. versionadded:: 2.4
<span class="w"> </span>           `defer_init` parameter added.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def compile_expression(self, source: str, undefined_to_none: bool=True</span>
<span class="gd">-        ) -&gt;&#39;TemplateExpression&#39;:</span>
<span class="gi">+        source_hint = None</span>
<span class="gi">+        try:</span>
<span class="gi">+            if isinstance(source, str):</span>
<span class="gi">+                source_hint = source</span>
<span class="gi">+                source = self._parse(source, name, filename)</span>
<span class="gi">+            source = self._generate(source, name, filename, defer_init=defer_init)</span>
<span class="gi">+            if raw:</span>
<span class="gi">+                return source</span>
<span class="gi">+            if filename is None:</span>
<span class="gi">+                filename = &quot;&lt;template&gt;&quot;</span>
<span class="gi">+            return self._compile(source, filename)</span>
<span class="gi">+        except TemplateSyntaxError:</span>
<span class="gi">+            self.handle_exception(source=source_hint)</span>
<span class="gi">+</span>
<span class="gi">+    def compile_expression(</span>
<span class="gi">+        self, source: str, undefined_to_none: bool = True</span>
<span class="gi">+    ) -&gt; &quot;TemplateExpression&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;A handy helper method that returns a callable that accepts keyword
<span class="w"> </span>        arguments that appear as variables in the expression.  If called it
<span class="w"> </span>        returns the result of the expression.
<span class="gu">@@ -486,13 +797,30 @@ class Environment:</span>

<span class="w"> </span>        .. versionadded:: 2.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def compile_templates(self, target: t.Union[str, &#39;os.PathLike[str]&#39;],</span>
<span class="gd">-        extensions: t.Optional[t.Collection[str]]=None, filter_func: t.</span>
<span class="gd">-        Optional[t.Callable[[str], bool]]=None, zip: t.Optional[str]=</span>
<span class="gd">-        &#39;deflated&#39;, log_function: t.Optional[t.Callable[[str], None]]=None,</span>
<span class="gd">-        ignore_errors: bool=True) -&gt;None:</span>
<span class="gi">+        parser = Parser(self, source, state=&quot;variable&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            expr = parser.parse_expression()</span>
<span class="gi">+            if not parser.stream.eos:</span>
<span class="gi">+                raise TemplateSyntaxError(</span>
<span class="gi">+                    &quot;chunk after expression&quot;, parser.stream.current.lineno, None, None</span>
<span class="gi">+                )</span>
<span class="gi">+            expr.set_environment(self)</span>
<span class="gi">+        except TemplateSyntaxError:</span>
<span class="gi">+            self.handle_exception(source=source)</span>
<span class="gi">+</span>
<span class="gi">+        body = [nodes.Assign(nodes.Name(&quot;result&quot;, &quot;store&quot;), expr, lineno=1)]</span>
<span class="gi">+        template = self.from_string(nodes.Template(body, lineno=1))</span>
<span class="gi">+        return TemplateExpression(template, undefined_to_none)</span>
<span class="gi">+</span>
<span class="gi">+    def compile_templates(</span>
<span class="gi">+        self,</span>
<span class="gi">+        target: t.Union[str, &quot;os.PathLike[str]&quot;],</span>
<span class="gi">+        extensions: t.Optional[t.Collection[str]] = None,</span>
<span class="gi">+        filter_func: t.Optional[t.Callable[[str], bool]] = None,</span>
<span class="gi">+        zip: t.Optional[str] = &quot;deflated&quot;,</span>
<span class="gi">+        log_function: t.Optional[t.Callable[[str], None]] = None,</span>
<span class="gi">+        ignore_errors: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Finds all the templates the loader can find, compiles them
<span class="w"> </span>        and stores them in `target`.  If `zip` is `None`, instead of in a
<span class="w"> </span>        zipfile, the templates will be stored in a directory.
<span class="gu">@@ -510,10 +838,66 @@ class Environment:</span>

<span class="w"> </span>        .. versionadded:: 2.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def list_templates(self, extensions: t.Optional[t.Collection[str]]=None,</span>
<span class="gd">-        filter_func: t.Optional[t.Callable[[str], bool]]=None) -&gt;t.List[str]:</span>
<span class="gi">+        from .loaders import ModuleLoader</span>
<span class="gi">+</span>
<span class="gi">+        if log_function is None:</span>
<span class="gi">+</span>
<span class="gi">+            def log_function(x: str) -&gt; None:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        assert log_function is not None</span>
<span class="gi">+        assert self.loader is not None, &quot;No loader configured.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        def write_file(filename: str, data: str) -&gt; None:</span>
<span class="gi">+            if zip:</span>
<span class="gi">+                info = ZipInfo(filename)</span>
<span class="gi">+                info.external_attr = 0o755 &lt;&lt; 16</span>
<span class="gi">+                zip_file.writestr(info, data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                with open(os.path.join(target, filename), &quot;wb&quot;) as f:</span>
<span class="gi">+                    f.write(data.encode(&quot;utf8&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        if zip is not None:</span>
<span class="gi">+            from zipfile import ZIP_DEFLATED</span>
<span class="gi">+            from zipfile import ZIP_STORED</span>
<span class="gi">+            from zipfile import ZipFile</span>
<span class="gi">+            from zipfile import ZipInfo</span>
<span class="gi">+</span>
<span class="gi">+            zip_file = ZipFile(</span>
<span class="gi">+                target, &quot;w&quot;, dict(deflated=ZIP_DEFLATED, stored=ZIP_STORED)[zip]</span>
<span class="gi">+            )</span>
<span class="gi">+            log_function(f&quot;Compiling into Zip archive {target!r}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not os.path.isdir(target):</span>
<span class="gi">+                os.makedirs(target)</span>
<span class="gi">+            log_function(f&quot;Compiling into folder {target!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            for name in self.list_templates(extensions, filter_func):</span>
<span class="gi">+                source, filename, _ = self.loader.get_source(self, name)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    code = self.compile(source, name, filename, True, True)</span>
<span class="gi">+                except TemplateSyntaxError as e:</span>
<span class="gi">+                    if not ignore_errors:</span>
<span class="gi">+                        raise</span>
<span class="gi">+                    log_function(f&#39;Could not compile &quot;{name}&quot;: {e}&#39;)</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                filename = ModuleLoader.get_module_filename(name)</span>
<span class="gi">+</span>
<span class="gi">+                write_file(filename, code)</span>
<span class="gi">+                log_function(f&#39;Compiled &quot;{name}&quot; as {filename}&#39;)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if zip:</span>
<span class="gi">+                zip_file.close()</span>
<span class="gi">+</span>
<span class="gi">+        log_function(&quot;Finished compiling templates&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def list_templates(</span>
<span class="gi">+        self,</span>
<span class="gi">+        extensions: t.Optional[t.Collection[str]] = None,</span>
<span class="gi">+        filter_func: t.Optional[t.Callable[[str], bool]] = None,</span>
<span class="gi">+    ) -&gt; t.List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a list of templates for this environment.  This requires
<span class="w"> </span>        that the loader supports the loader&#39;s
<span class="w"> </span>        :meth:`~BaseLoader.list_templates` method.
<span class="gu">@@ -529,15 +913,32 @@ class Environment:</span>

<span class="w"> </span>        .. versionadded:: 2.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.loader is not None, &quot;No loader configured.&quot;</span>
<span class="gi">+        names = self.loader.list_templates()</span>
<span class="gi">+</span>
<span class="gi">+        if extensions is not None:</span>
<span class="gi">+            if filter_func is not None:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &quot;either extensions or filter_func can be passed, but not both&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            def filter_func(x: str) -&gt; bool:</span>
<span class="gi">+                return &quot;.&quot; in x and x.rsplit(&quot;.&quot;, 1)[1] in extensions</span>
<span class="gi">+</span>
<span class="gi">+        if filter_func is not None:</span>
<span class="gi">+            names = [name for name in names if filter_func(name)]</span>

<span class="gd">-    def handle_exception(self, source: t.Optional[str]=None) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+        return names</span>
<span class="gi">+</span>
<span class="gi">+    def handle_exception(self, source: t.Optional[str] = None) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Exception handling helper.  This is used internally to either raise
<span class="w"> </span>        rewritten exceptions or return a rendered traceback for the template.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .debug import rewrite_traceback_stack</span>
<span class="gi">+</span>
<span class="gi">+        raise rewrite_traceback_stack(source=source)</span>

<span class="gd">-    def join_path(self, template: str, parent: str) -&gt;str:</span>
<span class="gi">+    def join_path(self, template: str, parent: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Join a template with the parent.  By default all the lookups are
<span class="w"> </span>        relative to the loader root so this method returns the `template`
<span class="w"> </span>        parameter unchanged, but if the paths should be relative to the
<span class="gu">@@ -547,12 +948,40 @@ class Environment:</span>
<span class="w"> </span>        Subclasses may override this method and implement template path
<span class="w"> </span>        joining here.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return template</span>
<span class="gi">+</span>
<span class="gi">+    @internalcode</span>
<span class="gi">+    def _load_template(</span>
<span class="gi">+        self, name: str, globals: t.Optional[t.MutableMapping[str, t.Any]]</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="gi">+        if self.loader is None:</span>
<span class="gi">+            raise TypeError(&quot;no loader for this environment specified&quot;)</span>
<span class="gi">+        cache_key = (weakref.ref(self.loader), name)</span>
<span class="gi">+        if self.cache is not None:</span>
<span class="gi">+            template = self.cache.get(cache_key)</span>
<span class="gi">+            if template is not None and (</span>
<span class="gi">+                not self.auto_reload or template.is_up_to_date</span>
<span class="gi">+            ):</span>
<span class="gi">+                # template.globals is a ChainMap, modifying it will only</span>
<span class="gi">+                # affect the template, not the environment globals.</span>
<span class="gi">+                if globals:</span>
<span class="gi">+                    template.globals.update(globals)</span>
<span class="gi">+</span>
<span class="gi">+                return template</span>
<span class="gi">+</span>
<span class="gi">+        template = self.loader.load(self, name, self.make_globals(globals))</span>
<span class="gi">+</span>
<span class="gi">+        if self.cache is not None:</span>
<span class="gi">+            self.cache[cache_key] = template</span>
<span class="gi">+        return template</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def get_template(self, name: t.Union[str, &#39;Template&#39;], parent: t.</span>
<span class="gd">-        Optional[str]=None, globals: t.Optional[t.MutableMapping[str, t.Any</span>
<span class="gd">-        ]]=None) -&gt;&#39;Template&#39;:</span>
<span class="gi">+    def get_template(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: t.Union[str, &quot;Template&quot;],</span>
<span class="gi">+        parent: t.Optional[str] = None,</span>
<span class="gi">+        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load a template by name with :attr:`loader` and return a
<span class="w"> </span>        :class:`Template`. If the template does not exist a
<span class="w"> </span>        :exc:`TemplateNotFound` exception is raised.
<span class="gu">@@ -576,12 +1005,20 @@ class Environment:</span>
<span class="w"> </span>            If ``name`` is a :class:`Template` object it is returned
<span class="w"> </span>            unchanged.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(name, Template):</span>
<span class="gi">+            return name</span>
<span class="gi">+        if parent is not None:</span>
<span class="gi">+            name = self.join_path(name, parent)</span>
<span class="gi">+</span>
<span class="gi">+        return self._load_template(name, globals)</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def select_template(self, names: t.Iterable[t.Union[str, &#39;Template&#39;]],</span>
<span class="gd">-        parent: t.Optional[str]=None, globals: t.Optional[t.MutableMapping[</span>
<span class="gd">-        str, t.Any]]=None) -&gt;&#39;Template&#39;:</span>
<span class="gi">+    def select_template(</span>
<span class="gi">+        self,</span>
<span class="gi">+        names: t.Iterable[t.Union[str, &quot;Template&quot;]],</span>
<span class="gi">+        parent: t.Optional[str] = None,</span>
<span class="gi">+        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`get_template`, but tries loading multiple names.
<span class="w"> </span>        If none of the names can be loaded a :exc:`TemplatesNotFound`
<span class="w"> </span>        exception is raised.
<span class="gu">@@ -610,23 +1047,51 @@ class Environment:</span>

<span class="w"> </span>        .. versionadded:: 2.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(names, Undefined):</span>
<span class="gi">+            names._fail_with_undefined_error()</span>
<span class="gi">+</span>
<span class="gi">+        if not names:</span>
<span class="gi">+            raise TemplatesNotFound(</span>
<span class="gi">+                message=&quot;Tried to select from an empty list of templates.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            if isinstance(name, Template):</span>
<span class="gi">+                return name</span>
<span class="gi">+            if parent is not None:</span>
<span class="gi">+                name = self.join_path(name, parent)</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self._load_template(name, globals)</span>
<span class="gi">+            except (TemplateNotFound, UndefinedError):</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise TemplatesNotFound(names)  # type: ignore</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def get_or_select_template(self, template_name_or_list: t.Union[str,</span>
<span class="gd">-        &#39;Template&#39;, t.List[t.Union[str, &#39;Template&#39;]]], parent: t.Optional[</span>
<span class="gd">-        str]=None, globals: t.Optional[t.MutableMapping[str, t.Any]]=None</span>
<span class="gd">-        ) -&gt;&#39;Template&#39;:</span>
<span class="gi">+    def get_or_select_template(</span>
<span class="gi">+        self,</span>
<span class="gi">+        template_name_or_list: t.Union[</span>
<span class="gi">+            str, &quot;Template&quot;, t.List[t.Union[str, &quot;Template&quot;]]</span>
<span class="gi">+        ],</span>
<span class="gi">+        parent: t.Optional[str] = None,</span>
<span class="gi">+        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Use :meth:`select_template` if an iterable of template names
<span class="w"> </span>        is given, or :meth:`get_template` if one name is given.

<span class="w"> </span>        .. versionadded:: 2.3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def from_string(self, source: t.Union[str, nodes.Template], globals: t.</span>
<span class="gd">-        Optional[t.MutableMapping[str, t.Any]]=None, template_class: t.</span>
<span class="gd">-        Optional[t.Type[&#39;Template&#39;]]=None) -&gt;&#39;Template&#39;:</span>
<span class="gi">+        if isinstance(template_name_or_list, (str, Undefined)):</span>
<span class="gi">+            return self.get_template(template_name_or_list, parent, globals)</span>
<span class="gi">+        elif isinstance(template_name_or_list, Template):</span>
<span class="gi">+            return template_name_or_list</span>
<span class="gi">+        return self.select_template(template_name_or_list, parent, globals)</span>
<span class="gi">+</span>
<span class="gi">+    def from_string(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: t.Union[str, nodes.Template],</span>
<span class="gi">+        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+        template_class: t.Optional[t.Type[&quot;Template&quot;]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load a template from a source string without using
<span class="w"> </span>        :attr:`loader`.

<span class="gu">@@ -638,10 +1103,13 @@ class Environment:</span>
<span class="w"> </span>        :param template_class: Return an instance of this
<span class="w"> </span>            :class:`Template` class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        gs = self.make_globals(globals)</span>
<span class="gi">+        cls = template_class or self.template_class</span>
<span class="gi">+        return cls.from_code(self, self.compile(source), gs, None)</span>

<span class="gd">-    def make_globals(self, d: t.Optional[t.MutableMapping[str, t.Any]]</span>
<span class="gd">-        ) -&gt;t.MutableMapping[str, t.Any]:</span>
<span class="gi">+    def make_globals(</span>
<span class="gi">+        self, d: t.Optional[t.MutableMapping[str, t.Any]]</span>
<span class="gi">+    ) -&gt; t.MutableMapping[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Make the globals map for a template. Any given template
<span class="w"> </span>        globals overlay the environment :attr:`globals`.

<span class="gu">@@ -656,7 +1124,10 @@ class Environment:</span>
<span class="w"> </span>            Use :class:`collections.ChainMap` to always prevent mutating
<span class="w"> </span>            environment globals.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if d is None:</span>
<span class="gi">+            d = {}</span>
<span class="gi">+</span>
<span class="gi">+        return ChainMap(d, self.globals)</span>


<span class="w"> </span>class Template:
<span class="gu">@@ -675,62 +1146,130 @@ class Template:</span>
<span class="w"> </span>    A template object should be considered immutable. Modifications on
<span class="w"> </span>    the object are not supported.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: Type of environment to create when creating a template directly</span>
<span class="gi">+    #: rather than through an existing environment.</span>
<span class="w"> </span>    environment_class: t.Type[Environment] = Environment
<span class="gi">+</span>
<span class="w"> </span>    environment: Environment
<span class="w"> </span>    globals: t.MutableMapping[str, t.Any]
<span class="w"> </span>    name: t.Optional[str]
<span class="w"> </span>    filename: t.Optional[str]
<span class="w"> </span>    blocks: t.Dict[str, t.Callable[[Context], t.Iterator[str]]]
<span class="w"> </span>    root_render_func: t.Callable[[Context], t.Iterator[str]]
<span class="gd">-    _module: t.Optional[&#39;TemplateModule&#39;]</span>
<span class="gi">+    _module: t.Optional[&quot;TemplateModule&quot;]</span>
<span class="w"> </span>    _debug_info: str
<span class="w"> </span>    _uptodate: t.Optional[t.Callable[[], bool]]

<span class="gd">-    def __new__(cls, source: t.Union[str, nodes.Template],</span>
<span class="gd">-        block_start_string: str=BLOCK_START_STRING, block_end_string: str=</span>
<span class="gd">-        BLOCK_END_STRING, variable_start_string: str=VARIABLE_START_STRING,</span>
<span class="gd">-        variable_end_string: str=VARIABLE_END_STRING, comment_start_string:</span>
<span class="gd">-        str=COMMENT_START_STRING, comment_end_string: str=</span>
<span class="gd">-        COMMENT_END_STRING, line_statement_prefix: t.Optional[str]=</span>
<span class="gd">-        LINE_STATEMENT_PREFIX, line_comment_prefix: t.Optional[str]=</span>
<span class="gd">-        LINE_COMMENT_PREFIX, trim_blocks: bool=TRIM_BLOCKS, lstrip_blocks:</span>
<span class="gd">-        bool=LSTRIP_BLOCKS, newline_sequence:</span>
<span class="gd">-        &quot;te.Literal[&#39;\\n&#39;, &#39;\\r\\n&#39;, &#39;\\r&#39;]&quot;=NEWLINE_SEQUENCE,</span>
<span class="gd">-        keep_trailing_newline: bool=KEEP_TRAILING_NEWLINE, extensions: t.</span>
<span class="gd">-        Sequence[t.Union[str, t.Type[&#39;Extension&#39;]]]=(), optimized: bool=</span>
<span class="gd">-        True, undefined: t.Type[Undefined]=Undefined, finalize: t.Optional[</span>
<span class="gd">-        t.Callable[..., t.Any]]=None, autoescape: t.Union[bool, t.Callable[</span>
<span class="gd">-        [t.Optional[str]], bool]]=False, enable_async: bool=False) -&gt;t.Any:</span>
<span class="gd">-        env = get_spontaneous_environment(cls.environment_class,</span>
<span class="gd">-            block_start_string, block_end_string, variable_start_string,</span>
<span class="gd">-            variable_end_string, comment_start_string, comment_end_string,</span>
<span class="gd">-            line_statement_prefix, line_comment_prefix, trim_blocks,</span>
<span class="gd">-            lstrip_blocks, newline_sequence, keep_trailing_newline,</span>
<span class="gd">-            frozenset(extensions), optimized, undefined, finalize,</span>
<span class="gd">-            autoescape, None, 0, False, None, enable_async)</span>
<span class="gi">+    def __new__(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        source: t.Union[str, nodes.Template],</span>
<span class="gi">+        block_start_string: str = BLOCK_START_STRING,</span>
<span class="gi">+        block_end_string: str = BLOCK_END_STRING,</span>
<span class="gi">+        variable_start_string: str = VARIABLE_START_STRING,</span>
<span class="gi">+        variable_end_string: str = VARIABLE_END_STRING,</span>
<span class="gi">+        comment_start_string: str = COMMENT_START_STRING,</span>
<span class="gi">+        comment_end_string: str = COMMENT_END_STRING,</span>
<span class="gi">+        line_statement_prefix: t.Optional[str] = LINE_STATEMENT_PREFIX,</span>
<span class="gi">+        line_comment_prefix: t.Optional[str] = LINE_COMMENT_PREFIX,</span>
<span class="gi">+        trim_blocks: bool = TRIM_BLOCKS,</span>
<span class="gi">+        lstrip_blocks: bool = LSTRIP_BLOCKS,</span>
<span class="gi">+        newline_sequence: &quot;te.Literal[&#39;\\n&#39;, &#39;\\r\\n&#39;, &#39;\\r&#39;]&quot; = NEWLINE_SEQUENCE,</span>
<span class="gi">+        keep_trailing_newline: bool = KEEP_TRAILING_NEWLINE,</span>
<span class="gi">+        extensions: t.Sequence[t.Union[str, t.Type[&quot;Extension&quot;]]] = (),</span>
<span class="gi">+        optimized: bool = True,</span>
<span class="gi">+        undefined: t.Type[Undefined] = Undefined,</span>
<span class="gi">+        finalize: t.Optional[t.Callable[..., t.Any]] = None,</span>
<span class="gi">+        autoescape: t.Union[bool, t.Callable[[t.Optional[str]], bool]] = False,</span>
<span class="gi">+        enable_async: bool = False,</span>
<span class="gi">+    ) -&gt; t.Any:  # it returns a `Template`, but this breaks the sphinx build...</span>
<span class="gi">+        env = get_spontaneous_environment(</span>
<span class="gi">+            cls.environment_class,  # type: ignore</span>
<span class="gi">+            block_start_string,</span>
<span class="gi">+            block_end_string,</span>
<span class="gi">+            variable_start_string,</span>
<span class="gi">+            variable_end_string,</span>
<span class="gi">+            comment_start_string,</span>
<span class="gi">+            comment_end_string,</span>
<span class="gi">+            line_statement_prefix,</span>
<span class="gi">+            line_comment_prefix,</span>
<span class="gi">+            trim_blocks,</span>
<span class="gi">+            lstrip_blocks,</span>
<span class="gi">+            newline_sequence,</span>
<span class="gi">+            keep_trailing_newline,</span>
<span class="gi">+            frozenset(extensions),</span>
<span class="gi">+            optimized,</span>
<span class="gi">+            undefined,  # type: ignore</span>
<span class="gi">+            finalize,</span>
<span class="gi">+            autoescape,</span>
<span class="gi">+            None,</span>
<span class="gi">+            0,</span>
<span class="gi">+            False,</span>
<span class="gi">+            None,</span>
<span class="gi">+            enable_async,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return env.from_string(source, template_class=cls)

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_code(cls, environment: Environment, code: CodeType, globals: t</span>
<span class="gd">-        .MutableMapping[str, t.Any], uptodate: t.Optional[t.Callable[[],</span>
<span class="gd">-        bool]]=None) -&gt;&#39;Template&#39;:</span>
<span class="gi">+    def from_code(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        environment: Environment,</span>
<span class="gi">+        code: CodeType,</span>
<span class="gi">+        globals: t.MutableMapping[str, t.Any],</span>
<span class="gi">+        uptodate: t.Optional[t.Callable[[], bool]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a template object from compiled code and the globals.  This
<span class="w"> </span>        is used by the loaders and environment to create a template object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        namespace = {&quot;environment&quot;: environment, &quot;__file__&quot;: code.co_filename}</span>
<span class="gi">+        exec(code, namespace)</span>
<span class="gi">+        rv = cls._from_namespace(environment, namespace, globals)</span>
<span class="gi">+        rv._uptodate = uptodate</span>
<span class="gi">+        return rv</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_module_dict(cls, environment: Environment, module_dict: t.</span>
<span class="gd">-        MutableMapping[str, t.Any], globals: t.MutableMapping[str, t.Any]</span>
<span class="gd">-        ) -&gt;&#39;Template&#39;:</span>
<span class="gi">+    def from_module_dict(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        environment: Environment,</span>
<span class="gi">+        module_dict: t.MutableMapping[str, t.Any],</span>
<span class="gi">+        globals: t.MutableMapping[str, t.Any],</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Creates a template object from a module.  This is used by the
<span class="w"> </span>        module loader to create a template object.

<span class="w"> </span>        .. versionadded:: 2.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls._from_namespace(environment, module_dict, globals)</span>

<span class="gd">-    def render(self, *args: t.Any, **kwargs: t.Any) -&gt;str:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _from_namespace(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        environment: Environment,</span>
<span class="gi">+        namespace: t.MutableMapping[str, t.Any],</span>
<span class="gi">+        globals: t.MutableMapping[str, t.Any],</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="gi">+        t: &quot;Template&quot; = object.__new__(cls)</span>
<span class="gi">+        t.environment = environment</span>
<span class="gi">+        t.globals = globals</span>
<span class="gi">+        t.name = namespace[&quot;name&quot;]</span>
<span class="gi">+        t.filename = namespace[&quot;__file__&quot;]</span>
<span class="gi">+        t.blocks = namespace[&quot;blocks&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        # render function and module</span>
<span class="gi">+        t.root_render_func = namespace[&quot;root&quot;]</span>
<span class="gi">+        t._module = None</span>
<span class="gi">+</span>
<span class="gi">+        # debug and loader helpers</span>
<span class="gi">+        t._debug_info = namespace[&quot;debug_info&quot;]</span>
<span class="gi">+        t._uptodate = None</span>
<span class="gi">+</span>
<span class="gi">+        # store the reference</span>
<span class="gi">+        namespace[&quot;environment&quot;] = environment</span>
<span class="gi">+        namespace[&quot;__jinja_template__&quot;] = t</span>
<span class="gi">+</span>
<span class="gi">+        return t</span>
<span class="gi">+</span>
<span class="gi">+    def render(self, *args: t.Any, **kwargs: t.Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method accepts the same arguments as the `dict` constructor:
<span class="w"> </span>        A dict, a dict subclass or some keyword arguments.  If no arguments
<span class="w"> </span>        are given the context will be empty.  These two calls do the same::
<span class="gu">@@ -740,9 +1279,31 @@ class Template:</span>

<span class="w"> </span>        This will return the rendered template as a string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            import asyncio</span>
<span class="gi">+</span>
<span class="gi">+            close = False</span>

<span class="gd">-    async def render_async(self, *args: t.Any, **kwargs: t.Any) -&gt;str:</span>
<span class="gi">+            try:</span>
<span class="gi">+                loop = asyncio.get_running_loop()</span>
<span class="gi">+            except RuntimeError:</span>
<span class="gi">+                loop = asyncio.new_event_loop()</span>
<span class="gi">+                close = True</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                return loop.run_until_complete(self.render_async(*args, **kwargs))</span>
<span class="gi">+            finally:</span>
<span class="gi">+                if close:</span>
<span class="gi">+                    loop.close()</span>
<span class="gi">+</span>
<span class="gi">+        ctx = self.new_context(dict(*args, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.environment.concat(self.root_render_func(ctx))  # type: ignore</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            self.environment.handle_exception()</span>
<span class="gi">+</span>
<span class="gi">+    async def render_async(self, *args: t.Any, **kwargs: t.Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;This works similar to :meth:`render` but returns a coroutine
<span class="w"> </span>        that when awaited returns the entire rendered template string.  This
<span class="w"> </span>        requires the async feature to be enabled.
<span class="gu">@@ -751,15 +1312,27 @@ class Template:</span>

<span class="w"> </span>            await template.render_async(knights=&#39;that say nih; asynchronously&#39;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.environment.is_async:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &quot;The environment was not created with async mode enabled.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        ctx = self.new_context(dict(*args, **kwargs))</span>

<span class="gd">-    def stream(self, *args: t.Any, **kwargs: t.Any) -&gt;&#39;TemplateStream&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.environment.concat(  # type: ignore</span>
<span class="gi">+                [n async for n in self.root_render_func(ctx)]  # type: ignore</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return self.environment.handle_exception()</span>
<span class="gi">+</span>
<span class="gi">+    def stream(self, *args: t.Any, **kwargs: t.Any) -&gt; &quot;TemplateStream&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Works exactly like :meth:`generate` but returns a
<span class="w"> </span>        :class:`TemplateStream`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return TemplateStream(self.generate(*args, **kwargs))</span>

<span class="gd">-    def generate(self, *args: t.Any, **kwargs: t.Any) -&gt;t.Iterator[str]:</span>
<span class="gi">+    def generate(self, *args: t.Any, **kwargs: t.Any) -&gt; t.Iterator[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;For very large templates it can be useful to not render the whole
<span class="w"> </span>        template at once but evaluate each statement after another and yield
<span class="w"> </span>        piece for piece.  This method basically does exactly that and returns
<span class="gu">@@ -767,17 +1340,47 @@ class Template:</span>

<span class="w"> </span>        It accepts the same arguments as :meth:`render`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            import asyncio</span>
<span class="gi">+</span>
<span class="gi">+            async def to_list() -&gt; t.List[str]:</span>
<span class="gi">+                return [x async for x in self.generate_async(*args, **kwargs)]</span>
<span class="gi">+</span>
<span class="gi">+            yield from asyncio.run(to_list())</span>
<span class="gi">+            return</span>

<span class="gd">-    async def generate_async(self, *args: t.Any, **kwargs: t.Any</span>
<span class="gd">-        ) -&gt;t.AsyncIterator[str]:</span>
<span class="gi">+        ctx = self.new_context(dict(*args, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield from self.root_render_func(ctx)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            yield self.environment.handle_exception()</span>
<span class="gi">+</span>
<span class="gi">+    async def generate_async(</span>
<span class="gi">+        self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; t.AsyncIterator[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;An async version of :meth:`generate`.  Works very similarly but
<span class="w"> </span>        returns an async iterator instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def new_context(self, vars: t.Optional[t.Dict[str, t.Any]]=None, shared:</span>
<span class="gd">-        bool=False, locals: t.Optional[t.Mapping[str, t.Any]]=None) -&gt;Context:</span>
<span class="gi">+        if not self.environment.is_async:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &quot;The environment was not created with async mode enabled.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        ctx = self.new_context(dict(*args, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            async for event in self.root_render_func(ctx):  # type: ignore</span>
<span class="gi">+                yield event</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            yield self.environment.handle_exception()</span>
<span class="gi">+</span>
<span class="gi">+    def new_context(</span>
<span class="gi">+        self,</span>
<span class="gi">+        vars: t.Optional[t.Dict[str, t.Any]] = None,</span>
<span class="gi">+        shared: bool = False,</span>
<span class="gi">+        locals: t.Optional[t.Mapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; Context:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new :class:`Context` for this template.  The vars
<span class="w"> </span>        provided will be passed to the template.  Per default the globals
<span class="w"> </span>        are added to the context.  If shared is set to `True` the data
<span class="gu">@@ -785,32 +1388,45 @@ class Template:</span>

<span class="w"> </span>        `locals` can be a dict of local variables for internal usage.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def make_module(self, vars: t.Optional[t.Dict[str, t.Any]]=None, shared:</span>
<span class="gd">-        bool=False, locals: t.Optional[t.Mapping[str, t.Any]]=None</span>
<span class="gd">-        ) -&gt;&#39;TemplateModule&#39;:</span>
<span class="gi">+        return new_context(</span>
<span class="gi">+            self.environment, self.name, self.blocks, vars, shared, self.globals, locals</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def make_module(</span>
<span class="gi">+        self,</span>
<span class="gi">+        vars: t.Optional[t.Dict[str, t.Any]] = None,</span>
<span class="gi">+        shared: bool = False,</span>
<span class="gi">+        locals: t.Optional[t.Mapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; &quot;TemplateModule&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method works like the :attr:`module` attribute when called
<span class="w"> </span>        without arguments but it will evaluate the template on every call
<span class="w"> </span>        rather than caching it.  It&#39;s also possible to provide
<span class="w"> </span>        a dict which is then used as context.  The arguments are the same
<span class="w"> </span>        as for the :meth:`new_context` method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    async def make_module_async(self, vars: t.Optional[t.Dict[str, t.Any]]=</span>
<span class="gd">-        None, shared: bool=False, locals: t.Optional[t.Mapping[str, t.Any]]</span>
<span class="gd">-        =None) -&gt;&#39;TemplateModule&#39;:</span>
<span class="gi">+        ctx = self.new_context(vars, shared, locals)</span>
<span class="gi">+        return TemplateModule(self, ctx)</span>
<span class="gi">+</span>
<span class="gi">+    async def make_module_async(</span>
<span class="gi">+        self,</span>
<span class="gi">+        vars: t.Optional[t.Dict[str, t.Any]] = None,</span>
<span class="gi">+        shared: bool = False,</span>
<span class="gi">+        locals: t.Optional[t.Mapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; &quot;TemplateModule&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;As template module creation can invoke template code for
<span class="w"> </span>        asynchronous executions this method must be used instead of the
<span class="w"> </span>        normal :meth:`make_module` one.  Likewise the module attribute
<span class="w"> </span>        becomes unavailable in async mode.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ctx = self.new_context(vars, shared, locals)</span>
<span class="gi">+        return TemplateModule(</span>
<span class="gi">+            self,</span>
<span class="gi">+            ctx,</span>
<span class="gi">+            [x async for x in self.root_render_func(ctx)],  # type: ignore</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def _get_default_module(self, ctx: t.Optional[Context]=None</span>
<span class="gd">-        ) -&gt;&#39;TemplateModule&#39;:</span>
<span class="gi">+    def _get_default_module(self, ctx: t.Optional[Context] = None) -&gt; &quot;TemplateModule&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;If a context is passed in, this means that the template was
<span class="w"> </span>        imported. Imported templates have access to the current
<span class="w"> </span>        template&#39;s globals by default, but they can only be accessed via
<span class="gu">@@ -822,10 +1438,36 @@ class Template:</span>
<span class="w"> </span>        cached because the template can be imported elsewhere, and it
<span class="w"> </span>        should have access to only the current template&#39;s globals.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.environment.is_async:</span>
<span class="gi">+            raise RuntimeError(&quot;Module is not available in async mode.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if ctx is not None:</span>
<span class="gi">+            keys = ctx.globals_keys - self.globals.keys()</span>
<span class="gi">+</span>
<span class="gi">+            if keys:</span>
<span class="gi">+                return self.make_module({k: ctx.parent[k] for k in keys})</span>
<span class="gi">+</span>
<span class="gi">+        if self._module is None:</span>
<span class="gi">+            self._module = self.make_module()</span>
<span class="gi">+</span>
<span class="gi">+        return self._module</span>
<span class="gi">+</span>
<span class="gi">+    async def _get_default_module_async(</span>
<span class="gi">+        self, ctx: t.Optional[Context] = None</span>
<span class="gi">+    ) -&gt; &quot;TemplateModule&quot;:</span>
<span class="gi">+        if ctx is not None:</span>
<span class="gi">+            keys = ctx.globals_keys - self.globals.keys()</span>
<span class="gi">+</span>
<span class="gi">+            if keys:</span>
<span class="gi">+                return await self.make_module_async({k: ctx.parent[k] for k in keys})</span>
<span class="gi">+</span>
<span class="gi">+        if self._module is None:</span>
<span class="gi">+            self._module = await self.make_module_async()</span>
<span class="gi">+</span>
<span class="gi">+        return self._module</span>

<span class="w"> </span>    @property
<span class="gd">-    def module(self) -&gt;&#39;TemplateModule&#39;:</span>
<span class="gi">+    def module(self) -&gt; &quot;TemplateModule&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;The template as module.  This is used for imports in the
<span class="w"> </span>        template runtime but is also useful if one wants to access
<span class="w"> </span>        exported template variables from the Python layer:
<span class="gu">@@ -838,30 +1480,41 @@ class Template:</span>

<span class="w"> </span>        This attribute is not available if async mode is enabled.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_default_module()</span>

<span class="gd">-    def get_corresponding_lineno(self, lineno: int) -&gt;int:</span>
<span class="gi">+    def get_corresponding_lineno(self, lineno: int) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the source line number of a line number in the
<span class="w"> </span>        generated bytecode as they are not in sync.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for template_line, code_line in reversed(self.debug_info):</span>
<span class="gi">+            if code_line &lt;= lineno:</span>
<span class="gi">+                return template_line</span>
<span class="gi">+        return 1</span>

<span class="w"> </span>    @property
<span class="gd">-    def is_up_to_date(self) -&gt;bool:</span>
<span class="gi">+    def is_up_to_date(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;If this variable is `False` there is a newer version available.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._uptodate is None:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return self._uptodate()</span>

<span class="w"> </span>    @property
<span class="gd">-    def debug_info(self) -&gt;t.List[t.Tuple[int, int]]:</span>
<span class="gi">+    def debug_info(self) -&gt; t.List[t.Tuple[int, int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The debug info mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._debug_info:</span>
<span class="gi">+            return [</span>
<span class="gi">+                tuple(map(int, x.split(&quot;=&quot;)))  # type: ignore</span>
<span class="gi">+                for x in self._debug_info.split(&quot;&amp;&quot;)</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+        return []</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        if self.name is None:
<span class="gd">-            name = f&#39;memory:{id(self):x}&#39;</span>
<span class="gi">+            name = f&quot;memory:{id(self):x}&quot;</span>
<span class="w"> </span>        else:
<span class="w"> </span>            name = repr(self.name)
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {name}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {name}&gt;&quot;</span>


<span class="w"> </span>class TemplateModule:
<span class="gu">@@ -870,30 +1523,38 @@ class TemplateModule:</span>
<span class="w"> </span>    converting it into a string renders the contents.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, template: Template, context: Context, body_stream: t</span>
<span class="gd">-        .Optional[t.Iterable[str]]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        template: Template,</span>
<span class="gi">+        context: Context,</span>
<span class="gi">+        body_stream: t.Optional[t.Iterable[str]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if body_stream is None:
<span class="w"> </span>            if context.environment.is_async:
<span class="w"> </span>                raise RuntimeError(
<span class="gd">-                    &#39;Async mode requires a body stream to be passed to a template module. Use the async methods of the API you are using.&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    &quot;Async mode requires a body stream to be passed to&quot;</span>
<span class="gi">+                    &quot; a template module. Use the async methods of the&quot;</span>
<span class="gi">+                    &quot; API you are using.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="w"> </span>            body_stream = list(template.root_render_func(context))
<span class="gi">+</span>
<span class="w"> </span>        self._body_stream = body_stream
<span class="w"> </span>        self.__dict__.update(context.get_exported())
<span class="w"> </span>        self.__name__ = template.name

<span class="gd">-    def __html__(self) -&gt;Markup:</span>
<span class="gi">+    def __html__(self) -&gt; Markup:</span>
<span class="w"> </span>        return Markup(concat(self._body_stream))

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return concat(self._body_stream)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        if self.__name__ is None:
<span class="gd">-            name = f&#39;memory:{id(self):x}&#39;</span>
<span class="gi">+            name = f&quot;memory:{id(self):x}&quot;</span>
<span class="w"> </span>        else:
<span class="w"> </span>            name = repr(self.__name__)
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {name}&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {name}&gt;&quot;</span>


<span class="w"> </span>class TemplateExpression:
<span class="gu">@@ -902,14 +1563,14 @@ class TemplateExpression:</span>
<span class="w"> </span>    to the template with an expression it wraps.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, template: Template, undefined_to_none: bool) -&gt;None:</span>
<span class="gi">+    def __init__(self, template: Template, undefined_to_none: bool) -&gt; None:</span>
<span class="w"> </span>        self._template = template
<span class="w"> </span>        self._undefined_to_none = undefined_to_none

<span class="gd">-    def __call__(self, *args: t.Any, **kwargs: t.Any) -&gt;t.Optional[t.Any]:</span>
<span class="gi">+    def __call__(self, *args: t.Any, **kwargs: t.Any) -&gt; t.Optional[t.Any]:</span>
<span class="w"> </span>        context = self._template.new_context(dict(*args, **kwargs))
<span class="w"> </span>        consume(self._template.root_render_func(context))
<span class="gd">-        rv = context.vars[&#39;result&#39;]</span>
<span class="gi">+        rv = context.vars[&quot;result&quot;]</span>
<span class="w"> </span>        if self._undefined_to_none and isinstance(rv, Undefined):
<span class="w"> </span>            rv = None
<span class="w"> </span>        return rv
<span class="gu">@@ -926,12 +1587,16 @@ class TemplateStream:</span>
<span class="w"> </span>    big templates to a client via WSGI which flushes after each iteration.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, gen: t.Iterator[str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, gen: t.Iterator[str]) -&gt; None:</span>
<span class="w"> </span>        self._gen = gen
<span class="w"> </span>        self.disable_buffering()

<span class="gd">-    def dump(self, fp: t.Union[str, t.IO[bytes]], encoding: t.Optional[str]</span>
<span class="gd">-        =None, errors: t.Optional[str]=&#39;strict&#39;) -&gt;None:</span>
<span class="gi">+    def dump(</span>
<span class="gi">+        self,</span>
<span class="gi">+        fp: t.Union[str, t.IO[bytes]],</span>
<span class="gi">+        encoding: t.Optional[str] = None,</span>
<span class="gi">+        errors: t.Optional[str] = &quot;strict&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Dump the complete stream into a file or file-like object.
<span class="w"> </span>        Per default strings are written, if you want to encode
<span class="w"> </span>        before writing specify an `encoding`.
<span class="gu">@@ -940,21 +1605,71 @@ class TemplateStream:</span>

<span class="w"> </span>            Template(&#39;Hello {{ name }}!&#39;).stream(name=&#39;foo&#39;).dump(&#39;hello.html&#39;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        close = False</span>

<span class="gd">-    def disable_buffering(self) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Disable the output buffering.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(fp, str):</span>
<span class="gi">+            if encoding is None:</span>
<span class="gi">+                encoding = &quot;utf-8&quot;</span>

<span class="gd">-    def enable_buffering(self, size: int=5) -&gt;None:</span>
<span class="gi">+            real_fp: t.IO[bytes] = open(fp, &quot;wb&quot;)</span>
<span class="gi">+            close = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            real_fp = fp</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if encoding is not None:</span>
<span class="gi">+                iterable = (x.encode(encoding, errors) for x in self)  # type: ignore</span>
<span class="gi">+            else:</span>
<span class="gi">+                iterable = self  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+            if hasattr(real_fp, &quot;writelines&quot;):</span>
<span class="gi">+                real_fp.writelines(iterable)</span>
<span class="gi">+            else:</span>
<span class="gi">+                for item in iterable:</span>
<span class="gi">+                    real_fp.write(item)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if close:</span>
<span class="gi">+                real_fp.close()</span>
<span class="gi">+</span>
<span class="gi">+    def disable_buffering(self) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Disable the output buffering.&quot;&quot;&quot;</span>
<span class="gi">+        self._next = partial(next, self._gen)</span>
<span class="gi">+        self.buffered = False</span>
<span class="gi">+</span>
<span class="gi">+    def _buffered_generator(self, size: int) -&gt; t.Iterator[str]:</span>
<span class="gi">+        buf: t.List[str] = []</span>
<span class="gi">+        c_size = 0</span>
<span class="gi">+        push = buf.append</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                while c_size &lt; size:</span>
<span class="gi">+                    c = next(self._gen)</span>
<span class="gi">+                    push(c)</span>
<span class="gi">+                    if c:</span>
<span class="gi">+                        c_size += 1</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                if not c_size:</span>
<span class="gi">+                    return</span>
<span class="gi">+            yield concat(buf)</span>
<span class="gi">+            del buf[:]</span>
<span class="gi">+            c_size = 0</span>
<span class="gi">+</span>
<span class="gi">+    def enable_buffering(self, size: int = 5) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Enable buffering.  Buffer `size` items before yielding them.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if size &lt;= 1:</span>
<span class="gi">+            raise ValueError(&quot;buffer size too small&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.buffered = True</span>
<span class="gi">+        self._next = partial(next, self._buffered_generator(size))</span>

<span class="gd">-    def __iter__(self) -&gt;&#39;TemplateStream&#39;:</span>
<span class="gi">+    def __iter__(self) -&gt; &quot;TemplateStream&quot;:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __next__(self) -&gt;str:</span>
<span class="gd">-        return self._next()</span>
<span class="gi">+    def __next__(self) -&gt; str:</span>
<span class="gi">+        return self._next()  # type: ignore</span>


<span class="gi">+# hook in default template class.  if anyone reads this comment: ignore that</span>
<span class="gi">+# it&#39;s possible to use custom templates ;-)</span>
<span class="w"> </span>Environment.template_class = Template
<span class="gh">diff --git a/src/jinja2/exceptions.py b/src/jinja2/exceptions.py</span>
<span class="gh">index 39cc9cb..082ebe8 100644</span>
<span class="gd">--- a/src/jinja2/exceptions.py</span>
<span class="gi">+++ b/src/jinja2/exceptions.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from .runtime import Undefined

<span class="gu">@@ -6,9 +7,13 @@ if t.TYPE_CHECKING:</span>
<span class="w"> </span>class TemplateError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Baseclass for all template errors.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: t.Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: t.Optional[str] = None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message)

<span class="gi">+    @property</span>
<span class="gi">+    def message(self) -&gt; t.Optional[str]:</span>
<span class="gi">+        return self.args[0] if self.args else None</span>
<span class="gi">+</span>

<span class="w"> </span>class TemplateNotFound(IOError, LookupError, TemplateError):
<span class="w"> </span>    &quot;&quot;&quot;Raised if a template does not exist.
<span class="gu">@@ -17,21 +22,31 @@ class TemplateNotFound(IOError, LookupError, TemplateError):</span>
<span class="w"> </span>        If the given name is :class:`Undefined` and no message was
<span class="w"> </span>        provided, an :exc:`UndefinedError` is raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # Silence the Python warning about message being deprecated since</span>
<span class="gi">+    # it&#39;s not valid here.</span>
<span class="w"> </span>    message: t.Optional[str] = None

<span class="gd">-    def __init__(self, name: t.Optional[t.Union[str, &#39;Undefined&#39;]], message:</span>
<span class="gd">-        t.Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: t.Optional[t.Union[str, &quot;Undefined&quot;]],</span>
<span class="gi">+        message: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        IOError.__init__(self, name)
<span class="gi">+</span>
<span class="w"> </span>        if message is None:
<span class="w"> </span>            from .runtime import Undefined
<span class="gi">+</span>
<span class="w"> </span>            if isinstance(name, Undefined):
<span class="w"> </span>                name._fail_with_undefined_error()
<span class="gi">+</span>
<span class="w"> </span>            message = name
<span class="gi">+</span>
<span class="w"> </span>        self.message = message
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.templates = [name]

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return str(self.message)


<span class="gu">@@ -47,18 +62,25 @@ class TemplatesNotFound(TemplateNotFound):</span>
<span class="w"> </span>    .. versionadded:: 2.2
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, names: t.Sequence[t.Union[str, &#39;Undefined&#39;]]=(),</span>
<span class="gd">-        message: t.Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        names: t.Sequence[t.Union[str, &quot;Undefined&quot;]] = (),</span>
<span class="gi">+        message: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if message is None:
<span class="w"> </span>            from .runtime import Undefined
<span class="gi">+</span>
<span class="w"> </span>            parts = []
<span class="gi">+</span>
<span class="w"> </span>            for name in names:
<span class="w"> </span>                if isinstance(name, Undefined):
<span class="w"> </span>                    parts.append(name._undefined_message)
<span class="w"> </span>                else:
<span class="w"> </span>                    parts.append(name)
<span class="gd">-            parts_str = &#39;, &#39;.join(map(str, parts))</span>
<span class="gd">-            message = f&#39;none of the templates given were found: {parts_str}&#39;</span>
<span class="gi">+</span>
<span class="gi">+            parts_str = &quot;, &quot;.join(map(str, parts))</span>
<span class="gi">+            message = f&quot;none of the templates given were found: {parts_str}&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(names[-1] if names else None, message)
<span class="w"> </span>        self.templates = list(names)

<span class="gu">@@ -66,35 +88,52 @@ class TemplatesNotFound(TemplateNotFound):</span>
<span class="w"> </span>class TemplateSyntaxError(TemplateError):
<span class="w"> </span>    &quot;&quot;&quot;Raised to tell the user that there is a problem with the template.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, lineno: int, name: t.Optional[str]=</span>
<span class="gd">-        None, filename: t.Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        lineno: int,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message)
<span class="w"> </span>        self.lineno = lineno
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.source: t.Optional[str] = None
<span class="gi">+</span>
<span class="gi">+        # this is set to True if the debug.translate_syntax_error</span>
<span class="gi">+        # function translated the syntax error into a new traceback</span>
<span class="w"> </span>        self.translated = False

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        # for translated errors we only return the message</span>
<span class="w"> </span>        if self.translated:
<span class="w"> </span>            return t.cast(str, self.message)
<span class="gd">-        location = f&#39;line {self.lineno}&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # otherwise attach some stuff</span>
<span class="gi">+        location = f&quot;line {self.lineno}&quot;</span>
<span class="w"> </span>        name = self.filename or self.name
<span class="w"> </span>        if name:
<span class="w"> </span>            location = f&#39;File &quot;{name}&quot;, {location}&#39;
<span class="gd">-        lines = [t.cast(str, self.message), &#39;  &#39; + location]</span>
<span class="gi">+        lines = [t.cast(str, self.message), &quot;  &quot; + location]</span>
<span class="gi">+</span>
<span class="gi">+        # if the source is set, add the line to the output</span>
<span class="w"> </span>        if self.source is not None:
<span class="w"> </span>            try:
<span class="w"> </span>                line = self.source.splitlines()[self.lineno - 1]
<span class="w"> </span>            except IndexError:
<span class="w"> </span>                pass
<span class="w"> </span>            else:
<span class="gd">-                lines.append(&#39;    &#39; + line.strip())</span>
<span class="gd">-        return &#39;\n&#39;.join(lines)</span>
<span class="gi">+                lines.append(&quot;    &quot; + line.strip())</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;\n&quot;.join(lines)</span>

<span class="gd">-    def __reduce__(self):</span>
<span class="gd">-        return self.__class__, (self.message, self.lineno, self.name, self.</span>
<span class="gd">-            filename)</span>
<span class="gi">+    def __reduce__(self):  # type: ignore</span>
<span class="gi">+        # https://bugs.python.org/issue1692335 Exceptions that take</span>
<span class="gi">+        # multiple required arguments have problems with pickling.</span>
<span class="gi">+        # Without this, raises TypeError: __init__() missing 1 required</span>
<span class="gi">+        # positional argument: &#39;lineno&#39;</span>
<span class="gi">+        return self.__class__, (self.message, self.lineno, self.name, self.filename)</span>


<span class="w"> </span>class TemplateAssertionError(TemplateSyntaxError):
<span class="gh">diff --git a/src/jinja2/ext.py b/src/jinja2/ext.py</span>
<span class="gh">index 337f30c..8d0810c 100644</span>
<span class="gd">--- a/src/jinja2/ext.py</span>
<span class="gi">+++ b/src/jinja2/ext.py</span>
<span class="gu">@@ -1,35 +1,55 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Extension API for adding custom tags and behavior.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import pprint
<span class="w"> </span>import re
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from markupsafe import Markup
<span class="gi">+</span>
<span class="w"> </span>from . import defaults
<span class="w"> </span>from . import nodes
<span class="w"> </span>from .environment import Environment
<span class="w"> </span>from .exceptions import TemplateAssertionError
<span class="w"> </span>from .exceptions import TemplateSyntaxError
<span class="gd">-from .runtime import concat</span>
<span class="gi">+from .runtime import concat  # type: ignore</span>
<span class="w"> </span>from .runtime import Context
<span class="w"> </span>from .runtime import Undefined
<span class="w"> </span>from .utils import import_string
<span class="w"> </span>from .utils import pass_context
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gi">+</span>
<span class="w"> </span>    from .lexer import Token
<span class="w"> </span>    from .lexer import TokenStream
<span class="w"> </span>    from .parser import Parser

<span class="gd">-</span>
<span class="w"> </span>    class _TranslationsBasic(te.Protocol):
<span class="gd">-        pass</span>
<span class="gi">+        def gettext(self, message: str) -&gt; str: ...</span>

<span class="gi">+        def ngettext(self, singular: str, plural: str, n: int) -&gt; str:</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    class _TranslationsContext(_TranslationsBasic):
<span class="gd">-        pass</span>
<span class="gi">+        def pgettext(self, context: str, message: str) -&gt; str: ...</span>
<span class="gi">+</span>
<span class="gi">+        def npgettext(</span>
<span class="gi">+            self, context: str, singular: str, plural: str, n: int</span>
<span class="gi">+        ) -&gt; str: ...</span>
<span class="gi">+</span>
<span class="w"> </span>    _SupportedTranslations = t.Union[_TranslationsBasic, _TranslationsContext]
<span class="gd">-GETTEXT_FUNCTIONS: t.Tuple[str, ...] = (&#39;_&#39;, &#39;gettext&#39;, &#39;ngettext&#39;,</span>
<span class="gd">-    &#39;pgettext&#39;, &#39;npgettext&#39;)</span>
<span class="gd">-_ws_re = re.compile(&#39;\\s*\\n\\s*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# I18N functions available in Jinja templates. If the I18N library</span>
<span class="gi">+# provides ugettext, it will be assigned to gettext.</span>
<span class="gi">+GETTEXT_FUNCTIONS: t.Tuple[str, ...] = (</span>
<span class="gi">+    &quot;_&quot;,</span>
<span class="gi">+    &quot;gettext&quot;,</span>
<span class="gi">+    &quot;ngettext&quot;,</span>
<span class="gi">+    &quot;pgettext&quot;,</span>
<span class="gi">+    &quot;npgettext&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+_ws_re = re.compile(r&quot;\s*\n\s*&quot;)</span>


<span class="w"> </span>class Extension:
<span class="gu">@@ -50,48 +70,62 @@ class Extension:</span>
<span class="w"> </span>    is a terrible name, ``fragment_cache_prefix`` on the other hand is a good
<span class="w"> </span>    name as includes the name of the extension (fragment cache).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    identifier: t.ClassVar[str]

<span class="gd">-    def __init_subclass__(cls) -&gt;None:</span>
<span class="gd">-        cls.identifier = f&#39;{cls.__module__}.{cls.__name__}&#39;</span>
<span class="gi">+    def __init_subclass__(cls) -&gt; None:</span>
<span class="gi">+        cls.identifier = f&quot;{cls.__module__}.{cls.__name__}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    #: if this extension parses this is the list of tags it&#39;s listening to.</span>
<span class="w"> </span>    tags: t.Set[str] = set()
<span class="gi">+</span>
<span class="gi">+    #: the priority of that extension.  This is especially useful for</span>
<span class="gi">+    #: extensions that preprocess values.  A lower value means higher</span>
<span class="gi">+    #: priority.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 2.4</span>
<span class="w"> </span>    priority = 100

<span class="gd">-    def __init__(self, environment: Environment) -&gt;None:</span>
<span class="gi">+    def __init__(self, environment: Environment) -&gt; None:</span>
<span class="w"> </span>        self.environment = environment

<span class="gd">-    def bind(self, environment: Environment) -&gt;&#39;Extension&#39;:</span>
<span class="gi">+    def bind(self, environment: Environment) -&gt; &quot;Extension&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a copy of this extension bound to another environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def preprocess(self, source: str, name: t.Optional[str], filename: t.</span>
<span class="gd">-        Optional[str]=None) -&gt;str:</span>
<span class="gi">+        rv = object.__new__(self.__class__)</span>
<span class="gi">+        rv.__dict__.update(self.__dict__)</span>
<span class="gi">+        rv.environment = environment</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def preprocess(</span>
<span class="gi">+        self, source: str, name: t.Optional[str], filename: t.Optional[str] = None</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method is called before the actual lexing and can be used to
<span class="w"> </span>        preprocess the source.  The `filename` is optional.  The return value
<span class="w"> </span>        must be the preprocessed source.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return source</span>

<span class="gd">-    def filter_stream(self, stream: &#39;TokenStream&#39;) -&gt;t.Union[&#39;TokenStream&#39;,</span>
<span class="gd">-        t.Iterable[&#39;Token&#39;]]:</span>
<span class="gi">+    def filter_stream(</span>
<span class="gi">+        self, stream: &quot;TokenStream&quot;</span>
<span class="gi">+    ) -&gt; t.Union[&quot;TokenStream&quot;, t.Iterable[&quot;Token&quot;]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;It&#39;s passed a :class:`~jinja2.lexer.TokenStream` that can be used
<span class="w"> </span>        to filter tokens returned.  This method has to return an iterable of
<span class="w"> </span>        :class:`~jinja2.lexer.Token`\\s, but it doesn&#39;t have to return a
<span class="w"> </span>        :class:`~jinja2.lexer.TokenStream`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return stream</span>

<span class="gd">-    def parse(self, parser: &#39;Parser&#39;) -&gt;t.Union[nodes.Node, t.List[nodes.Node]</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def parse(self, parser: &quot;Parser&quot;) -&gt; t.Union[nodes.Node, t.List[nodes.Node]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;If any of the :attr:`tags` matched this method is called with the
<span class="w"> </span>        parser as first argument.  The token the parser stream is pointing at
<span class="w"> </span>        is the name token that matched.  This method has to return one or a
<span class="w"> </span>        list of multiple nodes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def attr(self, name: str, lineno: t.Optional[int]=None</span>
<span class="gd">-        ) -&gt;nodes.ExtensionAttribute:</span>
<span class="gi">+    def attr(</span>
<span class="gi">+        self, name: str, lineno: t.Optional[int] = None</span>
<span class="gi">+    ) -&gt; nodes.ExtensionAttribute:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an attribute node for the current extension.  This is useful
<span class="w"> </span>        to pass constants on extensions to generated template code.

<span class="gu">@@ -99,59 +133,483 @@ class Extension:</span>

<span class="w"> </span>            self.attr(&#39;_my_attribute&#39;, lineno=lineno)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def call_method(self, name: str, args: t.Optional[t.List[nodes.Expr]]=</span>
<span class="gd">-        None, kwargs: t.Optional[t.List[nodes.Keyword]]=None, dyn_args: t.</span>
<span class="gd">-        Optional[nodes.Expr]=None, dyn_kwargs: t.Optional[nodes.Expr]=None,</span>
<span class="gd">-        lineno: t.Optional[int]=None) -&gt;nodes.Call:</span>
<span class="gi">+        return nodes.ExtensionAttribute(self.identifier, name, lineno=lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def call_method(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        args: t.Optional[t.List[nodes.Expr]] = None,</span>
<span class="gi">+        kwargs: t.Optional[t.List[nodes.Keyword]] = None,</span>
<span class="gi">+        dyn_args: t.Optional[nodes.Expr] = None,</span>
<span class="gi">+        dyn_kwargs: t.Optional[nodes.Expr] = None,</span>
<span class="gi">+        lineno: t.Optional[int] = None,</span>
<span class="gi">+    ) -&gt; nodes.Call:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call a method of the extension.  This is a shortcut for
<span class="w"> </span>        :meth:`attr` + :class:`jinja2.nodes.Call`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if args is None:</span>
<span class="gi">+            args = []</span>
<span class="gi">+        if kwargs is None:</span>
<span class="gi">+            kwargs = []</span>
<span class="gi">+        return nodes.Call(</span>
<span class="gi">+            self.attr(name, lineno=lineno),</span>
<span class="gi">+            args,</span>
<span class="gi">+            kwargs,</span>
<span class="gi">+            dyn_args,</span>
<span class="gi">+            dyn_kwargs,</span>
<span class="gi">+            lineno=lineno,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@pass_context</span>
<span class="gi">+def _gettext_alias(</span>
<span class="gi">+    __context: Context, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+) -&gt; t.Union[t.Any, Undefined]:</span>
<span class="gi">+    return __context.call(__context.resolve(&quot;gettext&quot;), *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_new_gettext(func: t.Callable[[str], str]) -&gt; t.Callable[..., str]:</span>
<span class="gi">+    @pass_context</span>
<span class="gi">+    def gettext(__context: Context, __string: str, **variables: t.Any) -&gt; str:</span>
<span class="gi">+        rv = __context.call(func, __string)</span>
<span class="gi">+        if __context.eval_ctx.autoescape:</span>
<span class="gi">+            rv = Markup(rv)</span>
<span class="gi">+        # Always treat as a format string, even if there are no</span>
<span class="gi">+        # variables. This makes translation strings more consistent</span>
<span class="gi">+        # and predictable. This requires escaping</span>
<span class="gi">+        return rv % variables  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return gettext</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_new_ngettext(func: t.Callable[[str, str, int], str]) -&gt; t.Callable[..., str]:</span>
<span class="gi">+    @pass_context</span>
<span class="gi">+    def ngettext(</span>
<span class="gi">+        __context: Context,</span>
<span class="gi">+        __singular: str,</span>
<span class="gi">+        __plural: str,</span>
<span class="gi">+        __num: int,</span>
<span class="gi">+        **variables: t.Any,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        variables.setdefault(&quot;num&quot;, __num)</span>
<span class="gi">+        rv = __context.call(func, __singular, __plural, __num)</span>
<span class="gi">+        if __context.eval_ctx.autoescape:</span>
<span class="gi">+            rv = Markup(rv)</span>
<span class="gi">+        # Always treat as a format string, see gettext comment above.</span>
<span class="gi">+        return rv % variables  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return ngettext</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_new_pgettext(func: t.Callable[[str, str], str]) -&gt; t.Callable[..., str]:</span>
<span class="gi">+    @pass_context</span>
<span class="gi">+    def pgettext(</span>
<span class="gi">+        __context: Context, __string_ctx: str, __string: str, **variables: t.Any</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        variables.setdefault(&quot;context&quot;, __string_ctx)</span>
<span class="gi">+        rv = __context.call(func, __string_ctx, __string)</span>
<span class="gi">+</span>
<span class="gi">+        if __context.eval_ctx.autoescape:</span>
<span class="gi">+            rv = Markup(rv)</span>
<span class="gi">+</span>
<span class="gi">+        # Always treat as a format string, see gettext comment above.</span>
<span class="gi">+        return rv % variables  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return pgettext</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_new_npgettext(</span>
<span class="gi">+    func: t.Callable[[str, str, str, int], str],</span>
<span class="gi">+) -&gt; t.Callable[..., str]:</span>
<span class="gi">+    @pass_context</span>
<span class="gi">+    def npgettext(</span>
<span class="gi">+        __context: Context,</span>
<span class="gi">+        __string_ctx: str,</span>
<span class="gi">+        __singular: str,</span>
<span class="gi">+        __plural: str,</span>
<span class="gi">+        __num: int,</span>
<span class="gi">+        **variables: t.Any,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        variables.setdefault(&quot;context&quot;, __string_ctx)</span>
<span class="gi">+        variables.setdefault(&quot;num&quot;, __num)</span>
<span class="gi">+        rv = __context.call(func, __string_ctx, __singular, __plural, __num)</span>
<span class="gi">+</span>
<span class="gi">+        if __context.eval_ctx.autoescape:</span>
<span class="gi">+            rv = Markup(rv)</span>
<span class="gi">+</span>
<span class="gi">+        # Always treat as a format string, see gettext comment above.</span>
<span class="gi">+        return rv % variables  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return npgettext</span>


<span class="w"> </span>class InternationalizationExtension(Extension):
<span class="w"> </span>    &quot;&quot;&quot;This extension adds gettext support to Jinja.&quot;&quot;&quot;
<span class="gd">-    tags = {&#39;trans&#39;}</span>

<span class="gd">-    def __init__(self, environment: Environment) -&gt;None:</span>
<span class="gi">+    tags = {&quot;trans&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: the i18n extension is currently reevaluating values in a few</span>
<span class="gi">+    # situations.  Take this example:</span>
<span class="gi">+    #   {% trans count=something() %}{{ count }} foo{% pluralize</span>
<span class="gi">+    #     %}{{ count }} fooss{% endtrans %}</span>
<span class="gi">+    # something is called twice here.  One time for the gettext value and</span>
<span class="gi">+    # the other time for the n-parameter of the ngettext function.</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, environment: Environment) -&gt; None:</span>
<span class="w"> </span>        super().__init__(environment)
<span class="gd">-        environment.globals[&#39;_&#39;] = _gettext_alias</span>
<span class="gd">-        environment.extend(install_gettext_translations=self._install,</span>
<span class="gi">+        environment.globals[&quot;_&quot;] = _gettext_alias</span>
<span class="gi">+        environment.extend(</span>
<span class="gi">+            install_gettext_translations=self._install,</span>
<span class="w"> </span>            install_null_translations=self._install_null,
<span class="w"> </span>            install_gettext_callables=self._install_callables,
<span class="w"> </span>            uninstall_gettext_translations=self._uninstall,
<span class="gd">-            extract_translations=self._extract, newstyle_gettext=False)</span>
<span class="gd">-</span>
<span class="gd">-    def parse(self, parser: &#39;Parser&#39;) -&gt;t.Union[nodes.Node, t.List[nodes.Node]</span>
<span class="gd">-        ]:</span>
<span class="gi">+            extract_translations=self._extract,</span>
<span class="gi">+            newstyle_gettext=False,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _install(</span>
<span class="gi">+        self, translations: &quot;_SupportedTranslations&quot;, newstyle: t.Optional[bool] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # ugettext and ungettext are preferred in case the I18N library</span>
<span class="gi">+        # is providing compatibility with older Python versions.</span>
<span class="gi">+        gettext = getattr(translations, &quot;ugettext&quot;, None)</span>
<span class="gi">+        if gettext is None:</span>
<span class="gi">+            gettext = translations.gettext</span>
<span class="gi">+        ngettext = getattr(translations, &quot;ungettext&quot;, None)</span>
<span class="gi">+        if ngettext is None:</span>
<span class="gi">+            ngettext = translations.ngettext</span>
<span class="gi">+</span>
<span class="gi">+        pgettext = getattr(translations, &quot;pgettext&quot;, None)</span>
<span class="gi">+        npgettext = getattr(translations, &quot;npgettext&quot;, None)</span>
<span class="gi">+        self._install_callables(</span>
<span class="gi">+            gettext, ngettext, newstyle=newstyle, pgettext=pgettext, npgettext=npgettext</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _install_null(self, newstyle: t.Optional[bool] = None) -&gt; None:</span>
<span class="gi">+        import gettext</span>
<span class="gi">+</span>
<span class="gi">+        translations = gettext.NullTranslations()</span>
<span class="gi">+</span>
<span class="gi">+        if hasattr(translations, &quot;pgettext&quot;):</span>
<span class="gi">+            # Python &lt; 3.8</span>
<span class="gi">+            pgettext = translations.pgettext</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def pgettext(c: str, s: str) -&gt; str:  # type: ignore[misc]</span>
<span class="gi">+                return s</span>
<span class="gi">+</span>
<span class="gi">+        if hasattr(translations, &quot;npgettext&quot;):</span>
<span class="gi">+            npgettext = translations.npgettext</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def npgettext(c: str, s: str, p: str, n: int) -&gt; str:  # type: ignore[misc]</span>
<span class="gi">+                return s if n == 1 else p</span>
<span class="gi">+</span>
<span class="gi">+        self._install_callables(</span>
<span class="gi">+            gettext=translations.gettext,</span>
<span class="gi">+            ngettext=translations.ngettext,</span>
<span class="gi">+            newstyle=newstyle,</span>
<span class="gi">+            pgettext=pgettext,</span>
<span class="gi">+            npgettext=npgettext,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _install_callables(</span>
<span class="gi">+        self,</span>
<span class="gi">+        gettext: t.Callable[[str], str],</span>
<span class="gi">+        ngettext: t.Callable[[str, str, int], str],</span>
<span class="gi">+        newstyle: t.Optional[bool] = None,</span>
<span class="gi">+        pgettext: t.Optional[t.Callable[[str, str], str]] = None,</span>
<span class="gi">+        npgettext: t.Optional[t.Callable[[str, str, str, int], str]] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if newstyle is not None:</span>
<span class="gi">+            self.environment.newstyle_gettext = newstyle  # type: ignore</span>
<span class="gi">+        if self.environment.newstyle_gettext:  # type: ignore</span>
<span class="gi">+            gettext = _make_new_gettext(gettext)</span>
<span class="gi">+            ngettext = _make_new_ngettext(ngettext)</span>
<span class="gi">+</span>
<span class="gi">+            if pgettext is not None:</span>
<span class="gi">+                pgettext = _make_new_pgettext(pgettext)</span>
<span class="gi">+</span>
<span class="gi">+            if npgettext is not None:</span>
<span class="gi">+                npgettext = _make_new_npgettext(npgettext)</span>
<span class="gi">+</span>
<span class="gi">+        self.environment.globals.update(</span>
<span class="gi">+            gettext=gettext, ngettext=ngettext, pgettext=pgettext, npgettext=npgettext</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _uninstall(self, translations: &quot;_SupportedTranslations&quot;) -&gt; None:</span>
<span class="gi">+        for key in (&quot;gettext&quot;, &quot;ngettext&quot;, &quot;pgettext&quot;, &quot;npgettext&quot;):</span>
<span class="gi">+            self.environment.globals.pop(key, None)</span>
<span class="gi">+</span>
<span class="gi">+    def _extract(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: t.Union[str, nodes.Template],</span>
<span class="gi">+        gettext_functions: t.Sequence[str] = GETTEXT_FUNCTIONS,</span>
<span class="gi">+    ) -&gt; t.Iterator[</span>
<span class="gi">+        t.Tuple[int, str, t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]]]</span>
<span class="gi">+    ]:</span>
<span class="gi">+        if isinstance(source, str):</span>
<span class="gi">+            source = self.environment.parse(source)</span>
<span class="gi">+        return extract_from_ast(source, gettext_functions)</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, parser: &quot;Parser&quot;) -&gt; t.Union[nodes.Node, t.List[nodes.Node]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse a translatable tag.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _parse_block(self, parser: &#39;Parser&#39;, allow_pluralize: bool) -&gt;t.Tuple[</span>
<span class="gd">-        t.List[str], str]:</span>
<span class="gi">+        lineno = next(parser.stream).lineno</span>
<span class="gi">+</span>
<span class="gi">+        context = None</span>
<span class="gi">+        context_token = parser.stream.next_if(&quot;string&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if context_token is not None:</span>
<span class="gi">+            context = context_token.value</span>
<span class="gi">+</span>
<span class="gi">+        # find all the variables referenced.  Additionally a variable can be</span>
<span class="gi">+        # defined in the body of the trans block too, but this is checked at</span>
<span class="gi">+        # a later state.</span>
<span class="gi">+        plural_expr: t.Optional[nodes.Expr] = None</span>
<span class="gi">+        plural_expr_assignment: t.Optional[nodes.Assign] = None</span>
<span class="gi">+        num_called_num = False</span>
<span class="gi">+        variables: t.Dict[str, nodes.Expr] = {}</span>
<span class="gi">+        trimmed = None</span>
<span class="gi">+        while parser.stream.current.type != &quot;block_end&quot;:</span>
<span class="gi">+            if variables:</span>
<span class="gi">+                parser.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            # skip colon for python compatibility</span>
<span class="gi">+            if parser.stream.skip_if(&quot;colon&quot;):</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            token = parser.stream.expect(&quot;name&quot;)</span>
<span class="gi">+            if token.value in variables:</span>
<span class="gi">+                parser.fail(</span>
<span class="gi">+                    f&quot;translatable variable {token.value!r} defined twice.&quot;,</span>
<span class="gi">+                    token.lineno,</span>
<span class="gi">+                    exc=TemplateAssertionError,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # expressions</span>
<span class="gi">+            if parser.stream.current.type == &quot;assign&quot;:</span>
<span class="gi">+                next(parser.stream)</span>
<span class="gi">+                variables[token.value] = var = parser.parse_expression()</span>
<span class="gi">+            elif trimmed is None and token.value in (&quot;trimmed&quot;, &quot;notrimmed&quot;):</span>
<span class="gi">+                trimmed = token.value == &quot;trimmed&quot;</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                variables[token.value] = var = nodes.Name(token.value, &quot;load&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if plural_expr is None:</span>
<span class="gi">+                if isinstance(var, nodes.Call):</span>
<span class="gi">+                    plural_expr = nodes.Name(&quot;_trans&quot;, &quot;load&quot;)</span>
<span class="gi">+                    variables[token.value] = plural_expr</span>
<span class="gi">+                    plural_expr_assignment = nodes.Assign(</span>
<span class="gi">+                        nodes.Name(&quot;_trans&quot;, &quot;store&quot;), var</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    plural_expr = var</span>
<span class="gi">+                num_called_num = token.value == &quot;num&quot;</span>
<span class="gi">+</span>
<span class="gi">+        parser.stream.expect(&quot;block_end&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        plural = None</span>
<span class="gi">+        have_plural = False</span>
<span class="gi">+        referenced = set()</span>
<span class="gi">+</span>
<span class="gi">+        # now parse until endtrans or pluralize</span>
<span class="gi">+        singular_names, singular = self._parse_block(parser, True)</span>
<span class="gi">+        if singular_names:</span>
<span class="gi">+            referenced.update(singular_names)</span>
<span class="gi">+            if plural_expr is None:</span>
<span class="gi">+                plural_expr = nodes.Name(singular_names[0], &quot;load&quot;)</span>
<span class="gi">+                num_called_num = singular_names[0] == &quot;num&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # if we have a pluralize block, we parse that too</span>
<span class="gi">+        if parser.stream.current.test(&quot;name:pluralize&quot;):</span>
<span class="gi">+            have_plural = True</span>
<span class="gi">+            next(parser.stream)</span>
<span class="gi">+            if parser.stream.current.type != &quot;block_end&quot;:</span>
<span class="gi">+                token = parser.stream.expect(&quot;name&quot;)</span>
<span class="gi">+                if token.value not in variables:</span>
<span class="gi">+                    parser.fail(</span>
<span class="gi">+                        f&quot;unknown variable {token.value!r} for pluralization&quot;,</span>
<span class="gi">+                        token.lineno,</span>
<span class="gi">+                        exc=TemplateAssertionError,</span>
<span class="gi">+                    )</span>
<span class="gi">+                plural_expr = variables[token.value]</span>
<span class="gi">+                num_called_num = token.value == &quot;num&quot;</span>
<span class="gi">+            parser.stream.expect(&quot;block_end&quot;)</span>
<span class="gi">+            plural_names, plural = self._parse_block(parser, False)</span>
<span class="gi">+            next(parser.stream)</span>
<span class="gi">+            referenced.update(plural_names)</span>
<span class="gi">+        else:</span>
<span class="gi">+            next(parser.stream)</span>
<span class="gi">+</span>
<span class="gi">+        # register free names as simple name expressions</span>
<span class="gi">+        for name in referenced:</span>
<span class="gi">+            if name not in variables:</span>
<span class="gi">+                variables[name] = nodes.Name(name, &quot;load&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not have_plural:</span>
<span class="gi">+            plural_expr = None</span>
<span class="gi">+        elif plural_expr is None:</span>
<span class="gi">+            parser.fail(&quot;pluralize without variables&quot;, lineno)</span>
<span class="gi">+</span>
<span class="gi">+        if trimmed is None:</span>
<span class="gi">+            trimmed = self.environment.policies[&quot;ext.i18n.trimmed&quot;]</span>
<span class="gi">+        if trimmed:</span>
<span class="gi">+            singular = self._trim_whitespace(singular)</span>
<span class="gi">+            if plural:</span>
<span class="gi">+                plural = self._trim_whitespace(plural)</span>
<span class="gi">+</span>
<span class="gi">+        node = self._make_node(</span>
<span class="gi">+            singular,</span>
<span class="gi">+            plural,</span>
<span class="gi">+            context,</span>
<span class="gi">+            variables,</span>
<span class="gi">+            plural_expr,</span>
<span class="gi">+            bool(referenced),</span>
<span class="gi">+            num_called_num and have_plural,</span>
<span class="gi">+        )</span>
<span class="gi">+        node.set_lineno(lineno)</span>
<span class="gi">+        if plural_expr_assignment is not None:</span>
<span class="gi">+            return [plural_expr_assignment, node]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return node</span>
<span class="gi">+</span>
<span class="gi">+    def _trim_whitespace(self, string: str, _ws_re: t.Pattern[str] = _ws_re) -&gt; str:</span>
<span class="gi">+        return _ws_re.sub(&quot; &quot;, string.strip())</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_block(</span>
<span class="gi">+        self, parser: &quot;Parser&quot;, allow_pluralize: bool</span>
<span class="gi">+    ) -&gt; t.Tuple[t.List[str], str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse until the next block tag with a given name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _make_node(self, singular: str, plural: t.Optional[str], context: t</span>
<span class="gd">-        .Optional[str], variables: t.Dict[str, nodes.Expr], plural_expr: t.</span>
<span class="gd">-        Optional[nodes.Expr], vars_referenced: bool, num_called_num: bool</span>
<span class="gd">-        ) -&gt;nodes.Output:</span>
<span class="gi">+        referenced = []</span>
<span class="gi">+        buf = []</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if parser.stream.current.type == &quot;data&quot;:</span>
<span class="gi">+                buf.append(parser.stream.current.value.replace(&quot;%&quot;, &quot;%%&quot;))</span>
<span class="gi">+                next(parser.stream)</span>
<span class="gi">+            elif parser.stream.current.type == &quot;variable_begin&quot;:</span>
<span class="gi">+                next(parser.stream)</span>
<span class="gi">+                name = parser.stream.expect(&quot;name&quot;).value</span>
<span class="gi">+                referenced.append(name)</span>
<span class="gi">+                buf.append(f&quot;%({name})s&quot;)</span>
<span class="gi">+                parser.stream.expect(&quot;variable_end&quot;)</span>
<span class="gi">+            elif parser.stream.current.type == &quot;block_begin&quot;:</span>
<span class="gi">+                next(parser.stream)</span>
<span class="gi">+                block_name = (</span>
<span class="gi">+                    parser.stream.current.value</span>
<span class="gi">+                    if parser.stream.current.type == &quot;name&quot;</span>
<span class="gi">+                    else None</span>
<span class="gi">+                )</span>
<span class="gi">+                if block_name == &quot;endtrans&quot;:</span>
<span class="gi">+                    break</span>
<span class="gi">+                elif block_name == &quot;pluralize&quot;:</span>
<span class="gi">+                    if allow_pluralize:</span>
<span class="gi">+                        break</span>
<span class="gi">+                    parser.fail(</span>
<span class="gi">+                        &quot;a translatable section can have only one pluralize section&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif block_name == &quot;trans&quot;:</span>
<span class="gi">+                    parser.fail(</span>
<span class="gi">+                        &quot;trans blocks can&#39;t be nested; did you mean `endtrans`?&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                parser.fail(</span>
<span class="gi">+                    f&quot;control structures in translatable sections are not allowed; &quot;</span>
<span class="gi">+                    f&quot;saw `{block_name}`&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            elif parser.stream.eos:</span>
<span class="gi">+                parser.fail(&quot;unclosed translation block&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise RuntimeError(&quot;internal parser error&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return referenced, concat(buf)</span>
<span class="gi">+</span>
<span class="gi">+    def _make_node(</span>
<span class="gi">+        self,</span>
<span class="gi">+        singular: str,</span>
<span class="gi">+        plural: t.Optional[str],</span>
<span class="gi">+        context: t.Optional[str],</span>
<span class="gi">+        variables: t.Dict[str, nodes.Expr],</span>
<span class="gi">+        plural_expr: t.Optional[nodes.Expr],</span>
<span class="gi">+        vars_referenced: bool,</span>
<span class="gi">+        num_called_num: bool,</span>
<span class="gi">+    ) -&gt; nodes.Output:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a useful node from the data provided.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        newstyle = self.environment.newstyle_gettext  # type: ignore</span>
<span class="gi">+        node: nodes.Expr</span>
<span class="gi">+</span>
<span class="gi">+        # no variables referenced?  no need to escape for old style</span>
<span class="gi">+        # gettext invocations only if there are vars.</span>
<span class="gi">+        if not vars_referenced and not newstyle:</span>
<span class="gi">+            singular = singular.replace(&quot;%%&quot;, &quot;%&quot;)</span>
<span class="gi">+            if plural:</span>
<span class="gi">+                plural = plural.replace(&quot;%%&quot;, &quot;%&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        func_name = &quot;gettext&quot;</span>
<span class="gi">+        func_args: t.List[nodes.Expr] = [nodes.Const(singular)]</span>
<span class="gi">+</span>
<span class="gi">+        if context is not None:</span>
<span class="gi">+            func_args.insert(0, nodes.Const(context))</span>
<span class="gi">+            func_name = f&quot;p{func_name}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if plural_expr is not None:</span>
<span class="gi">+            func_name = f&quot;n{func_name}&quot;</span>
<span class="gi">+            func_args.extend((nodes.Const(plural), plural_expr))</span>
<span class="gi">+</span>
<span class="gi">+        node = nodes.Call(nodes.Name(func_name, &quot;load&quot;), func_args, [], None, None)</span>
<span class="gi">+</span>
<span class="gi">+        # in case newstyle gettext is used, the method is powerful</span>
<span class="gi">+        # enough to handle the variable expansion and autoescape</span>
<span class="gi">+        # handling itself</span>
<span class="gi">+        if newstyle:</span>
<span class="gi">+            for key, value in variables.items():</span>
<span class="gi">+                # the function adds that later anyways in case num was</span>
<span class="gi">+                # called num, so just skip it.</span>
<span class="gi">+                if num_called_num and key == &quot;num&quot;:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                node.kwargs.append(nodes.Keyword(key, value))</span>
<span class="gi">+</span>
<span class="gi">+        # otherwise do that here</span>
<span class="gi">+        else:</span>
<span class="gi">+            # mark the return value as safe if we are in an</span>
<span class="gi">+            # environment with autoescaping turned on</span>
<span class="gi">+            node = nodes.MarkSafeIfAutoescape(node)</span>
<span class="gi">+            if variables:</span>
<span class="gi">+                node = nodes.Mod(</span>
<span class="gi">+                    node,</span>
<span class="gi">+                    nodes.Dict(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            nodes.Pair(nodes.Const(key), value)</span>
<span class="gi">+                            for key, value in variables.items()</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+        return nodes.Output([node])</span>


<span class="w"> </span>class ExprStmtExtension(Extension):
<span class="w"> </span>    &quot;&quot;&quot;Adds a `do` tag to Jinja that works like the print statement just
<span class="w"> </span>    that it doesn&#39;t print the return value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    tags = {&#39;do&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    tags = {&quot;do&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, parser: &quot;Parser&quot;) -&gt; nodes.ExprStmt:</span>
<span class="gi">+        node = nodes.ExprStmt(lineno=next(parser.stream).lineno)</span>
<span class="gi">+        node.node = parser.parse_tuple()</span>
<span class="gi">+        return node</span>


<span class="w"> </span>class LoopControlExtension(Extension):
<span class="w"> </span>    &quot;&quot;&quot;Adds break and continue to the template engine.&quot;&quot;&quot;
<span class="gd">-    tags = {&#39;break&#39;, &#39;continue&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    tags = {&quot;break&quot;, &quot;continue&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, parser: &quot;Parser&quot;) -&gt; t.Union[nodes.Break, nodes.Continue]:</span>
<span class="gi">+        token = next(parser.stream)</span>
<span class="gi">+        if token.value == &quot;break&quot;:</span>
<span class="gi">+            return nodes.Break(lineno=token.lineno)</span>
<span class="gi">+        return nodes.Continue(lineno=token.lineno)</span>


<span class="w"> </span>class DebugExtension(Extension):
<span class="gu">@@ -174,12 +632,33 @@ class DebugExtension(Extension):</span>

<span class="w"> </span>    .. versionadded:: 2.11.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    tags = {&#39;debug&#39;}</span>

<span class="gi">+    tags = {&quot;debug&quot;}</span>

<span class="gd">-def extract_from_ast(ast: nodes.Template, gettext_functions: t.Sequence[str</span>
<span class="gd">-    ]=GETTEXT_FUNCTIONS, babel_style: bool=True) -&gt;t.Iterator[t.Tuple[int,</span>
<span class="gd">-    str, t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]]]]:</span>
<span class="gi">+    def parse(self, parser: &quot;Parser&quot;) -&gt; nodes.Output:</span>
<span class="gi">+        lineno = parser.stream.expect(&quot;name:debug&quot;).lineno</span>
<span class="gi">+        context = nodes.ContextReference()</span>
<span class="gi">+        result = self.call_method(&quot;_render&quot;, [context], lineno=lineno)</span>
<span class="gi">+        return nodes.Output([result], lineno=lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def _render(self, context: Context) -&gt; str:</span>
<span class="gi">+        result = {</span>
<span class="gi">+            &quot;context&quot;: context.get_all(),</span>
<span class="gi">+            &quot;filters&quot;: sorted(self.environment.filters.keys()),</span>
<span class="gi">+            &quot;tests&quot;: sorted(self.environment.tests.keys()),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # Set the depth since the intent is to show the top few names.</span>
<span class="gi">+        return pprint.pformat(result, depth=3, compact=True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_from_ast(</span>
<span class="gi">+    ast: nodes.Template,</span>
<span class="gi">+    gettext_functions: t.Sequence[str] = GETTEXT_FUNCTIONS,</span>
<span class="gi">+    babel_style: bool = True,</span>
<span class="gi">+) -&gt; t.Iterator[</span>
<span class="gi">+    t.Tuple[int, str, t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]]]</span>
<span class="gi">+]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract localizable strings from the given template node.  Per
<span class="w"> </span>    default this function returns matches in babel style that means non string
<span class="w"> </span>    parameters as well as keyword arguments are returned as `None`.  This
<span class="gu">@@ -214,7 +693,42 @@ def extract_from_ast(ast: nodes.Template, gettext_functions: t.Sequence[str</span>
<span class="w"> </span>    to extract any comments.  For comment support you have to use the babel
<span class="w"> </span>    extraction interface or extract comments yourself.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    out: t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]]</span>
<span class="gi">+</span>
<span class="gi">+    for node in ast.find_all(nodes.Call):</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(node.node, nodes.Name)</span>
<span class="gi">+            or node.node.name not in gettext_functions</span>
<span class="gi">+        ):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        strings: t.List[t.Optional[str]] = []</span>
<span class="gi">+</span>
<span class="gi">+        for arg in node.args:</span>
<span class="gi">+            if isinstance(arg, nodes.Const) and isinstance(arg.value, str):</span>
<span class="gi">+                strings.append(arg.value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                strings.append(None)</span>
<span class="gi">+</span>
<span class="gi">+        for _ in node.kwargs:</span>
<span class="gi">+            strings.append(None)</span>
<span class="gi">+        if node.dyn_args is not None:</span>
<span class="gi">+            strings.append(None)</span>
<span class="gi">+        if node.dyn_kwargs is not None:</span>
<span class="gi">+            strings.append(None)</span>
<span class="gi">+</span>
<span class="gi">+        if not babel_style:</span>
<span class="gi">+            out = tuple(x for x in strings if x is not None)</span>
<span class="gi">+</span>
<span class="gi">+            if not out:</span>
<span class="gi">+                continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            if len(strings) == 1:</span>
<span class="gi">+                out = strings[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                out = tuple(strings)</span>
<span class="gi">+</span>
<span class="gi">+        yield node.lineno, node.node.name, out</span>


<span class="w"> </span>class _CommentFinder:
<span class="gu">@@ -224,18 +738,49 @@ class _CommentFinder:</span>
<span class="w"> </span>    usable value.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, tokens: t.Sequence[t.Tuple[int, str, str]],</span>
<span class="gd">-        comment_tags: t.Sequence[str]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, tokens: t.Sequence[t.Tuple[int, str, str]], comment_tags: t.Sequence[str]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.tokens = tokens
<span class="w"> </span>        self.comment_tags = comment_tags
<span class="w"> </span>        self.offset = 0
<span class="w"> </span>        self.last_lineno = 0

<span class="gd">-</span>
<span class="gd">-def babel_extract(fileobj: t.BinaryIO, keywords: t.Sequence[str],</span>
<span class="gd">-    comment_tags: t.Sequence[str], options: t.Dict[str, t.Any]) -&gt;t.Iterator[t</span>
<span class="gd">-    .Tuple[int, str, t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]</span>
<span class="gd">-    ], t.List[str]]]:</span>
<span class="gi">+    def find_backwards(self, offset: int) -&gt; t.List[str]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            for _, token_type, token_value in reversed(</span>
<span class="gi">+                self.tokens[self.offset : offset]</span>
<span class="gi">+            ):</span>
<span class="gi">+                if token_type in (&quot;comment&quot;, &quot;linecomment&quot;):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        prefix, comment = token_value.split(None, 1)</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if prefix in self.comment_tags:</span>
<span class="gi">+                        return [comment.rstrip()]</span>
<span class="gi">+            return []</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.offset = offset</span>
<span class="gi">+</span>
<span class="gi">+    def find_comments(self, lineno: int) -&gt; t.List[str]:</span>
<span class="gi">+        if not self.comment_tags or self.last_lineno &gt; lineno:</span>
<span class="gi">+            return []</span>
<span class="gi">+        for idx, (token_lineno, _, _) in enumerate(self.tokens[self.offset :]):</span>
<span class="gi">+            if token_lineno &gt; lineno:</span>
<span class="gi">+                return self.find_backwards(self.offset + idx)</span>
<span class="gi">+        return self.find_backwards(len(self.tokens))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def babel_extract(</span>
<span class="gi">+    fileobj: t.BinaryIO,</span>
<span class="gi">+    keywords: t.Sequence[str],</span>
<span class="gi">+    comment_tags: t.Sequence[str],</span>
<span class="gi">+    options: t.Dict[str, t.Any],</span>
<span class="gi">+) -&gt; t.Iterator[</span>
<span class="gi">+    t.Tuple[</span>
<span class="gi">+        int, str, t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]], t.List[str]</span>
<span class="gi">+    ]</span>
<span class="gi">+]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Babel extraction method for Jinja templates.

<span class="w"> </span>    .. versionchanged:: 2.3
<span class="gu">@@ -263,9 +808,62 @@ def babel_extract(fileobj: t.BinaryIO, keywords: t.Sequence[str],</span>
<span class="w"> </span>    :return: an iterator over ``(lineno, funcname, message, comments)`` tuples.
<span class="w"> </span>             (comments will be empty currently)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    extensions: t.Dict[t.Type[Extension], None] = {}</span>
<span class="gi">+</span>
<span class="gi">+    for extension_name in options.get(&quot;extensions&quot;, &quot;&quot;).split(&quot;,&quot;):</span>
<span class="gi">+        extension_name = extension_name.strip()</span>
<span class="gi">+</span>
<span class="gi">+        if not extension_name:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        extensions[import_string(extension_name)] = None</span>
<span class="gi">+</span>
<span class="gi">+    if InternationalizationExtension not in extensions:</span>
<span class="gi">+        extensions[InternationalizationExtension] = None</span>
<span class="gi">+</span>
<span class="gi">+    def getbool(options: t.Mapping[str, str], key: str, default: bool = False) -&gt; bool:</span>
<span class="gi">+        return options.get(key, str(default)).lower() in {&quot;1&quot;, &quot;on&quot;, &quot;yes&quot;, &quot;true&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    silent = getbool(options, &quot;silent&quot;, True)</span>
<span class="gi">+    environment = Environment(</span>
<span class="gi">+        options.get(&quot;block_start_string&quot;, defaults.BLOCK_START_STRING),</span>
<span class="gi">+        options.get(&quot;block_end_string&quot;, defaults.BLOCK_END_STRING),</span>
<span class="gi">+        options.get(&quot;variable_start_string&quot;, defaults.VARIABLE_START_STRING),</span>
<span class="gi">+        options.get(&quot;variable_end_string&quot;, defaults.VARIABLE_END_STRING),</span>
<span class="gi">+        options.get(&quot;comment_start_string&quot;, defaults.COMMENT_START_STRING),</span>
<span class="gi">+        options.get(&quot;comment_end_string&quot;, defaults.COMMENT_END_STRING),</span>
<span class="gi">+        options.get(&quot;line_statement_prefix&quot;) or defaults.LINE_STATEMENT_PREFIX,</span>
<span class="gi">+        options.get(&quot;line_comment_prefix&quot;) or defaults.LINE_COMMENT_PREFIX,</span>
<span class="gi">+        getbool(options, &quot;trim_blocks&quot;, defaults.TRIM_BLOCKS),</span>
<span class="gi">+        getbool(options, &quot;lstrip_blocks&quot;, defaults.LSTRIP_BLOCKS),</span>
<span class="gi">+        defaults.NEWLINE_SEQUENCE,</span>
<span class="gi">+        getbool(options, &quot;keep_trailing_newline&quot;, defaults.KEEP_TRAILING_NEWLINE),</span>
<span class="gi">+        tuple(extensions),</span>
<span class="gi">+        cache_size=0,</span>
<span class="gi">+        auto_reload=False,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if getbool(options, &quot;trimmed&quot;):</span>
<span class="gi">+        environment.policies[&quot;ext.i18n.trimmed&quot;] = True</span>
<span class="gi">+    if getbool(options, &quot;newstyle_gettext&quot;):</span>
<span class="gi">+        environment.newstyle_gettext = True  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    source = fileobj.read().decode(options.get(&quot;encoding&quot;, &quot;utf-8&quot;))</span>
<span class="gi">+    try:</span>
<span class="gi">+        node = environment.parse(source)</span>
<span class="gi">+        tokens = list(environment.lex(environment.preprocess(source)))</span>
<span class="gi">+    except TemplateSyntaxError:</span>
<span class="gi">+        if not silent:</span>
<span class="gi">+            raise</span>
<span class="gi">+        # skip templates with syntax errors</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    finder = _CommentFinder(tokens, comment_tags)</span>
<span class="gi">+    for lineno, func, message in extract_from_ast(node, keywords):</span>
<span class="gi">+        yield lineno, func, message, finder.find_comments(lineno)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: nicer import names</span>
<span class="w"> </span>i18n = InternationalizationExtension
<span class="w"> </span>do = ExprStmtExtension
<span class="w"> </span>loopcontrols = LoopControlExtension
<span class="gh">diff --git a/src/jinja2/filters.py b/src/jinja2/filters.py</span>
<span class="gh">index 9498dc3..acd1197 100644</span>
<span class="gd">--- a/src/jinja2/filters.py</span>
<span class="gi">+++ b/src/jinja2/filters.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Built-in template filters used with the ``|`` operator.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="w"> </span>import random
<span class="w"> </span>import re
<span class="gu">@@ -7,9 +8,11 @@ import typing as t</span>
<span class="w"> </span>from collections import abc
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from itertools import groupby
<span class="gi">+</span>
<span class="w"> </span>from markupsafe import escape
<span class="w"> </span>from markupsafe import Markup
<span class="w"> </span>from markupsafe import soft_str
<span class="gi">+</span>
<span class="w"> </span>from .async_utils import async_variant
<span class="w"> </span>from .async_utils import auto_aiter
<span class="w"> </span>from .async_utils import auto_await
<span class="gu">@@ -23,43 +26,67 @@ from .utils import pass_eval_context</span>
<span class="w"> </span>from .utils import pformat
<span class="w"> </span>from .utils import url_quote
<span class="w"> </span>from .utils import urlize
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gi">+</span>
<span class="w"> </span>    from .environment import Environment
<span class="w"> </span>    from .nodes import EvalContext
<span class="w"> </span>    from .runtime import Context
<span class="gd">-    from .sandbox import SandboxedEnvironment</span>
<span class="gd">-</span>
<span class="gi">+    from .sandbox import SandboxedEnvironment  # noqa: F401</span>

<span class="w"> </span>    class HasHTML(te.Protocol):
<span class="gd">-</span>
<span class="gd">-        def __html__(self) -&gt;str:</span>
<span class="gi">+        def __html__(self) -&gt; str:</span>
<span class="w"> </span>            pass
<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>
<span class="gd">-K = t.TypeVar(&#39;K&#39;)</span>
<span class="gd">-V = t.TypeVar(&#39;V&#39;)</span>


<span class="gd">-def ignore_case(value: V) -&gt;V:</span>
<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+K = t.TypeVar(&quot;K&quot;)</span>
<span class="gi">+V = t.TypeVar(&quot;V&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ignore_case(value: V) -&gt; V:</span>
<span class="w"> </span>    &quot;&quot;&quot;For use as a postprocessor for :func:`make_attrgetter`. Converts strings
<span class="w"> </span>    to lowercase and returns other types as-is.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        return t.cast(V, value.lower())</span>
<span class="gi">+</span>
<span class="gi">+    return value</span>


<span class="gd">-def make_attrgetter(environment: &#39;Environment&#39;, attribute: t.Optional[t.</span>
<span class="gd">-    Union[str, int]], postprocess: t.Optional[t.Callable[[t.Any], t.Any]]=</span>
<span class="gd">-    None, default: t.Optional[t.Any]=None) -&gt;t.Callable[[t.Any], t.Any]:</span>
<span class="gi">+def make_attrgetter(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]],</span>
<span class="gi">+    postprocess: t.Optional[t.Callable[[t.Any], t.Any]] = None,</span>
<span class="gi">+    default: t.Optional[t.Any] = None,</span>
<span class="gi">+) -&gt; t.Callable[[t.Any], t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a callable that looks up the given attribute from a
<span class="w"> </span>    passed object with the rules of the environment.  Dots are allowed
<span class="w"> </span>    to access attributes of attributes.  Integer parts in paths are
<span class="w"> </span>    looked up as integers.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = _prepare_attribute_parts(attribute)</span>

<span class="gi">+    def attrgetter(item: t.Any) -&gt; t.Any:</span>
<span class="gi">+        for part in parts:</span>
<span class="gi">+            item = environment.getitem(item, part)</span>

<span class="gd">-def make_multi_attrgetter(environment: &#39;Environment&#39;, attribute: t.Optional</span>
<span class="gd">-    [t.Union[str, int]], postprocess: t.Optional[t.Callable[[t.Any], t.Any]</span>
<span class="gd">-    ]=None) -&gt;t.Callable[[t.Any], t.List[t.Any]]:</span>
<span class="gi">+            if default is not None and isinstance(item, Undefined):</span>
<span class="gi">+                item = default</span>
<span class="gi">+</span>
<span class="gi">+        if postprocess is not None:</span>
<span class="gi">+            item = postprocess(item)</span>
<span class="gi">+</span>
<span class="gi">+        return item</span>
<span class="gi">+</span>
<span class="gi">+    return attrgetter</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_multi_attrgetter(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]],</span>
<span class="gi">+    postprocess: t.Optional[t.Callable[[t.Any], t.Any]] = None,</span>
<span class="gi">+) -&gt; t.Callable[[t.Any], t.List[t.Any]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a callable that looks up the given comma separated
<span class="w"> </span>    attributes from a passed object with the rules of the environment.
<span class="w"> </span>    Dots are allowed to access attributes of each attribute.  Integer
<span class="gu">@@ -70,16 +97,55 @@ def make_multi_attrgetter(environment: &#39;Environment&#39;, attribute: t.Optional</span>

<span class="w"> </span>    Examples of attribute: &quot;attr1,attr2&quot;, &quot;attr1.inner1.0,attr2.inner2.0&quot;, etc.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(attribute, str):</span>
<span class="gi">+        split: t.Sequence[t.Union[str, int, None]] = attribute.split(&quot;,&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        split = [attribute]</span>
<span class="gi">+</span>
<span class="gi">+    parts = [_prepare_attribute_parts(item) for item in split]</span>
<span class="gi">+</span>
<span class="gi">+    def attrgetter(item: t.Any) -&gt; t.List[t.Any]:</span>
<span class="gi">+        items = [None] * len(parts)</span>
<span class="gi">+</span>
<span class="gi">+        for i, attribute_part in enumerate(parts):</span>
<span class="gi">+            item_i = item</span>
<span class="gi">+</span>
<span class="gi">+            for part in attribute_part:</span>
<span class="gi">+                item_i = environment.getitem(item_i, part)</span>

<span class="gi">+            if postprocess is not None:</span>
<span class="gi">+                item_i = postprocess(item_i)</span>

<span class="gd">-def do_forceescape(value: &#39;t.Union[str, HasHTML]&#39;) -&gt;Markup:</span>
<span class="gi">+            items[i] = item_i</span>
<span class="gi">+</span>
<span class="gi">+        return items</span>
<span class="gi">+</span>
<span class="gi">+    return attrgetter</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _prepare_attribute_parts(</span>
<span class="gi">+    attr: t.Optional[t.Union[str, int]],</span>
<span class="gi">+) -&gt; t.List[t.Union[str, int]]:</span>
<span class="gi">+    if attr is None:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(attr, str):</span>
<span class="gi">+        return [int(x) if x.isdigit() else x for x in attr.split(&quot;.&quot;)]</span>
<span class="gi">+</span>
<span class="gi">+    return [attr]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_forceescape(value: &quot;t.Union[str, HasHTML]&quot;) -&gt; Markup:</span>
<span class="w"> </span>    &quot;&quot;&quot;Enforce HTML escaping.  This will probably double escape variables.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(value, &quot;__html__&quot;):</span>
<span class="gi">+        value = t.cast(&quot;HasHTML&quot;, value).__html__()</span>
<span class="gi">+</span>
<span class="gi">+    return escape(str(value))</span>


<span class="gd">-def do_urlencode(value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.</span>
<span class="gd">-    Tuple[str, t.Any]]]) -&gt;str:</span>
<span class="gi">+def do_urlencode(</span>
<span class="gi">+    value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.Tuple[str, t.Any]]],</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Quote data for use in a URL path or query using UTF-8.

<span class="w"> </span>    Basic wrapper around :func:`urllib.parse.quote` when given a
<span class="gu">@@ -95,12 +161,23 @@ def do_urlencode(value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.</span>

<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, str) or not isinstance(value, abc.Iterable):</span>
<span class="gi">+        return url_quote(value)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, dict):</span>
<span class="gi">+        items: t.Iterable[t.Tuple[str, t.Any]] = value.items()</span>
<span class="gi">+    else:</span>
<span class="gi">+        items = value  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return &quot;&amp;&quot;.join(</span>
<span class="gi">+        f&quot;{url_quote(k, for_qs=True)}={url_quote(v, for_qs=True)}&quot; for k, v in items</span>
<span class="gi">+    )</span>


<span class="w"> </span>@pass_eval_context
<span class="gd">-def do_replace(eval_ctx: &#39;EvalContext&#39;, s: str, old: str, new: str, count:</span>
<span class="gd">-    t.Optional[int]=None) -&gt;str:</span>
<span class="gi">+def do_replace(</span>
<span class="gi">+    eval_ctx: &quot;EvalContext&quot;, s: str, old: str, new: str, count: t.Optional[int] = None</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a copy of the value with all occurrences of a substring
<span class="w"> </span>    replaced with a new one. The first argument is the substring
<span class="w"> </span>    that should be replaced, the second is the replacement string.
<span class="gu">@@ -115,21 +192,35 @@ def do_replace(eval_ctx: &#39;EvalContext&#39;, s: str, old: str, new: str, count:</span>
<span class="w"> </span>        {{ &quot;aaaaargh&quot;|replace(&quot;a&quot;, &quot;d&#39;oh, &quot;, 2) }}
<span class="w"> </span>            -&gt; d&#39;oh, d&#39;oh, aaargh
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if count is None:</span>
<span class="gi">+        count = -1</span>
<span class="gi">+</span>
<span class="gi">+    if not eval_ctx.autoescape:</span>
<span class="gi">+        return str(s).replace(str(old), str(new), count)</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        hasattr(old, &quot;__html__&quot;)</span>
<span class="gi">+        or hasattr(new, &quot;__html__&quot;)</span>
<span class="gi">+        and not hasattr(s, &quot;__html__&quot;)</span>
<span class="gi">+    ):</span>
<span class="gi">+        s = escape(s)</span>
<span class="gi">+    else:</span>
<span class="gi">+        s = soft_str(s)</span>
<span class="gi">+</span>
<span class="gi">+    return s.replace(soft_str(old), soft_str(new), count)</span>


<span class="gd">-def do_upper(s: str) -&gt;str:</span>
<span class="gi">+def do_upper(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a value to uppercase.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return soft_str(s).upper()</span>


<span class="gd">-def do_lower(s: str) -&gt;str:</span>
<span class="gi">+def do_lower(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a value to lowercase.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return soft_str(s).lower()</span>


<span class="gd">-def do_items(value: t.Union[t.Mapping[K, V], Undefined]) -&gt;t.Iterator[t.</span>
<span class="gd">-    Tuple[K, V]]:</span>
<span class="gi">+def do_items(value: t.Union[t.Mapping[K, V], Undefined]) -&gt; t.Iterator[t.Tuple[K, V]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return an iterator over the ``(key, value)`` items of a mapping.

<span class="w"> </span>    ``x|items`` is the same as ``x.items()``, except if ``x`` is
<span class="gu">@@ -150,15 +241,24 @@ def do_items(value: t.Union[t.Mapping[K, V], Undefined]) -&gt;t.Iterator[t.</span>

<span class="w"> </span>    .. versionadded:: 3.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, Undefined):</span>
<span class="gi">+        return</span>

<span class="gi">+    if not isinstance(value, abc.Mapping):</span>
<span class="gi">+        raise TypeError(&quot;Can only get item pairs from a mapping.&quot;)</span>

<span class="gd">-_attr_key_re = re.compile(&#39;[\\s/&gt;=]&#39;, flags=re.ASCII)</span>
<span class="gi">+    yield from value.items()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Check for characters that would move the parser state from key to value.</span>
<span class="gi">+# https://html.spec.whatwg.org/#attribute-name-state</span>
<span class="gi">+_attr_key_re = re.compile(r&quot;[\s/&gt;=]&quot;, flags=re.ASCII)</span>


<span class="w"> </span>@pass_eval_context
<span class="gd">-def do_xmlattr(eval_ctx: &#39;EvalContext&#39;, d: t.Mapping[str, t.Any], autospace:</span>
<span class="gd">-    bool=True) -&gt;str:</span>
<span class="gi">+def do_xmlattr(</span>
<span class="gi">+    eval_ctx: &quot;EvalContext&quot;, d: t.Mapping[str, t.Any], autospace: bool = True</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create an SGML/XML attribute string based on the items in a dict.

<span class="w"> </span>    **Values** that are neither ``none`` nor ``undefined`` are automatically
<span class="gu">@@ -195,29 +295,57 @@ def do_xmlattr(eval_ctx: &#39;EvalContext&#39;, d: t.Mapping[str, t.Any], autospace:</span>
<span class="w"> </span>    .. versionchanged:: 3.1.3
<span class="w"> </span>        Keys with spaces are not allowed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    items = []</span>
<span class="gi">+</span>
<span class="gi">+    for key, value in d.items():</span>
<span class="gi">+        if value is None or isinstance(value, Undefined):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if _attr_key_re.search(key) is not None:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid character in attribute name: {key!r}&quot;)</span>

<span class="gi">+        items.append(f&#39;{escape(key)}=&quot;{escape(value)}&quot;&#39;)</span>

<span class="gd">-def do_capitalize(s: str) -&gt;str:</span>
<span class="gi">+    rv = &quot; &quot;.join(items)</span>
<span class="gi">+</span>
<span class="gi">+    if autospace and rv:</span>
<span class="gi">+        rv = &quot; &quot; + rv</span>
<span class="gi">+</span>
<span class="gi">+    if eval_ctx.autoescape:</span>
<span class="gi">+        rv = Markup(rv)</span>
<span class="gi">+</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_capitalize(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Capitalize a value. The first character will be uppercase, all others
<span class="w"> </span>    lowercase.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return soft_str(s).capitalize()</span>


<span class="gd">-_word_beginning_split_re = re.compile(&#39;([-\\s({\\[&lt;]+)&#39;)</span>
<span class="gi">+_word_beginning_split_re = re.compile(r&quot;([-\s({\[&lt;]+)&quot;)</span>


<span class="gd">-def do_title(s: str) -&gt;str:</span>
<span class="gi">+def do_title(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a titlecased version of the value. I.e. words will start with
<span class="w"> </span>    uppercase letters, all remaining characters are lowercase.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def do_dictsort(value: t.Mapping[K, V], case_sensitive: bool=False, by:</span>
<span class="gd">-    &#39;te.Literal[&quot;key&quot;, &quot;value&quot;]&#39;=&#39;key&#39;, reverse: bool=False) -&gt;t.List[t.</span>
<span class="gd">-    Tuple[K, V]]:</span>
<span class="gi">+    return &quot;&quot;.join(</span>
<span class="gi">+        [</span>
<span class="gi">+            item[0].upper() + item[1:].lower()</span>
<span class="gi">+            for item in _word_beginning_split_re.split(soft_str(s))</span>
<span class="gi">+            if item</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_dictsort(</span>
<span class="gi">+    value: t.Mapping[K, V],</span>
<span class="gi">+    case_sensitive: bool = False,</span>
<span class="gi">+    by: &#39;te.Literal[&quot;key&quot;, &quot;value&quot;]&#39; = &quot;key&quot;,</span>
<span class="gi">+    reverse: bool = False,</span>
<span class="gi">+) -&gt; t.List[t.Tuple[K, V]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sort a dict and yield (key, value) pairs. Python dicts may not
<span class="w"> </span>    be in the order you want to display them in, so sort them first.

<span class="gu">@@ -235,13 +363,32 @@ def do_dictsort(value: t.Mapping[K, V], case_sensitive: bool=False, by:</span>
<span class="w"> </span>        {% for key, value in mydict|dictsort(false, &#39;value&#39;) %}
<span class="w"> </span>            sort the dict by value, case insensitive
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if by == &quot;key&quot;:</span>
<span class="gi">+        pos = 0</span>
<span class="gi">+    elif by == &quot;value&quot;:</span>
<span class="gi">+        pos = 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise FilterArgumentError(&#39;You can only sort by either &quot;key&quot; or &quot;value&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def sort_func(item: t.Tuple[t.Any, t.Any]) -&gt; t.Any:</span>
<span class="gi">+        value = item[pos]</span>
<span class="gi">+</span>
<span class="gi">+        if not case_sensitive:</span>
<span class="gi">+            value = ignore_case(value)</span>
<span class="gi">+</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    return sorted(value.items(), key=sort_func, reverse=reverse)</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def do_sort(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;, reverse:</span>
<span class="gd">-    bool=False, case_sensitive: bool=False, attribute: t.Optional[t.Union[</span>
<span class="gd">-    str, int]]=None) -&gt;&#39;t.List[V]&#39;:</span>
<span class="gi">+def do_sort(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    value: &quot;t.Iterable[V]&quot;,</span>
<span class="gi">+    reverse: bool = False,</span>
<span class="gi">+    case_sensitive: bool = False,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]] = None,</span>
<span class="gi">+) -&gt; &quot;t.List[V]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sort an iterable using Python&#39;s :func:`sorted`.

<span class="w"> </span>    .. sourcecode:: jinja
<span class="gu">@@ -284,13 +431,19 @@ def do_sort(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;, reverse:</span>
<span class="w"> </span>    .. versionchanged:: 2.6
<span class="w"> </span>       The ``attribute`` parameter was added.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key_func = make_multi_attrgetter(</span>
<span class="gi">+        environment, attribute, postprocess=ignore_case if not case_sensitive else None</span>
<span class="gi">+    )</span>
<span class="gi">+    return sorted(value, key=key_func, reverse=reverse)</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def do_unique(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;,</span>
<span class="gd">-    case_sensitive: bool=False, attribute: t.Optional[t.Union[str, int]]=None</span>
<span class="gd">-    ) -&gt;&#39;t.Iterator[V]&#39;:</span>
<span class="gi">+def do_unique(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    value: &quot;t.Iterable[V]&quot;,</span>
<span class="gi">+    case_sensitive: bool = False,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]] = None,</span>
<span class="gi">+) -&gt; &quot;t.Iterator[V]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a list of unique items from the given iterable.

<span class="w"> </span>    .. sourcecode:: jinja
<span class="gu">@@ -304,13 +457,46 @@ def do_unique(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;,</span>
<span class="w"> </span>    :param case_sensitive: Treat upper and lower case strings as distinct.
<span class="w"> </span>    :param attribute: Filter objects with unique values for this attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    getter = make_attrgetter(</span>
<span class="gi">+        environment, attribute, postprocess=ignore_case if not case_sensitive else None</span>
<span class="gi">+    )</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+</span>
<span class="gi">+    for item in value:</span>
<span class="gi">+        key = getter(item)</span>
<span class="gi">+</span>
<span class="gi">+        if key not in seen:</span>
<span class="gi">+            seen.add(key)</span>
<span class="gi">+            yield item</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _min_or_max(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    value: &quot;t.Iterable[V]&quot;,</span>
<span class="gi">+    func: &quot;t.Callable[..., V]&quot;,</span>
<span class="gi">+    case_sensitive: bool,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]],</span>
<span class="gi">+) -&gt; &quot;t.Union[V, Undefined]&quot;:</span>
<span class="gi">+    it = iter(value)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        first = next(it)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return environment.undefined(&quot;No aggregated item, sequence was empty.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    key_func = make_attrgetter(</span>
<span class="gi">+        environment, attribute, postprocess=ignore_case if not case_sensitive else None</span>
<span class="gi">+    )</span>
<span class="gi">+    return func(chain([first], it), key=key_func)</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def do_min(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;,</span>
<span class="gd">-    case_sensitive: bool=False, attribute: t.Optional[t.Union[str, int]]=None</span>
<span class="gd">-    ) -&gt;&#39;t.Union[V, Undefined]&#39;:</span>
<span class="gi">+def do_min(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    value: &quot;t.Iterable[V]&quot;,</span>
<span class="gi">+    case_sensitive: bool = False,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]] = None,</span>
<span class="gi">+) -&gt; &quot;t.Union[V, Undefined]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the smallest item from the sequence.

<span class="w"> </span>    .. sourcecode:: jinja
<span class="gu">@@ -321,13 +507,16 @@ def do_min(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;,</span>
<span class="w"> </span>    :param case_sensitive: Treat upper and lower case strings as distinct.
<span class="w"> </span>    :param attribute: Get the object with the min value of this attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _min_or_max(environment, value, min, case_sensitive, attribute)</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def do_max(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;,</span>
<span class="gd">-    case_sensitive: bool=False, attribute: t.Optional[t.Union[str, int]]=None</span>
<span class="gd">-    ) -&gt;&#39;t.Union[V, Undefined]&#39;:</span>
<span class="gi">+def do_max(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    value: &quot;t.Iterable[V]&quot;,</span>
<span class="gi">+    case_sensitive: bool = False,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]] = None,</span>
<span class="gi">+) -&gt; &quot;t.Union[V, Undefined]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the largest item from the sequence.

<span class="w"> </span>    .. sourcecode:: jinja
<span class="gu">@@ -338,10 +527,14 @@ def do_max(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;,</span>
<span class="w"> </span>    :param case_sensitive: Treat upper and lower case strings as distinct.
<span class="w"> </span>    :param attribute: Get the object with the max value of this attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _min_or_max(environment, value, max, case_sensitive, attribute)</span>


<span class="gd">-def do_default(value: V, default_value: V=&#39;&#39;, boolean: bool=False) -&gt;V:</span>
<span class="gi">+def do_default(</span>
<span class="gi">+    value: V,</span>
<span class="gi">+    default_value: V = &quot;&quot;,  # type: ignore</span>
<span class="gi">+    boolean: bool = False,</span>
<span class="gi">+) -&gt; V:</span>
<span class="w"> </span>    &quot;&quot;&quot;If the value is undefined it will return the passed default value,
<span class="w"> </span>    otherwise the value of the variable:

<span class="gu">@@ -364,12 +557,19 @@ def do_default(value: V, default_value: V=&#39;&#39;, boolean: bool=False) -&gt;V:</span>
<span class="w"> </span>       on nested elements and attributes that may contain undefined values
<span class="w"> </span>       in the chain without getting an :exc:`~jinja2.UndefinedError`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, Undefined) or (boolean and not value):</span>
<span class="gi">+        return default_value</span>
<span class="gi">+</span>
<span class="gi">+    return value</span>


<span class="w"> </span>@pass_eval_context
<span class="gd">-def sync_do_join(eval_ctx: &#39;EvalContext&#39;, value: t.Iterable[t.Any], d: str=</span>
<span class="gd">-    &#39;&#39;, attribute: t.Optional[t.Union[str, int]]=None) -&gt;str:</span>
<span class="gi">+def sync_do_join(</span>
<span class="gi">+    eval_ctx: &quot;EvalContext&quot;,</span>
<span class="gi">+    value: t.Iterable[t.Any],</span>
<span class="gi">+    d: str = &quot;&quot;,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]] = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a string which is the concatenation of the strings in the
<span class="w"> </span>    sequence. The separator between elements is an empty string per
<span class="w"> </span>    default, you can define it with the optional parameter:
<span class="gu">@@ -391,24 +591,76 @@ def sync_do_join(eval_ctx: &#39;EvalContext&#39;, value: t.Iterable[t.Any], d: str=</span>
<span class="w"> </span>    .. versionadded:: 2.6
<span class="w"> </span>       The `attribute` parameter was added.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if attribute is not None:</span>
<span class="gi">+        value = map(make_attrgetter(eval_ctx.environment, attribute), value)</span>

<span class="gi">+    # no automatic escaping?  joining is a lot easier then</span>
<span class="gi">+    if not eval_ctx.autoescape:</span>
<span class="gi">+        return str(d).join(map(str, value))</span>

<span class="gd">-def do_center(value: str, width: int=80) -&gt;str:</span>
<span class="gi">+    # if the delimiter doesn&#39;t have an html representation we check</span>
<span class="gi">+    # if any of the items has.  If yes we do a coercion to Markup</span>
<span class="gi">+    if not hasattr(d, &quot;__html__&quot;):</span>
<span class="gi">+        value = list(value)</span>
<span class="gi">+        do_escape = False</span>
<span class="gi">+</span>
<span class="gi">+        for idx, item in enumerate(value):</span>
<span class="gi">+            if hasattr(item, &quot;__html__&quot;):</span>
<span class="gi">+                do_escape = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                value[idx] = str(item)</span>
<span class="gi">+</span>
<span class="gi">+        if do_escape:</span>
<span class="gi">+            d = escape(d)</span>
<span class="gi">+        else:</span>
<span class="gi">+            d = str(d)</span>
<span class="gi">+</span>
<span class="gi">+        return d.join(value)</span>
<span class="gi">+</span>
<span class="gi">+    # no html involved, to normal joining</span>
<span class="gi">+    return soft_str(d).join(map(soft_str, value))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@async_variant(sync_do_join)  # type: ignore</span>
<span class="gi">+async def do_join(</span>
<span class="gi">+    eval_ctx: &quot;EvalContext&quot;,</span>
<span class="gi">+    value: t.Union[t.AsyncIterable[t.Any], t.Iterable[t.Any]],</span>
<span class="gi">+    d: str = &quot;&quot;,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]] = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    return sync_do_join(eval_ctx, await auto_to_list(value), d, attribute)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_center(value: str, width: int = 80) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Centers the value in a field of a given width.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return soft_str(value).center(width)</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def sync_do_first(environment: &#39;Environment&#39;, seq: &#39;t.Iterable[V]&#39;</span>
<span class="gd">-    ) -&gt;&#39;t.Union[V, Undefined]&#39;:</span>
<span class="gi">+def sync_do_first(</span>
<span class="gi">+    environment: &quot;Environment&quot;, seq: &quot;t.Iterable[V]&quot;</span>
<span class="gi">+) -&gt; &quot;t.Union[V, Undefined]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the first item of a sequence.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return next(iter(seq))</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return environment.undefined(&quot;No first item, sequence was empty.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@async_variant(sync_do_first)  # type: ignore</span>
<span class="gi">+async def do_first(</span>
<span class="gi">+    environment: &quot;Environment&quot;, seq: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span>
<span class="gi">+) -&gt; &quot;t.Union[V, Undefined]&quot;:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return await auto_aiter(seq).__anext__()</span>
<span class="gi">+    except StopAsyncIteration:</span>
<span class="gi">+        return environment.undefined(&quot;No first item, sequence was empty.&quot;)</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def do_last(environment: &#39;Environment&#39;, seq: &#39;t.Reversible[V]&#39;</span>
<span class="gd">-    ) -&gt;&#39;t.Union[V, Undefined]&#39;:</span>
<span class="gi">+def do_last(</span>
<span class="gi">+    environment: &quot;Environment&quot;, seq: &quot;t.Reversible[V]&quot;</span>
<span class="gi">+) -&gt; &quot;t.Union[V, Undefined]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the last item of a sequence.

<span class="w"> </span>    Note: Does not work with generators. You may want to explicitly
<span class="gu">@@ -418,39 +670,75 @@ def do_last(environment: &#39;Environment&#39;, seq: &#39;t.Reversible[V]&#39;</span>

<span class="w"> </span>        {{ data | selectattr(&#39;name&#39;, &#39;==&#39;, &#39;Jinja&#39;) | list | last }}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return next(iter(reversed(seq)))</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return environment.undefined(&quot;No last item, sequence was empty.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# No async do_last, it may not be safe in async mode.</span>


<span class="w"> </span>@pass_context
<span class="gd">-def do_random(context: &#39;Context&#39;, seq: &#39;t.Sequence[V]&#39;</span>
<span class="gd">-    ) -&gt;&#39;t.Union[V, Undefined]&#39;:</span>
<span class="gi">+def do_random(context: &quot;Context&quot;, seq: &quot;t.Sequence[V]&quot;) -&gt; &quot;t.Union[V, Undefined]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a random item from the sequence.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return random.choice(seq)</span>
<span class="gi">+    except IndexError:</span>
<span class="gi">+        return context.environment.undefined(&quot;No random item, sequence was empty.&quot;)</span>


<span class="gd">-def do_filesizeformat(value: t.Union[str, float, int], binary: bool=False</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+def do_filesizeformat(value: t.Union[str, float, int], binary: bool = False) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format the value like a &#39;human-readable&#39; file size (i.e. 13 kB,
<span class="w"> </span>    4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega,
<span class="w"> </span>    Giga, etc.), if the second parameter is set to `True` the binary
<span class="w"> </span>    prefixes are used (Mebi, Gibi).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def do_pprint(value: t.Any) -&gt;str:</span>
<span class="gi">+    bytes = float(value)</span>
<span class="gi">+    base = 1024 if binary else 1000</span>
<span class="gi">+    prefixes = [</span>
<span class="gi">+        (&quot;KiB&quot; if binary else &quot;kB&quot;),</span>
<span class="gi">+        (&quot;MiB&quot; if binary else &quot;MB&quot;),</span>
<span class="gi">+        (&quot;GiB&quot; if binary else &quot;GB&quot;),</span>
<span class="gi">+        (&quot;TiB&quot; if binary else &quot;TB&quot;),</span>
<span class="gi">+        (&quot;PiB&quot; if binary else &quot;PB&quot;),</span>
<span class="gi">+        (&quot;EiB&quot; if binary else &quot;EB&quot;),</span>
<span class="gi">+        (&quot;ZiB&quot; if binary else &quot;ZB&quot;),</span>
<span class="gi">+        (&quot;YiB&quot; if binary else &quot;YB&quot;),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    if bytes == 1:</span>
<span class="gi">+        return &quot;1 Byte&quot;</span>
<span class="gi">+    elif bytes &lt; base:</span>
<span class="gi">+        return f&quot;{int(bytes)} Bytes&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        for i, prefix in enumerate(prefixes):</span>
<span class="gi">+            unit = base ** (i + 2)</span>
<span class="gi">+</span>
<span class="gi">+            if bytes &lt; unit:</span>
<span class="gi">+                return f&quot;{base * bytes / unit:.1f} {prefix}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return f&quot;{base * bytes / unit:.1f} {prefix}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_pprint(value: t.Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pretty print a variable. Useful for debugging.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return pformat(value)</span>


<span class="gd">-_uri_scheme_re = re.compile(&#39;^([\\w.+-]{2,}:(/){0,2})$&#39;)</span>
<span class="gi">+_uri_scheme_re = re.compile(r&quot;^([\w.+-]{2,}:(/){0,2})$&quot;)</span>


<span class="w"> </span>@pass_eval_context
<span class="gd">-def do_urlize(eval_ctx: &#39;EvalContext&#39;, value: str, trim_url_limit: t.</span>
<span class="gd">-    Optional[int]=None, nofollow: bool=False, target: t.Optional[str]=None,</span>
<span class="gd">-    rel: t.Optional[str]=None, extra_schemes: t.Optional[t.Iterable[str]]=None</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+def do_urlize(</span>
<span class="gi">+    eval_ctx: &quot;EvalContext&quot;,</span>
<span class="gi">+    value: str,</span>
<span class="gi">+    trim_url_limit: t.Optional[int] = None,</span>
<span class="gi">+    nofollow: bool = False,</span>
<span class="gi">+    target: t.Optional[str] = None,</span>
<span class="gi">+    rel: t.Optional[str] = None,</span>
<span class="gi">+    extra_schemes: t.Optional[t.Iterable[str]] = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert URLs in text into clickable links.

<span class="w"> </span>    This may not recognize links in some situations. Usually, a more
<span class="gu">@@ -488,11 +776,42 @@ def do_urlize(eval_ctx: &#39;EvalContext&#39;, value: str, trim_url_limit: t.</span>
<span class="w"> </span>    .. versionchanged:: 2.8
<span class="w"> </span>       The ``target`` parameter was added.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    policies = eval_ctx.environment.policies</span>
<span class="gi">+    rel_parts = set((rel or &quot;&quot;).split())</span>
<span class="gi">+</span>
<span class="gi">+    if nofollow:</span>
<span class="gi">+        rel_parts.add(&quot;nofollow&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    rel_parts.update((policies[&quot;urlize.rel&quot;] or &quot;&quot;).split())</span>
<span class="gi">+    rel = &quot; &quot;.join(sorted(rel_parts)) or None</span>
<span class="gi">+</span>
<span class="gi">+    if target is None:</span>
<span class="gi">+        target = policies[&quot;urlize.target&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    if extra_schemes is None:</span>
<span class="gi">+        extra_schemes = policies[&quot;urlize.extra_schemes&quot;] or ()</span>

<span class="gi">+    for scheme in extra_schemes:</span>
<span class="gi">+        if _uri_scheme_re.fullmatch(scheme) is None:</span>
<span class="gi">+            raise FilterArgumentError(f&quot;{scheme!r} is not a valid URI scheme prefix.&quot;)</span>

<span class="gd">-def do_indent(s: str, width: t.Union[int, str]=4, first: bool=False, blank:</span>
<span class="gd">-    bool=False) -&gt;str:</span>
<span class="gi">+    rv = urlize(</span>
<span class="gi">+        value,</span>
<span class="gi">+        trim_url_limit=trim_url_limit,</span>
<span class="gi">+        rel=rel,</span>
<span class="gi">+        target=target,</span>
<span class="gi">+        extra_schemes=extra_schemes,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if eval_ctx.autoescape:</span>
<span class="gi">+        rv = Markup(rv)</span>
<span class="gi">+</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_indent(</span>
<span class="gi">+    s: str, width: t.Union[int, str] = 4, first: bool = False, blank: bool = False</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a copy of the string with each line indented by 4 spaces. The
<span class="w"> </span>    first line and blank lines are not indented by default.

<span class="gu">@@ -508,12 +827,45 @@ def do_indent(s: str, width: t.Union[int, str]=4, first: bool=False, blank:</span>

<span class="w"> </span>        Rename the ``indentfirst`` argument to ``first``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(width, str):</span>
<span class="gi">+        indention = width</span>
<span class="gi">+    else:</span>
<span class="gi">+        indention = &quot; &quot; * width</span>
<span class="gi">+</span>
<span class="gi">+    newline = &quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(s, Markup):</span>
<span class="gi">+        indention = Markup(indention)</span>
<span class="gi">+        newline = Markup(newline)</span>
<span class="gi">+</span>
<span class="gi">+    s += newline  # this quirk is necessary for splitlines method</span>
<span class="gi">+</span>
<span class="gi">+    if blank:</span>
<span class="gi">+        rv = (newline + indention).join(s.splitlines())</span>
<span class="gi">+    else:</span>
<span class="gi">+        lines = s.splitlines()</span>
<span class="gi">+        rv = lines.pop(0)</span>
<span class="gi">+</span>
<span class="gi">+        if lines:</span>
<span class="gi">+            rv += newline + newline.join(</span>
<span class="gi">+                indention + line if line else line for line in lines</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    if first:</span>
<span class="gi">+        rv = indention + rv</span>
<span class="gi">+</span>
<span class="gi">+    return rv</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def do_truncate(env: &#39;Environment&#39;, s: str, length: int=255, killwords:</span>
<span class="gd">-    bool=False, end: str=&#39;...&#39;, leeway: t.Optional[int]=None) -&gt;str:</span>
<span class="gi">+def do_truncate(</span>
<span class="gi">+    env: &quot;Environment&quot;,</span>
<span class="gi">+    s: str,</span>
<span class="gi">+    length: int = 255,</span>
<span class="gi">+    killwords: bool = False,</span>
<span class="gi">+    end: str = &quot;...&quot;,</span>
<span class="gi">+    leeway: t.Optional[int] = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a truncated copy of the string. The length is specified
<span class="w"> </span>    with the first parameter which defaults to ``255``. If the second
<span class="w"> </span>    parameter is ``true`` the filter will cut the text at length. Otherwise
<span class="gu">@@ -537,13 +889,31 @@ def do_truncate(env: &#39;Environment&#39;, s: str, length: int=255, killwords:</span>
<span class="w"> </span>    The default leeway on newer Jinja versions is 5 and was 0 before but
<span class="w"> </span>    can be reconfigured globally.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if leeway is None:</span>
<span class="gi">+        leeway = env.policies[&quot;truncate.leeway&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    assert length &gt;= len(end), f&quot;expected length &gt;= {len(end)}, got {length}&quot;</span>
<span class="gi">+    assert leeway &gt;= 0, f&quot;expected leeway &gt;= 0, got {leeway}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if len(s) &lt;= length + leeway:</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    if killwords:</span>
<span class="gi">+        return s[: length - len(end)] + end</span>
<span class="gi">+</span>
<span class="gi">+    result = s[: length - len(end)].rsplit(&quot; &quot;, 1)[0]</span>
<span class="gi">+    return result + end</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def do_wordwrap(environment: &#39;Environment&#39;, s: str, width: int=79,</span>
<span class="gd">-    break_long_words: bool=True, wrapstring: t.Optional[str]=None,</span>
<span class="gd">-    break_on_hyphens: bool=True) -&gt;str:</span>
<span class="gi">+def do_wordwrap(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    s: str,</span>
<span class="gi">+    width: int = 79,</span>
<span class="gi">+    break_long_words: bool = True,</span>
<span class="gi">+    wrapstring: t.Optional[str] = None,</span>
<span class="gi">+    break_on_hyphens: bool = True,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wrap a string to the given width. Existing newlines are treated
<span class="w"> </span>    as paragraphs to be wrapped separately.

<span class="gu">@@ -565,18 +935,41 @@ def do_wordwrap(environment: &#39;Environment&#39;, s: str, width: int=79,</span>
<span class="w"> </span>    .. versionchanged:: 2.7
<span class="w"> </span>        Added the ``wrapstring`` parameter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_word_re = re.compile(&#39;\\w+&#39;)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def do_wordcount(s: str) -&gt;int:</span>
<span class="gi">+    import textwrap</span>
<span class="gi">+</span>
<span class="gi">+    if wrapstring is None:</span>
<span class="gi">+        wrapstring = environment.newline_sequence</span>
<span class="gi">+</span>
<span class="gi">+    # textwrap.wrap doesn&#39;t consider existing newlines when wrapping.</span>
<span class="gi">+    # If the string has a newline before width, wrap will still insert</span>
<span class="gi">+    # a newline at width, resulting in a short line. Instead, split and</span>
<span class="gi">+    # wrap each paragraph individually.</span>
<span class="gi">+    return wrapstring.join(</span>
<span class="gi">+        [</span>
<span class="gi">+            wrapstring.join(</span>
<span class="gi">+                textwrap.wrap(</span>
<span class="gi">+                    line,</span>
<span class="gi">+                    width=width,</span>
<span class="gi">+                    expand_tabs=False,</span>
<span class="gi">+                    replace_whitespace=False,</span>
<span class="gi">+                    break_long_words=break_long_words,</span>
<span class="gi">+                    break_on_hyphens=break_on_hyphens,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            for line in s.splitlines()</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_word_re = re.compile(r&quot;\w+&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_wordcount(s: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Count the words in that string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(_word_re.findall(soft_str(s)))</span>


<span class="gd">-def do_int(value: t.Any, default: int=0, base: int=10) -&gt;int:</span>
<span class="gi">+def do_int(value: t.Any, default: int = 0, base: int = 10) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the value into an integer. If the
<span class="w"> </span>    conversion doesn&#39;t work it will return ``0``. You can
<span class="w"> </span>    override this default using the first parameter. You
<span class="gu">@@ -585,18 +978,31 @@ def do_int(value: t.Any, default: int=0, base: int=10) -&gt;int:</span>
<span class="w"> </span>    0b, 0o and 0x for bases 2, 8 and 16 respectively.
<span class="w"> </span>    The base is ignored for decimal numbers and non-string values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            return int(value, base)</span>

<span class="gi">+        return int(value)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        # this quirk is necessary so that &quot;42.23&quot;|int gives 42.</span>
<span class="gi">+        try:</span>
<span class="gi">+            return int(float(value))</span>
<span class="gi">+        except (TypeError, ValueError):</span>
<span class="gi">+            return default</span>

<span class="gd">-def do_float(value: t.Any, default: float=0.0) -&gt;float:</span>
<span class="gi">+</span>
<span class="gi">+def do_float(value: t.Any, default: float = 0.0) -&gt; float:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the value into a floating point number. If the
<span class="w"> </span>    conversion doesn&#39;t work it will return ``0.0``. You can
<span class="w"> </span>    override this default using the first parameter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return float(value)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        return default</span>


<span class="gd">-def do_format(value: str, *args: t.Any, **kwargs: t.Any) -&gt;str:</span>
<span class="gi">+def do_format(value: str, *args: t.Any, **kwargs: t.Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Apply the given values to a `printf-style`_ format string, like
<span class="w"> </span>    ``string % values``.

<span class="gu">@@ -616,21 +1022,30 @@ def do_format(value: str, *args: t.Any, **kwargs: t.Any) -&gt;str:</span>
<span class="w"> </span>    .. _printf-style: https://docs.python.org/library/stdtypes.html
<span class="w"> </span>        #printf-style-string-formatting
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if args and kwargs:</span>
<span class="gi">+        raise FilterArgumentError(</span>
<span class="gi">+            &quot;can&#39;t handle positional and keyword arguments at the same time&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return soft_str(value) % (kwargs or args)</span>


<span class="gd">-def do_trim(value: str, chars: t.Optional[str]=None) -&gt;str:</span>
<span class="gi">+def do_trim(value: str, chars: t.Optional[str] = None) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Strip leading and trailing characters, by default whitespace.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return soft_str(value).strip(chars)</span>


<span class="gd">-def do_striptags(value: &#39;t.Union[str, HasHTML]&#39;) -&gt;str:</span>
<span class="gi">+def do_striptags(value: &quot;t.Union[str, HasHTML]&quot;) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Strip SGML/XML tags and replace adjacent whitespace by one space.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(value, &quot;__html__&quot;):</span>
<span class="gi">+        value = t.cast(&quot;HasHTML&quot;, value).__html__()</span>
<span class="gi">+</span>
<span class="gi">+    return Markup(str(value)).striptags()</span>


<span class="gd">-def sync_do_slice(value: &#39;t.Collection[V]&#39;, slices: int, fill_with:</span>
<span class="gd">-    &#39;t.Optional[V]&#39;=None) -&gt;&#39;t.Iterator[t.List[V]]&#39;:</span>
<span class="gi">+def sync_do_slice(</span>
<span class="gi">+    value: &quot;t.Collection[V]&quot;, slices: int, fill_with: &quot;t.Optional[V]&quot; = None</span>
<span class="gi">+) -&gt; &quot;t.Iterator[t.List[V]]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Slice an iterator and return a list of lists containing
<span class="w"> </span>    those items. Useful if you want to create a div containing
<span class="w"> </span>    three ul tags that represent columns:
<span class="gu">@@ -650,11 +1065,39 @@ def sync_do_slice(value: &#39;t.Collection[V]&#39;, slices: int, fill_with:</span>
<span class="w"> </span>    If you pass it a second argument it&#39;s used to fill missing
<span class="w"> </span>    values on the last iteration.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seq = list(value)</span>
<span class="gi">+    length = len(seq)</span>
<span class="gi">+    items_per_slice = length // slices</span>
<span class="gi">+    slices_with_extra = length % slices</span>
<span class="gi">+    offset = 0</span>
<span class="gi">+</span>
<span class="gi">+    for slice_number in range(slices):</span>
<span class="gi">+        start = offset + slice_number * items_per_slice</span>
<span class="gi">+</span>
<span class="gi">+        if slice_number &lt; slices_with_extra:</span>
<span class="gi">+            offset += 1</span>
<span class="gi">+</span>
<span class="gi">+        end = offset + (slice_number + 1) * items_per_slice</span>
<span class="gi">+        tmp = seq[start:end]</span>
<span class="gi">+</span>
<span class="gi">+        if fill_with is not None and slice_number &gt;= slices_with_extra:</span>
<span class="gi">+            tmp.append(fill_with)</span>
<span class="gi">+</span>
<span class="gi">+        yield tmp</span>
<span class="gi">+</span>

<span class="gi">+@async_variant(sync_do_slice)  # type: ignore</span>
<span class="gi">+async def do_slice(</span>
<span class="gi">+    value: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+    slices: int,</span>
<span class="gi">+    fill_with: t.Optional[t.Any] = None,</span>
<span class="gi">+) -&gt; &quot;t.Iterator[t.List[V]]&quot;:</span>
<span class="gi">+    return sync_do_slice(await auto_to_list(value), slices, fill_with)</span>

<span class="gd">-def do_batch(value: &#39;t.Iterable[V]&#39;, linecount: int, fill_with:</span>
<span class="gd">-    &#39;t.Optional[V]&#39;=None) -&gt;&#39;t.Iterator[t.List[V]]&#39;:</span>
<span class="gi">+</span>
<span class="gi">+def do_batch(</span>
<span class="gi">+    value: &quot;t.Iterable[V]&quot;, linecount: int, fill_with: &quot;t.Optional[V]&quot; = None</span>
<span class="gi">+) -&gt; &quot;t.Iterator[t.List[V]]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A filter that batches items. It works pretty much like `slice`
<span class="w"> </span>    just the other way round. It returns a list of lists with the
<span class="gu">@@ -673,11 +1116,27 @@ def do_batch(value: &#39;t.Iterable[V]&#39;, linecount: int, fill_with:</span>
<span class="w"> </span>        {%- endfor %}
<span class="w"> </span>        &lt;/table&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tmp: &quot;t.List[V]&quot; = []</span>
<span class="gi">+</span>
<span class="gi">+    for item in value:</span>
<span class="gi">+        if len(tmp) == linecount:</span>
<span class="gi">+            yield tmp</span>
<span class="gi">+            tmp = []</span>
<span class="gi">+</span>
<span class="gi">+        tmp.append(item)</span>
<span class="gi">+</span>
<span class="gi">+    if tmp:</span>
<span class="gi">+        if fill_with is not None and len(tmp) &lt; linecount:</span>
<span class="gi">+            tmp += [fill_with] * (linecount - len(tmp))</span>
<span class="gi">+</span>
<span class="gi">+        yield tmp</span>


<span class="gd">-def do_round(value: float, precision: int=0, method:</span>
<span class="gd">-    &#39;te.Literal[&quot;common&quot;, &quot;ceil&quot;, &quot;floor&quot;]&#39;=&#39;common&#39;) -&gt;float:</span>
<span class="gi">+def do_round(</span>
<span class="gi">+    value: float,</span>
<span class="gi">+    precision: int = 0,</span>
<span class="gi">+    method: &#39;te.Literal[&quot;common&quot;, &quot;ceil&quot;, &quot;floor&quot;]&#39; = &quot;common&quot;,</span>
<span class="gi">+) -&gt; float:</span>
<span class="w"> </span>    &quot;&quot;&quot;Round the number to a given precision. The first
<span class="w"> </span>    parameter specifies the precision (default is ``0``), the
<span class="w"> </span>    second the rounding method:
<span class="gu">@@ -703,24 +1162,37 @@ def do_round(value: float, precision: int=0, method:</span>
<span class="w"> </span>        {{ 42.55|round|int }}
<span class="w"> </span>            -&gt; 43
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if method not in {&quot;common&quot;, &quot;ceil&quot;, &quot;floor&quot;}:</span>
<span class="gi">+        raise FilterArgumentError(&quot;method must be common, ceil or floor&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if method == &quot;common&quot;:</span>
<span class="gi">+        return round(value, precision)</span>
<span class="gi">+</span>
<span class="gi">+    func = getattr(math, method)</span>
<span class="gi">+    return t.cast(float, func(value * (10**precision)) / (10**precision))</span>


<span class="w"> </span>class _GroupTuple(t.NamedTuple):
<span class="w"> </span>    grouper: t.Any
<span class="w"> </span>    list: t.List[t.Any]

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    # Use the regular tuple repr to hide this subclass if users print</span>
<span class="gi">+    # out the value during debugging.</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return tuple.__repr__(self)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return tuple.__str__(self)


<span class="w"> </span>@pass_environment
<span class="gd">-def sync_do_groupby(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;,</span>
<span class="gd">-    attribute: t.Union[str, int], default: t.Optional[t.Any]=None,</span>
<span class="gd">-    case_sensitive: bool=False) -&gt;&#39;t.List[_GroupTuple]&#39;:</span>
<span class="gi">+def sync_do_groupby(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    value: &quot;t.Iterable[V]&quot;,</span>
<span class="gi">+    attribute: t.Union[str, int],</span>
<span class="gi">+    default: t.Optional[t.Any] = None,</span>
<span class="gi">+    case_sensitive: bool = False,</span>
<span class="gi">+) -&gt; &quot;t.List[_GroupTuple]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Group a sequence of objects by an attribute using Python&#39;s
<span class="w"> </span>    :func:`itertools.groupby`. The attribute can use dot notation for
<span class="w"> </span>    nested access, like ``&quot;address.city&quot;``. Unlike Python&#39;s ``groupby``,
<span class="gu">@@ -778,12 +1250,59 @@ def sync_do_groupby(environment: &#39;Environment&#39;, value: &#39;t.Iterable[V]&#39;,</span>
<span class="w"> </span>    .. versionchanged:: 2.6
<span class="w"> </span>        The attribute supports dot notation for nested access.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    expr = make_attrgetter(</span>
<span class="gi">+        environment,</span>
<span class="gi">+        attribute,</span>
<span class="gi">+        postprocess=ignore_case if not case_sensitive else None,</span>
<span class="gi">+        default=default,</span>
<span class="gi">+    )</span>
<span class="gi">+    out = [</span>
<span class="gi">+        _GroupTuple(key, list(values))</span>
<span class="gi">+        for key, values in groupby(sorted(value, key=expr), expr)</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    if not case_sensitive:</span>
<span class="gi">+        # Return the real key from the first value instead of the lowercase key.</span>
<span class="gi">+        output_expr = make_attrgetter(environment, attribute, default=default)</span>
<span class="gi">+        out = [_GroupTuple(output_expr(values[0]), values) for _, values in out]</span>
<span class="gi">+</span>
<span class="gi">+    return out</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@async_variant(sync_do_groupby)  # type: ignore</span>
<span class="gi">+async def do_groupby(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    value: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+    attribute: t.Union[str, int],</span>
<span class="gi">+    default: t.Optional[t.Any] = None,</span>
<span class="gi">+    case_sensitive: bool = False,</span>
<span class="gi">+) -&gt; &quot;t.List[_GroupTuple]&quot;:</span>
<span class="gi">+    expr = make_attrgetter(</span>
<span class="gi">+        environment,</span>
<span class="gi">+        attribute,</span>
<span class="gi">+        postprocess=ignore_case if not case_sensitive else None,</span>
<span class="gi">+        default=default,</span>
<span class="gi">+    )</span>
<span class="gi">+    out = [</span>
<span class="gi">+        _GroupTuple(key, await auto_to_list(values))</span>
<span class="gi">+        for key, values in groupby(sorted(await auto_to_list(value), key=expr), expr)</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    if not case_sensitive:</span>
<span class="gi">+        # Return the real key from the first value instead of the lowercase key.</span>
<span class="gi">+        output_expr = make_attrgetter(environment, attribute, default=default)</span>
<span class="gi">+        out = [_GroupTuple(output_expr(values[0]), values) for _, values in out]</span>
<span class="gi">+</span>
<span class="gi">+    return out</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def sync_do_sum(environment: &#39;Environment&#39;, iterable: &#39;t.Iterable[V]&#39;,</span>
<span class="gd">-    attribute: t.Optional[t.Union[str, int]]=None, start: V=0) -&gt;V:</span>
<span class="gi">+def sync_do_sum(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    iterable: &quot;t.Iterable[V]&quot;,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]] = None,</span>
<span class="gi">+    start: V = 0,  # type: ignore</span>
<span class="gi">+) -&gt; V:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the sum of a sequence of numbers plus the value of parameter
<span class="w"> </span>    &#39;start&#39; (which defaults to 0).  When the sequence is empty it returns
<span class="w"> </span>    start.
<span class="gu">@@ -798,51 +1317,139 @@ def sync_do_sum(environment: &#39;Environment&#39;, iterable: &#39;t.Iterable[V]&#39;,</span>
<span class="w"> </span>       The ``attribute`` parameter was added to allow summing up over
<span class="w"> </span>       attributes.  Also the ``start`` parameter was moved on to the right.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if attribute is not None:</span>
<span class="gi">+        iterable = map(make_attrgetter(environment, attribute), iterable)</span>
<span class="gi">+</span>
<span class="gi">+    return sum(iterable, start)  # type: ignore[no-any-return, call-overload]</span>
<span class="gi">+</span>

<span class="gi">+@async_variant(sync_do_sum)  # type: ignore</span>
<span class="gi">+async def do_sum(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    iterable: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+    attribute: t.Optional[t.Union[str, int]] = None,</span>
<span class="gi">+    start: V = 0,  # type: ignore</span>
<span class="gi">+) -&gt; V:</span>
<span class="gi">+    rv = start</span>

<span class="gd">-def sync_do_list(value: &#39;t.Iterable[V]&#39;) -&gt;&#39;t.List[V]&#39;:</span>
<span class="gi">+    if attribute is not None:</span>
<span class="gi">+        func = make_attrgetter(environment, attribute)</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def func(x: V) -&gt; V:</span>
<span class="gi">+            return x</span>
<span class="gi">+</span>
<span class="gi">+    async for item in auto_aiter(iterable):</span>
<span class="gi">+        rv += func(item)</span>
<span class="gi">+</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def sync_do_list(value: &quot;t.Iterable[V]&quot;) -&gt; &quot;t.List[V]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert the value into a list.  If it was a string the returned list
<span class="w"> </span>    will be a list of characters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(value)</span>


<span class="gd">-def do_mark_safe(value: str) -&gt;Markup:</span>
<span class="gi">+@async_variant(sync_do_list)  # type: ignore</span>
<span class="gi">+async def do_list(value: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;) -&gt; &quot;t.List[V]&quot;:</span>
<span class="gi">+    return await auto_to_list(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_mark_safe(value: str) -&gt; Markup:</span>
<span class="w"> </span>    &quot;&quot;&quot;Mark the value as safe which means that in an environment with automatic
<span class="w"> </span>    escaping enabled this variable will not be escaped.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Markup(value)</span>


<span class="gd">-def do_mark_unsafe(value: str) -&gt;str:</span>
<span class="gi">+def do_mark_unsafe(value: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Mark a value as unsafe.  This is the reverse operation for :func:`safe`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def do_reverse(value: str) -&gt; str: ...</span>


<span class="gd">-def do_reverse(value: t.Union[str, t.Iterable[V]]) -&gt;t.Union[str, t.Iterable[V]</span>
<span class="gd">-    ]:</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def do_reverse(value: &quot;t.Iterable[V]&quot;) -&gt; &quot;t.Iterable[V]&quot;: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_reverse(value: t.Union[str, t.Iterable[V]]) -&gt; t.Union[str, t.Iterable[V]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Reverse the object or return an iterator that iterates over it the other
<span class="w"> </span>    way round.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        return value[::-1]</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return reversed(value)  # type: ignore</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        try:</span>
<span class="gi">+            rv = list(value)</span>
<span class="gi">+            rv.reverse()</span>
<span class="gi">+            return rv</span>
<span class="gi">+        except TypeError as e:</span>
<span class="gi">+            raise FilterArgumentError(&quot;argument must be iterable&quot;) from e</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def do_attr(environment: &#39;Environment&#39;, obj: t.Any, name: str) -&gt;t.Union[</span>
<span class="gd">-    Undefined, t.Any]:</span>
<span class="gi">+def do_attr(</span>
<span class="gi">+    environment: &quot;Environment&quot;, obj: t.Any, name: str</span>
<span class="gi">+) -&gt; t.Union[Undefined, t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get an attribute of an object.  ``foo|attr(&quot;bar&quot;)`` works like
<span class="w"> </span>    ``foo.bar`` just that always an attribute is returned and items are not
<span class="w"> </span>    looked up.

<span class="w"> </span>    See :ref:`Notes on subscriptions &lt;notes-on-subscriptions&gt;` for more details.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        name = str(name)</span>
<span class="gi">+    except UnicodeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = getattr(obj, name)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if environment.sandboxed:</span>
<span class="gi">+                environment = t.cast(&quot;SandboxedEnvironment&quot;, environment)</span>
<span class="gi">+</span>
<span class="gi">+                if not environment.is_safe_attribute(obj, name, value):</span>
<span class="gi">+                    return environment.unsafe_undefined(obj, name)</span>
<span class="gi">+</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+    return environment.undefined(obj=obj, name=name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def sync_do_map(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: t.Iterable[t.Any],</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    *args: t.Any,</span>
<span class="gi">+    **kwargs: t.Any,</span>
<span class="gi">+) -&gt; t.Iterable[t.Any]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def sync_do_map(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: t.Iterable[t.Any],</span>
<span class="gi">+    *,</span>
<span class="gi">+    attribute: str = ...,</span>
<span class="gi">+    default: t.Optional[t.Any] = None,</span>
<span class="gi">+) -&gt; t.Iterable[t.Any]: ...</span>


<span class="w"> </span>@pass_context
<span class="gd">-def sync_do_map(context: &#39;Context&#39;, value: t.Iterable[t.Any], *args: t.Any,</span>
<span class="gd">-    **kwargs: t.Any) -&gt;t.Iterable[t.Any]:</span>
<span class="gi">+def sync_do_map(</span>
<span class="gi">+    context: &quot;Context&quot;, value: t.Iterable[t.Any], *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+) -&gt; t.Iterable[t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Applies a filter on a sequence of objects or looks up an attribute.
<span class="w"> </span>    This is useful when dealing with lists of objects but you are really
<span class="w"> </span>    only interested in a certain value of it.
<span class="gu">@@ -882,12 +1489,51 @@ def sync_do_map(context: &#39;Context&#39;, value: t.Iterable[t.Any], *args: t.Any,</span>

<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value:</span>
<span class="gi">+        func = prepare_map(context, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        for item in value:</span>
<span class="gi">+            yield func(item)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def do_map(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: t.Union[t.AsyncIterable[t.Any], t.Iterable[t.Any]],</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    *args: t.Any,</span>
<span class="gi">+    **kwargs: t.Any,</span>
<span class="gi">+) -&gt; t.Iterable[t.Any]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@typing.overload</span>
<span class="gi">+def do_map(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: t.Union[t.AsyncIterable[t.Any], t.Iterable[t.Any]],</span>
<span class="gi">+    *,</span>
<span class="gi">+    attribute: str = ...,</span>
<span class="gi">+    default: t.Optional[t.Any] = None,</span>
<span class="gi">+) -&gt; t.Iterable[t.Any]: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@async_variant(sync_do_map)  # type: ignore</span>
<span class="gi">+async def do_map(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: t.Union[t.AsyncIterable[t.Any], t.Iterable[t.Any]],</span>
<span class="gi">+    *args: t.Any,</span>
<span class="gi">+    **kwargs: t.Any,</span>
<span class="gi">+) -&gt; t.AsyncIterable[t.Any]:</span>
<span class="gi">+    if value:</span>
<span class="gi">+        func = prepare_map(context, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        async for item in auto_aiter(value):</span>
<span class="gi">+            yield await auto_await(func(item))</span>


<span class="w"> </span>@pass_context
<span class="gd">-def sync_do_select(context: &#39;Context&#39;, value: &#39;t.Iterable[V]&#39;, *args: t.Any,</span>
<span class="gd">-    **kwargs: t.Any) -&gt;&#39;t.Iterator[V]&#39;:</span>
<span class="gi">+def sync_do_select(</span>
<span class="gi">+    context: &quot;Context&quot;, value: &quot;t.Iterable[V]&quot;, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+) -&gt; &quot;t.Iterator[V]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Filters a sequence of objects by applying a test to each object,
<span class="w"> </span>    and only selecting the objects with the test succeeding.

<span class="gu">@@ -912,12 +1558,23 @@ def sync_do_select(context: &#39;Context&#39;, value: &#39;t.Iterable[V]&#39;, *args: t.Any,</span>

<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return select_or_reject(context, value, args, kwargs, lambda x: x, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@async_variant(sync_do_select)  # type: ignore</span>
<span class="gi">+async def do_select(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+    *args: t.Any,</span>
<span class="gi">+    **kwargs: t.Any,</span>
<span class="gi">+) -&gt; &quot;t.AsyncIterator[V]&quot;:</span>
<span class="gi">+    return async_select_or_reject(context, value, args, kwargs, lambda x: x, False)</span>


<span class="w"> </span>@pass_context
<span class="gd">-def sync_do_reject(context: &#39;Context&#39;, value: &#39;t.Iterable[V]&#39;, *args: t.Any,</span>
<span class="gd">-    **kwargs: t.Any) -&gt;&#39;t.Iterator[V]&#39;:</span>
<span class="gi">+def sync_do_reject(</span>
<span class="gi">+    context: &quot;Context&quot;, value: &quot;t.Iterable[V]&quot;, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+) -&gt; &quot;t.Iterator[V]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Filters a sequence of objects by applying a test to each object,
<span class="w"> </span>    and rejecting the objects with the test succeeding.

<span class="gu">@@ -937,12 +1594,23 @@ def sync_do_reject(context: &#39;Context&#39;, value: &#39;t.Iterable[V]&#39;, *args: t.Any,</span>

<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return select_or_reject(context, value, args, kwargs, lambda x: not x, False)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@async_variant(sync_do_reject)  # type: ignore</span>
<span class="gi">+async def do_reject(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+    *args: t.Any,</span>
<span class="gi">+    **kwargs: t.Any,</span>
<span class="gi">+) -&gt; &quot;t.AsyncIterator[V]&quot;:</span>
<span class="gi">+    return async_select_or_reject(context, value, args, kwargs, lambda x: not x, False)</span>


<span class="w"> </span>@pass_context
<span class="gd">-def sync_do_selectattr(context: &#39;Context&#39;, value: &#39;t.Iterable[V]&#39;, *args: t</span>
<span class="gd">-    .Any, **kwargs: t.Any) -&gt;&#39;t.Iterator[V]&#39;:</span>
<span class="gi">+def sync_do_selectattr(</span>
<span class="gi">+    context: &quot;Context&quot;, value: &quot;t.Iterable[V]&quot;, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+) -&gt; &quot;t.Iterator[V]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Filters a sequence of objects by applying a test to the specified
<span class="w"> </span>    attribute of each object, and only selecting the objects with the
<span class="w"> </span>    test succeeding.
<span class="gu">@@ -966,12 +1634,23 @@ def sync_do_selectattr(context: &#39;Context&#39;, value: &#39;t.Iterable[V]&#39;, *args: t</span>

<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return select_or_reject(context, value, args, kwargs, lambda x: x, True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@async_variant(sync_do_selectattr)  # type: ignore</span>
<span class="gi">+async def do_selectattr(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+    *args: t.Any,</span>
<span class="gi">+    **kwargs: t.Any,</span>
<span class="gi">+) -&gt; &quot;t.AsyncIterator[V]&quot;:</span>
<span class="gi">+    return async_select_or_reject(context, value, args, kwargs, lambda x: x, True)</span>


<span class="w"> </span>@pass_context
<span class="gd">-def sync_do_rejectattr(context: &#39;Context&#39;, value: &#39;t.Iterable[V]&#39;, *args: t</span>
<span class="gd">-    .Any, **kwargs: t.Any) -&gt;&#39;t.Iterator[V]&#39;:</span>
<span class="gi">+def sync_do_rejectattr(</span>
<span class="gi">+    context: &quot;Context&quot;, value: &quot;t.Iterable[V]&quot;, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+) -&gt; &quot;t.Iterator[V]&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Filters a sequence of objects by applying a test to the specified
<span class="w"> </span>    attribute of each object, and rejecting the objects with the test
<span class="w"> </span>    succeeding.
<span class="gu">@@ -993,12 +1672,23 @@ def sync_do_rejectattr(context: &#39;Context&#39;, value: &#39;t.Iterable[V]&#39;, *args: t</span>

<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return select_or_reject(context, value, args, kwargs, lambda x: not x, True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@async_variant(sync_do_rejectattr)  # type: ignore</span>
<span class="gi">+async def do_rejectattr(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+    *args: t.Any,</span>
<span class="gi">+    **kwargs: t.Any,</span>
<span class="gi">+) -&gt; &quot;t.AsyncIterator[V]&quot;:</span>
<span class="gi">+    return async_select_or_reject(context, value, args, kwargs, lambda x: not x, True)</span>


<span class="w"> </span>@pass_eval_context
<span class="gd">-def do_tojson(eval_ctx: &#39;EvalContext&#39;, value: t.Any, indent: t.Optional[int</span>
<span class="gd">-    ]=None) -&gt;Markup:</span>
<span class="gi">+def do_tojson(</span>
<span class="gi">+    eval_ctx: &quot;EvalContext&quot;, value: t.Any, indent: t.Optional[int] = None</span>
<span class="gi">+) -&gt; Markup:</span>
<span class="w"> </span>    &quot;&quot;&quot;Serialize an object to a string of JSON, and mark it safe to
<span class="w"> </span>    render in HTML. This filter is only for use in HTML documents.

<span class="gu">@@ -1013,23 +1703,164 @@ def do_tojson(eval_ctx: &#39;EvalContext&#39;, value: t.Any, indent: t.Optional[int</span>

<span class="w"> </span>    .. versionadded:: 2.9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-FILTERS = {&#39;abs&#39;: abs, &#39;attr&#39;: do_attr, &#39;batch&#39;: do_batch, &#39;capitalize&#39;:</span>
<span class="gd">-    do_capitalize, &#39;center&#39;: do_center, &#39;count&#39;: len, &#39;d&#39;: do_default,</span>
<span class="gd">-    &#39;default&#39;: do_default, &#39;dictsort&#39;: do_dictsort, &#39;e&#39;: escape, &#39;escape&#39;:</span>
<span class="gd">-    escape, &#39;filesizeformat&#39;: do_filesizeformat, &#39;first&#39;: do_first, &#39;float&#39;:</span>
<span class="gd">-    do_float, &#39;forceescape&#39;: do_forceescape, &#39;format&#39;: do_format, &#39;groupby&#39;:</span>
<span class="gd">-    do_groupby, &#39;indent&#39;: do_indent, &#39;int&#39;: do_int, &#39;join&#39;: do_join, &#39;last&#39;:</span>
<span class="gd">-    do_last, &#39;length&#39;: len, &#39;list&#39;: do_list, &#39;lower&#39;: do_lower, &#39;items&#39;:</span>
<span class="gd">-    do_items, &#39;map&#39;: do_map, &#39;min&#39;: do_min, &#39;max&#39;: do_max, &#39;pprint&#39;:</span>
<span class="gd">-    do_pprint, &#39;random&#39;: do_random, &#39;reject&#39;: do_reject, &#39;rejectattr&#39;:</span>
<span class="gd">-    do_rejectattr, &#39;replace&#39;: do_replace, &#39;reverse&#39;: do_reverse, &#39;round&#39;:</span>
<span class="gd">-    do_round, &#39;safe&#39;: do_mark_safe, &#39;select&#39;: do_select, &#39;selectattr&#39;:</span>
<span class="gd">-    do_selectattr, &#39;slice&#39;: do_slice, &#39;sort&#39;: do_sort, &#39;string&#39;: soft_str,</span>
<span class="gd">-    &#39;striptags&#39;: do_striptags, &#39;sum&#39;: do_sum, &#39;title&#39;: do_title, &#39;trim&#39;:</span>
<span class="gd">-    do_trim, &#39;truncate&#39;: do_truncate, &#39;unique&#39;: do_unique, &#39;upper&#39;:</span>
<span class="gd">-    do_upper, &#39;urlencode&#39;: do_urlencode, &#39;urlize&#39;: do_urlize, &#39;wordcount&#39;:</span>
<span class="gd">-    do_wordcount, &#39;wordwrap&#39;: do_wordwrap, &#39;xmlattr&#39;: do_xmlattr, &#39;tojson&#39;:</span>
<span class="gd">-    do_tojson}</span>
<span class="gi">+    policies = eval_ctx.environment.policies</span>
<span class="gi">+    dumps = policies[&quot;json.dumps_function&quot;]</span>
<span class="gi">+    kwargs = policies[&quot;json.dumps_kwargs&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    if indent is not None:</span>
<span class="gi">+        kwargs = kwargs.copy()</span>
<span class="gi">+        kwargs[&quot;indent&quot;] = indent</span>
<span class="gi">+</span>
<span class="gi">+    return htmlsafe_json_dumps(value, dumps=dumps, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def prepare_map(</span>
<span class="gi">+    context: &quot;Context&quot;, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]</span>
<span class="gi">+) -&gt; t.Callable[[t.Any], t.Any]:</span>
<span class="gi">+    if not args and &quot;attribute&quot; in kwargs:</span>
<span class="gi">+        attribute = kwargs.pop(&quot;attribute&quot;)</span>
<span class="gi">+        default = kwargs.pop(&quot;default&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        if kwargs:</span>
<span class="gi">+            raise FilterArgumentError(</span>
<span class="gi">+                f&quot;Unexpected keyword argument {next(iter(kwargs))!r}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        func = make_attrgetter(context.environment, attribute, default=default)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            name = args[0]</span>
<span class="gi">+            args = args[1:]</span>
<span class="gi">+        except LookupError:</span>
<span class="gi">+            raise FilterArgumentError(&quot;map requires a filter argument&quot;) from None</span>
<span class="gi">+</span>
<span class="gi">+        def func(item: t.Any) -&gt; t.Any:</span>
<span class="gi">+            return context.environment.call_filter(</span>
<span class="gi">+                name, item, args, kwargs, context=context</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    return func</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def prepare_select_or_reject(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    args: t.Tuple[t.Any, ...],</span>
<span class="gi">+    kwargs: t.Dict[str, t.Any],</span>
<span class="gi">+    modfunc: t.Callable[[t.Any], t.Any],</span>
<span class="gi">+    lookup_attr: bool,</span>
<span class="gi">+) -&gt; t.Callable[[t.Any], t.Any]:</span>
<span class="gi">+    if lookup_attr:</span>
<span class="gi">+        try:</span>
<span class="gi">+            attr = args[0]</span>
<span class="gi">+        except LookupError:</span>
<span class="gi">+            raise FilterArgumentError(&quot;Missing parameter for attribute name&quot;) from None</span>
<span class="gi">+</span>
<span class="gi">+        transfunc = make_attrgetter(context.environment, attr)</span>
<span class="gi">+        off = 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        off = 0</span>
<span class="gi">+</span>
<span class="gi">+        def transfunc(x: V) -&gt; V:</span>
<span class="gi">+            return x</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        name = args[off]</span>
<span class="gi">+        args = args[1 + off :]</span>
<span class="gi">+</span>
<span class="gi">+        def func(item: t.Any) -&gt; t.Any:</span>
<span class="gi">+            return context.environment.call_test(name, item, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    except LookupError:</span>
<span class="gi">+        func = bool  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return lambda item: modfunc(func(transfunc(item)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def select_or_reject(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: &quot;t.Iterable[V]&quot;,</span>
<span class="gi">+    args: t.Tuple[t.Any, ...],</span>
<span class="gi">+    kwargs: t.Dict[str, t.Any],</span>
<span class="gi">+    modfunc: t.Callable[[t.Any], t.Any],</span>
<span class="gi">+    lookup_attr: bool,</span>
<span class="gi">+) -&gt; &quot;t.Iterator[V]&quot;:</span>
<span class="gi">+    if value:</span>
<span class="gi">+        func = prepare_select_or_reject(context, args, kwargs, modfunc, lookup_attr)</span>
<span class="gi">+</span>
<span class="gi">+        for item in value:</span>
<span class="gi">+            if func(item):</span>
<span class="gi">+                yield item</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+async def async_select_or_reject(</span>
<span class="gi">+    context: &quot;Context&quot;,</span>
<span class="gi">+    value: &quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;,</span>
<span class="gi">+    args: t.Tuple[t.Any, ...],</span>
<span class="gi">+    kwargs: t.Dict[str, t.Any],</span>
<span class="gi">+    modfunc: t.Callable[[t.Any], t.Any],</span>
<span class="gi">+    lookup_attr: bool,</span>
<span class="gi">+) -&gt; &quot;t.AsyncIterator[V]&quot;:</span>
<span class="gi">+    if value:</span>
<span class="gi">+        func = prepare_select_or_reject(context, args, kwargs, modfunc, lookup_attr)</span>
<span class="gi">+</span>
<span class="gi">+        async for item in auto_aiter(value):</span>
<span class="gi">+            if func(item):</span>
<span class="gi">+                yield item</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+FILTERS = {</span>
<span class="gi">+    &quot;abs&quot;: abs,</span>
<span class="gi">+    &quot;attr&quot;: do_attr,</span>
<span class="gi">+    &quot;batch&quot;: do_batch,</span>
<span class="gi">+    &quot;capitalize&quot;: do_capitalize,</span>
<span class="gi">+    &quot;center&quot;: do_center,</span>
<span class="gi">+    &quot;count&quot;: len,</span>
<span class="gi">+    &quot;d&quot;: do_default,</span>
<span class="gi">+    &quot;default&quot;: do_default,</span>
<span class="gi">+    &quot;dictsort&quot;: do_dictsort,</span>
<span class="gi">+    &quot;e&quot;: escape,</span>
<span class="gi">+    &quot;escape&quot;: escape,</span>
<span class="gi">+    &quot;filesizeformat&quot;: do_filesizeformat,</span>
<span class="gi">+    &quot;first&quot;: do_first,</span>
<span class="gi">+    &quot;float&quot;: do_float,</span>
<span class="gi">+    &quot;forceescape&quot;: do_forceescape,</span>
<span class="gi">+    &quot;format&quot;: do_format,</span>
<span class="gi">+    &quot;groupby&quot;: do_groupby,</span>
<span class="gi">+    &quot;indent&quot;: do_indent,</span>
<span class="gi">+    &quot;int&quot;: do_int,</span>
<span class="gi">+    &quot;join&quot;: do_join,</span>
<span class="gi">+    &quot;last&quot;: do_last,</span>
<span class="gi">+    &quot;length&quot;: len,</span>
<span class="gi">+    &quot;list&quot;: do_list,</span>
<span class="gi">+    &quot;lower&quot;: do_lower,</span>
<span class="gi">+    &quot;items&quot;: do_items,</span>
<span class="gi">+    &quot;map&quot;: do_map,</span>
<span class="gi">+    &quot;min&quot;: do_min,</span>
<span class="gi">+    &quot;max&quot;: do_max,</span>
<span class="gi">+    &quot;pprint&quot;: do_pprint,</span>
<span class="gi">+    &quot;random&quot;: do_random,</span>
<span class="gi">+    &quot;reject&quot;: do_reject,</span>
<span class="gi">+    &quot;rejectattr&quot;: do_rejectattr,</span>
<span class="gi">+    &quot;replace&quot;: do_replace,</span>
<span class="gi">+    &quot;reverse&quot;: do_reverse,</span>
<span class="gi">+    &quot;round&quot;: do_round,</span>
<span class="gi">+    &quot;safe&quot;: do_mark_safe,</span>
<span class="gi">+    &quot;select&quot;: do_select,</span>
<span class="gi">+    &quot;selectattr&quot;: do_selectattr,</span>
<span class="gi">+    &quot;slice&quot;: do_slice,</span>
<span class="gi">+    &quot;sort&quot;: do_sort,</span>
<span class="gi">+    &quot;string&quot;: soft_str,</span>
<span class="gi">+    &quot;striptags&quot;: do_striptags,</span>
<span class="gi">+    &quot;sum&quot;: do_sum,</span>
<span class="gi">+    &quot;title&quot;: do_title,</span>
<span class="gi">+    &quot;trim&quot;: do_trim,</span>
<span class="gi">+    &quot;truncate&quot;: do_truncate,</span>
<span class="gi">+    &quot;unique&quot;: do_unique,</span>
<span class="gi">+    &quot;upper&quot;: do_upper,</span>
<span class="gi">+    &quot;urlencode&quot;: do_urlencode,</span>
<span class="gi">+    &quot;urlize&quot;: do_urlize,</span>
<span class="gi">+    &quot;wordcount&quot;: do_wordcount,</span>
<span class="gi">+    &quot;wordwrap&quot;: do_wordwrap,</span>
<span class="gi">+    &quot;xmlattr&quot;: do_xmlattr,</span>
<span class="gi">+    &quot;tojson&quot;: do_tojson,</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/src/jinja2/idtracking.py b/src/jinja2/idtracking.py</span>
<span class="gh">index a1d69ca..995ebaa 100644</span>
<span class="gd">--- a/src/jinja2/idtracking.py</span>
<span class="gi">+++ b/src/jinja2/idtracking.py</span>
<span class="gu">@@ -1,32 +1,184 @@</span>
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from . import nodes
<span class="w"> </span>from .visitor import NodeVisitor
<span class="gd">-VAR_LOAD_PARAMETER = &#39;param&#39;</span>
<span class="gd">-VAR_LOAD_RESOLVE = &#39;resolve&#39;</span>
<span class="gd">-VAR_LOAD_ALIAS = &#39;alias&#39;</span>
<span class="gd">-VAR_LOAD_UNDEFINED = &#39;undefined&#39;</span>

<span class="gi">+VAR_LOAD_PARAMETER = &quot;param&quot;</span>
<span class="gi">+VAR_LOAD_RESOLVE = &quot;resolve&quot;</span>
<span class="gi">+VAR_LOAD_ALIAS = &quot;alias&quot;</span>
<span class="gi">+VAR_LOAD_UNDEFINED = &quot;undefined&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_symbols(</span>
<span class="gi">+    nodes: t.Iterable[nodes.Node], parent_symbols: t.Optional[&quot;Symbols&quot;] = None</span>
<span class="gi">+) -&gt; &quot;Symbols&quot;:</span>
<span class="gi">+    sym = Symbols(parent=parent_symbols)</span>
<span class="gi">+    visitor = FrameSymbolVisitor(sym)</span>
<span class="gi">+    for node in nodes:</span>
<span class="gi">+        visitor.visit(node)</span>
<span class="gi">+    return sym</span>

<span class="gd">-class Symbols:</span>

<span class="gd">-    def __init__(self, parent: t.Optional[&#39;Symbols&#39;]=None, level: t.</span>
<span class="gd">-        Optional[int]=None) -&gt;None:</span>
<span class="gi">+def symbols_for_node(</span>
<span class="gi">+    node: nodes.Node, parent_symbols: t.Optional[&quot;Symbols&quot;] = None</span>
<span class="gi">+) -&gt; &quot;Symbols&quot;:</span>
<span class="gi">+    sym = Symbols(parent=parent_symbols)</span>
<span class="gi">+    sym.analyze_node(node)</span>
<span class="gi">+    return sym</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class Symbols:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, parent: t.Optional[&quot;Symbols&quot;] = None, level: t.Optional[int] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if level is None:
<span class="w"> </span>            if parent is None:
<span class="w"> </span>                level = 0
<span class="w"> </span>            else:
<span class="w"> </span>                level = parent.level + 1
<span class="gi">+</span>
<span class="w"> </span>        self.level: int = level
<span class="w"> </span>        self.parent = parent
<span class="w"> </span>        self.refs: t.Dict[str, str] = {}
<span class="w"> </span>        self.loads: t.Dict[str, t.Any] = {}
<span class="w"> </span>        self.stores: t.Set[str] = set()

<span class="gi">+    def analyze_node(self, node: nodes.Node, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        visitor = RootVisitor(self)</span>
<span class="gi">+        visitor.visit(node, **kwargs)</span>

<span class="gd">-class RootVisitor(NodeVisitor):</span>
<span class="gi">+    def _define_ref(</span>
<span class="gi">+        self, name: str, load: t.Optional[t.Tuple[str, t.Optional[str]]] = None</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        ident = f&quot;l_{self.level}_{name}&quot;</span>
<span class="gi">+        self.refs[name] = ident</span>
<span class="gi">+        if load is not None:</span>
<span class="gi">+            self.loads[ident] = load</span>
<span class="gi">+        return ident</span>
<span class="gi">+</span>
<span class="gi">+    def find_load(self, target: str) -&gt; t.Optional[t.Any]:</span>
<span class="gi">+        if target in self.loads:</span>
<span class="gi">+            return self.loads[target]</span>
<span class="gi">+</span>
<span class="gi">+        if self.parent is not None:</span>
<span class="gi">+            return self.parent.find_load(target)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def find_ref(self, name: str) -&gt; t.Optional[str]:</span>
<span class="gi">+        if name in self.refs:</span>
<span class="gi">+            return self.refs[name]</span>
<span class="gi">+</span>
<span class="gi">+        if self.parent is not None:</span>
<span class="gi">+            return self.parent.find_ref(name)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def ref(self, name: str) -&gt; str:</span>
<span class="gi">+        rv = self.find_ref(name)</span>
<span class="gi">+        if rv is None:</span>
<span class="gi">+            raise AssertionError(</span>
<span class="gi">+                &quot;Tried to resolve a name to a reference that was&quot;</span>
<span class="gi">+                f&quot; unknown to the frame ({name!r})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def copy(self) -&gt; &quot;Symbols&quot;:</span>
<span class="gi">+        rv = object.__new__(self.__class__)</span>
<span class="gi">+        rv.__dict__.update(self.__dict__)</span>
<span class="gi">+        rv.refs = self.refs.copy()</span>
<span class="gi">+        rv.loads = self.loads.copy()</span>
<span class="gi">+        rv.stores = self.stores.copy()</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def store(self, name: str) -&gt; None:</span>
<span class="gi">+        self.stores.add(name)</span>
<span class="gi">+</span>
<span class="gi">+        # If we have not see the name referenced yet, we need to figure</span>
<span class="gi">+        # out what to set it to.</span>
<span class="gi">+        if name not in self.refs:</span>
<span class="gi">+            # If there is a parent scope we check if the name has a</span>
<span class="gi">+            # reference there.  If it does it means we might have to alias</span>
<span class="gi">+            # to a variable there.</span>
<span class="gi">+            if self.parent is not None:</span>
<span class="gi">+                outer_ref = self.parent.find_ref(name)</span>
<span class="gi">+                if outer_ref is not None:</span>
<span class="gi">+                    self._define_ref(name, load=(VAR_LOAD_ALIAS, outer_ref))</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            # Otherwise we can just set it to undefined.</span>
<span class="gi">+            self._define_ref(name, load=(VAR_LOAD_UNDEFINED, None))</span>
<span class="gi">+</span>
<span class="gi">+    def declare_parameter(self, name: str) -&gt; str:</span>
<span class="gi">+        self.stores.add(name)</span>
<span class="gi">+        return self._define_ref(name, load=(VAR_LOAD_PARAMETER, None))</span>
<span class="gi">+</span>
<span class="gi">+    def load(self, name: str) -&gt; None:</span>
<span class="gi">+        if self.find_ref(name) is None:</span>
<span class="gi">+            self._define_ref(name, load=(VAR_LOAD_RESOLVE, name))</span>
<span class="gi">+</span>
<span class="gi">+    def branch_update(self, branch_symbols: t.Sequence[&quot;Symbols&quot;]) -&gt; None:</span>
<span class="gi">+        stores: t.Dict[str, int] = {}</span>
<span class="gi">+        for branch in branch_symbols:</span>
<span class="gi">+            for target in branch.stores:</span>
<span class="gi">+                if target in self.stores:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                stores[target] = stores.get(target, 0) + 1</span>
<span class="gi">+</span>
<span class="gi">+        for sym in branch_symbols:</span>
<span class="gi">+            self.refs.update(sym.refs)</span>
<span class="gi">+            self.loads.update(sym.loads)</span>
<span class="gi">+            self.stores.update(sym.stores)</span>
<span class="gi">+</span>
<span class="gi">+        for name, branch_count in stores.items():</span>
<span class="gi">+            if branch_count == len(branch_symbols):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            target = self.find_ref(name)  # type: ignore</span>
<span class="gi">+            assert target is not None, &quot;should not happen&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if self.parent is not None:</span>
<span class="gi">+                outer_target = self.parent.find_ref(name)</span>
<span class="gi">+                if outer_target is not None:</span>
<span class="gi">+                    self.loads[target] = (VAR_LOAD_ALIAS, outer_target)</span>
<span class="gi">+                    continue</span>
<span class="gi">+            self.loads[target] = (VAR_LOAD_RESOLVE, name)</span>
<span class="gi">+</span>
<span class="gi">+    def dump_stores(self) -&gt; t.Dict[str, str]:</span>
<span class="gi">+        rv: t.Dict[str, str] = {}</span>
<span class="gi">+        node: t.Optional[&quot;Symbols&quot;] = self</span>
<span class="gi">+</span>
<span class="gi">+        while node is not None:</span>
<span class="gi">+            for name in sorted(node.stores):</span>
<span class="gi">+                if name not in rv:</span>
<span class="gi">+                    rv[name] = self.find_ref(name)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+            node = node.parent</span>

<span class="gd">-    def __init__(self, symbols: &#39;Symbols&#39;) -&gt;None:</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def dump_param_targets(self) -&gt; t.Set[str]:</span>
<span class="gi">+        rv = set()</span>
<span class="gi">+        node: t.Optional[&quot;Symbols&quot;] = self</span>
<span class="gi">+</span>
<span class="gi">+        while node is not None:</span>
<span class="gi">+            for target, (instr, _) in self.loads.items():</span>
<span class="gi">+                if instr == VAR_LOAD_PARAMETER:</span>
<span class="gi">+                    rv.add(target)</span>
<span class="gi">+</span>
<span class="gi">+            node = node.parent</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class RootVisitor(NodeVisitor):</span>
<span class="gi">+    def __init__(self, symbols: &quot;Symbols&quot;) -&gt; None:</span>
<span class="w"> </span>        self.sym_visitor = FrameSymbolVisitor(symbols)
<span class="gi">+</span>
<span class="gi">+    def _simple_visit(self, node: nodes.Node, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        for child in node.iter_child_nodes():</span>
<span class="gi">+            self.sym_visitor.visit(child)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_Template = _simple_visit
<span class="w"> </span>    visit_Block = _simple_visit
<span class="w"> </span>    visit_Macro = _simple_visit
<span class="gu">@@ -35,42 +187,132 @@ class RootVisitor(NodeVisitor):</span>
<span class="w"> </span>    visit_If = _simple_visit
<span class="w"> </span>    visit_ScopedEvalContextModifier = _simple_visit

<span class="gi">+    def visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            self.sym_visitor.visit(child)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_CallBlock(self, node: nodes.CallBlock, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        for child in node.iter_child_nodes(exclude=(&quot;call&quot;,)):</span>
<span class="gi">+            self.sym_visitor.visit(child)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            self.sym_visitor.visit(child)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_For(</span>
<span class="gi">+        self, node: nodes.For, for_branch: str = &quot;body&quot;, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if for_branch == &quot;body&quot;:</span>
<span class="gi">+            self.sym_visitor.visit(node.target, store_as_param=True)</span>
<span class="gi">+            branch = node.body</span>
<span class="gi">+        elif for_branch == &quot;else&quot;:</span>
<span class="gi">+            branch = node.else_</span>
<span class="gi">+        elif for_branch == &quot;test&quot;:</span>
<span class="gi">+            self.sym_visitor.visit(node.target, store_as_param=True)</span>
<span class="gi">+            if node.test is not None:</span>
<span class="gi">+                self.sym_visitor.visit(node.test)</span>
<span class="gi">+            return</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuntimeError(&quot;Unknown for branch&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if branch:</span>
<span class="gi">+            for item in branch:</span>
<span class="gi">+                self.sym_visitor.visit(item)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_With(self, node: nodes.With, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        for target in node.targets:</span>
<span class="gi">+            self.sym_visitor.visit(target)</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            self.sym_visitor.visit(child)</span>
<span class="gi">+</span>
<span class="gi">+    def generic_visit(self, node: nodes.Node, *args: t.Any, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(f&quot;Cannot find symbols for {type(node).__name__!r}&quot;)</span>
<span class="gi">+</span>

<span class="w"> </span>class FrameSymbolVisitor(NodeVisitor):
<span class="w"> </span>    &quot;&quot;&quot;A visitor for `Frame.inspect`.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, symbols: &#39;Symbols&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, symbols: &quot;Symbols&quot;) -&gt; None:</span>
<span class="w"> </span>        self.symbols = symbols

<span class="gd">-    def visit_Name(self, node: nodes.Name, store_as_param: bool=False, **</span>
<span class="gd">-        kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def visit_Name(</span>
<span class="gi">+        self, node: nodes.Name, store_as_param: bool = False, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;All assignments to names go through this function.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if store_as_param or node.ctx == &quot;param&quot;:</span>
<span class="gi">+            self.symbols.declare_parameter(node.name)</span>
<span class="gi">+        elif node.ctx == &quot;store&quot;:</span>
<span class="gi">+            self.symbols.store(node.name)</span>
<span class="gi">+        elif node.ctx == &quot;load&quot;:</span>
<span class="gi">+            self.symbols.load(node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_NSRef(self, node: nodes.NSRef, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        self.symbols.load(node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_If(self, node: nodes.If, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        self.visit(node.test, **kwargs)</span>
<span class="gi">+        original_symbols = self.symbols</span>
<span class="gi">+</span>
<span class="gi">+        def inner_visit(nodes: t.Iterable[nodes.Node]) -&gt; &quot;Symbols&quot;:</span>
<span class="gi">+            self.symbols = rv = original_symbols.copy()</span>
<span class="gi">+</span>
<span class="gi">+            for subnode in nodes:</span>
<span class="gi">+                self.visit(subnode, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            self.symbols = original_symbols</span>
<span class="gi">+            return rv</span>
<span class="gi">+</span>
<span class="gi">+        body_symbols = inner_visit(node.body)</span>
<span class="gi">+        elif_symbols = inner_visit(node.elif_)</span>
<span class="gi">+        else_symbols = inner_visit(node.else_ or ())</span>
<span class="gi">+        self.symbols.branch_update([body_symbols, elif_symbols, else_symbols])</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Macro(self, node: nodes.Macro, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        self.symbols.store(node.name)</span>

<span class="gd">-    def visit_Assign(self, node: nodes.Assign, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def visit_Import(self, node: nodes.Import, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        self.generic_visit(node, **kwargs)</span>
<span class="gi">+        self.symbols.store(node.target)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_FromImport(self, node: nodes.FromImport, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        self.generic_visit(node, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            if isinstance(name, tuple):</span>
<span class="gi">+                self.symbols.store(name[1])</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.symbols.store(name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Assign(self, node: nodes.Assign, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit assignments in the correct order.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit(node.node, **kwargs)</span>
<span class="gi">+        self.visit(node.target, **kwargs)</span>

<span class="gd">-    def visit_For(self, node: nodes.For, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def visit_For(self, node: nodes.For, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visiting stops at for blocks.  However the block sequence
<span class="w"> </span>        is visited as part of the outer scope.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit(node.iter, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_CallBlock(self, node: nodes.CallBlock, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        self.visit(node.call, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_FilterBlock(self, node: nodes.FilterBlock, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        self.visit(node.filter, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_With(self, node: nodes.With, **kwargs: t.Any) -&gt; None:</span>
<span class="gi">+        for target in node.values:</span>
<span class="gi">+            self.visit(target)</span>

<span class="gd">-    def visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at block assigns.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit(node.target, **kwargs)</span>

<span class="gd">-    def visit_Scope(self, node: nodes.Scope, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def visit_Scope(self, node: nodes.Scope, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at scopes.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def visit_Block(self, node: nodes.Block, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def visit_Block(self, node: nodes.Block, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stop visiting at blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do not visit into overlay scopes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gh">diff --git a/src/jinja2/lexer.py b/src/jinja2/lexer.py</span>
<span class="gh">index 2281b7e..62b0471 100644</span>
<span class="gd">--- a/src/jinja2/lexer.py</span>
<span class="gi">+++ b/src/jinja2/lexer.py</span>
<span class="gu">@@ -3,138 +3,252 @@ is used to do some preprocessing. It filters out invalid operators like</span>
<span class="w"> </span>the bitshift operators we don&#39;t allow in templates. It separates
<span class="w"> </span>template code and python code in expressions.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import typing as t
<span class="w"> </span>from ast import literal_eval
<span class="w"> </span>from collections import deque
<span class="w"> </span>from sys import intern
<span class="gi">+</span>
<span class="w"> </span>from ._identifier import pattern as name_re
<span class="w"> </span>from .exceptions import TemplateSyntaxError
<span class="w"> </span>from .utils import LRUCache
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gi">+</span>
<span class="w"> </span>    from .environment import Environment
<span class="gd">-_lexer_cache: t.MutableMapping[t.Tuple, &#39;Lexer&#39;] = LRUCache(50)</span>
<span class="gd">-whitespace_re = re.compile(&#39;\\s+&#39;)</span>
<span class="gd">-newline_re = re.compile(&#39;(\\r\\n|\\r|\\n)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# cache for the lexers. Exists in order to be able to have multiple</span>
<span class="gi">+# environments with the same lexer</span>
<span class="gi">+_lexer_cache: t.MutableMapping[t.Tuple, &quot;Lexer&quot;] = LRUCache(50)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+# static regular expressions</span>
<span class="gi">+whitespace_re = re.compile(r&quot;\s+&quot;)</span>
<span class="gi">+newline_re = re.compile(r&quot;(\r\n|\r|\n)&quot;)</span>
<span class="w"> </span>string_re = re.compile(
<span class="gd">-    &#39;(\&#39;([^\&#39;\\\\]*(?:\\\\.[^\&#39;\\\\]*)*)\&#39;|&quot;([^&quot;\\\\]*(?:\\\\.[^&quot;\\\\]*)*)&quot;)&#39;,</span>
<span class="gd">-    re.S)</span>
<span class="gi">+    r&quot;(&#39;([^&#39;\\]*(?:\\.[^&#39;\\]*)*)&#39;&quot; r&#39;|&quot;([^&quot;\\]*(?:\\.[^&quot;\\]*)*)&quot;)&#39;, re.S</span>
<span class="gi">+)</span>
<span class="w"> </span>integer_re = re.compile(
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    r&quot;&quot;&quot;</span>
<span class="w"> </span>    (
<span class="w"> </span>        0b(_?[0-1])+ # binary
<span class="w"> </span>    |
<span class="w"> </span>        0o(_?[0-7])+ # octal
<span class="w"> </span>    |
<span class="gd">-        0x(_?[\\da-f])+ # hex</span>
<span class="gi">+        0x(_?[\da-f])+ # hex</span>
<span class="w"> </span>    |
<span class="gd">-        [1-9](_?\\d)* # decimal</span>
<span class="gi">+        [1-9](_?\d)* # decimal</span>
<span class="w"> </span>    |
<span class="w"> </span>        0(_?0)* # decimal zero
<span class="w"> </span>    )
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , re.IGNORECASE | re.VERBOSE)</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    re.IGNORECASE | re.VERBOSE,</span>
<span class="gi">+)</span>
<span class="w"> </span>float_re = re.compile(
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    (?&lt;!\\.)  # doesn&#39;t start with a .</span>
<span class="gd">-    (\\d+_)*\\d+  # digits, possibly _ separated</span>
<span class="gi">+    r&quot;&quot;&quot;</span>
<span class="gi">+    (?&lt;!\.)  # doesn&#39;t start with a .</span>
<span class="gi">+    (\d+_)*\d+  # digits, possibly _ separated</span>
<span class="w"> </span>    (
<span class="gd">-        (\\.(\\d+_)*\\d+)?  # optional fractional part</span>
<span class="gd">-        e[+\\-]?(\\d+_)*\\d+  # exponent part</span>
<span class="gi">+        (\.(\d+_)*\d+)?  # optional fractional part</span>
<span class="gi">+        e[+\-]?(\d+_)*\d+  # exponent part</span>
<span class="w"> </span>    |
<span class="gd">-        \\.(\\d+_)*\\d+  # required fractional part</span>
<span class="gi">+        \.(\d+_)*\d+  # required fractional part</span>
<span class="w"> </span>    )
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , re.IGNORECASE | re.VERBOSE)</span>
<span class="gd">-TOKEN_ADD = intern(&#39;add&#39;)</span>
<span class="gd">-TOKEN_ASSIGN = intern(&#39;assign&#39;)</span>
<span class="gd">-TOKEN_COLON = intern(&#39;colon&#39;)</span>
<span class="gd">-TOKEN_COMMA = intern(&#39;comma&#39;)</span>
<span class="gd">-TOKEN_DIV = intern(&#39;div&#39;)</span>
<span class="gd">-TOKEN_DOT = intern(&#39;dot&#39;)</span>
<span class="gd">-TOKEN_EQ = intern(&#39;eq&#39;)</span>
<span class="gd">-TOKEN_FLOORDIV = intern(&#39;floordiv&#39;)</span>
<span class="gd">-TOKEN_GT = intern(&#39;gt&#39;)</span>
<span class="gd">-TOKEN_GTEQ = intern(&#39;gteq&#39;)</span>
<span class="gd">-TOKEN_LBRACE = intern(&#39;lbrace&#39;)</span>
<span class="gd">-TOKEN_LBRACKET = intern(&#39;lbracket&#39;)</span>
<span class="gd">-TOKEN_LPAREN = intern(&#39;lparen&#39;)</span>
<span class="gd">-TOKEN_LT = intern(&#39;lt&#39;)</span>
<span class="gd">-TOKEN_LTEQ = intern(&#39;lteq&#39;)</span>
<span class="gd">-TOKEN_MOD = intern(&#39;mod&#39;)</span>
<span class="gd">-TOKEN_MUL = intern(&#39;mul&#39;)</span>
<span class="gd">-TOKEN_NE = intern(&#39;ne&#39;)</span>
<span class="gd">-TOKEN_PIPE = intern(&#39;pipe&#39;)</span>
<span class="gd">-TOKEN_POW = intern(&#39;pow&#39;)</span>
<span class="gd">-TOKEN_RBRACE = intern(&#39;rbrace&#39;)</span>
<span class="gd">-TOKEN_RBRACKET = intern(&#39;rbracket&#39;)</span>
<span class="gd">-TOKEN_RPAREN = intern(&#39;rparen&#39;)</span>
<span class="gd">-TOKEN_SEMICOLON = intern(&#39;semicolon&#39;)</span>
<span class="gd">-TOKEN_SUB = intern(&#39;sub&#39;)</span>
<span class="gd">-TOKEN_TILDE = intern(&#39;tilde&#39;)</span>
<span class="gd">-TOKEN_WHITESPACE = intern(&#39;whitespace&#39;)</span>
<span class="gd">-TOKEN_FLOAT = intern(&#39;float&#39;)</span>
<span class="gd">-TOKEN_INTEGER = intern(&#39;integer&#39;)</span>
<span class="gd">-TOKEN_NAME = intern(&#39;name&#39;)</span>
<span class="gd">-TOKEN_STRING = intern(&#39;string&#39;)</span>
<span class="gd">-TOKEN_OPERATOR = intern(&#39;operator&#39;)</span>
<span class="gd">-TOKEN_BLOCK_BEGIN = intern(&#39;block_begin&#39;)</span>
<span class="gd">-TOKEN_BLOCK_END = intern(&#39;block_end&#39;)</span>
<span class="gd">-TOKEN_VARIABLE_BEGIN = intern(&#39;variable_begin&#39;)</span>
<span class="gd">-TOKEN_VARIABLE_END = intern(&#39;variable_end&#39;)</span>
<span class="gd">-TOKEN_RAW_BEGIN = intern(&#39;raw_begin&#39;)</span>
<span class="gd">-TOKEN_RAW_END = intern(&#39;raw_end&#39;)</span>
<span class="gd">-TOKEN_COMMENT_BEGIN = intern(&#39;comment_begin&#39;)</span>
<span class="gd">-TOKEN_COMMENT_END = intern(&#39;comment_end&#39;)</span>
<span class="gd">-TOKEN_COMMENT = intern(&#39;comment&#39;)</span>
<span class="gd">-TOKEN_LINESTATEMENT_BEGIN = intern(&#39;linestatement_begin&#39;)</span>
<span class="gd">-TOKEN_LINESTATEMENT_END = intern(&#39;linestatement_end&#39;)</span>
<span class="gd">-TOKEN_LINECOMMENT_BEGIN = intern(&#39;linecomment_begin&#39;)</span>
<span class="gd">-TOKEN_LINECOMMENT_END = intern(&#39;linecomment_end&#39;)</span>
<span class="gd">-TOKEN_LINECOMMENT = intern(&#39;linecomment&#39;)</span>
<span class="gd">-TOKEN_DATA = intern(&#39;data&#39;)</span>
<span class="gd">-TOKEN_INITIAL = intern(&#39;initial&#39;)</span>
<span class="gd">-TOKEN_EOF = intern(&#39;eof&#39;)</span>
<span class="gd">-operators = {&#39;+&#39;: TOKEN_ADD, &#39;-&#39;: TOKEN_SUB, &#39;/&#39;: TOKEN_DIV, &#39;//&#39;:</span>
<span class="gd">-    TOKEN_FLOORDIV, &#39;*&#39;: TOKEN_MUL, &#39;%&#39;: TOKEN_MOD, &#39;**&#39;: TOKEN_POW, &#39;~&#39;:</span>
<span class="gd">-    TOKEN_TILDE, &#39;[&#39;: TOKEN_LBRACKET, &#39;]&#39;: TOKEN_RBRACKET, &#39;(&#39;:</span>
<span class="gd">-    TOKEN_LPAREN, &#39;)&#39;: TOKEN_RPAREN, &#39;{&#39;: TOKEN_LBRACE, &#39;}&#39;: TOKEN_RBRACE,</span>
<span class="gd">-    &#39;==&#39;: TOKEN_EQ, &#39;!=&#39;: TOKEN_NE, &#39;&gt;&#39;: TOKEN_GT, &#39;&gt;=&#39;: TOKEN_GTEQ, &#39;&lt;&#39;:</span>
<span class="gd">-    TOKEN_LT, &#39;&lt;=&#39;: TOKEN_LTEQ, &#39;=&#39;: TOKEN_ASSIGN, &#39;.&#39;: TOKEN_DOT, &#39;:&#39;:</span>
<span class="gd">-    TOKEN_COLON, &#39;|&#39;: TOKEN_PIPE, &#39;,&#39;: TOKEN_COMMA, &#39;;&#39;: TOKEN_SEMICOLON}</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    re.IGNORECASE | re.VERBOSE,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# internal the tokens and keep references to them</span>
<span class="gi">+TOKEN_ADD = intern(&quot;add&quot;)</span>
<span class="gi">+TOKEN_ASSIGN = intern(&quot;assign&quot;)</span>
<span class="gi">+TOKEN_COLON = intern(&quot;colon&quot;)</span>
<span class="gi">+TOKEN_COMMA = intern(&quot;comma&quot;)</span>
<span class="gi">+TOKEN_DIV = intern(&quot;div&quot;)</span>
<span class="gi">+TOKEN_DOT = intern(&quot;dot&quot;)</span>
<span class="gi">+TOKEN_EQ = intern(&quot;eq&quot;)</span>
<span class="gi">+TOKEN_FLOORDIV = intern(&quot;floordiv&quot;)</span>
<span class="gi">+TOKEN_GT = intern(&quot;gt&quot;)</span>
<span class="gi">+TOKEN_GTEQ = intern(&quot;gteq&quot;)</span>
<span class="gi">+TOKEN_LBRACE = intern(&quot;lbrace&quot;)</span>
<span class="gi">+TOKEN_LBRACKET = intern(&quot;lbracket&quot;)</span>
<span class="gi">+TOKEN_LPAREN = intern(&quot;lparen&quot;)</span>
<span class="gi">+TOKEN_LT = intern(&quot;lt&quot;)</span>
<span class="gi">+TOKEN_LTEQ = intern(&quot;lteq&quot;)</span>
<span class="gi">+TOKEN_MOD = intern(&quot;mod&quot;)</span>
<span class="gi">+TOKEN_MUL = intern(&quot;mul&quot;)</span>
<span class="gi">+TOKEN_NE = intern(&quot;ne&quot;)</span>
<span class="gi">+TOKEN_PIPE = intern(&quot;pipe&quot;)</span>
<span class="gi">+TOKEN_POW = intern(&quot;pow&quot;)</span>
<span class="gi">+TOKEN_RBRACE = intern(&quot;rbrace&quot;)</span>
<span class="gi">+TOKEN_RBRACKET = intern(&quot;rbracket&quot;)</span>
<span class="gi">+TOKEN_RPAREN = intern(&quot;rparen&quot;)</span>
<span class="gi">+TOKEN_SEMICOLON = intern(&quot;semicolon&quot;)</span>
<span class="gi">+TOKEN_SUB = intern(&quot;sub&quot;)</span>
<span class="gi">+TOKEN_TILDE = intern(&quot;tilde&quot;)</span>
<span class="gi">+TOKEN_WHITESPACE = intern(&quot;whitespace&quot;)</span>
<span class="gi">+TOKEN_FLOAT = intern(&quot;float&quot;)</span>
<span class="gi">+TOKEN_INTEGER = intern(&quot;integer&quot;)</span>
<span class="gi">+TOKEN_NAME = intern(&quot;name&quot;)</span>
<span class="gi">+TOKEN_STRING = intern(&quot;string&quot;)</span>
<span class="gi">+TOKEN_OPERATOR = intern(&quot;operator&quot;)</span>
<span class="gi">+TOKEN_BLOCK_BEGIN = intern(&quot;block_begin&quot;)</span>
<span class="gi">+TOKEN_BLOCK_END = intern(&quot;block_end&quot;)</span>
<span class="gi">+TOKEN_VARIABLE_BEGIN = intern(&quot;variable_begin&quot;)</span>
<span class="gi">+TOKEN_VARIABLE_END = intern(&quot;variable_end&quot;)</span>
<span class="gi">+TOKEN_RAW_BEGIN = intern(&quot;raw_begin&quot;)</span>
<span class="gi">+TOKEN_RAW_END = intern(&quot;raw_end&quot;)</span>
<span class="gi">+TOKEN_COMMENT_BEGIN = intern(&quot;comment_begin&quot;)</span>
<span class="gi">+TOKEN_COMMENT_END = intern(&quot;comment_end&quot;)</span>
<span class="gi">+TOKEN_COMMENT = intern(&quot;comment&quot;)</span>
<span class="gi">+TOKEN_LINESTATEMENT_BEGIN = intern(&quot;linestatement_begin&quot;)</span>
<span class="gi">+TOKEN_LINESTATEMENT_END = intern(&quot;linestatement_end&quot;)</span>
<span class="gi">+TOKEN_LINECOMMENT_BEGIN = intern(&quot;linecomment_begin&quot;)</span>
<span class="gi">+TOKEN_LINECOMMENT_END = intern(&quot;linecomment_end&quot;)</span>
<span class="gi">+TOKEN_LINECOMMENT = intern(&quot;linecomment&quot;)</span>
<span class="gi">+TOKEN_DATA = intern(&quot;data&quot;)</span>
<span class="gi">+TOKEN_INITIAL = intern(&quot;initial&quot;)</span>
<span class="gi">+TOKEN_EOF = intern(&quot;eof&quot;)</span>
<span class="gi">+</span>
<span class="gi">+# bind operators to token types</span>
<span class="gi">+operators = {</span>
<span class="gi">+    &quot;+&quot;: TOKEN_ADD,</span>
<span class="gi">+    &quot;-&quot;: TOKEN_SUB,</span>
<span class="gi">+    &quot;/&quot;: TOKEN_DIV,</span>
<span class="gi">+    &quot;//&quot;: TOKEN_FLOORDIV,</span>
<span class="gi">+    &quot;*&quot;: TOKEN_MUL,</span>
<span class="gi">+    &quot;%&quot;: TOKEN_MOD,</span>
<span class="gi">+    &quot;**&quot;: TOKEN_POW,</span>
<span class="gi">+    &quot;~&quot;: TOKEN_TILDE,</span>
<span class="gi">+    &quot;[&quot;: TOKEN_LBRACKET,</span>
<span class="gi">+    &quot;]&quot;: TOKEN_RBRACKET,</span>
<span class="gi">+    &quot;(&quot;: TOKEN_LPAREN,</span>
<span class="gi">+    &quot;)&quot;: TOKEN_RPAREN,</span>
<span class="gi">+    &quot;{&quot;: TOKEN_LBRACE,</span>
<span class="gi">+    &quot;}&quot;: TOKEN_RBRACE,</span>
<span class="gi">+    &quot;==&quot;: TOKEN_EQ,</span>
<span class="gi">+    &quot;!=&quot;: TOKEN_NE,</span>
<span class="gi">+    &quot;&gt;&quot;: TOKEN_GT,</span>
<span class="gi">+    &quot;&gt;=&quot;: TOKEN_GTEQ,</span>
<span class="gi">+    &quot;&lt;&quot;: TOKEN_LT,</span>
<span class="gi">+    &quot;&lt;=&quot;: TOKEN_LTEQ,</span>
<span class="gi">+    &quot;=&quot;: TOKEN_ASSIGN,</span>
<span class="gi">+    &quot;.&quot;: TOKEN_DOT,</span>
<span class="gi">+    &quot;:&quot;: TOKEN_COLON,</span>
<span class="gi">+    &quot;|&quot;: TOKEN_PIPE,</span>
<span class="gi">+    &quot;,&quot;: TOKEN_COMMA,</span>
<span class="gi">+    &quot;;&quot;: TOKEN_SEMICOLON,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>reverse_operators = {v: k for k, v in operators.items()}
<span class="gd">-assert len(operators) == len(reverse_operators), &#39;operators dropped&#39;</span>
<span class="gi">+assert len(operators) == len(reverse_operators), &quot;operators dropped&quot;</span>
<span class="w"> </span>operator_re = re.compile(
<span class="w"> </span>    f&quot;({&#39;|&#39;.join(re.escape(x) for x in sorted(operators, key=lambda x: -len(x)))})&quot;
<span class="gd">-    )</span>
<span class="gd">-ignored_tokens = frozenset([TOKEN_COMMENT_BEGIN, TOKEN_COMMENT,</span>
<span class="gd">-    TOKEN_COMMENT_END, TOKEN_WHITESPACE, TOKEN_LINECOMMENT_BEGIN,</span>
<span class="gd">-    TOKEN_LINECOMMENT_END, TOKEN_LINECOMMENT])</span>
<span class="gd">-ignore_if_empty = frozenset([TOKEN_WHITESPACE, TOKEN_DATA, TOKEN_COMMENT,</span>
<span class="gd">-    TOKEN_LINECOMMENT])</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def describe_token(token: &#39;Token&#39;) -&gt;str:</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+ignored_tokens = frozenset(</span>
<span class="gi">+    [</span>
<span class="gi">+        TOKEN_COMMENT_BEGIN,</span>
<span class="gi">+        TOKEN_COMMENT,</span>
<span class="gi">+        TOKEN_COMMENT_END,</span>
<span class="gi">+        TOKEN_WHITESPACE,</span>
<span class="gi">+        TOKEN_LINECOMMENT_BEGIN,</span>
<span class="gi">+        TOKEN_LINECOMMENT_END,</span>
<span class="gi">+        TOKEN_LINECOMMENT,</span>
<span class="gi">+    ]</span>
<span class="gi">+)</span>
<span class="gi">+ignore_if_empty = frozenset(</span>
<span class="gi">+    [TOKEN_WHITESPACE, TOKEN_DATA, TOKEN_COMMENT, TOKEN_LINECOMMENT]</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _describe_token_type(token_type: str) -&gt; str:</span>
<span class="gi">+    if token_type in reverse_operators:</span>
<span class="gi">+        return reverse_operators[token_type]</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        TOKEN_COMMENT_BEGIN: &quot;begin of comment&quot;,</span>
<span class="gi">+        TOKEN_COMMENT_END: &quot;end of comment&quot;,</span>
<span class="gi">+        TOKEN_COMMENT: &quot;comment&quot;,</span>
<span class="gi">+        TOKEN_LINECOMMENT: &quot;comment&quot;,</span>
<span class="gi">+        TOKEN_BLOCK_BEGIN: &quot;begin of statement block&quot;,</span>
<span class="gi">+        TOKEN_BLOCK_END: &quot;end of statement block&quot;,</span>
<span class="gi">+        TOKEN_VARIABLE_BEGIN: &quot;begin of print statement&quot;,</span>
<span class="gi">+        TOKEN_VARIABLE_END: &quot;end of print statement&quot;,</span>
<span class="gi">+        TOKEN_LINESTATEMENT_BEGIN: &quot;begin of line statement&quot;,</span>
<span class="gi">+        TOKEN_LINESTATEMENT_END: &quot;end of line statement&quot;,</span>
<span class="gi">+        TOKEN_DATA: &quot;template data / text&quot;,</span>
<span class="gi">+        TOKEN_EOF: &quot;end of template&quot;,</span>
<span class="gi">+    }.get(token_type, token_type)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def describe_token(token: &quot;Token&quot;) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a description of the token.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if token.type == TOKEN_NAME:</span>
<span class="gi">+        return token.value</span>

<span class="gi">+    return _describe_token_type(token.type)</span>

<span class="gd">-def describe_token_expr(expr: str) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def describe_token_expr(expr: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Like `describe_token` but for token expressions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;:&quot; in expr:</span>
<span class="gi">+        type, value = expr.split(&quot;:&quot;, 1)</span>
<span class="gi">+</span>
<span class="gi">+        if type == TOKEN_NAME:</span>
<span class="gi">+            return value</span>
<span class="gi">+    else:</span>
<span class="gi">+        type = expr</span>
<span class="gi">+</span>
<span class="gi">+    return _describe_token_type(type)</span>


<span class="gd">-def count_newlines(value: str) -&gt;int:</span>
<span class="gi">+def count_newlines(value: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Count the number of newline characters in the string.  This is
<span class="w"> </span>    useful for extensions that filter a stream.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(newline_re.findall(value))</span>


<span class="gd">-def compile_rules(environment: &#39;Environment&#39;) -&gt;t.List[t.Tuple[str, str]]:</span>
<span class="gi">+def compile_rules(environment: &quot;Environment&quot;) -&gt; t.List[t.Tuple[str, str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Compiles all the rules from the environment into a list of rules.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    e = re.escape</span>
<span class="gi">+    rules = [</span>
<span class="gi">+        (</span>
<span class="gi">+            len(environment.comment_start_string),</span>
<span class="gi">+            TOKEN_COMMENT_BEGIN,</span>
<span class="gi">+            e(environment.comment_start_string),</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            len(environment.block_start_string),</span>
<span class="gi">+            TOKEN_BLOCK_BEGIN,</span>
<span class="gi">+            e(environment.block_start_string),</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            len(environment.variable_start_string),</span>
<span class="gi">+            TOKEN_VARIABLE_BEGIN,</span>
<span class="gi">+            e(environment.variable_start_string),</span>
<span class="gi">+        ),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    if environment.line_statement_prefix is not None:</span>
<span class="gi">+        rules.append(</span>
<span class="gi">+            (</span>
<span class="gi">+                len(environment.line_statement_prefix),</span>
<span class="gi">+                TOKEN_LINESTATEMENT_BEGIN,</span>
<span class="gi">+                r&quot;^[ \t\v]*&quot; + e(environment.line_statement_prefix),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    if environment.line_comment_prefix is not None:</span>
<span class="gi">+        rules.append(</span>
<span class="gi">+            (</span>
<span class="gi">+                len(environment.line_comment_prefix),</span>
<span class="gi">+                TOKEN_LINECOMMENT_BEGIN,</span>
<span class="gi">+                r&quot;(?:^|(?&lt;=\S))[^\S\r\n]*&quot; + e(environment.line_comment_prefix),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return [x[1:] for x in sorted(rules, reverse=True)]</span>


<span class="w"> </span>class Failure:
<span class="gu">@@ -142,12 +256,13 @@ class Failure:</span>
<span class="w"> </span>    Used by the `Lexer` to specify known errors.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, cls: t.Type[TemplateSyntaxError]=</span>
<span class="gd">-        TemplateSyntaxError) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, message: str, cls: t.Type[TemplateSyntaxError] = TemplateSyntaxError</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.message = message
<span class="w"> </span>        self.error_class = cls

<span class="gd">-    def __call__(self, lineno: int, filename: str) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+    def __call__(self, lineno: int, filename: str) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        raise self.error_class(self.message, lineno, filename)


<span class="gu">@@ -156,19 +271,27 @@ class Token(t.NamedTuple):</span>
<span class="w"> </span>    type: str
<span class="w"> </span>    value: str

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return describe_token(self)

<span class="gd">-    def test(self, expr: str) -&gt;bool:</span>
<span class="gi">+    def test(self, expr: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Test a token against a token expression.  This can either be a
<span class="w"> </span>        token type or ``&#39;token_type:token_value&#39;``.  This can only test
<span class="w"> </span>        against string values and types.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # here we do a regular string equality check as test_any is usually</span>
<span class="gi">+        # passed an iterable of not interned strings.</span>
<span class="gi">+        if self.type == expr:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;:&quot; in expr:</span>
<span class="gi">+            return expr.split(&quot;:&quot;, 1) == [self.type, self.value]</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>

<span class="gd">-    def test_any(self, *iterable: str) -&gt;bool:</span>
<span class="gi">+    def test_any(self, *iterable: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Test against multiple token expressions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return any(self.test(expr) for expr in iterable)</span>


<span class="w"> </span>class TokenStreamIterator:
<span class="gu">@@ -176,17 +299,19 @@ class TokenStreamIterator:</span>
<span class="w"> </span>    until the eof token is reached.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stream: &#39;TokenStream&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, stream: &quot;TokenStream&quot;) -&gt; None:</span>
<span class="w"> </span>        self.stream = stream

<span class="gd">-    def __iter__(self) -&gt;&#39;TokenStreamIterator&#39;:</span>
<span class="gi">+    def __iter__(self) -&gt; &quot;TokenStreamIterator&quot;:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __next__(self) -&gt;Token:</span>
<span class="gi">+    def __next__(self) -&gt; Token:</span>
<span class="w"> </span>        token = self.stream.current
<span class="gi">+</span>
<span class="w"> </span>        if token.type is TOKEN_EOF:
<span class="w"> </span>            self.stream.close()
<span class="w"> </span>            raise StopIteration
<span class="gi">+</span>
<span class="w"> </span>        next(self.stream)
<span class="w"> </span>        return token

<span class="gu">@@ -197,55 +322,68 @@ class TokenStream:</span>
<span class="w"> </span>    one token ahead.  The current active token is stored as :attr:`current`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, generator: t.Iterable[Token], name: t.Optional[str],</span>
<span class="gd">-        filename: t.Optional[str]):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        generator: t.Iterable[Token],</span>
<span class="gi">+        name: t.Optional[str],</span>
<span class="gi">+        filename: t.Optional[str],</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self._iter = iter(generator)
<span class="gd">-        self._pushed: &#39;te.Deque[Token]&#39; = deque()</span>
<span class="gi">+        self._pushed: &quot;te.Deque[Token]&quot; = deque()</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.closed = False
<span class="gd">-        self.current = Token(1, TOKEN_INITIAL, &#39;&#39;)</span>
<span class="gi">+        self.current = Token(1, TOKEN_INITIAL, &quot;&quot;)</span>
<span class="w"> </span>        next(self)

<span class="gd">-    def __iter__(self) -&gt;TokenStreamIterator:</span>
<span class="gi">+    def __iter__(self) -&gt; TokenStreamIterator:</span>
<span class="w"> </span>        return TokenStreamIterator(self)

<span class="gd">-    def __bool__(self) -&gt;bool:</span>
<span class="gi">+    def __bool__(self) -&gt; bool:</span>
<span class="w"> </span>        return bool(self._pushed) or self.current.type is not TOKEN_EOF

<span class="w"> </span>    @property
<span class="gd">-    def eos(self) -&gt;bool:</span>
<span class="gi">+    def eos(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Are we at the end of the stream?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return not self</span>

<span class="gd">-    def push(self, token: Token) -&gt;None:</span>
<span class="gi">+    def push(self, token: Token) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Push a token back to the stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._pushed.append(token)</span>

<span class="gd">-    def look(self) -&gt;Token:</span>
<span class="gi">+    def look(self) -&gt; Token:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look at the next token.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        old_token = next(self)</span>
<span class="gi">+        result = self.current</span>
<span class="gi">+        self.push(result)</span>
<span class="gi">+        self.current = old_token</span>
<span class="gi">+        return result</span>

<span class="gd">-    def skip(self, n: int=1) -&gt;None:</span>
<span class="gi">+    def skip(self, n: int = 1) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Got n tokens ahead.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _ in range(n):</span>
<span class="gi">+            next(self)</span>

<span class="gd">-    def next_if(self, expr: str) -&gt;t.Optional[Token]:</span>
<span class="gi">+    def next_if(self, expr: str) -&gt; t.Optional[Token]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform the token test and return the token if it matched.
<span class="w"> </span>        Otherwise the return value is `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.current.test(expr):</span>
<span class="gi">+            return next(self)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="gd">-    def skip_if(self, expr: str) -&gt;bool:</span>
<span class="gi">+    def skip_if(self, expr: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like :meth:`next_if` but only returns `True` or `False`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.next_if(expr) is not None</span>

<span class="gd">-    def __next__(self) -&gt;Token:</span>
<span class="gi">+    def __next__(self) -&gt; Token:</span>
<span class="w"> </span>        &quot;&quot;&quot;Go one token ahead and return the old one.

<span class="w"> </span>        Use the built-in :func:`next` instead of calling this directly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        rv = self.current
<span class="gi">+</span>
<span class="w"> </span>        if self._pushed:
<span class="w"> </span>            self.current = self._pushed.popleft()
<span class="w"> </span>        elif self.current.type is not TOKEN_EOF:
<span class="gu">@@ -253,31 +391,74 @@ class TokenStream:</span>
<span class="w"> </span>                self.current = next(self._iter)
<span class="w"> </span>            except StopIteration:
<span class="w"> </span>                self.close()
<span class="gi">+</span>
<span class="w"> </span>        return rv

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Close the stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.current = Token(self.current.lineno, TOKEN_EOF, &quot;&quot;)</span>
<span class="gi">+        self._iter = iter(())</span>
<span class="gi">+        self.closed = True</span>

<span class="gd">-    def expect(self, expr: str) -&gt;Token:</span>
<span class="gi">+    def expect(self, expr: str) -&gt; Token:</span>
<span class="w"> </span>        &quot;&quot;&quot;Expect a given token type and return it.  This accepts the same
<span class="w"> </span>        argument as :meth:`jinja2.lexer.Token.test`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.current.test(expr):</span>
<span class="gi">+            expr = describe_token_expr(expr)</span>
<span class="gi">+</span>
<span class="gi">+            if self.current.type is TOKEN_EOF:</span>
<span class="gi">+                raise TemplateSyntaxError(</span>
<span class="gi">+                    f&quot;unexpected end of template, expected {expr!r}.&quot;,</span>
<span class="gi">+                    self.current.lineno,</span>
<span class="gi">+                    self.name,</span>
<span class="gi">+                    self.filename,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            raise TemplateSyntaxError(</span>
<span class="gi">+                f&quot;expected token {expr!r}, got {describe_token(self.current)!r}&quot;,</span>
<span class="gi">+                self.current.lineno,</span>
<span class="gi">+                self.name,</span>
<span class="gi">+                self.filename,</span>
<span class="gi">+            )</span>

<span class="gi">+        return next(self)</span>

<span class="gd">-def get_lexer(environment: &#39;Environment&#39;) -&gt;&#39;Lexer&#39;:</span>
<span class="gi">+</span>
<span class="gi">+def get_lexer(environment: &quot;Environment&quot;) -&gt; &quot;Lexer&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a lexer which is probably cached.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key = (</span>
<span class="gi">+        environment.block_start_string,</span>
<span class="gi">+        environment.block_end_string,</span>
<span class="gi">+        environment.variable_start_string,</span>
<span class="gi">+        environment.variable_end_string,</span>
<span class="gi">+        environment.comment_start_string,</span>
<span class="gi">+        environment.comment_end_string,</span>
<span class="gi">+        environment.line_statement_prefix,</span>
<span class="gi">+        environment.line_comment_prefix,</span>
<span class="gi">+        environment.trim_blocks,</span>
<span class="gi">+        environment.lstrip_blocks,</span>
<span class="gi">+        environment.newline_sequence,</span>
<span class="gi">+        environment.keep_trailing_newline,</span>
<span class="gi">+    )</span>
<span class="gi">+    lexer = _lexer_cache.get(key)</span>
<span class="gi">+</span>
<span class="gi">+    if lexer is None:</span>
<span class="gi">+        _lexer_cache[key] = lexer = Lexer(environment)</span>

<span class="gi">+    return lexer</span>

<span class="gd">-class OptionalLStrip(tuple):</span>
<span class="gi">+</span>
<span class="gi">+class OptionalLStrip(tuple):  # type: ignore[type-arg]</span>
<span class="w"> </span>    &quot;&quot;&quot;A special tuple for marking a point in the state that can have
<span class="w"> </span>    lstrip applied.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="gd">-    def __new__(cls, *members, **kwargs):</span>
<span class="gi">+    # Even though it looks like a no-op, creating instances fails</span>
<span class="gi">+    # without this.</span>
<span class="gi">+    def __new__(cls, *members, **kwargs):  # type: ignore</span>
<span class="w"> </span>        return super().__new__(cls, members)


<span class="gu">@@ -295,73 +476,203 @@ class Lexer:</span>
<span class="w"> </span>    Multiple environments can share the same lexer.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, environment: &#39;Environment&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, environment: &quot;Environment&quot;) -&gt; None:</span>
<span class="gi">+        # shortcuts</span>
<span class="w"> </span>        e = re.escape

<span class="gd">-        def c(x: str) -&gt;t.Pattern[str]:</span>
<span class="gi">+        def c(x: str) -&gt; t.Pattern[str]:</span>
<span class="w"> </span>            return re.compile(x, re.M | re.S)
<span class="gd">-        tag_rules: t.List[_Rule] = [_Rule(whitespace_re, TOKEN_WHITESPACE,</span>
<span class="gd">-            None), _Rule(float_re, TOKEN_FLOAT, None), _Rule(integer_re,</span>
<span class="gd">-            TOKEN_INTEGER, None), _Rule(name_re, TOKEN_NAME, None), _Rule(</span>
<span class="gd">-            string_re, TOKEN_STRING, None), _Rule(operator_re,</span>
<span class="gd">-            TOKEN_OPERATOR, None)]</span>
<span class="gi">+</span>
<span class="gi">+        # lexing rules for tags</span>
<span class="gi">+        tag_rules: t.List[_Rule] = [</span>
<span class="gi">+            _Rule(whitespace_re, TOKEN_WHITESPACE, None),</span>
<span class="gi">+            _Rule(float_re, TOKEN_FLOAT, None),</span>
<span class="gi">+            _Rule(integer_re, TOKEN_INTEGER, None),</span>
<span class="gi">+            _Rule(name_re, TOKEN_NAME, None),</span>
<span class="gi">+            _Rule(string_re, TOKEN_STRING, None),</span>
<span class="gi">+            _Rule(operator_re, TOKEN_OPERATOR, None),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # assemble the root lexing rule. because &quot;|&quot; is ungreedy</span>
<span class="gi">+        # we have to sort by length so that the lexer continues working</span>
<span class="gi">+        # as expected when we have parsing rules like &lt;% for block and</span>
<span class="gi">+        # &lt;%= for variables. (if someone wants asp like syntax)</span>
<span class="gi">+        # variables are just part of the rules if variable processing</span>
<span class="gi">+        # is required.</span>
<span class="w"> </span>        root_tag_rules = compile_rules(environment)
<span class="gi">+</span>
<span class="w"> </span>        block_start_re = e(environment.block_start_string)
<span class="w"> </span>        block_end_re = e(environment.block_end_string)
<span class="w"> </span>        comment_end_re = e(environment.comment_end_string)
<span class="w"> </span>        variable_end_re = e(environment.variable_end_string)
<span class="gd">-        block_suffix_re = &#39;\\n?&#39; if environment.trim_blocks else &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # block suffix if trimming is enabled</span>
<span class="gi">+        block_suffix_re = &quot;\\n?&quot; if environment.trim_blocks else &quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        self.lstrip_blocks = environment.lstrip_blocks
<span class="gi">+</span>
<span class="w"> </span>        self.newline_sequence = environment.newline_sequence
<span class="w"> </span>        self.keep_trailing_newline = environment.keep_trailing_newline
<span class="gi">+</span>
<span class="w"> </span>        root_raw_re = (
<span class="gd">-            f&#39;(?P&lt;raw_begin&gt;{block_start_re}(\\-|\\+|)\\s*raw\\s*(?:\\-{block_end_re}\\s*|{block_end_re}))&#39;</span>
<span class="gd">-            )</span>
<span class="gd">-        root_parts_re = &#39;|&#39;.join([root_raw_re] + [f&#39;(?P&lt;{n}&gt;{r}(\\-|\\+|))&#39; for</span>
<span class="gd">-            n, r in root_tag_rules])</span>
<span class="gd">-        self.rules: t.Dict[str, t.List[_Rule]] = {&#39;root&#39;: [_Rule(c(</span>
<span class="gd">-            f&#39;(.*?)(?:{root_parts_re})&#39;), OptionalLStrip(TOKEN_DATA,</span>
<span class="gd">-            &#39;#bygroup&#39;), &#39;#bygroup&#39;), _Rule(c(&#39;.+&#39;), TOKEN_DATA, None)],</span>
<span class="gd">-            TOKEN_COMMENT_BEGIN: [_Rule(c(</span>
<span class="gd">-            f&#39;(.*?)((?:\\+{comment_end_re}|\\-{comment_end_re}\\s*|{comment_end_re}{block_suffix_re}))&#39;</span>
<span class="gd">-            ), (TOKEN_COMMENT, TOKEN_COMMENT_END), &#39;#pop&#39;), _Rule(c(&#39;(.)&#39;),</span>
<span class="gd">-            (Failure(&#39;Missing end of comment tag&#39;),), None)],</span>
<span class="gd">-            TOKEN_BLOCK_BEGIN: [_Rule(c(</span>
<span class="gd">-            f&#39;(?:\\+{block_end_re}|\\-{block_end_re}\\s*|{block_end_re}{block_suffix_re})&#39;</span>
<span class="gd">-            ), TOKEN_BLOCK_END, &#39;#pop&#39;)] + tag_rules, TOKEN_VARIABLE_BEGIN:</span>
<span class="gd">-            [_Rule(c(f&#39;\\-{variable_end_re}\\s*|{variable_end_re}&#39;),</span>
<span class="gd">-            TOKEN_VARIABLE_END, &#39;#pop&#39;)] + tag_rules, TOKEN_RAW_BEGIN: [</span>
<span class="gd">-            _Rule(c(</span>
<span class="gd">-            f&#39;(.*?)((?:{block_start_re}(\\-|\\+|))\\s*endraw\\s*(?:\\+{block_end_re}|\\-{block_end_re}\\s*|{block_end_re}{block_suffix_re}))&#39;</span>
<span class="gd">-            ), OptionalLStrip(TOKEN_DATA, TOKEN_RAW_END), &#39;#pop&#39;), _Rule(c(</span>
<span class="gd">-            &#39;(.)&#39;), (Failure(&#39;Missing end of raw directive&#39;),), None)],</span>
<span class="gd">-            TOKEN_LINESTATEMENT_BEGIN: [_Rule(c(&#39;\\s*(\\n|$)&#39;),</span>
<span class="gd">-            TOKEN_LINESTATEMENT_END, &#39;#pop&#39;)] + tag_rules,</span>
<span class="gd">-            TOKEN_LINECOMMENT_BEGIN: [_Rule(c(&#39;(.*?)()(?=\\n|$)&#39;), (</span>
<span class="gd">-            TOKEN_LINECOMMENT, TOKEN_LINECOMMENT_END), &#39;#pop&#39;)]}</span>
<span class="gd">-</span>
<span class="gd">-    def _normalize_newlines(self, value: str) -&gt;str:</span>
<span class="gi">+            rf&quot;(?P&lt;raw_begin&gt;{block_start_re}(\-|\+|)\s*raw\s*&quot;</span>
<span class="gi">+            rf&quot;(?:\-{block_end_re}\s*|{block_end_re}))&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        root_parts_re = &quot;|&quot;.join(</span>
<span class="gi">+            [root_raw_re] + [rf&quot;(?P&lt;{n}&gt;{r}(\-|\+|))&quot; for n, r in root_tag_rules]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # global lexing rules</span>
<span class="gi">+        self.rules: t.Dict[str, t.List[_Rule]] = {</span>
<span class="gi">+            &quot;root&quot;: [</span>
<span class="gi">+                # directives</span>
<span class="gi">+                _Rule(</span>
<span class="gi">+                    c(rf&quot;(.*?)(?:{root_parts_re})&quot;),</span>
<span class="gi">+                    OptionalLStrip(TOKEN_DATA, &quot;#bygroup&quot;),  # type: ignore</span>
<span class="gi">+                    &quot;#bygroup&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                # data</span>
<span class="gi">+                _Rule(c(&quot;.+&quot;), TOKEN_DATA, None),</span>
<span class="gi">+            ],</span>
<span class="gi">+            # comments</span>
<span class="gi">+            TOKEN_COMMENT_BEGIN: [</span>
<span class="gi">+                _Rule(</span>
<span class="gi">+                    c(</span>
<span class="gi">+                        rf&quot;(.*?)((?:\+{comment_end_re}|\-{comment_end_re}\s*&quot;</span>
<span class="gi">+                        rf&quot;|{comment_end_re}{block_suffix_re}))&quot;</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    (TOKEN_COMMENT, TOKEN_COMMENT_END),</span>
<span class="gi">+                    &quot;#pop&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                _Rule(c(r&quot;(.)&quot;), (Failure(&quot;Missing end of comment tag&quot;),), None),</span>
<span class="gi">+            ],</span>
<span class="gi">+            # blocks</span>
<span class="gi">+            TOKEN_BLOCK_BEGIN: [</span>
<span class="gi">+                _Rule(</span>
<span class="gi">+                    c(</span>
<span class="gi">+                        rf&quot;(?:\+{block_end_re}|\-{block_end_re}\s*&quot;</span>
<span class="gi">+                        rf&quot;|{block_end_re}{block_suffix_re})&quot;</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    TOKEN_BLOCK_END,</span>
<span class="gi">+                    &quot;#pop&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+            ]</span>
<span class="gi">+            + tag_rules,</span>
<span class="gi">+            # variables</span>
<span class="gi">+            TOKEN_VARIABLE_BEGIN: [</span>
<span class="gi">+                _Rule(</span>
<span class="gi">+                    c(rf&quot;\-{variable_end_re}\s*|{variable_end_re}&quot;),</span>
<span class="gi">+                    TOKEN_VARIABLE_END,</span>
<span class="gi">+                    &quot;#pop&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+            ]</span>
<span class="gi">+            + tag_rules,</span>
<span class="gi">+            # raw block</span>
<span class="gi">+            TOKEN_RAW_BEGIN: [</span>
<span class="gi">+                _Rule(</span>
<span class="gi">+                    c(</span>
<span class="gi">+                        rf&quot;(.*?)((?:{block_start_re}(\-|\+|))\s*endraw\s*&quot;</span>
<span class="gi">+                        rf&quot;(?:\+{block_end_re}|\-{block_end_re}\s*&quot;</span>
<span class="gi">+                        rf&quot;|{block_end_re}{block_suffix_re}))&quot;</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    OptionalLStrip(TOKEN_DATA, TOKEN_RAW_END),  # type: ignore</span>
<span class="gi">+                    &quot;#pop&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                _Rule(c(r&quot;(.)&quot;), (Failure(&quot;Missing end of raw directive&quot;),), None),</span>
<span class="gi">+            ],</span>
<span class="gi">+            # line statements</span>
<span class="gi">+            TOKEN_LINESTATEMENT_BEGIN: [</span>
<span class="gi">+                _Rule(c(r&quot;\s*(\n|$)&quot;), TOKEN_LINESTATEMENT_END, &quot;#pop&quot;)</span>
<span class="gi">+            ]</span>
<span class="gi">+            + tag_rules,</span>
<span class="gi">+            # line comments</span>
<span class="gi">+            TOKEN_LINECOMMENT_BEGIN: [</span>
<span class="gi">+                _Rule(</span>
<span class="gi">+                    c(r&quot;(.*?)()(?=\n|$)&quot;),</span>
<span class="gi">+                    (TOKEN_LINECOMMENT, TOKEN_LINECOMMENT_END),</span>
<span class="gi">+                    &quot;#pop&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+            ],</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def _normalize_newlines(self, value: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace all newlines with the configured sequence in strings
<span class="w"> </span>        and template data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def tokenize(self, source: str, name: t.Optional[str]=None, filename: t</span>
<span class="gd">-        .Optional[str]=None, state: t.Optional[str]=None) -&gt;TokenStream:</span>
<span class="gi">+        return newline_re.sub(self.newline_sequence, value)</span>
<span class="gi">+</span>
<span class="gi">+    def tokenize(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: str,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+        state: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; TokenStream:</span>
<span class="w"> </span>        &quot;&quot;&quot;Calls tokeniter + tokenize and wraps it in a token stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def wrap(self, stream: t.Iterable[t.Tuple[int, str, str]], name: t.</span>
<span class="gd">-        Optional[str]=None, filename: t.Optional[str]=None) -&gt;t.Iterator[Token</span>
<span class="gd">-        ]:</span>
<span class="gi">+        stream = self.tokeniter(source, name, filename, state)</span>
<span class="gi">+        return TokenStream(self.wrap(stream, name, filename), name, filename)</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stream: t.Iterable[t.Tuple[int, str, str]],</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; t.Iterator[Token]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is called with the stream as returned by `tokenize` and wraps
<span class="w"> </span>        every token in a :class:`Token` and converts the value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def tokeniter(self, source: str, name: t.Optional[str], filename: t.</span>
<span class="gd">-        Optional[str]=None, state: t.Optional[str]=None) -&gt;t.Iterator[t.</span>
<span class="gd">-        Tuple[int, str, str]]:</span>
<span class="gi">+        for lineno, token, value_str in stream:</span>
<span class="gi">+            if token in ignored_tokens:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            value: t.Any = value_str</span>
<span class="gi">+</span>
<span class="gi">+            if token == TOKEN_LINESTATEMENT_BEGIN:</span>
<span class="gi">+                token = TOKEN_BLOCK_BEGIN</span>
<span class="gi">+            elif token == TOKEN_LINESTATEMENT_END:</span>
<span class="gi">+                token = TOKEN_BLOCK_END</span>
<span class="gi">+            # we are not interested in those tokens in the parser</span>
<span class="gi">+            elif token in (TOKEN_RAW_BEGIN, TOKEN_RAW_END):</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif token == TOKEN_DATA:</span>
<span class="gi">+                value = self._normalize_newlines(value_str)</span>
<span class="gi">+            elif token == &quot;keyword&quot;:</span>
<span class="gi">+                token = value_str</span>
<span class="gi">+            elif token == TOKEN_NAME:</span>
<span class="gi">+                value = value_str</span>
<span class="gi">+</span>
<span class="gi">+                if not value.isidentifier():</span>
<span class="gi">+                    raise TemplateSyntaxError(</span>
<span class="gi">+                        &quot;Invalid character in identifier&quot;, lineno, name, filename</span>
<span class="gi">+                    )</span>
<span class="gi">+            elif token == TOKEN_STRING:</span>
<span class="gi">+                # try to unescape string</span>
<span class="gi">+                try:</span>
<span class="gi">+                    value = (</span>
<span class="gi">+                        self._normalize_newlines(value_str[1:-1])</span>
<span class="gi">+                        .encode(&quot;ascii&quot;, &quot;backslashreplace&quot;)</span>
<span class="gi">+                        .decode(&quot;unicode-escape&quot;)</span>
<span class="gi">+                    )</span>
<span class="gi">+                except Exception as e:</span>
<span class="gi">+                    msg = str(e).split(&quot;:&quot;)[-1].strip()</span>
<span class="gi">+                    raise TemplateSyntaxError(msg, lineno, name, filename) from e</span>
<span class="gi">+            elif token == TOKEN_INTEGER:</span>
<span class="gi">+                value = int(value_str.replace(&quot;_&quot;, &quot;&quot;), 0)</span>
<span class="gi">+            elif token == TOKEN_FLOAT:</span>
<span class="gi">+                # remove all &quot;_&quot; first to support more Python versions</span>
<span class="gi">+                value = literal_eval(value_str.replace(&quot;_&quot;, &quot;&quot;))</span>
<span class="gi">+            elif token == TOKEN_OPERATOR:</span>
<span class="gi">+                token = operators[value_str]</span>
<span class="gi">+</span>
<span class="gi">+            yield Token(lineno, token, value)</span>
<span class="gi">+</span>
<span class="gi">+    def tokeniter(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: str,</span>
<span class="gi">+        name: t.Optional[str],</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+        state: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; t.Iterator[t.Tuple[int, str, str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method tokenizes the text and returns the tokens in a
<span class="w"> </span>        generator. Use this method if you just want to tokenize a template.

<span class="gu">@@ -369,4 +680,189 @@ class Lexer:</span>
<span class="w"> </span>            Only ``\\n``, ``\\r\\n`` and ``\\r`` are treated as line
<span class="w"> </span>            breaks.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines = newline_re.split(source)[::2]</span>
<span class="gi">+</span>
<span class="gi">+        if not self.keep_trailing_newline and lines[-1] == &quot;&quot;:</span>
<span class="gi">+            del lines[-1]</span>
<span class="gi">+</span>
<span class="gi">+        source = &quot;\n&quot;.join(lines)</span>
<span class="gi">+        pos = 0</span>
<span class="gi">+        lineno = 1</span>
<span class="gi">+        stack = [&quot;root&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if state is not None and state != &quot;root&quot;:</span>
<span class="gi">+            assert state in (&quot;variable&quot;, &quot;block&quot;), &quot;invalid state&quot;</span>
<span class="gi">+            stack.append(state + &quot;_begin&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        statetokens = self.rules[stack[-1]]</span>
<span class="gi">+        source_length = len(source)</span>
<span class="gi">+        balancing_stack: t.List[str] = []</span>
<span class="gi">+        newlines_stripped = 0</span>
<span class="gi">+        line_starting = True</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # tokenizer loop</span>
<span class="gi">+            for regex, tokens, new_state in statetokens:</span>
<span class="gi">+                m = regex.match(source, pos)</span>
<span class="gi">+</span>
<span class="gi">+                # if no match we try again with the next rule</span>
<span class="gi">+                if m is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # we only match blocks and variables if braces / parentheses</span>
<span class="gi">+                # are balanced. continue parsing with the lower rule which</span>
<span class="gi">+                # is the operator rule. do this only if the end tags look</span>
<span class="gi">+                # like operators</span>
<span class="gi">+                if balancing_stack and tokens in (</span>
<span class="gi">+                    TOKEN_VARIABLE_END,</span>
<span class="gi">+                    TOKEN_BLOCK_END,</span>
<span class="gi">+                    TOKEN_LINESTATEMENT_END,</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # tuples support more options</span>
<span class="gi">+                if isinstance(tokens, tuple):</span>
<span class="gi">+                    groups: t.Sequence[str] = m.groups()</span>
<span class="gi">+</span>
<span class="gi">+                    if isinstance(tokens, OptionalLStrip):</span>
<span class="gi">+                        # Rule supports lstrip. Match will look like</span>
<span class="gi">+                        # text, block type, whitespace control, type, control, ...</span>
<span class="gi">+                        text = groups[0]</span>
<span class="gi">+                        # Skipping the text and first type, every other group is the</span>
<span class="gi">+                        # whitespace control for each type. One of the groups will be</span>
<span class="gi">+                        # -, +, or empty string instead of None.</span>
<span class="gi">+                        strip_sign = next(g for g in groups[2::2] if g is not None)</span>
<span class="gi">+</span>
<span class="gi">+                        if strip_sign == &quot;-&quot;:</span>
<span class="gi">+                            # Strip all whitespace between the text and the tag.</span>
<span class="gi">+                            stripped = text.rstrip()</span>
<span class="gi">+                            newlines_stripped = text[len(stripped) :].count(&quot;\n&quot;)</span>
<span class="gi">+                            groups = [stripped, *groups[1:]]</span>
<span class="gi">+                        elif (</span>
<span class="gi">+                            # Not marked for preserving whitespace.</span>
<span class="gi">+                            strip_sign != &quot;+&quot;</span>
<span class="gi">+                            # lstrip is enabled.</span>
<span class="gi">+                            and self.lstrip_blocks</span>
<span class="gi">+                            # Not a variable expression.</span>
<span class="gi">+                            and not m.groupdict().get(TOKEN_VARIABLE_BEGIN)</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            # The start of text between the last newline and the tag.</span>
<span class="gi">+                            l_pos = text.rfind(&quot;\n&quot;) + 1</span>
<span class="gi">+</span>
<span class="gi">+                            if l_pos &gt; 0 or line_starting:</span>
<span class="gi">+                                # If there&#39;s only whitespace between the newline and the</span>
<span class="gi">+                                # tag, strip it.</span>
<span class="gi">+                                if whitespace_re.fullmatch(text, l_pos):</span>
<span class="gi">+                                    groups = [text[:l_pos], *groups[1:]]</span>
<span class="gi">+</span>
<span class="gi">+                    for idx, token in enumerate(tokens):</span>
<span class="gi">+                        # failure group</span>
<span class="gi">+                        if token.__class__ is Failure:</span>
<span class="gi">+                            raise token(lineno, filename)</span>
<span class="gi">+                        # bygroup is a bit more complex, in that case we</span>
<span class="gi">+                        # yield for the current token the first named</span>
<span class="gi">+                        # group that matched</span>
<span class="gi">+                        elif token == &quot;#bygroup&quot;:</span>
<span class="gi">+                            for key, value in m.groupdict().items():</span>
<span class="gi">+                                if value is not None:</span>
<span class="gi">+                                    yield lineno, key, value</span>
<span class="gi">+                                    lineno += value.count(&quot;\n&quot;)</span>
<span class="gi">+                                    break</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                raise RuntimeError(</span>
<span class="gi">+                                    f&quot;{regex!r} wanted to resolve the token dynamically&quot;</span>
<span class="gi">+                                    &quot; but no group matched&quot;</span>
<span class="gi">+                                )</span>
<span class="gi">+                        # normal group</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            data = groups[idx]</span>
<span class="gi">+</span>
<span class="gi">+                            if data or token not in ignore_if_empty:</span>
<span class="gi">+                                yield lineno, token, data</span>
<span class="gi">+</span>
<span class="gi">+                            lineno += data.count(&quot;\n&quot;) + newlines_stripped</span>
<span class="gi">+                            newlines_stripped = 0</span>
<span class="gi">+</span>
<span class="gi">+                # strings as token just are yielded as it.</span>
<span class="gi">+                else:</span>
<span class="gi">+                    data = m.group()</span>
<span class="gi">+</span>
<span class="gi">+                    # update brace/parentheses balance</span>
<span class="gi">+                    if tokens == TOKEN_OPERATOR:</span>
<span class="gi">+                        if data == &quot;{&quot;:</span>
<span class="gi">+                            balancing_stack.append(&quot;}&quot;)</span>
<span class="gi">+                        elif data == &quot;(&quot;:</span>
<span class="gi">+                            balancing_stack.append(&quot;)&quot;)</span>
<span class="gi">+                        elif data == &quot;[&quot;:</span>
<span class="gi">+                            balancing_stack.append(&quot;]&quot;)</span>
<span class="gi">+                        elif data in (&quot;}&quot;, &quot;)&quot;, &quot;]&quot;):</span>
<span class="gi">+                            if not balancing_stack:</span>
<span class="gi">+                                raise TemplateSyntaxError(</span>
<span class="gi">+                                    f&quot;unexpected &#39;{data}&#39;&quot;, lineno, name, filename</span>
<span class="gi">+                                )</span>
<span class="gi">+</span>
<span class="gi">+                            expected_op = balancing_stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+                            if expected_op != data:</span>
<span class="gi">+                                raise TemplateSyntaxError(</span>
<span class="gi">+                                    f&quot;unexpected &#39;{data}&#39;, expected &#39;{expected_op}&#39;&quot;,</span>
<span class="gi">+                                    lineno,</span>
<span class="gi">+                                    name,</span>
<span class="gi">+                                    filename,</span>
<span class="gi">+                                )</span>
<span class="gi">+</span>
<span class="gi">+                    # yield items</span>
<span class="gi">+                    if data or tokens not in ignore_if_empty:</span>
<span class="gi">+                        yield lineno, tokens, data</span>
<span class="gi">+</span>
<span class="gi">+                    lineno += data.count(&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                line_starting = m.group()[-1:] == &quot;\n&quot;</span>
<span class="gi">+                # fetch new position into new variable so that we can check</span>
<span class="gi">+                # if there is a internal parsing error which would result</span>
<span class="gi">+                # in an infinite loop</span>
<span class="gi">+                pos2 = m.end()</span>
<span class="gi">+</span>
<span class="gi">+                # handle state changes</span>
<span class="gi">+                if new_state is not None:</span>
<span class="gi">+                    # remove the uppermost state</span>
<span class="gi">+                    if new_state == &quot;#pop&quot;:</span>
<span class="gi">+                        stack.pop()</span>
<span class="gi">+                    # resolve the new state by group checking</span>
<span class="gi">+                    elif new_state == &quot;#bygroup&quot;:</span>
<span class="gi">+                        for key, value in m.groupdict().items():</span>
<span class="gi">+                            if value is not None:</span>
<span class="gi">+                                stack.append(key)</span>
<span class="gi">+                                break</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            raise RuntimeError(</span>
<span class="gi">+                                f&quot;{regex!r} wanted to resolve the new state dynamically&quot;</span>
<span class="gi">+                                f&quot; but no group matched&quot;</span>
<span class="gi">+                            )</span>
<span class="gi">+                    # direct state name given</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        stack.append(new_state)</span>
<span class="gi">+</span>
<span class="gi">+                    statetokens = self.rules[stack[-1]]</span>
<span class="gi">+                # we are still at the same position and no stack change.</span>
<span class="gi">+                # this means a loop without break condition, avoid that and</span>
<span class="gi">+                # raise error</span>
<span class="gi">+                elif pos2 == pos:</span>
<span class="gi">+                    raise RuntimeError(</span>
<span class="gi">+                        f&quot;{regex!r} yielded empty string without stack change&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                # publish new function and start again</span>
<span class="gi">+                pos = pos2</span>
<span class="gi">+                break</span>
<span class="gi">+            # if loop terminated without break we haven&#39;t found a single match</span>
<span class="gi">+            # either we are at the end of the file or we have a problem</span>
<span class="gi">+            else:</span>
<span class="gi">+                # end of text</span>
<span class="gi">+                if pos &gt;= source_length:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                # something went wrong</span>
<span class="gi">+                raise TemplateSyntaxError(</span>
<span class="gi">+                    f&quot;unexpected char {source[pos]!r} at {pos}&quot;, lineno, name, filename</span>
<span class="gi">+                )</span>
<span class="gh">diff --git a/src/jinja2/loaders.py b/src/jinja2/loaders.py</span>
<span class="gh">index f336510..9eaf647 100644</span>
<span class="gd">--- a/src/jinja2/loaders.py</span>
<span class="gi">+++ b/src/jinja2/loaders.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;API and implementations for loading templates from different data
<span class="w"> </span>sources.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import importlib.util
<span class="w"> </span>import os
<span class="w"> </span>import posixpath
<span class="gu">@@ -12,18 +13,30 @@ from collections import abc</span>
<span class="w"> </span>from hashlib import sha1
<span class="w"> </span>from importlib import import_module
<span class="w"> </span>from types import ModuleType
<span class="gi">+</span>
<span class="w"> </span>from .exceptions import TemplateNotFound
<span class="w"> </span>from .utils import internalcode
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from .environment import Environment
<span class="w"> </span>    from .environment import Template


<span class="gd">-def split_template_path(template: str) -&gt;t.List[str]:</span>
<span class="gi">+def split_template_path(template: str) -&gt; t.List[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Split a path into segments and perform a sanity check.  If it detects
<span class="w"> </span>    &#39;..&#39; in the path it will raise a `TemplateNotFound` error.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pieces = []</span>
<span class="gi">+    for piece in template.split(&quot;/&quot;):</span>
<span class="gi">+        if (</span>
<span class="gi">+            os.path.sep in piece</span>
<span class="gi">+            or (os.path.altsep and os.path.altsep in piece)</span>
<span class="gi">+            or piece == os.path.pardir</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise TemplateNotFound(template)</span>
<span class="gi">+        elif piece and piece != &quot;.&quot;:</span>
<span class="gi">+            pieces.append(piece)</span>
<span class="gi">+    return pieces</span>


<span class="w"> </span>class BaseLoader:
<span class="gu">@@ -52,10 +65,16 @@ class BaseLoader:</span>
<span class="w"> </span>                    source = f.read()
<span class="w"> </span>                return source, path, lambda: mtime == getmtime(path)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: if set to `False` it indicates that the loader cannot provide access</span>
<span class="gi">+    #: to the source of templates.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 2.4</span>
<span class="w"> </span>    has_source_access = True

<span class="gd">-    def get_source(self, environment: &#39;Environment&#39;, template: str) -&gt;t.Tuple[</span>
<span class="gd">-        str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:</span>
<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: &quot;Environment&quot;, template: str</span>
<span class="gi">+    ) -&gt; t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the template source, filename and reload helper for a template.
<span class="w"> </span>        It&#39;s passed the environment and template name and has to return a
<span class="w"> </span>        tuple in the form ``(source, filename, uptodate)`` or raise a
<span class="gu">@@ -73,24 +92,61 @@ class BaseLoader:</span>
<span class="w"> </span>        old state somewhere (for example in a closure).  If it returns `False`
<span class="w"> </span>        the template will be reloaded.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.has_source_access:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                f&quot;{type(self).__name__} cannot provide access to the source&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        raise TemplateNotFound(template)</span>

<span class="gd">-    def list_templates(self) -&gt;t.List[str]:</span>
<span class="gi">+    def list_templates(self) -&gt; t.List[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterates over all templates.  If the loader does not support that
<span class="w"> </span>        it should raise a :exc:`TypeError` which is the default behavior.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise TypeError(&quot;this loader cannot iterate over all templates&quot;)</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def load(self, environment: &#39;Environment&#39;, name: str, globals: t.</span>
<span class="gd">-        Optional[t.MutableMapping[str, t.Any]]=None) -&gt;&#39;Template&#39;:</span>
<span class="gi">+    def load(</span>
<span class="gi">+        self,</span>
<span class="gi">+        environment: &quot;Environment&quot;,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Loads a template.  This method looks up the template in the cache
<span class="w"> </span>        or loads one by calling :meth:`get_source`.  Subclasses should not
<span class="w"> </span>        override this method as loaders working on collections of other
<span class="w"> </span>        loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
<span class="w"> </span>        will not call this method but `get_source` directly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        code = None</span>
<span class="gi">+        if globals is None:</span>
<span class="gi">+            globals = {}</span>
<span class="gi">+</span>
<span class="gi">+        # first we try to get the source for this template together</span>
<span class="gi">+        # with the filename and the uptodate function.</span>
<span class="gi">+        source, filename, uptodate = self.get_source(environment, name)</span>
<span class="gi">+</span>
<span class="gi">+        # try to load the code from the bytecode cache if there is a</span>
<span class="gi">+        # bytecode cache configured.</span>
<span class="gi">+        bcc = environment.bytecode_cache</span>
<span class="gi">+        if bcc is not None:</span>
<span class="gi">+            bucket = bcc.get_bucket(environment, name, filename, source)</span>
<span class="gi">+            code = bucket.code</span>
<span class="gi">+</span>
<span class="gi">+        # if we don&#39;t have code so far (not cached, no longer up to</span>
<span class="gi">+        # date) etc. we compile the template</span>
<span class="gi">+        if code is None:</span>
<span class="gi">+            code = environment.compile(source, name, filename)</span>
<span class="gi">+</span>
<span class="gi">+        # if the bytecode cache is available and the bucket doesn&#39;t</span>
<span class="gi">+        # have a code so far, we give the bucket the new code and put</span>
<span class="gi">+        # it back to the bytecode cache.</span>
<span class="gi">+        if bcc is not None and bucket.code is None:</span>
<span class="gi">+            bucket.code = code</span>
<span class="gi">+            bcc.set_bucket(bucket)</span>
<span class="gi">+</span>
<span class="gi">+        return environment.template_class.from_code(</span>
<span class="gi">+            environment, code, globals, uptodate</span>
<span class="gi">+        )</span>


<span class="w"> </span>class FileSystemLoader(BaseLoader):
<span class="gu">@@ -120,16 +176,67 @@ class FileSystemLoader(BaseLoader):</span>
<span class="w"> </span>        Added the ``followlinks`` parameter.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, searchpath: t.Union[str, &#39;os.PathLike[str]&#39;, t.</span>
<span class="gd">-        Sequence[t.Union[str, &#39;os.PathLike[str]&#39;]]], encoding: str=&#39;utf-8&#39;,</span>
<span class="gd">-        followlinks: bool=False) -&gt;None:</span>
<span class="gd">-        if not isinstance(searchpath, abc.Iterable) or isinstance(searchpath,</span>
<span class="gd">-            str):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        searchpath: t.Union[</span>
<span class="gi">+            str, &quot;os.PathLike[str]&quot;, t.Sequence[t.Union[str, &quot;os.PathLike[str]&quot;]]</span>
<span class="gi">+        ],</span>
<span class="gi">+        encoding: str = &quot;utf-8&quot;,</span>
<span class="gi">+        followlinks: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if not isinstance(searchpath, abc.Iterable) or isinstance(searchpath, str):</span>
<span class="w"> </span>            searchpath = [searchpath]
<span class="gi">+</span>
<span class="w"> </span>        self.searchpath = [os.fspath(p) for p in searchpath]
<span class="w"> </span>        self.encoding = encoding
<span class="w"> </span>        self.followlinks = followlinks

<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: &quot;Environment&quot;, template: str</span>
<span class="gi">+    ) -&gt; t.Tuple[str, str, t.Callable[[], bool]]:</span>
<span class="gi">+        pieces = split_template_path(template)</span>
<span class="gi">+</span>
<span class="gi">+        for searchpath in self.searchpath:</span>
<span class="gi">+            # Use posixpath even on Windows to avoid &quot;drive:&quot; or UNC</span>
<span class="gi">+            # segments breaking out of the search directory.</span>
<span class="gi">+            filename = posixpath.join(searchpath, *pieces)</span>
<span class="gi">+</span>
<span class="gi">+            if os.path.isfile(filename):</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TemplateNotFound(template)</span>
<span class="gi">+</span>
<span class="gi">+        with open(filename, encoding=self.encoding) as f:</span>
<span class="gi">+            contents = f.read()</span>
<span class="gi">+</span>
<span class="gi">+        mtime = os.path.getmtime(filename)</span>
<span class="gi">+</span>
<span class="gi">+        def uptodate() -&gt; bool:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return os.path.getmtime(filename) == mtime</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        # Use normpath to convert Windows altsep to sep.</span>
<span class="gi">+        return contents, os.path.normpath(filename), uptodate</span>
<span class="gi">+</span>
<span class="gi">+    def list_templates(self) -&gt; t.List[str]:</span>
<span class="gi">+        found = set()</span>
<span class="gi">+        for searchpath in self.searchpath:</span>
<span class="gi">+            walk_dir = os.walk(searchpath, followlinks=self.followlinks)</span>
<span class="gi">+            for dirpath, _, filenames in walk_dir:</span>
<span class="gi">+                for filename in filenames:</span>
<span class="gi">+                    template = (</span>
<span class="gi">+                        os.path.join(dirpath, filename)[len(searchpath) :]</span>
<span class="gi">+                        .strip(os.path.sep)</span>
<span class="gi">+                        .replace(os.path.sep, &quot;/&quot;)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if template[:2] == &quot;./&quot;:</span>
<span class="gi">+                        template = template[2:]</span>
<span class="gi">+                    if template not in found:</span>
<span class="gi">+                        found.add(template)</span>
<span class="gi">+        return sorted(found)</span>
<span class="gi">+</span>

<span class="w"> </span>class PackageLoader(BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;Load templates from a directory in a Python package.
<span class="gu">@@ -164,46 +271,138 @@ class PackageLoader(BaseLoader):</span>
<span class="w"> </span>        Limited PEP 420 namespace package support.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, package_name: str, package_path: &#39;str&#39;=&#39;templates&#39;,</span>
<span class="gd">-        encoding: str=&#39;utf-8&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        package_name: str,</span>
<span class="gi">+        package_path: &quot;str&quot; = &quot;templates&quot;,</span>
<span class="gi">+        encoding: str = &quot;utf-8&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        package_path = os.path.normpath(package_path).rstrip(os.path.sep)
<span class="gi">+</span>
<span class="gi">+        # normpath preserves &quot;.&quot;, which isn&#39;t valid in zip paths.</span>
<span class="w"> </span>        if package_path == os.path.curdir:
<span class="gd">-            package_path = &#39;&#39;</span>
<span class="gi">+            package_path = &quot;&quot;</span>
<span class="w"> </span>        elif package_path[:2] == os.path.curdir + os.path.sep:
<span class="w"> </span>            package_path = package_path[2:]
<span class="gi">+</span>
<span class="w"> </span>        self.package_path = package_path
<span class="w"> </span>        self.package_name = package_name
<span class="w"> </span>        self.encoding = encoding
<span class="gi">+</span>
<span class="gi">+        # Make sure the package exists. This also makes namespace</span>
<span class="gi">+        # packages work, otherwise get_loader returns None.</span>
<span class="w"> </span>        import_module(package_name)
<span class="w"> </span>        spec = importlib.util.find_spec(package_name)
<span class="gd">-        assert spec is not None, &#39;An import spec was not found for the package.&#39;</span>
<span class="gi">+        assert spec is not None, &quot;An import spec was not found for the package.&quot;</span>
<span class="w"> </span>        loader = spec.loader
<span class="gd">-        assert loader is not None, &#39;A loader was not found for the package.&#39;</span>
<span class="gi">+        assert loader is not None, &quot;A loader was not found for the package.&quot;</span>
<span class="w"> </span>        self._loader = loader
<span class="w"> </span>        self._archive = None
<span class="w"> </span>        template_root = None
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(loader, zipimport.zipimporter):
<span class="w"> </span>            self._archive = loader.archive
<span class="gd">-            pkgdir = next(iter(spec.submodule_search_locations))</span>
<span class="gd">-            template_root = os.path.join(pkgdir, package_path).rstrip(os.</span>
<span class="gd">-                path.sep)</span>
<span class="gi">+            pkgdir = next(iter(spec.submodule_search_locations))  # type: ignore</span>
<span class="gi">+            template_root = os.path.join(pkgdir, package_path).rstrip(os.path.sep)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            roots: t.List[str] = []
<span class="gi">+</span>
<span class="gi">+            # One element for regular packages, multiple for namespace</span>
<span class="gi">+            # packages, or None for single module file.</span>
<span class="w"> </span>            if spec.submodule_search_locations:
<span class="w"> </span>                roots.extend(spec.submodule_search_locations)
<span class="gi">+            # A single module file, use the parent directory instead.</span>
<span class="w"> </span>            elif spec.origin is not None:
<span class="w"> </span>                roots.append(os.path.dirname(spec.origin))
<span class="gi">+</span>
<span class="w"> </span>            for root in roots:
<span class="w"> </span>                root = os.path.join(root, package_path)
<span class="gi">+</span>
<span class="w"> </span>                if os.path.isdir(root):
<span class="w"> </span>                    template_root = root
<span class="w"> </span>                    break
<span class="gi">+</span>
<span class="w"> </span>        if template_root is None:
<span class="w"> </span>            raise ValueError(
<span class="gd">-                f&#39;The {package_name!r} package was not installed in a way that PackageLoader understands.&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;The {package_name!r} package was not installed in a&quot;</span>
<span class="gi">+                &quot; way that PackageLoader understands.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        self._template_root = template_root

<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: &quot;Environment&quot;, template: str</span>
<span class="gi">+    ) -&gt; t.Tuple[str, str, t.Optional[t.Callable[[], bool]]]:</span>
<span class="gi">+        # Use posixpath even on Windows to avoid &quot;drive:&quot; or UNC</span>
<span class="gi">+        # segments breaking out of the search directory. Use normpath to</span>
<span class="gi">+        # convert Windows altsep to sep.</span>
<span class="gi">+        p = os.path.normpath(</span>
<span class="gi">+            posixpath.join(self._template_root, *split_template_path(template))</span>
<span class="gi">+        )</span>
<span class="gi">+        up_to_date: t.Optional[t.Callable[[], bool]]</span>
<span class="gi">+</span>
<span class="gi">+        if self._archive is None:</span>
<span class="gi">+            # Package is a directory.</span>
<span class="gi">+            if not os.path.isfile(p):</span>
<span class="gi">+                raise TemplateNotFound(template)</span>
<span class="gi">+</span>
<span class="gi">+            with open(p, &quot;rb&quot;) as f:</span>
<span class="gi">+                source = f.read()</span>
<span class="gi">+</span>
<span class="gi">+            mtime = os.path.getmtime(p)</span>
<span class="gi">+</span>
<span class="gi">+            def up_to_date() -&gt; bool:</span>
<span class="gi">+                return os.path.isfile(p) and os.path.getmtime(p) == mtime</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Package is a zip file.</span>
<span class="gi">+            try:</span>
<span class="gi">+                source = self._loader.get_data(p)  # type: ignore</span>
<span class="gi">+            except OSError as e:</span>
<span class="gi">+                raise TemplateNotFound(template) from e</span>
<span class="gi">+</span>
<span class="gi">+            # Could use the zip&#39;s mtime for all template mtimes, but</span>
<span class="gi">+            # would need to safely reload the module if it&#39;s out of</span>
<span class="gi">+            # date, so just report it as always current.</span>
<span class="gi">+            up_to_date = None</span>
<span class="gi">+</span>
<span class="gi">+        return source.decode(self.encoding), p, up_to_date</span>
<span class="gi">+</span>
<span class="gi">+    def list_templates(self) -&gt; t.List[str]:</span>
<span class="gi">+        results: t.List[str] = []</span>
<span class="gi">+</span>
<span class="gi">+        if self._archive is None:</span>
<span class="gi">+            # Package is a directory.</span>
<span class="gi">+            offset = len(self._template_root)</span>
<span class="gi">+</span>
<span class="gi">+            for dirpath, _, filenames in os.walk(self._template_root):</span>
<span class="gi">+                dirpath = dirpath[offset:].lstrip(os.path.sep)</span>
<span class="gi">+                results.extend(</span>
<span class="gi">+                    os.path.join(dirpath, name).replace(os.path.sep, &quot;/&quot;)</span>
<span class="gi">+                    for name in filenames</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not hasattr(self._loader, &quot;_files&quot;):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &quot;This zip import does not have the required&quot;</span>
<span class="gi">+                    &quot; metadata to list templates.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # Package is a zip file.</span>
<span class="gi">+            prefix = (</span>
<span class="gi">+                self._template_root[len(self._archive) :].lstrip(os.path.sep)</span>
<span class="gi">+                + os.path.sep</span>
<span class="gi">+            )</span>
<span class="gi">+            offset = len(prefix)</span>
<span class="gi">+</span>
<span class="gi">+            for name in self._loader._files.keys():</span>
<span class="gi">+                # Find names under the templates directory that aren&#39;t directories.</span>
<span class="gi">+                if name.startswith(prefix) and name[-1] != os.path.sep:</span>
<span class="gi">+                    results.append(name[offset:].replace(os.path.sep, &quot;/&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        results.sort()</span>
<span class="gi">+        return results</span>
<span class="gi">+</span>

<span class="w"> </span>class DictLoader(BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;Loads a template from a Python dict mapping template names to
<span class="gu">@@ -214,9 +413,20 @@ class DictLoader(BaseLoader):</span>
<span class="w"> </span>    Because auto reloading is rarely useful this is disabled per default.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, mapping: t.Mapping[str, str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, mapping: t.Mapping[str, str]) -&gt; None:</span>
<span class="w"> </span>        self.mapping = mapping

<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: &quot;Environment&quot;, template: str</span>
<span class="gi">+    ) -&gt; t.Tuple[str, None, t.Callable[[], bool]]:</span>
<span class="gi">+        if template in self.mapping:</span>
<span class="gi">+            source = self.mapping[template]</span>
<span class="gi">+            return source, None, lambda: source == self.mapping.get(template)</span>
<span class="gi">+        raise TemplateNotFound(template)</span>
<span class="gi">+</span>
<span class="gi">+    def list_templates(self) -&gt; t.List[str]:</span>
<span class="gi">+        return sorted(self.mapping)</span>
<span class="gi">+</span>

<span class="w"> </span>class FunctionLoader(BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;A loader that is passed a function which does the loading.  The
<span class="gu">@@ -236,11 +446,32 @@ class FunctionLoader(BaseLoader):</span>
<span class="w"> </span>    return value.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, load_func: t.Callable[[str], t.Optional[t.Union[str,</span>
<span class="gd">-        t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]]]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        load_func: t.Callable[</span>
<span class="gi">+            [str],</span>
<span class="gi">+            t.Optional[</span>
<span class="gi">+                t.Union[</span>
<span class="gi">+                    str, t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]</span>
<span class="gi">+                ]</span>
<span class="gi">+            ],</span>
<span class="gi">+        ],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.load_func = load_func

<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: &quot;Environment&quot;, template: str</span>
<span class="gi">+    ) -&gt; t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:</span>
<span class="gi">+        rv = self.load_func(template)</span>
<span class="gi">+</span>
<span class="gi">+        if rv is None:</span>
<span class="gi">+            raise TemplateNotFound(template)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(rv, str):</span>
<span class="gi">+            return rv, None, None</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>

<span class="w"> </span>class PrefixLoader(BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;A loader that is passed a dict of loaders where each loader is bound
<span class="gu">@@ -257,11 +488,53 @@ class PrefixLoader(BaseLoader):</span>
<span class="w"> </span>    by loading ``&#39;app2/index.html&#39;`` the file from the second.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, mapping: t.Mapping[str, BaseLoader], delimiter: str=&#39;/&#39;</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, mapping: t.Mapping[str, BaseLoader], delimiter: str = &quot;/&quot;</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.mapping = mapping
<span class="w"> </span>        self.delimiter = delimiter

<span class="gi">+    def get_loader(self, template: str) -&gt; t.Tuple[BaseLoader, str]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            prefix, name = template.split(self.delimiter, 1)</span>
<span class="gi">+            loader = self.mapping[prefix]</span>
<span class="gi">+        except (ValueError, KeyError) as e:</span>
<span class="gi">+            raise TemplateNotFound(template) from e</span>
<span class="gi">+        return loader, name</span>
<span class="gi">+</span>
<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: &quot;Environment&quot;, template: str</span>
<span class="gi">+    ) -&gt; t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:</span>
<span class="gi">+        loader, name = self.get_loader(template)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return loader.get_source(environment, name)</span>
<span class="gi">+        except TemplateNotFound as e:</span>
<span class="gi">+            # re-raise the exception with the correct filename here.</span>
<span class="gi">+            # (the one that includes the prefix)</span>
<span class="gi">+            raise TemplateNotFound(template) from e</span>
<span class="gi">+</span>
<span class="gi">+    @internalcode</span>
<span class="gi">+    def load(</span>
<span class="gi">+        self,</span>
<span class="gi">+        environment: &quot;Environment&quot;,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="gi">+        loader, local_name = self.get_loader(name)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return loader.load(environment, local_name, globals)</span>
<span class="gi">+        except TemplateNotFound as e:</span>
<span class="gi">+            # re-raise the exception with the correct filename here.</span>
<span class="gi">+            # (the one that includes the prefix)</span>
<span class="gi">+            raise TemplateNotFound(name) from e</span>
<span class="gi">+</span>
<span class="gi">+    def list_templates(self) -&gt; t.List[str]:</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for prefix, loader in self.mapping.items():</span>
<span class="gi">+            for template in loader.list_templates():</span>
<span class="gi">+                result.append(prefix + self.delimiter + template)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>

<span class="w"> </span>class ChoiceLoader(BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;This loader works like the `PrefixLoader` just that no prefix is
<span class="gu">@@ -277,9 +550,39 @@ class ChoiceLoader(BaseLoader):</span>
<span class="w"> </span>    from a different location.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, loaders: t.Sequence[BaseLoader]) -&gt;None:</span>
<span class="gi">+    def __init__(self, loaders: t.Sequence[BaseLoader]) -&gt; None:</span>
<span class="w"> </span>        self.loaders = loaders

<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: &quot;Environment&quot;, template: str</span>
<span class="gi">+    ) -&gt; t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:</span>
<span class="gi">+        for loader in self.loaders:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return loader.get_source(environment, template)</span>
<span class="gi">+            except TemplateNotFound:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise TemplateNotFound(template)</span>
<span class="gi">+</span>
<span class="gi">+    @internalcode</span>
<span class="gi">+    def load(</span>
<span class="gi">+        self,</span>
<span class="gi">+        environment: &quot;Environment&quot;,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="gi">+        for loader in self.loaders:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return loader.load(environment, name, globals)</span>
<span class="gi">+            except TemplateNotFound:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise TemplateNotFound(name)</span>
<span class="gi">+</span>
<span class="gi">+    def list_templates(self) -&gt; t.List[str]:</span>
<span class="gi">+        found = set()</span>
<span class="gi">+        for loader in self.loaders:</span>
<span class="gi">+            found.update(loader.list_templates())</span>
<span class="gi">+        return sorted(found)</span>
<span class="gi">+</span>

<span class="w"> </span>class _TemplateModule(ModuleType):
<span class="w"> </span>    &quot;&quot;&quot;Like a normal module but with support for weak references&quot;&quot;&quot;
<span class="gu">@@ -297,16 +600,68 @@ class ModuleLoader(BaseLoader):</span>

<span class="w"> </span>    Templates can be precompiled with :meth:`Environment.compile_templates`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_source_access = False

<span class="gd">-    def __init__(self, path: t.Union[str, &#39;os.PathLike[str]&#39;, t.Sequence[t.</span>
<span class="gd">-        Union[str, &#39;os.PathLike[str]&#39;]]]) -&gt;None:</span>
<span class="gd">-        package_name = f&#39;_jinja2_module_templates_{id(self):x}&#39;</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path: t.Union[</span>
<span class="gi">+            str, &quot;os.PathLike[str]&quot;, t.Sequence[t.Union[str, &quot;os.PathLike[str]&quot;]]</span>
<span class="gi">+        ],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        package_name = f&quot;_jinja2_module_templates_{id(self):x}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # create a fake module that looks for the templates in the</span>
<span class="gi">+        # path given.</span>
<span class="w"> </span>        mod = _TemplateModule(package_name)
<span class="gi">+</span>
<span class="w"> </span>        if not isinstance(path, abc.Iterable) or isinstance(path, str):
<span class="w"> </span>            path = [path]
<span class="gi">+</span>
<span class="w"> </span>        mod.__path__ = [os.fspath(p) for p in path]
<span class="gd">-        sys.modules[package_name] = weakref.proxy(mod, lambda x: sys.</span>
<span class="gd">-            modules.pop(package_name, None))</span>
<span class="gi">+</span>
<span class="gi">+        sys.modules[package_name] = weakref.proxy(</span>
<span class="gi">+            mod, lambda x: sys.modules.pop(package_name, None)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # the only strong reference, the sys.modules entry is weak</span>
<span class="gi">+        # so that the garbage collector can remove it once the</span>
<span class="gi">+        # loader that created it goes out of business.</span>
<span class="w"> </span>        self.module = mod
<span class="w"> </span>        self.package_name = package_name
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def get_template_key(name: str) -&gt; str:</span>
<span class="gi">+        return &quot;tmpl_&quot; + sha1(name.encode(&quot;utf-8&quot;)).hexdigest()</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def get_module_filename(name: str) -&gt; str:</span>
<span class="gi">+        return ModuleLoader.get_template_key(name) + &quot;.py&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @internalcode</span>
<span class="gi">+    def load(</span>
<span class="gi">+        self,</span>
<span class="gi">+        environment: &quot;Environment&quot;,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    ) -&gt; &quot;Template&quot;:</span>
<span class="gi">+        key = self.get_template_key(name)</span>
<span class="gi">+        module = f&quot;{self.package_name}.{key}&quot;</span>
<span class="gi">+        mod = getattr(self.module, module, None)</span>
<span class="gi">+</span>
<span class="gi">+        if mod is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                mod = __import__(module, None, None, [&quot;root&quot;])</span>
<span class="gi">+            except ImportError as e:</span>
<span class="gi">+                raise TemplateNotFound(name) from e</span>
<span class="gi">+</span>
<span class="gi">+            # remove the entry from sys.modules, we only want the attribute</span>
<span class="gi">+            # on the module object we have stored on the loader.</span>
<span class="gi">+            sys.modules.pop(module, None)</span>
<span class="gi">+</span>
<span class="gi">+        if globals is None:</span>
<span class="gi">+            globals = {}</span>
<span class="gi">+</span>
<span class="gi">+        return environment.template_class.from_module_dict(</span>
<span class="gi">+            environment, mod.__dict__, globals</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/src/jinja2/meta.py b/src/jinja2/meta.py</span>
<span class="gh">index 37016c7..298499e 100644</span>
<span class="gd">--- a/src/jinja2/meta.py</span>
<span class="gi">+++ b/src/jinja2/meta.py</span>
<span class="gu">@@ -1,10 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions that expose information about templates that might be
<span class="w"> </span>interesting for introspection.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from . import nodes
<span class="w"> </span>from .compiler import CodeGenerator
<span class="w"> </span>from .compiler import Frame
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from .environment import Environment

<span class="gu">@@ -12,20 +15,23 @@ if t.TYPE_CHECKING:</span>
<span class="w"> </span>class TrackingCodeGenerator(CodeGenerator):
<span class="w"> </span>    &quot;&quot;&quot;We abuse the code generator for introspection.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, environment: &#39;Environment&#39;) -&gt;None:</span>
<span class="gd">-        super().__init__(environment, &#39;&lt;introspection&gt;&#39;, &#39;&lt;introspection&gt;&#39;)</span>
<span class="gi">+    def __init__(self, environment: &quot;Environment&quot;) -&gt; None:</span>
<span class="gi">+        super().__init__(environment, &quot;&lt;introspection&gt;&quot;, &quot;&lt;introspection&gt;&quot;)</span>
<span class="w"> </span>        self.undeclared_identifiers: t.Set[str] = set()

<span class="gd">-    def write(self, x: str) -&gt;None:</span>
<span class="gi">+    def write(self, x: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Don&#39;t write.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def enter_frame(self, frame: Frame) -&gt;None:</span>
<span class="gi">+    def enter_frame(self, frame: Frame) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remember all undeclared identifiers.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        super().enter_frame(frame)</span>
<span class="gi">+</span>
<span class="gi">+        for _, (action, param) in frame.symbols.loads.items():</span>
<span class="gi">+            if action == &quot;resolve&quot; and param not in self.environment.globals:</span>
<span class="gi">+                self.undeclared_identifiers.add(param)</span>


<span class="gd">-def find_undeclared_variables(ast: nodes.Template) -&gt;t.Set[str]:</span>
<span class="gi">+def find_undeclared_variables(ast: nodes.Template) -&gt; t.Set[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a set of all variables in the AST that will be looked up from
<span class="w"> </span>    the context at runtime.  Because at compile time it&#39;s not known which
<span class="w"> </span>    variables will be used depending on the path the execution takes at
<span class="gu">@@ -44,16 +50,16 @@ def find_undeclared_variables(ast: nodes.Template) -&gt;t.Set[str]:</span>
<span class="w"> </span>       :exc:`TemplateAssertionError` during compilation and as a matter of
<span class="w"> </span>       fact this function can currently raise that exception as well.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    codegen = TrackingCodeGenerator(ast.environment)  # type: ignore</span>
<span class="gi">+    codegen.visit(ast)</span>
<span class="gi">+    return codegen.undeclared_identifiers</span>


<span class="gd">-_ref_types = nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include</span>
<span class="gd">-_RefType = t.Union[nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include</span>
<span class="gd">-    ]</span>
<span class="gi">+_ref_types = (nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include)</span>
<span class="gi">+_RefType = t.Union[nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include]</span>


<span class="gd">-def find_referenced_templates(ast: nodes.Template) -&gt;t.Iterator[t.Optional[str]</span>
<span class="gd">-    ]:</span>
<span class="gi">+def find_referenced_templates(ast: nodes.Template) -&gt; t.Iterator[t.Optional[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Finds all the referenced templates from the AST.  This will return an
<span class="w"> </span>    iterator over all the hardcoded template extensions, inclusions and
<span class="w"> </span>    imports.  If dynamic inheritance or inclusion is used, `None` will be
<span class="gu">@@ -68,4 +74,39 @@ def find_referenced_templates(ast: nodes.Template) -&gt;t.Iterator[t.Optional[str]</span>
<span class="w"> </span>    This function is useful for dependency tracking.  For example if you want
<span class="w"> </span>    to rebuild parts of the website after a layout template has changed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    template_name: t.Any</span>
<span class="gi">+</span>
<span class="gi">+    for node in ast.find_all(_ref_types):</span>
<span class="gi">+        template: nodes.Expr = node.template  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(template, nodes.Const):</span>
<span class="gi">+            # a tuple with some non consts in there</span>
<span class="gi">+            if isinstance(template, (nodes.Tuple, nodes.List)):</span>
<span class="gi">+                for template_name in template.items:</span>
<span class="gi">+                    # something const, only yield the strings and ignore</span>
<span class="gi">+                    # non-string consts that really just make no sense</span>
<span class="gi">+                    if isinstance(template_name, nodes.Const):</span>
<span class="gi">+                        if isinstance(template_name.value, str):</span>
<span class="gi">+                            yield template_name.value</span>
<span class="gi">+                    # something dynamic in there</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield None</span>
<span class="gi">+            # something dynamic we don&#39;t know about here</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield None</span>
<span class="gi">+            continue</span>
<span class="gi">+        # constant is a basestring, direct template name</span>
<span class="gi">+        if isinstance(template.value, str):</span>
<span class="gi">+            yield template.value</span>
<span class="gi">+        # a tuple or list (latter *should* not happen) made of consts,</span>
<span class="gi">+        # yield the consts that are strings.  We could warn here for</span>
<span class="gi">+        # non string values</span>
<span class="gi">+        elif isinstance(node, nodes.Include) and isinstance(</span>
<span class="gi">+            template.value, (tuple, list)</span>
<span class="gi">+        ):</span>
<span class="gi">+            for template_name in template.value:</span>
<span class="gi">+                if isinstance(template_name, str):</span>
<span class="gi">+                    yield template_name</span>
<span class="gi">+        # something else we don&#39;t care about, we could warn here</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield None</span>
<span class="gh">diff --git a/src/jinja2/nativetypes.py b/src/jinja2/nativetypes.py</span>
<span class="gh">index 9eae726..71db8cc 100644</span>
<span class="gd">--- a/src/jinja2/nativetypes.py</span>
<span class="gi">+++ b/src/jinja2/nativetypes.py</span>
<span class="gu">@@ -4,6 +4,7 @@ from ast import parse</span>
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from itertools import islice
<span class="w"> </span>from types import GeneratorType
<span class="gi">+</span>
<span class="w"> </span>from . import nodes
<span class="w"> </span>from .compiler import CodeGenerator
<span class="w"> </span>from .compiler import Frame
<span class="gu">@@ -12,7 +13,7 @@ from .environment import Environment</span>
<span class="w"> </span>from .environment import Template


<span class="gd">-def native_concat(values: t.Iterable[t.Any]) -&gt;t.Optional[t.Any]:</span>
<span class="gi">+def native_concat(values: t.Iterable[t.Any]) -&gt; t.Optional[t.Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a native Python type from the list of compiled nodes. If
<span class="w"> </span>    the result is a single node, its value is returned. Otherwise, the
<span class="w"> </span>    nodes are concatenated as strings. If the result can be parsed with
<span class="gu">@@ -21,7 +22,29 @@ def native_concat(values: t.Iterable[t.Any]) -&gt;t.Optional[t.Any]:</span>

<span class="w"> </span>    :param values: Iterable of outputs to concatenate.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    head = list(islice(values, 2))</span>
<span class="gi">+</span>
<span class="gi">+    if not head:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if len(head) == 1:</span>
<span class="gi">+        raw = head[0]</span>
<span class="gi">+        if not isinstance(raw, str):</span>
<span class="gi">+            return raw</span>
<span class="gi">+    else:</span>
<span class="gi">+        if isinstance(values, GeneratorType):</span>
<span class="gi">+            values = chain(head, values)</span>
<span class="gi">+        raw = &quot;&quot;.join([str(v) for v in values])</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return literal_eval(</span>
<span class="gi">+            # In Python 3.10+ ast.literal_eval removes leading spaces/tabs</span>
<span class="gi">+            # from the given string. For backwards compatibility we need to</span>
<span class="gi">+            # parse the string ourselves without removing leading spaces/tabs.</span>
<span class="gi">+            parse(raw, mode=&quot;eval&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+    except (ValueError, SyntaxError, MemoryError):</span>
<span class="gi">+        return raw</span>


<span class="w"> </span>class NativeCodeGenerator(CodeGenerator):
<span class="gu">@@ -29,24 +52,79 @@ class NativeCodeGenerator(CodeGenerator):</span>
<span class="w"> </span>    ``str()`` around output nodes.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _default_finalize(value: t.Any) -&gt; t.Any:</span>
<span class="gi">+        return value</span>
<span class="gi">+</span>
<span class="gi">+    def _output_const_repr(self, group: t.Iterable[t.Any]) -&gt; str:</span>
<span class="gi">+        return repr(&quot;&quot;.join([str(v) for v in group]))</span>
<span class="gi">+</span>
<span class="gi">+    def _output_child_to_const(</span>
<span class="gi">+        self, node: nodes.Expr, frame: Frame, finalize: CodeGenerator._FinalizeInfo</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="gi">+        const = node.as_const(frame.eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        if not has_safe_repr(const):</span>
<span class="gi">+            raise nodes.Impossible()</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node, nodes.TemplateData):</span>
<span class="gi">+            return const</span>
<span class="gi">+</span>
<span class="gi">+        return finalize.const(const)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def _output_child_pre(</span>
<span class="gi">+        self, node: nodes.Expr, frame: Frame, finalize: CodeGenerator._FinalizeInfo</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if finalize.src is not None:</span>
<span class="gi">+            self.write(finalize.src)</span>
<span class="gi">+</span>
<span class="gi">+    def _output_child_post(</span>
<span class="gi">+        self, node: nodes.Expr, frame: Frame, finalize: CodeGenerator._FinalizeInfo</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if finalize.src is not None:</span>
<span class="gi">+            self.write(&quot;)&quot;)</span>
<span class="gi">+</span>

<span class="w"> </span>class NativeEnvironment(Environment):
<span class="w"> </span>    &quot;&quot;&quot;An environment that renders templates to native Python types.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    code_generator_class = NativeCodeGenerator
<span class="gd">-    concat = staticmethod(native_concat)</span>
<span class="gi">+    concat = staticmethod(native_concat)  # type: ignore</span>


<span class="w"> </span>class NativeTemplate(Template):
<span class="w"> </span>    environment_class = NativeEnvironment

<span class="gd">-    def render(self, *args: t.Any, **kwargs: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def render(self, *args: t.Any, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Render the template to produce a native Python type. If the
<span class="w"> </span>        result is a single node, its value is returned. Otherwise, the
<span class="w"> </span>        nodes are concatenated as strings. If the result can be parsed
<span class="w"> </span>        with :func:`ast.literal_eval`, the parsed value is returned.
<span class="w"> </span>        Otherwise, the string is returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ctx = self.new_context(dict(*args, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.environment_class.concat(  # type: ignore</span>
<span class="gi">+                self.root_render_func(ctx)</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return self.environment.handle_exception()</span>
<span class="gi">+</span>
<span class="gi">+    async def render_async(self, *args: t.Any, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="gi">+        if not self.environment.is_async:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &quot;The environment was not created with async mode enabled.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        ctx = self.new_context(dict(*args, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.environment_class.concat(  # type: ignore</span>
<span class="gi">+                [n async for n in self.root_render_func(ctx)]  # type: ignore</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return self.environment.handle_exception()</span>


<span class="w"> </span>NativeEnvironment.template_class = NativeTemplate
<span class="gh">diff --git a/src/jinja2/nodes.py b/src/jinja2/nodes.py</span>
<span class="gh">index 4ec1d17..2f93b90 100644</span>
<span class="gd">--- a/src/jinja2/nodes.py</span>
<span class="gi">+++ b/src/jinja2/nodes.py</span>
<span class="gu">@@ -2,25 +2,49 @@</span>
<span class="w"> </span>some node tree helper functions used by the parser and compiler in order
<span class="w"> </span>to normalize nodes.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import inspect
<span class="w"> </span>import operator
<span class="w"> </span>import typing as t
<span class="w"> </span>from collections import deque
<span class="gi">+</span>
<span class="w"> </span>from markupsafe import Markup
<span class="gi">+</span>
<span class="w"> </span>from .utils import _PassArg
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gi">+</span>
<span class="w"> </span>    from .environment import Environment
<span class="gd">-_NodeBound = t.TypeVar(&#39;_NodeBound&#39;, bound=&#39;Node&#39;)</span>
<span class="gd">-_binop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {&#39;*&#39;:</span>
<span class="gd">-    operator.mul, &#39;/&#39;: operator.truediv, &#39;//&#39;: operator.floordiv, &#39;**&#39;:</span>
<span class="gd">-    operator.pow, &#39;%&#39;: operator.mod, &#39;+&#39;: operator.add, &#39;-&#39;: operator.sub}</span>
<span class="gd">-_uaop_to_func: t.Dict[str, t.Callable[[t.Any], t.Any]] = {&#39;not&#39;: operator.</span>
<span class="gd">-    not_, &#39;+&#39;: operator.pos, &#39;-&#39;: operator.neg}</span>
<span class="gd">-_cmpop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {&#39;eq&#39;:</span>
<span class="gd">-    operator.eq, &#39;ne&#39;: operator.ne, &#39;gt&#39;: operator.gt, &#39;gteq&#39;: operator.ge,</span>
<span class="gd">-    &#39;lt&#39;: operator.lt, &#39;lteq&#39;: operator.le, &#39;in&#39;: lambda a, b: a in b,</span>
<span class="gd">-    &#39;notin&#39;: lambda a, b: a not in b}</span>
<span class="gi">+</span>
<span class="gi">+_NodeBound = t.TypeVar(&quot;_NodeBound&quot;, bound=&quot;Node&quot;)</span>
<span class="gi">+</span>
<span class="gi">+_binop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {</span>
<span class="gi">+    &quot;*&quot;: operator.mul,</span>
<span class="gi">+    &quot;/&quot;: operator.truediv,</span>
<span class="gi">+    &quot;//&quot;: operator.floordiv,</span>
<span class="gi">+    &quot;**&quot;: operator.pow,</span>
<span class="gi">+    &quot;%&quot;: operator.mod,</span>
<span class="gi">+    &quot;+&quot;: operator.add,</span>
<span class="gi">+    &quot;-&quot;: operator.sub,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+_uaop_to_func: t.Dict[str, t.Callable[[t.Any], t.Any]] = {</span>
<span class="gi">+    &quot;not&quot;: operator.not_,</span>
<span class="gi">+    &quot;+&quot;: operator.pos,</span>
<span class="gi">+    &quot;-&quot;: operator.neg,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+_cmpop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {</span>
<span class="gi">+    &quot;eq&quot;: operator.eq,</span>
<span class="gi">+    &quot;ne&quot;: operator.ne,</span>
<span class="gi">+    &quot;gt&quot;: operator.gt,</span>
<span class="gi">+    &quot;gteq&quot;: operator.ge,</span>
<span class="gi">+    &quot;lt&quot;: operator.lt,</span>
<span class="gi">+    &quot;lteq&quot;: operator.le,</span>
<span class="gi">+    &quot;in&quot;: lambda a, b: a in b,</span>
<span class="gi">+    &quot;notin&quot;: lambda a, b: a not in b,</span>
<span class="gi">+}</span>


<span class="w"> </span>class Impossible(Exception):
<span class="gu">@@ -32,15 +56,15 @@ class NodeType(type):</span>
<span class="w"> </span>    inheritance.  fields and attributes from the parent class are
<span class="w"> </span>    automatically forwarded to the child.&quot;&quot;&quot;

<span class="gd">-    def __new__(mcs, name, bases, d):</span>
<span class="gd">-        for attr in (&#39;fields&#39;, &#39;attributes&#39;):</span>
<span class="gi">+    def __new__(mcs, name, bases, d):  # type: ignore</span>
<span class="gi">+        for attr in &quot;fields&quot;, &quot;attributes&quot;:</span>
<span class="w"> </span>            storage: t.List[t.Tuple[str, ...]] = []
<span class="w"> </span>            storage.extend(getattr(bases[0] if bases else object, attr, ()))
<span class="w"> </span>            storage.extend(d.get(attr, ()))
<span class="gd">-            assert len(bases) &lt;= 1, &#39;multiple inheritance not allowed&#39;</span>
<span class="gd">-            assert len(storage) == len(set(storage)), &#39;layout conflict&#39;</span>
<span class="gi">+            assert len(bases) &lt;= 1, &quot;multiple inheritance not allowed&quot;</span>
<span class="gi">+            assert len(storage) == len(set(storage)), &quot;layout conflict&quot;</span>
<span class="w"> </span>            d[attr] = tuple(storage)
<span class="gd">-        d.setdefault(&#39;abstract&#39;, False)</span>
<span class="gi">+        d.setdefault(&quot;abstract&quot;, False)</span>
<span class="w"> </span>        return type.__new__(mcs, name, bases, d)


<span class="gu">@@ -49,8 +73,9 @@ class EvalContext:</span>
<span class="w"> </span>    to it in extensions.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, environment: &#39;Environment&#39;, template_name: t.</span>
<span class="gd">-        Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, environment: &quot;Environment&quot;, template_name: t.Optional[str] = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.environment = environment
<span class="w"> </span>        if callable(environment.autoescape):
<span class="w"> </span>            self.autoescape = environment.autoescape(template_name)
<span class="gu">@@ -58,6 +83,24 @@ class EvalContext:</span>
<span class="w"> </span>            self.autoescape = environment.autoescape
<span class="w"> </span>        self.volatile = False

<span class="gi">+    def save(self) -&gt; t.Mapping[str, t.Any]:</span>
<span class="gi">+        return self.__dict__.copy()</span>
<span class="gi">+</span>
<span class="gi">+    def revert(self, old: t.Mapping[str, t.Any]) -&gt; None:</span>
<span class="gi">+        self.__dict__.clear()</span>
<span class="gi">+        self.__dict__.update(old)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_eval_context(node: &quot;Node&quot;, ctx: t.Optional[EvalContext]) -&gt; EvalContext:</span>
<span class="gi">+    if ctx is None:</span>
<span class="gi">+        if node.environment is None:</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &quot;if no eval context is passed, the node must have an&quot;</span>
<span class="gi">+                &quot; attached environment.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return EvalContext(node.environment)</span>
<span class="gi">+    return ctx</span>
<span class="gi">+</span>

<span class="w"> </span>class Node(metaclass=NodeType):
<span class="w"> </span>    &quot;&quot;&quot;Baseclass for all Jinja nodes.  There are a number of nodes available
<span class="gu">@@ -75,96 +118,176 @@ class Node(metaclass=NodeType):</span>
<span class="w"> </span>    The `environment` attribute is set at the end of the parsing process for
<span class="w"> </span>    all nodes automatically.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    fields: t.Tuple[str, ...] = ()
<span class="gd">-    attributes: t.Tuple[str, ...] = (&#39;lineno&#39;, &#39;environment&#39;)</span>
<span class="gi">+    attributes: t.Tuple[str, ...] = (&quot;lineno&quot;, &quot;environment&quot;)</span>
<span class="w"> </span>    abstract = True
<span class="gi">+</span>
<span class="w"> </span>    lineno: int
<span class="gd">-    environment: t.Optional[&#39;Environment&#39;]</span>
<span class="gi">+    environment: t.Optional[&quot;Environment&quot;]</span>

<span class="gd">-    def __init__(self, *fields: t.Any, **attributes: t.Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *fields: t.Any, **attributes: t.Any) -&gt; None:</span>
<span class="w"> </span>        if self.abstract:
<span class="gd">-            raise TypeError(&#39;abstract nodes are not instantiable&#39;)</span>
<span class="gi">+            raise TypeError(&quot;abstract nodes are not instantiable&quot;)</span>
<span class="w"> </span>        if fields:
<span class="w"> </span>            if len(fields) != len(self.fields):
<span class="w"> </span>                if not self.fields:
<span class="gd">-                    raise TypeError(</span>
<span class="gd">-                        f&#39;{type(self).__name__!r} takes 0 arguments&#39;)</span>
<span class="gi">+                    raise TypeError(f&quot;{type(self).__name__!r} takes 0 arguments&quot;)</span>
<span class="w"> </span>                raise TypeError(
<span class="gd">-                    f&quot;{type(self).__name__!r} takes 0 or {len(self.fields)} argument{&#39;s&#39; if len(self.fields) != 1 else &#39;&#39;}&quot;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    f&quot;{type(self).__name__!r} takes 0 or {len(self.fields)}&quot;</span>
<span class="gi">+                    f&quot; argument{&#39;s&#39; if len(self.fields) != 1 else &#39;&#39;}&quot;</span>
<span class="gi">+                )</span>
<span class="w"> </span>            for name, arg in zip(self.fields, fields):
<span class="w"> </span>                setattr(self, name, arg)
<span class="w"> </span>        for attr in self.attributes:
<span class="w"> </span>            setattr(self, attr, attributes.pop(attr, None))
<span class="w"> </span>        if attributes:
<span class="gd">-            raise TypeError(f&#39;unknown attribute {next(iter(attributes))!r}&#39;)</span>
<span class="gi">+            raise TypeError(f&quot;unknown attribute {next(iter(attributes))!r}&quot;)</span>

<span class="gd">-    def iter_fields(self, exclude: t.Optional[t.Container[str]]=None, only:</span>
<span class="gd">-        t.Optional[t.Container[str]]=None) -&gt;t.Iterator[t.Tuple[str, t.Any]]:</span>
<span class="gi">+    def iter_fields(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exclude: t.Optional[t.Container[str]] = None,</span>
<span class="gi">+        only: t.Optional[t.Container[str]] = None,</span>
<span class="gi">+    ) -&gt; t.Iterator[t.Tuple[str, t.Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method iterates over all fields that are defined and yields
<span class="w"> </span>        ``(key, value)`` tuples.  Per default all fields are returned, but
<span class="w"> </span>        it&#39;s possible to limit that to some fields by providing the `only`
<span class="w"> </span>        parameter or to exclude some using the `exclude` parameter.  Both
<span class="w"> </span>        should be sets or tuples of field names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def iter_child_nodes(self, exclude: t.Optional[t.Container[str]]=None,</span>
<span class="gd">-        only: t.Optional[t.Container[str]]=None) -&gt;t.Iterator[&#39;Node&#39;]:</span>
<span class="gi">+        for name in self.fields:</span>
<span class="gi">+            if (</span>
<span class="gi">+                (exclude is None and only is None)</span>
<span class="gi">+                or (exclude is not None and name not in exclude)</span>
<span class="gi">+                or (only is not None and name in only)</span>
<span class="gi">+            ):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    yield name, getattr(self, name)</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+    def iter_child_nodes(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exclude: t.Optional[t.Container[str]] = None,</span>
<span class="gi">+        only: t.Optional[t.Container[str]] = None,</span>
<span class="gi">+    ) -&gt; t.Iterator[&quot;Node&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterates over all direct child nodes of the node.  This iterates
<span class="w"> </span>        over all fields and yields the values of they are nodes.  If the value
<span class="w"> </span>        of a field is a list all the nodes in that list are returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def find(self, node_type: t.Type[_NodeBound]) -&gt;t.Optional[_NodeBound]:</span>
<span class="gi">+        for _, item in self.iter_fields(exclude, only):</span>
<span class="gi">+            if isinstance(item, list):</span>
<span class="gi">+                for n in item:</span>
<span class="gi">+                    if isinstance(n, Node):</span>
<span class="gi">+                        yield n</span>
<span class="gi">+            elif isinstance(item, Node):</span>
<span class="gi">+                yield item</span>
<span class="gi">+</span>
<span class="gi">+    def find(self, node_type: t.Type[_NodeBound]) -&gt; t.Optional[_NodeBound]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find the first node of a given type.  If no such node exists the
<span class="w"> </span>        return value is `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for result in self.find_all(node_type):</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="gd">-    def find_all(self, node_type: t.Union[t.Type[_NodeBound], t.Tuple[t.</span>
<span class="gd">-        Type[_NodeBound], ...]]) -&gt;t.Iterator[_NodeBound]:</span>
<span class="gi">+    def find_all(</span>
<span class="gi">+        self, node_type: t.Union[t.Type[_NodeBound], t.Tuple[t.Type[_NodeBound], ...]]</span>
<span class="gi">+    ) -&gt; t.Iterator[_NodeBound]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find all the nodes of a given type.  If the type is a tuple,
<span class="w"> </span>        the check is performed for any of the tuple items.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child in self.iter_child_nodes():</span>
<span class="gi">+            if isinstance(child, node_type):</span>
<span class="gi">+                yield child  # type: ignore</span>
<span class="gi">+            yield from child.find_all(node_type)</span>

<span class="gd">-    def set_ctx(self, ctx: str) -&gt;&#39;Node&#39;:</span>
<span class="gi">+    def set_ctx(self, ctx: str) -&gt; &quot;Node&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the context of a node and all child nodes.  Per default the
<span class="w"> </span>        parser will all generate nodes that have a &#39;load&#39; context as it&#39;s the
<span class="w"> </span>        most common one.  This method is used in the parser to set assignment
<span class="w"> </span>        targets and other nodes to a store context.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_lineno(self, lineno: int, override: bool=False) -&gt;&#39;Node&#39;:</span>
<span class="gi">+        todo = deque([self])</span>
<span class="gi">+        while todo:</span>
<span class="gi">+            node = todo.popleft()</span>
<span class="gi">+            if &quot;ctx&quot; in node.fields:</span>
<span class="gi">+                node.ctx = ctx  # type: ignore</span>
<span class="gi">+            todo.extend(node.iter_child_nodes())</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def set_lineno(self, lineno: int, override: bool = False) -&gt; &quot;Node&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the line numbers of the node and children.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_environment(self, environment: &#39;Environment&#39;) -&gt;&#39;Node&#39;:</span>
<span class="gi">+        todo = deque([self])</span>
<span class="gi">+        while todo:</span>
<span class="gi">+            node = todo.popleft()</span>
<span class="gi">+            if &quot;lineno&quot; in node.attributes:</span>
<span class="gi">+                if node.lineno is None or override:</span>
<span class="gi">+                    node.lineno = lineno</span>
<span class="gi">+            todo.extend(node.iter_child_nodes())</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def set_environment(self, environment: &quot;Environment&quot;) -&gt; &quot;Node&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the environment for all nodes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __eq__(self, other: t.Any) -&gt;bool:</span>
<span class="gi">+        todo = deque([self])</span>
<span class="gi">+        while todo:</span>
<span class="gi">+            node = todo.popleft()</span>
<span class="gi">+            node.environment = environment</span>
<span class="gi">+            todo.extend(node.iter_child_nodes())</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def __eq__(self, other: t.Any) -&gt; bool:</span>
<span class="w"> </span>        if type(self) is not type(other):
<span class="w"> </span>            return NotImplemented
<span class="gi">+</span>
<span class="w"> </span>        return tuple(self.iter_fields()) == tuple(other.iter_fields())
<span class="gi">+</span>
<span class="w"> </span>    __hash__ = object.__hash__

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        args_str = &#39;, &#39;.join(f&#39;{a}={getattr(self, a, None)!r}&#39; for a in</span>
<span class="gd">-            self.fields)</span>
<span class="gd">-        return f&#39;{type(self).__name__}({args_str})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        args_str = &quot;, &quot;.join(f&quot;{a}={getattr(self, a, None)!r}&quot; for a in self.fields)</span>
<span class="gi">+        return f&quot;{type(self).__name__}({args_str})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def dump(self) -&gt; str:</span>
<span class="gi">+        def _dump(node: t.Union[Node, t.Any]) -&gt; None:</span>
<span class="gi">+            if not isinstance(node, Node):</span>
<span class="gi">+                buf.append(repr(node))</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            buf.append(f&quot;nodes.{type(node).__name__}(&quot;)</span>
<span class="gi">+            if not node.fields:</span>
<span class="gi">+                buf.append(&quot;)&quot;)</span>
<span class="gi">+                return</span>
<span class="gi">+            for idx, field in enumerate(node.fields):</span>
<span class="gi">+                if idx:</span>
<span class="gi">+                    buf.append(&quot;, &quot;)</span>
<span class="gi">+                value = getattr(node, field)</span>
<span class="gi">+                if isinstance(value, list):</span>
<span class="gi">+                    buf.append(&quot;[&quot;)</span>
<span class="gi">+                    for idx, item in enumerate(value):</span>
<span class="gi">+                        if idx:</span>
<span class="gi">+                            buf.append(&quot;, &quot;)</span>
<span class="gi">+                        _dump(item)</span>
<span class="gi">+                    buf.append(&quot;]&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    _dump(value)</span>
<span class="gi">+            buf.append(&quot;)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        buf: t.List[str] = []</span>
<span class="gi">+        _dump(self)</span>
<span class="gi">+        return &quot;&quot;.join(buf)</span>


<span class="w"> </span>class Stmt(Node):
<span class="w"> </span>    &quot;&quot;&quot;Base node for all statements.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    abstract = True


<span class="w"> </span>class Helper(Node):
<span class="w"> </span>    &quot;&quot;&quot;Nodes that exist in a specific context only.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    abstract = True


<span class="gu">@@ -172,7 +295,8 @@ class Template(Node):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node that represents a template.  This must be the outermost node that
<span class="w"> </span>    is passed to the compiler.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;body&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;body&quot;,)</span>
<span class="w"> </span>    body: t.List[Node]


<span class="gu">@@ -180,14 +304,16 @@ class Output(Stmt):</span>
<span class="w"> </span>    &quot;&quot;&quot;A node that holds multiple expressions which are then printed out.
<span class="w"> </span>    This is used both for the `print` statement and the regular template data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;nodes&#39;,</span>
<span class="gd">-    nodes: t.List[&#39;Expr&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;nodes&quot;,)</span>
<span class="gi">+    nodes: t.List[&quot;Expr&quot;]</span>


<span class="w"> </span>class Extends(Stmt):
<span class="w"> </span>    &quot;&quot;&quot;Represents an extends statement.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;template&#39;,</span>
<span class="gd">-    template: &#39;Expr&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;template&quot;,)</span>
<span class="gi">+    template: &quot;Expr&quot;</span>


<span class="w"> </span>class For(Stmt):
<span class="gu">@@ -198,7 +324,8 @@ class For(Stmt):</span>

<span class="w"> </span>    For filtered nodes an expression can be stored as `test`, otherwise `None`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;target&#39;, &#39;iter&#39;, &#39;body&#39;, &#39;else_&#39;, &#39;test&#39;, &#39;recursive&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;target&quot;, &quot;iter&quot;, &quot;body&quot;, &quot;else_&quot;, &quot;test&quot;, &quot;recursive&quot;)</span>
<span class="w"> </span>    target: Node
<span class="w"> </span>    iter: Node
<span class="w"> </span>    body: t.List[Node]
<span class="gu">@@ -209,10 +336,11 @@ class For(Stmt):</span>

<span class="w"> </span>class If(Stmt):
<span class="w"> </span>    &quot;&quot;&quot;If `test` is true, `body` is rendered, else `else_`.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;test&#39;, &#39;body&#39;, &#39;elif_&#39;, &#39;else_&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;test&quot;, &quot;body&quot;, &quot;elif_&quot;, &quot;else_&quot;)</span>
<span class="w"> </span>    test: Node
<span class="w"> </span>    body: t.List[Node]
<span class="gd">-    elif_: t.List[&#39;If&#39;]</span>
<span class="gi">+    elif_: t.List[&quot;If&quot;]</span>
<span class="w"> </span>    else_: t.List[Node]


<span class="gu">@@ -221,10 +349,11 @@ class Macro(Stmt):</span>
<span class="w"> </span>    arguments and `defaults` a list of defaults if there are any.  `body` is
<span class="w"> </span>    a list of nodes for the macro body.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;name&#39;, &#39;args&#39;, &#39;defaults&#39;, &#39;body&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;name&quot;, &quot;args&quot;, &quot;defaults&quot;, &quot;body&quot;)</span>
<span class="w"> </span>    name: str
<span class="gd">-    args: t.List[&#39;Name&#39;]</span>
<span class="gd">-    defaults: t.List[&#39;Expr&#39;]</span>
<span class="gi">+    args: t.List[&quot;Name&quot;]</span>
<span class="gi">+    defaults: t.List[&quot;Expr&quot;]</span>
<span class="w"> </span>    body: t.List[Node]


<span class="gu">@@ -232,18 +361,20 @@ class CallBlock(Stmt):</span>
<span class="w"> </span>    &quot;&quot;&quot;Like a macro without a name but a call instead.  `call` is called with
<span class="w"> </span>    the unnamed macro as `caller` argument this node holds.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;call&#39;, &#39;args&#39;, &#39;defaults&#39;, &#39;body&#39;</span>
<span class="gd">-    call: &#39;Call&#39;</span>
<span class="gd">-    args: t.List[&#39;Name&#39;]</span>
<span class="gd">-    defaults: t.List[&#39;Expr&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;call&quot;, &quot;args&quot;, &quot;defaults&quot;, &quot;body&quot;)</span>
<span class="gi">+    call: &quot;Call&quot;</span>
<span class="gi">+    args: t.List[&quot;Name&quot;]</span>
<span class="gi">+    defaults: t.List[&quot;Expr&quot;]</span>
<span class="w"> </span>    body: t.List[Node]


<span class="w"> </span>class FilterBlock(Stmt):
<span class="w"> </span>    &quot;&quot;&quot;Node for filter sections.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;body&#39;, &#39;filter&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;body&quot;, &quot;filter&quot;)</span>
<span class="w"> </span>    body: t.List[Node]
<span class="gd">-    filter: &#39;Filter&#39;</span>
<span class="gi">+    filter: &quot;Filter&quot;</span>


<span class="w"> </span>class With(Stmt):
<span class="gu">@@ -252,9 +383,10 @@ class With(Stmt):</span>

<span class="w"> </span>    .. versionadded:: 2.9.3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;targets&#39;, &#39;values&#39;, &#39;body&#39;</span>
<span class="gd">-    targets: t.List[&#39;Expr&#39;]</span>
<span class="gd">-    values: t.List[&#39;Expr&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;targets&quot;, &quot;values&quot;, &quot;body&quot;)</span>
<span class="gi">+    targets: t.List[&quot;Expr&quot;]</span>
<span class="gi">+    values: t.List[&quot;Expr&quot;]</span>
<span class="w"> </span>    body: t.List[Node]


<span class="gu">@@ -264,7 +396,8 @@ class Block(Stmt):</span>
<span class="w"> </span>    .. versionchanged:: 3.0.0
<span class="w"> </span>        the `required` field was added.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;name&#39;, &#39;body&#39;, &#39;scoped&#39;, &#39;required&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;name&quot;, &quot;body&quot;, &quot;scoped&quot;, &quot;required&quot;)</span>
<span class="w"> </span>    name: str
<span class="w"> </span>    body: t.List[Node]
<span class="w"> </span>    scoped: bool
<span class="gu">@@ -273,16 +406,18 @@ class Block(Stmt):</span>

<span class="w"> </span>class Include(Stmt):
<span class="w"> </span>    &quot;&quot;&quot;A node that represents the include tag.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;template&#39;, &#39;with_context&#39;, &#39;ignore_missing&#39;</span>
<span class="gd">-    template: &#39;Expr&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;template&quot;, &quot;with_context&quot;, &quot;ignore_missing&quot;)</span>
<span class="gi">+    template: &quot;Expr&quot;</span>
<span class="w"> </span>    with_context: bool
<span class="w"> </span>    ignore_missing: bool


<span class="w"> </span>class Import(Stmt):
<span class="w"> </span>    &quot;&quot;&quot;A node that represents the import tag.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;template&#39;, &#39;target&#39;, &#39;with_context&#39;</span>
<span class="gd">-    template: &#39;Expr&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;template&quot;, &quot;target&quot;, &quot;with_context&quot;)</span>
<span class="gi">+    template: &quot;Expr&quot;</span>
<span class="w"> </span>    target: str
<span class="w"> </span>    with_context: bool

<span class="gu">@@ -298,38 +433,43 @@ class FromImport(Stmt):</span>

<span class="w"> </span>    The list of names may contain tuples if aliases are wanted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;template&#39;, &#39;names&#39;, &#39;with_context&#39;</span>
<span class="gd">-    template: &#39;Expr&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;template&quot;, &quot;names&quot;, &quot;with_context&quot;)</span>
<span class="gi">+    template: &quot;Expr&quot;</span>
<span class="w"> </span>    names: t.List[t.Union[str, t.Tuple[str, str]]]
<span class="w"> </span>    with_context: bool


<span class="w"> </span>class ExprStmt(Stmt):
<span class="w"> </span>    &quot;&quot;&quot;A statement that evaluates an expression and discards the result.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;node&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;node&quot;,)</span>
<span class="w"> </span>    node: Node


<span class="w"> </span>class Assign(Stmt):
<span class="w"> </span>    &quot;&quot;&quot;Assigns an expression to a target.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;target&#39;, &#39;node&#39;</span>
<span class="gd">-    target: &#39;Expr&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;target&quot;, &quot;node&quot;)</span>
<span class="gi">+    target: &quot;Expr&quot;</span>
<span class="w"> </span>    node: Node


<span class="w"> </span>class AssignBlock(Stmt):
<span class="w"> </span>    &quot;&quot;&quot;Assigns a block to a target.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;target&#39;, &#39;filter&#39;, &#39;body&#39;</span>
<span class="gd">-    target: &#39;Expr&#39;</span>
<span class="gd">-    filter: t.Optional[&#39;Filter&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;target&quot;, &quot;filter&quot;, &quot;body&quot;)</span>
<span class="gi">+    target: &quot;Expr&quot;</span>
<span class="gi">+    filter: t.Optional[&quot;Filter&quot;]</span>
<span class="w"> </span>    body: t.List[Node]


<span class="w"> </span>class Expr(Node):
<span class="w"> </span>    &quot;&quot;&quot;Baseclass for all expressions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    abstract = True

<span class="gd">-    def as_const(self, eval_ctx: t.Optional[EvalContext]=None) -&gt;t.Any:</span>
<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the value of the expression as constant or raise
<span class="w"> </span>        :exc:`Impossible` if this was not possible.

<span class="gu">@@ -340,29 +480,61 @@ class Expr(Node):</span>
<span class="w"> </span>        .. versionchanged:: 2.4
<span class="w"> </span>           the `eval_ctx` parameter was added.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise Impossible()</span>

<span class="gd">-    def can_assign(self) -&gt;bool:</span>
<span class="gi">+    def can_assign(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if it&#39;s possible to assign something to this node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>


<span class="w"> </span>class BinExpr(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Baseclass for all binary expressions.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;left&#39;, &#39;right&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;left&quot;, &quot;right&quot;)</span>
<span class="w"> </span>    left: Expr
<span class="w"> </span>    right: Expr
<span class="w"> </span>    operator: str
<span class="w"> </span>    abstract = True

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        # intercepted operators cannot be folded at compile time</span>
<span class="gi">+        if (</span>
<span class="gi">+            eval_ctx.environment.sandboxed</span>
<span class="gi">+            and self.operator in eval_ctx.environment.intercepted_binops  # type: ignore</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+        f = _binop_to_func[self.operator]</span>
<span class="gi">+        try:</span>
<span class="gi">+            return f(self.left.as_const(eval_ctx), self.right.as_const(eval_ctx))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise Impossible() from e</span>
<span class="gi">+</span>

<span class="w"> </span>class UnaryExpr(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Baseclass for all unary expressions.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;node&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;node&quot;,)</span>
<span class="w"> </span>    node: Expr
<span class="w"> </span>    operator: str
<span class="w"> </span>    abstract = True

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        # intercepted operators cannot be folded at compile time</span>
<span class="gi">+        if (</span>
<span class="gi">+            eval_ctx.environment.sandboxed</span>
<span class="gi">+            and self.operator in eval_ctx.environment.intercepted_unops  # type: ignore</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+        f = _uaop_to_func[self.operator]</span>
<span class="gi">+        try:</span>
<span class="gi">+            return f(self.node.as_const(eval_ctx))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise Impossible() from e</span>
<span class="gi">+</span>

<span class="w"> </span>class Name(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Looks up a name or stores a value in a name.
<span class="gu">@@ -372,20 +544,33 @@ class Name(Expr):</span>
<span class="w"> </span>    -   `load`: load that name
<span class="w"> </span>    -   `param`: like `store` but if the name was defined as function parameter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;name&#39;, &#39;ctx&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;name&quot;, &quot;ctx&quot;)</span>
<span class="w"> </span>    name: str
<span class="w"> </span>    ctx: str

<span class="gi">+    def can_assign(self) -&gt; bool:</span>
<span class="gi">+        return self.name not in {&quot;true&quot;, &quot;false&quot;, &quot;none&quot;, &quot;True&quot;, &quot;False&quot;, &quot;None&quot;}</span>
<span class="gi">+</span>

<span class="w"> </span>class NSRef(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Reference to a namespace value assignment&quot;&quot;&quot;
<span class="gd">-    fields = &#39;name&#39;, &#39;attr&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;name&quot;, &quot;attr&quot;)</span>
<span class="w"> </span>    name: str
<span class="w"> </span>    attr: str

<span class="gi">+    def can_assign(self) -&gt; bool:</span>
<span class="gi">+        # We don&#39;t need any special checks here; NSRef assignments have a</span>
<span class="gi">+        # runtime check to ensure the target is a namespace object which will</span>
<span class="gi">+        # have been checked already as it is created using a normal assignment</span>
<span class="gi">+        # which goes through a `Name` node.</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class Literal(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Baseclass for literals.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    abstract = True


<span class="gu">@@ -395,75 +580,164 @@ class Const(Literal):</span>
<span class="w"> </span>    complex values such as lists too.  Only constants with a safe
<span class="w"> </span>    representation (objects where ``eval(repr(x)) == x`` is true).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;value&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;value&quot;,)</span>
<span class="w"> </span>    value: t.Any

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        return self.value</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def from_untrusted(cls, value: t.Any, lineno: t.Optional[int]=None,</span>
<span class="gd">-        environment: &#39;t.Optional[Environment]&#39;=None) -&gt;&#39;Const&#39;:</span>
<span class="gi">+    def from_untrusted(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        value: t.Any,</span>
<span class="gi">+        lineno: t.Optional[int] = None,</span>
<span class="gi">+        environment: &quot;t.Optional[Environment]&quot; = None,</span>
<span class="gi">+    ) -&gt; &quot;Const&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a const object if the value is representable as
<span class="w"> </span>        constant value in the generated code, otherwise it will raise
<span class="w"> </span>        an `Impossible` exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from .compiler import has_safe_repr</span>
<span class="gi">+</span>
<span class="gi">+        if not has_safe_repr(value):</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+        return cls(value, lineno=lineno, environment=environment)</span>


<span class="w"> </span>class TemplateData(Literal):
<span class="w"> </span>    &quot;&quot;&quot;A constant template string.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;data&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;data&quot;,)</span>
<span class="w"> </span>    data: str

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; str:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        if eval_ctx.volatile:</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+        if eval_ctx.autoescape:</span>
<span class="gi">+            return Markup(self.data)</span>
<span class="gi">+        return self.data</span>
<span class="gi">+</span>

<span class="w"> </span>class Tuple(Literal):
<span class="w"> </span>    &quot;&quot;&quot;For loop unpacking and some other things like multiple arguments
<span class="w"> </span>    for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple
<span class="w"> </span>    is used for loading the names or storing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;items&#39;, &#39;ctx&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;items&quot;, &quot;ctx&quot;)</span>
<span class="w"> </span>    items: t.List[Expr]
<span class="w"> </span>    ctx: str

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Tuple[t.Any, ...]:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        return tuple(x.as_const(eval_ctx) for x in self.items)</span>
<span class="gi">+</span>
<span class="gi">+    def can_assign(self) -&gt; bool:</span>
<span class="gi">+        for item in self.items:</span>
<span class="gi">+            if not item.can_assign():</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class List(Literal):
<span class="w"> </span>    &quot;&quot;&quot;Any list literal such as ``[1, 2, 3]``&quot;&quot;&quot;
<span class="gd">-    fields = &#39;items&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;items&quot;,)</span>
<span class="w"> </span>    items: t.List[Expr]

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.List[t.Any]:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        return [x.as_const(eval_ctx) for x in self.items]</span>
<span class="gi">+</span>

<span class="w"> </span>class Dict(Literal):
<span class="w"> </span>    &quot;&quot;&quot;Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of
<span class="w"> </span>    :class:`Pair` nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;items&#39;,</span>
<span class="gd">-    items: t.List[&#39;Pair&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;items&quot;,)</span>
<span class="gi">+    items: t.List[&quot;Pair&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def as_const(</span>
<span class="gi">+        self, eval_ctx: t.Optional[EvalContext] = None</span>
<span class="gi">+    ) -&gt; t.Dict[t.Any, t.Any]:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        return dict(x.as_const(eval_ctx) for x in self.items)</span>


<span class="w"> </span>class Pair(Helper):
<span class="w"> </span>    &quot;&quot;&quot;A key, value pair for dicts.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;key&#39;, &#39;value&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;key&quot;, &quot;value&quot;)</span>
<span class="w"> </span>    key: Expr
<span class="w"> </span>    value: Expr

<span class="gi">+    def as_const(</span>
<span class="gi">+        self, eval_ctx: t.Optional[EvalContext] = None</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Any, t.Any]:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        return self.key.as_const(eval_ctx), self.value.as_const(eval_ctx)</span>
<span class="gi">+</span>

<span class="w"> </span>class Keyword(Helper):
<span class="w"> </span>    &quot;&quot;&quot;A key, value pair for keyword arguments where key is a string.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;key&#39;, &#39;value&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;key&quot;, &quot;value&quot;)</span>
<span class="w"> </span>    key: str
<span class="w"> </span>    value: Expr

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Tuple[str, t.Any]:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        return self.key, self.value.as_const(eval_ctx)</span>
<span class="gi">+</span>

<span class="w"> </span>class CondExpr(Expr):
<span class="w"> </span>    &quot;&quot;&quot;A conditional expression (inline if expression).  (``{{
<span class="w"> </span>    foo if bar else baz }}``)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;test&#39;, &#39;expr1&#39;, &#39;expr2&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;test&quot;, &quot;expr1&quot;, &quot;expr2&quot;)</span>
<span class="w"> </span>    test: Expr
<span class="w"> </span>    expr1: Expr
<span class="w"> </span>    expr2: t.Optional[Expr]

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        if self.test.as_const(eval_ctx):</span>
<span class="gi">+            return self.expr1.as_const(eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        # if we evaluate to an undefined object, we better do that at runtime</span>
<span class="gi">+        if self.expr2 is None:</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+</span>
<span class="gi">+        return self.expr2.as_const(eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def args_as_const(</span>
<span class="gi">+    node: t.Union[&quot;_FilterTestCommon&quot;, &quot;Call&quot;], eval_ctx: t.Optional[EvalContext]</span>
<span class="gi">+) -&gt; t.Tuple[t.List[t.Any], t.Dict[t.Any, t.Any]]:</span>
<span class="gi">+    args = [x.as_const(eval_ctx) for x in node.args]</span>
<span class="gi">+    kwargs = dict(x.as_const(eval_ctx) for x in node.kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if node.dyn_args is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            args.extend(node.dyn_args.as_const(eval_ctx))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise Impossible() from e</span>
<span class="gi">+</span>
<span class="gi">+    if node.dyn_kwargs is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            kwargs.update(node.dyn_kwargs.as_const(eval_ctx))</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise Impossible() from e</span>
<span class="gi">+</span>
<span class="gi">+    return args, kwargs</span>
<span class="gi">+</span>

<span class="w"> </span>class _FilterTestCommon(Expr):
<span class="gd">-    fields = &#39;node&#39;, &#39;name&#39;, &#39;args&#39;, &#39;kwargs&#39;, &#39;dyn_args&#39;, &#39;dyn_kwargs&#39;</span>
<span class="gi">+    fields = (&quot;node&quot;, &quot;name&quot;, &quot;args&quot;, &quot;kwargs&quot;, &quot;dyn_args&quot;, &quot;dyn_kwargs&quot;)</span>
<span class="w"> </span>    node: Expr
<span class="w"> </span>    name: str
<span class="w"> </span>    args: t.List[Expr]
<span class="gu">@@ -473,6 +747,42 @@ class _FilterTestCommon(Expr):</span>
<span class="w"> </span>    abstract = True
<span class="w"> </span>    _is_filter = True

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        if eval_ctx.volatile:</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+</span>
<span class="gi">+        if self._is_filter:</span>
<span class="gi">+            env_map = eval_ctx.environment.filters</span>
<span class="gi">+        else:</span>
<span class="gi">+            env_map = eval_ctx.environment.tests</span>
<span class="gi">+</span>
<span class="gi">+        func = env_map.get(self.name)</span>
<span class="gi">+        pass_arg = _PassArg.from_obj(func)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        if func is None or pass_arg is _PassArg.context:</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+</span>
<span class="gi">+        if eval_ctx.environment.is_async and (</span>
<span class="gi">+            getattr(func, &quot;jinja_async_variant&quot;, False) is True</span>
<span class="gi">+            or inspect.iscoroutinefunction(func)</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+</span>
<span class="gi">+        args, kwargs = args_as_const(self, eval_ctx)</span>
<span class="gi">+        args.insert(0, self.node.as_const(eval_ctx))</span>
<span class="gi">+</span>
<span class="gi">+        if pass_arg is _PassArg.eval_context:</span>
<span class="gi">+            args.insert(0, eval_ctx)</span>
<span class="gi">+        elif pass_arg is _PassArg.environment:</span>
<span class="gi">+            args.insert(0, eval_ctx.environment)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise Impossible() from e</span>
<span class="gi">+</span>

<span class="w"> </span>class Filter(_FilterTestCommon):
<span class="w"> </span>    &quot;&quot;&quot;Apply a filter to an expression. ``name`` is the name of the
<span class="gu">@@ -481,7 +791,14 @@ class Filter(_FilterTestCommon):</span>
<span class="w"> </span>    If ``node`` is ``None``, the filter is being used in a filter block
<span class="w"> </span>    and is applied to the content of the block.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    node: t.Optional[Expr]</span>
<span class="gi">+</span>
<span class="gi">+    node: t.Optional[Expr]  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        if self.node is None:</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+</span>
<span class="gi">+        return super().as_const(eval_ctx=eval_ctx)</span>


<span class="w"> </span>class Test(_FilterTestCommon):
<span class="gu">@@ -493,6 +810,7 @@ class Test(_FilterTestCommon):</span>
<span class="w"> </span>        check for volatile, async, and ``@pass_context`` etc.
<span class="w"> </span>        decorators.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _is_filter = False


<span class="gu">@@ -503,7 +821,8 @@ class Call(Expr):</span>
<span class="w"> </span>    node for dynamic positional (``*args``) or keyword (``**kwargs``)
<span class="w"> </span>    arguments.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;node&#39;, &#39;args&#39;, &#39;kwargs&#39;, &#39;dyn_args&#39;, &#39;dyn_kwargs&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;node&quot;, &quot;args&quot;, &quot;kwargs&quot;, &quot;dyn_args&quot;, &quot;dyn_kwargs&quot;)</span>
<span class="w"> </span>    node: Expr
<span class="w"> </span>    args: t.List[Expr]
<span class="w"> </span>    kwargs: t.List[Keyword]
<span class="gu">@@ -513,123 +832,209 @@ class Call(Expr):</span>

<span class="w"> </span>class Getitem(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Get an attribute or item from an expression and prefer the item.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;node&#39;, &#39;arg&#39;, &#39;ctx&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;node&quot;, &quot;arg&quot;, &quot;ctx&quot;)</span>
<span class="w"> </span>    node: Expr
<span class="w"> </span>    arg: Expr
<span class="w"> </span>    ctx: str

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        if self.ctx != &quot;load&quot;:</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return eval_ctx.environment.getitem(</span>
<span class="gi">+                self.node.as_const(eval_ctx), self.arg.as_const(eval_ctx)</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise Impossible() from e</span>
<span class="gi">+</span>

<span class="w"> </span>class Getattr(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Get an attribute or item from an expression that is a ascii-only
<span class="w"> </span>    bytestring and prefer the attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;node&#39;, &#39;attr&#39;, &#39;ctx&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;node&quot;, &quot;attr&quot;, &quot;ctx&quot;)</span>
<span class="w"> </span>    node: Expr
<span class="w"> </span>    attr: str
<span class="w"> </span>    ctx: str

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        if self.ctx != &quot;load&quot;:</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return eval_ctx.environment.getattr(self.node.as_const(eval_ctx), self.attr)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise Impossible() from e</span>
<span class="gi">+</span>

<span class="w"> </span>class Slice(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Represents a slice object.  This must only be used as argument for
<span class="w"> </span>    :class:`Subscript`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;start&#39;, &#39;stop&#39;, &#39;step&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;start&quot;, &quot;stop&quot;, &quot;step&quot;)</span>
<span class="w"> </span>    start: t.Optional[Expr]
<span class="w"> </span>    stop: t.Optional[Expr]
<span class="w"> </span>    step: t.Optional[Expr]

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; slice:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        def const(obj: t.Optional[Expr]) -&gt; t.Optional[t.Any]:</span>
<span class="gi">+            if obj is None:</span>
<span class="gi">+                return None</span>
<span class="gi">+            return obj.as_const(eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        return slice(const(self.start), const(self.stop), const(self.step))</span>
<span class="gi">+</span>

<span class="w"> </span>class Concat(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Concatenates the list of expressions provided after converting
<span class="w"> </span>    them to strings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;nodes&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;nodes&quot;,)</span>
<span class="w"> </span>    nodes: t.List[Expr]

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; str:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        return &quot;&quot;.join(str(x.as_const(eval_ctx)) for x in self.nodes)</span>
<span class="gi">+</span>

<span class="w"> </span>class Compare(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Compares an expression with some other expressions.  `ops` must be a
<span class="w"> </span>    list of :class:`Operand`\\s.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;expr&#39;, &#39;ops&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;expr&quot;, &quot;ops&quot;)</span>
<span class="w"> </span>    expr: Expr
<span class="gd">-    ops: t.List[&#39;Operand&#39;]</span>
<span class="gi">+    ops: t.List[&quot;Operand&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        result = value = self.expr.as_const(eval_ctx)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            for op in self.ops:</span>
<span class="gi">+                new_value = op.expr.as_const(eval_ctx)</span>
<span class="gi">+                result = _cmpop_to_func[op.op](value, new_value)</span>
<span class="gi">+</span>
<span class="gi">+                if not result:</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+                value = new_value</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise Impossible() from e</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class Operand(Helper):
<span class="w"> </span>    &quot;&quot;&quot;Holds an operator and an expression.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;op&#39;, &#39;expr&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;op&quot;, &quot;expr&quot;)</span>
<span class="w"> </span>    op: str
<span class="w"> </span>    expr: Expr


<span class="w"> </span>class Mul(BinExpr):
<span class="w"> </span>    &quot;&quot;&quot;Multiplies the left with the right node.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;*&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;*&quot;</span>


<span class="w"> </span>class Div(BinExpr):
<span class="w"> </span>    &quot;&quot;&quot;Divides the left by the right node.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;/&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;/&quot;</span>


<span class="w"> </span>class FloorDiv(BinExpr):
<span class="w"> </span>    &quot;&quot;&quot;Divides the left by the right node and converts the
<span class="w"> </span>    result into an integer by truncating.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    operator = &#39;//&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;//&quot;</span>


<span class="w"> </span>class Add(BinExpr):
<span class="w"> </span>    &quot;&quot;&quot;Add the left to the right node.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;+&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;+&quot;</span>


<span class="w"> </span>class Sub(BinExpr):
<span class="w"> </span>    &quot;&quot;&quot;Subtract the right from the left node.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;-&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;-&quot;</span>


<span class="w"> </span>class Mod(BinExpr):
<span class="w"> </span>    &quot;&quot;&quot;Left modulo right.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;%&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;%&quot;</span>


<span class="w"> </span>class Pow(BinExpr):
<span class="w"> </span>    &quot;&quot;&quot;Left to the power of right.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;**&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;**&quot;</span>


<span class="w"> </span>class And(BinExpr):
<span class="w"> </span>    &quot;&quot;&quot;Short circuited AND.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;and&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;and&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)</span>


<span class="w"> </span>class Or(BinExpr):
<span class="w"> </span>    &quot;&quot;&quot;Short circuited OR.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;or&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;or&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; t.Any:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        return self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)</span>


<span class="w"> </span>class Not(UnaryExpr):
<span class="w"> </span>    &quot;&quot;&quot;Negate the expression.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;not&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;not&quot;</span>


<span class="w"> </span>class Neg(UnaryExpr):
<span class="w"> </span>    &quot;&quot;&quot;Make the expression negative.&quot;&quot;&quot;
<span class="gd">-    operator = &#39;-&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;-&quot;</span>


<span class="w"> </span>class Pos(UnaryExpr):
<span class="w"> </span>    &quot;&quot;&quot;Make the expression positive (noop for most expressions)&quot;&quot;&quot;
<span class="gd">-    operator = &#39;+&#39;</span>
<span class="gi">+</span>
<span class="gi">+    operator = &quot;+&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Helpers for extensions</span>


<span class="w"> </span>class EnvironmentAttribute(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Loads an attribute from the environment object.  This is useful for
<span class="w"> </span>    extensions that want to call a callback stored on the environment.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;name&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;name&quot;,)</span>
<span class="w"> </span>    name: str


<span class="gu">@@ -640,7 +1045,8 @@ class ExtensionAttribute(Expr):</span>
<span class="w"> </span>    This node is usually constructed by calling the
<span class="w"> </span>    :meth:`~jinja2.ext.Extension.attr` method on an extension.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;identifier&#39;, &#39;name&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;identifier&quot;, &quot;name&quot;)</span>
<span class="w"> </span>    identifier: str
<span class="w"> </span>    name: str

<span class="gu">@@ -651,7 +1057,8 @@ class ImportedName(Expr):</span>
<span class="w"> </span>    function from the cgi module on evaluation.  Imports are optimized by the
<span class="w"> </span>    compiler so there is no need to assign them to local variables.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;importname&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;importname&quot;,)</span>
<span class="w"> </span>    importname: str


<span class="gu">@@ -662,20 +1069,27 @@ class InternalName(Expr):</span>
<span class="w"> </span>    a new identifier for you.  This identifier is not available from the
<span class="w"> </span>    template and is not treated specially by the compiler.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;name&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;name&quot;,)</span>
<span class="w"> </span>    name: str

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        raise TypeError(
<span class="gd">-            &quot;Can&#39;t create internal names.  Use the `free_identifier` method on a parser.&quot;</span>
<span class="gd">-            )</span>
<span class="gi">+            &quot;Can&#39;t create internal names.  Use the &quot;</span>
<span class="gi">+            &quot;`free_identifier` method on a parser.&quot;</span>
<span class="gi">+        )</span>


<span class="w"> </span>class MarkSafe(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Mark the wrapped expression as safe (wrap it as `Markup`).&quot;&quot;&quot;
<span class="gd">-    fields = &#39;expr&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;expr&quot;,)</span>
<span class="w"> </span>    expr: Expr

<span class="gi">+    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -&gt; Markup:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        return Markup(self.expr.as_const(eval_ctx))</span>
<span class="gi">+</span>

<span class="w"> </span>class MarkSafeIfAutoescape(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Mark the wrapped expression as safe (wrap it as `Markup`) but
<span class="gu">@@ -683,9 +1097,21 @@ class MarkSafeIfAutoescape(Expr):</span>

<span class="w"> </span>    .. versionadded:: 2.5
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;expr&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;expr&quot;,)</span>
<span class="w"> </span>    expr: Expr

<span class="gi">+    def as_const(</span>
<span class="gi">+        self, eval_ctx: t.Optional[EvalContext] = None</span>
<span class="gi">+    ) -&gt; t.Union[Markup, t.Any]:</span>
<span class="gi">+        eval_ctx = get_eval_context(self, eval_ctx)</span>
<span class="gi">+        if eval_ctx.volatile:</span>
<span class="gi">+            raise Impossible()</span>
<span class="gi">+        expr = self.expr.as_const(eval_ctx)</span>
<span class="gi">+        if eval_ctx.autoescape:</span>
<span class="gi">+            return Markup(expr)</span>
<span class="gi">+        return expr</span>
<span class="gi">+</span>

<span class="w"> </span>class ContextReference(Expr):
<span class="w"> </span>    &quot;&quot;&quot;Returns the current template context.  It can be used like a
<span class="gu">@@ -724,7 +1150,8 @@ class Break(Stmt):</span>

<span class="w"> </span>class Scope(Stmt):
<span class="w"> </span>    &quot;&quot;&quot;An artificial scope.&quot;&quot;&quot;
<span class="gd">-    fields = &#39;body&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;body&quot;,)</span>
<span class="w"> </span>    body: t.List[Node]


<span class="gu">@@ -741,7 +1168,8 @@ class OverlayScope(Stmt):</span>

<span class="w"> </span>    .. versionadded:: 2.10
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;context&#39;, &#39;body&#39;</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;context&quot;, &quot;body&quot;)</span>
<span class="w"> </span>    context: Expr
<span class="w"> </span>    body: t.List[Node]

<span class="gu">@@ -754,7 +1182,8 @@ class EvalContextModifier(Stmt):</span>

<span class="w"> </span>        EvalContextModifier(options=[Keyword(&#39;autoescape&#39;, Const(True))])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;options&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;options&quot;,)</span>
<span class="w"> </span>    options: t.List[Keyword]


<span class="gu">@@ -763,9 +1192,15 @@ class ScopedEvalContextModifier(EvalContextModifier):</span>
<span class="w"> </span>    :class:`EvalContextModifier` but will only modify the
<span class="w"> </span>    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    fields = &#39;body&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    fields = (&quot;body&quot;,)</span>
<span class="w"> </span>    body: t.List[Node]


<span class="gd">-NodeType.__new__ = staticmethod(_failing_new)</span>
<span class="gi">+# make sure nobody creates custom nodes</span>
<span class="gi">+def _failing_new(*args: t.Any, **kwargs: t.Any) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="gi">+    raise TypeError(&quot;can&#39;t create custom node types&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+NodeType.__new__ = staticmethod(_failing_new)  # type: ignore</span>
<span class="w"> </span>del _failing_new
<span class="gh">diff --git a/src/jinja2/optimizer.py b/src/jinja2/optimizer.py</span>
<span class="gh">index 53d50e4..32d1c71 100644</span>
<span class="gd">--- a/src/jinja2/optimizer.py</span>
<span class="gi">+++ b/src/jinja2/optimizer.py</span>
<span class="gu">@@ -7,20 +7,42 @@ want. For example, loop unrolling doesn&#39;t work because unrolled loops</span>
<span class="w"> </span>would have a different scope. The solution would be a second syntax tree
<span class="w"> </span>that stored the scoping rules.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from . import nodes
<span class="w"> </span>from .visitor import NodeTransformer
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from .environment import Environment


<span class="gd">-def optimize(node: nodes.Node, environment: &#39;Environment&#39;) -&gt;nodes.Node:</span>
<span class="gi">+def optimize(node: nodes.Node, environment: &quot;Environment&quot;) -&gt; nodes.Node:</span>
<span class="w"> </span>    &quot;&quot;&quot;The context hint can be used to perform an static optimization
<span class="w"> </span>    based on the context given.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    optimizer = Optimizer(environment)</span>
<span class="gi">+    return t.cast(nodes.Node, optimizer.visit(node))</span>


<span class="w"> </span>class Optimizer(NodeTransformer):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, environment: &#39;t.Optional[Environment]&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, environment: &quot;t.Optional[Environment]&quot;) -&gt; None:</span>
<span class="w"> </span>        self.environment = environment
<span class="gi">+</span>
<span class="gi">+    def generic_visit(</span>
<span class="gi">+        self, node: nodes.Node, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; nodes.Node:</span>
<span class="gi">+        node = super().generic_visit(node, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # Do constant folding. Some other nodes besides Expr have</span>
<span class="gi">+        # as_const, but folding them causes errors later on.</span>
<span class="gi">+        if isinstance(node, nodes.Expr):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return nodes.Const.from_untrusted(</span>
<span class="gi">+                    node.as_const(args[0] if args else None),</span>
<span class="gi">+                    lineno=node.lineno,</span>
<span class="gi">+                    environment=self.environment,</span>
<span class="gi">+                )</span>
<span class="gi">+            except nodes.Impossible:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        return node</span>
<span class="gh">diff --git a/src/jinja2/parser.py b/src/jinja2/parser.py</span>
<span class="gh">index 05ce33d..0ec997f 100644</span>
<span class="gd">--- a/src/jinja2/parser.py</span>
<span class="gi">+++ b/src/jinja2/parser.py</span>
<span class="gu">@@ -1,22 +1,48 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Parse tokens from the lexer into nodes for the compiler.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import typing
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from . import nodes
<span class="w"> </span>from .exceptions import TemplateAssertionError
<span class="w"> </span>from .exceptions import TemplateSyntaxError
<span class="w"> </span>from .lexer import describe_token
<span class="w"> </span>from .lexer import describe_token_expr
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gi">+</span>
<span class="w"> </span>    from .environment import Environment
<span class="gd">-_ImportInclude = t.TypeVar(&#39;_ImportInclude&#39;, nodes.Import, nodes.Include)</span>
<span class="gd">-_MacroCall = t.TypeVar(&#39;_MacroCall&#39;, nodes.Macro, nodes.CallBlock)</span>
<span class="gd">-_statement_keywords = frozenset([&#39;for&#39;, &#39;if&#39;, &#39;block&#39;, &#39;extends&#39;, &#39;print&#39;,</span>
<span class="gd">-    &#39;macro&#39;, &#39;include&#39;, &#39;from&#39;, &#39;import&#39;, &#39;set&#39;, &#39;with&#39;, &#39;autoescape&#39;])</span>
<span class="gd">-_compare_operators = frozenset([&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;lteq&#39;, &#39;gt&#39;, &#39;gteq&#39;])</span>
<span class="gd">-_math_nodes: t.Dict[str, t.Type[nodes.Expr]] = {&#39;add&#39;: nodes.Add, &#39;sub&#39;:</span>
<span class="gd">-    nodes.Sub, &#39;mul&#39;: nodes.Mul, &#39;div&#39;: nodes.Div, &#39;floordiv&#39;: nodes.</span>
<span class="gd">-    FloorDiv, &#39;mod&#39;: nodes.Mod}</span>
<span class="gi">+</span>
<span class="gi">+_ImportInclude = t.TypeVar(&quot;_ImportInclude&quot;, nodes.Import, nodes.Include)</span>
<span class="gi">+_MacroCall = t.TypeVar(&quot;_MacroCall&quot;, nodes.Macro, nodes.CallBlock)</span>
<span class="gi">+</span>
<span class="gi">+_statement_keywords = frozenset(</span>
<span class="gi">+    [</span>
<span class="gi">+        &quot;for&quot;,</span>
<span class="gi">+        &quot;if&quot;,</span>
<span class="gi">+        &quot;block&quot;,</span>
<span class="gi">+        &quot;extends&quot;,</span>
<span class="gi">+        &quot;print&quot;,</span>
<span class="gi">+        &quot;macro&quot;,</span>
<span class="gi">+        &quot;include&quot;,</span>
<span class="gi">+        &quot;from&quot;,</span>
<span class="gi">+        &quot;import&quot;,</span>
<span class="gi">+        &quot;set&quot;,</span>
<span class="gi">+        &quot;with&quot;,</span>
<span class="gi">+        &quot;autoescape&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+)</span>
<span class="gi">+_compare_operators = frozenset([&quot;eq&quot;, &quot;ne&quot;, &quot;lt&quot;, &quot;lteq&quot;, &quot;gt&quot;, &quot;gteq&quot;])</span>
<span class="gi">+</span>
<span class="gi">+_math_nodes: t.Dict[str, t.Type[nodes.Expr]] = {</span>
<span class="gi">+    &quot;add&quot;: nodes.Add,</span>
<span class="gi">+    &quot;sub&quot;: nodes.Sub,</span>
<span class="gi">+    &quot;mul&quot;: nodes.Mul,</span>
<span class="gi">+    &quot;div&quot;: nodes.Div,</span>
<span class="gi">+    &quot;floordiv&quot;: nodes.FloorDiv,</span>
<span class="gi">+    &quot;mod&quot;: nodes.Mod,</span>
<span class="gi">+}</span>


<span class="w"> </span>class Parser:
<span class="gu">@@ -24,16 +50,22 @@ class Parser:</span>
<span class="w"> </span>    extensions and can be used to parse expressions or statements.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, environment: &#39;Environment&#39;, source: str, name: t.</span>
<span class="gd">-        Optional[str]=None, filename: t.Optional[str]=None, state: t.</span>
<span class="gd">-        Optional[str]=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        environment: &quot;Environment&quot;,</span>
<span class="gi">+        source: str,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        filename: t.Optional[str] = None,</span>
<span class="gi">+        state: t.Optional[str] = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.environment = environment
<span class="w"> </span>        self.stream = environment._tokenize(source, name, filename, state)
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.closed = False
<span class="gd">-        self.extensions: t.Dict[str, t.Callable[[&#39;Parser&#39;], t.Union[nodes.</span>
<span class="gd">-            Node, t.List[nodes.Node]]]] = {}</span>
<span class="gi">+        self.extensions: t.Dict[</span>
<span class="gi">+            str, t.Callable[[&quot;Parser&quot;], t.Union[nodes.Node, t.List[nodes.Node]]]</span>
<span class="gi">+        ] = {}</span>
<span class="w"> </span>        for extension in environment.iter_extensions():
<span class="w"> </span>            for tag in extension.tags:
<span class="w"> </span>                self.extensions[tag] = extension.parse
<span class="gu">@@ -41,43 +73,129 @@ class Parser:</span>
<span class="w"> </span>        self._tag_stack: t.List[str] = []
<span class="w"> </span>        self._end_token_stack: t.List[t.Tuple[str, ...]] = []

<span class="gd">-    def fail(self, msg: str, lineno: t.Optional[int]=None, exc: t.Type[</span>
<span class="gd">-        TemplateSyntaxError]=TemplateSyntaxError) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+    def fail(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg: str,</span>
<span class="gi">+        lineno: t.Optional[int] = None,</span>
<span class="gi">+        exc: t.Type[TemplateSyntaxError] = TemplateSyntaxError,</span>
<span class="gi">+    ) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convenience method that raises `exc` with the message, passed
<span class="w"> </span>        line number or last line number as well as the current name and
<span class="w"> </span>        filename.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if lineno is None:</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        raise exc(msg, lineno, self.name, self.filename)</span>
<span class="gi">+</span>
<span class="gi">+    def _fail_ut_eof(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: t.Optional[str],</span>
<span class="gi">+        end_token_stack: t.List[t.Tuple[str, ...]],</span>
<span class="gi">+        lineno: t.Optional[int],</span>
<span class="gi">+    ) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="gi">+        expected: t.Set[str] = set()</span>
<span class="gi">+        for exprs in end_token_stack:</span>
<span class="gi">+            expected.update(map(describe_token_expr, exprs))</span>
<span class="gi">+        if end_token_stack:</span>
<span class="gi">+            currently_looking: t.Optional[str] = &quot; or &quot;.join(</span>
<span class="gi">+                map(repr, map(describe_token_expr, end_token_stack[-1]))</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            currently_looking = None</span>
<span class="gi">+</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            message = [&quot;Unexpected end of template.&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            message = [f&quot;Encountered unknown tag {name!r}.&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if currently_looking:</span>
<span class="gi">+            if name is not None and name in expected:</span>
<span class="gi">+                message.append(</span>
<span class="gi">+                    &quot;You probably made a nesting mistake. Jinja is expecting this tag,&quot;</span>
<span class="gi">+                    f&quot; but currently looking for {currently_looking}.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                message.append(</span>
<span class="gi">+                    f&quot;Jinja was looking for the following tags: {currently_looking}.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if self._tag_stack:</span>
<span class="gi">+            message.append(</span>
<span class="gi">+                &quot;The innermost block that needs to be closed is&quot;</span>
<span class="gi">+                f&quot; {self._tag_stack[-1]!r}.&quot;</span>
<span class="gi">+            )</span>

<span class="gd">-    def fail_unknown_tag(self, name: str, lineno: t.Optional[int]=None</span>
<span class="gd">-        ) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+        self.fail(&quot; &quot;.join(message), lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def fail_unknown_tag(</span>
<span class="gi">+        self, name: str, lineno: t.Optional[int] = None</span>
<span class="gi">+    ) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called if the parser encounters an unknown tag.  Tries to fail
<span class="w"> </span>        with a human readable error message that could help to identify
<span class="w"> </span>        the problem.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._fail_ut_eof(name, self._end_token_stack, lineno)</span>

<span class="gd">-    def fail_eof(self, end_tokens: t.Optional[t.Tuple[str, ...]]=None,</span>
<span class="gd">-        lineno: t.Optional[int]=None) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+    def fail_eof(</span>
<span class="gi">+        self,</span>
<span class="gi">+        end_tokens: t.Optional[t.Tuple[str, ...]] = None,</span>
<span class="gi">+        lineno: t.Optional[int] = None,</span>
<span class="gi">+    ) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Like fail_unknown_tag but for end of template situations.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stack = list(self._end_token_stack)</span>
<span class="gi">+        if end_tokens is not None:</span>
<span class="gi">+            stack.append(end_tokens)</span>
<span class="gi">+        self._fail_ut_eof(None, stack, lineno)</span>

<span class="gd">-    def is_tuple_end(self, extra_end_rules: t.Optional[t.Tuple[str, ...]]=None</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def is_tuple_end(</span>
<span class="gi">+        self, extra_end_rules: t.Optional[t.Tuple[str, ...]] = None</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Are we at the end of a tuple?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.stream.current.type in (&quot;variable_end&quot;, &quot;block_end&quot;, &quot;rparen&quot;):</span>
<span class="gi">+            return True</span>
<span class="gi">+        elif extra_end_rules is not None:</span>
<span class="gi">+            return self.stream.current.test_any(extra_end_rules)  # type: ignore</span>
<span class="gi">+        return False</span>

<span class="gd">-    def free_identifier(self, lineno: t.Optional[int]=None</span>
<span class="gd">-        ) -&gt;nodes.InternalName:</span>
<span class="gi">+    def free_identifier(self, lineno: t.Optional[int] = None) -&gt; nodes.InternalName:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a new free identifier as :class:`~jinja2.nodes.InternalName`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._last_identifier += 1</span>
<span class="gi">+        rv = object.__new__(nodes.InternalName)</span>
<span class="gi">+        nodes.Node.__init__(rv, f&quot;fi{self._last_identifier}&quot;, lineno=lineno)</span>
<span class="gi">+        return rv</span>

<span class="gd">-    def parse_statement(self) -&gt;t.Union[nodes.Node, t.List[nodes.Node]]:</span>
<span class="gi">+    def parse_statement(self) -&gt; t.Union[nodes.Node, t.List[nodes.Node]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse a single statement.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.stream.current</span>
<span class="gi">+        if token.type != &quot;name&quot;:</span>
<span class="gi">+            self.fail(&quot;tag name expected&quot;, token.lineno)</span>
<span class="gi">+        self._tag_stack.append(token.value)</span>
<span class="gi">+        pop_tag = True</span>
<span class="gi">+        try:</span>
<span class="gi">+            if token.value in _statement_keywords:</span>
<span class="gi">+                f = getattr(self, f&quot;parse_{self.stream.current.value}&quot;)</span>
<span class="gi">+                return f()  # type: ignore</span>
<span class="gi">+            if token.value == &quot;call&quot;:</span>
<span class="gi">+                return self.parse_call_block()</span>
<span class="gi">+            if token.value == &quot;filter&quot;:</span>
<span class="gi">+                return self.parse_filter_block()</span>
<span class="gi">+            ext = self.extensions.get(token.value)</span>
<span class="gi">+            if ext is not None:</span>
<span class="gi">+                return ext(self)</span>
<span class="gi">+</span>
<span class="gi">+            # did not work out, remove the token we pushed by accident</span>
<span class="gi">+            # from the stack so that the unknown tag fail function can</span>
<span class="gi">+            # produce a proper error message.</span>
<span class="gi">+            self._tag_stack.pop()</span>
<span class="gi">+            pop_tag = False</span>
<span class="gi">+            self.fail_unknown_tag(token.value, token.lineno)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if pop_tag:</span>
<span class="gi">+                self._tag_stack.pop()</span>

<span class="gd">-    def parse_statements(self, end_tokens: t.Tuple[str, ...], drop_needle:</span>
<span class="gd">-        bool=False) -&gt;t.List[nodes.Node]:</span>
<span class="gi">+    def parse_statements(</span>
<span class="gi">+        self, end_tokens: t.Tuple[str, ...], drop_needle: bool = False</span>
<span class="gi">+    ) -&gt; t.List[nodes.Node]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse multiple statements into a list until one of the end tokens
<span class="w"> </span>        is reached.  This is used to parse the body of statements as it also
<span class="w"> </span>        parses template data if appropriate.  The parser checks first if the
<span class="gu">@@ -87,24 +205,278 @@ class Parser:</span>
<span class="w"> </span>        the call is the matched end token.  If this is not wanted `drop_needle`
<span class="w"> </span>        can be set to `True` and the end token is removed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # the first token may be a colon for python compatibility</span>
<span class="gi">+        self.stream.skip_if(&quot;colon&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # in the future it would be possible to add whole code sections</span>
<span class="gi">+        # by adding some sort of end of statement token and parsing those here.</span>
<span class="gi">+        self.stream.expect(&quot;block_end&quot;)</span>
<span class="gi">+        result = self.subparse(end_tokens)</span>

<span class="gd">-    def parse_set(self) -&gt;t.Union[nodes.Assign, nodes.AssignBlock]:</span>
<span class="gi">+        # we reached the end of the template too early, the subparser</span>
<span class="gi">+        # does not check for this, so we do that now</span>
<span class="gi">+        if self.stream.current.type == &quot;eof&quot;:</span>
<span class="gi">+            self.fail_eof(end_tokens)</span>
<span class="gi">+</span>
<span class="gi">+        if drop_needle:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def parse_set(self) -&gt; t.Union[nodes.Assign, nodes.AssignBlock]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse an assign statement.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lineno = next(self.stream).lineno</span>
<span class="gi">+        target = self.parse_assign_target(with_namespace=True)</span>
<span class="gi">+        if self.stream.skip_if(&quot;assign&quot;):</span>
<span class="gi">+            expr = self.parse_tuple()</span>
<span class="gi">+            return nodes.Assign(target, expr, lineno=lineno)</span>
<span class="gi">+        filter_node = self.parse_filter(None)</span>
<span class="gi">+        body = self.parse_statements((&quot;name:endset&quot;,), drop_needle=True)</span>
<span class="gi">+        return nodes.AssignBlock(target, filter_node, body, lineno=lineno)</span>

<span class="gd">-    def parse_for(self) -&gt;nodes.For:</span>
<span class="gi">+    def parse_for(self) -&gt; nodes.For:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse a for loop.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lineno = self.stream.expect(&quot;name:for&quot;).lineno</span>
<span class="gi">+        target = self.parse_assign_target(extra_end_rules=(&quot;name:in&quot;,))</span>
<span class="gi">+        self.stream.expect(&quot;name:in&quot;)</span>
<span class="gi">+        iter = self.parse_tuple(</span>
<span class="gi">+            with_condexpr=False, extra_end_rules=(&quot;name:recursive&quot;,)</span>
<span class="gi">+        )</span>
<span class="gi">+        test = None</span>
<span class="gi">+        if self.stream.skip_if(&quot;name:if&quot;):</span>
<span class="gi">+            test = self.parse_expression()</span>
<span class="gi">+        recursive = self.stream.skip_if(&quot;name:recursive&quot;)</span>
<span class="gi">+        body = self.parse_statements((&quot;name:endfor&quot;, &quot;name:else&quot;))</span>
<span class="gi">+        if next(self.stream).value == &quot;endfor&quot;:</span>
<span class="gi">+            else_ = []</span>
<span class="gi">+        else:</span>
<span class="gi">+            else_ = self.parse_statements((&quot;name:endfor&quot;,), drop_needle=True)</span>
<span class="gi">+        return nodes.For(target, iter, body, else_, test, recursive, lineno=lineno)</span>

<span class="gd">-    def parse_if(self) -&gt;nodes.If:</span>
<span class="gi">+    def parse_if(self) -&gt; nodes.If:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse an if construct.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node = result = nodes.If(lineno=self.stream.expect(&quot;name:if&quot;).lineno)</span>
<span class="gi">+        while True:</span>
<span class="gi">+            node.test = self.parse_tuple(with_condexpr=False)</span>
<span class="gi">+            node.body = self.parse_statements((&quot;name:elif&quot;, &quot;name:else&quot;, &quot;name:endif&quot;))</span>
<span class="gi">+            node.elif_ = []</span>
<span class="gi">+            node.else_ = []</span>
<span class="gi">+            token = next(self.stream)</span>
<span class="gi">+            if token.test(&quot;name:elif&quot;):</span>
<span class="gi">+                node = nodes.If(lineno=self.stream.current.lineno)</span>
<span class="gi">+                result.elif_.append(node)</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif token.test(&quot;name:else&quot;):</span>
<span class="gi">+                result.else_ = self.parse_statements((&quot;name:endif&quot;,), drop_needle=True)</span>
<span class="gi">+            break</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def parse_with(self) -&gt; nodes.With:</span>
<span class="gi">+        node = nodes.With(lineno=next(self.stream).lineno)</span>
<span class="gi">+        targets: t.List[nodes.Expr] = []</span>
<span class="gi">+        values: t.List[nodes.Expr] = []</span>
<span class="gi">+        while self.stream.current.type != &quot;block_end&quot;:</span>
<span class="gi">+            if targets:</span>
<span class="gi">+                self.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+            target = self.parse_assign_target()</span>
<span class="gi">+            target.set_ctx(&quot;param&quot;)</span>
<span class="gi">+            targets.append(target)</span>
<span class="gi">+            self.stream.expect(&quot;assign&quot;)</span>
<span class="gi">+            values.append(self.parse_expression())</span>
<span class="gi">+        node.targets = targets</span>
<span class="gi">+        node.values = values</span>
<span class="gi">+        node.body = self.parse_statements((&quot;name:endwith&quot;,), drop_needle=True)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_autoescape(self) -&gt; nodes.Scope:</span>
<span class="gi">+        node = nodes.ScopedEvalContextModifier(lineno=next(self.stream).lineno)</span>
<span class="gi">+        node.options = [nodes.Keyword(&quot;autoescape&quot;, self.parse_expression())]</span>
<span class="gi">+        node.body = self.parse_statements((&quot;name:endautoescape&quot;,), drop_needle=True)</span>
<span class="gi">+        return nodes.Scope([node])</span>
<span class="gi">+</span>
<span class="gi">+    def parse_block(self) -&gt; nodes.Block:</span>
<span class="gi">+        node = nodes.Block(lineno=next(self.stream).lineno)</span>
<span class="gi">+        node.name = self.stream.expect(&quot;name&quot;).value</span>
<span class="gi">+        node.scoped = self.stream.skip_if(&quot;name:scoped&quot;)</span>
<span class="gi">+        node.required = self.stream.skip_if(&quot;name:required&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # common problem people encounter when switching from django</span>
<span class="gi">+        # to jinja.  we do not support hyphens in block names, so let&#39;s</span>
<span class="gi">+        # raise a nicer error message in that case.</span>
<span class="gi">+        if self.stream.current.type == &quot;sub&quot;:</span>
<span class="gi">+            self.fail(</span>
<span class="gi">+                &quot;Block names in Jinja have to be valid Python identifiers and may not&quot;</span>
<span class="gi">+                &quot; contain hyphens, use an underscore instead.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        node.body = self.parse_statements((&quot;name:endblock&quot;,), drop_needle=True)</span>
<span class="gi">+</span>
<span class="gi">+        # enforce that required blocks only contain whitespace or comments</span>
<span class="gi">+        # by asserting that the body, if not empty, is just TemplateData nodes</span>
<span class="gi">+        # with whitespace data</span>
<span class="gi">+        if node.required:</span>
<span class="gi">+            for body_node in node.body:</span>
<span class="gi">+                if not isinstance(body_node, nodes.Output) or any(</span>
<span class="gi">+                    not isinstance(output_node, nodes.TemplateData)</span>
<span class="gi">+                    or not output_node.data.isspace()</span>
<span class="gi">+                    for output_node in body_node.nodes</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.fail(&quot;Required blocks can only contain comments or whitespace&quot;)</span>

<span class="gd">-    def parse_assign_target(self, with_tuple: bool=True, name_only: bool=</span>
<span class="gd">-        False, extra_end_rules: t.Optional[t.Tuple[str, ...]]=None,</span>
<span class="gd">-        with_namespace: bool=False) -&gt;t.Union[nodes.NSRef, nodes.Name,</span>
<span class="gd">-        nodes.Tuple]:</span>
<span class="gi">+        self.stream.skip_if(&quot;name:&quot; + node.name)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_extends(self) -&gt; nodes.Extends:</span>
<span class="gi">+        node = nodes.Extends(lineno=next(self.stream).lineno)</span>
<span class="gi">+        node.template = self.parse_expression()</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_import_context(</span>
<span class="gi">+        self, node: _ImportInclude, default: bool</span>
<span class="gi">+    ) -&gt; _ImportInclude:</span>
<span class="gi">+        if self.stream.current.test_any(</span>
<span class="gi">+            &quot;name:with&quot;, &quot;name:without&quot;</span>
<span class="gi">+        ) and self.stream.look().test(&quot;name:context&quot;):</span>
<span class="gi">+            node.with_context = next(self.stream).value == &quot;with&quot;</span>
<span class="gi">+            self.stream.skip()</span>
<span class="gi">+        else:</span>
<span class="gi">+            node.with_context = default</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_include(self) -&gt; nodes.Include:</span>
<span class="gi">+        node = nodes.Include(lineno=next(self.stream).lineno)</span>
<span class="gi">+        node.template = self.parse_expression()</span>
<span class="gi">+        if self.stream.current.test(&quot;name:ignore&quot;) and self.stream.look().test(</span>
<span class="gi">+            &quot;name:missing&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            node.ignore_missing = True</span>
<span class="gi">+            self.stream.skip(2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node.ignore_missing = False</span>
<span class="gi">+        return self.parse_import_context(node, True)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_import(self) -&gt; nodes.Import:</span>
<span class="gi">+        node = nodes.Import(lineno=next(self.stream).lineno)</span>
<span class="gi">+        node.template = self.parse_expression()</span>
<span class="gi">+        self.stream.expect(&quot;name:as&quot;)</span>
<span class="gi">+        node.target = self.parse_assign_target(name_only=True).name</span>
<span class="gi">+        return self.parse_import_context(node, False)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_from(self) -&gt; nodes.FromImport:</span>
<span class="gi">+        node = nodes.FromImport(lineno=next(self.stream).lineno)</span>
<span class="gi">+        node.template = self.parse_expression()</span>
<span class="gi">+        self.stream.expect(&quot;name:import&quot;)</span>
<span class="gi">+        node.names = []</span>
<span class="gi">+</span>
<span class="gi">+        def parse_context() -&gt; bool:</span>
<span class="gi">+            if self.stream.current.value in {</span>
<span class="gi">+                &quot;with&quot;,</span>
<span class="gi">+                &quot;without&quot;,</span>
<span class="gi">+            } and self.stream.look().test(&quot;name:context&quot;):</span>
<span class="gi">+                node.with_context = next(self.stream).value == &quot;with&quot;</span>
<span class="gi">+                self.stream.skip()</span>
<span class="gi">+                return True</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if node.names:</span>
<span class="gi">+                self.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+            if self.stream.current.type == &quot;name&quot;:</span>
<span class="gi">+                if parse_context():</span>
<span class="gi">+                    break</span>
<span class="gi">+                target = self.parse_assign_target(name_only=True)</span>
<span class="gi">+                if target.name.startswith(&quot;_&quot;):</span>
<span class="gi">+                    self.fail(</span>
<span class="gi">+                        &quot;names starting with an underline can not be imported&quot;,</span>
<span class="gi">+                        target.lineno,</span>
<span class="gi">+                        exc=TemplateAssertionError,</span>
<span class="gi">+                    )</span>
<span class="gi">+                if self.stream.skip_if(&quot;name:as&quot;):</span>
<span class="gi">+                    alias = self.parse_assign_target(name_only=True)</span>
<span class="gi">+                    node.names.append((target.name, alias.name))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    node.names.append(target.name)</span>
<span class="gi">+                if parse_context() or self.stream.current.type != &quot;comma&quot;:</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.stream.expect(&quot;name&quot;)</span>
<span class="gi">+        if not hasattr(node, &quot;with_context&quot;):</span>
<span class="gi">+            node.with_context = False</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_signature(self, node: _MacroCall) -&gt; None:</span>
<span class="gi">+        args = node.args = []</span>
<span class="gi">+        defaults = node.defaults = []</span>
<span class="gi">+        self.stream.expect(&quot;lparen&quot;)</span>
<span class="gi">+        while self.stream.current.type != &quot;rparen&quot;:</span>
<span class="gi">+            if args:</span>
<span class="gi">+                self.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+            arg = self.parse_assign_target(name_only=True)</span>
<span class="gi">+            arg.set_ctx(&quot;param&quot;)</span>
<span class="gi">+            if self.stream.skip_if(&quot;assign&quot;):</span>
<span class="gi">+                defaults.append(self.parse_expression())</span>
<span class="gi">+            elif defaults:</span>
<span class="gi">+                self.fail(&quot;non-default argument follows default argument&quot;)</span>
<span class="gi">+            args.append(arg)</span>
<span class="gi">+        self.stream.expect(&quot;rparen&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_call_block(self) -&gt; nodes.CallBlock:</span>
<span class="gi">+        node = nodes.CallBlock(lineno=next(self.stream).lineno)</span>
<span class="gi">+        if self.stream.current.type == &quot;lparen&quot;:</span>
<span class="gi">+            self.parse_signature(node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node.args = []</span>
<span class="gi">+            node.defaults = []</span>
<span class="gi">+</span>
<span class="gi">+        call_node = self.parse_expression()</span>
<span class="gi">+        if not isinstance(call_node, nodes.Call):</span>
<span class="gi">+            self.fail(&quot;expected call&quot;, node.lineno)</span>
<span class="gi">+        node.call = call_node</span>
<span class="gi">+        node.body = self.parse_statements((&quot;name:endcall&quot;,), drop_needle=True)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_filter_block(self) -&gt; nodes.FilterBlock:</span>
<span class="gi">+        node = nodes.FilterBlock(lineno=next(self.stream).lineno)</span>
<span class="gi">+        node.filter = self.parse_filter(None, start_inline=True)  # type: ignore</span>
<span class="gi">+        node.body = self.parse_statements((&quot;name:endfilter&quot;,), drop_needle=True)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_macro(self) -&gt; nodes.Macro:</span>
<span class="gi">+        node = nodes.Macro(lineno=next(self.stream).lineno)</span>
<span class="gi">+        node.name = self.parse_assign_target(name_only=True).name</span>
<span class="gi">+        self.parse_signature(node)</span>
<span class="gi">+        node.body = self.parse_statements((&quot;name:endmacro&quot;,), drop_needle=True)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_print(self) -&gt; nodes.Output:</span>
<span class="gi">+        node = nodes.Output(lineno=next(self.stream).lineno)</span>
<span class="gi">+        node.nodes = []</span>
<span class="gi">+        while self.stream.current.type != &quot;block_end&quot;:</span>
<span class="gi">+            if node.nodes:</span>
<span class="gi">+                self.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+            node.nodes.append(self.parse_expression())</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    @typing.overload</span>
<span class="gi">+    def parse_assign_target(</span>
<span class="gi">+        self, with_tuple: bool = ..., name_only: &quot;te.Literal[True]&quot; = ...</span>
<span class="gi">+    ) -&gt; nodes.Name: ...</span>
<span class="gi">+</span>
<span class="gi">+    @typing.overload</span>
<span class="gi">+    def parse_assign_target(</span>
<span class="gi">+        self,</span>
<span class="gi">+        with_tuple: bool = True,</span>
<span class="gi">+        name_only: bool = False,</span>
<span class="gi">+        extra_end_rules: t.Optional[t.Tuple[str, ...]] = None,</span>
<span class="gi">+        with_namespace: bool = False,</span>
<span class="gi">+    ) -&gt; t.Union[nodes.NSRef, nodes.Name, nodes.Tuple]: ...</span>
<span class="gi">+</span>
<span class="gi">+    def parse_assign_target(</span>
<span class="gi">+        self,</span>
<span class="gi">+        with_tuple: bool = True,</span>
<span class="gi">+        name_only: bool = False,</span>
<span class="gi">+        extra_end_rules: t.Optional[t.Tuple[str, ...]] = None,</span>
<span class="gi">+        with_namespace: bool = False,</span>
<span class="gi">+    ) -&gt; t.Union[nodes.NSRef, nodes.Name, nodes.Tuple]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse an assignment target.  As Jinja allows assignments to
<span class="w"> </span>        tuples, this function can parse all allowed assignment targets.  Per
<span class="w"> </span>        default assignments to tuples are parsed, that can be disable however
<span class="gu">@@ -113,18 +485,205 @@ class Parser:</span>
<span class="w"> </span>        parameter is forwarded to the tuple parsing function.  If
<span class="w"> </span>        `with_namespace` is enabled, a namespace assignment may be parsed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        target: nodes.Expr</span>
<span class="gi">+</span>
<span class="gi">+        if with_namespace and self.stream.look().type == &quot;dot&quot;:</span>
<span class="gi">+            token = self.stream.expect(&quot;name&quot;)</span>
<span class="gi">+            next(self.stream)  # dot</span>
<span class="gi">+            attr = self.stream.expect(&quot;name&quot;)</span>
<span class="gi">+            target = nodes.NSRef(token.value, attr.value, lineno=token.lineno)</span>
<span class="gi">+        elif name_only:</span>
<span class="gi">+            token = self.stream.expect(&quot;name&quot;)</span>
<span class="gi">+            target = nodes.Name(token.value, &quot;store&quot;, lineno=token.lineno)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if with_tuple:</span>
<span class="gi">+                target = self.parse_tuple(</span>
<span class="gi">+                    simplified=True, extra_end_rules=extra_end_rules</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                target = self.parse_primary()</span>

<span class="gd">-    def parse_expression(self, with_condexpr: bool=True) -&gt;nodes.Expr:</span>
<span class="gi">+            target.set_ctx(&quot;store&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not target.can_assign():</span>
<span class="gi">+            self.fail(</span>
<span class="gi">+                f&quot;can&#39;t assign to {type(target).__name__.lower()!r}&quot;, target.lineno</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return target  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def parse_expression(self, with_condexpr: bool = True) -&gt; nodes.Expr:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse an expression.  Per default all expressions are parsed, if
<span class="w"> </span>        the optional `with_condexpr` parameter is set to `False` conditional
<span class="w"> </span>        expressions are not parsed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if with_condexpr:</span>
<span class="gi">+            return self.parse_condexpr()</span>
<span class="gi">+        return self.parse_or()</span>
<span class="gi">+</span>
<span class="gi">+    def parse_condexpr(self) -&gt; nodes.Expr:</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        expr1 = self.parse_or()</span>
<span class="gi">+        expr3: t.Optional[nodes.Expr]</span>
<span class="gi">+</span>
<span class="gi">+        while self.stream.skip_if(&quot;name:if&quot;):</span>
<span class="gi">+            expr2 = self.parse_or()</span>
<span class="gi">+            if self.stream.skip_if(&quot;name:else&quot;):</span>
<span class="gi">+                expr3 = self.parse_condexpr()</span>
<span class="gi">+            else:</span>
<span class="gi">+                expr3 = None</span>
<span class="gi">+            expr1 = nodes.CondExpr(expr2, expr1, expr3, lineno=lineno)</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        return expr1</span>

<span class="gd">-    def parse_tuple(self, simplified: bool=False, with_condexpr: bool=True,</span>
<span class="gd">-        extra_end_rules: t.Optional[t.Tuple[str, ...]]=None,</span>
<span class="gd">-        explicit_parentheses: bool=False) -&gt;t.Union[nodes.Tuple, nodes.Expr]:</span>
<span class="gi">+    def parse_or(self) -&gt; nodes.Expr:</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        left = self.parse_and()</span>
<span class="gi">+        while self.stream.skip_if(&quot;name:or&quot;):</span>
<span class="gi">+            right = self.parse_and()</span>
<span class="gi">+            left = nodes.Or(left, right, lineno=lineno)</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        return left</span>
<span class="gi">+</span>
<span class="gi">+    def parse_and(self) -&gt; nodes.Expr:</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        left = self.parse_not()</span>
<span class="gi">+        while self.stream.skip_if(&quot;name:and&quot;):</span>
<span class="gi">+            right = self.parse_not()</span>
<span class="gi">+            left = nodes.And(left, right, lineno=lineno)</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        return left</span>
<span class="gi">+</span>
<span class="gi">+    def parse_not(self) -&gt; nodes.Expr:</span>
<span class="gi">+        if self.stream.current.test(&quot;name:not&quot;):</span>
<span class="gi">+            lineno = next(self.stream).lineno</span>
<span class="gi">+            return nodes.Not(self.parse_not(), lineno=lineno)</span>
<span class="gi">+        return self.parse_compare()</span>
<span class="gi">+</span>
<span class="gi">+    def parse_compare(self) -&gt; nodes.Expr:</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        expr = self.parse_math1()</span>
<span class="gi">+        ops = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            token_type = self.stream.current.type</span>
<span class="gi">+            if token_type in _compare_operators:</span>
<span class="gi">+                next(self.stream)</span>
<span class="gi">+                ops.append(nodes.Operand(token_type, self.parse_math1()))</span>
<span class="gi">+            elif self.stream.skip_if(&quot;name:in&quot;):</span>
<span class="gi">+                ops.append(nodes.Operand(&quot;in&quot;, self.parse_math1()))</span>
<span class="gi">+            elif self.stream.current.test(&quot;name:not&quot;) and self.stream.look().test(</span>
<span class="gi">+                &quot;name:in&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.stream.skip(2)</span>
<span class="gi">+                ops.append(nodes.Operand(&quot;notin&quot;, self.parse_math1()))</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        if not ops:</span>
<span class="gi">+            return expr</span>
<span class="gi">+        return nodes.Compare(expr, ops, lineno=lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_math1(self) -&gt; nodes.Expr:</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        left = self.parse_concat()</span>
<span class="gi">+        while self.stream.current.type in (&quot;add&quot;, &quot;sub&quot;):</span>
<span class="gi">+            cls = _math_nodes[self.stream.current.type]</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            right = self.parse_concat()</span>
<span class="gi">+            left = cls(left, right, lineno=lineno)</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        return left</span>
<span class="gi">+</span>
<span class="gi">+    def parse_concat(self) -&gt; nodes.Expr:</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        args = [self.parse_math2()]</span>
<span class="gi">+        while self.stream.current.type == &quot;tilde&quot;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            args.append(self.parse_math2())</span>
<span class="gi">+        if len(args) == 1:</span>
<span class="gi">+            return args[0]</span>
<span class="gi">+        return nodes.Concat(args, lineno=lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_math2(self) -&gt; nodes.Expr:</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        left = self.parse_pow()</span>
<span class="gi">+        while self.stream.current.type in (&quot;mul&quot;, &quot;div&quot;, &quot;floordiv&quot;, &quot;mod&quot;):</span>
<span class="gi">+            cls = _math_nodes[self.stream.current.type]</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            right = self.parse_pow()</span>
<span class="gi">+            left = cls(left, right, lineno=lineno)</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        return left</span>
<span class="gi">+</span>
<span class="gi">+    def parse_pow(self) -&gt; nodes.Expr:</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        left = self.parse_unary()</span>
<span class="gi">+        while self.stream.current.type == &quot;pow&quot;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            right = self.parse_unary()</span>
<span class="gi">+            left = nodes.Pow(left, right, lineno=lineno)</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+        return left</span>
<span class="gi">+</span>
<span class="gi">+    def parse_unary(self, with_filter: bool = True) -&gt; nodes.Expr:</span>
<span class="gi">+        token_type = self.stream.current.type</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        node: nodes.Expr</span>
<span class="gi">+</span>
<span class="gi">+        if token_type == &quot;sub&quot;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            node = nodes.Neg(self.parse_unary(False), lineno=lineno)</span>
<span class="gi">+        elif token_type == &quot;add&quot;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            node = nodes.Pos(self.parse_unary(False), lineno=lineno)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node = self.parse_primary()</span>
<span class="gi">+        node = self.parse_postfix(node)</span>
<span class="gi">+        if with_filter:</span>
<span class="gi">+            node = self.parse_filter_expr(node)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_primary(self) -&gt; nodes.Expr:</span>
<span class="gi">+        token = self.stream.current</span>
<span class="gi">+        node: nodes.Expr</span>
<span class="gi">+        if token.type == &quot;name&quot;:</span>
<span class="gi">+            if token.value in (&quot;true&quot;, &quot;false&quot;, &quot;True&quot;, &quot;False&quot;):</span>
<span class="gi">+                node = nodes.Const(token.value in (&quot;true&quot;, &quot;True&quot;), lineno=token.lineno)</span>
<span class="gi">+            elif token.value in (&quot;none&quot;, &quot;None&quot;):</span>
<span class="gi">+                node = nodes.Const(None, lineno=token.lineno)</span>
<span class="gi">+            else:</span>
<span class="gi">+                node = nodes.Name(token.value, &quot;load&quot;, lineno=token.lineno)</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+        elif token.type == &quot;string&quot;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            buf = [token.value]</span>
<span class="gi">+            lineno = token.lineno</span>
<span class="gi">+            while self.stream.current.type == &quot;string&quot;:</span>
<span class="gi">+                buf.append(self.stream.current.value)</span>
<span class="gi">+                next(self.stream)</span>
<span class="gi">+            node = nodes.Const(&quot;&quot;.join(buf), lineno=lineno)</span>
<span class="gi">+        elif token.type in (&quot;integer&quot;, &quot;float&quot;):</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            node = nodes.Const(token.value, lineno=token.lineno)</span>
<span class="gi">+        elif token.type == &quot;lparen&quot;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            node = self.parse_tuple(explicit_parentheses=True)</span>
<span class="gi">+            self.stream.expect(&quot;rparen&quot;)</span>
<span class="gi">+        elif token.type == &quot;lbracket&quot;:</span>
<span class="gi">+            node = self.parse_list()</span>
<span class="gi">+        elif token.type == &quot;lbrace&quot;:</span>
<span class="gi">+            node = self.parse_dict()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.fail(f&quot;unexpected {describe_token(token)!r}&quot;, token.lineno)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_tuple(</span>
<span class="gi">+        self,</span>
<span class="gi">+        simplified: bool = False,</span>
<span class="gi">+        with_condexpr: bool = True,</span>
<span class="gi">+        extra_end_rules: t.Optional[t.Tuple[str, ...]] = None,</span>
<span class="gi">+        explicit_parentheses: bool = False,</span>
<span class="gi">+    ) -&gt; t.Union[nodes.Tuple, nodes.Expr]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Works like `parse_expression` but if multiple expressions are
<span class="w"> </span>        delimited by a comma a :class:`~jinja2.nodes.Tuple` node is created.
<span class="w"> </span>        This method could also return a regular expression instead of a tuple
<span class="gu">@@ -143,8 +702,340 @@ class Parser:</span>
<span class="w"> </span>        expression in parentheses.  This is used to figure out if an empty
<span class="w"> </span>        tuple is a valid expression or not.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        if simplified:</span>
<span class="gi">+            parse = self.parse_primary</span>
<span class="gi">+        elif with_condexpr:</span>
<span class="gi">+            parse = self.parse_expression</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def parse() -&gt; nodes.Expr:</span>
<span class="gi">+                return self.parse_expression(with_condexpr=False)</span>
<span class="gi">+</span>
<span class="gi">+        args: t.List[nodes.Expr] = []</span>
<span class="gi">+        is_tuple = False</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if args:</span>
<span class="gi">+                self.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+            if self.is_tuple_end(extra_end_rules):</span>
<span class="gi">+                break</span>
<span class="gi">+            args.append(parse())</span>
<span class="gi">+            if self.stream.current.type == &quot;comma&quot;:</span>
<span class="gi">+                is_tuple = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+            lineno = self.stream.current.lineno</span>
<span class="gi">+</span>
<span class="gi">+        if not is_tuple:</span>
<span class="gi">+            if args:</span>
<span class="gi">+                return args[0]</span>
<span class="gi">+</span>
<span class="gi">+            # if we don&#39;t have explicit parentheses, an empty tuple is</span>
<span class="gi">+            # not a valid expression.  This would mean nothing (literally</span>
<span class="gi">+            # nothing) in the spot of an expression would be an empty</span>
<span class="gi">+            # tuple.</span>
<span class="gi">+            if not explicit_parentheses:</span>
<span class="gi">+                self.fail(</span>
<span class="gi">+                    &quot;Expected an expression,&quot;</span>
<span class="gi">+                    f&quot; got {describe_token(self.stream.current)!r}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        return nodes.Tuple(args, &quot;load&quot;, lineno=lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_list(self) -&gt; nodes.List:</span>
<span class="gi">+        token = self.stream.expect(&quot;lbracket&quot;)</span>
<span class="gi">+        items: t.List[nodes.Expr] = []</span>
<span class="gi">+        while self.stream.current.type != &quot;rbracket&quot;:</span>
<span class="gi">+            if items:</span>
<span class="gi">+                self.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+            if self.stream.current.type == &quot;rbracket&quot;:</span>
<span class="gi">+                break</span>
<span class="gi">+            items.append(self.parse_expression())</span>
<span class="gi">+        self.stream.expect(&quot;rbracket&quot;)</span>
<span class="gi">+        return nodes.List(items, lineno=token.lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_dict(self) -&gt; nodes.Dict:</span>
<span class="gi">+        token = self.stream.expect(&quot;lbrace&quot;)</span>
<span class="gi">+        items: t.List[nodes.Pair] = []</span>
<span class="gi">+        while self.stream.current.type != &quot;rbrace&quot;:</span>
<span class="gi">+            if items:</span>
<span class="gi">+                self.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+            if self.stream.current.type == &quot;rbrace&quot;:</span>
<span class="gi">+                break</span>
<span class="gi">+            key = self.parse_expression()</span>
<span class="gi">+            self.stream.expect(&quot;colon&quot;)</span>
<span class="gi">+            value = self.parse_expression()</span>
<span class="gi">+            items.append(nodes.Pair(key, value, lineno=key.lineno))</span>
<span class="gi">+        self.stream.expect(&quot;rbrace&quot;)</span>
<span class="gi">+        return nodes.Dict(items, lineno=token.lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_postfix(self, node: nodes.Expr) -&gt; nodes.Expr:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            token_type = self.stream.current.type</span>
<span class="gi">+            if token_type == &quot;dot&quot; or token_type == &quot;lbracket&quot;:</span>
<span class="gi">+                node = self.parse_subscript(node)</span>
<span class="gi">+            # calls are valid both after postfix expressions (getattr</span>
<span class="gi">+            # and getitem) as well as filters and tests</span>
<span class="gi">+            elif token_type == &quot;lparen&quot;:</span>
<span class="gi">+                node = self.parse_call(node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_filter_expr(self, node: nodes.Expr) -&gt; nodes.Expr:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            token_type = self.stream.current.type</span>
<span class="gi">+            if token_type == &quot;pipe&quot;:</span>
<span class="gi">+                node = self.parse_filter(node)  # type: ignore</span>
<span class="gi">+            elif token_type == &quot;name&quot; and self.stream.current.value == &quot;is&quot;:</span>
<span class="gi">+                node = self.parse_test(node)</span>
<span class="gi">+            # calls are valid both after postfix expressions (getattr</span>
<span class="gi">+            # and getitem) as well as filters and tests</span>
<span class="gi">+            elif token_type == &quot;lparen&quot;:</span>
<span class="gi">+                node = self.parse_call(node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_subscript(</span>
<span class="gi">+        self, node: nodes.Expr</span>
<span class="gi">+    ) -&gt; t.Union[nodes.Getattr, nodes.Getitem]:</span>
<span class="gi">+        token = next(self.stream)</span>
<span class="gi">+        arg: nodes.Expr</span>
<span class="gi">+</span>
<span class="gi">+        if token.type == &quot;dot&quot;:</span>
<span class="gi">+            attr_token = self.stream.current</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            if attr_token.type == &quot;name&quot;:</span>
<span class="gi">+                return nodes.Getattr(</span>
<span class="gi">+                    node, attr_token.value, &quot;load&quot;, lineno=token.lineno</span>
<span class="gi">+                )</span>
<span class="gi">+            elif attr_token.type != &quot;integer&quot;:</span>
<span class="gi">+                self.fail(&quot;expected name or number&quot;, attr_token.lineno)</span>
<span class="gi">+            arg = nodes.Const(attr_token.value, lineno=attr_token.lineno)</span>
<span class="gi">+            return nodes.Getitem(node, arg, &quot;load&quot;, lineno=token.lineno)</span>
<span class="gi">+        if token.type == &quot;lbracket&quot;:</span>
<span class="gi">+            args: t.List[nodes.Expr] = []</span>
<span class="gi">+            while self.stream.current.type != &quot;rbracket&quot;:</span>
<span class="gi">+                if args:</span>
<span class="gi">+                    self.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+                args.append(self.parse_subscribed())</span>
<span class="gi">+            self.stream.expect(&quot;rbracket&quot;)</span>
<span class="gi">+            if len(args) == 1:</span>
<span class="gi">+                arg = args[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                arg = nodes.Tuple(args, &quot;load&quot;, lineno=token.lineno)</span>
<span class="gi">+            return nodes.Getitem(node, arg, &quot;load&quot;, lineno=token.lineno)</span>
<span class="gi">+        self.fail(&quot;expected subscript expression&quot;, token.lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_subscribed(self) -&gt; nodes.Expr:</span>
<span class="gi">+        lineno = self.stream.current.lineno</span>
<span class="gi">+        args: t.List[t.Optional[nodes.Expr]]</span>
<span class="gi">+</span>
<span class="gi">+        if self.stream.current.type == &quot;colon&quot;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            args = [None]</span>
<span class="gi">+        else:</span>
<span class="gi">+            node = self.parse_expression()</span>
<span class="gi">+            if self.stream.current.type != &quot;colon&quot;:</span>
<span class="gi">+                return node</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            args = [node]</span>
<span class="gi">+</span>
<span class="gi">+        if self.stream.current.type == &quot;colon&quot;:</span>
<span class="gi">+            args.append(None)</span>
<span class="gi">+        elif self.stream.current.type not in (&quot;rbracket&quot;, &quot;comma&quot;):</span>
<span class="gi">+            args.append(self.parse_expression())</span>
<span class="gi">+        else:</span>
<span class="gi">+            args.append(None)</span>
<span class="gi">+</span>
<span class="gi">+        if self.stream.current.type == &quot;colon&quot;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            if self.stream.current.type not in (&quot;rbracket&quot;, &quot;comma&quot;):</span>
<span class="gi">+                args.append(self.parse_expression())</span>
<span class="gi">+            else:</span>
<span class="gi">+                args.append(None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            args.append(None)</span>
<span class="gi">+</span>
<span class="gi">+        return nodes.Slice(lineno=lineno, *args)  # noqa: B026</span>
<span class="gi">+</span>
<span class="gi">+    def parse_call_args(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; t.Tuple[</span>
<span class="gi">+        t.List[nodes.Expr],</span>
<span class="gi">+        t.List[nodes.Keyword],</span>
<span class="gi">+        t.Optional[nodes.Expr],</span>
<span class="gi">+        t.Optional[nodes.Expr],</span>
<span class="gi">+    ]:</span>
<span class="gi">+        token = self.stream.expect(&quot;lparen&quot;)</span>
<span class="gi">+        args = []</span>
<span class="gi">+        kwargs = []</span>
<span class="gi">+        dyn_args = None</span>
<span class="gi">+        dyn_kwargs = None</span>
<span class="gi">+        require_comma = False</span>
<span class="gi">+</span>
<span class="gi">+        def ensure(expr: bool) -&gt; None:</span>
<span class="gi">+            if not expr:</span>
<span class="gi">+                self.fail(&quot;invalid syntax for function call expression&quot;, token.lineno)</span>
<span class="gi">+</span>
<span class="gi">+        while self.stream.current.type != &quot;rparen&quot;:</span>
<span class="gi">+            if require_comma:</span>
<span class="gi">+                self.stream.expect(&quot;comma&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                # support for trailing comma</span>
<span class="gi">+                if self.stream.current.type == &quot;rparen&quot;:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if self.stream.current.type == &quot;mul&quot;:</span>
<span class="gi">+                ensure(dyn_args is None and dyn_kwargs is None)</span>
<span class="gi">+                next(self.stream)</span>
<span class="gi">+                dyn_args = self.parse_expression()</span>
<span class="gi">+            elif self.stream.current.type == &quot;pow&quot;:</span>
<span class="gi">+                ensure(dyn_kwargs is None)</span>
<span class="gi">+                next(self.stream)</span>
<span class="gi">+                dyn_kwargs = self.parse_expression()</span>
<span class="gi">+            else:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    self.stream.current.type == &quot;name&quot;</span>
<span class="gi">+                    and self.stream.look().type == &quot;assign&quot;</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Parsing a kwarg</span>
<span class="gi">+                    ensure(dyn_kwargs is None)</span>
<span class="gi">+                    key = self.stream.current.value</span>
<span class="gi">+                    self.stream.skip(2)</span>
<span class="gi">+                    value = self.parse_expression()</span>
<span class="gi">+                    kwargs.append(nodes.Keyword(key, value, lineno=value.lineno))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Parsing an arg</span>
<span class="gi">+                    ensure(dyn_args is None and dyn_kwargs is None and not kwargs)</span>
<span class="gi">+                    args.append(self.parse_expression())</span>
<span class="gi">+</span>
<span class="gi">+            require_comma = True</span>
<span class="gi">+</span>
<span class="gi">+        self.stream.expect(&quot;rparen&quot;)</span>
<span class="gi">+        return args, kwargs, dyn_args, dyn_kwargs</span>
<span class="gi">+</span>
<span class="gi">+    def parse_call(self, node: nodes.Expr) -&gt; nodes.Call:</span>
<span class="gi">+        # The lparen will be expected in parse_call_args, but the lineno</span>
<span class="gi">+        # needs to be recorded before the stream is advanced.</span>
<span class="gi">+        token = self.stream.current</span>
<span class="gi">+        args, kwargs, dyn_args, dyn_kwargs = self.parse_call_args()</span>
<span class="gi">+        return nodes.Call(node, args, kwargs, dyn_args, dyn_kwargs, lineno=token.lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_filter(</span>
<span class="gi">+        self, node: t.Optional[nodes.Expr], start_inline: bool = False</span>
<span class="gi">+    ) -&gt; t.Optional[nodes.Expr]:</span>
<span class="gi">+        while self.stream.current.type == &quot;pipe&quot; or start_inline:</span>
<span class="gi">+            if not start_inline:</span>
<span class="gi">+                next(self.stream)</span>
<span class="gi">+            token = self.stream.expect(&quot;name&quot;)</span>
<span class="gi">+            name = token.value</span>
<span class="gi">+            while self.stream.current.type == &quot;dot&quot;:</span>
<span class="gi">+                next(self.stream)</span>
<span class="gi">+                name += &quot;.&quot; + self.stream.expect(&quot;name&quot;).value</span>
<span class="gi">+            if self.stream.current.type == &quot;lparen&quot;:</span>
<span class="gi">+                args, kwargs, dyn_args, dyn_kwargs = self.parse_call_args()</span>
<span class="gi">+            else:</span>
<span class="gi">+                args = []</span>
<span class="gi">+                kwargs = []</span>
<span class="gi">+                dyn_args = dyn_kwargs = None</span>
<span class="gi">+            node = nodes.Filter(</span>
<span class="gi">+                node, name, args, kwargs, dyn_args, dyn_kwargs, lineno=token.lineno</span>
<span class="gi">+            )</span>
<span class="gi">+            start_inline = False</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def parse_test(self, node: nodes.Expr) -&gt; nodes.Expr:</span>
<span class="gi">+        token = next(self.stream)</span>
<span class="gi">+        if self.stream.current.test(&quot;name:not&quot;):</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            negated = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            negated = False</span>
<span class="gi">+        name = self.stream.expect(&quot;name&quot;).value</span>
<span class="gi">+        while self.stream.current.type == &quot;dot&quot;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            name += &quot;.&quot; + self.stream.expect(&quot;name&quot;).value</span>
<span class="gi">+        dyn_args = dyn_kwargs = None</span>
<span class="gi">+        kwargs: t.List[nodes.Keyword] = []</span>
<span class="gi">+        if self.stream.current.type == &quot;lparen&quot;:</span>
<span class="gi">+            args, kwargs, dyn_args, dyn_kwargs = self.parse_call_args()</span>
<span class="gi">+        elif self.stream.current.type in {</span>
<span class="gi">+            &quot;name&quot;,</span>
<span class="gi">+            &quot;string&quot;,</span>
<span class="gi">+            &quot;integer&quot;,</span>
<span class="gi">+            &quot;float&quot;,</span>
<span class="gi">+            &quot;lparen&quot;,</span>
<span class="gi">+            &quot;lbracket&quot;,</span>
<span class="gi">+            &quot;lbrace&quot;,</span>
<span class="gi">+        } and not self.stream.current.test_any(&quot;name:else&quot;, &quot;name:or&quot;, &quot;name:and&quot;):</span>
<span class="gi">+            if self.stream.current.test(&quot;name:is&quot;):</span>
<span class="gi">+                self.fail(&quot;You cannot chain multiple tests with is&quot;)</span>
<span class="gi">+            arg_node = self.parse_primary()</span>
<span class="gi">+            arg_node = self.parse_postfix(arg_node)</span>
<span class="gi">+            args = [arg_node]</span>
<span class="gi">+        else:</span>
<span class="gi">+            args = []</span>
<span class="gi">+        node = nodes.Test(</span>
<span class="gi">+            node, name, args, kwargs, dyn_args, dyn_kwargs, lineno=token.lineno</span>
<span class="gi">+        )</span>
<span class="gi">+        if negated:</span>
<span class="gi">+            node = nodes.Not(node, lineno=token.lineno)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def subparse(</span>
<span class="gi">+        self, end_tokens: t.Optional[t.Tuple[str, ...]] = None</span>
<span class="gi">+    ) -&gt; t.List[nodes.Node]:</span>
<span class="gi">+        body: t.List[nodes.Node] = []</span>
<span class="gi">+        data_buffer: t.List[nodes.Node] = []</span>
<span class="gi">+        add_data = data_buffer.append</span>
<span class="gi">+</span>
<span class="gi">+        if end_tokens is not None:</span>
<span class="gi">+            self._end_token_stack.append(end_tokens)</span>
<span class="gi">+</span>
<span class="gi">+        def flush_data() -&gt; None:</span>
<span class="gi">+            if data_buffer:</span>
<span class="gi">+                lineno = data_buffer[0].lineno</span>
<span class="gi">+                body.append(nodes.Output(data_buffer[:], lineno=lineno))</span>
<span class="gi">+                del data_buffer[:]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            while self.stream:</span>
<span class="gi">+                token = self.stream.current</span>
<span class="gi">+                if token.type == &quot;data&quot;:</span>
<span class="gi">+                    if token.value:</span>
<span class="gi">+                        add_data(nodes.TemplateData(token.value, lineno=token.lineno))</span>
<span class="gi">+                    next(self.stream)</span>
<span class="gi">+                elif token.type == &quot;variable_begin&quot;:</span>
<span class="gi">+                    next(self.stream)</span>
<span class="gi">+                    add_data(self.parse_tuple(with_condexpr=True))</span>
<span class="gi">+                    self.stream.expect(&quot;variable_end&quot;)</span>
<span class="gi">+                elif token.type == &quot;block_begin&quot;:</span>
<span class="gi">+                    flush_data()</span>
<span class="gi">+                    next(self.stream)</span>
<span class="gi">+                    if end_tokens is not None and self.stream.current.test_any(</span>
<span class="gi">+                        *end_tokens</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return body</span>
<span class="gi">+                    rv = self.parse_statement()</span>
<span class="gi">+                    if isinstance(rv, list):</span>
<span class="gi">+                        body.extend(rv)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        body.append(rv)</span>
<span class="gi">+                    self.stream.expect(&quot;block_end&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise AssertionError(&quot;internal parsing error&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            flush_data()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if end_tokens is not None:</span>
<span class="gi">+                self._end_token_stack.pop()</span>
<span class="gi">+        return body</span>

<span class="gd">-    def parse(self) -&gt;nodes.Template:</span>
<span class="gi">+    def parse(self) -&gt; nodes.Template:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the whole template into a `Template` node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = nodes.Template(self.subparse(), lineno=1)</span>
<span class="gi">+        result.set_environment(self.environment)</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/src/jinja2/runtime.py b/src/jinja2/runtime.py</span>
<span class="gh">index c88211d..4325c8d 100644</span>
<span class="gd">--- a/src/jinja2/runtime.py</span>
<span class="gi">+++ b/src/jinja2/runtime.py</span>
<span class="gu">@@ -1,82 +1,144 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The runtime functions and state used by compiled templates.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>import sys
<span class="w"> </span>import typing as t
<span class="w"> </span>from collections import abc
<span class="w"> </span>from itertools import chain
<span class="gd">-from markupsafe import escape</span>
<span class="gi">+</span>
<span class="gi">+from markupsafe import escape  # noqa: F401</span>
<span class="w"> </span>from markupsafe import Markup
<span class="w"> </span>from markupsafe import soft_str
<span class="gi">+</span>
<span class="w"> </span>from .async_utils import auto_aiter
<span class="gd">-from .async_utils import auto_await</span>
<span class="gd">-from .exceptions import TemplateNotFound</span>
<span class="gd">-from .exceptions import TemplateRuntimeError</span>
<span class="gi">+from .async_utils import auto_await  # noqa: F401</span>
<span class="gi">+from .exceptions import TemplateNotFound  # noqa: F401</span>
<span class="gi">+from .exceptions import TemplateRuntimeError  # noqa: F401</span>
<span class="w"> </span>from .exceptions import UndefinedError
<span class="w"> </span>from .nodes import EvalContext
<span class="w"> </span>from .utils import _PassArg
<span class="w"> </span>from .utils import concat
<span class="w"> </span>from .utils import internalcode
<span class="w"> </span>from .utils import missing
<span class="gd">-from .utils import Namespace</span>
<span class="gi">+from .utils import Namespace  # noqa: F401</span>
<span class="w"> </span>from .utils import object_type_repr
<span class="w"> </span>from .utils import pass_eval_context
<span class="gd">-V = t.TypeVar(&#39;V&#39;)</span>
<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+</span>
<span class="gi">+V = t.TypeVar(&quot;V&quot;)</span>
<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import logging
<span class="gi">+</span>
<span class="w"> </span>    import typing_extensions as te
<span class="gd">-    from .environment import Environment</span>

<span class="gi">+    from .environment import Environment</span>

<span class="w"> </span>    class LoopRenderFunc(te.Protocol):
<span class="gd">-</span>
<span class="gd">-        def __call__(self, reciter: t.Iterable[V], loop_render_func:</span>
<span class="gd">-            &#39;LoopRenderFunc&#39;, depth: int=0) -&gt;str:</span>
<span class="gd">-            ...</span>
<span class="gd">-exported = [&#39;LoopContext&#39;, &#39;TemplateReference&#39;, &#39;Macro&#39;, &#39;Markup&#39;,</span>
<span class="gd">-    &#39;TemplateRuntimeError&#39;, &#39;missing&#39;, &#39;escape&#39;, &#39;markup_join&#39;, &#39;str_join&#39;,</span>
<span class="gd">-    &#39;identity&#39;, &#39;TemplateNotFound&#39;, &#39;Namespace&#39;, &#39;Undefined&#39;, &#39;internalcode&#39;]</span>
<span class="gd">-async_exported = [&#39;AsyncLoopContext&#39;, &#39;auto_aiter&#39;, &#39;auto_await&#39;]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def identity(x: V) -&gt;V:</span>
<span class="gi">+        def __call__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            reciter: t.Iterable[V],</span>
<span class="gi">+            loop_render_func: &quot;LoopRenderFunc&quot;,</span>
<span class="gi">+            depth: int = 0,</span>
<span class="gi">+        ) -&gt; str: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# these variables are exported to the template runtime</span>
<span class="gi">+exported = [</span>
<span class="gi">+    &quot;LoopContext&quot;,</span>
<span class="gi">+    &quot;TemplateReference&quot;,</span>
<span class="gi">+    &quot;Macro&quot;,</span>
<span class="gi">+    &quot;Markup&quot;,</span>
<span class="gi">+    &quot;TemplateRuntimeError&quot;,</span>
<span class="gi">+    &quot;missing&quot;,</span>
<span class="gi">+    &quot;escape&quot;,</span>
<span class="gi">+    &quot;markup_join&quot;,</span>
<span class="gi">+    &quot;str_join&quot;,</span>
<span class="gi">+    &quot;identity&quot;,</span>
<span class="gi">+    &quot;TemplateNotFound&quot;,</span>
<span class="gi">+    &quot;Namespace&quot;,</span>
<span class="gi">+    &quot;Undefined&quot;,</span>
<span class="gi">+    &quot;internalcode&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+async_exported = [</span>
<span class="gi">+    &quot;AsyncLoopContext&quot;,</span>
<span class="gi">+    &quot;auto_aiter&quot;,</span>
<span class="gi">+    &quot;auto_await&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def identity(x: V) -&gt; V:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns its argument. Useful for certain things in the
<span class="w"> </span>    environment.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return x</span>


<span class="gd">-def markup_join(seq: t.Iterable[t.Any]) -&gt;str:</span>
<span class="gi">+def markup_join(seq: t.Iterable[t.Any]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Concatenation that escapes if necessary and converts to string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    buf = []</span>
<span class="gi">+    iterator = map(soft_str, seq)</span>
<span class="gi">+    for arg in iterator:</span>
<span class="gi">+        buf.append(arg)</span>
<span class="gi">+        if hasattr(arg, &quot;__html__&quot;):</span>
<span class="gi">+            return Markup(&quot;&quot;).join(chain(buf, iterator))</span>
<span class="gi">+    return concat(buf)</span>


<span class="gd">-def str_join(seq: t.Iterable[t.Any]) -&gt;str:</span>
<span class="gi">+def str_join(seq: t.Iterable[t.Any]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Simple args to string conversion and concatenation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def new_context(environment: &#39;Environment&#39;, template_name: t.Optional[str],</span>
<span class="gd">-    blocks: t.Dict[str, t.Callable[[&#39;Context&#39;], t.Iterator[str]]], vars: t.</span>
<span class="gd">-    Optional[t.Dict[str, t.Any]]=None, shared: bool=False, globals: t.</span>
<span class="gd">-    Optional[t.MutableMapping[str, t.Any]]=None, locals: t.Optional[t.</span>
<span class="gd">-    Mapping[str, t.Any]]=None) -&gt;&#39;Context&#39;:</span>
<span class="gi">+    return concat(map(str, seq))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def new_context(</span>
<span class="gi">+    environment: &quot;Environment&quot;,</span>
<span class="gi">+    template_name: t.Optional[str],</span>
<span class="gi">+    blocks: t.Dict[str, t.Callable[[&quot;Context&quot;], t.Iterator[str]]],</span>
<span class="gi">+    vars: t.Optional[t.Dict[str, t.Any]] = None,</span>
<span class="gi">+    shared: bool = False,</span>
<span class="gi">+    globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    locals: t.Optional[t.Mapping[str, t.Any]] = None,</span>
<span class="gi">+) -&gt; &quot;Context&quot;:</span>
<span class="w"> </span>    &quot;&quot;&quot;Internal helper for context creation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if vars is None:</span>
<span class="gi">+        vars = {}</span>
<span class="gi">+    if shared:</span>
<span class="gi">+        parent = vars</span>
<span class="gi">+    else:</span>
<span class="gi">+        parent = dict(globals or (), **vars)</span>
<span class="gi">+    if locals:</span>
<span class="gi">+        # if the parent is shared a copy should be created because</span>
<span class="gi">+        # we don&#39;t want to modify the dict passed</span>
<span class="gi">+        if shared:</span>
<span class="gi">+            parent = dict(parent)</span>
<span class="gi">+        for key, value in locals.items():</span>
<span class="gi">+            if value is not missing:</span>
<span class="gi">+                parent[key] = value</span>
<span class="gi">+    return environment.context_class(</span>
<span class="gi">+        environment, parent, template_name, blocks, globals=globals</span>
<span class="gi">+    )</span>


<span class="w"> </span>class TemplateReference:
<span class="w"> </span>    &quot;&quot;&quot;The `self` in templates.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, context: &#39;Context&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, context: &quot;Context&quot;) -&gt; None:</span>
<span class="w"> </span>        self.__context = context

<span class="gd">-    def __getitem__(self, name: str) -&gt;t.Any:</span>
<span class="gi">+    def __getitem__(self, name: str) -&gt; t.Any:</span>
<span class="w"> </span>        blocks = self.__context.blocks[name]
<span class="w"> </span>        return BlockReference(name, self.__context, blocks, 0)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self.__context.name!r}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self.__context.name!r}&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _dict_method_all(dict_method: F) -&gt; F:</span>
<span class="gi">+    @functools.wraps(dict_method)</span>
<span class="gi">+    def f_all(self: &quot;Context&quot;) -&gt; t.Any:</span>
<span class="gi">+        return dict_method(self.get_all())</span>
<span class="gi">+</span>
<span class="gi">+    return t.cast(F, f_all)</span>


<span class="w"> </span>@abc.Mapping.register
<span class="gu">@@ -100,34 +162,54 @@ class Context:</span>
<span class="w"> </span>    :class:`Undefined` object for missing variables.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, environment: &#39;Environment&#39;, parent: t.Dict[str, t.</span>
<span class="gd">-        Any], name: t.Optional[str], blocks: t.Dict[str, t.Callable[[</span>
<span class="gd">-        &#39;Context&#39;], t.Iterator[str]]], globals: t.Optional[t.MutableMapping</span>
<span class="gd">-        [str, t.Any]]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        environment: &quot;Environment&quot;,</span>
<span class="gi">+        parent: t.Dict[str, t.Any],</span>
<span class="gi">+        name: t.Optional[str],</span>
<span class="gi">+        blocks: t.Dict[str, t.Callable[[&quot;Context&quot;], t.Iterator[str]]],</span>
<span class="gi">+        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.parent = parent
<span class="w"> </span>        self.vars: t.Dict[str, t.Any] = {}
<span class="gd">-        self.environment: &#39;Environment&#39; = environment</span>
<span class="gi">+        self.environment: &quot;Environment&quot; = environment</span>
<span class="w"> </span>        self.eval_ctx = EvalContext(self.environment, name)
<span class="w"> </span>        self.exported_vars: t.Set[str] = set()
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.globals_keys = set() if globals is None else set(globals)
<span class="gi">+</span>
<span class="gi">+        # create the initial mapping of blocks.  Whenever template inheritance</span>
<span class="gi">+        # takes place the runtime will update this mapping with the new blocks</span>
<span class="gi">+        # from the template.</span>
<span class="w"> </span>        self.blocks = {k: [v] for k, v in blocks.items()}

<span class="gd">-    def super(self, name: str, current: t.Callable[[&#39;Context&#39;], t.Iterator[</span>
<span class="gd">-        str]]) -&gt;t.Union[&#39;BlockReference&#39;, &#39;Undefined&#39;]:</span>
<span class="gi">+    def super(</span>
<span class="gi">+        self, name: str, current: t.Callable[[&quot;Context&quot;], t.Iterator[str]]</span>
<span class="gi">+    ) -&gt; t.Union[&quot;BlockReference&quot;, &quot;Undefined&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Render a parent block.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get(self, key: str, default: t.Any=None) -&gt;t.Any:</span>
<span class="gi">+        try:</span>
<span class="gi">+            blocks = self.blocks[name]</span>
<span class="gi">+            index = blocks.index(current) + 1</span>
<span class="gi">+            blocks[index]</span>
<span class="gi">+        except LookupError:</span>
<span class="gi">+            return self.environment.undefined(</span>
<span class="gi">+                f&quot;there is no parent block called {name!r}.&quot;, name=&quot;super&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return BlockReference(name, self, blocks, index)</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, key: str, default: t.Any = None) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look up a variable by name, or return a default if the key is
<span class="w"> </span>        not found.

<span class="w"> </span>        :param key: The variable name to look up.
<span class="w"> </span>        :param default: The value to return if the key is not found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return default</span>

<span class="gd">-    def resolve(self, key: str) -&gt;t.Union[t.Any, &#39;Undefined&#39;]:</span>
<span class="gi">+    def resolve(self, key: str) -&gt; t.Union[t.Any, &quot;Undefined&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look up a variable by name, or return an :class:`Undefined`
<span class="w"> </span>        object if the key is not found.

<span class="gu">@@ -137,9 +219,14 @@ class Context:</span>

<span class="w"> </span>        :param key: The variable name to look up.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = self.resolve_or_missing(key)</span>
<span class="gi">+</span>
<span class="gi">+        if rv is missing:</span>
<span class="gi">+            return self.environment.undefined(name=key)</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>

<span class="gd">-    def resolve_or_missing(self, key: str) -&gt;t.Any:</span>
<span class="gi">+    def resolve_or_missing(self, key: str) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look up a variable by name, or return a ``missing`` sentinel
<span class="w"> </span>        if the key is not found.

<span class="gu">@@ -149,77 +236,156 @@ class Context:</span>

<span class="w"> </span>        :param key: The variable name to look up.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key in self.vars:</span>
<span class="gi">+            return self.vars[key]</span>
<span class="gi">+</span>
<span class="gi">+        if key in self.parent:</span>
<span class="gi">+            return self.parent[key]</span>

<span class="gd">-    def get_exported(self) -&gt;t.Dict[str, t.Any]:</span>
<span class="gi">+        return missing</span>
<span class="gi">+</span>
<span class="gi">+    def get_exported(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a new dict with the exported variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {k: self.vars[k] for k in self.exported_vars}</span>

<span class="gd">-    def get_all(self) -&gt;t.Dict[str, t.Any]:</span>
<span class="gi">+    def get_all(self) -&gt; t.Dict[str, t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the complete context as dict including the exported
<span class="w"> </span>        variables.  For optimizations reasons this might not return an
<span class="w"> </span>        actual copy so be careful with using it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.vars:</span>
<span class="gi">+            return self.parent</span>
<span class="gi">+        if not self.parent:</span>
<span class="gi">+            return self.vars</span>
<span class="gi">+        return dict(self.parent, **self.vars)</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def call(__self, __obj: t.Callable[..., t.Any], *args: t.Any, **kwargs:</span>
<span class="gd">-        t.Any) -&gt;t.Union[t.Any, &#39;Undefined&#39;]:</span>
<span class="gi">+    def call(</span>
<span class="gi">+        __self,</span>
<span class="gi">+        __obj: t.Callable[..., t.Any],</span>
<span class="gi">+        *args: t.Any,</span>
<span class="gi">+        **kwargs: t.Any,  # noqa: B902</span>
<span class="gi">+    ) -&gt; t.Union[t.Any, &quot;Undefined&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call the callable with the arguments and keyword arguments
<span class="w"> </span>        provided but inject the active context or environment as first
<span class="w"> </span>        argument if the callable has :func:`pass_context` or
<span class="w"> </span>        :func:`pass_environment`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def derived(self, locals: t.Optional[t.Dict[str, t.Any]]=None) -&gt;&#39;Context&#39;:</span>
<span class="gi">+        if __debug__:</span>
<span class="gi">+            __traceback_hide__ = True  # noqa</span>
<span class="gi">+</span>
<span class="gi">+        # Allow callable classes to take a context</span>
<span class="gi">+        if (</span>
<span class="gi">+            hasattr(__obj, &quot;__call__&quot;)  # noqa: B004</span>
<span class="gi">+            and _PassArg.from_obj(__obj.__call__) is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            __obj = __obj.__call__</span>
<span class="gi">+</span>
<span class="gi">+        pass_arg = _PassArg.from_obj(__obj)</span>
<span class="gi">+</span>
<span class="gi">+        if pass_arg is _PassArg.context:</span>
<span class="gi">+            # the active context should have access to variables set in</span>
<span class="gi">+            # loops and blocks without mutating the context itself</span>
<span class="gi">+            if kwargs.get(&quot;_loop_vars&quot;):</span>
<span class="gi">+                __self = __self.derived(kwargs[&quot;_loop_vars&quot;])</span>
<span class="gi">+            if kwargs.get(&quot;_block_vars&quot;):</span>
<span class="gi">+                __self = __self.derived(kwargs[&quot;_block_vars&quot;])</span>
<span class="gi">+            args = (__self,) + args</span>
<span class="gi">+        elif pass_arg is _PassArg.eval_context:</span>
<span class="gi">+            args = (__self.eval_ctx,) + args</span>
<span class="gi">+        elif pass_arg is _PassArg.environment:</span>
<span class="gi">+            args = (__self.environment,) + args</span>
<span class="gi">+</span>
<span class="gi">+        kwargs.pop(&quot;_block_vars&quot;, None)</span>
<span class="gi">+        kwargs.pop(&quot;_loop_vars&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return __obj(*args, **kwargs)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            return __self.environment.undefined(</span>
<span class="gi">+                &quot;value was undefined because a callable raised a&quot;</span>
<span class="gi">+                &quot; StopIteration exception&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def derived(self, locals: t.Optional[t.Dict[str, t.Any]] = None) -&gt; &quot;Context&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Internal helper function to create a derived context.  This is
<span class="w"> </span>        used in situations where the system needs a new context in the same
<span class="w"> </span>        template that is independent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        context = new_context(</span>
<span class="gi">+            self.environment, self.name, {}, self.get_all(), True, None, locals</span>
<span class="gi">+        )</span>
<span class="gi">+        context.eval_ctx = self.eval_ctx</span>
<span class="gi">+        context.blocks.update((k, list(v)) for k, v in self.blocks.items())</span>
<span class="gi">+        return context</span>
<span class="gi">+</span>
<span class="w"> </span>    keys = _dict_method_all(dict.keys)
<span class="w"> </span>    values = _dict_method_all(dict.values)
<span class="w"> </span>    items = _dict_method_all(dict.items)

<span class="gd">-    def __contains__(self, name: str) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, name: str) -&gt; bool:</span>
<span class="w"> </span>        return name in self.vars or name in self.parent

<span class="gd">-    def __getitem__(self, key: str) -&gt;t.Any:</span>
<span class="gi">+    def __getitem__(self, key: str) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look up a variable by name with ``[]`` syntax, or raise a
<span class="w"> </span>        ``KeyError`` if the key is not found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        item = self.resolve_or_missing(key)
<span class="gi">+</span>
<span class="w"> </span>        if item is missing:
<span class="w"> </span>            raise KeyError(key)
<span class="gi">+</span>
<span class="w"> </span>        return item

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self.get_all()!r} of {self.name!r}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self.get_all()!r} of {self.name!r}&gt;&quot;</span>


<span class="w"> </span>class BlockReference:
<span class="w"> </span>    &quot;&quot;&quot;One block on a template reference.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str, context: &#39;Context&#39;, stack: t.List[t.</span>
<span class="gd">-        Callable[[&#39;Context&#39;], t.Iterator[str]]], depth: int) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        context: &quot;Context&quot;,</span>
<span class="gi">+        stack: t.List[t.Callable[[&quot;Context&quot;], t.Iterator[str]]],</span>
<span class="gi">+        depth: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self._context = context
<span class="w"> </span>        self._stack = stack
<span class="w"> </span>        self._depth = depth

<span class="w"> </span>    @property
<span class="gd">-    def super(self) -&gt;t.Union[&#39;BlockReference&#39;, &#39;Undefined&#39;]:</span>
<span class="gi">+    def super(self) -&gt; t.Union[&quot;BlockReference&quot;, &quot;Undefined&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Super the block.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._depth + 1 &gt;= len(self._stack):</span>
<span class="gi">+            return self._context.environment.undefined(</span>
<span class="gi">+                f&quot;there is no parent block called {self.name!r}.&quot;, name=&quot;super&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return BlockReference(self.name, self._context, self._stack, self._depth + 1)</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def __call__(self) -&gt;str:</span>
<span class="gi">+    async def _async_call(self) -&gt; str:</span>
<span class="gi">+        rv = concat(</span>
<span class="gi">+            [x async for x in self._stack[self._depth](self._context)]  # type: ignore</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self._context.eval_ctx.autoescape:</span>
<span class="gi">+            return Markup(rv)</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    @internalcode</span>
<span class="gi">+    def __call__(self) -&gt; str:</span>
<span class="w"> </span>        if self._context.environment.is_async:
<span class="gd">-            return self._async_call()</span>
<span class="gi">+            return self._async_call()  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>        rv = concat(self._stack[self._depth](self._context))
<span class="gi">+</span>
<span class="w"> </span>        if self._context.eval_ctx.autoescape:
<span class="w"> </span>            return Markup(rv)
<span class="gi">+</span>
<span class="w"> </span>        return rv


<span class="gu">@@ -227,16 +393,23 @@ class LoopContext:</span>
<span class="w"> </span>    &quot;&quot;&quot;A wrapper iterable for dynamic ``for`` loops, with information
<span class="w"> </span>    about the loop and iteration.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: Current iteration of the loop, starting at 0.</span>
<span class="w"> </span>    index0 = -1
<span class="gi">+</span>
<span class="w"> </span>    _length: t.Optional[int] = None
<span class="w"> </span>    _after: t.Any = missing
<span class="w"> </span>    _current: t.Any = missing
<span class="w"> </span>    _before: t.Any = missing
<span class="w"> </span>    _last_changed_value: t.Any = missing

<span class="gd">-    def __init__(self, iterable: t.Iterable[V], undefined: t.Type[</span>
<span class="gd">-        &#39;Undefined&#39;], recurse: t.Optional[&#39;LoopRenderFunc&#39;]=None, depth0: int=0</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        iterable: t.Iterable[V],</span>
<span class="gi">+        undefined: t.Type[&quot;Undefined&quot;],</span>
<span class="gi">+        recurse: t.Optional[&quot;LoopRenderFunc&quot;] = None,</span>
<span class="gi">+        depth0: int = 0,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param iterable: Iterable to wrap.
<span class="w"> </span>        :param undefined: :class:`Undefined` class to use for next and
<span class="gu">@@ -249,78 +422,100 @@ class LoopContext:</span>
<span class="w"> </span>        self._iterator = self._to_iterator(iterable)
<span class="w"> </span>        self._undefined = undefined
<span class="w"> </span>        self._recurse = recurse
<span class="gi">+        #: How many levels deep a recursive loop currently is, starting at 0.</span>
<span class="w"> </span>        self.depth0 = depth0

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _to_iterator(iterable: t.Iterable[V]) -&gt; t.Iterator[V]:</span>
<span class="gi">+        return iter(iterable)</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="gd">-    def length(self) -&gt;int:</span>
<span class="gi">+    def length(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Length of the iterable.

<span class="w"> </span>        If the iterable is a generator or otherwise does not have a
<span class="w"> </span>        size, it is eagerly evaluated to get a size.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._length is not None:</span>
<span class="gi">+            return self._length</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._length = len(self._iterable)  # type: ignore</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            iterable = list(self._iterator)</span>
<span class="gi">+            self._iterator = self._to_iterator(iterable)</span>
<span class="gi">+            self._length = len(iterable) + self.index + (self._after is not missing)</span>

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+        return self._length</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return self.length

<span class="w"> </span>    @property
<span class="gd">-    def depth(self) -&gt;int:</span>
<span class="gi">+    def depth(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;How many levels deep a recursive loop currently is, starting at 1.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.depth0 + 1</span>

<span class="w"> </span>    @property
<span class="gd">-    def index(self) -&gt;int:</span>
<span class="gi">+    def index(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Current iteration of the loop, starting at 1.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.index0 + 1</span>

<span class="w"> </span>    @property
<span class="gd">-    def revindex0(self) -&gt;int:</span>
<span class="gi">+    def revindex0(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Number of iterations from the end of the loop, ending at 0.

<span class="w"> </span>        Requires calculating :attr:`length`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.length - self.index</span>

<span class="w"> </span>    @property
<span class="gd">-    def revindex(self) -&gt;int:</span>
<span class="gi">+    def revindex(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Number of iterations from the end of the loop, ending at 1.

<span class="w"> </span>        Requires calculating :attr:`length`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.length - self.index0</span>

<span class="w"> </span>    @property
<span class="gd">-    def first(self) -&gt;bool:</span>
<span class="gi">+    def first(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether this is the first iteration of the loop.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.index0 == 0</span>

<span class="gd">-    def _peek_next(self) -&gt;t.Any:</span>
<span class="gi">+    def _peek_next(self) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the next element in the iterable, or :data:`missing`
<span class="w"> </span>        if the iterable is exhausted. Only peeks one item ahead, caching
<span class="w"> </span>        the result in :attr:`_last` for use in subsequent checks. The
<span class="w"> </span>        cache is reset when :meth:`__next__` is called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._after is not missing:</span>
<span class="gi">+            return self._after</span>
<span class="gi">+</span>
<span class="gi">+        self._after = next(self._iterator, missing)</span>
<span class="gi">+        return self._after</span>

<span class="w"> </span>    @property
<span class="gd">-    def last(self) -&gt;bool:</span>
<span class="gi">+    def last(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Whether this is the last iteration of the loop.

<span class="w"> </span>        Causes the iterable to advance early. See
<span class="w"> </span>        :func:`itertools.groupby` for issues this can cause.
<span class="w"> </span>        The :func:`groupby` filter avoids that issue.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._peek_next() is missing</span>

<span class="w"> </span>    @property
<span class="gd">-    def previtem(self) -&gt;t.Union[t.Any, &#39;Undefined&#39;]:</span>
<span class="gi">+    def previtem(self) -&gt; t.Union[t.Any, &quot;Undefined&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The item in the previous iteration. Undefined during the
<span class="w"> </span>        first iteration.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.first:</span>
<span class="gi">+            return self._undefined(&quot;there is no previous item&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self._before</span>

<span class="w"> </span>    @property
<span class="gd">-    def nextitem(self) -&gt;t.Union[t.Any, &#39;Undefined&#39;]:</span>
<span class="gi">+    def nextitem(self) -&gt; t.Union[t.Any, &quot;Undefined&quot;]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The item in the next iteration. Undefined during the last
<span class="w"> </span>        iteration.

<span class="gu">@@ -328,40 +523,53 @@ class LoopContext:</span>
<span class="w"> </span>        :func:`itertools.groupby` for issues this can cause.
<span class="w"> </span>        The :func:`jinja-filters.groupby` filter avoids that issue.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = self._peek_next()</span>
<span class="gi">+</span>
<span class="gi">+        if rv is missing:</span>
<span class="gi">+            return self._undefined(&quot;there is no next item&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>

<span class="gd">-    def cycle(self, *args: V) -&gt;V:</span>
<span class="gi">+    def cycle(self, *args: V) -&gt; V:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a value from the given args, cycling through based on
<span class="w"> </span>        the current :attr:`index0`.

<span class="w"> </span>        :param args: One or more values to cycle through.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            raise TypeError(&quot;no items for cycling given&quot;)</span>

<span class="gd">-    def changed(self, *value: t.Any) -&gt;bool:</span>
<span class="gi">+        return args[self.index0 % len(args)]</span>
<span class="gi">+</span>
<span class="gi">+    def changed(self, *value: t.Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return ``True`` if previously called with a different value
<span class="w"> </span>        (including when called for the first time).

<span class="w"> </span>        :param value: One or more values to compare to the last call.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._last_changed_value != value:</span>
<span class="gi">+            self._last_changed_value = value</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>

<span class="gd">-    def __iter__(self) -&gt;&#39;LoopContext&#39;:</span>
<span class="gi">+    def __iter__(self) -&gt; &quot;LoopContext&quot;:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __next__(self) -&gt;t.Tuple[t.Any, &#39;LoopContext&#39;]:</span>
<span class="gi">+    def __next__(self) -&gt; t.Tuple[t.Any, &quot;LoopContext&quot;]:</span>
<span class="w"> </span>        if self._after is not missing:
<span class="w"> </span>            rv = self._after
<span class="w"> </span>            self._after = missing
<span class="w"> </span>        else:
<span class="w"> </span>            rv = next(self._iterator)
<span class="gi">+</span>
<span class="w"> </span>        self.index0 += 1
<span class="w"> </span>        self._before = self._current
<span class="w"> </span>        self._current = rv
<span class="w"> </span>        return rv, self

<span class="w"> </span>    @internalcode
<span class="gd">-    def __call__(self, iterable: t.Iterable[V]) -&gt;str:</span>
<span class="gi">+    def __call__(self, iterable: t.Iterable[V]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;When iterating over nested data, render the body of the loop
<span class="w"> </span>        recursively with the given inner iterable data.

<span class="gu">@@ -370,25 +578,79 @@ class LoopContext:</span>
<span class="w"> </span>        if self._recurse is None:
<span class="w"> </span>            raise TypeError(
<span class="w"> </span>                &quot;The loop must have the &#39;recursive&#39; marker to be called recursively.&quot;
<span class="gd">-                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        return self._recurse(iterable, self._recurse, depth=self.depth)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self.index}/{self.length}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self.index}/{self.length}&gt;&quot;</span>


<span class="w"> </span>class AsyncLoopContext(LoopContext):
<span class="gd">-    _iterator: t.AsyncIterator[t.Any]</span>
<span class="gi">+    _iterator: t.AsyncIterator[t.Any]  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _to_iterator(  # type: ignore</span>
<span class="gi">+        iterable: t.Union[t.Iterable[V], t.AsyncIterable[V]],</span>
<span class="gi">+    ) -&gt; t.AsyncIterator[V]:</span>
<span class="gi">+        return auto_aiter(iterable)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def length(self) -&gt; int:  # type: ignore</span>
<span class="gi">+        if self._length is not None:</span>
<span class="gi">+            return self._length</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._length = len(self._iterable)  # type: ignore</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            iterable = [x async for x in self._iterator]</span>
<span class="gi">+            self._iterator = self._to_iterator(iterable)</span>
<span class="gi">+            self._length = len(iterable) + self.index + (self._after is not missing)</span>
<span class="gi">+</span>
<span class="gi">+        return self._length</span>

<span class="gd">-    def __aiter__(self) -&gt;&#39;AsyncLoopContext&#39;:</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def revindex0(self) -&gt; int:  # type: ignore</span>
<span class="gi">+        return await self.length - self.index</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def revindex(self) -&gt; int:  # type: ignore</span>
<span class="gi">+        return await self.length - self.index0</span>
<span class="gi">+</span>
<span class="gi">+    async def _peek_next(self) -&gt; t.Any:</span>
<span class="gi">+        if self._after is not missing:</span>
<span class="gi">+            return self._after</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._after = await self._iterator.__anext__()</span>
<span class="gi">+        except StopAsyncIteration:</span>
<span class="gi">+            self._after = missing</span>
<span class="gi">+</span>
<span class="gi">+        return self._after</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def last(self) -&gt; bool:  # type: ignore</span>
<span class="gi">+        return await self._peek_next() is missing</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def nextitem(self) -&gt; t.Union[t.Any, &quot;Undefined&quot;]:</span>
<span class="gi">+        rv = await self._peek_next()</span>
<span class="gi">+</span>
<span class="gi">+        if rv is missing:</span>
<span class="gi">+            return self._undefined(&quot;there is no next item&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def __aiter__(self) -&gt; &quot;AsyncLoopContext&quot;:</span>
<span class="w"> </span>        return self

<span class="gd">-    async def __anext__(self) -&gt;t.Tuple[t.Any, &#39;AsyncLoopContext&#39;]:</span>
<span class="gi">+    async def __anext__(self) -&gt; t.Tuple[t.Any, &quot;AsyncLoopContext&quot;]:</span>
<span class="w"> </span>        if self._after is not missing:
<span class="w"> </span>            rv = self._after
<span class="w"> </span>            self._after = missing
<span class="w"> </span>        else:
<span class="w"> </span>            rv = await self._iterator.__anext__()
<span class="gi">+</span>
<span class="w"> </span>        self.index0 += 1
<span class="w"> </span>        self._before = self._current
<span class="w"> </span>        self._current = rv
<span class="gu">@@ -398,10 +660,17 @@ class AsyncLoopContext(LoopContext):</span>
<span class="w"> </span>class Macro:
<span class="w"> </span>    &quot;&quot;&quot;Wraps a macro function.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, environment: &#39;Environment&#39;, func: t.Callable[...,</span>
<span class="gd">-        str], name: str, arguments: t.List[str], catch_kwargs: bool,</span>
<span class="gd">-        catch_varargs: bool, caller: bool, default_autoescape: t.Optional[</span>
<span class="gd">-        bool]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        environment: &quot;Environment&quot;,</span>
<span class="gi">+        func: t.Callable[..., str],</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        arguments: t.List[str],</span>
<span class="gi">+        catch_kwargs: bool,</span>
<span class="gi">+        catch_varargs: bool,</span>
<span class="gi">+        caller: bool,</span>
<span class="gi">+        default_autoescape: t.Optional[bool] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self._environment = environment
<span class="w"> </span>        self._func = func
<span class="w"> </span>        self._argument_count = len(arguments)
<span class="gu">@@ -410,63 +679,116 @@ class Macro:</span>
<span class="w"> </span>        self.catch_kwargs = catch_kwargs
<span class="w"> </span>        self.catch_varargs = catch_varargs
<span class="w"> </span>        self.caller = caller
<span class="gd">-        self.explicit_caller = &#39;caller&#39; in arguments</span>
<span class="gi">+        self.explicit_caller = &quot;caller&quot; in arguments</span>
<span class="gi">+</span>
<span class="w"> </span>        if default_autoescape is None:
<span class="w"> </span>            if callable(environment.autoescape):
<span class="w"> </span>                default_autoescape = environment.autoescape(None)
<span class="w"> </span>            else:
<span class="w"> </span>                default_autoescape = environment.autoescape
<span class="gi">+</span>
<span class="w"> </span>        self._default_autoescape = default_autoescape

<span class="w"> </span>    @internalcode
<span class="w"> </span>    @pass_eval_context
<span class="gd">-    def __call__(self, *args: t.Any, **kwargs: t.Any) -&gt;str:</span>
<span class="gi">+    def __call__(self, *args: t.Any, **kwargs: t.Any) -&gt; str:</span>
<span class="gi">+        # This requires a bit of explanation,  In the past we used to</span>
<span class="gi">+        # decide largely based on compile-time information if a macro is</span>
<span class="gi">+        # safe or unsafe.  While there was a volatile mode it was largely</span>
<span class="gi">+        # unused for deciding on escaping.  This turns out to be</span>
<span class="gi">+        # problematic for macros because whether a macro is safe depends not</span>
<span class="gi">+        # on the escape mode when it was defined, but rather when it was used.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Because however we export macros from the module system and</span>
<span class="gi">+        # there are historic callers that do not pass an eval context (and</span>
<span class="gi">+        # will continue to not pass one), we need to perform an instance</span>
<span class="gi">+        # check here.</span>
<span class="gi">+        #</span>
<span class="gi">+        # This is considered safe because an eval context is not a valid</span>
<span class="gi">+        # argument to callables otherwise anyway.  Worst case here is</span>
<span class="gi">+        # that if no eval context is passed we fall back to the compile</span>
<span class="gi">+        # time autoescape flag.</span>
<span class="w"> </span>        if args and isinstance(args[0], EvalContext):
<span class="w"> </span>            autoescape = args[0].autoescape
<span class="w"> </span>            args = args[1:]
<span class="w"> </span>        else:
<span class="w"> </span>            autoescape = self._default_autoescape
<span class="gd">-        arguments = list(args[:self._argument_count])</span>
<span class="gi">+</span>
<span class="gi">+        # try to consume the positional arguments</span>
<span class="gi">+        arguments = list(args[: self._argument_count])</span>
<span class="w"> </span>        off = len(arguments)
<span class="gi">+</span>
<span class="gi">+        # For information why this is necessary refer to the handling</span>
<span class="gi">+        # of caller in the `macro_body` handler in the compiler.</span>
<span class="w"> </span>        found_caller = False
<span class="gi">+</span>
<span class="gi">+        # if the number of arguments consumed is not the number of</span>
<span class="gi">+        # arguments expected we start filling in keyword arguments</span>
<span class="gi">+        # and defaults.</span>
<span class="w"> </span>        if off != self._argument_count:
<span class="gd">-            for name in self.arguments[len(arguments):]:</span>
<span class="gi">+            for name in self.arguments[len(arguments) :]:</span>
<span class="w"> </span>                try:
<span class="w"> </span>                    value = kwargs.pop(name)
<span class="w"> </span>                except KeyError:
<span class="w"> </span>                    value = missing
<span class="gd">-                if name == &#39;caller&#39;:</span>
<span class="gi">+                if name == &quot;caller&quot;:</span>
<span class="w"> </span>                    found_caller = True
<span class="w"> </span>                arguments.append(value)
<span class="w"> </span>        else:
<span class="w"> </span>            found_caller = self.explicit_caller
<span class="gi">+</span>
<span class="gi">+        # it&#39;s important that the order of these arguments does not change</span>
<span class="gi">+        # if not also changed in the compiler&#39;s `function_scoping` method.</span>
<span class="gi">+        # the order is caller, keyword arguments, positional arguments!</span>
<span class="w"> </span>        if self.caller and not found_caller:
<span class="gd">-            caller = kwargs.pop(&#39;caller&#39;, None)</span>
<span class="gi">+            caller = kwargs.pop(&quot;caller&quot;, None)</span>
<span class="w"> </span>            if caller is None:
<span class="gd">-                caller = self._environment.undefined(&#39;No caller defined&#39;,</span>
<span class="gd">-                    name=&#39;caller&#39;)</span>
<span class="gi">+                caller = self._environment.undefined(&quot;No caller defined&quot;, name=&quot;caller&quot;)</span>
<span class="w"> </span>            arguments.append(caller)
<span class="gi">+</span>
<span class="w"> </span>        if self.catch_kwargs:
<span class="w"> </span>            arguments.append(kwargs)
<span class="w"> </span>        elif kwargs:
<span class="gd">-            if &#39;caller&#39; in kwargs:</span>
<span class="gi">+            if &quot;caller&quot; in kwargs:</span>
<span class="w"> </span>                raise TypeError(
<span class="gd">-                    f&#39;macro {self.name!r} was invoked with two values for the special caller argument. This is most likely a bug.&#39;</span>
<span class="gd">-                    )</span>
<span class="gd">-            raise TypeError(</span>
<span class="gd">-                f&#39;macro {self.name!r} takes no keyword argument {next(iter(kwargs))!r}&#39;</span>
<span class="gi">+                    f&quot;macro {self.name!r} was invoked with two values for the special&quot;</span>
<span class="gi">+                    &quot; caller argument. This is most likely a bug.&quot;</span>
<span class="w"> </span>                )
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&quot;macro {self.name!r} takes no keyword argument {next(iter(kwargs))!r}&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        if self.catch_varargs:
<span class="gd">-            arguments.append(args[self._argument_count:])</span>
<span class="gi">+            arguments.append(args[self._argument_count :])</span>
<span class="w"> </span>        elif len(args) &gt; self._argument_count:
<span class="w"> </span>            raise TypeError(
<span class="gd">-                f&#39;macro {self.name!r} takes not more than {len(self.arguments)} argument(s)&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;macro {self.name!r} takes not more than&quot;</span>
<span class="gi">+                f&quot; {len(self.arguments)} argument(s)&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        return self._invoke(arguments, autoescape)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        name = &#39;anonymous&#39; if self.name is None else repr(self.name)</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {name}&gt;&#39;</span>
<span class="gi">+    async def _async_invoke(self, arguments: t.List[t.Any], autoescape: bool) -&gt; str:</span>
<span class="gi">+        rv = await self._func(*arguments)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        if autoescape:</span>
<span class="gi">+            return Markup(rv)</span>
<span class="gi">+</span>
<span class="gi">+        return rv  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def _invoke(self, arguments: t.List[t.Any], autoescape: bool) -&gt; str:</span>
<span class="gi">+        if self._environment.is_async:</span>
<span class="gi">+            return self._async_invoke(arguments, autoescape)  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        rv = self._func(*arguments)</span>
<span class="gi">+</span>
<span class="gi">+        if autoescape:</span>
<span class="gi">+            rv = Markup(rv)</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        name = &quot;anonymous&quot; if self.name is None else repr(self.name)</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {name}&gt;&quot;</span>


<span class="w"> </span>class Undefined:
<span class="gu">@@ -483,37 +805,64 @@ class Undefined:</span>
<span class="w"> </span>      ...
<span class="w"> </span>    jinja2.exceptions.UndefinedError: &#39;foo&#39; is undefined
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;_undefined_hint&#39;, &#39;_undefined_obj&#39;, &#39;_undefined_name&#39;,</span>
<span class="gd">-        &#39;_undefined_exception&#39;)</span>

<span class="gd">-    def __init__(self, hint: t.Optional[str]=None, obj: t.Any=missing, name:</span>
<span class="gd">-        t.Optional[str]=None, exc: t.Type[TemplateRuntimeError]=UndefinedError</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &quot;_undefined_hint&quot;,</span>
<span class="gi">+        &quot;_undefined_obj&quot;,</span>
<span class="gi">+        &quot;_undefined_name&quot;,</span>
<span class="gi">+        &quot;_undefined_exception&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        hint: t.Optional[str] = None,</span>
<span class="gi">+        obj: t.Any = missing,</span>
<span class="gi">+        name: t.Optional[str] = None,</span>
<span class="gi">+        exc: t.Type[TemplateRuntimeError] = UndefinedError,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._undefined_hint = hint
<span class="w"> </span>        self._undefined_obj = obj
<span class="w"> </span>        self._undefined_name = name
<span class="w"> </span>        self._undefined_exception = exc

<span class="w"> </span>    @property
<span class="gd">-    def _undefined_message(self) -&gt;str:</span>
<span class="gi">+    def _undefined_message(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build a message about the undefined value based on how it was
<span class="w"> </span>        accessed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._undefined_hint:</span>
<span class="gi">+            return self._undefined_hint</span>
<span class="gi">+</span>
<span class="gi">+        if self._undefined_obj is missing:</span>
<span class="gi">+            return f&quot;{self._undefined_name!r} is undefined&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(self._undefined_name, str):</span>
<span class="gi">+            return (</span>
<span class="gi">+                f&quot;{object_type_repr(self._undefined_obj)} has no&quot;</span>
<span class="gi">+                f&quot; element {self._undefined_name!r}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            f&quot;{object_type_repr(self._undefined_obj)!r} has no&quot;</span>
<span class="gi">+            f&quot; attribute {self._undefined_name!r}&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def _fail_with_undefined_error(self, *args: t.Any, **kwargs: t.Any</span>
<span class="gd">-        ) -&gt;&#39;te.NoReturn&#39;:</span>
<span class="gi">+    def _fail_with_undefined_error(</span>
<span class="gi">+        self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+    ) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Raise an :exc:`UndefinedError` when operations are performed
<span class="w"> </span>        on the undefined value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise self._undefined_exception(self._undefined_message)</span>

<span class="w"> </span>    @internalcode
<span class="gd">-    def __getattr__(self, name: str) -&gt;t.Any:</span>
<span class="gd">-        if name[:2] == &#39;__&#39;:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; t.Any:</span>
<span class="gi">+        if name[:2] == &quot;__&quot;:</span>
<span class="w"> </span>            raise AttributeError(name)
<span class="gi">+</span>
<span class="w"> </span>        return self._fail_with_undefined_error()
<span class="gi">+</span>
<span class="w"> </span>    __add__ = __radd__ = __sub__ = __rsub__ = _fail_with_undefined_error
<span class="w"> </span>    __mul__ = __rmul__ = __div__ = __rdiv__ = _fail_with_undefined_error
<span class="w"> </span>    __truediv__ = __rtruediv__ = _fail_with_undefined_error
<span class="gu">@@ -525,37 +874,38 @@ class Undefined:</span>
<span class="w"> </span>    __int__ = __float__ = __complex__ = _fail_with_undefined_error
<span class="w"> </span>    __pow__ = __rpow__ = _fail_with_undefined_error

<span class="gd">-    def __eq__(self, other: t.Any) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: t.Any) -&gt; bool:</span>
<span class="w"> </span>        return type(self) is type(other)

<span class="gd">-    def __ne__(self, other: t.Any) -&gt;bool:</span>
<span class="gi">+    def __ne__(self, other: t.Any) -&gt; bool:</span>
<span class="w"> </span>        return not self.__eq__(other)

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return id(type(self))

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return &#39;&#39;</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return &quot;&quot;</span>

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return 0

<span class="gd">-    def __iter__(self) -&gt;t.Iterator[t.Any]:</span>
<span class="gi">+    def __iter__(self) -&gt; t.Iterator[t.Any]:</span>
<span class="w"> </span>        yield from ()

<span class="gd">-    async def __aiter__(self) -&gt;t.AsyncIterator[t.Any]:</span>
<span class="gi">+    async def __aiter__(self) -&gt; t.AsyncIterator[t.Any]:</span>
<span class="w"> </span>        for _ in ():
<span class="w"> </span>            yield

<span class="gd">-    def __bool__(self) -&gt;bool:</span>
<span class="gi">+    def __bool__(self) -&gt; bool:</span>
<span class="w"> </span>        return False

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;Undefined&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;Undefined&quot;</span>


<span class="gd">-def make_logging_undefined(logger: t.Optional[&#39;logging.Logger&#39;]=None, base:</span>
<span class="gd">-    t.Type[Undefined]=Undefined) -&gt;t.Type[Undefined]:</span>
<span class="gi">+def make_logging_undefined(</span>
<span class="gi">+    logger: t.Optional[&quot;logging.Logger&quot;] = None, base: t.Type[Undefined] = Undefined</span>
<span class="gi">+) -&gt; t.Type[Undefined]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a logger object this returns a new undefined class that will
<span class="w"> </span>    log certain failures.  It will log iterations and printing.  If no
<span class="w"> </span>    logger is given a default logger is created.
<span class="gu">@@ -575,7 +925,40 @@ def make_logging_undefined(logger: t.Optional[&#39;logging.Logger&#39;]=None, base:</span>
<span class="w"> </span>    :param base: the base class to add logging functionality to.  This
<span class="w"> </span>                 defaults to :class:`Undefined`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if logger is None:</span>
<span class="gi">+        import logging</span>
<span class="gi">+</span>
<span class="gi">+        logger = logging.getLogger(__name__)</span>
<span class="gi">+        logger.addHandler(logging.StreamHandler(sys.stderr))</span>
<span class="gi">+</span>
<span class="gi">+    def _log_message(undef: Undefined) -&gt; None:</span>
<span class="gi">+        logger.warning(&quot;Template variable warning: %s&quot;, undef._undefined_message)</span>
<span class="gi">+</span>
<span class="gi">+    class LoggingUndefined(base):  # type: ignore</span>
<span class="gi">+        __slots__ = ()</span>
<span class="gi">+</span>
<span class="gi">+        def _fail_with_undefined_error(  # type: ignore</span>
<span class="gi">+            self, *args: t.Any, **kwargs: t.Any</span>
<span class="gi">+        ) -&gt; &quot;te.NoReturn&quot;:</span>
<span class="gi">+            try:</span>
<span class="gi">+                super()._fail_with_undefined_error(*args, **kwargs)</span>
<span class="gi">+            except self._undefined_exception as e:</span>
<span class="gi">+                logger.error(&quot;Template variable error: %s&quot;, e)  # type: ignore</span>
<span class="gi">+                raise e</span>
<span class="gi">+</span>
<span class="gi">+        def __str__(self) -&gt; str:</span>
<span class="gi">+            _log_message(self)</span>
<span class="gi">+            return super().__str__()  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        def __iter__(self) -&gt; t.Iterator[t.Any]:</span>
<span class="gi">+            _log_message(self)</span>
<span class="gi">+            return super().__iter__()  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        def __bool__(self) -&gt; bool:</span>
<span class="gi">+            _log_message(self)</span>
<span class="gi">+            return super().__bool__()  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    return LoggingUndefined</span>


<span class="w"> </span>class ChainableUndefined(Undefined):
<span class="gu">@@ -593,14 +976,16 @@ class ChainableUndefined(Undefined):</span>

<span class="w"> </span>    .. versionadded:: 2.11.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="gd">-    def __html__(self) -&gt;str:</span>
<span class="gi">+    def __html__(self) -&gt; str:</span>
<span class="w"> </span>        return str(self)

<span class="gd">-    def __getattr__(self, _: str) -&gt;&#39;ChainableUndefined&#39;:</span>
<span class="gi">+    def __getattr__(self, _: str) -&gt; &quot;ChainableUndefined&quot;:</span>
<span class="w"> </span>        return self
<span class="gd">-    __getitem__ = __getattr__</span>
<span class="gi">+</span>
<span class="gi">+    __getitem__ = __getattr__  # type: ignore</span>


<span class="w"> </span>class DebugUndefined(Undefined):
<span class="gu">@@ -616,18 +1001,23 @@ class DebugUndefined(Undefined):</span>
<span class="w"> </span>      ...
<span class="w"> </span>    jinja2.exceptions.UndefinedError: &#39;foo&#39; is undefined
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        if self._undefined_hint:
<span class="gd">-            message = f&#39;undefined value printed: {self._undefined_hint}&#39;</span>
<span class="gi">+            message = f&quot;undefined value printed: {self._undefined_hint}&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        elif self._undefined_obj is missing:
<span class="gd">-            message = self._undefined_name</span>
<span class="gi">+            message = self._undefined_name  # type: ignore</span>
<span class="gi">+</span>
<span class="w"> </span>        else:
<span class="w"> </span>            message = (
<span class="gd">-                f&#39;no such element: {object_type_repr(self._undefined_obj)}[{self._undefined_name!r}]&#39;</span>
<span class="gd">-                )</span>
<span class="gd">-        return f&#39;{{{{ {message} }}}}&#39;</span>
<span class="gi">+                f&quot;no such element: {object_type_repr(self._undefined_obj)}&quot;</span>
<span class="gi">+                f&quot;[{self._undefined_name!r}]&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return f&quot;{{{{ {message} }}}}&quot;</span>


<span class="w"> </span>class StrictUndefined(Undefined):
<span class="gu">@@ -649,12 +1039,18 @@ class StrictUndefined(Undefined):</span>
<span class="w"> </span>      ...
<span class="w"> </span>    jinja2.exceptions.UndefinedError: &#39;foo&#39; is undefined
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()
<span class="w"> </span>    __iter__ = __str__ = __len__ = Undefined._fail_with_undefined_error
<span class="gd">-    __eq__ = __ne__ = __bool__ = __hash__ = (Undefined.</span>
<span class="gd">-        _fail_with_undefined_error)</span>
<span class="gi">+    __eq__ = __ne__ = __bool__ = __hash__ = Undefined._fail_with_undefined_error</span>
<span class="w"> </span>    __contains__ = Undefined._fail_with_undefined_error


<span class="gd">-del (Undefined.__slots__, ChainableUndefined.__slots__, DebugUndefined.</span>
<span class="gd">-    __slots__, StrictUndefined.__slots__)</span>
<span class="gi">+# Remove slots attributes, after the metaclass is applied they are</span>
<span class="gi">+# unneeded and contain wrong data for subclasses.</span>
<span class="gi">+del (</span>
<span class="gi">+    Undefined.__slots__,</span>
<span class="gi">+    ChainableUndefined.__slots__,</span>
<span class="gi">+    DebugUndefined.__slots__,</span>
<span class="gi">+    StrictUndefined.__slots__,</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/src/jinja2/sandbox.py b/src/jinja2/sandbox.py</span>
<span class="gh">index b73a983..0b4fc12 100644</span>
<span class="gd">--- a/src/jinja2/sandbox.py</span>
<span class="gi">+++ b/src/jinja2/sandbox.py</span>
<span class="gu">@@ -1,44 +1,116 @@</span>
<span class="w"> </span>&quot;&quot;&quot;A sandbox layer that ensures unsafe operations cannot be performed.
<span class="w"> </span>Useful when the template itself comes from an untrusted source.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import operator
<span class="w"> </span>import types
<span class="w"> </span>import typing as t
<span class="w"> </span>from collections import abc
<span class="w"> </span>from collections import deque
<span class="w"> </span>from string import Formatter
<span class="gd">-from _string import formatter_field_name_split</span>
<span class="gi">+</span>
<span class="gi">+from _string import formatter_field_name_split  # type: ignore</span>
<span class="w"> </span>from markupsafe import EscapeFormatter
<span class="w"> </span>from markupsafe import Markup
<span class="gi">+</span>
<span class="w"> </span>from .environment import Environment
<span class="w"> </span>from .exceptions import SecurityError
<span class="w"> </span>from .runtime import Context
<span class="w"> </span>from .runtime import Undefined
<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+</span>
<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+</span>
<span class="gi">+#: maximum number of items a range may produce</span>
<span class="w"> </span>MAX_RANGE = 100000
<span class="gi">+</span>
<span class="gi">+#: Unsafe function attributes.</span>
<span class="w"> </span>UNSAFE_FUNCTION_ATTRIBUTES: t.Set[str] = set()
<span class="gi">+</span>
<span class="gi">+#: Unsafe method attributes. Function attributes are unsafe for methods too.</span>
<span class="w"> </span>UNSAFE_METHOD_ATTRIBUTES: t.Set[str] = set()
<span class="gd">-UNSAFE_GENERATOR_ATTRIBUTES = {&#39;gi_frame&#39;, &#39;gi_code&#39;}</span>
<span class="gd">-UNSAFE_COROUTINE_ATTRIBUTES = {&#39;cr_frame&#39;, &#39;cr_code&#39;}</span>
<span class="gd">-UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {&#39;ag_code&#39;, &#39;ag_frame&#39;}</span>
<span class="gd">-_mutable_spec: t.Tuple[t.Tuple[t.Type[t.Any], t.FrozenSet[str]], ...] = ((</span>
<span class="gd">-    abc.MutableSet, frozenset([&#39;add&#39;, &#39;clear&#39;, &#39;difference_update&#39;,</span>
<span class="gd">-    &#39;discard&#39;, &#39;pop&#39;, &#39;remove&#39;, &#39;symmetric_difference_update&#39;, &#39;update&#39;])),</span>
<span class="gd">-    (abc.MutableMapping, frozenset([&#39;clear&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;setdefault&#39;,</span>
<span class="gd">-    &#39;update&#39;])), (abc.MutableSequence, frozenset([&#39;append&#39;, &#39;reverse&#39;,</span>
<span class="gd">-    &#39;insert&#39;, &#39;sort&#39;, &#39;extend&#39;, &#39;remove&#39;])), (deque, frozenset([&#39;append&#39;,</span>
<span class="gd">-    &#39;appendleft&#39;, &#39;clear&#39;, &#39;extend&#39;, &#39;extendleft&#39;, &#39;pop&#39;, &#39;popleft&#39;,</span>
<span class="gd">-    &#39;remove&#39;, &#39;rotate&#39;])))</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def safe_range(*args: int) -&gt;range:</span>
<span class="gi">+</span>
<span class="gi">+#: unsafe generator attributes.</span>
<span class="gi">+UNSAFE_GENERATOR_ATTRIBUTES = {&quot;gi_frame&quot;, &quot;gi_code&quot;}</span>
<span class="gi">+</span>
<span class="gi">+#: unsafe attributes on coroutines</span>
<span class="gi">+UNSAFE_COROUTINE_ATTRIBUTES = {&quot;cr_frame&quot;, &quot;cr_code&quot;}</span>
<span class="gi">+</span>
<span class="gi">+#: unsafe attributes on async generators</span>
<span class="gi">+UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {&quot;ag_code&quot;, &quot;ag_frame&quot;}</span>
<span class="gi">+</span>
<span class="gi">+_mutable_spec: t.Tuple[t.Tuple[t.Type[t.Any], t.FrozenSet[str]], ...] = (</span>
<span class="gi">+    (</span>
<span class="gi">+        abc.MutableSet,</span>
<span class="gi">+        frozenset(</span>
<span class="gi">+            [</span>
<span class="gi">+                &quot;add&quot;,</span>
<span class="gi">+                &quot;clear&quot;,</span>
<span class="gi">+                &quot;difference_update&quot;,</span>
<span class="gi">+                &quot;discard&quot;,</span>
<span class="gi">+                &quot;pop&quot;,</span>
<span class="gi">+                &quot;remove&quot;,</span>
<span class="gi">+                &quot;symmetric_difference_update&quot;,</span>
<span class="gi">+                &quot;update&quot;,</span>
<span class="gi">+            ]</span>
<span class="gi">+        ),</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        abc.MutableMapping,</span>
<span class="gi">+        frozenset([&quot;clear&quot;, &quot;pop&quot;, &quot;popitem&quot;, &quot;setdefault&quot;, &quot;update&quot;]),</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        abc.MutableSequence,</span>
<span class="gi">+        frozenset([&quot;append&quot;, &quot;reverse&quot;, &quot;insert&quot;, &quot;sort&quot;, &quot;extend&quot;, &quot;remove&quot;]),</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        deque,</span>
<span class="gi">+        frozenset(</span>
<span class="gi">+            [</span>
<span class="gi">+                &quot;append&quot;,</span>
<span class="gi">+                &quot;appendleft&quot;,</span>
<span class="gi">+                &quot;clear&quot;,</span>
<span class="gi">+                &quot;extend&quot;,</span>
<span class="gi">+                &quot;extendleft&quot;,</span>
<span class="gi">+                &quot;pop&quot;,</span>
<span class="gi">+                &quot;popleft&quot;,</span>
<span class="gi">+                &quot;remove&quot;,</span>
<span class="gi">+                &quot;rotate&quot;,</span>
<span class="gi">+            ]</span>
<span class="gi">+        ),</span>
<span class="gi">+    ),</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inspect_format_method(callable: t.Callable[..., t.Any]) -&gt; t.Optional[str]:</span>
<span class="gi">+    if not isinstance(</span>
<span class="gi">+        callable, (types.MethodType, types.BuiltinMethodType)</span>
<span class="gi">+    ) or callable.__name__ not in (&quot;format&quot;, &quot;format_map&quot;):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    obj = callable.__self__</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(obj, str):</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def safe_range(*args: int) -&gt; range:</span>
<span class="w"> </span>    &quot;&quot;&quot;A range that can&#39;t generate ranges with a length of more than
<span class="w"> </span>    MAX_RANGE items.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rng = range(*args)</span>
<span class="gi">+</span>
<span class="gi">+    if len(rng) &gt; MAX_RANGE:</span>
<span class="gi">+        raise OverflowError(</span>
<span class="gi">+            &quot;Range too big. The sandbox blocks ranges larger than&quot;</span>
<span class="gi">+            f&quot; MAX_RANGE ({MAX_RANGE}).&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return rng</span>


<span class="gd">-def unsafe(f: F) -&gt;F:</span>
<span class="gi">+def unsafe(f: F) -&gt; F:</span>
<span class="w"> </span>    &quot;&quot;&quot;Marks a function or method as unsafe.

<span class="w"> </span>    .. code-block: python
<span class="gu">@@ -47,10 +119,11 @@ def unsafe(f: F) -&gt;F:</span>
<span class="w"> </span>        def delete(self):
<span class="w"> </span>            pass
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f.unsafe_callable = True  # type: ignore</span>
<span class="gi">+    return f</span>


<span class="gd">-def is_internal_attribute(obj: t.Any, attr: str) -&gt;bool:</span>
<span class="gi">+def is_internal_attribute(obj: t.Any, attr: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Test if the attribute given is an internal python attribute.  For
<span class="w"> </span>    example this function returns `True` for the `func_code` attribute of
<span class="w"> </span>    python objects.  This is useful if the environment method
<span class="gu">@@ -62,10 +135,32 @@ def is_internal_attribute(obj: t.Any, attr: str) -&gt;bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; is_internal_attribute(str, &quot;upper&quot;)
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def modifies_known_mutable(obj: t.Any, attr: str) -&gt;bool:</span>
<span class="gi">+    if isinstance(obj, types.FunctionType):</span>
<span class="gi">+        if attr in UNSAFE_FUNCTION_ATTRIBUTES:</span>
<span class="gi">+            return True</span>
<span class="gi">+    elif isinstance(obj, types.MethodType):</span>
<span class="gi">+        if attr in UNSAFE_FUNCTION_ATTRIBUTES or attr in UNSAFE_METHOD_ATTRIBUTES:</span>
<span class="gi">+            return True</span>
<span class="gi">+    elif isinstance(obj, type):</span>
<span class="gi">+        if attr == &quot;mro&quot;:</span>
<span class="gi">+            return True</span>
<span class="gi">+    elif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)):</span>
<span class="gi">+        return True</span>
<span class="gi">+    elif isinstance(obj, types.GeneratorType):</span>
<span class="gi">+        if attr in UNSAFE_GENERATOR_ATTRIBUTES:</span>
<span class="gi">+            return True</span>
<span class="gi">+    elif hasattr(types, &quot;CoroutineType&quot;) and isinstance(obj, types.CoroutineType):</span>
<span class="gi">+        if attr in UNSAFE_COROUTINE_ATTRIBUTES:</span>
<span class="gi">+            return True</span>
<span class="gi">+    elif hasattr(types, &quot;AsyncGeneratorType&quot;) and isinstance(</span>
<span class="gi">+        obj, types.AsyncGeneratorType</span>
<span class="gi">+    ):</span>
<span class="gi">+        if attr in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES:</span>
<span class="gi">+            return True</span>
<span class="gi">+    return attr.startswith(&quot;__&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def modifies_known_mutable(obj: t.Any, attr: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;This function checks if an attribute on a builtin mutable object
<span class="w"> </span>    (list, dict, set or deque) or the corresponding ABCs would modify it
<span class="w"> </span>    if called.
<span class="gu">@@ -84,7 +179,10 @@ def modifies_known_mutable(obj: t.Any, attr: str) -&gt;bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; modifies_known_mutable(&quot;foo&quot;, &quot;upper&quot;)
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for typespec, unsafe in _mutable_spec:</span>
<span class="gi">+        if isinstance(obj, typespec):</span>
<span class="gi">+            return attr in unsafe</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class SandboxedEnvironment(Environment):
<span class="gu">@@ -97,86 +195,203 @@ class SandboxedEnvironment(Environment):</span>
<span class="w"> </span>    raised.  However also other exceptions may occur during the rendering so
<span class="w"> </span>    the caller has to ensure that all exceptions are caught.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    sandboxed = True
<span class="gd">-    default_binop_table: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {&#39;+&#39;:</span>
<span class="gd">-        operator.add, &#39;-&#39;: operator.sub, &#39;*&#39;: operator.mul, &#39;/&#39;: operator.</span>
<span class="gd">-        truediv, &#39;//&#39;: operator.floordiv, &#39;**&#39;: operator.pow, &#39;%&#39;: operator.mod</span>
<span class="gd">-        }</span>
<span class="gd">-    default_unop_table: t.Dict[str, t.Callable[[t.Any], t.Any]] = {&#39;+&#39;:</span>
<span class="gd">-        operator.pos, &#39;-&#39;: operator.neg}</span>
<span class="gi">+</span>
<span class="gi">+    #: default callback table for the binary operators.  A copy of this is</span>
<span class="gi">+    #: available on each instance of a sandboxed environment as</span>
<span class="gi">+    #: :attr:`binop_table`</span>
<span class="gi">+    default_binop_table: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {</span>
<span class="gi">+        &quot;+&quot;: operator.add,</span>
<span class="gi">+        &quot;-&quot;: operator.sub,</span>
<span class="gi">+        &quot;*&quot;: operator.mul,</span>
<span class="gi">+        &quot;/&quot;: operator.truediv,</span>
<span class="gi">+        &quot;//&quot;: operator.floordiv,</span>
<span class="gi">+        &quot;**&quot;: operator.pow,</span>
<span class="gi">+        &quot;%&quot;: operator.mod,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    #: default callback table for the unary operators.  A copy of this is</span>
<span class="gi">+    #: available on each instance of a sandboxed environment as</span>
<span class="gi">+    #: :attr:`unop_table`</span>
<span class="gi">+    default_unop_table: t.Dict[str, t.Callable[[t.Any], t.Any]] = {</span>
<span class="gi">+        &quot;+&quot;: operator.pos,</span>
<span class="gi">+        &quot;-&quot;: operator.neg,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    #: a set of binary operators that should be intercepted.  Each operator</span>
<span class="gi">+    #: that is added to this set (empty by default) is delegated to the</span>
<span class="gi">+    #: :meth:`call_binop` method that will perform the operator.  The default</span>
<span class="gi">+    #: operator callback is specified by :attr:`binop_table`.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: The following binary operators are interceptable:</span>
<span class="gi">+    #: ``//``, ``%``, ``+``, ``*``, ``-``, ``/``, and ``**``</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: The default operation form the operator table corresponds to the</span>
<span class="gi">+    #: builtin function.  Intercepted calls are always slower than the native</span>
<span class="gi">+    #: operator call, so make sure only to intercept the ones you are</span>
<span class="gi">+    #: interested in.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 2.6</span>
<span class="w"> </span>    intercepted_binops: t.FrozenSet[str] = frozenset()
<span class="gi">+</span>
<span class="gi">+    #: a set of unary operators that should be intercepted.  Each operator</span>
<span class="gi">+    #: that is added to this set (empty by default) is delegated to the</span>
<span class="gi">+    #: :meth:`call_unop` method that will perform the operator.  The default</span>
<span class="gi">+    #: operator callback is specified by :attr:`unop_table`.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: The following unary operators are interceptable: ``+``, ``-``</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: The default operation form the operator table corresponds to the</span>
<span class="gi">+    #: builtin function.  Intercepted calls are always slower than the native</span>
<span class="gi">+    #: operator call, so make sure only to intercept the ones you are</span>
<span class="gi">+    #: interested in.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. versionadded:: 2.6</span>
<span class="w"> </span>    intercepted_unops: t.FrozenSet[str] = frozenset()

<span class="gd">-    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args: t.Any, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="gd">-        self.globals[&#39;range&#39;] = safe_range</span>
<span class="gi">+        self.globals[&quot;range&quot;] = safe_range</span>
<span class="w"> </span>        self.binop_table = self.default_binop_table.copy()
<span class="w"> </span>        self.unop_table = self.default_unop_table.copy()

<span class="gd">-    def is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -&gt;bool:</span>
<span class="gi">+    def is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;The sandboxed environment will call this method to check if the
<span class="w"> </span>        attribute of an object is safe to access.  Per default all attributes
<span class="w"> </span>        starting with an underscore are considered private as well as the
<span class="w"> </span>        special attributes of internal python objects as returned by the
<span class="w"> </span>        :func:`is_internal_attribute` function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return not (attr.startswith(&quot;_&quot;) or is_internal_attribute(obj, attr))</span>

<span class="gd">-    def is_safe_callable(self, obj: t.Any) -&gt;bool:</span>
<span class="gi">+    def is_safe_callable(self, obj: t.Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if an object is safely callable. By default callables
<span class="w"> </span>        are considered safe unless decorated with :func:`unsafe`.

<span class="w"> </span>        This also recognizes the Django convention of setting
<span class="w"> </span>        ``func.alters_data = True``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return not (</span>
<span class="gi">+            getattr(obj, &quot;unsafe_callable&quot;, False) or getattr(obj, &quot;alters_data&quot;, False)</span>
<span class="gi">+        )</span>

<span class="gd">-    def call_binop(self, context: Context, operator: str, left: t.Any,</span>
<span class="gd">-        right: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def call_binop(</span>
<span class="gi">+        self, context: Context, operator: str, left: t.Any, right: t.Any</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;For intercepted binary operator calls (:meth:`intercepted_binops`)
<span class="w"> </span>        this function is executed instead of the builtin operator.  This can
<span class="w"> </span>        be used to fine tune the behavior of certain operators.

<span class="w"> </span>        .. versionadded:: 2.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.binop_table[operator](left, right)</span>

<span class="gd">-    def call_unop(self, context: Context, operator: str, arg: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def call_unop(self, context: Context, operator: str, arg: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;For intercepted unary operator calls (:meth:`intercepted_unops`)
<span class="w"> </span>        this function is executed instead of the builtin operator.  This can
<span class="w"> </span>        be used to fine tune the behavior of certain operators.

<span class="w"> </span>        .. versionadded:: 2.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.unop_table[operator](arg)</span>

<span class="gd">-    def getitem(self, obj: t.Any, argument: t.Union[str, t.Any]) -&gt;t.Union[</span>
<span class="gd">-        t.Any, Undefined]:</span>
<span class="gi">+    def getitem(</span>
<span class="gi">+        self, obj: t.Any, argument: t.Union[str, t.Any]</span>
<span class="gi">+    ) -&gt; t.Union[t.Any, Undefined]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Subscribe an object from sandboxed code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def getattr(self, obj: t.Any, attribute: str) -&gt;t.Union[t.Any, Undefined]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return obj[argument]</span>
<span class="gi">+        except (TypeError, LookupError):</span>
<span class="gi">+            if isinstance(argument, str):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    attr = str(argument)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        value = getattr(obj, attr)</span>
<span class="gi">+                    except AttributeError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if self.is_safe_attribute(obj, argument, value):</span>
<span class="gi">+                            return value</span>
<span class="gi">+                        return self.unsafe_undefined(obj, argument)</span>
<span class="gi">+        return self.undefined(obj=obj, name=argument)</span>
<span class="gi">+</span>
<span class="gi">+    def getattr(self, obj: t.Any, attribute: str) -&gt; t.Union[t.Any, Undefined]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Subscribe an object from sandboxed code and prefer the
<span class="w"> </span>        attribute.  The attribute passed *must* be a bytestring.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def unsafe_undefined(self, obj: t.Any, attribute: str) -&gt;Undefined:</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = getattr(obj, attribute)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return obj[attribute]</span>
<span class="gi">+            except (TypeError, LookupError):</span>
<span class="gi">+                pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.is_safe_attribute(obj, attribute, value):</span>
<span class="gi">+                return value</span>
<span class="gi">+            return self.unsafe_undefined(obj, attribute)</span>
<span class="gi">+        return self.undefined(obj=obj, name=attribute)</span>
<span class="gi">+</span>
<span class="gi">+    def unsafe_undefined(self, obj: t.Any, attribute: str) -&gt; Undefined:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an undefined object for unsafe attributes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def format_string(self, s: str, args: t.Tuple[t.Any, ...], kwargs: t.</span>
<span class="gd">-        Dict[str, t.Any], format_func: t.Optional[t.Callable[..., t.Any]]=None</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+        return self.undefined(</span>
<span class="gi">+            f&quot;access to attribute {attribute!r} of&quot;</span>
<span class="gi">+            f&quot; {type(obj).__name__!r} object is unsafe.&quot;,</span>
<span class="gi">+            name=attribute,</span>
<span class="gi">+            obj=obj,</span>
<span class="gi">+            exc=SecurityError,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def format_string(</span>
<span class="gi">+        self,</span>
<span class="gi">+        s: str,</span>
<span class="gi">+        args: t.Tuple[t.Any, ...],</span>
<span class="gi">+        kwargs: t.Dict[str, t.Any],</span>
<span class="gi">+        format_func: t.Optional[t.Callable[..., t.Any]] = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;If a format call is detected, then this is routed through this
<span class="w"> </span>        method so that our safety sandbox can be used for it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def call(__self, __context: Context, __obj: t.Any, *args: t.Any, **</span>
<span class="gd">-        kwargs: t.Any) -&gt;t.Any:</span>
<span class="gi">+        formatter: SandboxedFormatter</span>
<span class="gi">+        if isinstance(s, Markup):</span>
<span class="gi">+            formatter = SandboxedEscapeFormatter(self, escape=s.escape)</span>
<span class="gi">+        else:</span>
<span class="gi">+            formatter = SandboxedFormatter(self)</span>
<span class="gi">+</span>
<span class="gi">+        if format_func is not None and format_func.__name__ == &quot;format_map&quot;:</span>
<span class="gi">+            if len(args) != 1 or kwargs:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &quot;format_map() takes exactly one argument&quot;</span>
<span class="gi">+                    f&quot; {len(args) + (kwargs is not None)} given&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            kwargs = args[0]</span>
<span class="gi">+            args = ()</span>
<span class="gi">+</span>
<span class="gi">+        rv = formatter.vformat(s, args, kwargs)</span>
<span class="gi">+        return type(s)(rv)</span>
<span class="gi">+</span>
<span class="gi">+    def call(</span>
<span class="gi">+        __self,  # noqa: B902</span>
<span class="gi">+        __context: Context,</span>
<span class="gi">+        __obj: t.Any,</span>
<span class="gi">+        *args: t.Any,</span>
<span class="gi">+        **kwargs: t.Any,</span>
<span class="gi">+    ) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call an object from sandboxed code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fmt = inspect_format_method(__obj)</span>
<span class="gi">+        if fmt is not None:</span>
<span class="gi">+            return __self.format_string(fmt, args, kwargs, __obj)</span>
<span class="gi">+</span>
<span class="gi">+        # the double prefixes are to avoid double keyword argument</span>
<span class="gi">+        # errors when proxying the call.</span>
<span class="gi">+        if not __self.is_safe_callable(__obj):</span>
<span class="gi">+            raise SecurityError(f&quot;{__obj!r} is not safely callable&quot;)</span>
<span class="gi">+        return __context.call(__obj, *args, **kwargs)</span>


<span class="w"> </span>class ImmutableSandboxedEnvironment(SandboxedEnvironment):
<span class="gu">@@ -185,13 +400,30 @@ class ImmutableSandboxedEnvironment(SandboxedEnvironment):</span>
<span class="w"> </span>    `dict` by using the :func:`modifies_known_mutable` function.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -&gt; bool:</span>
<span class="gi">+        if not super().is_safe_attribute(obj, attr, value):</span>
<span class="gi">+            return False</span>

<span class="gd">-class SandboxedFormatter(Formatter):</span>
<span class="gi">+        return not modifies_known_mutable(obj, attr)</span>

<span class="gd">-    def __init__(self, env: Environment, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class SandboxedFormatter(Formatter):</span>
<span class="gi">+    def __init__(self, env: Environment, **kwargs: t.Any) -&gt; None:</span>
<span class="w"> </span>        self._env = env
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gi">+    def get_field(</span>
<span class="gi">+        self, field_name: str, args: t.Sequence[t.Any], kwargs: t.Mapping[str, t.Any]</span>
<span class="gi">+    ) -&gt; t.Tuple[t.Any, str]:</span>
<span class="gi">+        first, rest = formatter_field_name_split(field_name)</span>
<span class="gi">+        obj = self.get_value(first, args, kwargs)</span>
<span class="gi">+        for is_attr, i in rest:</span>
<span class="gi">+            if is_attr:</span>
<span class="gi">+                obj = self._env.getattr(obj, i)</span>
<span class="gi">+            else:</span>
<span class="gi">+                obj = self._env.getitem(obj, i)</span>
<span class="gi">+        return obj, first</span>
<span class="gi">+</span>

<span class="w"> </span>class SandboxedEscapeFormatter(SandboxedFormatter, EscapeFormatter):
<span class="w"> </span>    pass
<span class="gh">diff --git a/src/jinja2/tests.py b/src/jinja2/tests.py</span>
<span class="gh">index 2823a4b..1a59e37 100644</span>
<span class="gd">--- a/src/jinja2/tests.py</span>
<span class="gi">+++ b/src/jinja2/tests.py</span>
<span class="gu">@@ -1,30 +1,33 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Built-in template tests used with the ``is`` operator.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import operator
<span class="w"> </span>import typing as t
<span class="w"> </span>from collections import abc
<span class="w"> </span>from numbers import Number
<span class="gi">+</span>
<span class="w"> </span>from .runtime import Undefined
<span class="w"> </span>from .utils import pass_environment
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    from .environment import Environment


<span class="gd">-def test_odd(value: int) -&gt;bool:</span>
<span class="gi">+def test_odd(value: int) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is odd.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value % 2 == 1</span>


<span class="gd">-def test_even(value: int) -&gt;bool:</span>
<span class="gi">+def test_even(value: int) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is even.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value % 2 == 0</span>


<span class="gd">-def test_divisibleby(value: int, num: int) -&gt;bool:</span>
<span class="gi">+def test_divisibleby(value: int, num: int) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a variable is divisible by a number.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value % num == 0</span>


<span class="gd">-def test_defined(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_defined(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is defined:

<span class="w"> </span>    .. sourcecode:: jinja
<span class="gu">@@ -38,16 +41,16 @@ def test_defined(value: t.Any) -&gt;bool:</span>
<span class="w"> </span>    See the :func:`default` filter for a simple way to set undefined
<span class="w"> </span>    variables.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return not isinstance(value, Undefined)</span>


<span class="gd">-def test_undefined(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_undefined(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Like :func:`defined` but the other way round.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, Undefined)</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def test_filter(env: &#39;Environment&#39;, value: str) -&gt;bool:</span>
<span class="gi">+def test_filter(env: &quot;Environment&quot;, value: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a filter exists by name. Useful if a filter may be
<span class="w"> </span>    optionally available.

<span class="gu">@@ -61,11 +64,11 @@ def test_filter(env: &#39;Environment&#39;, value: str) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value in env.filters</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def test_test(env: &#39;Environment&#39;, value: str) -&gt;bool:</span>
<span class="gi">+def test_test(env: &quot;Environment&quot;, value: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a test exists by name. Useful if a test may be
<span class="w"> </span>    optionally available.

<span class="gu">@@ -83,90 +86,98 @@ def test_test(env: &#39;Environment&#39;, value: str) -&gt;bool:</span>

<span class="w"> </span>    .. versionadded:: 3.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value in env.tests</span>


<span class="gd">-def test_none(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_none(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is none.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is None</span>


<span class="gd">-def test_boolean(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_boolean(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the object is a boolean value.

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is True or value is False</span>


<span class="gd">-def test_false(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_false(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the object is False.

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is False</span>


<span class="gd">-def test_true(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_true(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the object is True.

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is True</span>


<span class="gd">-def test_integer(value: t.Any) -&gt;bool:</span>
<span class="gi">+# NOTE: The existing &#39;number&#39; test matches booleans and floats</span>
<span class="gi">+def test_integer(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the object is an integer.

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, int) and value is not True and value is not False</span>


<span class="gd">-def test_float(value: t.Any) -&gt;bool:</span>
<span class="gi">+# NOTE: The existing &#39;number&#39; test matches booleans and integers</span>
<span class="gi">+def test_float(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the object is a float.

<span class="w"> </span>    .. versionadded:: 2.11
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, float)</span>


<span class="gd">-def test_lower(value: str) -&gt;bool:</span>
<span class="gi">+def test_lower(value: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is lowercased.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(value).islower()</span>


<span class="gd">-def test_upper(value: str) -&gt;bool:</span>
<span class="gi">+def test_upper(value: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is uppercased.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(value).isupper()</span>


<span class="gd">-def test_string(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_string(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the object is a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, str)</span>


<span class="gd">-def test_mapping(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_mapping(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the object is a mapping (dict etc.).

<span class="w"> </span>    .. versionadded:: 2.6
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, abc.Mapping)</span>


<span class="gd">-def test_number(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_number(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is a number.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, Number)</span>


<span class="gd">-def test_sequence(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_sequence(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the variable is a sequence. Sequences are variables
<span class="w"> </span>    that are iterable.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        len(value)</span>
<span class="gi">+        value.__getitem__  # noqa B018</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>

<span class="gi">+    return True</span>

<span class="gd">-def test_sameas(value: t.Any, other: t.Any) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def test_sameas(value: t.Any, other: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if an object points to the same memory address than another
<span class="w"> </span>    object:

<span class="gu">@@ -176,37 +187,70 @@ def test_sameas(value: t.Any, other: t.Any) -&gt;bool:</span>
<span class="w"> </span>            the foo attribute really is the `False` singleton
<span class="w"> </span>        {% endif %}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is other</span>


<span class="gd">-def test_iterable(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_iterable(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if it&#39;s possible to iterate over an object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        iter(value)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>


<span class="gd">-def test_escaped(value: t.Any) -&gt;bool:</span>
<span class="gi">+def test_escaped(value: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the value is escaped.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(value, &quot;__html__&quot;)</span>


<span class="gd">-def test_in(value: t.Any, seq: t.Container[t.Any]) -&gt;bool:</span>
<span class="gi">+def test_in(value: t.Any, seq: t.Container[t.Any]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if value is in seq.

<span class="w"> </span>    .. versionadded:: 2.10
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-TESTS = {&#39;odd&#39;: test_odd, &#39;even&#39;: test_even, &#39;divisibleby&#39;:</span>
<span class="gd">-    test_divisibleby, &#39;defined&#39;: test_defined, &#39;undefined&#39;: test_undefined,</span>
<span class="gd">-    &#39;filter&#39;: test_filter, &#39;test&#39;: test_test, &#39;none&#39;: test_none, &#39;boolean&#39;:</span>
<span class="gd">-    test_boolean, &#39;false&#39;: test_false, &#39;true&#39;: test_true, &#39;integer&#39;:</span>
<span class="gd">-    test_integer, &#39;float&#39;: test_float, &#39;lower&#39;: test_lower, &#39;upper&#39;:</span>
<span class="gd">-    test_upper, &#39;string&#39;: test_string, &#39;mapping&#39;: test_mapping, &#39;number&#39;:</span>
<span class="gd">-    test_number, &#39;sequence&#39;: test_sequence, &#39;iterable&#39;: test_iterable,</span>
<span class="gd">-    &#39;callable&#39;: callable, &#39;sameas&#39;: test_sameas, &#39;escaped&#39;: test_escaped,</span>
<span class="gd">-    &#39;in&#39;: test_in, &#39;==&#39;: operator.eq, &#39;eq&#39;: operator.eq, &#39;equalto&#39;:</span>
<span class="gd">-    operator.eq, &#39;!=&#39;: operator.ne, &#39;ne&#39;: operator.ne, &#39;&gt;&#39;: operator.gt,</span>
<span class="gd">-    &#39;gt&#39;: operator.gt, &#39;greaterthan&#39;: operator.gt, &#39;ge&#39;: operator.ge, &#39;&gt;=&#39;:</span>
<span class="gd">-    operator.ge, &#39;&lt;&#39;: operator.lt, &#39;lt&#39;: operator.lt, &#39;lessthan&#39;: operator.</span>
<span class="gd">-    lt, &#39;&lt;=&#39;: operator.le, &#39;le&#39;: operator.le}</span>
<span class="gi">+    return value in seq</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+TESTS = {</span>
<span class="gi">+    &quot;odd&quot;: test_odd,</span>
<span class="gi">+    &quot;even&quot;: test_even,</span>
<span class="gi">+    &quot;divisibleby&quot;: test_divisibleby,</span>
<span class="gi">+    &quot;defined&quot;: test_defined,</span>
<span class="gi">+    &quot;undefined&quot;: test_undefined,</span>
<span class="gi">+    &quot;filter&quot;: test_filter,</span>
<span class="gi">+    &quot;test&quot;: test_test,</span>
<span class="gi">+    &quot;none&quot;: test_none,</span>
<span class="gi">+    &quot;boolean&quot;: test_boolean,</span>
<span class="gi">+    &quot;false&quot;: test_false,</span>
<span class="gi">+    &quot;true&quot;: test_true,</span>
<span class="gi">+    &quot;integer&quot;: test_integer,</span>
<span class="gi">+    &quot;float&quot;: test_float,</span>
<span class="gi">+    &quot;lower&quot;: test_lower,</span>
<span class="gi">+    &quot;upper&quot;: test_upper,</span>
<span class="gi">+    &quot;string&quot;: test_string,</span>
<span class="gi">+    &quot;mapping&quot;: test_mapping,</span>
<span class="gi">+    &quot;number&quot;: test_number,</span>
<span class="gi">+    &quot;sequence&quot;: test_sequence,</span>
<span class="gi">+    &quot;iterable&quot;: test_iterable,</span>
<span class="gi">+    &quot;callable&quot;: callable,</span>
<span class="gi">+    &quot;sameas&quot;: test_sameas,</span>
<span class="gi">+    &quot;escaped&quot;: test_escaped,</span>
<span class="gi">+    &quot;in&quot;: test_in,</span>
<span class="gi">+    &quot;==&quot;: operator.eq,</span>
<span class="gi">+    &quot;eq&quot;: operator.eq,</span>
<span class="gi">+    &quot;equalto&quot;: operator.eq,</span>
<span class="gi">+    &quot;!=&quot;: operator.ne,</span>
<span class="gi">+    &quot;ne&quot;: operator.ne,</span>
<span class="gi">+    &quot;&gt;&quot;: operator.gt,</span>
<span class="gi">+    &quot;gt&quot;: operator.gt,</span>
<span class="gi">+    &quot;greaterthan&quot;: operator.gt,</span>
<span class="gi">+    &quot;ge&quot;: operator.ge,</span>
<span class="gi">+    &quot;&gt;=&quot;: operator.ge,</span>
<span class="gi">+    &quot;&lt;&quot;: operator.lt,</span>
<span class="gi">+    &quot;lt&quot;: operator.lt,</span>
<span class="gi">+    &quot;lessthan&quot;: operator.lt,</span>
<span class="gi">+    &quot;&lt;=&quot;: operator.le,</span>
<span class="gi">+    &quot;le&quot;: operator.le,</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/src/jinja2/utils.py b/src/jinja2/utils.py</span>
<span class="gh">index 7563812..7fb7693 100644</span>
<span class="gd">--- a/src/jinja2/utils.py</span>
<span class="gi">+++ b/src/jinja2/utils.py</span>
<span class="gu">@@ -10,16 +10,23 @@ from random import randrange</span>
<span class="w"> </span>from threading import Lock
<span class="w"> </span>from types import CodeType
<span class="w"> </span>from urllib.parse import quote_from_bytes
<span class="gi">+</span>
<span class="w"> </span>import markupsafe
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te
<span class="gd">-F = t.TypeVar(&#39;F&#39;, bound=t.Callable[..., t.Any])</span>
<span class="gd">-missing: t.Any = type(&#39;MissingType&#39;, (), {&#39;__repr__&#39;: lambda x: &#39;missing&#39;})()</span>
<span class="gi">+</span>
<span class="gi">+F = t.TypeVar(&quot;F&quot;, bound=t.Callable[..., t.Any])</span>
<span class="gi">+</span>
<span class="gi">+# special singleton representing missing values for the runtime</span>
<span class="gi">+missing: t.Any = type(&quot;MissingType&quot;, (), {&quot;__repr__&quot;: lambda x: &quot;missing&quot;})()</span>
<span class="gi">+</span>
<span class="w"> </span>internal_code: t.MutableSet[CodeType] = set()
<span class="gd">-concat = &#39;&#39;.join</span>
<span class="gi">+</span>
<span class="gi">+concat = &quot;&quot;.join</span>


<span class="gd">-def pass_context(f: F) -&gt;F:</span>
<span class="gi">+def pass_context(f: F) -&gt; F:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pass the :class:`~jinja2.runtime.Context` as the first argument
<span class="w"> </span>    to the decorated function when called while rendering a template.

<span class="gu">@@ -32,10 +39,11 @@ def pass_context(f: F) -&gt;F:</span>
<span class="w"> </span>    .. versionadded:: 3.0.0
<span class="w"> </span>        Replaces ``contextfunction`` and ``contextfilter``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f.jinja_pass_arg = _PassArg.context  # type: ignore</span>
<span class="gi">+    return f</span>


<span class="gd">-def pass_eval_context(f: F) -&gt;F:</span>
<span class="gi">+def pass_eval_context(f: F) -&gt; F:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pass the :class:`~jinja2.nodes.EvalContext` as the first argument
<span class="w"> </span>    to the decorated function when called while rendering a template.
<span class="w"> </span>    See :ref:`eval-context`.
<span class="gu">@@ -48,10 +56,11 @@ def pass_eval_context(f: F) -&gt;F:</span>
<span class="w"> </span>    .. versionadded:: 3.0.0
<span class="w"> </span>        Replaces ``evalcontextfunction`` and ``evalcontextfilter``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f.jinja_pass_arg = _PassArg.eval_context  # type: ignore</span>
<span class="gi">+    return f</span>


<span class="gd">-def pass_environment(f: F) -&gt;F:</span>
<span class="gi">+def pass_environment(f: F) -&gt; F:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pass the :class:`~jinja2.Environment` as the first argument to
<span class="w"> </span>    the decorated function when called while rendering a template.

<span class="gu">@@ -60,7 +69,8 @@ def pass_environment(f: F) -&gt;F:</span>
<span class="w"> </span>    .. versionadded:: 3.0.0
<span class="w"> </span>        Replaces ``environmentfunction`` and ``environmentfilter``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    f.jinja_pass_arg = _PassArg.environment  # type: ignore</span>
<span class="gi">+    return f</span>


<span class="w"> </span>class _PassArg(enum.Enum):
<span class="gu">@@ -68,13 +78,21 @@ class _PassArg(enum.Enum):</span>
<span class="w"> </span>    eval_context = enum.auto()
<span class="w"> </span>    environment = enum.auto()

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_obj(cls, obj: F) -&gt; t.Optional[&quot;_PassArg&quot;]:</span>
<span class="gi">+        if hasattr(obj, &quot;jinja_pass_arg&quot;):</span>
<span class="gi">+            return obj.jinja_pass_arg  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="gd">-def internalcode(f: F) -&gt;F:</span>
<span class="gi">+def internalcode(f: F) -&gt; F:</span>
<span class="w"> </span>    &quot;&quot;&quot;Marks the function as internally used&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    internal_code.add(f.__code__)</span>
<span class="gi">+    return f</span>


<span class="gd">-def is_undefined(obj: t.Any) -&gt;bool:</span>
<span class="gi">+def is_undefined(obj: t.Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object passed is undefined.  This does nothing more than
<span class="w"> </span>    performing an instance check against :class:`Undefined` but looks nicer.
<span class="w"> </span>    This can be used for custom filters or tests that want to react to
<span class="gu">@@ -86,24 +104,31 @@ def is_undefined(obj: t.Any) -&gt;bool:</span>
<span class="w"> </span>                return default
<span class="w"> </span>            return var
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from .runtime import Undefined</span>

<span class="gi">+    return isinstance(obj, Undefined)</span>

<span class="gd">-def consume(iterable: t.Iterable[t.Any]) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def consume(iterable: t.Iterable[t.Any]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Consumes an iterable without doing anything with it.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for _ in iterable:</span>
<span class="gi">+        pass</span>


<span class="gd">-def clear_caches() -&gt;None:</span>
<span class="gi">+def clear_caches() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Jinja keeps internal caches for environments and lexers.  These are
<span class="w"> </span>    used so that Jinja doesn&#39;t have to recreate environments and lexers all
<span class="w"> </span>    the time.  Normally you don&#39;t have to care about that but if you are
<span class="w"> </span>    measuring memory consumption you may want to clean the caches.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from .environment import get_spontaneous_environment</span>
<span class="gi">+    from .lexer import _lexer_cache</span>

<span class="gi">+    get_spontaneous_environment.cache_clear()</span>
<span class="gi">+    _lexer_cache.clear()</span>

<span class="gd">-def import_string(import_name: str, silent: bool=False) -&gt;t.Any:</span>
<span class="gi">+</span>
<span class="gi">+def import_string(import_name: str, silent: bool = False) -&gt; t.Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Imports an object based on a string.  This is useful if you want to
<span class="w"> </span>    use import paths as endpoints or something similar.  An import path can
<span class="w"> </span>    be specified either in dotted notation (``xml.sax.saxutils.escape``)
<span class="gu">@@ -114,62 +139,92 @@ def import_string(import_name: str, silent: bool=False) -&gt;t.Any:</span>

<span class="w"> </span>    :return: imported object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def open_if_exists(filename: str, mode: str=&#39;rb&#39;) -&gt;t.Optional[t.IO[t.Any]]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        if &quot;:&quot; in import_name:</span>
<span class="gi">+            module, obj = import_name.split(&quot;:&quot;, 1)</span>
<span class="gi">+        elif &quot;.&quot; in import_name:</span>
<span class="gi">+            module, _, obj = import_name.rpartition(&quot;.&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return __import__(import_name)</span>
<span class="gi">+        return getattr(__import__(module, None, None, [obj]), obj)</span>
<span class="gi">+    except (ImportError, AttributeError):</span>
<span class="gi">+        if not silent:</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def open_if_exists(filename: str, mode: str = &quot;rb&quot;) -&gt; t.Optional[t.IO[t.Any]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a file descriptor for the filename if that file exists,
<span class="w"> </span>    otherwise ``None``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not os.path.isfile(filename):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    return open(filename, mode)</span>


<span class="gd">-def object_type_repr(obj: t.Any) -&gt;str:</span>
<span class="gi">+def object_type_repr(obj: t.Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the name of the object&#39;s type.  For some recognized
<span class="w"> </span>    singletons the name of the object is returned instead. (For
<span class="w"> </span>    example for `None` and `Ellipsis`).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if obj is None:</span>
<span class="gi">+        return &quot;None&quot;</span>
<span class="gi">+    elif obj is Ellipsis:</span>
<span class="gi">+        return &quot;Ellipsis&quot;</span>
<span class="gi">+</span>
<span class="gi">+    cls = type(obj)</span>

<span class="gi">+    if cls.__module__ == &quot;builtins&quot;:</span>
<span class="gi">+        return f&quot;{cls.__name__} object&quot;</span>

<span class="gd">-def pformat(obj: t.Any) -&gt;str:</span>
<span class="gi">+    return f&quot;{cls.__module__}.{cls.__name__} object&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pformat(obj: t.Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format an object using :func:`pprint.pformat`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from pprint import pformat</span>
<span class="gi">+</span>
<span class="gi">+    return pformat(obj)</span>


<span class="w"> </span>_http_re = re.compile(
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    r&quot;&quot;&quot;</span>
<span class="w"> </span>    ^
<span class="w"> </span>    (
<span class="gd">-        (https?://|www\\.)  # scheme or www</span>
<span class="gd">-        (([\\w%-]+\\.)+)?  # subdomain</span>
<span class="gi">+        (https?://|www\.)  # scheme or www</span>
<span class="gi">+        (([\w%-]+\.)+)?  # subdomain</span>
<span class="w"> </span>        (
<span class="w"> </span>            [a-z]{2,63}  # basic tld
<span class="w"> </span>        |
<span class="gd">-            xn--[\\w%]{2,59}  # idna tld</span>
<span class="gi">+            xn--[\w%]{2,59}  # idna tld</span>
<span class="w"> </span>        )
<span class="w"> </span>    |
<span class="gd">-        ([\\w%-]{2,63}\\.)+  # basic domain</span>
<span class="gi">+        ([\w%-]{2,63}\.)+  # basic domain</span>
<span class="w"> </span>        (com|net|int|edu|gov|org|info|mil)  # basic tld
<span class="w"> </span>    |
<span class="w"> </span>        (https?://)  # scheme
<span class="w"> </span>        (
<span class="gd">-            (([\\d]{1,3})(\\.[\\d]{1,3}){3})  # IPv4</span>
<span class="gi">+            (([\d]{1,3})(\.[\d]{1,3}){3})  # IPv4</span>
<span class="w"> </span>        |
<span class="gd">-            (\\[([\\da-f]{0,4}:){2}([\\da-f]{0,4}:?){1,6}])  # IPv6</span>
<span class="gi">+            (\[([\da-f]{0,4}:){2}([\da-f]{0,4}:?){1,6}])  # IPv6</span>
<span class="w"> </span>        )
<span class="w"> </span>    )
<span class="gd">-    (?::[\\d]{1,5})?  # port</span>
<span class="gd">-    (?:[/?#]\\S*)?  # path, query, and fragment</span>
<span class="gi">+    (?::[\d]{1,5})?  # port</span>
<span class="gi">+    (?:[/?#]\S*)?  # path, query, and fragment</span>
<span class="w"> </span>    $
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    , re.IGNORECASE | re.VERBOSE)</span>
<span class="gd">-_email_re = re.compile(&#39;^\\S+@\\w[\\w.-]*\\.\\w+$&#39;)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def urlize(text: str, trim_url_limit: t.Optional[int]=None, rel: t.Optional</span>
<span class="gd">-    [str]=None, target: t.Optional[str]=None, extra_schemes: t.Optional[t.</span>
<span class="gd">-    Iterable[str]]=None) -&gt;str:</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+    re.IGNORECASE | re.VERBOSE,</span>
<span class="gi">+)</span>
<span class="gi">+_email_re = re.compile(r&quot;^\S+@\w[\w.-]*\.\w+$&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def urlize(</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    trim_url_limit: t.Optional[int] = None,</span>
<span class="gi">+    rel: t.Optional[str] = None,</span>
<span class="gi">+    target: t.Optional[str] = None,</span>
<span class="gi">+    extra_schemes: t.Optional[t.Iterable[str]] = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert URLs in text into clickable links.

<span class="w"> </span>    This may not recognize links in some situations. Usually, a more
<span class="gu">@@ -201,16 +256,145 @@ def urlize(text: str, trim_url_limit: t.Optional[int]=None, rel: t.Optional</span>
<span class="w"> </span>        or without the ``mailto:`` scheme. Validate IP addresses. Ignore
<span class="w"> </span>        parentheses and brackets in more cases.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def generate_lorem_ipsum(n: int=5, html: bool=True, min: int=20, max: int=100</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+    if trim_url_limit is not None:</span>
<span class="gi">+</span>
<span class="gi">+        def trim_url(x: str) -&gt; str:</span>
<span class="gi">+            if len(x) &gt; trim_url_limit:</span>
<span class="gi">+                return f&quot;{x[:trim_url_limit]}...&quot;</span>
<span class="gi">+</span>
<span class="gi">+            return x</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def trim_url(x: str) -&gt; str:</span>
<span class="gi">+            return x</span>
<span class="gi">+</span>
<span class="gi">+    words = re.split(r&quot;(\s+)&quot;, str(markupsafe.escape(text)))</span>
<span class="gi">+    rel_attr = f&#39; rel=&quot;{markupsafe.escape(rel)}&quot;&#39; if rel else &quot;&quot;</span>
<span class="gi">+    target_attr = f&#39; target=&quot;{markupsafe.escape(target)}&quot;&#39; if target else &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    for i, word in enumerate(words):</span>
<span class="gi">+        head, middle, tail = &quot;&quot;, word, &quot;&quot;</span>
<span class="gi">+        match = re.match(r&quot;^([(&lt;]|&amp;lt;)+&quot;, middle)</span>
<span class="gi">+</span>
<span class="gi">+        if match:</span>
<span class="gi">+            head = match.group()</span>
<span class="gi">+            middle = middle[match.end() :]</span>
<span class="gi">+</span>
<span class="gi">+        # Unlike lead, which is anchored to the start of the string,</span>
<span class="gi">+        # need to check that the string ends with any of the characters</span>
<span class="gi">+        # before trying to match all of them, to avoid backtracking.</span>
<span class="gi">+        if middle.endswith((&quot;)&quot;, &quot;&gt;&quot;, &quot;.&quot;, &quot;,&quot;, &quot;\n&quot;, &quot;&amp;gt;&quot;)):</span>
<span class="gi">+            match = re.search(r&quot;([)&gt;.,\n]|&amp;gt;)+$&quot;, middle)</span>
<span class="gi">+</span>
<span class="gi">+            if match:</span>
<span class="gi">+                tail = match.group()</span>
<span class="gi">+                middle = middle[: match.start()]</span>
<span class="gi">+</span>
<span class="gi">+        # Prefer balancing parentheses in URLs instead of ignoring a</span>
<span class="gi">+        # trailing character.</span>
<span class="gi">+        for start_char, end_char in (&quot;(&quot;, &quot;)&quot;), (&quot;&lt;&quot;, &quot;&gt;&quot;), (&quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;):</span>
<span class="gi">+            start_count = middle.count(start_char)</span>
<span class="gi">+</span>
<span class="gi">+            if start_count &lt;= middle.count(end_char):</span>
<span class="gi">+                # Balanced, or lighter on the left</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Move as many as possible from the tail to balance</span>
<span class="gi">+            for _ in range(min(start_count, tail.count(end_char))):</span>
<span class="gi">+                end_index = tail.index(end_char) + len(end_char)</span>
<span class="gi">+                # Move anything in the tail before the end char too</span>
<span class="gi">+                middle += tail[:end_index]</span>
<span class="gi">+                tail = tail[end_index:]</span>
<span class="gi">+</span>
<span class="gi">+        if _http_re.match(middle):</span>
<span class="gi">+            if middle.startswith(&quot;https://&quot;) or middle.startswith(&quot;http://&quot;):</span>
<span class="gi">+                middle = (</span>
<span class="gi">+                    f&#39;&lt;a href=&quot;{middle}&quot;{rel_attr}{target_attr}&gt;{trim_url(middle)}&lt;/a&gt;&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                middle = (</span>
<span class="gi">+                    f&#39;&lt;a href=&quot;https://{middle}&quot;{rel_attr}{target_attr}&gt;&#39;</span>
<span class="gi">+                    f&quot;{trim_url(middle)}&lt;/a&gt;&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        elif middle.startswith(&quot;mailto:&quot;) and _email_re.match(middle[7:]):</span>
<span class="gi">+            middle = f&#39;&lt;a href=&quot;{middle}&quot;&gt;{middle[7:]}&lt;/a&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        elif (</span>
<span class="gi">+            &quot;@&quot; in middle</span>
<span class="gi">+            and not middle.startswith(&quot;www.&quot;)</span>
<span class="gi">+            and &quot;:&quot; not in middle</span>
<span class="gi">+            and _email_re.match(middle)</span>
<span class="gi">+        ):</span>
<span class="gi">+            middle = f&#39;&lt;a href=&quot;mailto:{middle}&quot;&gt;{middle}&lt;/a&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        elif extra_schemes is not None:</span>
<span class="gi">+            for scheme in extra_schemes:</span>
<span class="gi">+                if middle != scheme and middle.startswith(scheme):</span>
<span class="gi">+                    middle = f&#39;&lt;a href=&quot;{middle}&quot;{rel_attr}{target_attr}&gt;{middle}&lt;/a&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        words[i] = f&quot;{head}{middle}{tail}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return &quot;&quot;.join(words)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generate_lorem_ipsum(</span>
<span class="gi">+    n: int = 5, html: bool = True, min: int = 20, max: int = 100</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate some lorem ipsum for the template.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from .constants import LOREM_IPSUM_WORDS</span>
<span class="gi">+</span>
<span class="gi">+    words = LOREM_IPSUM_WORDS.split()</span>
<span class="gi">+    result = []</span>
<span class="gi">+</span>
<span class="gi">+    for _ in range(n):</span>
<span class="gi">+        next_capitalized = True</span>
<span class="gi">+        last_comma = last_fullstop = 0</span>
<span class="gi">+        word = None</span>
<span class="gi">+        last = None</span>
<span class="gi">+        p = []</span>
<span class="gi">+</span>
<span class="gi">+        # each paragraph contains out of 20 to 100 words.</span>
<span class="gi">+        for idx, _ in enumerate(range(randrange(min, max))):</span>
<span class="gi">+            while True:</span>
<span class="gi">+                word = choice(words)</span>
<span class="gi">+                if word != last:</span>
<span class="gi">+                    last = word</span>
<span class="gi">+                    break</span>
<span class="gi">+            if next_capitalized:</span>
<span class="gi">+                word = word.capitalize()</span>
<span class="gi">+                next_capitalized = False</span>
<span class="gi">+            # add commas</span>
<span class="gi">+            if idx - randrange(3, 8) &gt; last_comma:</span>
<span class="gi">+                last_comma = idx</span>
<span class="gi">+                last_fullstop += 2</span>
<span class="gi">+                word += &quot;,&quot;</span>
<span class="gi">+            # add end of sentences</span>
<span class="gi">+            if idx - randrange(10, 20) &gt; last_fullstop:</span>
<span class="gi">+                last_comma = last_fullstop = idx</span>
<span class="gi">+                word += &quot;.&quot;</span>
<span class="gi">+                next_capitalized = True</span>
<span class="gi">+            p.append(word)</span>
<span class="gi">+</span>
<span class="gi">+        # ensure that the paragraph ends with a dot.</span>
<span class="gi">+        p_str = &quot; &quot;.join(p)</span>
<span class="gi">+</span>
<span class="gi">+        if p_str.endswith(&quot;,&quot;):</span>
<span class="gi">+            p_str = p_str[:-1] + &quot;.&quot;</span>
<span class="gi">+        elif not p_str.endswith(&quot;.&quot;):</span>
<span class="gi">+            p_str += &quot;.&quot;</span>
<span class="gi">+</span>
<span class="gi">+        result.append(p_str)</span>
<span class="gi">+</span>
<span class="gi">+    if not html:</span>
<span class="gi">+        return &quot;\n\n&quot;.join(result)</span>
<span class="gi">+    return markupsafe.Markup(</span>
<span class="gi">+        &quot;\n&quot;.join(f&quot;&lt;p&gt;{markupsafe.escape(x)}&lt;/p&gt;&quot; for x in result)</span>
<span class="gi">+    )</span>


<span class="gd">-def url_quote(obj: t.Any, charset: str=&#39;utf-8&#39;, for_qs: bool=False) -&gt;str:</span>
<span class="gi">+def url_quote(obj: t.Any, charset: str = &quot;utf-8&quot;, for_qs: bool = False) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Quote a string for use in a URL using the given charset.

<span class="w"> </span>    :param obj: String or bytes to quote. Other types are converted to
<span class="gu">@@ -218,60 +402,99 @@ def url_quote(obj: t.Any, charset: str=&#39;utf-8&#39;, for_qs: bool=False) -&gt;str:</span>
<span class="w"> </span>    :param charset: Encode text to bytes using this charset.
<span class="w"> </span>    :param for_qs: Quote &quot;/&quot; and use &quot;+&quot; for spaces.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(obj, bytes):</span>
<span class="gi">+        if not isinstance(obj, str):</span>
<span class="gi">+            obj = str(obj)</span>
<span class="gi">+</span>
<span class="gi">+        obj = obj.encode(charset)</span>
<span class="gi">+</span>
<span class="gi">+    safe = b&quot;&quot; if for_qs else b&quot;/&quot;</span>
<span class="gi">+    rv = quote_from_bytes(obj, safe)</span>
<span class="gi">+</span>
<span class="gi">+    if for_qs:</span>
<span class="gi">+        rv = rv.replace(&quot;%20&quot;, &quot;+&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return rv</span>


<span class="w"> </span>@abc.MutableMapping.register
<span class="w"> </span>class LRUCache:
<span class="w"> </span>    &quot;&quot;&quot;A simple LRU Cache implementation.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, capacity: int) -&gt;None:</span>
<span class="gi">+    # this is fast for small capacities (something below 1000) but doesn&#39;t</span>
<span class="gi">+    # scale.  But as long as it&#39;s only used as storage for templates this</span>
<span class="gi">+    # won&#39;t do any harm.</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, capacity: int) -&gt; None:</span>
<span class="w"> </span>        self.capacity = capacity
<span class="w"> </span>        self._mapping: t.Dict[t.Any, t.Any] = {}
<span class="gd">-        self._queue: &#39;te.Deque[t.Any]&#39; = deque()</span>
<span class="gi">+        self._queue: &quot;te.Deque[t.Any]&quot; = deque()</span>
<span class="w"> </span>        self._postinit()

<span class="gd">-    def __getstate__(self) -&gt;t.Mapping[str, t.Any]:</span>
<span class="gd">-        return {&#39;capacity&#39;: self.capacity, &#39;_mapping&#39;: self._mapping,</span>
<span class="gd">-            &#39;_queue&#39;: self._queue}</span>
<span class="gd">-</span>
<span class="gd">-    def __setstate__(self, d: t.Mapping[str, t.Any]) -&gt;None:</span>
<span class="gi">+    def _postinit(self) -&gt; None:</span>
<span class="gi">+        # alias all queue methods for faster lookup</span>
<span class="gi">+        self._popleft = self._queue.popleft</span>
<span class="gi">+        self._pop = self._queue.pop</span>
<span class="gi">+        self._remove = self._queue.remove</span>
<span class="gi">+        self._wlock = Lock()</span>
<span class="gi">+        self._append = self._queue.append</span>
<span class="gi">+</span>
<span class="gi">+    def __getstate__(self) -&gt; t.Mapping[str, t.Any]:</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;capacity&quot;: self.capacity,</span>
<span class="gi">+            &quot;_mapping&quot;: self._mapping,</span>
<span class="gi">+            &quot;_queue&quot;: self._queue,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def __setstate__(self, d: t.Mapping[str, t.Any]) -&gt; None:</span>
<span class="w"> </span>        self.__dict__.update(d)
<span class="w"> </span>        self._postinit()

<span class="gd">-    def __getnewargs__(self) -&gt;t.Tuple[t.Any, ...]:</span>
<span class="gd">-        return self.capacity,</span>
<span class="gi">+    def __getnewargs__(self) -&gt; t.Tuple[t.Any, ...]:</span>
<span class="gi">+        return (self.capacity,)</span>

<span class="gd">-    def copy(self) -&gt;&#39;LRUCache&#39;:</span>
<span class="gi">+    def copy(self) -&gt; &quot;LRUCache&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a shallow copy of the instance.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = self.__class__(self.capacity)</span>
<span class="gi">+        rv._mapping.update(self._mapping)</span>
<span class="gi">+        rv._queue.extend(self._queue)</span>
<span class="gi">+        return rv</span>

<span class="gd">-    def get(self, key: t.Any, default: t.Any=None) -&gt;t.Any:</span>
<span class="gi">+    def get(self, key: t.Any, default: t.Any = None) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an item from the cache dict or `default`&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return default</span>

<span class="gd">-    def setdefault(self, key: t.Any, default: t.Any=None) -&gt;t.Any:</span>
<span class="gi">+    def setdefault(self, key: t.Any, default: t.Any = None) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set `default` if the key is not in the cache otherwise
<span class="w"> </span>        leave unchanged. Return the value of this key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self[key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            self[key] = default</span>
<span class="gi">+            return default</span>

<span class="gd">-    def clear(self) -&gt;None:</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clear the cache.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._wlock:</span>
<span class="gi">+            self._mapping.clear()</span>
<span class="gi">+            self._queue.clear()</span>

<span class="gd">-    def __contains__(self, key: t.Any) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, key: t.Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a key exists in this cache.&quot;&quot;&quot;
<span class="w"> </span>        return key in self._mapping

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the current size of the cache.&quot;&quot;&quot;
<span class="w"> </span>        return len(self._mapping)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;{type(self).__name__} {self._mapping!r}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;{type(self).__name__} {self._mapping!r}&gt;&quot;</span>

<span class="gd">-    def __getitem__(self, key: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def __getitem__(self, key: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get an item from the cache. Moves the item up so that it has the
<span class="w"> </span>        highest priority then.

<span class="gu">@@ -279,15 +502,21 @@ class LRUCache:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        with self._wlock:
<span class="w"> </span>            rv = self._mapping[key]
<span class="gi">+</span>
<span class="w"> </span>            if self._queue[-1] != key:
<span class="w"> </span>                try:
<span class="w"> </span>                    self._remove(key)
<span class="w"> </span>                except ValueError:
<span class="gi">+                    # if something removed the key from the container</span>
<span class="gi">+                    # when we read, ignore the ValueError that we would</span>
<span class="gi">+                    # get otherwise.</span>
<span class="w"> </span>                    pass
<span class="gi">+</span>
<span class="w"> </span>                self._append(key)
<span class="gi">+</span>
<span class="w"> </span>            return rv

<span class="gd">-    def __setitem__(self, key: t.Any, value: t.Any) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, key: t.Any, value: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the value for an item. Moves the item up so that it
<span class="w"> </span>        has the highest priority then.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -296,46 +525,54 @@ class LRUCache:</span>
<span class="w"> </span>                self._remove(key)
<span class="w"> </span>            elif len(self._mapping) == self.capacity:
<span class="w"> </span>                del self._mapping[self._popleft()]
<span class="gi">+</span>
<span class="w"> </span>            self._append(key)
<span class="w"> </span>            self._mapping[key] = value

<span class="gd">-    def __delitem__(self, key: t.Any) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, key: t.Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove an item from the cache dict.
<span class="w"> </span>        Raise a `KeyError` if it does not exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        with self._wlock:
<span class="w"> </span>            del self._mapping[key]
<span class="gi">+</span>
<span class="w"> </span>            try:
<span class="w"> </span>                self._remove(key)
<span class="w"> </span>            except ValueError:
<span class="w"> </span>                pass

<span class="gd">-    def items(self) -&gt;t.Iterable[t.Tuple[t.Any, t.Any]]:</span>
<span class="gi">+    def items(self) -&gt; t.Iterable[t.Tuple[t.Any, t.Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of items.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = [(key, self._mapping[key]) for key in list(self._queue)]</span>
<span class="gi">+        result.reverse()</span>
<span class="gi">+        return result</span>

<span class="gd">-    def values(self) -&gt;t.Iterable[t.Any]:</span>
<span class="gi">+    def values(self) -&gt; t.Iterable[t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of all values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [x[1] for x in self.items()]</span>

<span class="gd">-    def keys(self) -&gt;t.Iterable[t.Any]:</span>
<span class="gi">+    def keys(self) -&gt; t.Iterable[t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of all keys ordered by most recent usage.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self)</span>

<span class="gd">-    def __iter__(self) -&gt;t.Iterator[t.Any]:</span>
<span class="gi">+    def __iter__(self) -&gt; t.Iterator[t.Any]:</span>
<span class="w"> </span>        return reversed(tuple(self._queue))

<span class="gd">-    def __reversed__(self) -&gt;t.Iterator[t.Any]:</span>
<span class="gi">+    def __reversed__(self) -&gt; t.Iterator[t.Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the keys in the cache dict, oldest items
<span class="w"> </span>        coming first.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return iter(tuple(self._queue))
<span class="gi">+</span>
<span class="w"> </span>    __copy__ = copy


<span class="gd">-def select_autoescape(enabled_extensions: t.Collection[str]=(&#39;html&#39;, &#39;htm&#39;,</span>
<span class="gd">-    &#39;xml&#39;), disabled_extensions: t.Collection[str]=(), default_for_string:</span>
<span class="gd">-    bool=True, default: bool=False) -&gt;t.Callable[[t.Optional[str]], bool]:</span>
<span class="gi">+def select_autoescape(</span>
<span class="gi">+    enabled_extensions: t.Collection[str] = (&quot;html&quot;, &quot;htm&quot;, &quot;xml&quot;),</span>
<span class="gi">+    disabled_extensions: t.Collection[str] = (),</span>
<span class="gi">+    default_for_string: bool = True,</span>
<span class="gi">+    default: bool = False,</span>
<span class="gi">+) -&gt; t.Callable[[t.Optional[str]], bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Intelligently sets the initial value of autoescaping based on the
<span class="w"> </span>    filename of the template.  This is the recommended way to configure
<span class="w"> </span>    autoescaping if you do not want to write a custom function yourself.
<span class="gu">@@ -370,11 +607,25 @@ def select_autoescape(enabled_extensions: t.Collection[str]=(&#39;html&#39;, &#39;htm&#39;,</span>

<span class="w"> </span>    .. versionadded:: 2.9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    enabled_patterns = tuple(f&quot;.{x.lstrip(&#39;.&#39;).lower()}&quot; for x in enabled_extensions)</span>
<span class="gi">+    disabled_patterns = tuple(f&quot;.{x.lstrip(&#39;.&#39;).lower()}&quot; for x in disabled_extensions)</span>
<span class="gi">+</span>
<span class="gi">+    def autoescape(template_name: t.Optional[str]) -&gt; bool:</span>
<span class="gi">+        if template_name is None:</span>
<span class="gi">+            return default_for_string</span>
<span class="gi">+        template_name = template_name.lower()</span>
<span class="gi">+        if template_name.endswith(enabled_patterns):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if template_name.endswith(disabled_patterns):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return default</span>

<span class="gi">+    return autoescape</span>

<span class="gd">-def htmlsafe_json_dumps(obj: t.Any, dumps: t.Optional[t.Callable[..., str]]</span>
<span class="gd">-    =None, **kwargs: t.Any) -&gt;markupsafe.Markup:</span>
<span class="gi">+</span>
<span class="gi">+def htmlsafe_json_dumps(</span>
<span class="gi">+    obj: t.Any, dumps: t.Optional[t.Callable[..., str]] = None, **kwargs: t.Any</span>
<span class="gi">+) -&gt; markupsafe.Markup:</span>
<span class="w"> </span>    &quot;&quot;&quot;Serialize an object to a string of JSON with :func:`json.dumps`,
<span class="w"> </span>    then replace HTML-unsafe characters with Unicode escapes and mark
<span class="w"> </span>    the result safe with :class:`~markupsafe.Markup`.
<span class="gu">@@ -400,7 +651,16 @@ def htmlsafe_json_dumps(obj: t.Any, dumps: t.Optional[t.Callable[..., str]]</span>

<span class="w"> </span>    .. versionadded:: 2.9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if dumps is None:</span>
<span class="gi">+        dumps = json.dumps</span>
<span class="gi">+</span>
<span class="gi">+    return markupsafe.Markup(</span>
<span class="gi">+        dumps(obj, **kwargs)</span>
<span class="gi">+        .replace(&quot;&lt;&quot;, &quot;\\u003c&quot;)</span>
<span class="gi">+        .replace(&quot;&gt;&quot;, &quot;\\u003e&quot;)</span>
<span class="gi">+        .replace(&quot;&amp;&quot;, &quot;\\u0026&quot;)</span>
<span class="gi">+        .replace(&quot;&#39;&quot;, &quot;\\u0027&quot;)</span>
<span class="gi">+    )</span>


<span class="w"> </span>class Cycler:
<span class="gu">@@ -429,42 +689,45 @@ class Cycler:</span>
<span class="w"> </span>    .. versionadded:: 2.1
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *items: t.Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *items: t.Any) -&gt; None:</span>
<span class="w"> </span>        if not items:
<span class="gd">-            raise RuntimeError(&#39;at least one item has to be provided&#39;)</span>
<span class="gi">+            raise RuntimeError(&quot;at least one item has to be provided&quot;)</span>
<span class="w"> </span>        self.items = items
<span class="w"> </span>        self.pos = 0

<span class="gd">-    def reset(self) -&gt;None:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets the current item to the first item.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.pos = 0</span>

<span class="w"> </span>    @property
<span class="gd">-    def current(self) -&gt;t.Any:</span>
<span class="gi">+    def current(self) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the current item. Equivalent to the item that will be
<span class="w"> </span>        returned next time :meth:`next` is called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.items[self.pos]</span>

<span class="gd">-    def next(self) -&gt;t.Any:</span>
<span class="gi">+    def next(self) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the current item, then advance :attr:`current` to the
<span class="w"> </span>        next item.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = self.current</span>
<span class="gi">+        self.pos = (self.pos + 1) % len(self.items)</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="w"> </span>    __next__ = next


<span class="w"> </span>class Joiner:
<span class="w"> </span>    &quot;&quot;&quot;A joining helper for templates.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, sep: str=&#39;, &#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, sep: str = &quot;, &quot;) -&gt; None:</span>
<span class="w"> </span>        self.sep = sep
<span class="w"> </span>        self.used = False

<span class="gd">-    def __call__(self) -&gt;str:</span>
<span class="gi">+    def __call__(self) -&gt; str:</span>
<span class="w"> </span>        if not self.used:
<span class="w"> </span>            self.used = True
<span class="gd">-            return &#39;&#39;</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="w"> </span>        return self.sep


<span class="gu">@@ -472,20 +735,21 @@ class Namespace:</span>
<span class="w"> </span>    &quot;&quot;&quot;A namespace object that can hold arbitrary attributes.  It may be
<span class="w"> </span>    initialized from a dictionary or with keyword arguments.&quot;&quot;&quot;

<span class="gd">-    def __init__(*args: t.Any, **kwargs: t.Any) -&gt;None:</span>
<span class="gi">+    def __init__(*args: t.Any, **kwargs: t.Any) -&gt; None:  # noqa: B902</span>
<span class="w"> </span>        self, args = args[0], args[1:]
<span class="w"> </span>        self.__attrs = dict(*args, **kwargs)

<span class="gd">-    def __getattribute__(self, name: str) -&gt;t.Any:</span>
<span class="gd">-        if name in {&#39;_Namespace__attrs&#39;, &#39;__class__&#39;}:</span>
<span class="gi">+    def __getattribute__(self, name: str) -&gt; t.Any:</span>
<span class="gi">+        # __class__ is needed for the awaitable check in async mode</span>
<span class="gi">+        if name in {&quot;_Namespace__attrs&quot;, &quot;__class__&quot;}:</span>
<span class="w"> </span>            return object.__getattribute__(self, name)
<span class="w"> </span>        try:
<span class="w"> </span>            return self.__attrs[name]
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            raise AttributeError(name) from None

<span class="gd">-    def __setitem__(self, name: str, value: t.Any) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, name: str, value: t.Any) -&gt; None:</span>
<span class="w"> </span>        self.__attrs[name] = value

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;Namespace {self.__attrs!r}&gt;&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;Namespace {self.__attrs!r}&gt;&quot;</span>
<span class="gh">diff --git a/src/jinja2/visitor.py b/src/jinja2/visitor.py</span>
<span class="gh">index ebb34c6..7b8e180 100644</span>
<span class="gd">--- a/src/jinja2/visitor.py</span>
<span class="gi">+++ b/src/jinja2/visitor.py</span>
<span class="gu">@@ -1,16 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot;API for traversing the AST nodes. Implemented by the compiler and
<span class="w"> </span>meta introspection.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import typing as t
<span class="gi">+</span>
<span class="w"> </span>from .nodes import Node
<span class="gi">+</span>
<span class="w"> </span>if t.TYPE_CHECKING:
<span class="w"> </span>    import typing_extensions as te

<span class="gd">-</span>
<span class="w"> </span>    class VisitCallable(te.Protocol):
<span class="gd">-</span>
<span class="gd">-        def __call__(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.Any:</span>
<span class="gd">-            ...</span>
<span class="gi">+        def __call__(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt; t.Any: ...</span>


<span class="w"> </span>class NodeVisitor:
<span class="gu">@@ -25,20 +25,26 @@ class NodeVisitor:</span>
<span class="w"> </span>    (return value `None`) the `generic_visit` visitor is used instead.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def get_visitor(self, node: Node) -&gt;&#39;t.Optional[VisitCallable]&#39;:</span>
<span class="gi">+    def get_visitor(self, node: Node) -&gt; &quot;t.Optional[VisitCallable]&quot;:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the visitor function for this node or `None` if no visitor
<span class="w"> </span>        exists for this node.  In that case the generic visit function is
<span class="w"> </span>        used instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return getattr(self, f&quot;visit_{type(node).__name__}&quot;, None)</span>

<span class="gd">-    def visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.Any:</span>
<span class="gi">+    def visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit a node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f = self.get_visitor(node)</span>

<span class="gd">-    def generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.Any:</span>
<span class="gi">+        if f is not None:</span>
<span class="gi">+            return f(node, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return self.generic_visit(node, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt; t.Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called if no explicit visitor function exists for a node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child_node in node.iter_child_nodes():</span>
<span class="gi">+            self.visit(child_node, *args, **kwargs)</span>


<span class="w"> </span>class NodeTransformer(NodeVisitor):
<span class="gu">@@ -52,9 +58,35 @@ class NodeTransformer(NodeVisitor):</span>
<span class="w"> </span>    replacement takes place.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def visit_list(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt;t.List[</span>
<span class="gd">-        Node]:</span>
<span class="gi">+    def generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt; Node:</span>
<span class="gi">+        for field, old_value in node.iter_fields():</span>
<span class="gi">+            if isinstance(old_value, list):</span>
<span class="gi">+                new_values = []</span>
<span class="gi">+                for value in old_value:</span>
<span class="gi">+                    if isinstance(value, Node):</span>
<span class="gi">+                        value = self.visit(value, *args, **kwargs)</span>
<span class="gi">+                        if value is None:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        elif not isinstance(value, Node):</span>
<span class="gi">+                            new_values.extend(value)</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    new_values.append(value)</span>
<span class="gi">+                old_value[:] = new_values</span>
<span class="gi">+            elif isinstance(old_value, Node):</span>
<span class="gi">+                new_node = self.visit(old_value, *args, **kwargs)</span>
<span class="gi">+                if new_node is None:</span>
<span class="gi">+                    delattr(node, field)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    setattr(node, field, new_node)</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_list(self, node: Node, *args: t.Any, **kwargs: t.Any) -&gt; t.List[Node]:</span>
<span class="w"> </span>        &quot;&quot;&quot;As transformers may return lists in some places this method
<span class="w"> </span>        can be used to enforce a list as return value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rv = self.visit(node, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(rv, list):</span>
<span class="gi">+            return [rv]</span>
<span class="gi">+</span>
<span class="gi">+        return rv</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
    
  </body>
</html>