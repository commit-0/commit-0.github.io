
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin python prompt toolkit - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-python-prompt-toolkit" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin python prompt toolkit
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-python-prompt-toolkit"><strong>Claude Sonnet 3.5 - Fill-in</strong>: python-prompt-toolkit</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>Pytest collection failure.
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/prompt_toolkit/application/application.py b/src/prompt_toolkit/application/application.py</span>
<span class="gh">index a630e551..88ef723e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/application/application.py</span>
<span class="gi">+++ b/src/prompt_toolkit/application/application.py</span>
<span class="gu">@@ -223,7 +223,16 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        Create a `Style` object that merges the default UI style, the default
<span class="w"> </span>        pygments style, and the custom user style.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        styles = []</span>
<span class="gi">+        styles.append(default_ui_style())</span>
<span class="gi">+</span>
<span class="gi">+        if include_default_pygments_style():</span>
<span class="gi">+            styles.append(default_pygments_style())</span>
<span class="gi">+</span>
<span class="gi">+        if self.style:</span>
<span class="gi">+            styles.append(self.style)</span>
<span class="gi">+</span>
<span class="gi">+        return merge_styles(styles)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def color_depth(self) -&gt;ColorDepth:
<span class="gu">@@ -239,7 +248,12 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>          created using `output.defaults.create_output`, then this value is
<span class="w"> </span>          coming from the $PROMPT_TOOLKIT_COLOR_DEPTH environment variable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if callable(self._color_depth):</span>
<span class="gi">+            value = self._color_depth()</span>
<span class="gi">+            if value is not None:</span>
<span class="gi">+                return value</span>
<span class="gi">+</span>
<span class="gi">+        return self.output.get_default_color_depth()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_buffer(self) -&gt;Buffer:
<span class="gu">@@ -250,7 +264,7 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        has the focus. In this case, it&#39;s really not practical to check for
<span class="w"> </span>        `None` values or catch exceptions every time.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.layout.current_control.buffer or Buffer()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_search_state(self) -&gt;SearchState:
<span class="gu">@@ -258,19 +272,42 @@ class Application(Generic[_AppResult]):</span>
<span class="w"> </span>        Return the current :class:`.SearchState`. (The one for the focused
<span class="w"> </span>        :class:`.BufferControl`.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        control = self.layout.current_control</span>
<span class="gi">+        if isinstance(control, BufferControl):</span>
<span class="gi">+            return control.search_state</span>
<span class="gi">+        return SearchState()</span>

<span class="w"> </span>    def reset(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reset everything, for reading the next input.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.layout.reset()</span>
<span class="gi">+        self.vi_state.reset()</span>
<span class="gi">+        self.emacs_state.reset()</span>
<span class="gi">+</span>
<span class="gi">+        self.renderer.reset()</span>
<span class="gi">+</span>
<span class="gi">+        self.exit_style = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.background_tasks = []</span>
<span class="gi">+</span>
<span class="gi">+        self.on_reset.fire()</span>

<span class="w"> </span>    def invalidate(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Thread safe way of sending a repaint trigger to the input event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.loop is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not self._invalidated:</span>
<span class="gi">+            self._invalidated = True</span>
<span class="gi">+</span>
<span class="gi">+            def redraw() -&gt;None:</span>
<span class="gi">+                self._invalidated = False</span>
<span class="gi">+                self._redraw()</span>
<span class="gi">+</span>
<span class="gi">+            call_soon_threadsafe(redraw, loop=self.loop)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def invalidated(self) -&gt;bool:
<span class="gh">diff --git a/src/prompt_toolkit/application/current.py b/src/prompt_toolkit/application/current.py</span>
<span class="gh">index 74edbaba..8c031f64 100644</span>
<span class="gd">--- a/src/prompt_toolkit/application/current.py</span>
<span class="gi">+++ b/src/prompt_toolkit/application/current.py</span>
<span class="gu">@@ -9,6 +9,9 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>__all__ = [&#39;AppSession&#39;, &#39;get_app_session&#39;, &#39;get_app&#39;, &#39;get_app_or_none&#39;,
<span class="w"> </span>    &#39;set_app&#39;, &#39;create_app_session&#39;, &#39;create_app_session_from_tty&#39;]

<span class="gi">+def get_app_session() -&gt; AppSession:</span>
<span class="gi">+    return _current_app_session.get()</span>
<span class="gi">+</span>

<span class="w"> </span>class AppSession:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -60,7 +63,11 @@ def get_app() -&gt;Application[Any]:</span>
<span class="w"> </span>    (For applications like pymux where we can have more than one `Application`,
<span class="w"> </span>    we&#39;ll use a work-around to handle that.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = get_app_session().app</span>
<span class="gi">+    if app is None:</span>
<span class="gi">+        from .dummy import DummyApplication</span>
<span class="gi">+        return DummyApplication()</span>
<span class="gi">+    return app</span>


<span class="w"> </span>def get_app_or_none() -&gt;(Application[Any] | None):
<span class="gu">@@ -68,7 +75,7 @@ def get_app_or_none() -&gt;(Application[Any] | None):</span>
<span class="w"> </span>    Get the current active (running) Application, or return `None` if no
<span class="w"> </span>    application is running.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app_session().app</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -83,7 +90,13 @@ def set_app(app: Application[Any]) -&gt;Generator[None, None, None]:</span>
<span class="w"> </span>    the case, use `contextvars.copy_context()`, or use `Application.context` to
<span class="w"> </span>    run it in the appropriate context.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    session = get_app_session()</span>
<span class="gi">+    previous_app = session.app</span>
<span class="gi">+    session.app = app</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        session.app = previous_app</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -95,7 +108,12 @@ def create_app_session(input: (Input | None)=None, output: (Output | None)=None</span>
<span class="w"> </span>    This is useful if there can be multiple individual `AppSession`s going on.
<span class="w"> </span>    Like in the case of an Telnet/SSH server.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    session = AppSession(input=input, output=output)</span>
<span class="gi">+    token = _current_app_session.set(session)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield session</span>
<span class="gi">+    finally:</span>
<span class="gi">+        _current_app_session.reset(token)</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -114,4 +132,11 @@ def create_app_session_from_tty() -&gt;Generator[AppSession, None, None]:</span>
<span class="w"> </span>        with create_app_session_from_tty():
<span class="w"> </span>            prompt(&#39;&gt;&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.input.defaults import create_input</span>
<span class="gi">+    from prompt_toolkit.output.defaults import create_output</span>
<span class="gi">+</span>
<span class="gi">+    input = create_input(always_prefer_tty=True)</span>
<span class="gi">+    output = create_output(always_prefer_tty=True)</span>
<span class="gi">+</span>
<span class="gi">+    with create_app_session(input=input, output=output) as session:</span>
<span class="gi">+        yield session</span>
<span class="gh">diff --git a/src/prompt_toolkit/application/run_in_terminal.py b/src/prompt_toolkit/application/run_in_terminal.py</span>
<span class="gh">index 2d3682ca..e80ebc9f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/application/run_in_terminal.py</span>
<span class="gi">+++ b/src/prompt_toolkit/application/run_in_terminal.py</span>
<span class="gu">@@ -34,12 +34,22 @@ def run_in_terminal(func: Callable[[], _T], render_cli_done: bool=False,</span>

<span class="w"> </span>    :returns: A `Future`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    async def run():</span>
<span class="gi">+        app = get_app_or_none()</span>
<span class="gi">+        if app is None:</span>
<span class="gi">+            return await run_in_executor_with_context(func) if in_executor else func()</span>
<span class="gi">+</span>
<span class="gi">+        async with in_terminal(render_cli_done):</span>
<span class="gi">+            if in_executor:</span>
<span class="gi">+                return await run_in_executor_with_context(func)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return func()</span>
<span class="gi">+</span>
<span class="gi">+    return ensure_future(run())</span>


<span class="w"> </span>@asynccontextmanager
<span class="gd">-async def in_terminal(render_cli_done: bool=False) -&gt;AsyncGenerator[None, None</span>
<span class="gd">-    ]:</span>
<span class="gi">+async def in_terminal(render_cli_done: bool=False) -&gt;AsyncGenerator[None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Asynchronous context manager that suspends the current application and runs
<span class="w"> </span>    the body in the terminal.
<span class="gu">@@ -51,4 +61,23 @@ async def in_terminal(render_cli_done: bool=False) -&gt;AsyncGenerator[None, None</span>
<span class="w"> </span>                call_some_function()
<span class="w"> </span>                await call_some_async_function()
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = get_app_or_none()</span>
<span class="gi">+    if app is None:</span>
<span class="gi">+        yield</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if render_cli_done:</span>
<span class="gi">+        app.pre_run_callables.append(app.renderer.erase)</span>
<span class="gi">+    else:</span>
<span class="gi">+        await app.run_system_command(lambda: None)</span>
<span class="gi">+</span>
<span class="gi">+    app.output.flush()</span>
<span class="gi">+    app._running_in_terminal = True</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        app._running_in_terminal = False</span>
<span class="gi">+        app.renderer.reset()</span>
<span class="gi">+        app._request_absolute_cursor_position()</span>
<span class="gi">+        app._redraw()</span>
<span class="gh">diff --git a/src/prompt_toolkit/auto_suggest.py b/src/prompt_toolkit/auto_suggest.py</span>
<span class="gh">index 2e73a69c..8efb440c 100644</span>
<span class="gd">--- a/src/prompt_toolkit/auto_suggest.py</span>
<span class="gi">+++ b/src/prompt_toolkit/auto_suggest.py</span>
<span class="gu">@@ -87,19 +87,32 @@ class ThreadedAutoSuggest(AutoSuggest):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run the `get_suggestion` function in a thread.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return await run_in_executor_with_context(</span>
<span class="gi">+            lambda: self.auto_suggest.get_suggestion(buff, document)</span>
<span class="gi">+        )</span>


<span class="w"> </span>class DummyAutoSuggest(AutoSuggest):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    AutoSuggest class that doesn&#39;t return any suggestion.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def get_suggestion(self, buffer: Buffer, document: Document) -&gt; None:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class AutoSuggestFromHistory(AutoSuggest):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Give suggestions based on the lines in the history.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def get_suggestion(self, buffer: Buffer, document: Document) -&gt; Suggestion | None:</span>
<span class="gi">+        history = buffer.history</span>
<span class="gi">+        text = document.text.lstrip()</span>
<span class="gi">+        </span>
<span class="gi">+        for string in reversed(list(history.get_strings())):</span>
<span class="gi">+            for line in reversed(string.splitlines()):</span>
<span class="gi">+                if line.startswith(text) and line != text:</span>
<span class="gi">+                    return Suggestion(line[len(text):])</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class ConditionalAutoSuggest(AutoSuggest):
<span class="gu">@@ -112,6 +125,11 @@ class ConditionalAutoSuggest(AutoSuggest):</span>
<span class="w"> </span>        self.auto_suggest = auto_suggest
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gi">+    def get_suggestion(self, buffer: Buffer, document: Document) -&gt; Suggestion | None:</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            return self.auto_suggest.get_suggestion(buffer, document)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicAutoSuggest(AutoSuggest):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -123,3 +141,9 @@ class DynamicAutoSuggest(AutoSuggest):</span>
<span class="w"> </span>    def __init__(self, get_auto_suggest: Callable[[], AutoSuggest | None]
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        self.get_auto_suggest = get_auto_suggest
<span class="gi">+</span>
<span class="gi">+    def get_suggestion(self, buffer: Buffer, document: Document) -&gt; Suggestion | None:</span>
<span class="gi">+        auto_suggest = self.get_auto_suggest()</span>
<span class="gi">+        if auto_suggest is not None:</span>
<span class="gi">+            return auto_suggest.get_suggestion(buffer, document)</span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/src/prompt_toolkit/buffer.py b/src/prompt_toolkit/buffer.py</span>
<span class="gh">index b2382429..9cf234d1 100644</span>
<span class="gd">--- a/src/prompt_toolkit/buffer.py</span>
<span class="gi">+++ b/src/prompt_toolkit/buffer.py</span>
<span class="gu">@@ -226,7 +226,15 @@ class Buffer:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param append_to_history: Append current input to history first.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if append_to_history:</span>
<span class="gi">+            self.append_to_history()</span>
<span class="gi">+</span>
<span class="gi">+        if document is None:</span>
<span class="gi">+            document = Document()</span>
<span class="gi">+</span>
<span class="gi">+        self.document = document</span>
<span class="gi">+        self._undo_stack = []</span>
<span class="gi">+        self._redo_stack = []</span>

<span class="w"> </span>    def load_history_if_not_yet_loaded(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -249,15 +257,22 @@ class Buffer:</span>
<span class="w"> </span>            thread, but history loading is the only place where it matters, and
<span class="w"> </span>            this solves it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._load_history_task is None:</span>
<span class="gi">+            async def load_history():</span>
<span class="gi">+                await self.history.load()</span>
<span class="gi">+            self._load_history_task = asyncio.create_task(load_history())</span>

<span class="w"> </span>    def _set_text(self, value: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;set text at current working_index. Return whether it changed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        original_value = self.text</span>
<span class="gi">+        self.text = value</span>
<span class="gi">+        return original_value != value</span>

<span class="w"> </span>    def _set_cursor_position(self, value: int) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Set cursor position. Return whether it changed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        original_position = self.cursor_position</span>
<span class="gi">+        self.cursor_position = max(0, min(value, len(self.text)))</span>
<span class="gi">+        return original_position != self.cursor_position</span>

<span class="w"> </span>    @text.setter
<span class="w"> </span>    def text(self, value: str) -&gt;None:
<span class="gu">@@ -266,14 +281,17 @@ class Buffer:</span>
<span class="w"> </span>        valid for this text. text/cursor_position should be consistent at any time,
<span class="w"> </span>        otherwise set a Document instead.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._set_text(value):</span>
<span class="gi">+            self.cursor_position = min(self.cursor_position, len(value))</span>
<span class="gi">+            self.on_text_changed.fire()</span>

<span class="w"> </span>    @cursor_position.setter
<span class="w"> </span>    def cursor_position(self, value: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Setting cursor position.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._set_cursor_position(value):</span>
<span class="gi">+            self.on_cursor_position_changed.fire()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def document(self) -&gt;Document:
<span class="gu">@@ -281,7 +299,10 @@ class Buffer:</span>
<span class="w"> </span>        Return :class:`~prompt_toolkit.document.Document` instance from the
<span class="w"> </span>        current text, cursor position and selection state.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._document_cache.get(</span>
<span class="gi">+            (self.text, self.cursor_position, self.selection_state),</span>
<span class="gi">+            lambda: Document(self.text, self.cursor_position, self.selection_state)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @document.setter
<span class="w"> </span>    def document(self, value: Document) -&gt;None:
<span class="gu">@@ -291,7 +312,7 @@ class Buffer:</span>
<span class="w"> </span>        This will set both the text and cursor position at the same time, but
<span class="w"> </span>        atomically. (Change events will be triggered only after both have been set.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_document(value)</span>

<span class="w"> </span>    def set_document(self, value: Document, bypass_readonly: bool=False
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -312,21 +333,32 @@ class Buffer:</span>
<span class="w"> </span>            you expect, and there won&#39;t be a stack trace. Use try/finally
<span class="w"> </span>            around this function if you need some cleanup code.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not bypass_readonly and self.read_only():</span>
<span class="gi">+            raise EditReadOnlyBuffer()</span>
<span class="gi">+</span>
<span class="gi">+        text_changed = self._set_text(value.text)</span>
<span class="gi">+        cursor_position_changed = self._set_cursor_position(value.cursor_position)</span>
<span class="gi">+</span>
<span class="gi">+        if text_changed:</span>
<span class="gi">+            self.on_text_changed.fire()</span>
<span class="gi">+        if cursor_position_changed:</span>
<span class="gi">+            self.on_cursor_position_changed.fire()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def is_returnable(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when there is something handling accept.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.accept_handler is not None</span>

<span class="w"> </span>    def save_to_undo_stack(self, clear_redo_stack: bool=True) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Safe current state (input text and cursor position), so that we can
<span class="w"> </span>        restore it by calling undo.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._undo_stack.append((self.text, self.cursor_position))</span>
<span class="gi">+        if clear_redo_stack:</span>
<span class="gi">+            self._redo_stack = []</span>

<span class="w"> </span>    def transform_lines(self, line_index_iterator: Iterable[int],
<span class="w"> </span>        transform_callback: Callable[[str], str]) -&gt;str:
<span class="gu">@@ -345,7 +377,16 @@ class Buffer:</span>

<span class="w"> </span>        :returns: The new text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines = self.text.splitlines(True)</span>
<span class="gi">+        new_lines = []</span>
<span class="gi">+</span>
<span class="gi">+        for index, original_line in enumerate(lines):</span>
<span class="gi">+            if index in line_index_iterator:</span>
<span class="gi">+                new_lines.append(transform_callback(original_line))</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_lines.append(original_line)</span>
<span class="gi">+</span>
<span class="gi">+        return &#39;&#39;.join(new_lines)</span>

<span class="w"> </span>    def transform_current_line(self, transform_callback: Callable[[str], str]
<span class="w"> </span>        ) -&gt;None:
<span class="gh">diff --git a/src/prompt_toolkit/cache.py b/src/prompt_toolkit/cache.py</span>
<span class="gh">index bfff0829..03b8455a 100644</span>
<span class="gd">--- a/src/prompt_toolkit/cache.py</span>
<span class="gi">+++ b/src/prompt_toolkit/cache.py</span>
<span class="gu">@@ -27,11 +27,23 @@ class SimpleCache(Generic[_T, _U]):</span>
<span class="w"> </span>        If not found, call `getter_func` to resolve it, and put that on the top
<span class="w"> </span>        of the cache instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key in self._data:</span>
<span class="gi">+            return self._data[key]</span>
<span class="gi">+        </span>
<span class="gi">+        value = getter_func()</span>
<span class="gi">+        self._data[key] = value</span>
<span class="gi">+        self._keys.append(key)</span>
<span class="gi">+        </span>
<span class="gi">+        if len(self._keys) &gt; self.maxsize:</span>
<span class="gi">+            oldest_key = self._keys.popleft()</span>
<span class="gi">+            del self._data[oldest_key]</span>
<span class="gi">+        </span>
<span class="gi">+        return value</span>

<span class="w"> </span>    def clear(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Clear cache.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._data.clear()</span>
<span class="gi">+        self._keys.clear()</span>


<span class="w"> </span>_K = TypeVar(&#39;_K&#39;, bound=Tuple[Hashable, ...])
<span class="gu">@@ -75,4 +87,14 @@ def memoized(maxsize: int=1024) -&gt;Callable[[_F], _F]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Memoization decorator for immutable classes and pure functions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func: _F) -&gt;_F:</span>
<span class="gi">+        cache = SimpleCache(maxsize)</span>
<span class="gi">+        </span>
<span class="gi">+        @wraps(func)</span>
<span class="gi">+        def wrapper(*args: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gi">+            key = (args, frozenset(kwargs.items()))</span>
<span class="gi">+            return cache.get(cast(_T, key), lambda: func(*args, **kwargs))</span>
<span class="gi">+        </span>
<span class="gi">+        return cast(_F, wrapper)</span>
<span class="gi">+    </span>
<span class="gi">+    return decorator</span>
<span class="gh">diff --git a/src/prompt_toolkit/clipboard/base.py b/src/prompt_toolkit/clipboard/base.py</span>
<span class="gh">index e09febd7..c92e9582 100644</span>
<span class="gd">--- a/src/prompt_toolkit/clipboard/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/clipboard/base.py</span>
<span class="gu">@@ -42,13 +42,14 @@ class Clipboard(metaclass=ABCMeta):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Shortcut for setting plain text on clipboard.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_data(ClipboardData(text))</span>

<span class="w"> </span>    def rotate(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For Emacs mode, rotate the kill ring.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This is a base implementation, which doesn&#39;t do anything.</span>
<span class="gi">+        # Subclasses can override this method if they support rotation.</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def get_data(self) -&gt;ClipboardData:
<span class="gu">@@ -62,6 +63,19 @@ class DummyClipboard(Clipboard):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Clipboard implementation that doesn&#39;t remember anything.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def set_data(self, data: ClipboardData) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Set data to the clipboard.</span>
<span class="gi">+</span>
<span class="gi">+        :param data: :class:`~.ClipboardData` instance.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        pass  # Dummy implementation, doesn&#39;t store anything</span>
<span class="gi">+</span>
<span class="gi">+    def get_data(self) -&gt;ClipboardData:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Return clipboard data.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return ClipboardData()  # Always return empty clipboard data</span>


<span class="w"> </span>class DynamicClipboard(Clipboard):
<span class="gu">@@ -73,3 +87,38 @@ class DynamicClipboard(Clipboard):</span>

<span class="w"> </span>    def __init__(self, get_clipboard: Callable[[], Clipboard | None]) -&gt;None:
<span class="w"> </span>        self.get_clipboard = get_clipboard
<span class="gi">+</span>
<span class="gi">+    def set_data(self, data: ClipboardData) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Set data to the clipboard.</span>
<span class="gi">+</span>
<span class="gi">+        :param data: :class:`~.ClipboardData` instance.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        clipboard = self.get_clipboard()</span>
<span class="gi">+        if clipboard:</span>
<span class="gi">+            clipboard.set_data(data)</span>
<span class="gi">+</span>
<span class="gi">+    def get_data(self) -&gt;ClipboardData:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Return clipboard data.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        clipboard = self.get_clipboard()</span>
<span class="gi">+        if clipboard:</span>
<span class="gi">+            return clipboard.get_data()</span>
<span class="gi">+        return ClipboardData()  # Return empty clipboard data if no clipboard is available</span>
<span class="gi">+</span>
<span class="gi">+    def set_text(self, text: str) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Shortcut for setting plain text on clipboard.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        clipboard = self.get_clipboard()</span>
<span class="gi">+        if clipboard:</span>
<span class="gi">+            clipboard.set_text(text)</span>
<span class="gi">+</span>
<span class="gi">+    def rotate(self) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        For Emacs mode, rotate the kill ring.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        clipboard = self.get_clipboard()</span>
<span class="gi">+        if clipboard:</span>
<span class="gi">+            clipboard.rotate()</span>
<span class="gh">diff --git a/src/prompt_toolkit/completion/base.py b/src/prompt_toolkit/completion/base.py</span>
<span class="gh">index 62214619..66210e72 100644</span>
<span class="gd">--- a/src/prompt_toolkit/completion/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/completion/base.py</span>
<span class="gu">@@ -65,17 +65,20 @@ class Completion:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def display_text(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;The &#39;display&#39; field as plain text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;&#39;.join(text for _, text in self.display)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def display_meta(self) -&gt;StyleAndTextTuples:
<span class="w"> </span>        &quot;&quot;&quot;Return meta-text. (This is lazy when using a callable).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from prompt_toolkit.formatted_text import to_formatted_text</span>
<span class="gi">+        if callable(self._display_meta):</span>
<span class="gi">+            return to_formatted_text(self._display_meta())</span>
<span class="gi">+        return to_formatted_text(self._display_meta)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def display_meta_text(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;The &#39;meta&#39; field as plain text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39;&#39;.join(text for _, text in self.display_meta)</span>

<span class="w"> </span>    def new_completion_from_position(self, position: int) -&gt;Completion:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -84,7 +87,14 @@ class Completion:</span>
<span class="w"> </span>        it needs to have a list of new completions after inserting the common
<span class="w"> </span>        prefix.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Completion(</span>
<span class="gi">+            text=self.text[position:],</span>
<span class="gi">+            start_position=self.start_position + position,</span>
<span class="gi">+            display=self.display,</span>
<span class="gi">+            display_meta=self._display_meta,</span>
<span class="gi">+            style=self.style,</span>
<span class="gi">+            selected_style=self.selected_style</span>
<span class="gi">+        )</span>


<span class="w"> </span>class CompleteEvent:
<span class="gu">@@ -143,7 +153,8 @@ class Completer(metaclass=ABCMeta):</span>

<span class="w"> </span>        Asynchronous generator of :class:`.Completion` objects.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        async for completion in generator_to_async_generator(lambda: self.get_completions(document, complete_event)):</span>
<span class="gi">+            yield completion</span>


<span class="w"> </span>class ThreadedCompleter(Completer):
<span class="gu">@@ -165,7 +176,12 @@ class ThreadedCompleter(Completer):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Asynchronous generator of completions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        import asyncio</span>
<span class="gi">+        loop = asyncio.get_event_loop()</span>
<span class="gi">+        return await loop.run_in_executor(</span>
<span class="gi">+            None,</span>
<span class="gi">+            lambda: generator_to_async_generator(lambda: self.completer.get_completions(document, complete_event))</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return f&#39;ThreadedCompleter({self.completer!r})&#39;
<span class="gu">@@ -233,7 +249,12 @@ def merge_completers(completers: Sequence[Completer], deduplicate: bool=False</span>
<span class="w"> </span>        so that completions that would result in the same text will be
<span class="w"> </span>        deduplicated.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.completion.deduplicate import DeduplicateCompleter</span>
<span class="gi">+</span>
<span class="gi">+    result = _MergedCompleter(completers)</span>
<span class="gi">+    if deduplicate:</span>
<span class="gi">+        return DeduplicateCompleter(result)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def get_common_complete_suffix(document: Document, completions: Sequence[
<span class="gu">@@ -241,4 +262,19 @@ def get_common_complete_suffix(document: Document, completions: Sequence[</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the common prefix for all completions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not completions:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Get all suffixes.</span>
<span class="gi">+    suffixes = [c.text for c in completions]</span>
<span class="gi">+</span>
<span class="gi">+    # Compute common suffix.</span>
<span class="gi">+    common_suffix = suffixes[0]</span>
<span class="gi">+    for s in suffixes[1:]:</span>
<span class="gi">+        common_suffix = common_suffix[:len(s)]</span>
<span class="gi">+        for i in range(len(common_suffix)):</span>
<span class="gi">+            if common_suffix[i] != s[i]:</span>
<span class="gi">+                common_suffix = common_suffix[:i]</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    return common_suffix</span>
<span class="gh">diff --git a/src/prompt_toolkit/completion/fuzzy_completer.py b/src/prompt_toolkit/completion/fuzzy_completer.py</span>
<span class="gh">index fc4b7e20..d4505a56 100644</span>
<span class="gd">--- a/src/prompt_toolkit/completion/fuzzy_completer.py</span>
<span class="gi">+++ b/src/prompt_toolkit/completion/fuzzy_completer.py</span>
<span class="gu">@@ -52,7 +52,24 @@ class FuzzyCompleter(Completer):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generate formatted text for the display label.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        match_start = fuzzy_match.start_pos</span>
<span class="gi">+        match_end = match_start + fuzzy_match.match_length</span>
<span class="gi">+        word = fuzzy_match.completion.text</span>
<span class="gi">+</span>
<span class="gi">+        result: StyleAndTextTuples = []</span>
<span class="gi">+        </span>
<span class="gi">+        # Add characters before match</span>
<span class="gi">+        if match_start &gt; 0:</span>
<span class="gi">+            result.append((&#39;&#39;, word[:match_start]))</span>
<span class="gi">+        </span>
<span class="gi">+        # Add matched characters</span>
<span class="gi">+        result.append((&#39;class:fuzzy-match&#39;, word[match_start:match_end]))</span>
<span class="gi">+        </span>
<span class="gi">+        # Add characters after match</span>
<span class="gi">+        if match_end &lt; len(word):</span>
<span class="gi">+            result.append((&#39;&#39;, word[match_end:]))</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class FuzzyWordCompleter(Completer):
<span class="gh">diff --git a/src/prompt_toolkit/completion/nested.py b/src/prompt_toolkit/completion/nested.py</span>
<span class="gh">index 130f3429..fed3c5b3 100644</span>
<span class="gd">--- a/src/prompt_toolkit/completion/nested.py</span>
<span class="gi">+++ b/src/prompt_toolkit/completion/nested.py</span>
<span class="gu">@@ -57,4 +57,16 @@ class NestedCompleter(Completer):</span>

<span class="w"> </span>        Values in this data structure can be a completers as well.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        options: dict[str, Completer | None] = {}</span>
<span class="gi">+</span>
<span class="gi">+        for key, value in data.items():</span>
<span class="gi">+            if isinstance(value, Mapping):</span>
<span class="gi">+                options[key] = cls.from_nested_dict(value)</span>
<span class="gi">+            elif isinstance(value, Set):</span>
<span class="gi">+                options[key] = WordCompleter(list(value))</span>
<span class="gi">+            elif isinstance(value, Completer):</span>
<span class="gi">+                options[key] = value</span>
<span class="gi">+            else:</span>
<span class="gi">+                options[key] = None</span>
<span class="gi">+</span>
<span class="gi">+        return cls(options)</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/regular_languages/compiler.py b/src/prompt_toolkit/contrib/regular_languages/compiler.py</span>
<span class="gh">index b154d948..5e0d9208 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/regular_languages/compiler.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/regular_languages/compiler.py</span>
<span class="gu">@@ -87,13 +87,19 @@ class _CompiledGrammar:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Escape `value` to fit in the place of this variable into the grammar.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        escape_func = self.escape_funcs.get(varname)</span>
<span class="gi">+        if escape_func:</span>
<span class="gi">+            return escape_func(value)</span>
<span class="gi">+        return re.escape(value)</span>

<span class="w"> </span>    def unescape(self, varname: str, value: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Unescape `value`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        unescape_func = self.unescape_funcs.get(varname)</span>
<span class="gi">+        if unescape_func:</span>
<span class="gi">+            return unescape_func(value)</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _transform(cls, root_node: Node, create_group_func: Callable[[
<span class="gu">@@ -105,7 +111,20 @@ class _CompiledGrammar:</span>
<span class="w"> </span>        :param create_group_func: A callable which takes a `Node` and returns the next
<span class="w"> </span>            free name for this node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(root_node, Variable):</span>
<span class="gi">+            return f&#39;(?P&lt;{create_group_func(root_node)}&gt;.+?)&#39;</span>
<span class="gi">+        elif isinstance(root_node, Regex):</span>
<span class="gi">+            return root_node.regex</span>
<span class="gi">+        elif isinstance(root_node, Repeat):</span>
<span class="gi">+            return f&#39;({cls._transform(root_node.childnode, create_group_func)}){root_node.cardinality}&#39;</span>
<span class="gi">+        elif isinstance(root_node, Lookahead):</span>
<span class="gi">+            return f&#39;(?={cls._transform(root_node.childnode, create_group_func)})&#39;</span>
<span class="gi">+        elif isinstance(root_node, NodeSequence):</span>
<span class="gi">+            return &#39;&#39;.join(cls._transform(c, create_group_func) for c in root_node.children)</span>
<span class="gi">+        elif isinstance(root_node, AnyNode):</span>
<span class="gi">+            return f&quot;({&#39;|&#39;.join(cls._transform(c, create_group_func) for c in root_node.children)})&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid node type: {type(root_node)}&quot;)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _transform_prefix(cls, root_node: Node, create_group_func: Callable
<span class="gu">@@ -131,7 +150,28 @@ class _CompiledGrammar:</span>
<span class="w"> </span>        :param create_group_func: A callable which takes a `Node` and returns the next
<span class="w"> </span>            free name for this node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(root_node, Variable):</span>
<span class="gi">+            yield f&#39;^(?P&lt;{create_group_func(root_node)}&gt;.+?)$&#39;</span>
<span class="gi">+        elif isinstance(root_node, Regex):</span>
<span class="gi">+            yield f&#39;^{root_node.regex}$&#39;</span>
<span class="gi">+        elif isinstance(root_node, Repeat):</span>
<span class="gi">+            child_patterns = list(cls._transform_prefix(root_node.childnode, create_group_func))</span>
<span class="gi">+            for i in range(1, root_node.max_repeat + 1):</span>
<span class="gi">+                yield from (f&#39;^{p * i}$&#39; for p in child_patterns)</span>
<span class="gi">+        elif isinstance(root_node, Lookahead):</span>
<span class="gi">+            yield from (f&#39;^(?={p})$&#39; for p in cls._transform_prefix(root_node.childnode, create_group_func))</span>
<span class="gi">+        elif isinstance(root_node, NodeSequence):</span>
<span class="gi">+            current = &#39;^&#39;</span>
<span class="gi">+            for child in root_node.children:</span>
<span class="gi">+                child_patterns = list(cls._transform_prefix(child, create_group_func))</span>
<span class="gi">+                for pattern in child_patterns:</span>
<span class="gi">+                    yield f&#39;{current}{pattern[1:-1]}$&#39;</span>
<span class="gi">+                current += cls._transform(child, create_group_func)</span>
<span class="gi">+        elif isinstance(root_node, AnyNode):</span>
<span class="gi">+            for child in root_node.children:</span>
<span class="gi">+                yield from cls._transform_prefix(child, create_group_func)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid node type: {type(root_node)}&quot;)</span>

<span class="w"> </span>    def match(self, string: str) -&gt;(Match | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -140,7 +180,10 @@ class _CompiledGrammar:</span>

<span class="w"> </span>        :param string: The input string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = self._re.match(string)</span>
<span class="gi">+        if m:</span>
<span class="gi">+            return Match(string, [(self._re, m)], self._group_names_to_nodes, self.unescape_funcs)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def match_prefix(self, string: str) -&gt;(Match | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -151,7 +194,19 @@ class _CompiledGrammar:</span>

<span class="w"> </span>        :param string: The input string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        matches = []</span>
<span class="gi">+        for re in self._re_prefix_with_trailing_input:</span>
<span class="gi">+            m = re.match(string)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                matches.append((re, m))</span>
<span class="gi">+        </span>
<span class="gi">+        if not matches:</span>
<span class="gi">+            # If no match, consider all input as trailing</span>
<span class="gi">+            dummy_re = re.compile(f&#39;^(?P&lt;{_INVALID_TRAILING_INPUT}&gt;.*)$&#39;)</span>
<span class="gi">+            m = dummy_re.match(string)</span>
<span class="gi">+            matches.append((dummy_re, m))</span>
<span class="gi">+        </span>
<span class="gi">+        return Match(string, matches, self._group_names_to_nodes, self.unescape_funcs)</span>


<span class="w"> </span>class Match:
<span class="gu">@@ -173,19 +228,29 @@ class Match:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of (varname, reg) tuples.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for re, match in self._re_matches:</span>
<span class="gi">+            for group_name, node_name in self._group_names_to_nodes.items():</span>
<span class="gi">+                if group_name in match.groupdict():</span>
<span class="gi">+                    start, end = match.span(group_name)</span>
<span class="gi">+                    result.append((node_name, (start, end)))</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def _nodes_to_values(self) -&gt;list[tuple[str, str, tuple[int, int]]]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns list of (Node, string_value) tuples.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for varname, reg in self._nodes_to_regs():</span>
<span class="gi">+            value = self.string[reg[0]:reg[1]]</span>
<span class="gi">+            result.append((varname, value, reg))</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def variables(self) -&gt;Variables:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns :class:`Variables` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Variables(self._nodes_to_values())</span>

<span class="w"> </span>    def trailing_input(self) -&gt;(MatchVariable | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -193,14 +258,21 @@ class Match:</span>
<span class="w"> </span>        &quot;Trailing input&quot; is input at the end that does not match the grammar anymore, but
<span class="w"> </span>        when this is removed from the end of the input, the input would be a valid string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for re, match in self._re_matches:</span>
<span class="gi">+            if _INVALID_TRAILING_INPUT in match.groupdict():</span>
<span class="gi">+                start, end = match.span(_INVALID_TRAILING_INPUT)</span>
<span class="gi">+                return MatchVariable(_INVALID_TRAILING_INPUT, self.string[start:end], (start, end))</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def end_nodes(self) -&gt;Iterable[MatchVariable]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Yields `MatchVariable` instances for all the nodes having their end
<span class="w"> </span>        position at the end of the input string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        input_len = len(self.string)</span>
<span class="gi">+        for varname, value, (start, end) in self._nodes_to_values():</span>
<span class="gi">+            if end == input_len:</span>
<span class="gi">+                yield MatchVariable(varname, value, (start, end))</span>


<span class="w"> </span>class Variables:
<span class="gu">@@ -251,7 +323,9 @@ def compile(expression: str, escape_funcs: (EscapeFuncDict | None)=None,</span>
<span class="w"> </span>    Compile grammar (given as regex string), returning a `CompiledGrammar`
<span class="w"> </span>    instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tokens = list(tokenize_regex(expression))</span>
<span class="gi">+    root_node = parse_regex(tokens)</span>
<span class="gi">+    return _compile_from_parse_tree(root_node, escape_funcs, unescape_funcs)</span>


<span class="w"> </span>def _compile_from_parse_tree(root_node: Node, escape_funcs: (EscapeFuncDict |
<span class="gu">@@ -261,4 +335,4 @@ def _compile_from_parse_tree(root_node: Node, escape_funcs: (EscapeFuncDict |</span>
<span class="w"> </span>    Compile grammar (given as parse tree), returning a `CompiledGrammar`
<span class="w"> </span>    instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _CompiledGrammar(root_node, escape_funcs, unescape_funcs)</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/regular_languages/completion.py b/src/prompt_toolkit/contrib/regular_languages/completion.py</span>
<span class="gh">index cf287636..a8050055 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/regular_languages/completion.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/regular_languages/completion.py</span>
<span class="gu">@@ -31,7 +31,12 @@ class GrammarCompleter(Completer):</span>
<span class="w"> </span>        (The completer assumes that the cursor position was at the end of the
<span class="w"> </span>        input string.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for var_name, value in match.variables():</span>
<span class="gi">+            if var_name in self.completers:</span>
<span class="gi">+                completer = self.completers[var_name]</span>
<span class="gi">+                # Create a new document for the completer</span>
<span class="gi">+                document = Document(value, cursor_position=len(value))</span>
<span class="gi">+                yield from completer.get_completions(document, complete_event)</span>

<span class="w"> </span>    def _remove_duplicates(self, items: Iterable[Completion]) -&gt;list[Completion
<span class="w"> </span>        ]:
<span class="gu">@@ -40,4 +45,10 @@ class GrammarCompleter(Completer):</span>
<span class="w"> </span>        (Sometimes we have duplicates, because the there several matches of the
<span class="w"> </span>        same grammar, each yielding similar completions.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        seen = set()</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for item in items:</span>
<span class="gi">+            if item.text not in seen:</span>
<span class="gi">+                seen.add(item.text)</span>
<span class="gi">+                result.append(item)</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/regular_languages/regex_parser.py b/src/prompt_toolkit/contrib/regular_languages/regex_parser.py</span>
<span class="gh">index ba97c928..bad83eb1 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/regular_languages/regex_parser.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/regular_languages/regex_parser.py</span>
<span class="gu">@@ -131,11 +131,82 @@ def tokenize_regex(input: str) -&gt;list[str]:</span>
<span class="w"> </span>    :param input: string, representing a regular expression.
<span class="w"> </span>    :returns: List of tokens.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tokens = []</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while i &lt; len(input):</span>
<span class="gi">+        if input[i].isspace():</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            continue</span>
<span class="gi">+        if input[i] == &#39;#&#39;:</span>
<span class="gi">+            while i &lt; len(input) and input[i] != &#39;\n&#39;:</span>
<span class="gi">+                i += 1</span>
<span class="gi">+            continue</span>
<span class="gi">+        if input[i] in &#39;()|*+?{}[]&#39;:</span>
<span class="gi">+            tokens.append(input[i])</span>
<span class="gi">+            i += 1</span>
<span class="gi">+        elif input[i] == &#39;\\&#39;:</span>
<span class="gi">+            if i + 1 &lt; len(input):</span>
<span class="gi">+                tokens.append(input[i:i+2])</span>
<span class="gi">+                i += 2</span>
<span class="gi">+            else:</span>
<span class="gi">+                tokens.append(input[i])</span>
<span class="gi">+                i += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            start = i</span>
<span class="gi">+            while i &lt; len(input) and input[i] not in &#39;()|*+?{}[]\\&#39; and not input[i].isspace():</span>
<span class="gi">+                i += 1</span>
<span class="gi">+            tokens.append(input[start:i])</span>
<span class="gi">+    return tokens</span>


<span class="w"> </span>def parse_regex(regex_tokens: list[str]) -&gt;Node:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Takes a list of tokens from the tokenizer, and returns a parse tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def parse_sequence():</span>
<span class="gi">+        sequence = []</span>
<span class="gi">+        while tokens and tokens[0] not in &#39;)|&#39;:</span>
<span class="gi">+            sequence.append(parse_atom())</span>
<span class="gi">+        return NodeSequence(sequence) if len(sequence) &gt; 1 else sequence[0] if sequence else None</span>
<span class="gi">+</span>
<span class="gi">+    def parse_atom():</span>
<span class="gi">+        if not tokens:</span>
<span class="gi">+            return None</span>
<span class="gi">+        token = tokens.pop(0)</span>
<span class="gi">+        if token == &#39;(&#39;:</span>
<span class="gi">+            node = parse_sequence()</span>
<span class="gi">+            if tokens and tokens[0] == &#39;)&#39;:</span>
<span class="gi">+                tokens.pop(0)</span>
<span class="gi">+            return node</span>
<span class="gi">+        elif token == &#39;[&#39;:</span>
<span class="gi">+            content = &#39;&#39;</span>
<span class="gi">+            while tokens and tokens[0] != &#39;]&#39;:</span>
<span class="gi">+                content += tokens.pop(0)</span>
<span class="gi">+            if tokens and tokens[0] == &#39;]&#39;:</span>
<span class="gi">+                tokens.pop(0)</span>
<span class="gi">+            return Regex(f&#39;[{content}]&#39;)</span>
<span class="gi">+        elif token in &#39;*+?&#39;:</span>
<span class="gi">+            return Repeat(parse_atom(), 0 if token in &#39;*?&#39; else 1, None if token in &#39;*+&#39; else 1)</span>
<span class="gi">+        elif token == &#39;{&#39;:</span>
<span class="gi">+            min_repeat = max_repeat = &#39;&#39;</span>
<span class="gi">+            while tokens and tokens[0] not in &#39;,}&#39;:</span>
<span class="gi">+                min_repeat += tokens.pop(0)</span>
<span class="gi">+            if tokens and tokens[0] == &#39;,&#39;:</span>
<span class="gi">+                tokens.pop(0)</span>
<span class="gi">+                while tokens and tokens[0] != &#39;}&#39;:</span>
<span class="gi">+                    max_repeat += tokens.pop(0)</span>
<span class="gi">+            if tokens and tokens[0] == &#39;}&#39;:</span>
<span class="gi">+                tokens.pop(0)</span>
<span class="gi">+            return Repeat(parse_atom(), int(min_repeat) if min_repeat else 0, int(max_repeat) if max_repeat else None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return Regex(token)</span>
<span class="gi">+</span>
<span class="gi">+    tokens = regex_tokens.copy()</span>
<span class="gi">+    result = parse_sequence()</span>
<span class="gi">+    while tokens:</span>
<span class="gi">+        if tokens[0] == &#39;|&#39;:</span>
<span class="gi">+            tokens.pop(0)</span>
<span class="gi">+            result = AnyNode([result, parse_sequence()])</span>
<span class="gi">+        else:</span>
<span class="gi">+            break</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/ssh/server.py b/src/prompt_toolkit/contrib/ssh/server.py</span>
<span class="gh">index 73ec9401..68bc92d1 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/ssh/server.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/ssh/server.py</span>
<span class="gu">@@ -52,7 +52,10 @@ class PromptToolkitSSHSession(asyncssh.SSHServerSession):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Callable that returns the current `Size`, required by Vt100_Output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._chan is None:</span>
<span class="gi">+            return Size(rows=24, columns=80)  # Default size if channel is not available</span>
<span class="gi">+        width, height, _, _ = self._chan.get_terminal_size()</span>
<span class="gi">+        return Size(rows=height, columns=width)</span>


<span class="w"> </span>class PromptToolkitSSHServer(asyncssh.SSHServer):
<span class="gh">diff --git a/src/prompt_toolkit/contrib/telnet/protocol.py b/src/prompt_toolkit/contrib/telnet/protocol.py</span>
<span class="gh">index f58280d4..8c337a4d 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/telnet/protocol.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/telnet/protocol.py</span>
<span class="gu">@@ -63,47 +63,106 @@ class TelnetProtocolParser:</span>

<span class="w"> </span>    def do_received(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Received telnet DO command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(f&quot;Received DO command: {data}&quot;)</span>
<span class="gi">+        # Respond with WILL if we support the option, WONT otherwise</span>
<span class="gi">+        # This is a simplified implementation</span>
<span class="gi">+        self.feed(IAC + WILL + data)</span>

<span class="w"> </span>    def dont_received(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Received telnet DONT command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(f&quot;Received DONT command: {data}&quot;)</span>
<span class="gi">+        # Acknowledge the DONT command</span>
<span class="gi">+        self.feed(IAC + WONT + data)</span>

<span class="w"> </span>    def will_received(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Received telnet WILL command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(f&quot;Received WILL command: {data}&quot;)</span>
<span class="gi">+        # Respond with DO if we want to enable the option, DONT otherwise</span>
<span class="gi">+        # This is a simplified implementation</span>
<span class="gi">+        self.feed(IAC + DO + data)</span>

<span class="w"> </span>    def wont_received(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Received telnet WONT command.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(f&quot;Received WONT command: {data}&quot;)</span>
<span class="gi">+        # Acknowledge the WONT command</span>
<span class="gi">+        self.feed(IAC + DONT + data)</span>

<span class="w"> </span>    def naws(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Received NAWS. (Window dimensions.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(data) == 4:</span>
<span class="gi">+            columns, rows = struct.unpack(&#39;!HH&#39;, data)</span>
<span class="gi">+            logger.debug(f&quot;Received NAWS: {columns}x{rows}&quot;)</span>
<span class="gi">+            self.size_received_callback(rows, columns)</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.warning(f&quot;Invalid NAWS data received: {data}&quot;)</span>

<span class="w"> </span>    def ttype(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Received terminal type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if data.startswith(IS):</span>
<span class="gi">+            terminal_type = data[1:].decode(&#39;ascii&#39;, errors=&#39;ignore&#39;)</span>
<span class="gi">+            logger.debug(f&quot;Received terminal type: {terminal_type}&quot;)</span>
<span class="gi">+            self.ttype_received_callback(terminal_type)</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.warning(f&quot;Invalid TTYPE data received: {data}&quot;)</span>

<span class="w"> </span>    def negotiate(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Got negotiate data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(f&quot;Negotiating: {data}&quot;)</span>
<span class="gi">+        # This method can be expanded to handle specific negotiation scenarios</span>
<span class="gi">+        # For now, we&#39;ll just log the data</span>

<span class="w"> </span>    def _parse_coroutine(self) -&gt;Generator[None, bytes, None]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Parser state machine.
<span class="w"> </span>        Every &#39;yield&#39; expression returns the next byte.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            d = yield</span>
<span class="gi">+            if d == IAC:</span>
<span class="gi">+                d = yield</span>
<span class="gi">+                if d == IAC:</span>
<span class="gi">+                    self.data_received_callback(IAC)</span>
<span class="gi">+                elif d in (DO, DONT, WILL, WONT):</span>
<span class="gi">+                    command = d</span>
<span class="gi">+                    d = yield</span>
<span class="gi">+                    if command == DO:</span>
<span class="gi">+                        self.do_received(d)</span>
<span class="gi">+                    elif command == DONT:</span>
<span class="gi">+                        self.dont_received(d)</span>
<span class="gi">+                    elif command == WILL:</span>
<span class="gi">+                        self.will_received(d)</span>
<span class="gi">+                    elif command == WONT:</span>
<span class="gi">+                        self.wont_received(d)</span>
<span class="gi">+                elif d == SB:</span>
<span class="gi">+                    buffer = []</span>
<span class="gi">+                    while True:</span>
<span class="gi">+                        d = yield</span>
<span class="gi">+                        if d == IAC:</span>
<span class="gi">+                            d = yield</span>
<span class="gi">+                            if d == SE:</span>
<span class="gi">+                                break</span>
<span class="gi">+                        buffer.append(d)</span>
<span class="gi">+                    buffer = b&#39;&#39;.join(buffer)</span>
<span class="gi">+                    if buffer.startswith(NAWS):</span>
<span class="gi">+                        self.naws(buffer[1:])</span>
<span class="gi">+                    elif buffer.startswith(TTYPE):</span>
<span class="gi">+                        self.ttype(buffer[1:])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.negotiate(buffer)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.negotiate(d)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.data_received_callback(d)</span>

<span class="w"> </span>    def feed(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Feed data to the parser.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for b in data:</span>
<span class="gi">+            self._parser.send(bytes([b]))</span>
<span class="gh">diff --git a/src/prompt_toolkit/contrib/telnet/server.py b/src/prompt_toolkit/contrib/telnet/server.py</span>
<span class="gh">index 4feaaadb..88ed36c4 100644</span>
<span class="gd">--- a/src/prompt_toolkit/contrib/telnet/server.py</span>
<span class="gi">+++ b/src/prompt_toolkit/contrib/telnet/server.py</span>
<span class="gu">@@ -84,38 +84,54 @@ class TelnetConnection:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run application.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        await self._ready.wait()</span>
<span class="gi">+        self.context = contextvars.copy_context()</span>
<span class="gi">+        with create_app_session(input=self.vt100_input, output=self.vt100_output):</span>
<span class="gi">+            await self.interact(self)</span>

<span class="w"> </span>    def feed(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handler for incoming data. (Called by TelnetServer.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.parser.feed(data)</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Closed by client.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+            self.vt100_input.close()</span>
<span class="gi">+            self.conn.close()</span>
<span class="gi">+            self.server.connections.remove(self)</span>

<span class="w"> </span>    def send(self, formatted_text: AnyFormattedText) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Send text to the client.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        formatted_text = to_formatted_text(formatted_text)</span>
<span class="gi">+        print_formatted_text(self.vt100_output, formatted_text, self.style or DummyStyle())</span>

<span class="w"> </span>    def send_above_prompt(self, formatted_text: AnyFormattedText) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Send text to the client.
<span class="w"> </span>        This is asynchronous, returns a `Future`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        async def send_above_prompt() -&gt;None:</span>
<span class="gi">+            if self.context:</span>
<span class="gi">+                with create_app_session(input=self.vt100_input, output=self.vt100_output):</span>
<span class="gi">+                    self.context.run(lambda: run_in_terminal(lambda: self.send(formatted_text)))</span>
<span class="gi">+</span>
<span class="gi">+        asyncio.create_task(send_above_prompt())</span>

<span class="w"> </span>    def erase_screen(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Erase the screen and move the cursor to the top.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.vt100_output:</span>
<span class="gi">+            self.vt100_output.erase_screen()</span>
<span class="gi">+            self.vt100_output.cursor_goto(0, 0)</span>
<span class="gi">+            self.vt100_output.flush()</span>


<span class="w"> </span>class TelnetServer:
<span class="gu">@@ -157,7 +173,21 @@ class TelnetServer:</span>
<span class="w"> </span>        :param ready_cb: Callback that will be called at the point that we&#39;re
<span class="w"> </span>            actually listening.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        loop = get_running_loop()</span>
<span class="gi">+        server = await loop.create_server(</span>
<span class="gi">+            lambda: asyncio.Protocol(),  # Placeholder protocol</span>
<span class="gi">+            self.host, self.port, reuse_address=True)</span>
<span class="gi">+</span>
<span class="gi">+        logger.info(f&quot;Listening for telnet connections on {self.host}:{self.port}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if ready_cb:</span>
<span class="gi">+            ready_cb()</span>
<span class="gi">+</span>
<span class="gi">+        async with server:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                conn, addr = await server.accept()</span>
<span class="gi">+                logger.info(f&quot;New connection from {addr}&quot;)</span>
<span class="gi">+                self._accept(conn)</span>

<span class="w"> </span>    def start(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -165,7 +195,8 @@ class TelnetServer:</span>

<span class="w"> </span>        Start the telnet server (stop by calling and awaiting `stop()`).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._run_task is None:</span>
<span class="gi">+            self._run_task = asyncio.create_task(self.run())</span>

<span class="w"> </span>    async def stop(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -174,10 +205,37 @@ class TelnetServer:</span>
<span class="w"> </span>        Stop a telnet server that was started using `.start()` and wait for the
<span class="w"> </span>        cancellation to complete.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._run_task:</span>
<span class="gi">+            self._run_task.cancel()</span>
<span class="gi">+            await asyncio.gather(self._run_task, return_exceptions=True)</span>
<span class="gi">+            self._run_task = None</span>
<span class="gi">+</span>
<span class="gi">+        for task in self._application_tasks:</span>
<span class="gi">+            task.cancel()</span>
<span class="gi">+</span>
<span class="gi">+        await asyncio.gather(*self._application_tasks, return_exceptions=True)</span>
<span class="gi">+        self._application_tasks.clear()</span>
<span class="gi">+</span>
<span class="gi">+        for connection in list(self.connections):</span>
<span class="gi">+            connection.close()</span>

<span class="gd">-    def _accept(self, listen_socket: socket.socket) -&gt;None:</span>
<span class="gi">+    def _accept(self, conn: socket.socket) -&gt;None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Accept new incoming connection.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        addr = conn.getpeername()</span>
<span class="gi">+        vt100_input = create_pipe_input()</span>
<span class="gi">+</span>
<span class="gi">+        connection = TelnetConnection(</span>
<span class="gi">+            conn=conn,</span>
<span class="gi">+            addr=addr,</span>
<span class="gi">+            interact=self.interact,</span>
<span class="gi">+            server=self,</span>
<span class="gi">+            encoding=self.encoding,</span>
<span class="gi">+            style=self.style,</span>
<span class="gi">+            vt100_input=vt100_input,</span>
<span class="gi">+            enable_cpr=self.enable_cpr,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self.connections.add(connection)</span>
<span class="gi">+        self._application_tasks.append(asyncio.create_task(connection.run_application()))</span>
<span class="gh">diff --git a/src/prompt_toolkit/cursor_shapes.py b/src/prompt_toolkit/cursor_shapes.py</span>
<span class="gh">index 076033d2..ee763816 100644</span>
<span class="gd">--- a/src/prompt_toolkit/cursor_shapes.py</span>
<span class="gi">+++ b/src/prompt_toolkit/cursor_shapes.py</span>
<span class="gu">@@ -43,12 +43,32 @@ class SimpleCursorShapeConfig(CursorShapeConfig):</span>
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        self.cursor_shape = cursor_shape

<span class="gi">+    def get_cursor_shape(self, application: Application[Any]) -&gt;CursorShape:</span>
<span class="gi">+        return self.cursor_shape</span>
<span class="gi">+</span>

<span class="w"> </span>class ModalCursorShapeConfig(CursorShapeConfig):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Show cursor shape according to the current input mode.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def __init__(self, </span>
<span class="gi">+                 emacs: CursorShape = CursorShape.BEAM,</span>
<span class="gi">+                 vi_insert: CursorShape = CursorShape.BEAM,</span>
<span class="gi">+                 vi_navigation: CursorShape = CursorShape.BLOCK) -&gt; None:</span>
<span class="gi">+        self.emacs = emacs</span>
<span class="gi">+        self.vi_insert = vi_insert</span>
<span class="gi">+        self.vi_navigation = vi_navigation</span>
<span class="gi">+</span>
<span class="gi">+    def get_cursor_shape(self, application: Application[Any]) -&gt; CursorShape:</span>
<span class="gi">+        if application.editing_mode == EditingMode.VI:</span>
<span class="gi">+            if application.vi_state.input_mode == InputMode.INSERT:</span>
<span class="gi">+                return self.vi_insert</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.vi_navigation</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.emacs</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicCursorShapeConfig(CursorShapeConfig):

<span class="gu">@@ -56,10 +76,26 @@ class DynamicCursorShapeConfig(CursorShapeConfig):</span>
<span class="w"> </span>        AnyCursorShapeConfig]) -&gt;None:
<span class="w"> </span>        self.get_cursor_shape_config = get_cursor_shape_config

<span class="gi">+    def get_cursor_shape(self, application: Application[Any]) -&gt; CursorShape:</span>
<span class="gi">+        config = self.get_cursor_shape_config()</span>
<span class="gi">+        if isinstance(config, CursorShape):</span>
<span class="gi">+            return config</span>
<span class="gi">+        elif isinstance(config, CursorShapeConfig):</span>
<span class="gi">+            return config.get_cursor_shape(application)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return CursorShape._NEVER_CHANGE</span>
<span class="gi">+</span>

<span class="w"> </span>def to_cursor_shape_config(value: AnyCursorShapeConfig) -&gt;CursorShapeConfig:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take a `CursorShape` instance or `CursorShapeConfig` and turn it into a
<span class="w"> </span>    `CursorShapeConfig`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, CursorShapeConfig):</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif isinstance(value, CursorShape):</span>
<span class="gi">+        return SimpleCursorShapeConfig(value)</span>
<span class="gi">+    elif value is None:</span>
<span class="gi">+        return SimpleCursorShapeConfig(CursorShape._NEVER_CHANGE)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(f&quot;Invalid cursor shape config: {value}&quot;)</span>
<span class="gh">diff --git a/src/prompt_toolkit/document.py b/src/prompt_toolkit/document.py</span>
<span class="gh">index c246ba0d..0a5fbdbe 100644</span>
<span class="gd">--- a/src/prompt_toolkit/document.py</span>
<span class="gi">+++ b/src/prompt_toolkit/document.py</span>
<span class="gu">@@ -90,109 +90,119 @@ class Document:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def text(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;The document text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._text</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def cursor_position(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;The document cursor position.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._cursor_position</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def selection(self) -&gt;(SelectionState | None):
<span class="w"> </span>        &quot;&quot;&quot;:class:`.SelectionState` object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._selection</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_char(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return character under cursor or an empty string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_char_relative_to_cursor() if self.cursor_position &lt; len(self._text) else &#39;&#39;</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def char_before_cursor(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return character before the cursor or an empty string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_char_relative_to_cursor(-1) if self.cursor_position &gt; 0 else &#39;&#39;</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_line_before_cursor(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Text from the start of the line until the cursor.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.current_line[:self.cursor_position_col]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_line_after_cursor(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Text from the cursor until the end of the line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.current_line[self.cursor_position_col:]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def lines(self) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Array of all the lines.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._cache.lines is None:</span>
<span class="gi">+            self._cache.lines = _ImmutableLineList(self._text.splitlines(keepends=True))</span>
<span class="gi">+        return self._cache.lines</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def _line_start_indexes(self) -&gt;list[int]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Array pointing to the start indexes of all the lines.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._cache.line_indexes is None:</span>
<span class="gi">+            indexes = [0]</span>
<span class="gi">+            for line in self.lines[:-1]:</span>
<span class="gi">+                indexes.append(indexes[-1] + len(line))</span>
<span class="gi">+            self._cache.line_indexes = indexes</span>
<span class="gi">+        return self._cache.line_indexes</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def lines_from_current(self) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Array of the lines starting from the current line, until the last line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.lines[self.cursor_position_row:]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def line_count(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Return the number of lines in this document. If the document ends
<span class="w"> </span>        with a trailing \\n, that counts as the beginning of a new line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.lines)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_line(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return the text on the line where the cursor is. (when the input
<span class="w"> </span>        consists of just one line, it equals `text`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.lines[self.cursor_position_row]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def leading_whitespace_in_current_line(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;The leading whitespace in the left margin of the current line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.current_line[:len(self.current_line) - len(self.current_line.lstrip())]</span>

<span class="w"> </span>    def _get_char_relative_to_cursor(self, offset: int=0) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return character relative to cursor position, or empty string
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._text[self._cursor_position + offset]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return &#39;&#39;</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def on_first_line(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when we are at the first line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.cursor_position_row == 0</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def on_last_line(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True when we are at the last line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.cursor_position_row == self.line_count - 1</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def cursor_position_row(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Current row. (0-based.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._find_line_start_index(self._cursor_position)[0]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def cursor_position_col(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Current column. (0-based.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._cursor_position - self._find_line_start_index(self._cursor_position)[1]</span>

<span class="w"> </span>    def _find_line_start_index(self, index: int) -&gt;tuple[int, int]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -201,14 +211,18 @@ class Document:</span>

<span class="w"> </span>        Return (row, index) tuple.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indexes = self._line_start_indexes</span>
<span class="gi">+        row = bisect.bisect_right(indexes, index) - 1</span>
<span class="gi">+        return row, indexes[row]</span>

<span class="w"> </span>    def translate_index_to_position(self, index: int) -&gt;tuple[int, int]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Given an index for the text, return the corresponding (row, col) tuple.
<span class="w"> </span>        (0-based. Returns (0, 0) for index=0.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        row, row_index = self._find_line_start_index(index)</span>
<span class="gi">+        col = index - row_index</span>
<span class="gi">+        return row, col</span>

<span class="w"> </span>    def translate_row_col_to_index(self, row: int, col: int) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -217,7 +231,10 @@ class Document:</span>

<span class="w"> </span>        Negative row/col values are turned into zero.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        row = max(0, row)</span>
<span class="gi">+        col = max(0, col)</span>
<span class="gi">+        row = min(row, len(self._line_start_indexes) - 1)</span>
<span class="gi">+        return min(self._line_start_indexes[row] + col, len(self._text))</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def is_cursor_at_the_end(self) -&gt;bool:
<span class="gh">diff --git a/src/prompt_toolkit/eventloop/async_generator.py b/src/prompt_toolkit/eventloop/async_generator.py</span>
<span class="gh">index 9c1d7e5a..eab1bbf1 100644</span>
<span class="gd">--- a/src/prompt_toolkit/eventloop/async_generator.py</span>
<span class="gi">+++ b/src/prompt_toolkit/eventloop/async_generator.py</span>
<span class="gu">@@ -14,7 +14,10 @@ _T_Generator = TypeVar(&#39;_T_Generator&#39;, bound=AsyncGenerator[Any, None])</span>
<span class="w"> </span>@asynccontextmanager
<span class="w"> </span>async def aclosing(thing: _T_Generator) -&gt;AsyncGenerator[_T_Generator, None]:
<span class="w"> </span>    &quot;&quot;&quot;Similar to `contextlib.aclosing`, in Python 3.10.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield thing</span>
<span class="gi">+    finally:</span>
<span class="gi">+        await thing.aclose()</span>


<span class="w"> </span>DEFAULT_BUFFER_SIZE: int = 1000
<span class="gu">@@ -37,4 +40,27 @@ async def generator_to_async_generator(get_iterable: Callable[[], Iterable[</span>
<span class="w"> </span>    :param buffer_size: Size of the queue between the async consumer and the
<span class="w"> </span>        synchronous generator that produces items.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    queue: Queue[_T | _Done] = Queue(maxsize=buffer_size)</span>
<span class="gi">+    loop = get_running_loop()</span>
<span class="gi">+</span>
<span class="gi">+    def producer():</span>
<span class="gi">+        try:</span>
<span class="gi">+            for item in get_iterable():</span>
<span class="gi">+                queue.put(item)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            loop.call_soon_threadsafe(lambda: queue.put(e))</span>
<span class="gi">+        finally:</span>
<span class="gi">+            queue.put(_Done())</span>
<span class="gi">+</span>
<span class="gi">+    await run_in_executor_with_context(producer)</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            item = await loop.run_in_executor(None, queue.get, True, 0.1)</span>
<span class="gi">+            if isinstance(item, _Done):</span>
<span class="gi">+                break</span>
<span class="gi">+            if isinstance(item, Exception):</span>
<span class="gi">+                raise item</span>
<span class="gi">+            yield item</span>
<span class="gi">+        except Empty:</span>
<span class="gi">+            pass</span>
<span class="gh">diff --git a/src/prompt_toolkit/eventloop/inputhook.py b/src/prompt_toolkit/eventloop/inputhook.py</span>
<span class="gh">index 33584d8e..436c545f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/eventloop/inputhook.py</span>
<span class="gi">+++ b/src/prompt_toolkit/eventloop/inputhook.py</span>
<span class="gu">@@ -58,7 +58,9 @@ def new_eventloop_with_inputhook(inputhook: Callable[[InputHookContext], None]</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new event loop with the given inputhook.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    selector = selectors.SelectSelector()</span>
<span class="gi">+    loop = asyncio.SelectorEventLoop(InputHookSelector(selector, inputhook))</span>
<span class="gi">+    return loop</span>


<span class="w"> </span>def set_eventloop_with_inputhook(inputhook: Callable[[InputHookContext], None]
<span class="gu">@@ -66,7 +68,9 @@ def set_eventloop_with_inputhook(inputhook: Callable[[InputHookContext], None]</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a new event loop with the given inputhook, and activate it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop = new_eventloop_with_inputhook(inputhook)</span>
<span class="gi">+    asyncio.set_event_loop(loop)</span>
<span class="gi">+    return loop</span>


<span class="w"> </span>class InputHookSelector(BaseSelector):
<span class="gu">@@ -88,4 +92,31 @@ class InputHookSelector(BaseSelector):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Clean up resources.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.selector.close()</span>
<span class="gi">+        os.close(self._r)</span>
<span class="gi">+        os.close(self._w)</span>
<span class="gi">+</span>
<span class="gi">+    def register(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None) -&gt; SelectorKey:</span>
<span class="gi">+        return self.selector.register(fileobj, events, data)</span>
<span class="gi">+</span>
<span class="gi">+    def unregister(self, fileobj: FileDescriptorLike) -&gt; SelectorKey:</span>
<span class="gi">+        return self.selector.unregister(fileobj)</span>
<span class="gi">+</span>
<span class="gi">+    def modify(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None) -&gt; SelectorKey:</span>
<span class="gi">+        return self.selector.modify(fileobj, events, data)</span>
<span class="gi">+</span>
<span class="gi">+    def select(self, timeout: float | None = None) -&gt; list[tuple[SelectorKey, _EventMask]]:</span>
<span class="gi">+        ready = self.selector.select(timeout=0)</span>
<span class="gi">+        if ready:</span>
<span class="gi">+            return ready</span>
<span class="gi">+</span>
<span class="gi">+        def input_is_ready() -&gt; bool:</span>
<span class="gi">+            return bool(self.selector.select(timeout=0))</span>
<span class="gi">+</span>
<span class="gi">+        context = InputHookContext(self._r, input_is_ready)</span>
<span class="gi">+        self.inputhook(context)</span>
<span class="gi">+</span>
<span class="gi">+        return self.selector.select(timeout=0)</span>
<span class="gi">+</span>
<span class="gi">+    def get_map(self) -&gt; Mapping[FileDescriptorLike, SelectorKey]:</span>
<span class="gi">+        return self.selector.get_map()</span>
<span class="gh">diff --git a/src/prompt_toolkit/eventloop/utils.py b/src/prompt_toolkit/eventloop/utils.py</span>
<span class="gh">index 4b6cc6db..4a03827d 100644</span>
<span class="gd">--- a/src/prompt_toolkit/eventloop/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/eventloop/utils.py</span>
<span class="gu">@@ -19,7 +19,9 @@ def run_in_executor_with_context(func: Callable[..., _T], *args: Any, loop:</span>

<span class="w"> </span>    See also: https://bugs.python.org/issue34014
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop = loop or asyncio.get_event_loop()</span>
<span class="gi">+    ctx = contextvars.copy_context()</span>
<span class="gi">+    return loop.run_in_executor(None, lambda: ctx.run(func, *args))</span>


<span class="w"> </span>def call_soon_threadsafe(func: Callable[[], None], max_postpone_time: (
<span class="gu">@@ -40,7 +42,19 @@ def call_soon_threadsafe(func: Callable[[], None], max_postpone_time: (</span>
<span class="w"> </span>    However, we want to set a deadline value, for when the rendering should
<span class="w"> </span>    happen. (The UI should stay responsive).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop = loop or asyncio.get_event_loop()</span>
<span class="gi">+    </span>
<span class="gi">+    if max_postpone_time is None:</span>
<span class="gi">+        loop.call_soon_threadsafe(func)</span>
<span class="gi">+    else:</span>
<span class="gi">+        def wrapper():</span>
<span class="gi">+            if time.time() &gt;= deadline:</span>
<span class="gi">+                func()</span>
<span class="gi">+            else:</span>
<span class="gi">+                loop.call_soon(wrapper)</span>
<span class="gi">+</span>
<span class="gi">+        deadline = time.time() + max_postpone_time</span>
<span class="gi">+        loop.call_soon_threadsafe(wrapper)</span>


<span class="w"> </span>def get_traceback_from_context(context: dict[str, Any]) -&gt;(TracebackType | None
<span class="gu">@@ -48,4 +62,7 @@ def get_traceback_from_context(context: dict[str, Any]) -&gt;(TracebackType | None</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Get the traceback object from the context.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    exception = context.get(&#39;exception&#39;)</span>
<span class="gi">+    if exception:</span>
<span class="gi">+        return exception.__traceback__</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/src/prompt_toolkit/eventloop/win32.py b/src/prompt_toolkit/eventloop/win32.py</span>
<span class="gh">index 55033702..cc0a2173 100644</span>
<span class="gd">--- a/src/prompt_toolkit/eventloop/win32.py</span>
<span class="gi">+++ b/src/prompt_toolkit/eventloop/win32.py</span>
<span class="gu">@@ -33,7 +33,17 @@ def wait_for_handles(handles: list[HANDLE], timeout: int=INFINITE) -&gt;(HANDLE |</span>
<span class="w"> </span>    This function returns either `None` or one of the given `HANDLE` objects.
<span class="w"> </span>    (The return value can be tested with the `is` operator.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    arr = (HANDLE * len(handles))(*handles)</span>
<span class="gi">+    ret = windll.kernel32.WaitForMultipleObjects(</span>
<span class="gi">+        len(handles),</span>
<span class="gi">+        arr,</span>
<span class="gi">+        BOOL(False),</span>
<span class="gi">+        DWORD(timeout)</span>
<span class="gi">+    )</span>
<span class="gi">+    if ret == WAIT_TIMEOUT:</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        return handles[ret]</span>


<span class="w"> </span>def create_win32_event() -&gt;HANDLE:
<span class="gu">@@ -41,4 +51,19 @@ def create_win32_event() -&gt;HANDLE:</span>
<span class="w"> </span>    Creates a Win32 unnamed Event .
<span class="w"> </span>    http://msdn.microsoft.com/en-us/library/windows/desktop/ms682396(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sa = SECURITY_ATTRIBUTES()</span>
<span class="gi">+    sa.nLength = DWORD(sizeof(SECURITY_ATTRIBUTES))</span>
<span class="gi">+    sa.bInheritHandle = BOOL(True)</span>
<span class="gi">+    sa.lpSecurityDescriptor = None</span>
<span class="gi">+</span>
<span class="gi">+    handle = windll.kernel32.CreateEventA(</span>
<span class="gi">+        pointer(sa),</span>
<span class="gi">+        BOOL(True),   # Manual reset event</span>
<span class="gi">+        BOOL(False),  # Initial state = 0</span>
<span class="gi">+        None          # Unnamed event</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if handle == 0:</span>
<span class="gi">+        raise WindowsError(windll.kernel32.GetLastError())</span>
<span class="gi">+</span>
<span class="gi">+    return handle</span>
<span class="gh">diff --git a/src/prompt_toolkit/filters/app.py b/src/prompt_toolkit/filters/app.py</span>
<span class="gh">index 1cf7bf99..21c2010b 100644</span>
<span class="gd">--- a/src/prompt_toolkit/filters/app.py</span>
<span class="gi">+++ b/src/prompt_toolkit/filters/app.py</span>
<span class="gu">@@ -25,7 +25,9 @@ def has_focus(value: FocusableElement) -&gt;Condition:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enable when this buffer has the focus.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def has_focus_filter() -&gt; bool:</span>
<span class="gi">+        return get_app().layout.current_control == value</span>
<span class="gi">+    return Condition(has_focus_filter)</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -33,7 +35,8 @@ def buffer_has_focus() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enabled when the currently focused control is a `BufferControl`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.layout.controls import BufferControl</span>
<span class="gi">+    return isinstance(get_app().layout.current_control, BufferControl)</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -41,7 +44,7 @@ def has_selection() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enable when the current buffer has a selection.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bool(get_app().current_buffer.selection_state)</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -49,7 +52,7 @@ def has_suggestion() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enable when the current buffer has a suggestion.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().current_buffer.suggestion is not None</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -57,7 +60,7 @@ def has_completions() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Enable when the current buffer has completions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bool(get_app().current_buffer.completer)</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -65,7 +68,8 @@ def completion_is_selected() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the user selected a completion.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().current_buffer.complete_state is not None and \</span>
<span class="gi">+           get_app().current_buffer.complete_state.current_completion is not None</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -73,7 +77,7 @@ def is_read_only() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the current buffer is read only.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().current_buffer.read_only()</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -81,19 +85,19 @@ def is_multiline() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the current buffer has been marked as multiline.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().current_buffer.multiline</span>


<span class="w"> </span>@Condition
<span class="w"> </span>def has_validation_error() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Current buffer has validation error.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().current_buffer.validation_error is not None</span>


<span class="w"> </span>@Condition
<span class="w"> </span>def has_arg() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Enable when the input processor has an &#39;arg&#39;.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().key_processor.arg is not None</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -101,7 +105,7 @@ def is_done() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the CLI is returning, aborting or exiting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().is_done</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -115,7 +119,7 @@ def renderer_height_is_known() -&gt;bool:</span>
<span class="w"> </span>    until we receive the height, in order to avoid flickering -- first drawing
<span class="w"> </span>    somewhere in the middle, and then again at the bottom.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().renderer.height_is_known</span>


<span class="w"> </span>@memoized()
<span class="gu">@@ -123,7 +127,9 @@ def in_editing_mode(editing_mode: EditingMode) -&gt;Condition:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether a given editing mode is active. (Vi or Emacs.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def in_editing_mode_filter() -&gt; bool:</span>
<span class="gi">+        return get_app().editing_mode == editing_mode</span>
<span class="gi">+    return Condition(in_editing_mode_filter)</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -131,34 +137,37 @@ def vi_navigation_mode() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Active when the set for Vi navigation key bindings are active.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    return app.editing_mode == EditingMode.VI and \</span>
<span class="gi">+           app.vi_state.input_mode == &#39;navigation&#39;</span>


<span class="w"> </span>@Condition
<span class="w"> </span>def vi_recording_macro() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;When recording a Vi macro.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().vi_state.recording_macro</span>


<span class="w"> </span>@Condition
<span class="w"> </span>def emacs_mode() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;When the Emacs bindings are active.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().editing_mode == EditingMode.EMACS</span>


<span class="w"> </span>@Condition
<span class="w"> </span>def is_searching() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;When we are searching.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().layout.is_searching</span>


<span class="w"> </span>@Condition
<span class="w"> </span>def control_is_searchable() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;When the current UIControl is searchable.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.layout.controls import SearchableControl</span>
<span class="gi">+    return isinstance(get_app().layout.current_control, SearchableControl)</span>


<span class="w"> </span>@Condition
<span class="w"> </span>def vi_search_direction_reversed() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;When the &#39;/&#39; and &#39;?&#39; key bindings for Vi-style searching have been reversed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return get_app().vi_search_direction_reversed</span>
<span class="gh">diff --git a/src/prompt_toolkit/filters/base.py b/src/prompt_toolkit/filters/base.py</span>
<span class="gh">index 66696022..7ddb9aef 100644</span>
<span class="gd">--- a/src/prompt_toolkit/filters/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/filters/base.py</span>
<span class="gu">@@ -93,7 +93,10 @@ class _AndList(Filter):</span>
<span class="w"> </span>        If there&#39;s only one unique filter in the given iterable, it will return
<span class="w"> </span>        that one filter instead of an `_AndList`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        unique_filters = list(set(filters))</span>
<span class="gi">+        if len(unique_filters) == 1:</span>
<span class="gi">+            return unique_filters[0]</span>
<span class="gi">+        return cls(unique_filters)</span>

<span class="w"> </span>    def __call__(self) -&gt;bool:
<span class="w"> </span>        return all(f() for f in self.filters)
<span class="gu">@@ -119,7 +122,10 @@ class _OrList(Filter):</span>
<span class="w"> </span>        If there&#39;s only one unique filter in the given iterable, it will return
<span class="w"> </span>        that one filter instead of an `_OrList`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        unique_filters = list(set(filters))</span>
<span class="gi">+        if len(unique_filters) == 1:</span>
<span class="gi">+            return unique_filters[0]</span>
<span class="gi">+        return cls(unique_filters)</span>

<span class="w"> </span>    def __call__(self) -&gt;bool:
<span class="w"> </span>        return any(f() for f in self.filters)
<span class="gh">diff --git a/src/prompt_toolkit/filters/utils.py b/src/prompt_toolkit/filters/utils.py</span>
<span class="gh">index 4234ca63..005f13eb 100644</span>
<span class="gd">--- a/src/prompt_toolkit/filters/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/filters/utils.py</span>
<span class="gu">@@ -11,7 +11,9 @@ def to_filter(bool_or_filter: FilterOrBool) -&gt;Filter:</span>
<span class="w"> </span>    Accept both booleans and Filters as input and
<span class="w"> </span>    turn it into a Filter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(bool_or_filter, bool):</span>
<span class="gi">+        return _bool_to_filter[bool_or_filter]</span>
<span class="gi">+    return bool_or_filter</span>


<span class="w"> </span>def is_true(value: FilterOrBool) -&gt;bool:
<span class="gu">@@ -20,4 +22,6 @@ def is_true(value: FilterOrBool) -&gt;bool:</span>

<span class="w"> </span>    :param value: Boolean or `Filter` instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, bool):</span>
<span class="gi">+        return value</span>
<span class="gi">+    return bool(value())</span>
<span class="gh">diff --git a/src/prompt_toolkit/formatted_text/ansi.py b/src/prompt_toolkit/formatted_text/ansi.py</span>
<span class="gh">index 35ad0c63..9e8b809a 100644</span>
<span class="gd">--- a/src/prompt_toolkit/formatted_text/ansi.py</span>
<span class="gi">+++ b/src/prompt_toolkit/formatted_text/ansi.py</span>
<span class="gu">@@ -43,19 +43,99 @@ class ANSI:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Coroutine that parses the ANSI escape sequences.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        formatted_text = self._formatted_text</span>
<span class="gi">+        style = &#39;&#39;</span>
<span class="gi">+        text = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            c = yield</span>
<span class="gi">+            if c == &#39;\x1b&#39;:</span>
<span class="gi">+                if text:</span>
<span class="gi">+                    formatted_text.append((style, text))</span>
<span class="gi">+                    text = &#39;&#39;</span>
<span class="gi">+                # Parse escape sequence</span>
<span class="gi">+                sequence = &#39;&#39;</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    c = yield</span>
<span class="gi">+                    if c.isalpha() or c == &#39;\\&#39;:</span>
<span class="gi">+                        sequence += c</span>
<span class="gi">+                        break</span>
<span class="gi">+                    sequence += c</span>
<span class="gi">+                </span>
<span class="gi">+                if sequence.startswith(&#39;[&#39;):</span>
<span class="gi">+                    params = sequence[1:-1].split(&#39;;&#39;)</span>
<span class="gi">+                    self._select_graphic_rendition([int(p) if p.isdigit() else 0 for p in params])</span>
<span class="gi">+                    style = self._create_style_string()</span>
<span class="gi">+            elif c in (&#39;\001&#39;, &#39;\002&#39;):</span>
<span class="gi">+                if text:</span>
<span class="gi">+                    formatted_text.append((style, text))</span>
<span class="gi">+                    text = &#39;&#39;</span>
<span class="gi">+                formatted_text.append((&#39;[ZeroWidthEscape]&#39;, c))</span>
<span class="gi">+            else:</span>
<span class="gi">+                text += c</span>
<span class="gi">+</span>
<span class="gi">+        if text:</span>
<span class="gi">+            formatted_text.append((style, text))</span>

<span class="w"> </span>    def _select_graphic_rendition(self, attrs: list[int]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        Taken a list of graphics attributes and apply changes.</span>
<span class="gi">+        Take a list of graphics attributes and apply changes.</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for attr in attrs:</span>
<span class="gi">+            if attr == 0:</span>
<span class="gi">+                self._color = self._bgcolor = None</span>
<span class="gi">+                self._bold = self._underline = self._strike = self._italic = self._blink = self._reverse = self._hidden = False</span>
<span class="gi">+            elif attr == 1:</span>
<span class="gi">+                self._bold = True</span>
<span class="gi">+            elif attr == 3:</span>
<span class="gi">+                self._italic = True</span>
<span class="gi">+            elif attr == 4:</span>
<span class="gi">+                self._underline = True</span>
<span class="gi">+            elif attr == 5:</span>
<span class="gi">+                self._blink = True</span>
<span class="gi">+            elif attr == 7:</span>
<span class="gi">+                self._reverse = True</span>
<span class="gi">+            elif attr == 8:</span>
<span class="gi">+                self._hidden = True</span>
<span class="gi">+            elif attr == 9:</span>
<span class="gi">+                self._strike = True</span>
<span class="gi">+            elif 30 &lt;= attr &lt;= 37:</span>
<span class="gi">+                self._color = _fg_colors[attr - 30]</span>
<span class="gi">+            elif attr == 39:</span>
<span class="gi">+                self._color = None</span>
<span class="gi">+            elif 40 &lt;= attr &lt;= 47:</span>
<span class="gi">+                self._bgcolor = _bg_colors[attr - 40]</span>
<span class="gi">+            elif attr == 49:</span>
<span class="gi">+                self._bgcolor = None</span>
<span class="gi">+            elif 90 &lt;= attr &lt;= 97:</span>
<span class="gi">+                self._color = _fg_colors[attr - 90 + 8]</span>
<span class="gi">+            elif 100 &lt;= attr &lt;= 107:</span>
<span class="gi">+                self._bgcolor = _bg_colors[attr - 100 + 8]</span>

<span class="w"> </span>    def _create_style_string(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Turn current style flags into a string for usage in a formatted text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parts = []</span>
<span class="gi">+        if self._color:</span>
<span class="gi">+            parts.append(f&#39;fg:{self._color}&#39;)</span>
<span class="gi">+        if self._bgcolor:</span>
<span class="gi">+            parts.append(f&#39;bg:{self._bgcolor}&#39;)</span>
<span class="gi">+        if self._bold:</span>
<span class="gi">+            parts.append(&#39;bold&#39;)</span>
<span class="gi">+        if self._underline:</span>
<span class="gi">+            parts.append(&#39;underline&#39;)</span>
<span class="gi">+        if self._strike:</span>
<span class="gi">+            parts.append(&#39;strike&#39;)</span>
<span class="gi">+        if self._italic:</span>
<span class="gi">+            parts.append(&#39;italic&#39;)</span>
<span class="gi">+        if self._blink:</span>
<span class="gi">+            parts.append(&#39;blink&#39;)</span>
<span class="gi">+        if self._reverse:</span>
<span class="gi">+            parts.append(&#39;reverse&#39;)</span>
<span class="gi">+        if self._hidden:</span>
<span class="gi">+            parts.append(&#39;hidden&#39;)</span>
<span class="gi">+        return &#39; &#39;.join(parts)</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return f&#39;ANSI({self.value!r})&#39;
<span class="gu">@@ -68,7 +148,9 @@ class ANSI:</span>
<span class="w"> </span>        Like `str.format`, but make sure that the arguments are properly
<span class="w"> </span>        escaped. (No ANSI escapes can be injected.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        escaped_args = tuple(ansi_escape(arg) for arg in args)</span>
<span class="gi">+        escaped_kwargs = {key: ansi_escape(value) for key, value in kwargs.items()}</span>
<span class="gi">+        return ANSI(FORMATTER.vformat(self.value, escaped_args, escaped_kwargs))</span>

<span class="w"> </span>    def __mod__(self, value: object) -&gt;ANSI:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -91,11 +173,17 @@ def ansi_escape(text: object) -&gt;str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Replace characters with a special meaning.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(text, str):</span>
<span class="gi">+        text = str(text)</span>
<span class="gi">+    return text.replace(&#39;\x1b&#39;, &#39;?&#39;).replace(&#39;\b&#39;, &#39;?&#39;)</span>


<span class="w"> </span>class ANSIFormatter(Formatter):
<span class="gd">-    pass</span>
<span class="gi">+    def format_field(self, value: object, format_spec: str) -&gt;str:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        This is used by the string formatting operator.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return ansi_escape(super().format_field(value, format_spec))</span>


<span class="w"> </span>FORMATTER = ANSIFormatter()
<span class="gh">diff --git a/src/prompt_toolkit/formatted_text/base.py b/src/prompt_toolkit/formatted_text/base.py</span>
<span class="gh">index 41ecbc3b..62b8ff85 100644</span>
<span class="gd">--- a/src/prompt_toolkit/formatted_text/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/formatted_text/base.py</span>
<span class="gu">@@ -42,7 +42,20 @@ def to_formatted_text(value: AnyFormattedText, style: str=&#39;&#39;, auto_convert:</span>
<span class="w"> </span>    :param auto_convert: If `True`, also accept other types, and convert them
<span class="w"> </span>        to a string first.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        value = value()</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        return FormattedText([(style, value)])</span>
<span class="gi">+    elif isinstance(value, list):</span>
<span class="gi">+        return FormattedText([(style + &#39; &#39; + item_style if style else item_style, item_text) </span>
<span class="gi">+                              for item_style, item_text in value])</span>
<span class="gi">+    elif hasattr(value, &#39;__pt_formatted_text__&#39;):</span>
<span class="gi">+        return to_formatted_text(value.__pt_formatted_text__(), style)</span>
<span class="gi">+    elif auto_convert:</span>
<span class="gi">+        return FormattedText([(style, str(value))])</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid formatted text: {value!r}&quot;)</span>


<span class="w"> </span>def is_formatted_text(value: object) -&gt;TypeGuard[AnyFormattedText]:
<span class="gu">@@ -51,7 +64,16 @@ def is_formatted_text(value: object) -&gt;TypeGuard[AnyFormattedText]:</span>
<span class="w"> </span>    statements).
<span class="w"> </span>    In case of a callable, it doesn&#39;t check the return type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if isinstance(value, (str, FormattedText)):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if isinstance(value, list):</span>
<span class="gi">+        return all(isinstance(item, tuple) and len(item) in (2, 3) and isinstance(item[0], str) and isinstance(item[1], str)</span>
<span class="gi">+                   for item in value)</span>
<span class="gi">+    if hasattr(value, &#39;__pt_formatted_text__&#39;):</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class FormattedText(StyleAndTextTuples):
<span class="gu">@@ -89,4 +111,7 @@ def merge_formatted_text(items: Iterable[AnyFormattedText]) -&gt;AnyFormattedText:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge (Concatenate) several pieces of formatted text together.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result: StyleAndTextTuples = []</span>
<span class="gi">+    for item in items:</span>
<span class="gi">+        result.extend(to_formatted_text(item))</span>
<span class="gi">+    return FormattedText(result)</span>
<span class="gh">diff --git a/src/prompt_toolkit/formatted_text/html.py b/src/prompt_toolkit/formatted_text/html.py</span>
<span class="gh">index 25f82c7d..6edb1443 100644</span>
<span class="gd">--- a/src/prompt_toolkit/formatted_text/html.py</span>
<span class="gi">+++ b/src/prompt_toolkit/formatted_text/html.py</span>
<span class="gu">@@ -3,8 +3,14 @@ import xml.dom.minidom as minidom</span>
<span class="w"> </span>from string import Formatter
<span class="w"> </span>from typing import Any
<span class="w"> </span>from .base import FormattedText, StyleAndTextTuples
<span class="gi">+import html</span>
<span class="gi">+</span>
<span class="w"> </span>__all__ = [&#39;HTML&#39;]

<span class="gi">+def html_escape(value: object) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Escape special characters to their HTML entities.&quot;&quot;&quot;</span>
<span class="gi">+    return html.escape(str(value), quote=True)</span>
<span class="gi">+</span>

<span class="w"> </span>class HTML:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -93,7 +99,10 @@ class HTML:</span>
<span class="w"> </span>        Like `str.format`, but make sure that the arguments are properly
<span class="w"> </span>        escaped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        escaped_args = tuple(html_escape(arg) for arg in args)</span>
<span class="gi">+        escaped_kwargs = {k: html_escape(v) for k, v in kwargs.items()}</span>
<span class="gi">+        formatted_value = FORMATTER.vformat(self.value, escaped_args, escaped_kwargs)</span>
<span class="gi">+        return HTML(formatted_value)</span>

<span class="w"> </span>    def __mod__(self, value: object) -&gt;HTML:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -106,7 +115,11 @@ class HTML:</span>


<span class="w"> </span>class HTMLFormatter(Formatter):
<span class="gd">-    pass</span>
<span class="gi">+    def get_value(self, key: int | str, args: tuple, kwargs: dict) -&gt; str:</span>
<span class="gi">+        value = super().get_value(key, args, kwargs)</span>
<span class="gi">+        if isinstance(value, HTML):</span>
<span class="gi">+            return value.value</span>
<span class="gi">+        return html_escape(value)</span>


<span class="w"> </span>FORMATTER = HTMLFormatter()
<span class="gh">diff --git a/src/prompt_toolkit/formatted_text/utils.py b/src/prompt_toolkit/formatted_text/utils.py</span>
<span class="gh">index 1e4f49b4..ccb49f30 100644</span>
<span class="gd">--- a/src/prompt_toolkit/formatted_text/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/formatted_text/utils.py</span>
<span class="gu">@@ -16,7 +16,7 @@ def to_plain_text(value: AnyFormattedText) -&gt;str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Turn any kind of formatted text back into plain text.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return fragment_list_to_text(to_formatted_text(value))</span>


<span class="w"> </span>def fragment_list_len(fragments: StyleAndTextTuples) -&gt;int:
<span class="gu">@@ -26,7 +26,7 @@ def fragment_list_len(fragments: StyleAndTextTuples) -&gt;int:</span>
<span class="w"> </span>    :param fragments: List of ``(style_str, text)`` or
<span class="w"> </span>        ``(style_str, text, mouse_handler)`` tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(len(text) for _, text, *_ in fragments)</span>


<span class="w"> </span>def fragment_list_width(fragments: StyleAndTextTuples) -&gt;int:
<span class="gu">@@ -37,7 +37,7 @@ def fragment_list_width(fragments: StyleAndTextTuples) -&gt;int:</span>
<span class="w"> </span>    :param fragments: List of ``(style_str, text)`` or
<span class="w"> </span>        ``(style_str, text, mouse_handler)`` tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(get_cwidth(text) for _, text, *_ in fragments)</span>


<span class="w"> </span>def fragment_list_to_text(fragments: StyleAndTextTuples) -&gt;str:
<span class="gu">@@ -47,7 +47,7 @@ def fragment_list_to_text(fragments: StyleAndTextTuples) -&gt;str:</span>
<span class="w"> </span>    :param fragments: List of ``(style_str, text)`` or
<span class="w"> </span>        ``(style_str, text, mouse_handler)`` tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;&#39;.join(text for _, text, *_ in fragments)</span>


<span class="w"> </span>def split_lines(fragments: Iterable[OneStyleAndTextTuple]) -&gt;Iterable[
<span class="gu">@@ -59,4 +59,14 @@ def split_lines(fragments: Iterable[OneStyleAndTextTuple]) -&gt;Iterable[</span>
<span class="w"> </span>    :param fragments: Iterable of ``(style_str, text)`` or
<span class="w"> </span>        ``(style_str, text, mouse_handler)`` tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    line: StyleAndTextTuples = []</span>
<span class="gi">+    for style, text, *rest in fragments:</span>
<span class="gi">+        parts = text.split(&#39;\n&#39;)</span>
<span class="gi">+        for part in parts[:-1]:</span>
<span class="gi">+            line.append((style, part, *rest))</span>
<span class="gi">+            yield line</span>
<span class="gi">+            line = []</span>
<span class="gi">+        if parts[-1]:</span>
<span class="gi">+            line.append((style, parts[-1], *rest))</span>
<span class="gi">+    if line:</span>
<span class="gi">+        yield line</span>
<span class="gh">diff --git a/src/prompt_toolkit/history.py b/src/prompt_toolkit/history.py</span>
<span class="gh">index de643197..12b55d7f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/history.py</span>
<span class="gi">+++ b/src/prompt_toolkit/history.py</span>
<span class="gu">@@ -40,18 +40,24 @@ class History(metaclass=ABCMeta):</span>
<span class="w"> </span>        were were appended to the history will be incorporated next time this
<span class="w"> </span>        method is called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._loaded:</span>
<span class="gi">+            self._loaded_strings = list(self.load_history_strings())</span>
<span class="gi">+            self._loaded = True</span>
<span class="gi">+</span>
<span class="gi">+        for item in reversed(self._loaded_strings):</span>
<span class="gi">+            yield item</span>

<span class="w"> </span>    def get_strings(self) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the strings from the history that are loaded so far.
<span class="w"> </span>        (In order. Oldest item first.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._loaded_strings.copy()</span>

<span class="w"> </span>    def append_string(self, string: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add string to the history.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._loaded_strings.append(string)</span>
<span class="gi">+        self.store_string(string)</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def load_history_strings(self) -&gt;Iterable[str]:
<span class="gu">@@ -94,7 +100,33 @@ class ThreadedHistory(History):</span>
<span class="w"> </span>        Like `History.load(), but call `self.load_history_strings()` in a
<span class="w"> </span>        background thread.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def load_in_thread():</span>
<span class="gi">+            with self._lock:</span>
<span class="gi">+                strings = list(self.history.load_history_strings())</span>
<span class="gi">+                self._loaded_strings.extend(strings)</span>
<span class="gi">+                for event in self._string_load_events:</span>
<span class="gi">+                    event.set()</span>
<span class="gi">+</span>
<span class="gi">+        if self._load_thread is None:</span>
<span class="gi">+            self._load_thread = threading.Thread(target=load_in_thread)</span>
<span class="gi">+            self._load_thread.daemon = True</span>
<span class="gi">+            self._load_thread.start()</span>
<span class="gi">+</span>
<span class="gi">+        loop = get_running_loop()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            with self._lock:</span>
<span class="gi">+                if self._loaded_strings:</span>
<span class="gi">+                    string = self._loaded_strings.pop()</span>
<span class="gi">+                    yield string</span>
<span class="gi">+                elif self._load_thread.is_alive():</span>
<span class="gi">+                    event = threading.Event()</span>
<span class="gi">+                    self._string_load_events.append(event)</span>
<span class="gi">+                    with self._lock:</span>
<span class="gi">+                        if self._loaded_strings:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    await loop.run_in_executor(None, event.wait)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return f&#39;ThreadedHistory({self.history!r})&#39;
<span class="gu">@@ -115,12 +147,24 @@ class InMemoryHistory(History):</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self._storage = list(history_strings)

<span class="gi">+    def load_history_strings(self) -&gt;Iterable[str]:</span>
<span class="gi">+        return reversed(self._storage)</span>
<span class="gi">+</span>
<span class="gi">+    def store_string(self, string: str) -&gt;None:</span>
<span class="gi">+        self._storage.append(string)</span>
<span class="gi">+</span>

<span class="w"> </span>class DummyHistory(History):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    :class:`.History` object that doesn&#39;t remember anything.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def load_history_strings(self) -&gt;Iterable[str]:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def store_string(self, string: str) -&gt;None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class FileHistory(History):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -130,3 +174,13 @@ class FileHistory(History):</span>
<span class="w"> </span>    def __init__(self, filename: str) -&gt;None:
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        super().__init__()
<span class="gi">+</span>
<span class="gi">+    def load_history_strings(self) -&gt;Iterable[str]:</span>
<span class="gi">+        if os.path.exists(self.filename):</span>
<span class="gi">+            with open(self.filename, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+                for line in reversed(f.readlines()):</span>
<span class="gi">+                    yield line.rstrip(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def store_string(self, string: str) -&gt;None:</span>
<span class="gi">+        with open(self.filename, &#39;a&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+            f.write(string + &#39;\n&#39;)</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/ansi_escape_sequences.py b/src/prompt_toolkit/input/ansi_escape_sequences.py</span>
<span class="gh">index e1df88bf..9e8bae56 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/ansi_escape_sequences.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/ansi_escape_sequences.py</span>
<span class="gu">@@ -133,7 +133,16 @@ def _get_reverse_ansi_sequences() -&gt;dict[Keys, str]:</span>
<span class="w"> </span>    Create a dictionary that maps prompt_toolkit keys back to the VT100 escape
<span class="w"> </span>    sequences.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for sequence, key in ANSI_SEQUENCES.items():</span>
<span class="gi">+        if isinstance(key, Keys):</span>
<span class="gi">+            if key not in result:</span>
<span class="gi">+                result[key] = sequence</span>
<span class="gi">+        elif isinstance(key, tuple):</span>
<span class="gi">+            # For tuples, we only consider the last key in the tuple</span>
<span class="gi">+            if key[-1] not in result:</span>
<span class="gi">+                result[key[-1]] = sequence</span>
<span class="gi">+    return result</span>


<span class="w"> </span>REVERSE_ANSI_SEQUENCES = _get_reverse_ansi_sequences()
<span class="gh">diff --git a/src/prompt_toolkit/input/base.py b/src/prompt_toolkit/input/base.py</span>
<span class="gh">index 208e9d1f..a01e1baf 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/base.py</span>
<span class="gu">@@ -23,28 +23,28 @@ class Input(metaclass=ABCMeta):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Fileno for putting this in an event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def typeahead_hash(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Identifier for storing type ahead key presses.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def read_keys(self) -&gt;list[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of Key objects which are read/parsed from the input.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def flush_keys(self) -&gt;list[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush the underlying parser. and return the pending keys.
<span class="w"> </span>        (Used for vt100 input.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="w"> </span>    def flush(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;The event loop can call this when the input has to be flushed.&quot;&quot;&quot;
<span class="gu">@@ -53,21 +53,21 @@ class Input(metaclass=ABCMeta):</span>
<span class="w"> </span>    @abstractproperty
<span class="w"> </span>    def closed(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Should be true when the input stream is closed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def raw_mode(self) -&gt;ContextManager[None]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Context manager that turns the input into raw mode.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def cooked_mode(self) -&gt;ContextManager[None]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Context manager that turns the input into cooked mode.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def attach(self, input_ready_callback: Callable[[], None]
<span class="gu">@@ -76,7 +76,7 @@ class Input(metaclass=ABCMeta):</span>
<span class="w"> </span>        Return a context manager that makes this input active in the current
<span class="w"> </span>        event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def detach(self) -&gt;ContextManager[None]:
<span class="gu">@@ -84,7 +84,7 @@ class Input(metaclass=ABCMeta):</span>
<span class="w"> </span>        Return a context manager that makes sure that this input is not active
<span class="w"> </span>        in the current event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close input.&quot;&quot;&quot;
<span class="gu">@@ -99,12 +99,12 @@ class PipeInput(Input):</span>
<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def send_bytes(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Feed byte string into the pipe&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def send_text(self, data: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Feed a text string into the pipe&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class DummyInput(Input):
<span class="gu">@@ -114,3 +114,32 @@ class DummyInput(Input):</span>
<span class="w"> </span>    If used in an actual application, it will make the application render
<span class="w"> </span>    itself once and exit immediately, due to an `EOFError`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    </span>
<span class="gi">+    def fileno(self) -&gt; int:</span>
<span class="gi">+        return -1</span>
<span class="gi">+</span>
<span class="gi">+    def typeahead_hash(self) -&gt; str:</span>
<span class="gi">+        return &quot;dummy&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def read_keys(self) -&gt; list[KeyPress]:</span>
<span class="gi">+        raise EOFError()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def closed(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def raw_mode(self) -&gt; Generator[None, None, None]:</span>
<span class="gi">+        yield</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def cooked_mode(self) -&gt; Generator[None, None, None]:</span>
<span class="gi">+        yield</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def attach(self, input_ready_callback: Callable[[], None]) -&gt; Generator[None, None, None]:</span>
<span class="gi">+        yield</span>
<span class="gi">+</span>
<span class="gi">+    @contextmanager</span>
<span class="gi">+    def detach(self) -&gt; Generator[None, None, None]:</span>
<span class="gi">+        yield</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/defaults.py b/src/prompt_toolkit/input/defaults.py</span>
<span class="gh">index 43cd9c53..11e39c47 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/defaults.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/defaults.py</span>
<span class="gu">@@ -17,7 +17,19 @@ def create_input(stdin: (TextIO | None)=None, always_prefer_tty: bool=False</span>
<span class="w"> </span>        `sys.stdin`. (We can open `stdout` or `stderr` for reading, this is how
<span class="w"> </span>        a `$PAGER` works.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if stdin is None:</span>
<span class="gi">+        stdin = sys.stdin</span>
<span class="gi">+</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        from prompt_toolkit.input.win32 import Win32Input</span>
<span class="gi">+        return Win32Input(stdin)</span>
<span class="gi">+    else:</span>
<span class="gi">+        from prompt_toolkit.input.vt100 import Vt100Input</span>
<span class="gi">+        if always_prefer_tty and not stdin.isatty():</span>
<span class="gi">+            for file in (sys.stderr, sys.stdout):</span>
<span class="gi">+                if file.isatty():</span>
<span class="gi">+                    return Vt100Input(open(file.fileno(), &#39;rb&#39;, buffering=0))</span>
<span class="gi">+        return Vt100Input(stdin)</span>


<span class="w"> </span>def create_pipe_input() -&gt;ContextManager[PipeInput]:
<span class="gu">@@ -33,4 +45,12 @@ def create_pipe_input() -&gt;ContextManager[PipeInput]:</span>
<span class="w"> </span>    Breaking change: In prompt_toolkit 3.0.28 and earlier, this was returning
<span class="w"> </span>    the `PipeInput` directly, rather than through a context manager.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _PipeInputContextManager()</span>
<span class="gi">+</span>
<span class="gi">+class _PipeInputContextManager:</span>
<span class="gi">+    def __enter__(self) -&gt; PipeInput:</span>
<span class="gi">+        self.pipe_input = PipeInput()</span>
<span class="gi">+        return self.pipe_input</span>
<span class="gi">+</span>
<span class="gi">+    def __exit__(self, exc_type, exc_val, exc_tb):</span>
<span class="gi">+        self.pipe_input.close()</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/posix_pipe.py b/src/prompt_toolkit/input/posix_pipe.py</span>
<span class="gh">index 33950c1e..0499dfae 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/posix_pipe.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/posix_pipe.py</span>
<span class="gu">@@ -20,15 +20,20 @@ class _Pipe:</span>

<span class="w"> </span>    def close_read(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close read-end if not yet closed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._read_closed:</span>
<span class="gi">+            os.close(self.read_fd)</span>
<span class="gi">+            self._read_closed = True</span>

<span class="w"> </span>    def close_write(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close write-end if not yet closed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._write_closed:</span>
<span class="gi">+            os.close(self.write_fd)</span>
<span class="gi">+            self._write_closed = True</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close both read and write ends.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.close_read()</span>
<span class="gi">+        self.close_write()</span>


<span class="w"> </span>class PosixPipeInput(Vt100Input, PipeInput):
<span class="gu">@@ -63,14 +68,14 @@ class PosixPipeInput(Vt100Input, PipeInput):</span>

<span class="w"> </span>    def send_text(self, data: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Send text to the input.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        os.write(self.pipe.write_fd, data.encode(&#39;utf-8&#39;))</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close pipe fds.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.pipe.close()</span>

<span class="w"> </span>    def typeahead_hash(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This needs to be unique for every `PipeInput`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&#39;posix-pipe-input-{self._id}&#39;</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/posix_utils.py b/src/prompt_toolkit/input/posix_utils.py</span>
<span class="gh">index 3e1d3ca4..6e39d8ff 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/posix_utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/posix_utils.py</span>
<span class="gu">@@ -43,4 +43,27 @@ class PosixStdinReader:</span>
<span class="w"> </span>        the input stream was not yet closed. This means that something went
<span class="w"> </span>        wrong during the decoding.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check if the file is closed</span>
<span class="gi">+        if self.closed:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Use select to check if there&#39;s data available to read</span>
<span class="gi">+        r, _, _ = select.select([self.stdin_fd], [], [], 0)</span>
<span class="gi">+        if not r:</span>
<span class="gi">+            return &#39;&#39;  # No data available</span>
<span class="gi">+</span>
<span class="gi">+        # Read available data</span>
<span class="gi">+        try:</span>
<span class="gi">+            data = os.read(self.stdin_fd, count)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            # File descriptor was closed</span>
<span class="gi">+            self.closed = True</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if not data:</span>
<span class="gi">+            # End of file</span>
<span class="gi">+            self.closed = True</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Decode the data</span>
<span class="gi">+        return self._stdin_decoder.decode(data)</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/typeahead.py b/src/prompt_toolkit/input/typeahead.py</span>
<span class="gh">index 1d5e4fca..c10ccc73 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/typeahead.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/typeahead.py</span>
<span class="gu">@@ -43,18 +43,20 @@ def store_typeahead(input_obj: Input, key_presses: list[KeyPress]) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Insert typeahead key presses for the given input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _buffer[input_obj].extend(key_presses)</span>


<span class="w"> </span>def get_typeahead(input_obj: Input) -&gt;list[KeyPress]:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Retrieve typeahead and reset the buffer for this input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    typeahead = _buffer[input_obj]</span>
<span class="gi">+    _buffer[input_obj] = []</span>
<span class="gi">+    return typeahead</span>


<span class="w"> </span>def clear_typeahead(input_obj: Input) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Clear typeahead buffer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _buffer[input_obj].clear()</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/vt100.py b/src/prompt_toolkit/input/vt100.py</span>
<span class="gh">index 2e980418..2ab345d7 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/vt100.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/vt100.py</span>
<span class="gu">@@ -53,25 +53,31 @@ class Vt100Input(Input):</span>
<span class="w"> </span>        Return a context manager that makes this input active in the current
<span class="w"> </span>        event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _attached_input(self, input_ready_callback)</span>

<span class="w"> </span>    def detach(self) -&gt;ContextManager[None]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes sure that this input is not active
<span class="w"> </span>        in the current event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _attached_input(self, None)</span>

<span class="w"> </span>    def read_keys(self) -&gt;list[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;Read list of KeyPress.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = self.stdin_reader.read()</span>
<span class="gi">+        self.vt100_parser.feed(data)</span>
<span class="gi">+        result = self._buffer</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def flush_keys(self) -&gt;list[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush pending keys and return them.
<span class="w"> </span>        (Used for flushing the &#39;escape&#39; key.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = self._buffer</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+        return result</span>


<span class="w"> </span>_current_callbacks: dict[tuple[AbstractEventLoop, int], Callable[[], None] |
<span class="gu">@@ -79,7 +85,7 @@ _current_callbacks: dict[tuple[AbstractEventLoop, int], Callable[[], None] |</span>


<span class="w"> </span>@contextlib.contextmanager
<span class="gd">-def _attached_input(input: Vt100Input, callback: Callable[[], None]</span>
<span class="gi">+def _attached_input(input: Vt100Input, callback: Callable[[], None] | None</span>
<span class="w"> </span>    ) -&gt;Generator[None, None, None]:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Context manager that makes this input active in the current event loop.
<span class="gu">@@ -87,7 +93,30 @@ def _attached_input(input: Vt100Input, callback: Callable[[], None]</span>
<span class="w"> </span>    :param input: :class:`~prompt_toolkit.input.Input` object.
<span class="w"> </span>    :param callback: Called when the input is ready to read.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop = get_running_loop()</span>
<span class="gi">+    key = (loop, input._fileno)</span>
<span class="gi">+</span>
<span class="gi">+    if callback is None:</span>
<span class="gi">+        # Detach</span>
<span class="gi">+        previous = _current_callbacks.get(key)</span>
<span class="gi">+        if previous:</span>
<span class="gi">+            loop.remove_reader(input._fileno)</span>
<span class="gi">+            del _current_callbacks[key]</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Attach</span>
<span class="gi">+        def ready() -&gt; None:</span>
<span class="gi">+            callback()</span>
<span class="gi">+</span>
<span class="gi">+        _current_callbacks[key] = ready</span>
<span class="gi">+        loop.add_reader(input._fileno, ready)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if callback is not None:</span>
<span class="gi">+            loop.remove_reader(input._fileno)</span>
<span class="gi">+            if key in _current_callbacks:</span>
<span class="gi">+                del _current_callbacks[key]</span>


<span class="w"> </span>class raw_mode:
<span class="gh">diff --git a/src/prompt_toolkit/input/vt100_parser.py b/src/prompt_toolkit/input/vt100_parser.py</span>
<span class="gh">index e2623b5d..253829de 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/vt100_parser.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/vt100_parser.py</span>
<span class="gu">@@ -65,26 +65,83 @@ class Vt100Parser:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start the parser coroutine.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._input_parser = self._input_parser_generator()</span>
<span class="gi">+        next(self._input_parser)</span>

<span class="w"> </span>    def _get_match(self, prefix: str) -&gt;(None | Keys | tuple[Keys, ...]):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the key (or keys) that maps to this prefix.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if prefix in ANSI_SEQUENCES:</span>
<span class="gi">+            return ANSI_SEQUENCES[prefix]</span>
<span class="gi">+        elif _cpr_response_re.match(prefix):</span>
<span class="gi">+            return Keys.CPRResponse</span>
<span class="gi">+        elif _mouse_event_re.match(prefix):</span>
<span class="gi">+            return Keys.Vt100MouseEvent</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def _input_parser_generator(self) -&gt;Generator[None, str | _Flush, None]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Coroutine (state machine) for the input parser.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prefix = &#39;&#39;</span>
<span class="gi">+        retry = False</span>
<span class="gi">+        flush = False</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            flush = False</span>
<span class="gi">+            retry = False</span>
<span class="gi">+</span>
<span class="gi">+            if retry:</span>
<span class="gi">+                data = prefix</span>
<span class="gi">+            else:</span>
<span class="gi">+                data = yield</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(data, _Flush):</span>
<span class="gi">+                flush = True</span>
<span class="gi">+                data = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+            for c in data:</span>
<span class="gi">+                prefix += c</span>
<span class="gi">+                is_prefix_of_longer_match = _IS_PREFIX_OF_LONGER_MATCH_CACHE[prefix]</span>
<span class="gi">+                match = self._get_match(prefix)</span>
<span class="gi">+</span>
<span class="gi">+                if is_prefix_of_longer_match and not flush:</span>
<span class="gi">+                    # No exact match found, but it is a prefix of a longer match.</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                elif match is None:</span>
<span class="gi">+                    # No match and also not a prefix of a longer match.</span>
<span class="gi">+                    # Reset prefix and retry with the next character.</span>
<span class="gi">+                    self._call_handler(prefix[0], &#39;&#39;)</span>
<span class="gi">+                    prefix = prefix[1:]</span>
<span class="gi">+                    retry = True</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Match found.</span>
<span class="gi">+                    self._call_handler(match, &#39;&#39;)</span>
<span class="gi">+                    prefix = &#39;&#39;</span>
<span class="gi">+                    retry = False</span>
<span class="gi">+</span>
<span class="gi">+            if flush and prefix:</span>
<span class="gi">+                # Flush prefix.</span>
<span class="gi">+                self._call_handler(prefix, &#39;&#39;)</span>
<span class="gi">+                prefix = &#39;&#39;</span>

<span class="w"> </span>    def _call_handler(self, key: (str | Keys | tuple[Keys, ...]),
<span class="w"> </span>        insert_text: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Callback to handler.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(key, tuple):</span>
<span class="gi">+            for k in key:</span>
<span class="gi">+                self._call_handler(k, insert_text)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if insert_text:</span>
<span class="gi">+                self.feed_key_callback(KeyPress(key, insert_text))</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.feed_key_callback(KeyPress(key))</span>

<span class="w"> </span>    def feed(self, data: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -92,7 +149,7 @@ class Vt100Parser:</span>

<span class="w"> </span>        :param data: Input string (unicode).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._input_parser.send(data)</span>

<span class="w"> </span>    def flush(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -106,10 +163,11 @@ class Vt100Parser:</span>
<span class="w"> </span>        timeout, and processes everything that&#39;s still in the buffer as-is, so
<span class="w"> </span>        without assuming any characters will follow.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._input_parser.send(_Flush())</span>

<span class="w"> </span>    def feed_and_flush(self, data: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Wrapper around ``feed`` and ``flush``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.feed(data)</span>
<span class="gi">+        self.flush()</span>
<span class="gh">diff --git a/src/prompt_toolkit/input/win32.py b/src/prompt_toolkit/input/win32.py</span>
<span class="gh">index 8d89a53c..ee29b772 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/win32.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/win32.py</span>
<span class="gu">@@ -52,14 +52,14 @@ class Win32Input(_Win32InputBase):</span>
<span class="w"> </span>        Return a context manager that makes this input active in the current
<span class="w"> </span>        event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return attach_win32_input(self, input_ready_callback)</span>

<span class="w"> </span>    def detach(self) -&gt;ContextManager[None]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes sure that this input is not active
<span class="w"> </span>        in the current event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return detach_win32_input(self)</span>


<span class="w"> </span>class ConsoleInputReader:
<span class="gu">@@ -106,7 +106,8 @@ class ConsoleInputReader:</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close fdcon.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._fdcon is not None:</span>
<span class="gi">+            os.close(self._fdcon)</span>

<span class="w"> </span>    def read(self) -&gt;Iterable[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -115,20 +116,49 @@ class ConsoleInputReader:</span>

<span class="w"> </span>        http://msdn.microsoft.com/en-us/library/windows/desktop/ms684961(v=vs.85).aspx
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        max_records = 1024</span>
<span class="gi">+        records = (INPUT_RECORD * max_records)()</span>
<span class="gi">+        read = DWORD()</span>
<span class="gi">+</span>
<span class="gi">+        if windll.kernel32.ReadConsoleInputW(self.handle, records, max_records, pointer(read)):</span>
<span class="gi">+            return list(self._get_keys(read.value, records))</span>
<span class="gi">+        return []</span>

<span class="w"> </span>    def _insert_key_data(self, key_press: KeyPress) -&gt;KeyPress:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Insert KeyPress data, for vt100 compatibility.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if key_press.data:</span>
<span class="gi">+            return key_press</span>
<span class="gi">+</span>
<span class="gi">+        data = REVERSE_ANSI_SEQUENCES.get(key_press.key, &#39;&#39;)</span>
<span class="gi">+        return KeyPress(key_press.key, data)</span>

<span class="w"> </span>    def _get_keys(self, read: DWORD, input_records: Array[INPUT_RECORD]
<span class="w"> </span>        ) -&gt;Iterator[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generator that yields `KeyPress` objects from the input records.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for i in range(read):</span>
<span class="gi">+            ir = input_records[i]</span>
<span class="gi">+</span>
<span class="gi">+            if ir.EventType == EventTypes.KEY_EVENT:</span>
<span class="gi">+                for key_press in self._event_to_key_presses(ir.Event.KeyEvent):</span>
<span class="gi">+                    yield self._insert_key_data(key_press)</span>
<span class="gi">+</span>
<span class="gi">+            elif ir.EventType == EventTypes.MOUSE_EVENT:</span>
<span class="gi">+                for key_press in self._handle_mouse(ir.Event.MouseEvent):</span>
<span class="gi">+                    yield key_press</span>
<span class="gi">+</span>
<span class="gi">+            elif ir.EventType == EventTypes.WINDOW_BUFFER_SIZE_EVENT:</span>
<span class="gi">+                yield KeyPress(Keys.WindowResize, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        key_presses = list(self._merge_paired_surrogates(list(self._get_keys(read, input_records))))</span>
<span class="gi">+</span>
<span class="gi">+        if self.recognize_paste and self._is_paste(key_presses):</span>
<span class="gi">+            yield KeyPress(Keys.BracketedPaste, &#39;&#39;.join(k.data for k in key_presses))</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield from key_presses</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _merge_paired_surrogates(key_presses: list[KeyPress]) -&gt;Iterator[
<span class="gu">@@ -137,7 +167,16 @@ class ConsoleInputReader:</span>
<span class="w"> </span>        Combines consecutive KeyPresses with high and low surrogates into
<span class="w"> </span>        single characters
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        while i &lt; len(key_presses):</span>
<span class="gi">+            if i + 1 &lt; len(key_presses) and \</span>
<span class="gi">+               0xD800 &lt;= ord(key_presses[i].data) &lt;= 0xDBFF and \</span>
<span class="gi">+               0xDC00 &lt;= ord(key_presses[i + 1].data) &lt;= 0xDFFF:</span>
<span class="gi">+                yield KeyPress(key_presses[i].key, key_presses[i].data + key_presses[i + 1].data)</span>
<span class="gi">+                i += 2</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield key_presses[i]</span>
<span class="gi">+                i += 1</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _is_paste(keys: list[KeyPress]) -&gt;bool:
<span class="gu">@@ -148,19 +187,69 @@ class ConsoleInputReader:</span>
<span class="w"> </span>        the best possible way to detect pasting of text and handle that
<span class="w"> </span>        correctly.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            len(keys) &gt; 1 and</span>
<span class="gi">+            all(k.key == Keys.ControlV or (</span>
<span class="gi">+                not isinstance(k.key, Keys) and</span>
<span class="gi">+                k.data is not None and</span>
<span class="gi">+                len(k.data) == 1</span>
<span class="gi">+            ) for k in keys)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _event_to_key_presses(self, ev: KEY_EVENT_RECORD) -&gt;list[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For this `KEY_EVENT_RECORD`, return a list of `KeyPress` instances.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+</span>
<span class="gi">+        if ev.KeyDown or ev.KeyDown == 0:  # In case of KeyUp, no unicode will be present.</span>
<span class="gi">+            if ev.UnicodeChar == &#39;\x00&#39;:</span>
<span class="gi">+                if ev.VirtualKeyCode in self.keycodes:</span>
<span class="gi">+                    result.append(KeyPress(self.keycodes[ev.VirtualKeyCode], &#39;&#39;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append(KeyPress(ev.UnicodeChar, ev.UnicodeChar))</span>
<span class="gi">+</span>
<span class="gi">+        # Correctly handle Control-Arrow keys.</span>
<span class="gi">+        if (ev.ControlKeyState &amp; self.LEFT_CTRL_PRESSED or</span>
<span class="gi">+            ev.ControlKeyState &amp; self.RIGHT_CTRL_PRESSED) and ev.VirtualKeyCode in self.keycodes:</span>
<span class="gi">+            result.append(KeyPress(self.keycodes[ev.VirtualKeyCode], &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        # Turn stateful shift/control/alt keys into individual events.</span>
<span class="gi">+        for k, v in [</span>
<span class="gi">+            (Keys.Shift, ev.ControlKeyState &amp; self.SHIFT_PRESSED),</span>
<span class="gi">+            (Keys.Control, ev.ControlKeyState &amp; self.LEFT_CTRL_PRESSED),</span>
<span class="gi">+            (Keys.Control, ev.ControlKeyState &amp; self.RIGHT_CTRL_PRESSED),</span>
<span class="gi">+            (Keys.Alt, ev.ControlKeyState &amp; self.LEFT_ALT_PRESSED),</span>
<span class="gi">+            (Keys.Alt, ev.ControlKeyState &amp; self.RIGHT_ALT_PRESSED),</span>
<span class="gi">+        ]:</span>
<span class="gi">+            if v:</span>
<span class="gi">+                result.append(KeyPress(k, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def _handle_mouse(self, ev: MOUSE_EVENT_RECORD) -&gt;list[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handle mouse events. Return a list of KeyPress instances.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+</span>
<span class="gi">+        # Get mouse position.</span>
<span class="gi">+        position = ev.MousePosition.X, ev.MousePosition.Y</span>
<span class="gi">+</span>
<span class="gi">+        # Mouse event.</span>
<span class="gi">+        if ev.EventFlags in (0, MOUSE_MOVED):</span>
<span class="gi">+            # Button press or release.</span>
<span class="gi">+            if ev.ButtonState == FROM_LEFT_1ST_BUTTON_PRESSED:</span>
<span class="gi">+                result.append(KeyPress(Keys.MouseDown, &#39;&#39;))</span>
<span class="gi">+            elif ev.ButtonState == RIGHTMOST_BUTTON_PRESSED:</span>
<span class="gi">+                result.append(KeyPress(Keys.MouseDown, &#39;&#39;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append(KeyPress(Keys.MouseUp, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        elif ev.EventFlags &amp; MOUSE_WHEELED:</span>
<span class="gi">+            result.append(KeyPress(Keys.ScrollUp if ev.ButtonState &gt; 0 else Keys.ScrollDown, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class _Win32Handles:
<span class="gu">@@ -188,7 +277,30 @@ class _Win32Handles:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add a Win32 handle to the event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        handle_value = handle.value</span>
<span class="gi">+</span>
<span class="gi">+        # Create an event object.</span>
<span class="gi">+        event = create_win32_event()</span>
<span class="gi">+        self._remove_events[handle_value] = event</span>
<span class="gi">+</span>
<span class="gi">+        # Add reader.</span>
<span class="gi">+        def ready() -&gt;None:</span>
<span class="gi">+            del self._handle_callbacks[handle_value]</span>
<span class="gi">+            del self._remove_events[handle_value]</span>
<span class="gi">+            callback()</span>
<span class="gi">+</span>
<span class="gi">+        self._handle_callbacks[handle_value] = ready</span>
<span class="gi">+</span>
<span class="gi">+        # Start wait thread.</span>
<span class="gi">+        def wait_for_handle() -&gt;None:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                result = wait_for_handles([handle, event])</span>
<span class="gi">+                if result == 0:</span>
<span class="gi">+                    get_running_loop().call_soon_threadsafe(ready)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        threading.Thread(target=wait_for_handle, daemon=True).start()</span>

<span class="w"> </span>    def remove_win32_handle(self, handle: HANDLE) -&gt;(Callable[[], None] | None
<span class="w"> </span>        ):
<span class="gu">@@ -196,7 +308,15 @@ class _Win32Handles:</span>
<span class="w"> </span>        Remove a Win32 handle from the event loop.
<span class="w"> </span>        Return either the registered handler or `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        handle_value = handle.value</span>
<span class="gi">+</span>
<span class="gi">+        if handle_value in self._handle_callbacks:</span>
<span class="gi">+            callback = self._handle_callbacks.pop(handle_value)</span>
<span class="gi">+            event = self._remove_events.pop(handle_value)</span>
<span class="gi">+            windll.kernel32.SetEvent(event)</span>
<span class="gi">+            return callback</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>


<span class="w"> </span>@contextmanager
<span class="gu">@@ -208,7 +328,18 @@ def attach_win32_input(input: _Win32InputBase, callback: Callable[[], None]</span>
<span class="w"> </span>    :param input: :class:`~prompt_toolkit.input.Input` object.
<span class="w"> </span>    :param input_ready_callback: Called when the input is ready to read.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    handle = input.console_input_reader.handle</span>
<span class="gi">+</span>
<span class="gi">+    def ready() -&gt;None:</span>
<span class="gi">+        # When the console is ready, set the event.</span>
<span class="gi">+        callback()</span>
<span class="gi">+</span>
<span class="gi">+    input.win32_handles.add_win32_handle(handle, ready)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        input.win32_handles.remove_win32_handle(handle)</span>


<span class="w"> </span>class raw_mode:
<span class="gh">diff --git a/src/prompt_toolkit/input/win32_pipe.py b/src/prompt_toolkit/input/win32_pipe.py</span>
<span class="gh">index 740ea177..70e6f6ad 100644</span>
<span class="gd">--- a/src/prompt_toolkit/input/win32_pipe.py</span>
<span class="gi">+++ b/src/prompt_toolkit/input/win32_pipe.py</span>
<span class="gu">@@ -44,12 +44,12 @@ class Win32PipeInput(_Win32InputBase, PipeInput):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The windows pipe doesn&#39;t depend on the file handle.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return -1  # Return a dummy value since it&#39;s not used</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def handle(self) -&gt;HANDLE:
<span class="w"> </span>        &quot;&quot;&quot;The handle used for registering this pipe in the event loop.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._event</span>

<span class="w"> </span>    def attach(self, input_ready_callback: Callable[[], None]
<span class="w"> </span>        ) -&gt;ContextManager[None]:
<span class="gu">@@ -57,40 +57,45 @@ class Win32PipeInput(_Win32InputBase, PipeInput):</span>
<span class="w"> </span>        Return a context manager that makes this input active in the current
<span class="w"> </span>        event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return attach_win32_input(self, input_ready_callback)</span>

<span class="w"> </span>    def detach(self) -&gt;ContextManager[None]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a context manager that makes sure that this input is not active
<span class="w"> </span>        in the current event loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return detach_win32_input(self)</span>

<span class="w"> </span>    def read_keys(self) -&gt;list[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;Read list of KeyPress.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = self._buffer</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def flush_keys(self) -&gt;list[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush pending keys and return them.
<span class="w"> </span>        (Used for flushing the &#39;escape&#39; key.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.read_keys()</span>

<span class="w"> </span>    def send_bytes(self, data: bytes) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Send bytes to the input.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.vt100_parser.feed(data)</span>
<span class="gi">+        windll.kernel32.SetEvent(self._event)</span>

<span class="w"> </span>    def send_text(self, text: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Send text to the input.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.send_bytes(text.encode())</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Close write-end of the pipe.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._closed:</span>
<span class="gi">+            self._closed = True</span>
<span class="gi">+            windll.kernel32.CloseHandle(self._event)</span>

<span class="w"> </span>    def typeahead_hash(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This needs to be unique for every `PipeInput`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&#39;win32-pipe-input-{self._id}&#39;</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/auto_suggest.py b/src/prompt_toolkit/key_binding/bindings/auto_suggest.py</span>
<span class="gh">index 67735983..52acce2c 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/auto_suggest.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/auto_suggest.py</span>
<span class="gu">@@ -19,4 +19,40 @@ def load_auto_suggest_bindings() -&gt;KeyBindings:</span>
<span class="w"> </span>    implementation for the &quot;right arrow&quot;, but we really want the suggestion
<span class="w"> </span>    binding when a suggestion is available.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @Condition</span>
<span class="gi">+    def suggestion_available() -&gt; bool:</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        return (</span>
<span class="gi">+            app.current_buffer.suggestion is not None</span>
<span class="gi">+            and app.current_buffer.document.is_cursor_at_the_end</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&quot;right&quot;, filter=suggestion_available)</span>
<span class="gi">+    @kb.add(&quot;c-e&quot;, filter=suggestion_available)</span>
<span class="gi">+    @kb.add(&quot;c-f&quot;, filter=suggestion_available &amp; emacs_mode)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Accept the auto-suggestion.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+        suggestion = b.suggestion</span>
<span class="gi">+</span>
<span class="gi">+        if suggestion:</span>
<span class="gi">+            b.insert_text(suggestion.text)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&quot;c-right&quot;, filter=suggestion_available)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Accept the next word of the auto-suggestion.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        b = event.current_buffer</span>
<span class="gi">+        suggestion = b.suggestion</span>
<span class="gi">+</span>
<span class="gi">+        if suggestion:</span>
<span class="gi">+            word_match = re.match(r&quot;^\S+\s*&quot;, suggestion.text)</span>
<span class="gi">+            if word_match:</span>
<span class="gi">+                b.insert_text(word_match.group())</span>
<span class="gi">+</span>
<span class="gi">+    return kb</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/basic.py b/src/prompt_toolkit/key_binding/bindings/basic.py</span>
<span class="gh">index 9c3870ef..08e12b24 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/basic.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/basic.py</span>
<span class="gu">@@ -12,4 +12,4 @@ E = KeyPressEvent</span>
<span class="w"> </span>def if_no_repeat(event: E) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Callable that returns True when the previous event was delivered to
<span class="w"> </span>    another handler.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return event.is_first_press</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/completion.py b/src/prompt_toolkit/key_binding/bindings/completion.py</span>
<span class="gh">index e88dca52..27557e75 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/completion.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/completion.py</span>
<span class="gu">@@ -24,7 +24,20 @@ def generate_completions(event: E) -&gt;None:</span>
<span class="w"> </span>    Tab-completion: where the first tab completes the common suffix and the
<span class="w"> </span>    second tab lists all the completions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    b = event.current_buffer</span>
<span class="gi">+</span>
<span class="gi">+    # If we are at the end of the input, and there&#39;s no selection, then we can</span>
<span class="gi">+    # safely insert the common suffix, otherwise, only list the completions.</span>
<span class="gi">+    if b.cursor_position == len(b.text) and not b.selection_state:</span>
<span class="gi">+        completions = list(b.completer.get_completions(b.document, CompleteEvent()))</span>
<span class="gi">+        if completions:</span>
<span class="gi">+            common_suffix = get_common_complete_suffix(b.document, completions)</span>
<span class="gi">+            if common_suffix:</span>
<span class="gi">+                b.insert_text(common_suffix)</span>
<span class="gi">+            else:</span>
<span class="gi">+                b.start_completion(select_first=False)</span>
<span class="gi">+    else:</span>
<span class="gi">+        b.start_completion(select_first=False)</span>


<span class="w"> </span>def display_completions_like_readline(event: E) -&gt;None:
<span class="gu">@@ -41,7 +54,11 @@ def display_completions_like_readline(event: E) -&gt;None:</span>
<span class="w"> </span>        # Call this handler when &#39;Tab&#39; has been pressed.
<span class="w"> </span>        key_bindings.add(Keys.ControlI)(display_completions_like_readline)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    b = event.current_buffer</span>
<span class="gi">+    completions = list(b.completer.get_completions(b.document, CompleteEvent()))</span>
<span class="gi">+</span>
<span class="gi">+    if completions:</span>
<span class="gi">+        asyncio.ensure_future(_display_completions_like_readline(event.app, completions))</span>


<span class="w"> </span>def _display_completions_like_readline(app: Application[object],
<span class="gu">@@ -51,11 +68,71 @@ def _display_completions_like_readline(app: Application[object],</span>
<span class="w"> </span>    This will ask for a confirmation if there are too many completions to fit
<span class="w"> </span>    on a single page and provide a paginator to walk through them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    async def run():</span>
<span class="gi">+        loop = asyncio.get_event_loop()</span>
<span class="gi">+        term_size = app.output.get_size()</span>
<span class="gi">+        page_size = term_size.rows - 1  # Leave one row for the prompt</span>
<span class="gi">+        completions_per_page = page_size * (term_size.columns // 20)</span>
<span class="gi">+        pages = math.ceil(len(completions) / completions_per_page)</span>
<span class="gi">+</span>
<span class="gi">+        if pages &gt; 1:</span>
<span class="gi">+            show_meta = await loop.run_in_executor(None, _create_more_session().prompt)</span>
<span class="gi">+            if not show_meta:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        def format_completion(completion: Completion) -&gt; StyleAndTextTuples:</span>
<span class="gi">+            return [(&#39;class:completion&#39;, completion.text)]</span>
<span class="gi">+</span>
<span class="gi">+        for page in range(pages):</span>
<span class="gi">+            start = page * completions_per_page</span>
<span class="gi">+            end = min((page + 1) * completions_per_page, len(completions))</span>
<span class="gi">+            page_completions = completions[start:end]</span>
<span class="gi">+</span>
<span class="gi">+            formatted_completions = [format_completion(c) for c in page_completions]</span>
<span class="gi">+            if page &lt; pages - 1:</span>
<span class="gi">+                formatted_completions.append([(&#39;class:completion&#39;, &#39;--MORE--&#39;)])</span>
<span class="gi">+</span>
<span class="gi">+            with in_terminal():</span>
<span class="gi">+                app.print_formatted_text(formatted_completions, style=&#39;class:completion-menu&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if page &lt; pages - 1:</span>
<span class="gi">+                show_next = await loop.run_in_executor(None, _create_more_session().prompt)</span>
<span class="gi">+                if not show_next:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+    return asyncio.create_task(run())</span>


<span class="w"> </span>def _create_more_session(message: str=&#39;--MORE--&#39;) -&gt;PromptSession[bool]:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a `PromptSession` object for displaying the &quot;--MORE--&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from prompt_toolkit.shortcuts import PromptSession</span>
<span class="gi">+</span>
<span class="gi">+    bindings = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @bindings.add(&#39; &#39;)</span>
<span class="gi">+    @bindings.add(&#39;y&#39;)</span>
<span class="gi">+    @bindings.add(&#39;Y&#39;)</span>
<span class="gi">+    @bindings.add(Keys.Enter)</span>
<span class="gi">+    @bindings.add(Keys.ControlJ)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        event.app.exit(result=True)</span>
<span class="gi">+</span>
<span class="gi">+    @bindings.add(&#39;n&#39;)</span>
<span class="gi">+    @bindings.add(&#39;N&#39;)</span>
<span class="gi">+    @bindings.add(&#39;q&#39;)</span>
<span class="gi">+    @bindings.add(&#39;Q&#39;)</span>
<span class="gi">+    @bindings.add(Keys.ControlC)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        event.app.exit(result=False)</span>
<span class="gi">+</span>
<span class="gi">+    @bindings.add(Keys.Any)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Disable inserting of text. &quot;</span>
<span class="gi">+</span>
<span class="gi">+    return PromptSession(</span>
<span class="gi">+        message,</span>
<span class="gi">+        key_bindings=bindings,</span>
<span class="gi">+        erase_when_done=True,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/emacs.py b/src/prompt_toolkit/key_binding/bindings/emacs.py</span>
<span class="gh">index c03fc0ea..46eebe86 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/emacs.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/emacs.py</span>
<span class="gu">@@ -18,11 +18,63 @@ def load_emacs_bindings() -&gt;KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Some e-macs extensions.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-x&#39;, &#39;c-e&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Open editor.&quot;&quot;&quot;</span>
<span class="gi">+        event.app.run_system_command(&#39;editor&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-x&#39;, &#39;c-f&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Find file.&quot;&quot;&quot;</span>
<span class="gi">+        event.app.run_system_command(&#39;find_file&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-x&#39;, &#39;c-s&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Save file.&quot;&quot;&quot;</span>
<span class="gi">+        event.app.run_system_command(&#39;save_file&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-x&#39;, &#39;c-c&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Quit.&quot;&quot;&quot;</span>
<span class="gi">+        event.app.exit()</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(kb, emacs_mode)</span>


<span class="w"> </span>def load_emacs_shift_selection_bindings() -&gt;KeyBindingsBase:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Bindings to select text with shift + cursor movements
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;s-left&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Move cursor left and select.&quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        buff.cursor_position += buff.document.get_cursor_left_position(count=event.arg)</span>
<span class="gi">+        buff.start_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;s-right&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Move cursor right and select.&quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        buff.cursor_position += buff.document.get_cursor_right_position(count=event.arg)</span>
<span class="gi">+        buff.start_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;s-up&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Move cursor up and select.&quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        buff.cursor_up(count=event.arg)</span>
<span class="gi">+        buff.start_selection()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;s-down&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Move cursor down and select.&quot;&quot;&quot;</span>
<span class="gi">+        buff = event.current_buffer</span>
<span class="gi">+        buff.cursor_down(count=event.arg)</span>
<span class="gi">+        buff.start_selection()</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(kb, emacs_mode &amp; shift_selection_mode)</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/focus.py b/src/prompt_toolkit/key_binding/bindings/focus.py</span>
<span class="gh">index 9d636a30..ae44abb3 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/focus.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/focus.py</span>
<span class="gu">@@ -9,7 +9,7 @@ def focus_next(event: E) -&gt;None:</span>
<span class="w"> </span>    Focus the next visible Window.
<span class="w"> </span>    (Often bound to the `Tab` key.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.layout.focus_next()</span>


<span class="w"> </span>def focus_previous(event: E) -&gt;None:
<span class="gu">@@ -17,4 +17,4 @@ def focus_previous(event: E) -&gt;None:</span>
<span class="w"> </span>    Focus the previous visible Window.
<span class="w"> </span>    (Often bound to the `BackTab` key.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.layout.focus_previous()</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/mouse.py b/src/prompt_toolkit/key_binding/bindings/mouse.py</span>
<span class="gh">index 03ff5d6f..20a15317 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/mouse.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/mouse.py</span>
<span class="gu">@@ -113,4 +113,48 @@ def load_mouse_bindings() -&gt;KeyBindings:</span>
<span class="w"> </span>    Key bindings, required for mouse support.
<span class="w"> </span>    (Mouse events enter through the key binding system.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key_bindings = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @key_bindings.add(Keys.Any)</span>
<span class="gi">+    def _(event: E) -&gt; NotImplementedOrNone:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Catch mouse events.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if event.key_sequence[0].key == Keys.WindowsMouseEvent:</span>
<span class="gi">+            return _handle_mouse_event(event, system=&quot;windows&quot;)</span>
<span class="gi">+        elif event.key_sequence[0].key == Keys.VtMouseEvent:</span>
<span class="gi">+            return _handle_mouse_event(event, system=&quot;vt&quot;)</span>
<span class="gi">+        return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+    return key_bindings</span>
<span class="gi">+</span>
<span class="gi">+def _handle_mouse_event(event: E, system: str) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Handle mouse events for both Windows and VT systems.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    # Get the parsed mouse event.</span>
<span class="gi">+    mouse_event = event.key_sequence[0].data</span>
<span class="gi">+</span>
<span class="gi">+    if system == &quot;windows&quot;:</span>
<span class="gi">+        # Windows systems</span>
<span class="gi">+        x = mouse_event.position.x</span>
<span class="gi">+        y = mouse_event.position.y</span>
<span class="gi">+        button = mouse_event.button</span>
<span class="gi">+        event_type = mouse_event.event_type</span>
<span class="gi">+        modifiers = mouse_event.modifiers</span>
<span class="gi">+    else:</span>
<span class="gi">+        # VT systems</span>
<span class="gi">+        x = mouse_event.x</span>
<span class="gi">+        y = mouse_event.y</span>
<span class="gi">+        button = mouse_event.button</span>
<span class="gi">+        event_type = mouse_event.event_type</span>
<span class="gi">+        modifiers = mouse_event.modifiers</span>
<span class="gi">+</span>
<span class="gi">+    # Create a MouseEvent instance</span>
<span class="gi">+    mouse_event = MouseEvent(position=Point(x=x, y=y),</span>
<span class="gi">+                             event_type=event_type,</span>
<span class="gi">+                             button=button,</span>
<span class="gi">+                             modifiers=modifiers)</span>
<span class="gi">+</span>
<span class="gi">+    # Call the mouse handler</span>
<span class="gi">+    event.app.mouse_handlers.mouse_click(mouse_event)</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/named_commands.py b/src/prompt_toolkit/key_binding/bindings/named_commands.py</span>
<span class="gh">index 5b59883f..813b24c0 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/named_commands.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/named_commands.py</span>
<span class="gu">@@ -26,14 +26,17 @@ def register(name: str) -&gt;Callable[[_T], _T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Store handler in the `_readline_commands` dictionary.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(handler: _T) -&gt;_T:</span>
<span class="gi">+        _readline_commands[name] = handler</span>
<span class="gi">+        return handler</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>def get_by_name(name: str) -&gt;Binding:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the handler for the (Readline) command with the given name.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _readline_commands.get(name, lambda event: None)</span>


<span class="w"> </span>@register(&#39;beginning-of-buffer&#39;)
<span class="gu">@@ -41,7 +44,7 @@ def beginning_of_buffer(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the start of the buffer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.cursor_position = 0</span>


<span class="w"> </span>@register(&#39;end-of-buffer&#39;)
<span class="gu">@@ -49,7 +52,7 @@ def end_of_buffer(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the end of the buffer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.cursor_position = len(event.current_buffer.text)</span>


<span class="w"> </span>@register(&#39;beginning-of-line&#39;)
<span class="gu">@@ -57,7 +60,7 @@ def beginning_of_line(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the start of the current line.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.cursor_position = event.current_buffer.document.get_start_of_line_position()</span>


<span class="w"> </span>@register(&#39;end-of-line&#39;)
<span class="gu">@@ -65,7 +68,7 @@ def end_of_line(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the end of the line.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.cursor_position = event.current_buffer.document.get_end_of_line_position()</span>


<span class="w"> </span>@register(&#39;forward-char&#39;)
<span class="gu">@@ -73,13 +76,13 @@ def forward_char(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move forward a character.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.cursor_right()</span>


<span class="w"> </span>@register(&#39;backward-char&#39;)
<span class="w"> </span>def backward_char(event: E) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Move back a character.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.cursor_left()</span>


<span class="w"> </span>@register(&#39;forward-word&#39;)
<span class="gu">@@ -88,7 +91,7 @@ def forward_word(event: E) -&gt;None:</span>
<span class="w"> </span>    Move forward to the end of the next word. Words are composed of letters and
<span class="w"> </span>    digits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.cursor_right(event.current_buffer.document.find_next_word_ending())</span>


<span class="w"> </span>@register(&#39;backward-word&#39;)
<span class="gu">@@ -97,7 +100,7 @@ def backward_word(event: E) -&gt;None:</span>
<span class="w"> </span>    Move back to the start of the current or previous word. Words are composed
<span class="w"> </span>    of letters and digits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.cursor_left(event.current_buffer.document.find_previous_word_beginning())</span>


<span class="w"> </span>@register(&#39;clear-screen&#39;)
<span class="gu">@@ -105,7 +108,7 @@ def clear_screen(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Clear the screen and redraw everything at the top of the screen.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.renderer.clear()</span>


<span class="w"> </span>@register(&#39;redraw-current-line&#39;)
<span class="gu">@@ -114,7 +117,7 @@ def redraw_current_line(event: E) -&gt;None:</span>
<span class="w"> </span>    Refresh the current line.
<span class="w"> </span>    (Readline defines this command, but prompt-toolkit doesn&#39;t have it.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.invalidate()</span>


<span class="w"> </span>@register(&#39;accept-line&#39;)
<span class="gu">@@ -122,7 +125,7 @@ def accept_line(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Accept the line regardless of where the cursor is.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.validate_and_handle()</span>


<span class="w"> </span>@register(&#39;previous-history&#39;)
<span class="gu">@@ -130,7 +133,7 @@ def previous_history(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move `back` through the history list, fetching the previous command.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.history_backward()</span>


<span class="w"> </span>@register(&#39;next-history&#39;)
<span class="gu">@@ -138,7 +141,7 @@ def next_history(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move `forward` through the history list, fetching the next command.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.history_forward()</span>


<span class="w"> </span>@register(&#39;beginning-of-history&#39;)
<span class="gu">@@ -146,7 +149,7 @@ def beginning_of_history(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the first line in the history.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.go_to_history(0)</span>


<span class="w"> </span>@register(&#39;end-of-history&#39;)
<span class="gu">@@ -154,7 +157,7 @@ def end_of_history(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Move to the end of the input history, i.e., the line currently being entered.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.current_buffer.history_forward(count=len(event.current_buffer._working_lines) - 1)</span>


<span class="w"> </span>@register(&#39;reverse-search-history&#39;)
<span class="gu">@@ -163,15 +166,16 @@ def reverse_search_history(event: E) -&gt;None:</span>
<span class="w"> </span>    Search backward starting at the current line and moving `up` through
<span class="w"> </span>    the history as necessary. This is an incremental search.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.layout.focus(event.app.layout.search_buffer)</span>
<span class="gi">+    event.app.vi_state.input_mode = EditingMode.INSERT</span>


<span class="w"> </span>@register(&#39;end-of-file&#39;)
<span class="gd">-def end_of_file(event: E) -&gt;None:</span>
<span class="gi">+def end-of-file(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Exit.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    event.app.exit()</span>


<span class="w"> </span>@register(&#39;delete-char&#39;)
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/open_in_editor.py b/src/prompt_toolkit/key_binding/bindings/open_in_editor.py</span>
<span class="gh">index 6199de8b..6f9c7429 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/open_in_editor.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/open_in_editor.py</span>
<span class="gu">@@ -13,18 +13,35 @@ def load_open_in_editor_bindings() -&gt;KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Load both the Vi and emacs key bindings for handling edit-and-execute-command.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return merge_key_bindings([</span>
<span class="gi">+        load_emacs_open_in_editor_bindings(),</span>
<span class="gi">+        load_vi_open_in_editor_bindings(),</span>
<span class="gi">+    ])</span>


<span class="w"> </span>def load_emacs_open_in_editor_bindings() -&gt;KeyBindings:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Pressing C-X C-E will open the buffer in an external editor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+    </span>
<span class="gi">+    @kb.add(&#39;c-x&#39;, &#39;c-e&#39;, filter=emacs_mode &amp; ~has_selection)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot;&quot;&quot;Edit and execute command.&quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.open_in_editor(event.cli)</span>
<span class="gi">+    </span>
<span class="gi">+    return kb</span>


<span class="w"> </span>def load_vi_open_in_editor_bindings() -&gt;KeyBindings:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Pressing &#39;v&#39; in navigation mode will open the buffer in an external editor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+    </span>
<span class="gi">+    @kb.add(&#39;v&#39;, filter=vi_navigation_mode &amp; ~has_selection)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot;&quot;&quot;Edit and execute command.&quot;&quot;&quot;</span>
<span class="gi">+        event.current_buffer.open_in_editor(event.cli)</span>
<span class="gi">+    </span>
<span class="gi">+    return kb</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/page_navigation.py b/src/prompt_toolkit/key_binding/bindings/page_navigation.py</span>
<span class="gh">index 302f662b..c5f525fb 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/page_navigation.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/page_navigation.py</span>
<span class="gu">@@ -14,7 +14,10 @@ def load_page_navigation_bindings() -&gt;KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Load both the Vi and Emacs bindings for page navigation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return merge_key_bindings([</span>
<span class="gi">+        load_emacs_page_navigation_bindings(),</span>
<span class="gi">+        load_vi_page_navigation_bindings()</span>
<span class="gi">+    ])</span>


<span class="w"> </span>def load_emacs_page_navigation_bindings() -&gt;KeyBindingsBase:
<span class="gu">@@ -22,7 +25,39 @@ def load_emacs_page_navigation_bindings() -&gt;KeyBindingsBase:</span>
<span class="w"> </span>    Key bindings, for scrolling up and down through pages.
<span class="w"> </span>    This are separate bindings, because GNU readline doesn&#39;t have them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-v&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll half page down. &quot;</span>
<span class="gi">+        scroll_half_page_down(event)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;pagedown&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll one page down. &quot;</span>
<span class="gi">+        scroll_page_down(event)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;escape&#39;, &#39;v&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll half page up. &quot;</span>
<span class="gi">+        scroll_half_page_up(event)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;pageup&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll one page up. &quot;</span>
<span class="gi">+        scroll_page_up(event)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;escape&#39;, &#39;&gt;&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll to bottom. &quot;</span>
<span class="gi">+        scroll_forward(event, count=1000000)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;escape&#39;, &#39;&lt;&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll to top. &quot;</span>
<span class="gi">+        scroll_backward(event, count=1000000)</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(kb, emacs_mode &amp; buffer_has_focus)</span>


<span class="w"> </span>def load_vi_page_navigation_bindings() -&gt;KeyBindingsBase:
<span class="gu">@@ -30,4 +65,36 @@ def load_vi_page_navigation_bindings() -&gt;KeyBindingsBase:</span>
<span class="w"> </span>    Key bindings, for scrolling up and down through pages.
<span class="w"> </span>    This are separate bindings, because GNU readline doesn&#39;t have them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-f&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll one page down. &quot;</span>
<span class="gi">+        scroll_page_down(event)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-b&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll one page up. &quot;</span>
<span class="gi">+        scroll_page_up(event)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-d&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll half page down. &quot;</span>
<span class="gi">+        scroll_half_page_down(event)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-u&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll half page up. &quot;</span>
<span class="gi">+        scroll_half_page_up(event)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-e&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll one line down. &quot;</span>
<span class="gi">+        scroll_one_line_down(event)</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-y&#39;)</span>
<span class="gi">+    def _(event):</span>
<span class="gi">+        &quot; Scroll one line up. &quot;</span>
<span class="gi">+        scroll_one_line_up(event)</span>
<span class="gi">+</span>
<span class="gi">+    return ConditionalKeyBindings(kb, vi_mode &amp; buffer_has_focus)</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/scroll.py b/src/prompt_toolkit/key_binding/bindings/scroll.py</span>
<span class="gh">index c1d1ada6..27d17576 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/scroll.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/scroll.py</span>
<span class="gu">@@ -16,53 +16,112 @@ def scroll_forward(event: E, half: bool=False) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Scroll window down.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    window = event.app.layout.current_window</span>
<span class="gi">+    if window:</span>
<span class="gi">+        info = window.render_info</span>
<span class="gi">+        if info:</span>
<span class="gi">+            amount = info.window_height // 2 if half else info.window_height</span>
<span class="gi">+            new_scroll = min(info.content_height - info.window_height,</span>
<span class="gi">+                             info.vertical_scroll + amount)</span>
<span class="gi">+            window.vertical_scroll = new_scroll</span>


<span class="w"> </span>def scroll_backward(event: E, half: bool=False) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Scroll window up.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    window = event.app.layout.current_window</span>
<span class="gi">+    if window:</span>
<span class="gi">+        info = window.render_info</span>
<span class="gi">+        if info:</span>
<span class="gi">+            amount = info.window_height // 2 if half else info.window_height</span>
<span class="gi">+            new_scroll = max(0, info.vertical_scroll - amount)</span>
<span class="gi">+            window.vertical_scroll = new_scroll</span>


<span class="w"> </span>def scroll_half_page_down(event: E) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Same as ControlF, but only scroll half a page.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scroll_forward(event, half=True)</span>


<span class="w"> </span>def scroll_half_page_up(event: E) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Same as ControlB, but only scroll half a page.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scroll_backward(event, half=True)</span>


<span class="w"> </span>def scroll_one_line_down(event: E) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    scroll_offset += 1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    window = event.app.layout.current_window</span>
<span class="gi">+    if window:</span>
<span class="gi">+        info = window.render_info</span>
<span class="gi">+        if info:</span>
<span class="gi">+            new_scroll = min(info.content_height - info.window_height,</span>
<span class="gi">+                             info.vertical_scroll + 1)</span>
<span class="gi">+            window.vertical_scroll = new_scroll</span>


<span class="w"> </span>def scroll_one_line_up(event: E) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    scroll_offset -= 1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    window = event.app.layout.current_window</span>
<span class="gi">+    if window:</span>
<span class="gi">+        info = window.render_info</span>
<span class="gi">+        if info:</span>
<span class="gi">+            new_scroll = max(0, info.vertical_scroll - 1)</span>
<span class="gi">+            window.vertical_scroll = new_scroll</span>


<span class="w"> </span>def scroll_page_down(event: E) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Scroll page down. (Prefer the cursor at the top of the page, after scrolling.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    window = event.app.layout.current_window</span>
<span class="gi">+    b = event.app.current_buffer</span>
<span class="gi">+    if window and b:</span>
<span class="gi">+        info = window.render_info</span>
<span class="gi">+        if info:</span>
<span class="gi">+            # Scroll down one page, but keep one overlap line.</span>
<span class="gi">+            overlap = 1</span>
<span class="gi">+            new_scroll = min(info.content_height - info.window_height,</span>
<span class="gi">+                             info.vertical_scroll + info.window_height - overlap)</span>
<span class="gi">+            window.vertical_scroll = new_scroll</span>
<span class="gi">+</span>
<span class="gi">+            # Put cursor at the top of the visible region.</span>
<span class="gi">+            try:</span>
<span class="gi">+                new_document_line = b.document.translate_row_col_to_index(</span>
<span class="gi">+                    info.first_visible_line(), 0</span>
<span class="gi">+                )</span>
<span class="gi">+                b.cursor_position = new_document_line</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                pass</span>


<span class="w"> </span>def scroll_page_up(event: E) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Scroll page up. (Prefer the cursor at the bottom of the page, after scrolling.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    window = event.app.layout.current_window</span>
<span class="gi">+    b = event.app.current_buffer</span>
<span class="gi">+    if window and b:</span>
<span class="gi">+        info = window.render_info</span>
<span class="gi">+        if info:</span>
<span class="gi">+            # Scroll up one page, but keep one overlap line.</span>
<span class="gi">+            overlap = 1</span>
<span class="gi">+            new_scroll = max(0, info.vertical_scroll - info.window_height + overlap)</span>
<span class="gi">+            window.vertical_scroll = new_scroll</span>
<span class="gi">+</span>
<span class="gi">+            # Put cursor at the bottom of the visible region.</span>
<span class="gi">+            try:</span>
<span class="gi">+                new_document_line = b.document.translate_row_col_to_index(</span>
<span class="gi">+                    info.last_visible_line(), 0</span>
<span class="gi">+                )</span>
<span class="gi">+                b.cursor_position = new_document_line</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                pass</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/search.py b/src/prompt_toolkit/key_binding/bindings/search.py</span>
<span class="gh">index 3df6124e..545f7144 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/search.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/search.py</span>
<span class="gu">@@ -21,7 +21,10 @@ def abort_search(event: E) -&gt;None:</span>
<span class="w"> </span>    line.
<span class="w"> </span>    (Usually bound to ControlG/ControlC.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search_state = event.app.current_search_state</span>
<span class="gi">+    if search_state:</span>
<span class="gi">+        search_state.abort()</span>
<span class="gi">+    event.app.layout.focus_previous()</span>


<span class="w"> </span>@key_binding(filter=is_searching)
<span class="gu">@@ -31,7 +34,10 @@ def accept_search(event: E) -&gt;None:</span>
<span class="w"> </span>    isearch would be too complicated.)
<span class="w"> </span>    (Usually bound to Enter.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search_state = event.app.current_search_state</span>
<span class="gi">+    if search_state:</span>
<span class="gi">+        search_state.apply_search()</span>
<span class="gi">+    event.app.layout.focus_previous()</span>


<span class="w"> </span>@key_binding(filter=control_is_searchable)
<span class="gu">@@ -40,7 +46,13 @@ def start_reverse_incremental_search(event: E) -&gt;None:</span>
<span class="w"> </span>    Enter reverse incremental search.
<span class="w"> </span>    (Usually ControlR.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search_state = event.app.current_search_state</span>
<span class="gi">+    if search_state is None:</span>
<span class="gi">+        search_state = search.SearchState(direction=search.SearchDirection.BACKWARD)</span>
<span class="gi">+        event.app.current_search_state = search_state</span>
<span class="gi">+    else:</span>
<span class="gi">+        search_state.direction = search.SearchDirection.BACKWARD</span>
<span class="gi">+    event.app.layout.focus(search_state.control)</span>


<span class="w"> </span>@key_binding(filter=control_is_searchable)
<span class="gu">@@ -49,7 +61,13 @@ def start_forward_incremental_search(event: E) -&gt;None:</span>
<span class="w"> </span>    Enter forward incremental search.
<span class="w"> </span>    (Usually ControlS.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search_state = event.app.current_search_state</span>
<span class="gi">+    if search_state is None:</span>
<span class="gi">+        search_state = search.SearchState(direction=search.SearchDirection.FORWARD)</span>
<span class="gi">+        event.app.current_search_state = search_state</span>
<span class="gi">+    else:</span>
<span class="gi">+        search_state.direction = search.SearchDirection.FORWARD</span>
<span class="gi">+    event.app.layout.focus(search_state.control)</span>


<span class="w"> </span>@key_binding(filter=is_searching)
<span class="gu">@@ -57,7 +75,10 @@ def reverse_incremental_search(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Apply reverse incremental search, but keep search buffer focused.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search_state = event.app.current_search_state</span>
<span class="gi">+    if search_state:</span>
<span class="gi">+        search_state.direction = search.SearchDirection.BACKWARD</span>
<span class="gi">+        search_state.apply_search()</span>


<span class="w"> </span>@key_binding(filter=is_searching)
<span class="gu">@@ -65,7 +86,10 @@ def forward_incremental_search(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Apply forward incremental search, but keep search buffer focused.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search_state = event.app.current_search_state</span>
<span class="gi">+    if search_state:</span>
<span class="gi">+        search_state.direction = search.SearchDirection.FORWARD</span>
<span class="gi">+        search_state.apply_search()</span>


<span class="w"> </span>@Condition
<span class="gu">@@ -73,7 +97,9 @@ def _previous_buffer_is_returnable() -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True if the previously focused buffer has a return handler.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    prev_control = app.layout.previous_control</span>
<span class="gi">+    return prev_control is not None and prev_control.buffer.is_returnable</span>


<span class="w"> </span>@key_binding(filter=is_searching &amp; _previous_buffer_is_returnable)
<span class="gu">@@ -81,4 +107,8 @@ def accept_search_and_accept_input(event: E) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Accept the search operation first, then accept the input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    search_state = event.app.current_search_state</span>
<span class="gi">+    if search_state:</span>
<span class="gi">+        search_state.apply_search()</span>
<span class="gi">+    event.app.layout.focus_previous()</span>
<span class="gi">+    event.app.current_buffer.validate_and_handle()</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/bindings/vi.py b/src/prompt_toolkit/key_binding/bindings/vi.py</span>
<span class="gh">index bdf5ffe0..3e9b4a1a 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/bindings/vi.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/bindings/vi.py</span>
<span class="gu">@@ -48,7 +48,7 @@ class TextObject:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a (start, end) tuple where start &lt;= end.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (min(self.start, self.end), max(self.start, self.end))</span>

<span class="w"> </span>    def operator_range(self, document: Document) -&gt;tuple[int, int]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -59,19 +59,57 @@ class TextObject:</span>
<span class="w"> </span>        This should return something that can be used in a slice, so the `end`
<span class="w"> </span>        position is *not* included.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start, end = self.sorted()</span>
<span class="gi">+        cursor_position = document.cursor_position</span>
<span class="gi">+</span>
<span class="gi">+        if self.type == TextObjectType.EXCLUSIVE:</span>
<span class="gi">+            return (cursor_position + start, cursor_position + end + 1)</span>
<span class="gi">+        elif self.type == TextObjectType.INCLUSIVE:</span>
<span class="gi">+            return (cursor_position + start, cursor_position + end + 1)</span>
<span class="gi">+        elif self.type == TextObjectType.LINEWISE:</span>
<span class="gi">+            start_line = document.line_count - 1 if start &lt; 0 else document.cursor_position_row + start</span>
<span class="gi">+            end_line = document.line_count - 1 if end &lt; 0 else document.cursor_position_row + end</span>
<span class="gi">+            return (document.get_start_of_line_position(start_line),</span>
<span class="gi">+                    min(document.get_end_of_line_position(end_line) + 1, len(document.text)))</span>
<span class="gi">+        else:  # BLOCK</span>
<span class="gi">+            return (cursor_position + start, cursor_position + end + 1)</span>

<span class="w"> </span>    def get_line_numbers(self, buffer: Buffer) -&gt;tuple[int, int]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a (start_line, end_line) pair.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        document = buffer.document</span>
<span class="gi">+        start, end = self.sorted()</span>
<span class="gi">+        cursor_row = document.cursor_position_row</span>
<span class="gi">+</span>
<span class="gi">+        if self.type in (TextObjectType.EXCLUSIVE, TextObjectType.INCLUSIVE):</span>
<span class="gi">+            start_line = document.translate_row_col_to_index(cursor_row + start, 0)</span>
<span class="gi">+            end_line = document.translate_row_col_to_index(cursor_row + end, 0)</span>
<span class="gi">+        elif self.type == TextObjectType.LINEWISE:</span>
<span class="gi">+            start_line = max(0, cursor_row + start)</span>
<span class="gi">+            end_line = min(document.line_count - 1, cursor_row + end)</span>
<span class="gi">+        else:  # BLOCK</span>
<span class="gi">+            start_line = cursor_row</span>
<span class="gi">+            end_line = cursor_row + end</span>
<span class="gi">+</span>
<span class="gi">+        return (start_line, end_line)</span>

<span class="w"> </span>    def cut(self, buffer: Buffer) -&gt;tuple[Document, ClipboardData]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Turn text object into `ClipboardData` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start, end = self.operator_range(buffer.document)</span>
<span class="gi">+        text = buffer.text[start:end]</span>
<span class="gi">+        </span>
<span class="gi">+        if self.type == TextObjectType.LINEWISE:</span>
<span class="gi">+            text += &#39;\n&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        new_document = Document(</span>
<span class="gi">+            text=buffer.text[:start] + buffer.text[end:],</span>
<span class="gi">+            cursor_position=start</span>
<span class="gi">+        )</span>
<span class="gi">+        </span>
<span class="gi">+        return new_document, ClipboardData(text, self.type)</span>


<span class="w"> </span>TextObjectFunction = Callable[[E], TextObject]
<span class="gu">@@ -83,7 +121,23 @@ def create_text_object_decorator(key_bindings: KeyBindings) -&gt;Callable[...,</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a decorator that can be used to register Vi text object implementations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(*keys: str, filter: Filter=Always(), eager: bool=False):</span>
<span class="gi">+        def wrapper(func: _TOF) -&gt; _TOF:</span>
<span class="gi">+            @key_bindings.add(*keys, filter=filter &amp; vi_waiting_for_text_object_mode, eager=eager)</span>
<span class="gi">+            def _(event: E) -&gt; None:</span>
<span class="gi">+                if event.app.vi_state.operator_func:</span>
<span class="gi">+                    text_object = func(event)</span>
<span class="gi">+                    event.app.vi_state.operator_func(event, text_object)</span>
<span class="gi">+                    event.app.vi_state.operator_func = None</span>
<span class="gi">+                    event.app.vi_state.operator_arg = None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Move cursor.</span>
<span class="gi">+                    text_object = func(event)</span>
<span class="gi">+                    start, end = text_object.operator_range(event.app.current_buffer.document)</span>
<span class="gi">+                    event.app.current_buffer.cursor_position += start</span>
<span class="gi">+            return func</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>OperatorFunction = Callable[[E, TextObject], None]
<span class="gu">@@ -95,7 +149,16 @@ def create_operator_decorator(key_bindings: KeyBindings) -&gt;Callable[...,</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a decorator that can be used for registering Vi operators.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(*keys: str, filter: Filter=Always(), eager: bool=False):</span>
<span class="gi">+        def wrapper(func: _OF) -&gt; _OF:</span>
<span class="gi">+            @key_bindings.add(*keys, filter=filter &amp; vi_navigation_mode, eager=eager)</span>
<span class="gi">+            def _(event: E) -&gt; None:</span>
<span class="gi">+                event.app.vi_state.operator_func = func</span>
<span class="gi">+                event.app.vi_state.operator_arg = event.arg</span>
<span class="gi">+</span>
<span class="gi">+            return func</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>def load_vi_bindings() -&gt;KeyBindingsBase:
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/defaults.py b/src/prompt_toolkit/key_binding/defaults.py</span>
<span class="gh">index 020b28c1..90dc0244 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/defaults.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/defaults.py</span>
<span class="gu">@@ -19,4 +19,22 @@ def load_key_bindings() -&gt;KeyBindingsBase:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a KeyBindings object that contains the default key bindings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return merge_key_bindings([</span>
<span class="gi">+        # Load basic bindings.</span>
<span class="gi">+        load_basic_bindings(),</span>
<span class="gi">+</span>
<span class="gi">+        # Load emacs bindings.</span>
<span class="gi">+        ConditionalKeyBindings(load_emacs_bindings(), ~buffer_has_focus),</span>
<span class="gi">+        ConditionalKeyBindings(load_emacs_search_bindings(), ~buffer_has_focus),</span>
<span class="gi">+        ConditionalKeyBindings(load_emacs_shift_selection_bindings(), ~buffer_has_focus),</span>
<span class="gi">+</span>
<span class="gi">+        # Load Vi bindings.</span>
<span class="gi">+        ConditionalKeyBindings(load_vi_bindings(), ~buffer_has_focus),</span>
<span class="gi">+        ConditionalKeyBindings(load_vi_search_bindings(), ~buffer_has_focus),</span>
<span class="gi">+</span>
<span class="gi">+        # Load mouse bindings.</span>
<span class="gi">+        load_mouse_bindings(),</span>
<span class="gi">+</span>
<span class="gi">+        # Load CPR bindings.</span>
<span class="gi">+        load_cpr_bindings(),</span>
<span class="gi">+    ])</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/emacs_state.py b/src/prompt_toolkit/key_binding/emacs_state.py</span>
<span class="gh">index d60cbeb7..66eb5ce1 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/emacs_state.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/emacs_state.py</span>
<span class="gu">@@ -15,12 +15,15 @@ class EmacsState:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def is_recording(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Tell whether we are recording a macro.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.current_recording is not None</span>

<span class="w"> </span>    def start_macro(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Start recording macro.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.is_recording:</span>
<span class="gi">+            self.current_recording = []</span>

<span class="w"> </span>    def end_macro(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;End recording macro.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.is_recording:</span>
<span class="gi">+            self.macro = self.current_recording</span>
<span class="gi">+            self.current_recording = None</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/key_bindings.py b/src/prompt_toolkit/key_binding/key_bindings.py</span>
<span class="gh">index 9d241939..b6c0d10e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/key_bindings.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/key_bindings.py</span>
<span class="gu">@@ -115,7 +115,10 @@ class KeyBindingsBase(metaclass=ABCMeta):</span>

<span class="w"> </span>        :param keys: tuple of keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def get():</span>
<span class="gi">+            return [b for b in self._bindings if b.keys[:len(keys)] == keys and len(b.keys) &gt; len(keys)]</span>
<span class="gi">+</span>
<span class="gi">+        return self._get_bindings_starting_with_keys_cache.get(keys, get)</span>

<span class="w"> </span>    @abstractproperty
<span class="w"> </span>    def bindings(self) -&gt;list[Binding]:
<span class="gu">@@ -182,7 +185,15 @@ class KeyBindings(KeyBindingsBase):</span>
<span class="w"> </span>        :param record_in_macro: Record these key bindings when a macro is
<span class="w"> </span>            being recorded. (True by default.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def decorator(func: T) -&gt; T:</span>
<span class="gi">+            if callable(func):</span>
<span class="gi">+                binding = Binding(keys, func, filter=filter, eager=eager,</span>
<span class="gi">+                                  is_global=is_global, save_before=save_before,</span>
<span class="gi">+                                  record_in_macro=record_in_macro)</span>
<span class="gi">+                self._bindings.append(binding)</span>
<span class="gi">+                self.__version += 1</span>
<span class="gi">+            return func</span>
<span class="gi">+        return decorator</span>

<span class="w"> </span>    def remove(self, *args: (Keys | str | KeyHandlerCallable)) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -198,7 +209,20 @@ class KeyBindings(KeyBindingsBase):</span>
<span class="w"> </span>            remove(handler)  # Pass handler.
<span class="w"> </span>            remove(&#39;c-x&#39;, &#39;c-a&#39;)  # Or pass the key bindings.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(args) == 1 and callable(args[0]):</span>
<span class="gi">+            handler = args[0]</span>
<span class="gi">+            bindings_to_remove = [b for b in self._bindings if b.handler == handler]</span>
<span class="gi">+        else:</span>
<span class="gi">+            keys = tuple(_parse_key(k) for k in args)</span>
<span class="gi">+            bindings_to_remove = [b for b in self._bindings if b.keys == keys]</span>
<span class="gi">+</span>
<span class="gi">+        if not bindings_to_remove:</span>
<span class="gi">+            raise ValueError(&quot;Binding not found&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for b in bindings_to_remove:</span>
<span class="gi">+            self._bindings.remove(b)</span>
<span class="gi">+        </span>
<span class="gi">+        self.__version += 1</span>
<span class="w"> </span>    add_binding = add
<span class="w"> </span>    remove_binding = remove

<span class="gu">@@ -210,7 +234,10 @@ class KeyBindings(KeyBindingsBase):</span>

<span class="w"> </span>        :param keys: tuple of keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def get():</span>
<span class="gi">+            return [b for b in self._bindings if b.keys == keys]</span>
<span class="gi">+</span>
<span class="gi">+        return self._get_bindings_for_keys_cache.get(keys, get)</span>

<span class="w"> </span>    def get_bindings_starting_with_keys(self, keys: KeysTuple) -&gt;list[Binding]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -228,7 +255,16 @@ def _parse_key(key: (Keys | str)) -&gt;(str | Keys):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Replace key by alias and verify whether it&#39;s a valid one.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(key, Keys):</span>
<span class="gi">+        return key</span>
<span class="gi">+    </span>
<span class="gi">+    if key in KEY_ALIASES:</span>
<span class="gi">+        return KEY_ALIASES[key]</span>
<span class="gi">+    </span>
<span class="gi">+    if len(key) == 1:</span>
<span class="gi">+        return key</span>
<span class="gi">+    </span>
<span class="gi">+    raise ValueError(f&quot;Invalid key: {key}&quot;)</span>


<span class="w"> </span>def key_binding(filter: FilterOrBool=True, eager: FilterOrBool=False,
<span class="gu">@@ -239,7 +275,17 @@ def key_binding(filter: FilterOrBool=True, eager: FilterOrBool=False,</span>
<span class="w"> </span>    Decorator that turn a function into a `Binding` object. This can be added
<span class="w"> </span>    to a `KeyBindings` object when a key binding is assigned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func: KeyHandlerCallable) -&gt; Binding:</span>
<span class="gi">+        return Binding(</span>
<span class="gi">+            keys=(),  # Empty tuple, as keys are not known at this point</span>
<span class="gi">+            handler=func,</span>
<span class="gi">+            filter=filter,</span>
<span class="gi">+            eager=eager,</span>
<span class="gi">+            is_global=is_global,</span>
<span class="gi">+            save_before=save_before,</span>
<span class="gi">+            record_in_macro=record_in_macro</span>
<span class="gi">+        )</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>class _Proxy(KeyBindingsBase):
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/key_processor.py b/src/prompt_toolkit/key_binding/key_processor.py</span>
<span class="gh">index 4104a4f6..586886d1 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/key_processor.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/key_processor.py</span>
<span class="gu">@@ -89,21 +89,49 @@ class KeyProcessor:</span>
<span class="w"> </span>        For a list of :class:`KeyPress` instances. Give the matching handlers
<span class="w"> </span>        that would handle this.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [b for b in self._bindings.get_bindings_for_keys(key_presses) if b.filter()]</span>

<span class="w"> </span>    def _is_prefix_of_longer_match(self, key_presses: list[KeyPress]) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For a list of :class:`KeyPress` instances. Return True if there is any
<span class="w"> </span>        handler that is bound to a suffix of this keys.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for b in self._bindings.get_bindings_starting_with_keys(key_presses):</span>
<span class="gi">+            if b.filter():</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def _process(self) -&gt;Generator[None, KeyPress, None]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Coroutine implementing the key match algorithm. Key strokes are sent
<span class="w"> </span>        into this generator, and it calls the appropriate handlers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        buffer: list[KeyPress] = []</span>
<span class="gi">+        retry = False</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if retry:</span>
<span class="gi">+                retry = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                key_press = yield</span>
<span class="gi">+</span>
<span class="gi">+            if key_press is _Flush:</span>
<span class="gi">+                self._flush(buffer)</span>
<span class="gi">+                buffer = []</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            buffer.append(key_press)</span>
<span class="gi">+</span>
<span class="gi">+            matches = self._get_matches(buffer)</span>
<span class="gi">+            if matches:</span>
<span class="gi">+                self._call_handler(matches[-1], key_sequence=buffer)</span>
<span class="gi">+                buffer = []</span>
<span class="gi">+            elif self._is_prefix_of_longer_match(buffer):</span>
<span class="gi">+                retry = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                retry = True</span>
<span class="gi">+                self._flush(buffer)</span>
<span class="gi">+                buffer = []</span>

<span class="w"> </span>    def feed(self, key_press: KeyPress, first: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -112,14 +140,20 @@ class KeyProcessor:</span>

<span class="w"> </span>        :param first: If true, insert before everything else.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if first:</span>
<span class="gi">+            self.input_queue.appendleft(key_press)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.input_queue.append(key_press)</span>

<span class="w"> </span>    def feed_multiple(self, key_presses: list[KeyPress], first: bool=False
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param first: If true, insert before everything else.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if first:</span>
<span class="gi">+            self.input_queue.extendleft(reversed(key_presses))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.input_queue.extend(key_presses)</span>

<span class="w"> </span>    def process_keys(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -130,13 +164,17 @@ class KeyProcessor:</span>
<span class="w"> </span>              possible to call `feed` from inside a key binding.
<span class="w"> </span>              This function keeps looping until the queue is empty.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while self.input_queue:</span>
<span class="gi">+            key_press = self.input_queue.popleft()</span>
<span class="gi">+            self._process().send(key_press)</span>

<span class="w"> </span>    def empty_queue(self) -&gt;list[KeyPress]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Empty the input queue. Return the unprocessed input.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key_presses = list(self.input_queue)</span>
<span class="gi">+        self.input_queue.clear()</span>
<span class="gi">+        return key_presses</span>

<span class="w"> </span>    def _fix_vi_cursor_position(self, event: KeyPressEvent) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -144,14 +182,23 @@ class KeyProcessor:</span>
<span class="w"> </span>        never put the cursor after the last character of a line. (Unless it&#39;s
<span class="w"> </span>        an empty line.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = event.app</span>
<span class="gi">+        buff = app.current_buffer</span>
<span class="gi">+        if (vi_navigation_mode() and buff.document.is_cursor_at_the_end_of_line</span>
<span class="gi">+            and len(buff.document.current_line) &gt; 0):</span>
<span class="gi">+            buff.cursor_position -= 1</span>

<span class="w"> </span>    def _leave_vi_temp_navigation_mode(self, event: KeyPressEvent) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        If we&#39;re in Vi temporary navigation (normal) mode, return to
<span class="w"> </span>        insert/replace mode after executing one action.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = event.app</span>
<span class="gi">+        if app.editing_mode == EditingMode.VI and not event.is_repeat:</span>
<span class="gi">+            vi_state = app.vi_state</span>
<span class="gi">+            if vi_state.temporary_navigation_mode:</span>
<span class="gi">+                vi_state.temporary_navigation_mode = False</span>
<span class="gi">+                app.vi_state.input_mode = vi_state.original_input_mode</span>

<span class="w"> </span>    def _start_timeout(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -161,13 +208,22 @@ class KeyProcessor:</span>
<span class="w"> </span>        and no key was pressed in the meantime, we flush all data in the queue
<span class="w"> </span>        and call the appropriate key binding handlers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        async def auto_flush() -&gt;None:</span>
<span class="gi">+            await sleep(self._timeout)</span>
<span class="gi">+            if self._flush_wait_task and not self._flush_wait_task.done():</span>
<span class="gi">+                self.feed(_Flush)</span>
<span class="gi">+                self.process_keys()</span>
<span class="gi">+</span>
<span class="gi">+        if self._timeout is not None:</span>
<span class="gi">+            self._flush_wait_task = get_app().create_background_task(auto_flush())</span>

<span class="w"> </span>    def send_sigint(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Send SIGINT. Immediately call the SIGINT key handler.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key_press = KeyPress(Keys.ControlC, &#39;\x03&#39;)</span>
<span class="gi">+        self.feed(key_press)</span>
<span class="gi">+        self.process_keys()</span>


<span class="w"> </span>class KeyPressEvent:
<span class="gu">@@ -200,28 +256,30 @@ class KeyPressEvent:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The current `Application` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._app</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_buffer(self) -&gt;Buffer:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The current buffer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._app.current_buffer</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def arg(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Repetition argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._arg:</span>
<span class="gi">+            return int(self._arg)</span>
<span class="gi">+        return 1</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def arg_present(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        True if repetition argument was explicitly provided.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._arg is not None</span>

<span class="w"> </span>    def append_to_arg_count(self, data: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -229,9 +287,11 @@ class KeyPressEvent:</span>

<span class="w"> </span>        :param data: the typed digit as string
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._arg is None:</span>
<span class="gi">+            self._arg = &#39;&#39;</span>
<span class="gi">+        self._arg += data</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def cli(self) -&gt;Application[Any]:
<span class="w"> </span>        &quot;&quot;&quot;For backward-compatibility.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.app</span>
<span class="gh">diff --git a/src/prompt_toolkit/key_binding/vi_state.py b/src/prompt_toolkit/key_binding/vi_state.py</span>
<span class="gh">index be95b80e..ce02f438 100644</span>
<span class="gd">--- a/src/prompt_toolkit/key_binding/vi_state.py</span>
<span class="gi">+++ b/src/prompt_toolkit/key_binding/vi_state.py</span>
<span class="gu">@@ -46,15 +46,25 @@ class ViState:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def input_mode(self) -&gt;InputMode:
<span class="w"> </span>        &quot;&quot;&quot;Get `InputMode`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__input_mode</span>

<span class="w"> </span>    @input_mode.setter
<span class="w"> </span>    def input_mode(self, value: InputMode) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set `InputMode`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__input_mode = value</span>

<span class="w"> </span>    def reset(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Reset state, go back to the given mode. INSERT by default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__input_mode = InputMode.INSERT</span>
<span class="gi">+        self.last_character_find = None</span>
<span class="gi">+        self.operator_func = None</span>
<span class="gi">+        self.operator_arg = None</span>
<span class="gi">+        self.named_registers = {}</span>
<span class="gi">+        self.waiting_for_digraph = False</span>
<span class="gi">+        self.digraph_symbol1 = None</span>
<span class="gi">+        self.tilde_operator = False</span>
<span class="gi">+        self.recording_register = None</span>
<span class="gi">+        self.current_recording = &#39;&#39;</span>
<span class="gi">+        self.temporary_navigation_mode = False</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/containers.py b/src/prompt_toolkit/layout/containers.py</span>
<span class="gh">index 52be90da..3b4500e8 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/containers.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/containers.py</span>
<span class="gu">@@ -117,7 +117,11 @@ AnyContainer = Union[Container, &#39;MagicContainer&#39;]</span>

<span class="w"> </span>def _window_too_small() -&gt;Window:
<span class="w"> </span>    &quot;&quot;&quot;Create a `Window` that displays the &#39;Window too small&#39; text.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Window(</span>
<span class="gi">+        FormattedTextControl(text=&#39;Window too small...&#39;),</span>
<span class="gi">+        style=&#39;class:window-too-small&#39;,</span>
<span class="gi">+        align=WindowAlign.CENTER</span>
<span class="gi">+    )</span>


<span class="w"> </span>class VerticalAlign(Enum):
<span class="gu">@@ -216,7 +220,16 @@ class HSplit(_Split):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        List of child objects, including padding.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def create_padding():</span>
<span class="gi">+            return Window(width=self.padding, char=self.padding_char, style=self.padding_style)</span>
<span class="gi">+</span>
<span class="gi">+        children = []</span>
<span class="gi">+        for i, c in enumerate(self.children):</span>
<span class="gi">+            if i != 0:</span>
<span class="gi">+                children.append(create_padding())</span>
<span class="gi">+            children.append(c)</span>
<span class="gi">+</span>
<span class="gi">+        return children</span>

<span class="w"> </span>    def write_to_screen(self, screen: Screen, mouse_handlers: MouseHandlers,
<span class="w"> </span>        write_position: WritePosition, parent_style: str, erase_bg: bool,
<span class="gu">@@ -235,7 +248,18 @@ class HSplit(_Split):</span>
<span class="w"> </span>        Return the heights for all rows.
<span class="w"> </span>        Or None when there is not enough space.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.height is not None:</span>
<span class="gi">+            height = to_dimension(self.height).preferred(write_position.height)</span>
<span class="gi">+        else:</span>
<span class="gi">+            height = write_position.height</span>
<span class="gi">+</span>
<span class="gi">+        children = self._all_children</span>
<span class="gi">+        dimensions = [c.preferred_height(write_position.width, height) for c in children]</span>
<span class="gi">+</span>
<span class="gi">+        if self.align == VerticalAlign.JUSTIFY:</span>
<span class="gi">+            return distribute_weights(dimensions, height)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return sum_layout_dimensions(dimensions)</span>


<span class="w"> </span>class VSplit(_Split):
<span class="gu">@@ -293,14 +317,29 @@ class VSplit(_Split):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        List of child objects, including padding.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def create_padding():</span>
<span class="gi">+            return Window(height=self.padding, char=self.padding_char, style=self.padding_style)</span>
<span class="gi">+</span>
<span class="gi">+        children = []</span>
<span class="gi">+        for i, c in enumerate(self.children):</span>
<span class="gi">+            if i != 0:</span>
<span class="gi">+                children.append(create_padding())</span>
<span class="gi">+            children.append(c)</span>
<span class="gi">+</span>
<span class="gi">+        return children</span>

<span class="w"> </span>    def _divide_widths(self, width: int) -&gt;(list[int] | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the widths for all columns.
<span class="w"> </span>        Or None when there is not enough space.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        children = self._all_children</span>
<span class="gi">+        dimensions = [c.preferred_width(width) for c in children]</span>
<span class="gi">+</span>
<span class="gi">+        if self.align == HorizontalAlign.JUSTIFY:</span>
<span class="gi">+            return distribute_weights(dimensions, width)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return sum_layout_dimensions(dimensions)</span>

<span class="w"> </span>    def write_to_screen(self, screen: Screen, mouse_handlers: MouseHandlers,
<span class="w"> </span>        write_position: WritePosition, parent_style: str, erase_bg: bool,
<span class="gu">@@ -915,21 +954,33 @@ class DynamicContainer(Container):</span>
<span class="w"> </span>        We call `to_container`, because `get_container` can also return a
<span class="w"> </span>        widget with a ``__pt_container__`` method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return to_container(self.get_container())</span>


<span class="w"> </span>def to_container(container: AnyContainer) -&gt;Container:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Make sure that the given object is a :class:`.Container`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(container, Container):</span>
<span class="gi">+        return container</span>
<span class="gi">+    elif hasattr(container, &#39;__pt_container__&#39;):</span>
<span class="gi">+        return to_container(container.__pt_container__())</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&#39;Not a container object: %r&#39; % (container,))</span>


<span class="w"> </span>def to_window(container: AnyContainer) -&gt;Window:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Make sure that the given argument is a :class:`.Window`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(container, Window):</span>
<span class="gi">+        return container</span>
<span class="gi">+    else:</span>
<span class="gi">+        container = to_container(container)</span>
<span class="gi">+        if isinstance(container, Window):</span>
<span class="gi">+            return container</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;Not a Window object: %r&#39; % (container,))</span>


<span class="w"> </span>def is_container(value: object) -&gt;TypeGuard[AnyContainer]:
<span class="gu">@@ -937,4 +988,4 @@ def is_container(value: object) -&gt;TypeGuard[AnyContainer]:</span>
<span class="w"> </span>    Checks whether the given value is a container object
<span class="w"> </span>    (for use in assert statements).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(value, Container) or hasattr(value, &#39;__pt_container__&#39;)</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/controls.py b/src/prompt_toolkit/layout/controls.py</span>
<span class="gh">index d76f0c21..c5fd5626 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/controls.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/controls.py</span>
<span class="gu">@@ -134,7 +134,25 @@ class UIContent:</span>
<span class="w"> </span>            when line wrapping.
<span class="w"> </span>        :returns: The computed height.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Create a unique key for caching</span>
<span class="gi">+        key = (lineno, width, get_line_prefix, slice_stop)</span>
<span class="gi">+        </span>
<span class="gi">+        if key not in self._line_heights_cache:</span>
<span class="gi">+            fragments = self.get_line(lineno)</span>
<span class="gi">+            </span>
<span class="gi">+            # Apply line prefix if provided</span>
<span class="gi">+            if get_line_prefix:</span>
<span class="gi">+                fragments = to_formatted_text(get_line_prefix(lineno, 0)) + fragments</span>
<span class="gi">+            </span>
<span class="gi">+            # Apply slice if provided</span>
<span class="gi">+            if slice_stop is not None:</span>
<span class="gi">+                fragments = fragments[:slice_stop]</span>
<span class="gi">+            </span>
<span class="gi">+            # Calculate the height</span>
<span class="gi">+            text = fragment_list_to_text(fragments)</span>
<span class="gi">+            self._line_heights_cache[key] = (len(text) - 1) // width + 1</span>
<span class="gi">+        </span>
<span class="gi">+        return self._line_heights_cache[key]</span>


<span class="w"> </span>class FormattedTextControl(UIControl):
<span class="gu">@@ -206,14 +224,27 @@ class FormattedTextControl(UIControl):</span>
<span class="w"> </span>        (This function is called several times during one rendering, because
<span class="w"> </span>        we also need those for calculating the dimensions.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Use SimpleCache to store the fragments</span>
<span class="gi">+        key = (self.text, get_app().render_counter)</span>
<span class="gi">+        </span>
<span class="gi">+        def get_formatted_text() -&gt;StyleAndTextTuples:</span>
<span class="gi">+            result = to_formatted_text(self.text, style=self.style)</span>
<span class="gi">+            self._fragments = result</span>
<span class="gi">+            return result</span>
<span class="gi">+        </span>
<span class="gi">+        return self._fragment_cache.get(key, get_formatted_text)</span>

<span class="w"> </span>    def preferred_width(self, max_available_width: int) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the preferred width for this control.
<span class="w"> </span>        That is the width of the longest line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fragments = self._get_formatted_text_cached()</span>
<span class="gi">+        text = fragment_list_to_text(fragments)</span>
<span class="gi">+        lines = text.splitlines()</span>
<span class="gi">+        if not lines:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        return max(get_cwidth(line) for line in lines)</span>

<span class="w"> </span>    def preferred_height(self, width: int, max_available_height: int,
<span class="w"> </span>        wrap_lines: bool, get_line_prefix: (GetLinePrefixCallable | None)) -&gt;(
<span class="gu">@@ -221,7 +252,27 @@ class FormattedTextControl(UIControl):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the preferred height for this control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fragments = self._get_formatted_text_cached()</span>
<span class="gi">+        </span>
<span class="gi">+        # If wrapping is disabled, return the number of lines</span>
<span class="gi">+        if not wrap_lines:</span>
<span class="gi">+            return len(split_lines(fragments))</span>
<span class="gi">+        </span>
<span class="gi">+        # If wrapping is enabled, calculate the wrapped height</span>
<span class="gi">+        height = 0</span>
<span class="gi">+        for line in split_lines(fragments):</span>
<span class="gi">+            # Apply line prefix if provided</span>
<span class="gi">+            if get_line_prefix:</span>
<span class="gi">+                line = to_formatted_text(get_line_prefix(height, 0)) + line</span>
<span class="gi">+            </span>
<span class="gi">+            # Calculate the height for this line</span>
<span class="gi">+            line_text = fragment_list_to_text(line)</span>
<span class="gi">+            height += (len(line_text) - 1) // width + 1</span>
<span class="gi">+            </span>
<span class="gi">+            if height &gt;= max_available_height:</span>
<span class="gi">+                return max_available_height</span>
<span class="gi">+        </span>
<span class="gi">+        return height</span>

<span class="w"> </span>    def mouse_handler(self, mouse_event: MouseEvent) -&gt;NotImplementedOrNone:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -233,7 +284,22 @@ class FormattedTextControl(UIControl):</span>
<span class="w"> </span>        :class:`~prompt_toolkit.layout.Window` to handle this particular
<span class="w"> </span>        event.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fragments = self._get_formatted_text_cached()</span>
<span class="gi">+        x = mouse_event.position.x</span>
<span class="gi">+        y = mouse_event.position.y</span>
<span class="gi">+        </span>
<span class="gi">+        # Find the fragment at the given position</span>
<span class="gi">+        for style, text, handler in fragments:</span>
<span class="gi">+            if y == 0 and x &lt; len(text):</span>
<span class="gi">+                if handler is not None:</span>
<span class="gi">+                    return handler(get_app(), mouse_event)</span>
<span class="gi">+                return NotImplemented</span>
<span class="gi">+            x -= len(text)</span>
<span class="gi">+            if x &lt; 0:</span>
<span class="gi">+                y -= 1</span>
<span class="gi">+                x = 9999</span>
<span class="gi">+        </span>
<span class="gi">+        return NotImplemented</span>


<span class="w"> </span>class DummyControl(UIControl):
<span class="gh">diff --git a/src/prompt_toolkit/layout/dimension.py b/src/prompt_toolkit/layout/dimension.py</span>
<span class="gh">index 27439360..d9e5b4ef 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/dimension.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/dimension.py</span>
<span class="gu">@@ -64,7 +64,7 @@ class Dimension:</span>
<span class="w"> </span>        Return a :class:`.Dimension` with an exact size. (min, max and
<span class="w"> </span>        preferred set to ``amount``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(min=amount, max=amount, preferred=amount)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def zero(cls) -&gt;Dimension:
<span class="gu">@@ -72,11 +72,11 @@ class Dimension:</span>
<span class="w"> </span>        Create a dimension that represents a zero size. (Used for &#39;invisible&#39;
<span class="w"> </span>        controls.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(min=0, max=0, preferred=0)</span>

<span class="w"> </span>    def is_zero(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;True if this `Dimension` represents a zero size.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.max == 0</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        fields = []
<span class="gu">@@ -95,7 +95,12 @@ def sum_layout_dimensions(dimensions: list[Dimension]) -&gt;Dimension:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Sum a list of :class:`.Dimension` instances.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    min_sum = sum(d.min for d in dimensions)</span>
<span class="gi">+    max_sum = sum(d.max for d in dimensions)</span>
<span class="gi">+    preferred_sum = sum(d.preferred for d in dimensions)</span>
<span class="gi">+    weight_sum = sum(d.weight for d in dimensions)</span>
<span class="gi">+    </span>
<span class="gi">+    return Dimension(min=min_sum, max=max_sum, preferred=preferred_sum, weight=weight_sum)</span>


<span class="w"> </span>def max_layout_dimensions(dimensions: list[Dimension]) -&gt;Dimension:
<span class="gu">@@ -103,7 +108,15 @@ def max_layout_dimensions(dimensions: list[Dimension]) -&gt;Dimension:</span>
<span class="w"> </span>    Take the maximum of a list of :class:`.Dimension` instances.
<span class="w"> </span>    Used when we have a HSplit/VSplit, and we want to get the best width/height.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not dimensions:</span>
<span class="gi">+        return Dimension.zero()</span>
<span class="gi">+    </span>
<span class="gi">+    return Dimension(</span>
<span class="gi">+        min=max(d.min for d in dimensions),</span>
<span class="gi">+        max=max(d.max for d in dimensions),</span>
<span class="gi">+        preferred=max(d.preferred for d in dimensions),</span>
<span class="gi">+        weight=max(d.weight for d in dimensions)</span>
<span class="gi">+    )</span>


<span class="w"> </span>AnyDimension = Union[None, int, Dimension, Callable[[], Any]]
<span class="gu">@@ -113,7 +126,15 @@ def to_dimension(value: AnyDimension) -&gt;Dimension:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Turn the given object into a `Dimension` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return Dimension()</span>
<span class="gi">+    if isinstance(value, int):</span>
<span class="gi">+        return Dimension.exact(value)</span>
<span class="gi">+    if isinstance(value, Dimension):</span>
<span class="gi">+        return value</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        return to_dimension(value())</span>
<span class="gi">+    raise ValueError(f&quot;Cannot convert {value} to Dimension&quot;)</span>


<span class="w"> </span>def is_dimension(value: object) -&gt;TypeGuard[AnyDimension]:
<span class="gu">@@ -121,7 +142,7 @@ def is_dimension(value: object) -&gt;TypeGuard[AnyDimension]:</span>
<span class="w"> </span>    Test whether the given value could be a valid dimension.
<span class="w"> </span>    (For usage in an assertion. It&#39;s not guaranteed in case of a callable.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value is None or isinstance(value, (int, Dimension)) or callable(value)</span>


<span class="w"> </span>D = Dimension
<span class="gh">diff --git a/src/prompt_toolkit/layout/dummy.py b/src/prompt_toolkit/layout/dummy.py</span>
<span class="gh">index 5c47d1f0..3169a74e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/dummy.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/dummy.py</span>
<span class="gu">@@ -19,4 +19,25 @@ def create_dummy_layout() -&gt;Layout:</span>
<span class="w"> </span>    Create a dummy layout for use in an &#39;Application&#39; that doesn&#39;t have a
<span class="w"> </span>    layout specified. When ENTER is pressed, the application quits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;enter&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot; Quit when enter is pressed. &quot;</span>
<span class="gi">+        event.app.exit()</span>
<span class="gi">+</span>
<span class="gi">+    dummy_text = HTML(</span>
<span class="gi">+        &#39;&lt;style bg=&quot;ansiblack&quot; fg=&quot;ansiwhite&quot;&gt;&#39;</span>
<span class="gi">+        &#39;This is a dummy layout. &#39;</span>
<span class="gi">+        &#39;You did not provide a layout to your Application.\n&#39;</span>
<span class="gi">+        &#39;Press ENTER to quit.&#39;</span>
<span class="gi">+        &#39;&lt;/style&gt;&#39;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    window = Window(</span>
<span class="gi">+        FormattedTextControl(dummy_text),</span>
<span class="gi">+        height=D(min=1),</span>
<span class="gi">+        key_bindings=kb,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return Layout(window)</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/layout.py b/src/prompt_toolkit/layout/layout.py</span>
<span class="gh">index e6a57ed0..b06d61a1 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/layout.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/layout.py</span>
<span class="gu">@@ -47,7 +47,9 @@ class Layout:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find all the :class:`.UIControl` objects in this layout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for item in self.walk():</span>
<span class="gi">+            if isinstance(item, Window):</span>
<span class="gi">+                yield item</span>

<span class="w"> </span>    def focus(self, value: FocusableElement) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -62,77 +64,114 @@ class Layout:</span>
<span class="w"> </span>          from this container that was focused most recent, or the very first
<span class="w"> </span>          focusable :class:`.Window` of the container.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(value, UIControl):</span>
<span class="gi">+            for window in self.find_all_windows():</span>
<span class="gi">+                if window.content == value:</span>
<span class="gi">+                    self.current_window = window</span>
<span class="gi">+                    return</span>
<span class="gi">+        elif isinstance(value, Buffer):</span>
<span class="gi">+            for window in self.find_all_windows():</span>
<span class="gi">+                if isinstance(window.content, BufferControl) and window.content.buffer == value:</span>
<span class="gi">+                    self.current_window = window</span>
<span class="gi">+                    return</span>
<span class="gi">+        elif isinstance(value, str):</span>
<span class="gi">+            for window in self.find_all_windows():</span>
<span class="gi">+                if isinstance(window.content, BufferControl) and window.content.buffer.name == value:</span>
<span class="gi">+                    self.current_window = window</span>
<span class="gi">+                    return</span>
<span class="gi">+        elif isinstance(value, Window):</span>
<span class="gi">+            self.current_window = value</span>
<span class="gi">+        elif isinstance(value, Container):</span>
<span class="gi">+            for window in self.find_all_windows():</span>
<span class="gi">+                if window in value.get_children():</span>
<span class="gi">+                    self.current_window = window</span>
<span class="gi">+                    return</span>

<span class="w"> </span>    def has_focus(self, value: FocusableElement) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Check whether the given control has the focus.
<span class="w"> </span>        :param value: :class:`.UIControl` or :class:`.Window` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(value, UIControl):</span>
<span class="gi">+            return self.current_control == value</span>
<span class="gi">+        elif isinstance(value, Window):</span>
<span class="gi">+            return self.current_window == value</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_control(self) -&gt;UIControl:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the :class:`.UIControl` to currently has the focus.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.current_window.content</span>

<span class="w"> </span>    @current_control.setter
<span class="w"> </span>    def current_control(self, control: UIControl) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set the :class:`.UIControl` to receive the focus.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.focus(control)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_window(self) -&gt;Window:
<span class="w"> </span>        &quot;&quot;&quot;Return the :class:`.Window` object that is currently focused.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._stack[-1] if self._stack else None</span>

<span class="w"> </span>    @current_window.setter
<span class="w"> </span>    def current_window(self, value: Window) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set the :class:`.Window` object to be currently focused.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if value not in self._stack:</span>
<span class="gi">+            self._stack.append(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._stack.remove(value)</span>
<span class="gi">+            self._stack.append(value)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def is_searching(self) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;True if we are searching right now.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return any(isinstance(c, SearchBufferControl) for c in self.search_links)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def search_target_buffer_control(self) -&gt;(BufferControl | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the :class:`.BufferControl` in which we are searching or `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for search_control, buffer_control in self.search_links.items():</span>
<span class="gi">+            if self.has_focus(search_control):</span>
<span class="gi">+                return buffer_control</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_focusable_windows(self) -&gt;Iterable[Window]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return all the :class:`.Window` objects which are focusable (in the
<span class="w"> </span>        &#39;modal&#39; area).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (w for w in self.walk_through_modal_area() if isinstance(w, Window) and w.content.is_focusable())</span>

<span class="w"> </span>    def get_visible_focusable_windows(self) -&gt;list[Window]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of :class:`.Window` objects that are focusable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [w for w in self.get_focusable_windows() if w.filter()]</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def current_buffer(self) -&gt;(Buffer | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The currently focused :class:`~.Buffer` or `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(self.current_control, BufferControl):</span>
<span class="gi">+            return self.current_control.buffer</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_buffer_by_name(self, buffer_name: str) -&gt;(Buffer | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Look in the layout for a buffer with the given name.
<span class="w"> </span>        Return `None` when nothing was found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for window in self.find_all_windows():</span>
<span class="gi">+            if isinstance(window.content, BufferControl) and window.content.buffer.name == buffer_name:</span>
<span class="gi">+                return window.content.buffer</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def buffer_has_focus(self) -&gt;bool:
<span class="gu">@@ -141,32 +180,49 @@ class Layout:</span>
<span class="w"> </span>        :class:`.BufferControl`. (For instance, used to determine whether the
<span class="w"> </span>        default key bindings should be active or not.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return isinstance(self.current_control, BufferControl)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def previous_control(self) -&gt;UIControl:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the :class:`.UIControl` to previously had the focus.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._stack[-2].content if len(self._stack) &gt; 1 else None</span>

<span class="w"> </span>    def focus_last(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Give the focus to the last focused control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(self._stack) &gt; 1:</span>
<span class="gi">+            self._stack.pop()</span>

<span class="w"> </span>    def focus_next(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Focus the next visible/focusable Window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        windows = self.get_visible_focusable_windows()</span>
<span class="gi">+        if not windows:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            index = windows.index(self.current_window)</span>
<span class="gi">+            self.focus(windows[(index + 1) % len(windows)])</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            # If the current window is not in the list, focus the first one</span>
<span class="gi">+            self.focus(windows[0])</span>

<span class="w"> </span>    def focus_previous(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Focus the previous visible/focusable Window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        windows = self.get_visible_focusable_windows()</span>
<span class="gi">+        if not windows:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            index = windows.index(self.current_window)</span>
<span class="gi">+            self.focus(windows[(index - 1) % len(windows)])</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            # If the current window is not in the list, focus the last one</span>
<span class="gi">+            self.focus(windows[-1])</span>

<span class="w"> </span>    def walk(self) -&gt;Iterable[Container]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -203,4 +259,11 @@ def walk(container: Container, skip_hidden: bool=False) -&gt;Iterable[Container]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Walk through layout, starting at this container.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def walk_recursive(cont):</span>
<span class="gi">+        yield cont</span>
<span class="gi">+        if hasattr(cont, &#39;get_children&#39;):</span>
<span class="gi">+            for child in cont.get_children():</span>
<span class="gi">+                if not skip_hidden or not isinstance(child, ConditionalContainer) or child.filter():</span>
<span class="gi">+                    yield from walk_recursive(child)</span>
<span class="gi">+</span>
<span class="gi">+    yield from walk_recursive(container)</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/margins.py b/src/prompt_toolkit/layout/margins.py</span>
<span class="gh">index 221ae7c0..32cf5fbe 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/margins.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/margins.py</span>
<span class="gu">@@ -120,4 +120,30 @@ class PromptMargin(Margin):</span>

<span class="w"> </span>    def get_width(self, get_ui_content: Callable[[], UIContent]) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Width to report to the `Window`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Get the prompt text</span>
<span class="gi">+        prompt_text = fragment_list_to_text(to_formatted_text(self.get_prompt()))</span>
<span class="gi">+        </span>
<span class="gi">+        # Calculate the width of the prompt</span>
<span class="gi">+        prompt_width = get_cwidth(prompt_text)</span>
<span class="gi">+        </span>
<span class="gi">+        # If there&#39;s a continuation function, calculate its maximum width</span>
<span class="gi">+        if self.get_continuation:</span>
<span class="gi">+            ui_content = get_ui_content()</span>
<span class="gi">+            line_count = ui_content.line_count</span>
<span class="gi">+            </span>
<span class="gi">+            # Check width for each line (excluding the first line)</span>
<span class="gi">+            continuation_widths = [</span>
<span class="gi">+                get_cwidth(fragment_list_to_text(to_formatted_text(</span>
<span class="gi">+                    self.get_continuation(prompt_width, i, False)</span>
<span class="gi">+                )))</span>
<span class="gi">+                for i in range(1, line_count)</span>
<span class="gi">+            ]</span>
<span class="gi">+            </span>
<span class="gi">+            # Get the maximum width of continuation lines</span>
<span class="gi">+            max_continuation_width = max(continuation_widths) if continuation_widths else 0</span>
<span class="gi">+            </span>
<span class="gi">+            # Return the maximum of prompt width and continuation width</span>
<span class="gi">+            return max(prompt_width, max_continuation_width)</span>
<span class="gi">+        </span>
<span class="gi">+        # If there&#39;s no continuation function, just return the prompt width</span>
<span class="gi">+        return prompt_width</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/menus.py b/src/prompt_toolkit/layout/menus.py</span>
<span class="gh">index 8231f28b..b419bc0f 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/menus.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/menus.py</span>
<span class="gu">@@ -38,33 +38,81 @@ class CompletionsMenuControl(UIControl):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a UIContent object for this control.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state is None:</span>
<span class="gi">+            return UIContent()</span>
<span class="gi">+</span>
<span class="gi">+        completions = complete_state.completions</span>
<span class="gi">+        index = complete_state.complete_index  # Can be None!</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate width of completions menu.</span>
<span class="gi">+        menu_width = self._get_menu_width(width, complete_state)</span>
<span class="gi">+        menu_meta_width = self._get_menu_meta_width(width, complete_state)</span>
<span class="gi">+        show_meta = self._show_meta(complete_state)</span>
<span class="gi">+</span>
<span class="gi">+        def get_line(i):</span>
<span class="gi">+            c = completions[i]</span>
<span class="gi">+            is_current_completion = (i == index)</span>
<span class="gi">+            result = _get_menu_item_fragments(c, is_current_completion, menu_width, space_after=show_meta)</span>
<span class="gi">+</span>
<span class="gi">+            if show_meta:</span>
<span class="gi">+                result += _get_menu_item_fragments(c.display_meta, is_current_completion, menu_meta_width)</span>
<span class="gi">+</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        return UIContent(get_line=get_line,</span>
<span class="gi">+                         cursor_position=Point(x=0, y=index or 0),</span>
<span class="gi">+                         line_count=len(completions))</span>

<span class="w"> </span>    def _show_meta(self, complete_state: CompletionState) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return ``True`` if we need to show a column with meta information.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return any(c.display_meta for c in complete_state.completions)</span>

<span class="w"> </span>    def _get_menu_width(self, max_width: int, complete_state: CompletionState
<span class="w"> </span>        ) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the width of the main column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return min(max_width, max(self.MIN_WIDTH, max(get_cwidth(c.display) for c in complete_state.completions) + 2))</span>

<span class="w"> </span>    def _get_menu_meta_width(self, max_width: int, complete_state:
<span class="w"> </span>        CompletionState) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the width of the meta column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._show_meta(complete_state):</span>
<span class="gi">+            return min(max_width // 2, max(get_cwidth(c.display_meta) for c in complete_state.completions if c.display_meta))</span>
<span class="gi">+        return 0</span>

<span class="w"> </span>    def mouse_handler(self, mouse_event: MouseEvent) -&gt;NotImplementedOrNone:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handle mouse events: clicking and scrolling.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        b = get_app().current_buffer</span>
<span class="gi">+        complete_state = b.complete_state</span>
<span class="gi">+</span>
<span class="gi">+        if complete_state is None:</span>
<span class="gi">+            return NotImplemented</span>
<span class="gi">+</span>
<span class="gi">+        # Mouse click</span>
<span class="gi">+        if mouse_event.event_type == MouseEventType.MOUSE_UP:</span>
<span class="gi">+            index = mouse_event.position.y</span>
<span class="gi">+</span>
<span class="gi">+            if 0 &lt;= index &lt; len(complete_state.completions):</span>
<span class="gi">+                b.apply_completion(complete_state.completions[index])</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        # Scroll up/down</span>
<span class="gi">+        if mouse_event.event_type == MouseEventType.SCROLL_DOWN:</span>
<span class="gi">+            b.complete_next()</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif mouse_event.event_type == MouseEventType.SCROLL_UP:</span>
<span class="gi">+            b.complete_previous()</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return NotImplemented</span>


<span class="w"> </span>def _get_menu_item_fragments(completion: Completion, is_current_completion:
<span class="gu">@@ -73,7 +121,24 @@ def _get_menu_item_fragments(completion: Completion, is_current_completion:</span>
<span class="w"> </span>    Get the style/text tuples for a menu item, styled and trimmed to the given
<span class="w"> </span>    width.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    style = &#39;class:completion-menu.completion&#39;</span>
<span class="gi">+    if is_current_completion:</span>
<span class="gi">+        style += &#39;.current&#39;</span>
<span class="gi">+</span>
<span class="gi">+    text = completion.display</span>
<span class="gi">+    text, text_width = _trim_formatted_text([(style, text)], width)</span>
<span class="gi">+</span>
<span class="gi">+    padding = width - text_width</span>
<span class="gi">+    if space_after:</span>
<span class="gi">+        padding -= 1</span>
<span class="gi">+</span>
<span class="gi">+    if padding &gt; 0:</span>
<span class="gi">+        text.append((style, &#39; &#39; * padding))</span>
<span class="gi">+</span>
<span class="gi">+    if space_after:</span>
<span class="gi">+        text.append((style, &#39; &#39;))</span>
<span class="gi">+</span>
<span class="gi">+    return text</span>


<span class="w"> </span>def _trim_formatted_text(formatted_text: StyleAndTextTuples, max_width: int
<span class="gu">@@ -82,7 +147,21 @@ def _trim_formatted_text(formatted_text: StyleAndTextTuples, max_width: int</span>
<span class="w"> </span>    Trim the text to `max_width`, append dots when the text is too long.
<span class="w"> </span>    Returns (text, width) tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result: StyleAndTextTuples = []</span>
<span class="gi">+    current_width = 0</span>
<span class="gi">+</span>
<span class="gi">+    for style, text in formatted_text:</span>
<span class="gi">+        for c in text:</span>
<span class="gi">+            char_width = get_cwidth(c)</span>
<span class="gi">+            if current_width + char_width &gt; max_width:</span>
<span class="gi">+                result.append((style, &#39;...&#39;))</span>
<span class="gi">+                current_width += 3</span>
<span class="gi">+                return result, current_width</span>
<span class="gi">+</span>
<span class="gi">+            result.append((style, c))</span>
<span class="gi">+            current_width += char_width</span>
<span class="gi">+</span>
<span class="gi">+    return result, current_width</span>


<span class="w"> </span>class CompletionsMenu(ConditionalContainer):
<span class="gu">@@ -146,7 +225,20 @@ class MultiColumnCompletionMenuControl(UIControl):</span>
<span class="w"> </span>        Preferred width: prefer to use at least min_rows, but otherwise as much
<span class="w"> </span>        as possible horizontally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state is None:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        column_width = self._get_column_width(complete_state)</span>
<span class="gi">+        max_columns = max(1, (max_available_width - self._required_margin) // column_width)</span>
<span class="gi">+</span>
<span class="gi">+        return min(</span>
<span class="gi">+            max_available_width,</span>
<span class="gi">+            max(</span>
<span class="gi">+                self._required_margin + column_width,</span>
<span class="gi">+                column_width * max_columns + self._required_margin</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def preferred_height(self, width: int, max_available_height: int,
<span class="w"> </span>        wrap_lines: bool, get_line_prefix: (GetLinePrefixCallable | None)) -&gt;(
<span class="gu">@@ -154,32 +246,122 @@ class MultiColumnCompletionMenuControl(UIControl):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Preferred height: as much as needed in order to display all the completions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state is None:</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        column_width = self._get_column_width(complete_state)</span>
<span class="gi">+        column_count = max(1, (width - self._required_margin) // column_width)</span>
<span class="gi">+        row_count = int(math.ceil(len(complete_state.completions) / float(column_count)))</span>
<span class="gi">+        return max(self.min_rows, min(row_count, max_available_height))</span>

<span class="w"> </span>    def create_content(self, width: int, height: int) -&gt;UIContent:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a UIContent object for this menu.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state is None:</span>
<span class="gi">+            return UIContent()</span>
<span class="gi">+</span>
<span class="gi">+        column_width = self._get_column_width(complete_state)</span>
<span class="gi">+        self._render_pos_to_completion = {}</span>
<span class="gi">+        self._render_left_arrow = False</span>
<span class="gi">+        self._render_right_arrow = False</span>
<span class="gi">+        self._render_width = width</span>
<span class="gi">+</span>
<span class="gi">+        visible_columns = max(1, (width - self._required_margin) // column_width)</span>
<span class="gi">+        visible_rows = height</span>
<span class="gi">+</span>
<span class="gi">+        columns = []</span>
<span class="gi">+        for i in range(visible_columns):</span>
<span class="gi">+            col_start = i * visible_rows - self.scroll</span>
<span class="gi">+            col_end = (i + 1) * visible_rows - self.scroll</span>
<span class="gi">+            columns.append(complete_state.completions[col_start:col_end])</span>
<span class="gi">+</span>
<span class="gi">+        def get_line(y):</span>
<span class="gi">+            result = []</span>
<span class="gi">+            for x, column in enumerate(columns):</span>
<span class="gi">+                if y &lt; len(column):</span>
<span class="gi">+                    completion = column[y]</span>
<span class="gi">+                    style = &#39;class:completion-menu.completion&#39;</span>
<span class="gi">+                    if complete_state.complete_index == self.scroll + x * visible_rows + y:</span>
<span class="gi">+                        style += &#39;.current&#39;</span>
<span class="gi">+                    result.extend(_get_menu_item_fragments(completion, False, column_width - 1, True))</span>
<span class="gi">+                    self._render_pos_to_completion[x, y] = completion</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result.append((&#39;&#39;, &#39; &#39; * column_width))</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        self._rendered_rows = visible_rows</span>
<span class="gi">+        self._rendered_columns = visible_columns</span>
<span class="gi">+        self._total_columns = int(math.ceil(len(complete_state.completions) / float(visible_rows)))</span>
<span class="gi">+</span>
<span class="gi">+        # Show left/right arrows (for scrolling) if there are more completions than visible.</span>
<span class="gi">+        if self.scroll &gt; 0:</span>
<span class="gi">+            self._render_left_arrow = True</span>
<span class="gi">+        if self.scroll &lt; (self._total_columns - visible_columns) * visible_rows:</span>
<span class="gi">+            self._render_right_arrow = True</span>
<span class="gi">+</span>
<span class="gi">+        return UIContent(get_line=get_line,</span>
<span class="gi">+                         line_count=visible_rows,</span>
<span class="gi">+                         show_cursor=False)</span>

<span class="w"> </span>    def _get_column_width(self, completion_state: CompletionState) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the width of each column.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if completion_state in self._column_width_for_completion_state:</span>
<span class="gi">+            return self._column_width_for_completion_state[completion_state][0]</span>
<span class="gi">+</span>
<span class="gi">+        max_width = max(get_cwidth(c.display) for c in completion_state.completions)</span>
<span class="gi">+        result = max(self.suggested_max_column_width, max_width)</span>
<span class="gi">+        self._column_width_for_completion_state[completion_state] = (result, max_width)</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def mouse_handler(self, mouse_event: MouseEvent) -&gt;NotImplementedOrNone:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Handle scroll and click events.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mouse_event.event_type == MouseEventType.SCROLL_DOWN:</span>
<span class="gi">+            self.scroll += self._rendered_rows</span>
<span class="gi">+            self.scroll = min(self.scroll, (self._total_columns - self._rendered_columns) * self._rendered_rows)</span>
<span class="gi">+        elif mouse_event.event_type == MouseEventType.SCROLL_UP:</span>
<span class="gi">+            self.scroll -= self._rendered_rows</span>
<span class="gi">+            self.scroll = max(0, self.scroll)</span>
<span class="gi">+        elif mouse_event.event_type == MouseEventType.MOUSE_UP:</span>
<span class="gi">+            x = mouse_event.position.x</span>
<span class="gi">+            y = mouse_event.position.y</span>
<span class="gi">+</span>
<span class="gi">+            if x == 0 and self._render_left_arrow:</span>
<span class="gi">+                self.scroll -= self._rendered_rows</span>
<span class="gi">+                self.scroll = max(0, self.scroll)</span>
<span class="gi">+            elif x == self._render_width - 1 and self._render_right_arrow:</span>
<span class="gi">+                self.scroll += self._rendered_rows</span>
<span class="gi">+                self.scroll = min(self.scroll, (self._total_columns - self._rendered_columns) * self._rendered_rows)</span>
<span class="gi">+            elif (x, y) in self._render_pos_to_completion:</span>
<span class="gi">+                completion = self._render_pos_to_completion[x, y]</span>
<span class="gi">+                get_app().current_buffer.apply_completion(completion)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_key_bindings(self) -&gt;KeyBindings:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Expose key bindings that handle the left/right arrow keys when the menu
<span class="w"> </span>        is displayed.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&#39;left&#39;, filter=~has_completions)</span>
<span class="gi">+        def _(event):</span>
<span class="gi">+            self.scroll -= self._rendered_rows</span>
<span class="gi">+            self.scroll = max(0, self.scroll)</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&#39;right&#39;, filter=~has_completions)</span>
<span class="gi">+        def _(event):</span>
<span class="gi">+            self.scroll += self._rendered_rows</span>
<span class="gi">+            self.scroll = min(self.scroll, (self._total_columns - self._rendered_columns) * self._rendered_rows)</span>
<span class="gi">+</span>
<span class="gi">+        return kb</span>


<span class="w"> </span>class MultiColumnCompletionsMenu(HSplit):
<span class="gu">@@ -224,4 +406,9 @@ class _SelectedCompletionMetaControl(UIControl):</span>
<span class="w"> </span>        layout doesn&#39;t change when we select another completion (E.g. that
<span class="w"> </span>        completions are suddenly shown in more or fewer columns.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        complete_state = get_app().current_buffer.complete_state</span>
<span class="gi">+        if complete_state is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        max_meta_width = max(get_cwidth(c.display_meta) for c in complete_state.completions if c.display_meta)</span>
<span class="gi">+        return min(max_meta_width, max_available_width)</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/mouse_handlers.py b/src/prompt_toolkit/layout/mouse_handlers.py</span>
<span class="gh">index 52c54dc6..0539ef1e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/mouse_handlers.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/mouse_handlers.py</span>
<span class="gu">@@ -29,4 +29,6 @@ class MouseHandlers:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set mouse handler for a region.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for x in range(x_min, x_max + 1):</span>
<span class="gi">+            for y in range(y_min, y_max + 1):</span>
<span class="gi">+                self.mouse_handlers[x][y] = handler</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/processors.py b/src/prompt_toolkit/layout/processors.py</span>
<span class="gh">index 71fc93e2..3c0fe8ba 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/processors.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/processors.py</span>
<span class="gu">@@ -119,7 +119,8 @@ class HighlightSearchProcessor(Processor):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The text we are searching for.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        search_state = buffer_control.search_state</span>
<span class="gi">+        return search_state.text if search_state else &#39;&#39;</span>


<span class="w"> </span>class HighlightIncrementalSearchProcessor(HighlightSearchProcessor):
<span class="gu">@@ -138,7 +139,8 @@ class HighlightIncrementalSearchProcessor(HighlightSearchProcessor):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The text we are searching for.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        search_state = buffer_control.search_state</span>
<span class="gi">+        return search_state.text if search_state and search_state.isearch_state else &#39;&#39;</span>


<span class="w"> </span>class HighlightSelectionProcessor(Processor):
<span class="gu">@@ -183,7 +185,44 @@ class HighlightMatchingBracketProcessor(Processor):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a list of (row, col) tuples that need to be highlighted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cursor_row, cursor_col = document.translate_index_to_position(</span>
<span class="gi">+            document.cursor_position)</span>
<span class="gi">+        </span>
<span class="gi">+        def find_matching_bracket(pos, direction):</span>
<span class="gi">+            stack = []</span>
<span class="gi">+            for i in range(pos, 0 if direction &lt; 0 else len(document.text), direction):</span>
<span class="gi">+                char = document.text[i]</span>
<span class="gi">+                if char in self.chars:</span>
<span class="gi">+                    if not stack and char in self._closing_braces:</span>
<span class="gi">+                        return i</span>
<span class="gi">+                    if self.chars.index(char) % 2 == 0:</span>
<span class="gi">+                        stack.append(char)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if stack and self.chars.index(stack[-1]) == self.chars.index(char) - 1:</span>
<span class="gi">+                            stack.pop()</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            return i</span>
<span class="gi">+                    if not stack:</span>
<span class="gi">+                        return i</span>
<span class="gi">+            return -1</span>
<span class="gi">+</span>
<span class="gi">+        result = []</span>
<span class="gi">+        cursor_char = document.text[document.cursor_position] if document.cursor_position &lt; len(document.text) else &#39;&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        if cursor_char in self.chars:</span>
<span class="gi">+            pos = document.cursor_position</span>
<span class="gi">+        elif document.cursor_position &gt; 0 and document.text[document.cursor_position - 1] in self.chars:</span>
<span class="gi">+            pos = document.cursor_position - 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        if abs(pos - document.cursor_position) &lt;= self.max_cursor_distance:</span>
<span class="gi">+            matching_pos = find_matching_bracket(pos, 1 if self.chars.index(document.text[pos]) % 2 == 0 else -1)</span>
<span class="gi">+            if matching_pos != -1:</span>
<span class="gi">+                result.append(document.translate_index_to_position(pos))</span>
<span class="gi">+                result.append(document.translate_index_to_position(matching_pos))</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class DisplayMultipleCursors(Processor):
<span class="gu">@@ -367,7 +406,7 @@ def merge_processors(processors: list[Processor]) -&gt;Processor:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge multiple `Processor` objects into one.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _MergedProcessor(processors)</span>


<span class="w"> </span>class _MergedProcessor(Processor):
<span class="gh">diff --git a/src/prompt_toolkit/layout/screen.py b/src/prompt_toolkit/layout/screen.py</span>
<span class="gh">index 29cbf2a9..9550258d 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/screen.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/screen.py</span>
<span class="gu">@@ -87,27 +87,27 @@ class Screen:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set the cursor position for a given window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cursor_positions[window] = position</span>

<span class="w"> </span>    def set_menu_position(self, window: Window, position: Point) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set the cursor position for a given window.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.menu_positions[window] = position</span>

<span class="w"> </span>    def get_cursor_position(self, window: Window) -&gt;Point:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the cursor position for a given window.
<span class="w"> </span>        Returns a `Point`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.cursor_positions.get(window, Point(0, 0))</span>

<span class="w"> </span>    def get_menu_position(self, window: Window) -&gt;Point:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the menu position for a given window.
<span class="w"> </span>        (This falls back to the cursor position if no menu position was set.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.menu_positions.get(window, self.get_cursor_position(window))</span>

<span class="w"> </span>    def draw_with_z_index(self, z_index: int, draw_func: Callable[[], None]
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -115,20 +115,24 @@ class Screen:</span>
<span class="w"> </span>        Add a draw-function for a `Window` which has a &gt;= 0 z_index.
<span class="w"> </span>        This will be postponed until `draw_all_floats` is called.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._draw_float_functions.append((z_index, draw_func))</span>

<span class="w"> </span>    def draw_all_floats(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Draw all float functions in order of z-index.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _, draw_func in sorted(self._draw_float_functions):</span>
<span class="gi">+            draw_func()</span>
<span class="gi">+        self._draw_float_functions.clear()</span>

<span class="w"> </span>    def append_style_to_content(self, style_str: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        For all the characters in the screen.
<span class="w"> </span>        Set the style string to the given `style_str`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for row in self.data_buffer.values():</span>
<span class="gi">+            for col, char in row.items():</span>
<span class="gi">+                row[col] = _CHAR_CACHE[char.char, char.style + &#39; &#39; + style_str]</span>

<span class="w"> </span>    def fill_area(self, write_position: WritePosition, style: str=&#39;&#39;, after:
<span class="w"> </span>        bool=False) -&gt;None:
<span class="gu">@@ -136,7 +140,12 @@ class Screen:</span>
<span class="w"> </span>        Fill the content of this area, using the given `style`.
<span class="w"> </span>        The style is prepended before whatever was here before.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for y in range(write_position.ypos, write_position.ypos + write_position.height):</span>
<span class="gi">+            row = self.data_buffer[y]</span>
<span class="gi">+            for x in range(write_position.xpos, write_position.xpos + write_position.width):</span>
<span class="gi">+                char = row[x]</span>
<span class="gi">+                new_style = style + &#39; &#39; + char.style if after else char.style + &#39; &#39; + style</span>
<span class="gi">+                row[x] = _CHAR_CACHE[char.char, new_style.strip()]</span>


<span class="w"> </span>class WritePosition:
<span class="gh">diff --git a/src/prompt_toolkit/layout/scrollable_pane.py b/src/prompt_toolkit/layout/scrollable_pane.py</span>
<span class="gh">index 22c7047e..f948f1a0 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/scrollable_pane.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/scrollable_pane.py</span>
<span class="gu">@@ -77,21 +77,82 @@ class ScrollablePane(Container):</span>
<span class="w"> </span>        This works by rendering on an off-screen canvas, and copying over the
<span class="w"> </span>        visible region.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Calculate dimensions</span>
<span class="gi">+        xpos = write_position.xpos</span>
<span class="gi">+        ypos = write_position.ypos</span>
<span class="gi">+        width = write_position.width</span>
<span class="gi">+        height = write_position.height</span>
<span class="gi">+</span>
<span class="gi">+        # Create a temporary screen for rendering the full content</span>
<span class="gi">+        temp_screen = Screen(self.max_available_height, width)</span>
<span class="gi">+        temp_mouse_handlers = MouseHandlers()</span>
<span class="gi">+</span>
<span class="gi">+        # Render content on the temporary screen</span>
<span class="gi">+        self.content.write_to_screen(</span>
<span class="gi">+            temp_screen,</span>
<span class="gi">+            temp_mouse_handlers,</span>
<span class="gi">+            WritePosition(xpos=0, ypos=0, width=width, height=self.max_available_height),</span>
<span class="gi">+            parent_style,</span>
<span class="gi">+            erase_bg,</span>
<span class="gi">+            z_index</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate the visible region</span>
<span class="gi">+        visible_height = min(height, temp_screen.height - self.vertical_scroll)</span>
<span class="gi">+        </span>
<span class="gi">+        # Copy visible region to the actual screen</span>
<span class="gi">+        self._copy_over_screen(screen, temp_screen, write_position, width)</span>
<span class="gi">+        self._copy_over_mouse_handlers(mouse_handlers, temp_mouse_handlers, write_position, width)</span>
<span class="gi">+        self._copy_over_write_positions(screen, temp_screen, write_position)</span>
<span class="gi">+</span>
<span class="gi">+        # Draw scrollbar if needed</span>
<span class="gi">+        if self.show_scrollbar() and temp_screen.height &gt; height:</span>
<span class="gi">+            self._draw_scrollbar(write_position, temp_screen.height, screen)</span>
<span class="gi">+</span>
<span class="gi">+        # Make focused window visible if needed</span>
<span class="gi">+        if self.keep_focused_window_visible():</span>
<span class="gi">+            focused_windows = [</span>
<span class="gi">+                w for w in temp_screen.visible_windows</span>
<span class="gi">+                if w.render_info and w.render_info.get_visible_line_to_row_col</span>
<span class="gi">+            ]</span>
<span class="gi">+            if focused_windows:</span>
<span class="gi">+                focused_window = focused_windows[-1]</span>
<span class="gi">+                cursor_position = focused_window.render_info.cursor_position</span>
<span class="gi">+                self._make_window_visible(visible_height, temp_screen.height,</span>
<span class="gi">+                                          focused_window.render_info.window_write_position,</span>
<span class="gi">+                                          cursor_position)</span>

<span class="w"> </span>    def _clip_point_to_visible_area(self, point: Point, write_position:
<span class="w"> </span>        WritePosition) -&gt;Point:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Ensure that the cursor and menu positions always are always reported
<span class="gi">+        within the visible area.</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        x = point.x</span>
<span class="gi">+        y = point.y - self.vertical_scroll</span>
<span class="gi">+</span>
<span class="gi">+        x = max(0, min(x, write_position.width - 1))</span>
<span class="gi">+        y = max(0, min(y, write_position.height - 1))</span>
<span class="gi">+</span>
<span class="gi">+        return Point(x=x, y=y)</span>

<span class="w"> </span>    def _copy_over_screen(self, screen: Screen, temp_screen: Screen,
<span class="w"> </span>        write_position: WritePosition, virtual_width: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy over visible screen content and &quot;zero width escape sequences&quot;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for y in range(min(write_position.height, temp_screen.height - self.vertical_scroll)):</span>
<span class="gi">+            for x in range(min(write_position.width, virtual_width)):</span>
<span class="gi">+                temp_char = temp_screen.data_buffer[self.vertical_scroll + y][x]</span>
<span class="gi">+                screen.data_buffer[write_position.ypos + y][write_position.xpos + x] = temp_char</span>
<span class="gi">+</span>
<span class="gi">+        # Copy over zero width escape sequences</span>
<span class="gi">+        for y in range(min(write_position.height, temp_screen.height - self.vertical_scroll)):</span>
<span class="gi">+            row = self.vertical_scroll + y</span>
<span class="gi">+            if row in temp_screen.zero_width_escapes:</span>
<span class="gi">+                for x, escapes in temp_screen.zero_width_escapes[row].items():</span>
<span class="gi">+                    if x &lt; virtual_width:</span>
<span class="gi">+                        screen.zero_width_escapes[write_position.ypos + y][write_position.xpos + x] = escapes</span>

<span class="w"> </span>    def _copy_over_mouse_handlers(self, mouse_handlers: MouseHandlers,
<span class="w"> </span>        temp_mouse_handlers: MouseHandlers, write_position: WritePosition,
<span class="gu">@@ -102,14 +163,36 @@ class ScrollablePane(Container):</span>
<span class="w"> </span>        Note: we take `virtual_width` because we don&#39;t want to copy over mouse
<span class="w"> </span>              handlers that we possibly have behind the scrollbar.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for y in range(min(write_position.height, self.max_available_height - self.vertical_scroll)):</span>
<span class="gi">+            for x in range(min(write_position.width, virtual_width)):</span>
<span class="gi">+                key = (self.vertical_scroll + y, x)</span>
<span class="gi">+                if key in temp_mouse_handlers.mouse_handlers:</span>
<span class="gi">+                    mouse_handlers.set_mouse_handler_for_region(</span>
<span class="gi">+                        x=write_position.xpos + x,</span>
<span class="gi">+                        y=write_position.ypos + y,</span>
<span class="gi">+                        width=1,</span>
<span class="gi">+                        height=1,</span>
<span class="gi">+                        handler=temp_mouse_handlers.mouse_handlers[key]</span>
<span class="gi">+                    )</span>

<span class="w"> </span>    def _copy_over_write_positions(self, screen: Screen, temp_screen:
<span class="w"> </span>        Screen, write_position: WritePosition) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy over window write positions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for window, positions in temp_screen.write_positions.items():</span>
<span class="gi">+            new_positions = []</span>
<span class="gi">+            for position in positions:</span>
<span class="gi">+                new_ypos = position.ypos - self.vertical_scroll + write_position.ypos</span>
<span class="gi">+                if write_position.ypos &lt;= new_ypos &lt; write_position.ypos + write_position.height:</span>
<span class="gi">+                    new_positions.append(WritePosition(</span>
<span class="gi">+                        xpos=position.xpos + write_position.xpos,</span>
<span class="gi">+                        ypos=new_ypos,</span>
<span class="gi">+                        width=min(position.width, write_position.width),</span>
<span class="gi">+                        height=min(position.height, write_position.ypos + write_position.height - new_ypos)</span>
<span class="gi">+                    ))</span>
<span class="gi">+            if new_positions:</span>
<span class="gi">+                screen.write_positions[window] = new_positions</span>

<span class="w"> </span>    def _make_window_visible(self, visible_height: int, virtual_height: int,
<span class="w"> </span>        visible_win_write_pos: WritePosition, cursor_position: (Point | None)
<span class="gu">@@ -124,7 +207,31 @@ class ScrollablePane(Container):</span>
<span class="w"> </span>        :param cursor_position: The location of the cursor position of this
<span class="w"> </span>            window on the temp screen.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cursor_position is not None:</span>
<span class="gi">+            cursor_y = cursor_position.y</span>
<span class="gi">+        else:</span>
<span class="gi">+            cursor_y = visible_win_write_pos.ypos</span>
<span class="gi">+</span>
<span class="gi">+        def scroll_to(scroll_offset):</span>
<span class="gi">+            self.vertical_scroll = max(0, min(scroll_offset, virtual_height - visible_height))</span>
<span class="gi">+</span>
<span class="gi">+        if self.keep_cursor_visible():</span>
<span class="gi">+            # Scroll up if needed</span>
<span class="gi">+            if cursor_y &lt; self.vertical_scroll + self.scroll_offsets.top:</span>
<span class="gi">+                scroll_to(cursor_y - self.scroll_offsets.top)</span>
<span class="gi">+</span>
<span class="gi">+            # Scroll down if needed</span>
<span class="gi">+            elif cursor_y &gt;= self.vertical_scroll + visible_height - self.scroll_offsets.bottom:</span>
<span class="gi">+                scroll_to(cursor_y - visible_height + 1 + self.scroll_offsets.bottom)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Scroll up if needed</span>
<span class="gi">+            if visible_win_write_pos.ypos &lt; self.vertical_scroll:</span>
<span class="gi">+                scroll_to(visible_win_write_pos.ypos)</span>
<span class="gi">+</span>
<span class="gi">+            # Scroll down if needed</span>
<span class="gi">+            elif visible_win_write_pos.ypos + visible_win_write_pos.height &gt; self.vertical_scroll + visible_height:</span>
<span class="gi">+                scroll_to(visible_win_write_pos.ypos + visible_win_write_pos.height - visible_height)</span>

<span class="w"> </span>    def _draw_scrollbar(self, write_position: WritePosition, content_height:
<span class="w"> </span>        int, screen: Screen) -&gt;None:
<span class="gu">@@ -134,4 +241,25 @@ class ScrollablePane(Container):</span>
<span class="w"> </span>        Note: There is some code duplication with the `ScrollbarMargin`
<span class="w"> </span>              implementation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        window_height = write_position.height</span>
<span class="gi">+        scrollbar_height = max(1, int(window_height * window_height / content_height))</span>
<span class="gi">+        scrollbar_top = int(self.vertical_scroll * window_height / content_height)</span>
<span class="gi">+</span>
<span class="gi">+        x = write_position.xpos + write_position.width - 1</span>
<span class="gi">+        y = write_position.ypos</span>
<span class="gi">+</span>
<span class="gi">+        # Draw scrollbar background</span>
<span class="gi">+        for i in range(window_height):</span>
<span class="gi">+            screen.data_buffer[y + i][x] = Char(&#39; &#39;, &#39;class:scrollbar.background&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Draw scrollbar itself</span>
<span class="gi">+        for i in range(scrollbar_height):</span>
<span class="gi">+            if 0 &lt;= y + scrollbar_top + i &lt; y + window_height:</span>
<span class="gi">+                screen.data_buffer[y + scrollbar_top + i][x] = Char(&#39; &#39;, &#39;class:scrollbar&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Draw arrows</span>
<span class="gi">+        if self.display_arrows():</span>
<span class="gi">+            if self.vertical_scroll &gt; 0:</span>
<span class="gi">+                screen.data_buffer[y][x] = Char(self.up_arrow_symbol, &#39;class:scrollbar.arrow&#39;)</span>
<span class="gi">+            if self.vertical_scroll + window_height &lt; content_height:</span>
<span class="gi">+                screen.data_buffer[y + window_height - 1][x] = Char(self.down_arrow_symbol, &#39;class:scrollbar.arrow&#39;)</span>
<span class="gh">diff --git a/src/prompt_toolkit/layout/utils.py b/src/prompt_toolkit/layout/utils.py</span>
<span class="gh">index b4df4dc7..3d19c4e6 100644</span>
<span class="gd">--- a/src/prompt_toolkit/layout/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/layout/utils.py</span>
<span class="gu">@@ -48,4 +48,13 @@ def explode_text_fragments(fragments: Iterable[_T]) -&gt;_ExplodedList[_T]:</span>

<span class="w"> </span>    :param fragments: List of (style, text) tuples.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = _ExplodedList()</span>
<span class="gi">+</span>
<span class="gi">+    for style, text in fragments:</span>
<span class="gi">+        if isinstance(text, str):</span>
<span class="gi">+            result.extend((style, c) for c in text)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If it&#39;s not a string, we assume it&#39;s already exploded</span>
<span class="gi">+            result.append((style, text))</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/src/prompt_toolkit/lexers/base.py b/src/prompt_toolkit/lexers/base.py</span>
<span class="gh">index a6b501bd..1d2d718d 100644</span>
<span class="gd">--- a/src/prompt_toolkit/lexers/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/lexers/base.py</span>
<span class="gu">@@ -32,7 +32,7 @@ class Lexer(metaclass=ABCMeta):</span>
<span class="w"> </span>        When this changes, `lex_document` could give a different output.
<span class="w"> </span>        (Only used for `DynamicLexer`.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class SimpleLexer(Lexer):
<span class="gu">@@ -46,6 +46,15 @@ class SimpleLexer(Lexer):</span>
<span class="w"> </span>    def __init__(self, style: str=&#39;&#39;) -&gt;None:
<span class="w"> </span>        self.style = style

<span class="gi">+    def lex_document(self, document: Document) -&gt;Callable[[int],</span>
<span class="gi">+        StyleAndTextTuples]:</span>
<span class="gi">+        def get_line(lineno: int) -&gt;StyleAndTextTuples:</span>
<span class="gi">+            return [(self.style, document.lines[lineno])]</span>
<span class="gi">+        return get_line</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt;Hashable:</span>
<span class="gi">+        return self.style</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicLexer(Lexer):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -57,3 +66,14 @@ class DynamicLexer(Lexer):</span>
<span class="w"> </span>    def __init__(self, get_lexer: Callable[[], Lexer | None]) -&gt;None:
<span class="w"> </span>        self.get_lexer = get_lexer
<span class="w"> </span>        self._dummy = SimpleLexer()
<span class="gi">+</span>
<span class="gi">+    def lex_document(self, document: Document) -&gt;Callable[[int],</span>
<span class="gi">+        StyleAndTextTuples]:</span>
<span class="gi">+        lexer = self.get_lexer() or self._dummy</span>
<span class="gi">+        return lexer.lex_document(document)</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt;Hashable:</span>
<span class="gi">+        lexer = self.get_lexer()</span>
<span class="gi">+        if lexer:</span>
<span class="gi">+            return lexer.invalidation_hash()</span>
<span class="gi">+        return self._dummy.invalidation_hash()</span>
<span class="gh">diff --git a/src/prompt_toolkit/lexers/pygments.py b/src/prompt_toolkit/lexers/pygments.py</span>
<span class="gh">index 79f8caa1..d1e1bd58 100644</span>
<span class="gd">--- a/src/prompt_toolkit/lexers/pygments.py</span>
<span class="gi">+++ b/src/prompt_toolkit/lexers/pygments.py</span>
<span class="gu">@@ -62,14 +62,27 @@ class RegexSync(SyntaxSync):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Scan backwards, and find a possible position to start.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Start from the requested line and move backwards</span>
<span class="gi">+        for i in range(max(0, lineno - 1), max(-1, lineno - self.MAX_BACKWARDS), -1):</span>
<span class="gi">+            match = self._compiled_pattern.search(document.lines[i])</span>
<span class="gi">+            if match:</span>
<span class="gi">+                return i, match.start()</span>
<span class="gi">+        </span>
<span class="gi">+        # If no match found, start from the beginning if the document is small</span>
<span class="gi">+        if lineno &lt;= self.FROM_START_IF_NO_SYNC_POS_FOUND:</span>
<span class="gi">+            return 0, 0</span>
<span class="gi">+        </span>
<span class="gi">+        # Otherwise, start a bit before the requested line</span>
<span class="gi">+        return max(0, lineno - self.MAX_BACKWARDS), 0</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_pygments_lexer_cls(cls, lexer_cls: PygmentsLexerCls) -&gt;RegexSync:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a :class:`.RegexSync` instance for this Pygments lexer class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        patterns = getattr(lexer_cls, &#39;flags&#39;, []) + getattr(lexer_cls, &#39;tokens&#39;, {}).get(&#39;root&#39;, [])</span>
<span class="gi">+        needle = &#39;|&#39;.join(f&#39;({p[1].pattern})&#39; for p in patterns if isinstance(p, tuple) and hasattr(p[1], &#39;pattern&#39;))</span>
<span class="gi">+        return cls(needle)</span>


<span class="w"> </span>class _TokenCache(Dict[Tuple[str, ...], str]):
<span class="gu">@@ -132,7 +145,13 @@ class PygmentsLexer(Lexer):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create a `Lexer` from a filename.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from pygments.lexers import get_lexer_for_filename</span>
<span class="gi">+        try:</span>
<span class="gi">+            pygments_lexer = get_lexer_for_filename(filename)</span>
<span class="gi">+        except ClassNotFound:</span>
<span class="gi">+            return SimpleLexer()</span>
<span class="gi">+        </span>
<span class="gi">+        return cls(pygments_lexer.__class__, sync_from_start=sync_from_start)</span>

<span class="w"> </span>    def lex_document(self, document: Document) -&gt;Callable[[int],
<span class="w"> </span>        StyleAndTextTuples]:
<span class="gu">@@ -140,4 +159,40 @@ class PygmentsLexer(Lexer):</span>
<span class="w"> </span>        Create a lexer function that takes a line number and returns the list
<span class="w"> </span>        of (style_str, text) tuples as the Pygments lexer returns for that line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.sync_from_start():</span>
<span class="gi">+            return self._lex_from_start(document)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._lex_from_closest_sync(document)</span>
<span class="gi">+</span>
<span class="gi">+    def _lex_from_start(self, document: Document) -&gt;Callable[[int],</span>
<span class="gi">+        StyleAndTextTuples]:</span>
<span class="gi">+        lines = document.lines</span>
<span class="gi">+        pygments_lexer = self.pygments_lexer</span>
<span class="gi">+        </span>
<span class="gi">+        def get_line(lineno: int) -&gt;StyleAndTextTuples:</span>
<span class="gi">+            return list(pygments_lexer.get_tokens(lines[lineno]))</span>
<span class="gi">+        </span>
<span class="gi">+        return get_line</span>
<span class="gi">+</span>
<span class="gi">+    def _lex_from_closest_sync(self, document: Document) -&gt;Callable[[int],</span>
<span class="gi">+        StyleAndTextTuples]:</span>
<span class="gi">+        lines = document.lines</span>
<span class="gi">+        pygments_lexer = self.pygments_lexer</span>
<span class="gi">+        </span>
<span class="gi">+        def get_line(lineno: int) -&gt;StyleAndTextTuples:</span>
<span class="gi">+            # Find the start position for the lexer</span>
<span class="gi">+            row, column = self.syntax_sync.get_sync_start_position(document, lineno)</span>
<span class="gi">+            </span>
<span class="gi">+            # Create a generator for the lexed tokens</span>
<span class="gi">+            text = &#39;\n&#39;.join(lines[row:lineno + 1])</span>
<span class="gi">+            tokens = pygments_lexer.get_tokens(text)</span>
<span class="gi">+            </span>
<span class="gi">+            # Ignore tokens for previous lines</span>
<span class="gi">+            for _ in range(lineno - row):</span>
<span class="gi">+                for _ in tokens:</span>
<span class="gi">+                    pass</span>
<span class="gi">+            </span>
<span class="gi">+            # Return the tokens for the requested line</span>
<span class="gi">+            return list(tokens)</span>
<span class="gi">+        </span>
<span class="gi">+        return get_line</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/base.py b/src/prompt_toolkit/output/base.py</span>
<span class="gh">index 8c4343ff..2ca27e5e 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/base.py</span>
<span class="gu">@@ -25,7 +25,9 @@ class Output(metaclass=ABCMeta):</span>
<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def fileno(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Return the file descriptor to which we can write for the output.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.stdout is not None:</span>
<span class="gi">+            return self.stdout.fileno()</span>
<span class="gi">+        raise NotImplementedError(&quot;fileno() not implemented for this output&quot;)</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def encoding(self) -&gt;str:
<span class="gu">@@ -35,7 +37,9 @@ class Output(metaclass=ABCMeta):</span>
<span class="w"> </span>        output the data, so that the UI can provide alternatives, when
<span class="w"> </span>        required.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.stdout is not None:</span>
<span class="gi">+            return self.stdout.encoding or &#39;utf-8&#39;</span>
<span class="gi">+        return &#39;utf-8&#39;</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def write(self, data: str) -&gt;None:
<span class="gu">@@ -191,7 +195,7 @@ class Output(metaclass=ABCMeta):</span>
<span class="w"> </span>        On Windows, we don&#39;t need this, there we have
<span class="w"> </span>        `get_rows_below_cursor_position`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False  # Default implementation returns False</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def get_size(self) -&gt;Size:
<span class="gu">@@ -253,4 +257,4 @@ class DummyOutput(Output):</span>

<span class="w"> </span>    def fileno(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;There is no sensible default for fileno().&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(&quot;DummyOutput does not have a file descriptor&quot;)</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/color_depth.py b/src/prompt_toolkit/output/color_depth.py</span>
<span class="gh">index 079d6e36..59f274de 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/color_depth.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/color_depth.py</span>
<span class="gu">@@ -27,11 +27,24 @@ class ColorDepth(str, Enum):</span>
<span class="w"> </span>        This is a way to enforce a certain color depth in all prompt_toolkit
<span class="w"> </span>        applications.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        env_value = os.environ.get(&#39;PROMPT_TOOLKIT_COLOR_DEPTH&#39;)</span>
<span class="gi">+        if env_value:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return cls(env_value)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                # If the value is not a valid ColorDepth, return None</span>
<span class="gi">+                return None</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def default(cls) -&gt;ColorDepth:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the default color depth for the default output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # First, check if there&#39;s an environment variable set</span>
<span class="gi">+        from_env = cls.from_env()</span>
<span class="gi">+        if from_env is not None:</span>
<span class="gi">+            return from_env</span>
<span class="gi">+</span>
<span class="gi">+        # If no environment variable is set, return the DEFAULT value</span>
<span class="gi">+        return cls.DEFAULT</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/defaults.py b/src/prompt_toolkit/output/defaults.py</span>
<span class="gh">index 396c16f3..c293f03c 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/defaults.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/defaults.py</span>
<span class="gu">@@ -24,4 +24,34 @@ def create_output(stdout: (TextIO | None)=None, always_prefer_tty: bool=False</span>
<span class="w"> </span>        That way, tools like `print_formatted_text` will write plain text into
<span class="w"> </span>        that file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if stdout is None:</span>
<span class="gi">+        stdout = sys.stdout</span>
<span class="gi">+</span>
<span class="gi">+    # Check if the output is a TTY.</span>
<span class="gi">+    if not stdout.isatty() and always_prefer_tty:</span>
<span class="gi">+        stdout = sys.stderr</span>
<span class="gi">+</span>
<span class="gi">+    if not stdout.isatty():</span>
<span class="gi">+        return PlainTextOutput(stdout)</span>
<span class="gi">+</span>
<span class="gi">+    term = get_term_environment_variable()</span>
<span class="gi">+    bell_variable = get_bell_environment_variable()</span>
<span class="gi">+</span>
<span class="gi">+    # If the PROMPT_TOOLKIT_COLOR_DEPTH environment variable is set, use that.</span>
<span class="gi">+    color_depth = ColorDepth.default()</span>
<span class="gi">+</span>
<span class="gi">+    if is_conemu_ansi():</span>
<span class="gi">+        from .conemu import ConEmuOutput</span>
<span class="gi">+        return ConEmuOutput(stdout)</span>
<span class="gi">+</span>
<span class="gi">+    if term in (&#39;linux&#39;, &#39;eterm-color&#39;):</span>
<span class="gi">+        from .vt100 import Vt100_Output</span>
<span class="gi">+        return Vt100_Output(stdout, color_depth=color_depth)</span>
<span class="gi">+</span>
<span class="gi">+    if term == &#39;windows&#39;:</span>
<span class="gi">+        from .win32 import Win32Output</span>
<span class="gi">+        return Win32Output(stdout, bell_variable=bell_variable)</span>
<span class="gi">+</span>
<span class="gi">+    # Default to VT100 output.</span>
<span class="gi">+    from .vt100 import Vt100_Output</span>
<span class="gi">+    return Vt100_Output(stdout, color_depth=color_depth)</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/flush_stdout.py b/src/prompt_toolkit/output/flush_stdout.py</span>
<span class="gh">index 5a1f98e9..d4f6c4ef 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/flush_stdout.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/flush_stdout.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>import errno
<span class="gi">+import fcntl</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from contextlib import contextmanager
<span class="gu">@@ -12,4 +13,13 @@ def _blocking_io(io: IO[str]) -&gt;Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Ensure that the FD for `io` is set to blocking in here.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fd = io.fileno()</span>
<span class="gi">+    old_flags = fcntl.fcntl(fd, fcntl.F_GETFL)</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        # Remove non-blocking flag</span>
<span class="gi">+        fcntl.fcntl(fd, fcntl.F_SETFL, old_flags &amp; ~os.O_NONBLOCK)</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # Restore original flags</span>
<span class="gi">+        fcntl.fcntl(fd, fcntl.F_SETFL, old_flags)</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/plain_text.py b/src/prompt_toolkit/output/plain_text.py</span>
<span class="gh">index 59ecf92e..46cdda73 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/plain_text.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/plain_text.py</span>
<span class="gu">@@ -27,5 +27,11 @@ class PlainTextOutput(Output):</span>
<span class="w"> </span>        self._buffer: list[str] = []

<span class="w"> </span>    def fileno(self) -&gt;int:
<span class="gd">-        &quot;&quot;&quot;There is no sensible default for fileno().&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Return the file descriptor of the stdout stream.</span>
<span class="gi">+        </span>
<span class="gi">+        If stdout doesn&#39;t have a file descriptor, raise an AttributeError.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if hasattr(self.stdout, &#39;fileno&#39;):</span>
<span class="gi">+            return self.stdout.fileno()</span>
<span class="gi">+        raise AttributeError(&quot;The stdout stream does not have a file descriptor.&quot;)</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/vt100.py b/src/prompt_toolkit/output/vt100.py</span>
<span class="gh">index d371a044..bc553357 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/vt100.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/vt100.py</span>
<span class="gu">@@ -52,7 +52,12 @@ def _get_closest_ansi_color(r: int, g: int, b: int, exclude: Sequence[str]=()</span>
<span class="w"> </span>    :param b: Blue (Between 0 and 255.)
<span class="w"> </span>    :param exclude: A tuple of color names to exclude. (E.g. ``(&#39;ansired&#39;, )``.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def distance(color):</span>
<span class="gi">+        r2, g2, b2 = ANSI_COLORS_TO_RGB[color]</span>
<span class="gi">+        return (r - r2) ** 2 + (g - g2) ** 2 + (b - b2) ** 2</span>
<span class="gi">+</span>
<span class="gi">+    colors = set(ANSI_COLORS_TO_RGB.keys()) - set(exclude)</span>
<span class="gi">+    return min(colors, key=distance)</span>


<span class="w"> </span>_ColorCodeAndName = Tuple[int, str]
<span class="gu">@@ -75,7 +80,20 @@ class _16ColorCache:</span>
<span class="w"> </span>        Return a (ansi_code, ansi_name) tuple. (E.g. ``(44, &#39;ansiblue&#39;)``.) for
<span class="w"> </span>        a given (r,g,b) value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        r, g, b = value</span>
<span class="gi">+</span>
<span class="gi">+        # If it&#39;s in the cache, return it</span>
<span class="gi">+        cache_key = (r, g, b, tuple(exclude))</span>
<span class="gi">+        if cache_key in self._cache:</span>
<span class="gi">+            return self._cache[cache_key]</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise, find the closest match</span>
<span class="gi">+        color_name = _get_closest_ansi_color(r, g, b, exclude)</span>
<span class="gi">+        color_code = (BG_ANSI_COLORS if self.bg else FG_ANSI_COLORS)[color_name]</span>
<span class="gi">+</span>
<span class="gi">+        result = (color_code, color_name)</span>
<span class="gi">+        self._cache[cache_key] = result</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class _256ColorCache(Dict[Tuple[int, int, int], int]):
<span class="gu">@@ -171,13 +189,41 @@ class _EscapeCodeCache(Dict[Attrs, str]):</span>

<span class="w"> </span>    def _color_name_to_rgb(self, color: str) -&gt;tuple[int, int, int]:
<span class="w"> </span>        &quot;&quot;&quot;Turn &#39;ffffff&#39;, into (0xff, 0xff, 0xff).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if color in ANSI_COLORS_TO_RGB:</span>
<span class="gi">+            return ANSI_COLORS_TO_RGB[color]</span>
<span class="gi">+        else:</span>
<span class="gi">+            r = int(color[0:2], 16)</span>
<span class="gi">+            g = int(color[2:4], 16)</span>
<span class="gi">+            b = int(color[4:6], 16)</span>
<span class="gi">+            return (r, g, b)</span>

<span class="w"> </span>    def _colors_to_code(self, fg_color: str, bg_color: str) -&gt;Iterable[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return a tuple with the vt100 values  that represent this color.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+</span>
<span class="gi">+        def color_to_code(color: str, fg: bool) -&gt;str:</span>
<span class="gi">+            table = FG_ANSI_COLORS if fg else BG_ANSI_COLORS</span>
<span class="gi">+            if color in table:</span>
<span class="gi">+                return str(table[color])</span>
<span class="gi">+            elif isinstance(color, str):</span>
<span class="gi">+                r, g, b = self._color_name_to_rgb(color)</span>
<span class="gi">+                if self.color_depth == ColorDepth.DEPTH_24_BIT:</span>
<span class="gi">+                    return f&#39;{38 if fg else 48};2;{r};{g};{b}&#39;</span>
<span class="gi">+                elif self.color_depth == ColorDepth.DEPTH_8_BIT:</span>
<span class="gi">+                    return f&#39;{38 if fg else 48};5;{_256_colors[(r, g, b)]}&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    code, name = (_16_fg_colors if fg else _16_bg_colors).get_code((r, g, b))</span>
<span class="gi">+                    return str(code)</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if fg_color:</span>
<span class="gi">+            result.append(color_to_code(fg_color, True))</span>
<span class="gi">+        if bg_color:</span>
<span class="gi">+            result.append(color_to_code(bg_color, False))</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>


<span class="w"> </span>def _get_size(fileno: int) -&gt;tuple[int, int]:
<span class="gu">@@ -187,7 +233,23 @@ def _get_size(fileno: int) -&gt;tuple[int, int]:</span>
<span class="w"> </span>    :param fileno: stdout.fileno()
<span class="w"> </span>    :returns: A (rows, cols) tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import fcntl</span>
<span class="gi">+    import termios</span>
<span class="gi">+    import struct</span>
<span class="gi">+</span>
<span class="gi">+    # Try to get the size using TIOCGWINSZ</span>
<span class="gi">+    try:</span>
<span class="gi">+        size = fcntl.ioctl(fileno, termios.TIOCGWINSZ, struct.pack(&#39;HHHH&#39;, 0, 0, 0, 0))</span>
<span class="gi">+        rows, cols, _, _ = struct.unpack(&#39;HHHH&#39;, size)</span>
<span class="gi">+        return rows, cols</span>
<span class="gi">+    except:</span>
<span class="gi">+        # Fallback to environment variables if ioctl fails</span>
<span class="gi">+        try:</span>
<span class="gi">+            return (int(os.environ.get(&#39;LINES&#39;, 25)),</span>
<span class="gi">+                    int(os.environ.get(&#39;COLUMNS&#39;, 80)))</span>
<span class="gi">+        except:</span>
<span class="gi">+            # If all else fails, return a default size</span>
<span class="gi">+            return 25, 80</span>


<span class="w"> </span>class Vt100_Output(Output):
<span class="gu">@@ -233,7 +295,13 @@ class Vt100_Output(Output):</span>
<span class="w"> </span>        (This will take the dimensions by reading the pseudo
<span class="w"> </span>        terminal attributes.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def get_size() -&gt;Size:</span>
<span class="gi">+            rows, columns = _get_size(stdout.fileno())</span>
<span class="gi">+            return Size(rows=rows, columns=columns)</span>
<span class="gi">+</span>
<span class="gi">+        return cls(stdout, get_size, term=term,</span>
<span class="gi">+                   default_color_depth=default_color_depth,</span>
<span class="gi">+                   enable_bell=enable_bell)</span>

<span class="w"> </span>    def fileno(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Return file descriptor.&quot;&quot;&quot;
<span class="gu">@@ -317,11 +385,15 @@ class Vt100_Output(Output):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Asks for a cursor position report (CPR).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.enable_cpr:</span>
<span class="gi">+            self.write_raw(&#39;\x1b[6n&#39;)</span>
<span class="gi">+            self.flush()</span>

<span class="w"> </span>    def bell(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Sound bell.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.enable_bell:</span>
<span class="gi">+            self.write_raw(&#39;\a&#39;)</span>
<span class="gi">+            self.flush()</span>

<span class="w"> </span>    def get_default_color_depth(self) -&gt;ColorDepth:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -331,4 +403,16 @@ class Vt100_Output(Output):</span>
<span class="w"> </span>        We prefer 256 colors almost always, because this is what most terminals
<span class="w"> </span>        support these days, and is a good default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.default_color_depth:</span>
<span class="gi">+            return self.default_color_depth</span>
<span class="gi">+</span>
<span class="gi">+        if self.term in (&#39;linux&#39;, &#39;eterm-color&#39;):</span>
<span class="gi">+            return ColorDepth.DEPTH_4_BIT</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;256color&#39; in self.term:</span>
<span class="gi">+            return ColorDepth.DEPTH_8_BIT</span>
<span class="gi">+</span>
<span class="gi">+        if self.term in (&#39;xterm&#39;, &#39;screen&#39;, &#39;vt100&#39;, &#39;vt220&#39;, &#39;rxvt-unicode&#39;):</span>
<span class="gi">+            return ColorDepth.DEPTH_8_BIT</span>
<span class="gi">+</span>
<span class="gi">+        return ColorDepth.DEPTH_8_BIT</span>
<span class="gh">diff --git a/src/prompt_toolkit/output/win32.py b/src/prompt_toolkit/output/win32.py</span>
<span class="gh">index 15c3a7b8..988839f6 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/win32.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/win32.py</span>
<span class="gu">@@ -33,7 +33,7 @@ def _coord_byval(coord: COORD) -&gt;c_long:</span>

<span class="w"> </span>    More info: http://msdn.microsoft.com/en-us/library/windows/desktop/ms686025(v=vs.85).aspx
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return c_long(coord.Y * 0x10000 | coord.X &amp; 0xFFFF)</span>


<span class="w"> </span>_DEBUG_RENDER_OUTPUT = False
<span class="gu">@@ -83,66 +83,115 @@ class Win32Output(Output):</span>

<span class="w"> </span>    def fileno(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Return file descriptor.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.stdout.fileno()</span>

<span class="w"> </span>    def encoding(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return encoding used for stdout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.stdout.encoding</span>

<span class="w"> </span>    def write_raw(self, data: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;For win32, there is no difference between write and write_raw.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._buffer.append(data)</span>

<span class="w"> </span>    def _winapi(self, func: Callable[..., _T], *a: object, **kw: object) -&gt;_T:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush and call win API function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.flush()</span>
<span class="gi">+        return func(*a, **kw)</span>

<span class="w"> </span>    def get_win32_screen_buffer_info(self) -&gt;CONSOLE_SCREEN_BUFFER_INFO:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return Screen buffer info.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        info = CONSOLE_SCREEN_BUFFER_INFO()</span>
<span class="gi">+        success = self._winapi(windll.kernel32.GetConsoleScreenBufferInfo,</span>
<span class="gi">+                               self.hconsole, byref(info))</span>
<span class="gi">+        if success:</span>
<span class="gi">+            return info</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NoConsoleScreenBufferError</span>

<span class="w"> </span>    def set_title(self, title: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set terminal title.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._winapi(windll.kernel32.SetConsoleTitleW, title)</span>

<span class="w"> </span>    def erase_end_of_line(self) -&gt;None:
<span class="gd">-        &quot;&quot;&quot;&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Erase from the current cursor position to the end of the line.&quot;&quot;&quot;</span>
<span class="gi">+        info = self.get_win32_screen_buffer_info()</span>
<span class="gi">+        if info:</span>
<span class="gi">+            size = info.dwSize</span>
<span class="gi">+            cursor_pos = info.dwCursorPosition</span>
<span class="gi">+            length = size.X - cursor_pos.X</span>
<span class="gi">+            cells_written = c_ulong()</span>
<span class="gi">+            self._winapi(windll.kernel32.FillConsoleOutputCharacterA,</span>
<span class="gi">+                         self.hconsole, c_char(b&#39; &#39;), length,</span>
<span class="gi">+                         _coord_byval(cursor_pos), byref(cells_written))</span>
<span class="gi">+            self._winapi(windll.kernel32.FillConsoleOutputAttribute,</span>
<span class="gi">+                         self.hconsole, info.wAttributes, length,</span>
<span class="gi">+                         _coord_byval(cursor_pos), byref(cells_written))</span>

<span class="w"> </span>    def reset_attributes(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Reset the console foreground/background color.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._winapi(windll.kernel32.SetConsoleTextAttribute,</span>
<span class="gi">+                     self.hconsole, self.default_attrs)</span>

<span class="w"> </span>    def flush(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write to output stream and flush.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._buffer:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        data = &#39;&#39;.join(self._buffer)</span>
<span class="gi">+        self._buffer = []</span>
<span class="gi">+</span>
<span class="gi">+        if _DEBUG_RENDER_OUTPUT:</span>
<span class="gi">+            self.LOG.write(data.encode(&#39;utf-8&#39;, &#39;replace&#39;))</span>
<span class="gi">+            self.LOG.flush()</span>
<span class="gi">+</span>
<span class="gi">+        self.stdout.write(data)</span>
<span class="gi">+        self.stdout.flush()</span>

<span class="w"> </span>    def scroll_buffer_to_prompt(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        To be called before drawing the prompt. This should scroll the console
<span class="w"> </span>        to left, with the cursor at the bottom (if possible).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        info = self.get_win32_screen_buffer_info()</span>
<span class="gi">+        if info:</span>
<span class="gi">+            sr = SMALL_RECT(</span>
<span class="gi">+                Left=0,</span>
<span class="gi">+                Top=info.srWindow.Top,</span>
<span class="gi">+                Right=info.dwSize.X - 1,</span>
<span class="gi">+                Bottom=info.dwSize.Y - 1,</span>
<span class="gi">+            )</span>
<span class="gi">+            self._winapi(windll.kernel32.SetConsoleWindowInfo,</span>
<span class="gi">+                         self.hconsole, True, byref(sr))</span>
<span class="gi">+</span>
<span class="gi">+            cursor_pos = COORD(x=0, y=info.dwSize.Y - 1)</span>
<span class="gi">+            self._winapi(windll.kernel32.SetConsoleCursorPosition,</span>
<span class="gi">+                         self.hconsole, _coord_byval(cursor_pos))</span>

<span class="w"> </span>    def enter_alternate_screen(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Go to alternate screen buffer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._in_alternate_screen:</span>
<span class="gi">+            self._in_alternate_screen = True</span>
<span class="gi">+            self._winapi(windll.kernel32.SetConsoleActiveScreenBuffer,</span>
<span class="gi">+                         self.hconsole)</span>

<span class="w"> </span>    def quit_alternate_screen(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Make stdout again the active buffer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._in_alternate_screen:</span>
<span class="gi">+            self._in_alternate_screen = False</span>
<span class="gi">+            self._winapi(windll.kernel32.SetConsoleActiveScreenBuffer,</span>
<span class="gi">+                         HANDLE(windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)))</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def win32_refresh_window(cls) -&gt;None:
<span class="gu">@@ -153,7 +202,8 @@ class Win32Output(Output):</span>
<span class="w"> </span>        for completion menus. When the menu disappears, it leaves traces due
<span class="w"> </span>        to a bug in the Windows Console. Sending a repaint request solves it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hconsole = HANDLE(windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE))</span>
<span class="gi">+        windll.user32.InvalidateRect(hconsole, None, True)</span>

<span class="w"> </span>    def get_default_color_depth(self) -&gt;ColorDepth:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -162,7 +212,14 @@ class Win32Output(Output):</span>
<span class="w"> </span>        Contrary to the Vt100 implementation, this doesn&#39;t depend on a $TERM
<span class="w"> </span>        variable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.default_color_depth is not None:</span>
<span class="gi">+            return self.default_color_depth</span>
<span class="gi">+</span>
<span class="gi">+        # Windows 10 supports true color.</span>
<span class="gi">+        if sys.getwindowsversion().build &gt;= 14393:</span>
<span class="gi">+            return ColorDepth.DEPTH_24_BIT</span>
<span class="gi">+</span>
<span class="gi">+        return ColorDepth.DEPTH_4_BIT</span>


<span class="w"> </span>class FOREGROUND_COLOR:
<span class="gu">@@ -192,7 +249,25 @@ class BACKGROUND_COLOR:</span>
<span class="w"> </span>def _create_ansi_color_dict(color_cls: (type[FOREGROUND_COLOR] | type[
<span class="w"> </span>    BACKGROUND_COLOR])) -&gt;dict[str, int]:
<span class="w"> </span>    &quot;&quot;&quot;Create a table that maps the 16 named ansi colors to their Windows code.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;ansidefault&#39;: color_cls.GRAY,</span>
<span class="gi">+        &#39;ansiblack&#39;: color_cls.BLACK,</span>
<span class="gi">+        &#39;ansired&#39;: color_cls.RED,</span>
<span class="gi">+        &#39;ansigreen&#39;: color_cls.GREEN,</span>
<span class="gi">+        &#39;ansiyellow&#39;: color_cls.YELLOW,</span>
<span class="gi">+        &#39;ansiblue&#39;: color_cls.BLUE,</span>
<span class="gi">+        &#39;ansimagenta&#39;: color_cls.MAGENTA,</span>
<span class="gi">+        &#39;ansicyan&#39;: color_cls.CYAN,</span>
<span class="gi">+        &#39;ansigray&#39;: color_cls.GRAY,</span>
<span class="gi">+        &#39;ansibrightblack&#39;: color_cls.BLACK | color_cls.INTENSITY,</span>
<span class="gi">+        &#39;ansibrightred&#39;: color_cls.RED | color_cls.INTENSITY,</span>
<span class="gi">+        &#39;ansibrightgreen&#39;: color_cls.GREEN | color_cls.INTENSITY,</span>
<span class="gi">+        &#39;ansibrightyellow&#39;: color_cls.YELLOW | color_cls.INTENSITY,</span>
<span class="gi">+        &#39;ansibrightblue&#39;: color_cls.BLUE | color_cls.INTENSITY,</span>
<span class="gi">+        &#39;ansibrightmagenta&#39;: color_cls.MAGENTA | color_cls.INTENSITY,</span>
<span class="gi">+        &#39;ansibrightcyan&#39;: color_cls.CYAN | color_cls.INTENSITY,</span>
<span class="gi">+        &#39;ansiwhite&#39;: color_cls.GRAY | color_cls.INTENSITY,</span>
<span class="gi">+    }</span>


<span class="w"> </span>FG_ANSI_COLORS = _create_ansi_color_dict(FOREGROUND_COLOR)
<span class="gh">diff --git a/src/prompt_toolkit/output/windows10.py b/src/prompt_toolkit/output/windows10.py</span>
<span class="gh">index 8ed52363..57b585e5 100644</span>
<span class="gd">--- a/src/prompt_toolkit/output/windows10.py</span>
<span class="gi">+++ b/src/prompt_toolkit/output/windows10.py</span>
<span class="gu">@@ -34,7 +34,8 @@ class Windows10_Output:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Write to output stream and flush.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.win32_output.flush()</span>
<span class="gi">+        self.vt100_output.flush()</span>

<span class="w"> </span>    def __getattr__(self, name: str) -&gt;Any:
<span class="w"> </span>        if name in (&#39;get_size&#39;, &#39;get_rows_below_cursor_position&#39;,
<span class="gu">@@ -52,7 +53,9 @@ class Windows10_Output:</span>
<span class="w"> </span>        Contrary to the Vt100 implementation, this doesn&#39;t depend on a $TERM
<span class="w"> </span>        variable.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.default_color_depth is not None:</span>
<span class="gi">+            return self.default_color_depth</span>
<span class="gi">+        return self.win32_output.get_default_color_depth()</span>


<span class="w"> </span>Output.register(Windows10_Output)
<span class="gu">@@ -63,4 +66,13 @@ def is_win_vt100_enabled() -&gt;bool:</span>
<span class="w"> </span>    Returns True when we&#39;re running Windows and VT100 escape sequences are
<span class="w"> </span>    supported.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.platform != &#39;win32&#39;:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    hconsole = HANDLE(windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE))</span>
<span class="gi">+    mode = DWORD()</span>
<span class="gi">+</span>
<span class="gi">+    if windll.kernel32.GetConsoleMode(hconsole, byref(mode)):</span>
<span class="gi">+        return bool(mode.value &amp; ENABLE_VIRTUAL_TERMINAL_PROCESSING)</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gh">diff --git a/src/prompt_toolkit/patch_stdout.py b/src/prompt_toolkit/patch_stdout.py</span>
<span class="gh">index c07354d2..c2e3b761 100644</span>
<span class="gd">--- a/src/prompt_toolkit/patch_stdout.py</span>
<span class="gi">+++ b/src/prompt_toolkit/patch_stdout.py</span>
<span class="gu">@@ -48,7 +48,14 @@ def patch_stdout(raw: bool=False) -&gt;Generator[None, None, None]:</span>
<span class="w"> </span>    :param raw: (`bool`) When True, vt100 terminal escape sequences are not
<span class="w"> </span>                removed/escaped.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    original_stdout = sys.stdout</span>
<span class="gi">+    try:</span>
<span class="gi">+        proxy = StdoutProxy(raw=raw)</span>
<span class="gi">+        sys.stdout = proxy</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        proxy.close()</span>
<span class="gi">+        sys.stdout = original_stdout</span>


<span class="w"> </span>class _Done:
<span class="gu">@@ -98,14 +105,21 @@ class StdoutProxy:</span>
<span class="w"> </span>        This will terminate the write thread, make sure everything is flushed
<span class="w"> </span>        and wait for the write thread to finish.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.closed:</span>
<span class="gi">+            self._flush_queue.put(_Done())</span>
<span class="gi">+            self._flush_thread.join()</span>
<span class="gi">+            self.flush()</span>
<span class="gi">+            self.closed = True</span>

<span class="w"> </span>    def _get_app_loop(self) -&gt;(asyncio.AbstractEventLoop | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the event loop for the application currently running in our
<span class="w"> </span>        `AppSession`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = self.app_session.app</span>
<span class="gi">+        if app and app.is_running:</span>
<span class="gi">+            return app.loop</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def _write_and_flush(self, loop: (asyncio.AbstractEventLoop | None),
<span class="w"> </span>        text: str) -&gt;None:
<span class="gu">@@ -113,7 +127,14 @@ class StdoutProxy:</span>
<span class="w"> </span>        Write the given text to stdout and flush.
<span class="w"> </span>        If an application is running, use `run_in_terminal`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def write_and_flush() -&gt;None:</span>
<span class="gi">+            self._output.write_raw(text)</span>
<span class="gi">+            self._output.flush()</span>
<span class="gi">+</span>
<span class="gi">+        if loop is not None:</span>
<span class="gi">+            run_in_terminal(write_and_flush, in_executor=True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            write_and_flush()</span>

<span class="w"> </span>    def _write(self, data: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -126,10 +147,27 @@ class StdoutProxy:</span>
<span class="w"> </span>              command line. Therefor, we have a little buffer which holds the
<span class="w"> </span>              text until a newline is written to stdout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.raw:</span>
<span class="gi">+            data = data.replace(&#39;\x1b&#39;, &#39;?&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;\n&#39; in data:</span>
<span class="gi">+            # When there&#39;s a newline in the data, write everything before the</span>
<span class="gi">+            # newline, including the newline itself.</span>
<span class="gi">+            before, after = data.rsplit(&#39;\n&#39;, 1)</span>
<span class="gi">+            to_write = &#39;&#39;.join(self._buffer) + before + &#39;\n&#39;</span>
<span class="gi">+            self._buffer = [after]</span>
<span class="gi">+</span>
<span class="gi">+            if to_write:</span>
<span class="gi">+                self._flush_queue.put(to_write)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Otherwise, cache in buffer.</span>
<span class="gi">+            self._buffer.append(data)</span>

<span class="w"> </span>    def flush(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Flush buffered output.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._buffer:</span>
<span class="gi">+            data = &#39;&#39;.join(self._buffer)</span>
<span class="gi">+            self._buffer = []</span>
<span class="gi">+            self._flush_queue.put(data)</span>
<span class="gh">diff --git a/src/prompt_toolkit/renderer.py b/src/prompt_toolkit/renderer.py</span>
<span class="gh">index d60c37f7..497c6762 100644</span>
<span class="gd">--- a/src/prompt_toolkit/renderer.py</span>
<span class="gi">+++ b/src/prompt_toolkit/renderer.py</span>
<span class="gu">@@ -47,7 +47,56 @@ def _output_screen_diff(app: Application[Any], output: Output, screen:</span>
<span class="w"> </span>    :param width: The width of the terminal.
<span class="w"> </span>    :param previous_width: The width of the terminal during the last rendering.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    width = size.columns</span>
<span class="gi">+</span>
<span class="gi">+    # Create locals for faster access</span>
<span class="gi">+    write = output.write</span>
<span class="gi">+    write_position = output.set_cursor_position</span>
<span class="gi">+    move_cursor = output.move_cursor</span>
<span class="gi">+</span>
<span class="gi">+    # Skip first empty lines. (This is a performance optimization.)</span>
<span class="gi">+    if previous_screen is None:</span>
<span class="gi">+        row = 0</span>
<span class="gi">+    else:</span>
<span class="gi">+        row = 0</span>
<span class="gi">+        while row &lt; screen.height and row &lt; previous_screen.height and screen.data_buffer[row] == previous_screen.data_buffer[row]:</span>
<span class="gi">+            row += 1</span>
<span class="gi">+</span>
<span class="gi">+    # Render output</span>
<span class="gi">+    for y in range(row, screen.height):</span>
<span class="gi">+        row = screen.data_buffer[y]</span>
<span class="gi">+        previous_row = previous_screen.data_buffer[y] if previous_screen and y &lt; previous_screen.height else None</span>
<span class="gi">+</span>
<span class="gi">+        col = 0</span>
<span class="gi">+        while col &lt; width:</span>
<span class="gi">+            char = row[col]</span>
<span class="gi">+            char_width = char.width or 1</span>
<span class="gi">+</span>
<span class="gi">+            if previous_row:</span>
<span class="gi">+                previous_char = previous_row[col]</span>
<span class="gi">+                if char == previous_char:</span>
<span class="gi">+                    col += char_width</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            current_pos = Point(x=col, y=y)</span>
<span class="gi">+            write_position(current_pos.x, current_pos.y)</span>
<span class="gi">+            style = char.style</span>
<span class="gi">+</span>
<span class="gi">+            if style != last_style:</span>
<span class="gi">+                attrs = attrs_for_style_string[style]</span>
<span class="gi">+                output.set_attributes(attrs, color_depth)</span>
<span class="gi">+                last_style = style</span>
<span class="gi">+</span>
<span class="gi">+            write(char.char)</span>
<span class="gi">+            col += char_width</span>
<span class="gi">+</span>
<span class="gi">+    # Move cursor</span>
<span class="gi">+    if is_done:</span>
<span class="gi">+        write_position(screen.cursor_position.x, screen.cursor_position.y)</span>
<span class="gi">+    else:</span>
<span class="gi">+        move_cursor(screen.cursor_position.x - current_pos.x, screen.cursor_position.y - current_pos.y)</span>
<span class="gi">+</span>
<span class="gi">+    return screen.cursor_position, last_style</span>


<span class="w"> </span>class HeightIsUnknownError(Exception):
<span class="gu">@@ -142,7 +191,7 @@ class Renderer:</span>
<span class="w"> </span>        The `Screen` class that was generated during the last rendering.
<span class="w"> </span>        This can be `None`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return getattr(self, &#39;_last_rendered_screen&#39;, None)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def height_is_known(self) -&gt;bool:
<span class="gu">@@ -151,14 +200,17 @@ class Renderer:</span>
<span class="w"> </span>        is known. (It&#39;s often nicer to draw bottom toolbars only if the height
<span class="w"> </span>        is known, in order to avoid flickering when the CPR response arrives.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.cpr_support != CPR_Support.UNKNOWN and not self.waiting_for_cpr</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def rows_above_layout(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the number of rows visible in the terminal above the layout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.cpr_support == CPR_Support.SUPPORTED:</span>
<span class="gi">+            return self._rows_above_layout</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 0</span>

<span class="w"> </span>    def request_absolute_cursor_position(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -171,14 +223,26 @@ class Renderer:</span>
<span class="w"> </span>        For vt100: Do CPR request. (answer will arrive later.)
<span class="w"> </span>        For win32: Do API call. (Answer comes immediately.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.cpr_support != CPR_Support.NOT_SUPPORTED:</span>
<span class="gi">+            self.output.get_cursor_position()</span>
<span class="gi">+            self.cpr_support = CPR_Support.SUPPORTED</span>
<span class="gi">+</span>
<span class="gi">+        if self.cpr_support == CPR_Support.NOT_SUPPORTED:</span>
<span class="gi">+            if self.cpr_not_supported_callback:</span>
<span class="gi">+                self.cpr_not_supported_callback()</span>

<span class="w"> </span>    def report_absolute_cursor_row(self, row: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        To be called when we know the absolute cursor position.
<span class="w"> </span>        (As an answer of a &quot;Cursor Position Request&quot; response.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._rows_above_layout = row - 1</span>
<span class="gi">+</span>
<span class="gi">+        # Resolve future.</span>
<span class="gi">+        if self._waiting_for_cpr_futures:</span>
<span class="gi">+            for f in self._waiting_for_cpr_futures:</span>
<span class="gi">+                f.set_result(None)</span>
<span class="gi">+            self._waiting_for_cpr_futures = deque()</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def waiting_for_cpr(self) -&gt;bool:
<span class="gu">@@ -186,13 +250,14 @@ class Renderer:</span>
<span class="w"> </span>        Waiting for CPR flag. True when we send the request, but didn&#39;t got a
<span class="w"> </span>        response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(self._waiting_for_cpr_futures)</span>

<span class="w"> </span>    async def wait_for_cpr_responses(self, timeout: int=1) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Wait for a CPR response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._waiting_for_cpr_futures:</span>
<span class="gi">+            await wait(list(self._waiting_for_cpr_futures), timeout=timeout)</span>

<span class="w"> </span>    def render(self, app: Application[Any], layout: Layout, is_done: bool=False
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -202,7 +267,79 @@ class Renderer:</span>
<span class="w"> </span>        :param is_done: When True, put the cursor at the end of the interface. We
<span class="w"> </span>                won&#39;t print any changes to this part.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        output = self.output</span>
<span class="gi">+        screen = layout.screen</span>
<span class="gi">+</span>
<span class="gi">+        if is_done:</span>
<span class="gi">+            self.request_absolute_cursor_position()</span>
<span class="gi">+</span>
<span class="gi">+        # Enter alternate screen.</span>
<span class="gi">+        if self.full_screen and not self._in_alternate_screen:</span>
<span class="gi">+            self._in_alternate_screen = True</span>
<span class="gi">+            output.enter_alternate_screen()</span>
<span class="gi">+</span>
<span class="gi">+        # Enable/disable mouse support.</span>
<span class="gi">+        needs_mouse_support = self.mouse_support()</span>
<span class="gi">+        if needs_mouse_support != self._mouse_support_enabled:</span>
<span class="gi">+            if needs_mouse_support:</span>
<span class="gi">+                output.enable_mouse_support()</span>
<span class="gi">+            else:</span>
<span class="gi">+                output.disable_mouse_support()</span>
<span class="gi">+            self._mouse_support_enabled = needs_mouse_support</span>
<span class="gi">+</span>
<span class="gi">+        # Enable bracketed paste.</span>
<span class="gi">+        if not self._bracketed_paste_enabled:</span>
<span class="gi">+            output.enable_bracketed_paste()</span>
<span class="gi">+            self._bracketed_paste_enabled = True</span>
<span class="gi">+</span>
<span class="gi">+        # Reset cursor key mode.</span>
<span class="gi">+        if not self._cursor_key_mode_reset:</span>
<span class="gi">+            output.reset_cursor_key_mode()</span>
<span class="gi">+            self._cursor_key_mode_reset = True</span>
<span class="gi">+</span>
<span class="gi">+        # Create new style transformation.</span>
<span class="gi">+        style_transformation = app.style_transformation or DummyStyleTransformation()</span>
<span class="gi">+</span>
<span class="gi">+        # Create new Cache objects.</span>
<span class="gi">+        style_hash = hash((app.style, style_transformation))</span>
<span class="gi">+        color_depth = output.get_default_color_depth()</span>
<span class="gi">+</span>
<span class="gi">+        if (style_hash != self._last_style_hash or</span>
<span class="gi">+            color_depth != self._last_color_depth):</span>
<span class="gi">+            self._attrs_for_style = _StyleStringToAttrsCache(</span>
<span class="gi">+                get_attrs_for_style_str=lambda style_str: app.style.get_attrs_for_style_str(style_str),</span>
<span class="gi">+                style_transformation=style_transformation)</span>
<span class="gi">+            self._style_string_has_style = _StyleStringHasStyleCache(self._attrs_for_style)</span>
<span class="gi">+</span>
<span class="gi">+        self._last_style_hash = style_hash</span>
<span class="gi">+        self._last_color_depth = color_depth</span>
<span class="gi">+</span>
<span class="gi">+        # Render to screen.</span>
<span class="gi">+        size = output.get_size()</span>
<span class="gi">+        if self.full_screen:</span>
<span class="gi">+            screen.resize(size)</span>
<span class="gi">+        else:</span>
<span class="gi">+            screen.resize(Size(rows=size.rows, columns=size.columns))</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate the difference between this and the previous screen.</span>
<span class="gi">+        current_pos, last_style = _output_screen_diff(</span>
<span class="gi">+            app,</span>
<span class="gi">+            output,</span>
<span class="gi">+            screen,</span>
<span class="gi">+            current_pos=Point(0, 0),</span>
<span class="gi">+            color_depth=color_depth,</span>
<span class="gi">+            previous_screen=self._last_rendered_screen,</span>
<span class="gi">+            last_style=None,</span>
<span class="gi">+            is_done=is_done,</span>
<span class="gi">+            full_screen=self.full_screen,</span>
<span class="gi">+            attrs_for_style_string=self._attrs_for_style,</span>
<span class="gi">+            style_string_has_style=self._style_string_has_style,</span>
<span class="gi">+            size=size,</span>
<span class="gi">+            previous_width=(self._last_rendered_screen.width</span>
<span class="gi">+                            if self._last_rendered_screen else 0))</span>
<span class="gi">+</span>
<span class="gi">+        output.flush()</span>
<span class="gi">+        self._last_rendered_screen = screen</span>

<span class="w"> </span>    def erase(self, leave_alternate_screen: bool=True) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -213,13 +350,30 @@ class Renderer:</span>
<span class="w"> </span>        :param leave_alternate_screen: When True, and when inside an alternate
<span class="w"> </span>            screen buffer, quit the alternate screen.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        output = self.output</span>
<span class="gi">+</span>
<span class="gi">+        output.erase_screen()</span>
<span class="gi">+        output.reset_attributes()</span>
<span class="gi">+        output.disable_mouse_support()</span>
<span class="gi">+        output.disable_bracketed_paste()</span>
<span class="gi">+        output.reset_cursor_key_mode()</span>
<span class="gi">+</span>
<span class="gi">+        if leave_alternate_screen and self._in_alternate_screen:</span>
<span class="gi">+            output.quit_alternate_screen()</span>
<span class="gi">+            self._in_alternate_screen = False</span>
<span class="gi">+</span>
<span class="gi">+        self._last_rendered_screen = None</span>
<span class="gi">+        output.flush()</span>

<span class="w"> </span>    def clear(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Clear screen and go to 0,0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        output = self.output</span>
<span class="gi">+</span>
<span class="gi">+        output.erase_screen()</span>
<span class="gi">+        output.cursor_goto(0, 0)</span>
<span class="gi">+        output.flush()</span>


<span class="w"> </span>def print_formatted_text(output: Output, formatted_text: AnyFormattedText,
<span class="gh">diff --git a/src/prompt_toolkit/search.py b/src/prompt_toolkit/search.py</span>
<span class="gh">index 60c9f64a..a6597ca3 100644</span>
<span class="gd">--- a/src/prompt_toolkit/search.py</span>
<span class="gi">+++ b/src/prompt_toolkit/search.py</span>
<span class="gu">@@ -71,28 +71,68 @@ def start_search(buffer_control: (BufferControl | None)=None, direction:</span>
<span class="w"> </span>    :param buffer_control: Start search for this `BufferControl`. If not given,
<span class="w"> </span>        search through the current control.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    </span>
<span class="gi">+    if buffer_control is None:</span>
<span class="gi">+        buffer_control = app.layout.current_control</span>
<span class="gi">+</span>
<span class="gi">+    search_control = _get_reverse_search_links(app.layout).get(buffer_control)</span>
<span class="gi">+    </span>
<span class="gi">+    if search_control:</span>
<span class="gi">+        buffer_control.search_state = SearchState(direction=direction)</span>
<span class="gi">+        app.layout.focus(search_control)</span>
<span class="gi">+        search_control.buffer.reset()</span>


<span class="w"> </span>def stop_search(buffer_control: (BufferControl | None)=None) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Stop search through the given `buffer_control`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    </span>
<span class="gi">+    if buffer_control is None:</span>
<span class="gi">+        buffer_control = app.layout.current_control</span>
<span class="gi">+</span>
<span class="gi">+    if buffer_control.search_state:</span>
<span class="gi">+        buffer_control.search_state = None</span>
<span class="gi">+        app.layout.focus(buffer_control)</span>


<span class="w"> </span>def do_incremental_search(direction: SearchDirection, count: int=1) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Apply search, but keep search buffer focused.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    search_control = app.layout.current_control</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(search_control, SearchBufferControl):</span>
<span class="gi">+        buffer_control = search_control.buffer_control</span>
<span class="gi">+        if buffer_control and buffer_control.search_state:</span>
<span class="gi">+            buffer_control.search_state.direction = direction</span>
<span class="gi">+            </span>
<span class="gi">+            for _ in range(count):</span>
<span class="gi">+                buffer_control.search(buffer_control.search_state.text,</span>
<span class="gi">+                                      direction,</span>
<span class="gi">+                                      count=1,</span>
<span class="gi">+                                      include_current_position=False)</span>


<span class="w"> </span>def accept_search() -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Accept current search query. Focus original `BufferControl` again.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app = get_app()</span>
<span class="gi">+    search_control = app.layout.current_control</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(search_control, SearchBufferControl):</span>
<span class="gi">+        buffer_control = search_control.buffer_control</span>
<span class="gi">+        if buffer_control:</span>
<span class="gi">+            app.layout.focus(buffer_control)</span>
<span class="gi">+</span>
<span class="gi">+            # If we&#39;re in Vi mode and in navigation mode, go back to </span>
<span class="gi">+            # insert mode.</span>
<span class="gi">+            if app.vi_state.input_mode == InputMode.NAVIGATION:</span>
<span class="gi">+                app.vi_state.input_mode = InputMode.INSERT</span>


<span class="w"> </span>def _get_reverse_search_links(layout: Layout) -&gt;dict[BufferControl,
<span class="gu">@@ -100,4 +140,8 @@ def _get_reverse_search_links(layout: Layout) -&gt;dict[BufferControl,</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return mapping from BufferControl to SearchBufferControl.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for search_control in layout.find_all_controls(lambda c: isinstance(c, SearchBufferControl)):</span>
<span class="gi">+        if search_control.buffer_control:</span>
<span class="gi">+            result[search_control.buffer_control] = search_control</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/dialogs.py b/src/prompt_toolkit/shortcuts/dialogs.py</span>
<span class="gh">index 1ae0d91d..0951f225 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/dialogs.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/dialogs.py</span>
<span class="gu">@@ -30,7 +30,33 @@ def yes_no_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="w"> </span>    Display a Yes/No dialog.
<span class="w"> </span>    Return a boolean.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def yes_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=True)</span>
<span class="gi">+</span>
<span class="gi">+    def no_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=False)</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=Label(text=text, dont_extend_height=True),</span>
<span class="gi">+        buttons=[</span>
<span class="gi">+            Button(text=yes_text, handler=yes_handler),</span>
<span class="gi">+            Button(text=no_text, handler=no_handler),</span>
<span class="gi">+        ],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return Application(</span>
<span class="gi">+        layout=Layout(dialog),</span>
<span class="gi">+        key_bindings=merge_key_bindings([</span>
<span class="gi">+            load_key_bindings(),</span>
<span class="gi">+            focus_next,</span>
<span class="gi">+            focus_previous,</span>
<span class="gi">+        ]),</span>
<span class="gi">+        mouse_support=True,</span>
<span class="gi">+        style=style,</span>
<span class="gi">+        full_screen=True,</span>
<span class="gi">+    )</span>


<span class="w"> </span>_T = TypeVar(&#39;_T&#39;)
<span class="gu">@@ -43,7 +69,30 @@ def button_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="w"> </span>    Display a dialog with button choices (given as a list of tuples).
<span class="w"> </span>    Return the value associated with button.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def button_handler(value: _T) -&gt; None:</span>
<span class="gi">+        get_app().exit(result=value)</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=Label(text=text, dont_extend_height=True),</span>
<span class="gi">+        buttons=[</span>
<span class="gi">+            Button(text=button_text, handler=functools.partial(button_handler, value))</span>
<span class="gi">+            for button_text, value in buttons</span>
<span class="gi">+        ],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return Application(</span>
<span class="gi">+        layout=Layout(dialog),</span>
<span class="gi">+        key_bindings=merge_key_bindings([</span>
<span class="gi">+            load_key_bindings(),</span>
<span class="gi">+            focus_next,</span>
<span class="gi">+            focus_previous,</span>
<span class="gi">+        ]),</span>
<span class="gi">+        mouse_support=True,</span>
<span class="gi">+        style=style,</span>
<span class="gi">+        full_screen=True,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def input_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,
<span class="gu">@@ -54,7 +103,51 @@ def input_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="w"> </span>    Display a text input box.
<span class="w"> </span>    Return the given text, or None when cancelled.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def accept(buf: Buffer) -&gt; bool:</span>
<span class="gi">+        get_app().layout.focus(ok_button)</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def ok_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=textfield.text)</span>
<span class="gi">+</span>
<span class="gi">+    def cancel_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=None)</span>
<span class="gi">+</span>
<span class="gi">+    textfield = TextArea(</span>
<span class="gi">+        completer=completer,</span>
<span class="gi">+        validator=validator,</span>
<span class="gi">+        password=password,</span>
<span class="gi">+        multiline=False,</span>
<span class="gi">+        width=D(preferred=40),</span>
<span class="gi">+        accept_handler=accept,</span>
<span class="gi">+        default=default,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    ok_button = Button(text=ok_text, handler=ok_handler)</span>
<span class="gi">+    cancel_button = Button(text=cancel_text, handler=cancel_handler)</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=HSplit([</span>
<span class="gi">+            Label(text=text, dont_extend_height=True),</span>
<span class="gi">+            textfield,</span>
<span class="gi">+            ValidationToolbar(),</span>
<span class="gi">+        ]),</span>
<span class="gi">+        buttons=[ok_button, cancel_button],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return Application(</span>
<span class="gi">+        layout=Layout(dialog),</span>
<span class="gi">+        key_bindings=merge_key_bindings([</span>
<span class="gi">+            load_key_bindings(),</span>
<span class="gi">+            focus_next,</span>
<span class="gi">+            focus_previous,</span>
<span class="gi">+        ]),</span>
<span class="gi">+        mouse_support=True,</span>
<span class="gi">+        style=style,</span>
<span class="gi">+        full_screen=True,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def message_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,
<span class="gu">@@ -62,7 +155,27 @@ def message_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Display a simple message box and wait until the user presses enter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def ok_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=None)</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=Label(text=text, dont_extend_height=True),</span>
<span class="gi">+        buttons=[Button(text=ok_text, handler=ok_handler)],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return Application(</span>
<span class="gi">+        layout=Layout(dialog),</span>
<span class="gi">+        key_bindings=merge_key_bindings([</span>
<span class="gi">+            load_key_bindings(),</span>
<span class="gi">+            focus_next,</span>
<span class="gi">+            focus_previous,</span>
<span class="gi">+        ]),</span>
<span class="gi">+        mouse_support=True,</span>
<span class="gi">+        style=style,</span>
<span class="gi">+        full_screen=True,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def radiolist_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,
<span class="gu">@@ -75,7 +188,38 @@ def radiolist_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="w"> </span>    Only one element can be selected at a time using Arrow keys and Enter.
<span class="w"> </span>    The focus can be moved between the list and the Ok/Cancel button with tab.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def ok_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=radio_list.current_value)</span>
<span class="gi">+</span>
<span class="gi">+    def cancel_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=None)</span>
<span class="gi">+</span>
<span class="gi">+    radio_list = RadioList(values or [], default=default)</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=HSplit([</span>
<span class="gi">+            Label(text=text, dont_extend_height=True),</span>
<span class="gi">+            radio_list,</span>
<span class="gi">+        ]),</span>
<span class="gi">+        buttons=[</span>
<span class="gi">+            Button(text=ok_text, handler=ok_handler),</span>
<span class="gi">+            Button(text=cancel_text, handler=cancel_handler),</span>
<span class="gi">+        ],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return Application(</span>
<span class="gi">+        layout=Layout(dialog),</span>
<span class="gi">+        key_bindings=merge_key_bindings([</span>
<span class="gi">+            load_key_bindings(),</span>
<span class="gi">+            focus_next,</span>
<span class="gi">+            focus_previous,</span>
<span class="gi">+        ]),</span>
<span class="gi">+        mouse_support=True,</span>
<span class="gi">+        style=style,</span>
<span class="gi">+        full_screen=True,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def checkboxlist_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=
<span class="gu">@@ -88,7 +232,38 @@ def checkboxlist_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=</span>
<span class="w"> </span>    Several elements can be selected at a time using Arrow keys and Enter.
<span class="w"> </span>    The focus can be moved between the list and the Ok/Cancel button with tab.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def ok_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=checkbox_list.current_values)</span>
<span class="gi">+</span>
<span class="gi">+    def cancel_handler() -&gt; None:</span>
<span class="gi">+        get_app().exit(result=None)</span>
<span class="gi">+</span>
<span class="gi">+    checkbox_list = CheckboxList(values or [], default_values=default_values or [])</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=HSplit([</span>
<span class="gi">+            Label(text=text, dont_extend_height=True),</span>
<span class="gi">+            checkbox_list,</span>
<span class="gi">+        ]),</span>
<span class="gi">+        buttons=[</span>
<span class="gi">+            Button(text=ok_text, handler=ok_handler),</span>
<span class="gi">+            Button(text=cancel_text, handler=cancel_handler),</span>
<span class="gi">+        ],</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return Application(</span>
<span class="gi">+        layout=Layout(dialog),</span>
<span class="gi">+        key_bindings=merge_key_bindings([</span>
<span class="gi">+            load_key_bindings(),</span>
<span class="gi">+            focus_next,</span>
<span class="gi">+            focus_previous,</span>
<span class="gi">+        ]),</span>
<span class="gi">+        mouse_support=True,</span>
<span class="gi">+        style=style,</span>
<span class="gi">+        full_screen=True,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def progress_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,
<span class="gu">@@ -98,9 +273,51 @@ def progress_dialog(title: AnyFormattedText=&#39;&#39;, text: AnyFormattedText=&#39;&#39;,</span>
<span class="w"> </span>    :param run_callback: A function that receives as input a `set_percentage`
<span class="w"> </span>        function and it does the work.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    progressbar = ProgressBar()</span>
<span class="gi">+    text_area = TextArea(</span>
<span class="gi">+        focusable=False,</span>
<span class="gi">+        multiline=True,</span>
<span class="gi">+        width=D(preferred=40),</span>
<span class="gi">+        height=D(preferred=3),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    dialog = Dialog(</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        body=HSplit([</span>
<span class="gi">+            Label(text=text, dont_extend_height=True),</span>
<span class="gi">+            Box(progressbar, padding=1),</span>
<span class="gi">+            text_area,</span>
<span class="gi">+        ]),</span>
<span class="gi">+        with_background=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    app = Application(</span>
<span class="gi">+        layout=Layout(dialog),</span>
<span class="gi">+        key_bindings=load_key_bindings(),</span>
<span class="gi">+        mouse_support=True,</span>
<span class="gi">+        style=style,</span>
<span class="gi">+        full_screen=True,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def set_percentage(value: int) -&gt; None:</span>
<span class="gi">+        progressbar.percentage = value</span>
<span class="gi">+        app.invalidate()</span>
<span class="gi">+</span>
<span class="gi">+    def set_text(text: str) -&gt; None:</span>
<span class="gi">+        text_area.text = text</span>
<span class="gi">+        app.invalidate()</span>
<span class="gi">+</span>
<span class="gi">+    async def run_in_executor() -&gt; None:</span>
<span class="gi">+        await run_in_executor_with_context(</span>
<span class="gi">+            run_callback, set_percentage, set_text</span>
<span class="gi">+        )</span>
<span class="gi">+        app.exit()</span>
<span class="gi">+</span>
<span class="gi">+    app.after_create = lambda: get_running_loop().create_task(run_in_executor())</span>
<span class="gi">+</span>
<span class="gi">+    return app</span>


<span class="w"> </span>def _return_none() -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Button handler that returns None.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    get_app().exit(result=None)</span>
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/progress_bar/base.py b/src/prompt_toolkit/shortcuts/progress_bar/base.py</span>
<span class="gh">index 3cc8cbce..fe2689db 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/progress_bar/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/progress_bar/base.py</span>
<span class="gu">@@ -41,7 +41,15 @@ def create_key_bindings(cancel_callback: (Callable[[], None] | None)</span>
<span class="w"> </span>    Key bindings handled by the progress bar.
<span class="w"> </span>    (The main thread is not supposed to handle any key bindings.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+    @kb.add(&#39;c-c&#39;)</span>
<span class="gi">+    def _(event: E) -&gt; None:</span>
<span class="gi">+        &quot; Abort when Control-C has been pressed. &quot;</span>
<span class="gi">+        if cancel_callback is not None:</span>
<span class="gi">+            cancel_callback()</span>
<span class="gi">+    </span>
<span class="gi">+    return kb</span>


<span class="w"> </span>_T = TypeVar(&#39;_T&#39;)
<span class="gu">@@ -215,7 +223,9 @@ class ProgressBarCounter(Generic[_CounterItem]):</span>

<span class="w"> </span>        (Can be called manually in case we don&#39;t have a collection to loop through.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.items_completed += 1</span>
<span class="gi">+        if self.total is not None and self.items_completed &gt;= self.total:</span>
<span class="gi">+            self.done = True</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def done(self) -&gt;bool:
<span class="gu">@@ -227,7 +237,15 @@ class ProgressBarCounter(Generic[_CounterItem]):</span>
<span class="w"> </span>        Contrast this with stopped. A stopped counter may be terminated before
<span class="w"> </span>        100% completion. A done counter has reached its 100% completion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._done</span>
<span class="gi">+</span>
<span class="gi">+    @done.setter</span>
<span class="gi">+    def done(self, value: bool) -&gt; None:</span>
<span class="gi">+        self._done = value</span>
<span class="gi">+        if value:</span>
<span class="gi">+            self.stopped = True</span>
<span class="gi">+            if self.remove_when_done:</span>
<span class="gi">+                self.progress_bar.counters.remove(self)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def stopped(self) -&gt;bool:
<span class="gu">@@ -245,18 +263,35 @@ class ProgressBarCounter(Generic[_CounterItem]):</span>
<span class="w"> </span>        Contrast this with done. A done counter has reached its 100% completion.
<span class="w"> </span>        A stopped counter may be terminated before 100% completion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.stop_time is not None</span>
<span class="gi">+</span>
<span class="gi">+    @stopped.setter</span>
<span class="gi">+    def stopped(self, value: bool) -&gt; None:</span>
<span class="gi">+        if value and self.stop_time is None:</span>
<span class="gi">+            self.stop_time = datetime.datetime.now()</span>
<span class="gi">+        elif not value:</span>
<span class="gi">+            self.stop_time = None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def time_elapsed(self) -&gt;datetime.timedelta:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return how much time has been elapsed since the start.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.stop_time is not None:</span>
<span class="gi">+            return self.stop_time - self.start_time</span>
<span class="gi">+        return datetime.datetime.now() - self.start_time</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def time_left(self) -&gt;(datetime.timedelta | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Timedelta representing the time left.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.total is None or self.items_completed == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        </span>
<span class="gi">+        elapsed = self.time_elapsed</span>
<span class="gi">+        rate = self.items_completed / elapsed.total_seconds()</span>
<span class="gi">+        remaining_items = self.total - self.items_completed</span>
<span class="gi">+        seconds_left = remaining_items / rate</span>
<span class="gi">+        </span>
<span class="gi">+        return datetime.timedelta(seconds=int(seconds_left))</span>
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/progress_bar/formatters.py b/src/prompt_toolkit/shortcuts/progress_bar/formatters.py</span>
<span class="gh">index 8ff11a85..22f4b3c5 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/progress_bar/formatters.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/progress_bar/formatters.py</span>
<span class="gu">@@ -87,7 +87,14 @@ def _format_timedelta(timedelta: datetime.timedelta) -&gt;str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return hh:mm:ss, or mm:ss if the amount of hours is zero.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total_seconds = int(timedelta.total_seconds())</span>
<span class="gi">+    hours, remainder = divmod(total_seconds, 3600)</span>
<span class="gi">+    minutes, seconds = divmod(remainder, 60)</span>
<span class="gi">+</span>
<span class="gi">+    if hours &gt; 0:</span>
<span class="gi">+        return f&quot;{hours:02d}:{minutes:02d}:{seconds:02d}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return f&quot;{minutes:02d}:{seconds:02d}&quot;</span>


<span class="w"> </span>class TimeElapsed(Formatter):
<span class="gu">@@ -124,7 +131,20 @@ def _hue_to_rgb(hue: float) -&gt;tuple[int, int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Take hue between 0 and 1, return (r, g, b).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hue *= 6</span>
<span class="gi">+    x = 1 - abs((hue % 2) - 1)</span>
<span class="gi">+    if hue &lt; 1:</span>
<span class="gi">+        return (255, int(x * 255), 0)</span>
<span class="gi">+    elif hue &lt; 2:</span>
<span class="gi">+        return (int(x * 255), 255, 0)</span>
<span class="gi">+    elif hue &lt; 3:</span>
<span class="gi">+        return (0, 255, int(x * 255))</span>
<span class="gi">+    elif hue &lt; 4:</span>
<span class="gi">+        return (0, int(x * 255), 255)</span>
<span class="gi">+    elif hue &lt; 5:</span>
<span class="gi">+        return (int(x * 255), 0, 255)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return (255, 0, int(x * 255))</span>


<span class="w"> </span>class Rainbow(Formatter):
<span class="gu">@@ -142,4 +162,17 @@ def create_default_formatters() -&gt;list[Formatter]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the list of default formatters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [</span>
<span class="gi">+        Label(),</span>
<span class="gi">+        Text(&#39; &#39;),</span>
<span class="gi">+        Percentage(),</span>
<span class="gi">+        Text(&#39; &#39;),</span>
<span class="gi">+        Bar(),</span>
<span class="gi">+        Text(&#39; &#39;),</span>
<span class="gi">+        Progress(),</span>
<span class="gi">+        Text(&#39; &#39;),</span>
<span class="gi">+        Text(&#39;eta [&#39;, style=&#39;class:time-left&#39;),</span>
<span class="gi">+        TimeLeft(),</span>
<span class="gi">+        Text(&#39;]&#39;, style=&#39;class:time-left&#39;),</span>
<span class="gi">+        Text(&#39; &#39;),</span>
<span class="gi">+    ]</span>
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/prompt.py b/src/prompt_toolkit/shortcuts/prompt.py</span>
<span class="gh">index 452ef1a4..e4df47d0 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/prompt.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/prompt.py</span>
<span class="gu">@@ -81,7 +81,22 @@ def _split_multiline_prompt(get_prompt_text: _StyleAndTextTuplesCallable</span>
<span class="w"> </span>    returns the fragments to be shown on the lines above the input; and another
<span class="w"> </span>    one with the fragments to be shown at the first line of the input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def has_multiple_lines() -&gt; bool:</span>
<span class="gi">+        return &#39;\n&#39; in fragment_list_to_text(get_prompt_text())</span>
<span class="gi">+</span>
<span class="gi">+    def before():</span>
<span class="gi">+        fragments = get_prompt_text()</span>
<span class="gi">+        if has_multiple_lines():</span>
<span class="gi">+            return fragments[:-1]</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def first_input_line():</span>
<span class="gi">+        fragments = get_prompt_text()</span>
<span class="gi">+        if has_multiple_lines():</span>
<span class="gi">+            return fragments[-1:]</span>
<span class="gi">+        return fragments</span>
<span class="gi">+</span>
<span class="gi">+    return has_multiple_lines, before, first_input_line</span>


<span class="w"> </span>class _RPrompt(Window):
<span class="gu">@@ -306,32 +321,273 @@ class PromptSession(Generic[_T]):</span>
<span class="w"> </span>        This returns something that can be used as either a `Filter`
<span class="w"> </span>        or `Filter`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def dynamic() -&gt; bool:</span>
<span class="gi">+            value = getattr(self, attr_name)</span>
<span class="gi">+            return to_filter(value)()</span>
<span class="gi">+        return dynamic</span>

<span class="w"> </span>    def _create_default_buffer(self) -&gt;Buffer:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create and return the default input buffer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Buffer(</span>
<span class="gi">+            name=DEFAULT_BUFFER,</span>
<span class="gi">+            complete_while_typing=self._dyncond(&#39;complete_while_typing&#39;),</span>
<span class="gi">+            validate_while_typing=self._dyncond(&#39;validate_while_typing&#39;),</span>
<span class="gi">+            enable_history_search=self._dyncond(&#39;enable_history_search&#39;),</span>
<span class="gi">+            completer=DynamicCompleter(lambda: self.completer),</span>
<span class="gi">+            history=self.history,</span>
<span class="gi">+            validator=DynamicValidator(lambda: self.validator),</span>
<span class="gi">+            auto_suggest=DynamicAutoSuggest(lambda: self.auto_suggest),</span>
<span class="gi">+            accept_handler=self._accept_handler,</span>
<span class="gi">+            tempfile_suffix=lambda: to_str(self.tempfile_suffix or &#39;&#39;),</span>
<span class="gi">+            tempfile=lambda: to_str(self.tempfile or &#39;&#39;),</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _create_layout(self) -&gt;Layout:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create `Layout` for this prompt.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Create processors list.</span>
<span class="gi">+        processors = [</span>
<span class="gi">+            ConditionalProcessor(</span>
<span class="gi">+                AppendAutoSuggestion(), has_focus(DEFAULT_BUFFER) &amp; ~is_done</span>
<span class="gi">+            ),</span>
<span class="gi">+            ConditionalProcessor(</span>
<span class="gi">+                HighlightIncrementalSearchProcessor(),</span>
<span class="gi">+                has_focus(SEARCH_BUFFER),</span>
<span class="gi">+            ),</span>
<span class="gi">+            PasswordProcessor(),</span>
<span class="gi">+            BeforeInput(lambda: self._get_prompt()),</span>
<span class="gi">+            AfterInput(lambda: self._get_rprompt()),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        if self.input_processors:</span>
<span class="gi">+            processors.extend(self.input_processors)</span>
<span class="gi">+</span>
<span class="gi">+        # Create bottom toolbars.</span>
<span class="gi">+        bottom_toolbar = ConditionalContainer(</span>
<span class="gi">+            Window(</span>
<span class="gi">+                FormattedTextControl(lambda: self.bottom_toolbar),</span>
<span class="gi">+                style=&quot;class:bottom-toolbar.text&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            filter=Condition(lambda: self.bottom_toolbar is not None),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        search_toolbar = SearchToolbar(</span>
<span class="gi">+            search_buffer=self.search_buffer,</span>
<span class="gi">+            ignore_case=self._dyncond(&quot;search_ignore_case&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        search_buffer_control = SearchBufferControl(</span>
<span class="gi">+            buffer=self.search_buffer,</span>
<span class="gi">+            input_processors=[ReverseSearchProcessor()],</span>
<span class="gi">+            ignore_case=self._dyncond(&quot;search_ignore_case&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        system_toolbar = SystemToolbar(</span>
<span class="gi">+            enable_global_bindings=self._dyncond(&quot;enable_system_prompt&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        def get_search_buffer_control():</span>
<span class="gi">+            &quot;Return the UIControl to be focused when searching start.&quot;</span>
<span class="gi">+            if is_true(self._dyncond(&quot;multiline&quot;)):</span>
<span class="gi">+                return search_toolbar.control</span>
<span class="gi">+            else:</span>
<span class="gi">+                return search_buffer_control</span>
<span class="gi">+</span>
<span class="gi">+        default_buffer_control = BufferControl(</span>
<span class="gi">+            buffer=self.default_buffer,</span>
<span class="gi">+            search_buffer_control=get_search_buffer_control,</span>
<span class="gi">+            input_processors=processors,</span>
<span class="gi">+            include_default_input_processors=False,</span>
<span class="gi">+            lexer=DynamicLexer(lambda: self.lexer),</span>
<span class="gi">+            preview_search=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        default_buffer_window = Window(</span>
<span class="gi">+            default_buffer_control,</span>
<span class="gi">+            height=self._dyncond(&quot;multiline&quot;),</span>
<span class="gi">+            get_line_prefix=partial(</span>
<span class="gi">+                self._get_line_prefix, get_prompt_text_2=self._get_prompt_text_2</span>
<span class="gi">+            ),</span>
<span class="gi">+            wrap_lines=self._dyncond(&quot;wrap_lines&quot;),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def multi_column_complete_style():</span>
<span class="gi">+            return self.complete_style == CompleteStyle.MULTI_COLUMN</span>
<span class="gi">+</span>
<span class="gi">+        # Build the layout.</span>
<span class="gi">+        layout = HSplit(</span>
<span class="gi">+            [</span>
<span class="gi">+                # The main input, with completion menus floating on top of it.</span>
<span class="gi">+                FloatContainer(</span>
<span class="gi">+                    HSplit(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            ConditionalContainer(</span>
<span class="gi">+                                Window(</span>
<span class="gi">+                                    FormattedTextControl(self._get_prompt_text_1),</span>
<span class="gi">+                                    dont_extend_height=True,</span>
<span class="gi">+                                ),</span>
<span class="gi">+                                Condition(lambda: self._get_prompt_text_1() != &quot;&quot;),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                            ConditionalContainer(</span>
<span class="gi">+                                default_buffer_window,</span>
<span class="gi">+                                Condition(lambda: not is_true(self._dyncond(&quot;multiline&quot;))),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                            ConditionalContainer(</span>
<span class="gi">+                                HSplit(</span>
<span class="gi">+                                    [</span>
<span class="gi">+                                        default_buffer_window,</span>
<span class="gi">+                                        ValidationToolbar(),</span>
<span class="gi">+                                        system_toolbar,</span>
<span class="gi">+                                        search_toolbar,</span>
<span class="gi">+                                    ]</span>
<span class="gi">+                                ),</span>
<span class="gi">+                                Condition(lambda: is_true(self._dyncond(&quot;multiline&quot;))),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    [</span>
<span class="gi">+                        Float(</span>
<span class="gi">+                            xcursor=True,</span>
<span class="gi">+                            ycursor=True,</span>
<span class="gi">+                            content=CompletionsMenu(</span>
<span class="gi">+                                max_height=16,</span>
<span class="gi">+                                scroll_offset=1,</span>
<span class="gi">+                                extra_filter=has_focus(DEFAULT_BUFFER)</span>
<span class="gi">+                                &amp; ~multi_column_complete_style,</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        Float(</span>
<span class="gi">+                            xcursor=True,</span>
<span class="gi">+                            ycursor=True,</span>
<span class="gi">+                            content=MultiColumnCompletionsMenu(</span>
<span class="gi">+                                show_meta=True,</span>
<span class="gi">+                                extra_filter=has_focus(DEFAULT_BUFFER)</span>
<span class="gi">+                                &amp; multi_column_complete_style,</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    ],</span>
<span class="gi">+                ),</span>
<span class="gi">+                ConditionalContainer(search_toolbar, ~is_true(self._dyncond(&quot;multiline&quot;))),</span>
<span class="gi">+                bottom_toolbar,</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return Layout(layout, default_buffer_window)</span>

<span class="w"> </span>    def _create_application(self, editing_mode: EditingMode,
<span class="w"> </span>        erase_when_done: bool) -&gt;Application[_T]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create the `Application` object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        app = Application[_T](</span>
<span class="gi">+            layout=self.layout,</span>
<span class="gi">+            style=DynamicStyle(lambda: self.style),</span>
<span class="gi">+            include_default_pygments_style=self._dyncond(</span>
<span class="gi">+                &quot;include_default_pygments_style&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            style_transformation=DynamicStyleTransformation(</span>
<span class="gi">+                lambda: self.style_transformation</span>
<span class="gi">+            ),</span>
<span class="gi">+            key_bindings=merge_key_bindings(</span>
<span class="gi">+                [</span>
<span class="gi">+                    ConditionalKeyBindings(</span>
<span class="gi">+                        self.key_bindings,</span>
<span class="gi">+                        self._dyncond(&quot;enable_system_prompt&quot;)</span>
<span class="gi">+                        | Condition(lambda: self.key_bindings is None),</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    self._create_prompt_bindings(),</span>
<span class="gi">+                ]</span>
<span class="gi">+            ),</span>
<span class="gi">+            mouse_support=self._dyncond(&quot;mouse_support&quot;),</span>
<span class="gi">+            editing_mode=editing_mode,</span>
<span class="gi">+            erase_when_done=erase_when_done,</span>
<span class="gi">+            reverse_vi_search_direction=True,</span>
<span class="gi">+            color_depth=self.color_depth,</span>
<span class="gi">+            cursor=DynamicCursorShapeConfig(lambda: self.cursor),</span>
<span class="gi">+            on_reset=self.on_reset,</span>
<span class="gi">+            on_render=self.on_render,</span>
<span class="gi">+            after_render=self.after_render,</span>
<span class="gi">+            input=self._input,</span>
<span class="gi">+            output=self._output,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # During render time, make sure that we focus the right buffer.</span>
<span class="gi">+        app.layout.focus_stack.push(DEFAULT_BUFFER)</span>
<span class="gi">+</span>
<span class="gi">+        return app</span>

<span class="w"> </span>    def _create_prompt_bindings(self) -&gt;KeyBindings:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create the KeyBindings for a prompt application.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kb = KeyBindings()</span>
<span class="gi">+        handle = kb.add</span>
<span class="gi">+        default_focused = has_focus(DEFAULT_BUFFER)</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def do_accept() -&gt; bool:</span>
<span class="gi">+            return not is_done() and self.app.layout.has_focus(DEFAULT_BUFFER)</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;enter&quot;, filter=do_accept &amp; ~(vi_navigation_mode &amp; default_focused))</span>
<span class="gi">+        def _(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Accept input when enter has been pressed.&quot;</span>
<span class="gi">+            self._accept_handler(event.current_buffer)</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def readline_complete_style() -&gt; bool:</span>
<span class="gi">+            return self.complete_style == CompleteStyle.READLINE_LIKE</span>
<span class="gi">+</span>
<span class="gi">+        # Readline-style tab completion.</span>
<span class="gi">+        @handle(&quot;tab&quot;, filter=readline_complete_style &amp; default_focused)</span>
<span class="gi">+        def _(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Display completions (like Readline).&quot;</span>
<span class="gi">+            display_completions_like_readline(event)</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;c-c&quot;, filter=default_focused)</span>
<span class="gi">+        def _(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Abort when Control-C has been pressed.&quot;</span>
<span class="gi">+            event.app.exit(exception=KeyboardInterrupt, style=&quot;class:aborting&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def ctrl_d_condition() -&gt; bool:</span>
<span class="gi">+            &quot;&quot;&quot; Ctrl-D binding is only active when the default buffer is selected</span>
<span class="gi">+            and empty. &quot;&quot;&quot;</span>
<span class="gi">+            app = get_app()</span>
<span class="gi">+            return (</span>
<span class="gi">+                app.current_buffer.name == DEFAULT_BUFFER</span>
<span class="gi">+                and not app.current_buffer.text</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;c-d&quot;, filter=ctrl_d_condition &amp; default_focused)</span>
<span class="gi">+        def _(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Exit when Control-D has been pressed.&quot;</span>
<span class="gi">+            event.app.exit(exception=EOFError, style=&quot;class:exiting&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        suspend_supported = Condition(suspend_to_background_supported)</span>
<span class="gi">+</span>
<span class="gi">+        @Condition</span>
<span class="gi">+        def enable_open_in_editor() -&gt; bool:</span>
<span class="gi">+            return bool(self.enable_open_in_editor)</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;c-x&quot;, &quot;c-e&quot;, filter=~vi_mode &amp; enable_open_in_editor &amp; default_focused)</span>
<span class="gi">+        @handle(&quot;v&quot;, filter=vi_mode &amp; enable_open_in_editor &amp; default_focused)</span>
<span class="gi">+        def _(event: E) -&gt; None:</span>
<span class="gi">+            &quot;Open editor.&quot;</span>
<span class="gi">+            event.app.current_buffer.open_in_editor(event.app)</span>
<span class="gi">+</span>
<span class="gi">+        @handle(&quot;c-z&quot;, filter=suspend_supported)</span>
<span class="gi">+        def _(event: E) -&gt; None:</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Suspend process to background.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            event.app.suspend_to_background()</span>
<span class="gi">+</span>
<span class="gi">+        return merge_key_bindings([kb, load_auto_suggest_bindings()])</span>

<span class="w"> </span>    def prompt(self, message: (AnyFormattedText | None)=None, *,
<span class="w"> </span>        editing_mode: (EditingMode | None)=None, refresh_interval: (float |
<span class="gh">diff --git a/src/prompt_toolkit/shortcuts/utils.py b/src/prompt_toolkit/shortcuts/utils.py</span>
<span class="gh">index 44028b38..3e5106d3 100644</span>
<span class="gd">--- a/src/prompt_toolkit/shortcuts/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/shortcuts/utils.py</span>
<span class="gu">@@ -73,7 +73,39 @@ def print_formatted_text(*values: Any, sep: str=&#39; &#39;, end: str=&#39;\n&#39;, file: (</span>
<span class="w"> </span>    :param include_default_pygments_style: `bool`. Include the default Pygments
<span class="w"> </span>        style when set to `True` (the default).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Create a merged style</span>
<span class="gi">+    merged_style = _create_merged_style(style, include_default_pygments_style)</span>
<span class="gi">+</span>
<span class="gi">+    # Convert all values to formatted text</span>
<span class="gi">+    fragments = []</span>
<span class="gi">+    for i, value in enumerate(values):</span>
<span class="gi">+        fragments.extend(to_formatted_text(value))</span>
<span class="gi">+        if i &lt; len(values) - 1:</span>
<span class="gi">+            fragments.append((&#39;&#39;, sep))</span>
<span class="gi">+</span>
<span class="gi">+    fragments.append((&#39;&#39;, end))</span>
<span class="gi">+</span>
<span class="gi">+    # Get output object</span>
<span class="gi">+    if output is None:</span>
<span class="gi">+        if file is None:</span>
<span class="gi">+            file = get_app_session().output</span>
<span class="gi">+        output = create_output(stdout=file)</span>
<span class="gi">+</span>
<span class="gi">+    # Get color depth</span>
<span class="gi">+    if color_depth is None:</span>
<span class="gi">+        color_depth = ColorDepth.default()</span>
<span class="gi">+</span>
<span class="gi">+    # Create and print formatted text</span>
<span class="gi">+    formatted_text = FormattedText(fragments)</span>
<span class="gi">+    renderer_print_formatted_text(</span>
<span class="gi">+        output, formatted_text, merged_style,</span>
<span class="gi">+        color_depth=color_depth,</span>
<span class="gi">+        style_transformation=style_transformation,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Flush the output</span>
<span class="gi">+    if flush:</span>
<span class="gi">+        output.flush()</span>


<span class="w"> </span>def print_container(container: AnyContainer, file: (TextIO | None)=None,
<span class="gu">@@ -88,7 +120,17 @@ def print_container(container: AnyContainer, file: (TextIO | None)=None,</span>
<span class="w"> </span>        print_container(
<span class="w"> </span>            Frame(TextArea(text=&#39;Hello world!&#39;)))
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    output = create_output(stdout=file)</span>
<span class="gi">+    merged_style = _create_merged_style(style, include_default_pygments_style)</span>
<span class="gi">+</span>
<span class="gi">+    app = Application(</span>
<span class="gi">+        layout=Layout(container=container),</span>
<span class="gi">+        output=output,</span>
<span class="gi">+        style=merged_style,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    with app.output.capture_stdout():</span>
<span class="gi">+        app.run(in_thread=True)</span>


<span class="w"> </span>def _create_merged_style(style: (BaseStyle | None),
<span class="gu">@@ -96,25 +138,34 @@ def _create_merged_style(style: (BaseStyle | None),</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge user defined style with built-in style.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    styles = [default_ui_style()]</span>
<span class="gi">+    if include_default_pygments_style:</span>
<span class="gi">+        styles.append(default_pygments_style())</span>
<span class="gi">+    if style:</span>
<span class="gi">+        styles.append(style)</span>
<span class="gi">+    return merge_styles(styles)</span>


<span class="w"> </span>def clear() -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Clear the screen.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    output = get_app_session().output</span>
<span class="gi">+    output.erase_screen()</span>
<span class="gi">+    output.cursor_goto(0, 0)</span>
<span class="gi">+    output.flush()</span>


<span class="w"> </span>def set_title(text: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Set the terminal title.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    output = get_app_session().output</span>
<span class="gi">+    output.set_title(text)</span>


<span class="w"> </span>def clear_title() -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Erase the current title.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    set_title(&#39;&#39;)</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/base.py b/src/prompt_toolkit/styles/base.py</span>
<span class="gh">index a78d7080..47453d0a 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/base.py</span>
<span class="gu">@@ -63,7 +63,7 @@ class BaseStyle(metaclass=ABCMeta):</span>
<span class="w"> </span>            well as classnames (e.g. &quot;class:title&quot;).
<span class="w"> </span>        :param default: `Attrs` to be used if no styling was defined.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractproperty
<span class="w"> </span>    def style_rules(self) -&gt;list[tuple[str, str]]:
<span class="gu">@@ -71,7 +71,7 @@ class BaseStyle(metaclass=ABCMeta):</span>
<span class="w"> </span>        The list of style rules, used to create this style.
<span class="w"> </span>        (Required for `DynamicStyle` and `_MergedStyle` to work.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def invalidation_hash(self) -&gt;Hashable:
<span class="gu">@@ -80,13 +80,22 @@ class BaseStyle(metaclass=ABCMeta):</span>
<span class="w"> </span>        renderer knows that something in the style changed, and that everything
<span class="w"> </span>        has to be redrawn.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class DummyStyle(BaseStyle):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A style that doesn&#39;t style anything.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def get_attrs_for_style_str(self, style_str: str, default: Attrs=DEFAULT_ATTRS) -&gt;Attrs:</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def style_rules(self) -&gt;list[tuple[str, str]]:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt;Hashable:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class DynamicStyle(BaseStyle):
<span class="gu">@@ -99,3 +108,16 @@ class DynamicStyle(BaseStyle):</span>
<span class="w"> </span>    def __init__(self, get_style: Callable[[], BaseStyle | None]):
<span class="w"> </span>        self.get_style = get_style
<span class="w"> </span>        self._dummy = DummyStyle()
<span class="gi">+</span>
<span class="gi">+    def get_attrs_for_style_str(self, style_str: str, default: Attrs=DEFAULT_ATTRS) -&gt;Attrs:</span>
<span class="gi">+        style = self.get_style() or self._dummy</span>
<span class="gi">+        return style.get_attrs_for_style_str(style_str, default)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def style_rules(self) -&gt;list[tuple[str, str]]:</span>
<span class="gi">+        style = self.get_style() or self._dummy</span>
<span class="gi">+        return style.style_rules</span>
<span class="gi">+</span>
<span class="gi">+    def invalidation_hash(self) -&gt;Hashable:</span>
<span class="gi">+        style = self.get_style() or self._dummy</span>
<span class="gi">+        return (self.get_style, style.invalidation_hash())</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/defaults.py b/src/prompt_toolkit/styles/defaults.py</span>
<span class="gh">index 21bda00d..a2d7a8b4 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/defaults.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/defaults.py</span>
<span class="gu">@@ -102,7 +102,7 @@ def default_ui_style() -&gt;BaseStyle:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a default `Style` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Style(PROMPT_TOOLKIT_STYLE + COLORS_STYLE + WIDGETS_STYLE)</span>


<span class="w"> </span>@memoized()
<span class="gu">@@ -110,4 +110,4 @@ def default_pygments_style() -&gt;Style:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a `Style` object that contains the default Pygments style.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Style.from_dict(PYGMENTS_DEFAULT_STYLE)</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/pygments.py b/src/prompt_toolkit/styles/pygments.py</span>
<span class="gh">index 07c41282..a9a00fd4 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/pygments.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/pygments.py</span>
<span class="gu">@@ -29,7 +29,8 @@ def style_from_pygments_cls(pygments_style_cls: type[PygmentsStyle]) -&gt;Style:</span>

<span class="w"> </span>    :param pygments_style_cls: Pygments style class to start from.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    style_dict = pygments_style_cls.styles.copy()</span>
<span class="gi">+    return style_from_pygments_dict(style_dict)</span>


<span class="w"> </span>def style_from_pygments_dict(pygments_dict: dict[Token, str]) -&gt;Style:
<span class="gu">@@ -37,7 +38,10 @@ def style_from_pygments_dict(pygments_dict: dict[Token, str]) -&gt;Style:</span>
<span class="w"> </span>    Create a :class:`.Style` instance from a Pygments style dictionary.
<span class="w"> </span>    (One that maps Token objects to style strings.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    style_dict = {}</span>
<span class="gi">+    for token, style in pygments_dict.items():</span>
<span class="gi">+        style_dict[pygments_token_to_classname(token)] = style</span>
<span class="gi">+    return Style.from_dict(style_dict)</span>


<span class="w"> </span>def pygments_token_to_classname(token: Token) -&gt;str:
<span class="gu">@@ -47,4 +51,4 @@ def pygments_token_to_classname(token: Token) -&gt;str:</span>
<span class="w"> </span>    (Our Pygments lexer will also turn the tokens that pygments produces in a
<span class="w"> </span>    prompt_toolkit list of fragments that match these styling rules.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;pygments.&#39; + &#39;.&#39;.join(token).lower()</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/style.py b/src/prompt_toolkit/styles/style.py</span>
<span class="gh">index ddd7ee70..633c4a47 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/style.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/style.py</span>
<span class="gu">@@ -21,7 +21,17 @@ def parse_color(text: str) -&gt;str:</span>
<span class="w"> </span>    Like in Pygments, but also support the ANSI color names.
<span class="w"> </span>    (These will map to the colors of the 16 color palette.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if text in ANSI_COLOR_NAMES:</span>
<span class="gi">+        return text</span>
<span class="gi">+    if text.lower() in ANSI_COLOR_NAMES_ALIASES:</span>
<span class="gi">+        return ANSI_COLOR_NAMES_ALIASES[text.lower()]</span>
<span class="gi">+    if text.lower() in _named_colors_lowercase:</span>
<span class="gi">+        return _named_colors_lowercase[text.lower()]</span>
<span class="gi">+    if text.startswith(&#39;#&#39;) and len(text) in (4, 7, 9):</span>
<span class="gi">+        return text</span>
<span class="gi">+    if re.match(r&#39;^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?([0-9a-fA-F]{2})?$&#39;, text):</span>
<span class="gi">+        return text</span>
<span class="gi">+    raise ValueError(f&quot;Wrong color format: {text}&quot;)</span>


<span class="w"> </span>_EMPTY_ATTRS = Attrs(color=None, bgcolor=None, bold=None, underline=None,
<span class="gu">@@ -34,7 +44,8 @@ def _expand_classname(classname: str) -&gt;list[str]:</span>

<span class="w"> </span>    E.g. &#39;a.b.c&#39; becomes [&#39;a&#39;, &#39;a.b&#39;, &#39;a.b.c&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = classname.split(&#39;.&#39;)</span>
<span class="gi">+    return [&#39;.&#39;.join(parts[:i+1]) for i in range(len(parts))]</span>


<span class="w"> </span>def _parse_style_str(style_str: str) -&gt;Attrs:
<span class="gu">@@ -42,7 +53,19 @@ def _parse_style_str(style_str: str) -&gt;Attrs:</span>
<span class="w"> </span>    Take a style string, e.g.  &#39;bg:red #88ff00 class:title&#39;
<span class="w"> </span>    and return a `Attrs` instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    attrs = _EMPTY_ATTRS._asdict()</span>
<span class="gi">+    for part in style_str.split():</span>
<span class="gi">+        if part.startswith(&#39;bg:&#39;):</span>
<span class="gi">+            attrs[&#39;bgcolor&#39;] = parse_color(part[3:])</span>
<span class="gi">+        elif part.startswith(&#39;fg:&#39;) or part.startswith(&#39;color:&#39;):</span>
<span class="gi">+            attrs[&#39;color&#39;] = parse_color(part.split(&#39;:&#39;, 1)[1])</span>
<span class="gi">+        elif part in (&#39;bold&#39;, &#39;italic&#39;, &#39;underline&#39;, &#39;strike&#39;, &#39;reverse&#39;, &#39;hidden&#39;):</span>
<span class="gi">+            attrs[part] = True</span>
<span class="gi">+        elif part == &#39;blink&#39;:</span>
<span class="gi">+            attrs[&#39;blink&#39;] = True</span>
<span class="gi">+        elif &#39;:&#39; not in part:</span>
<span class="gi">+            attrs[&#39;color&#39;] = parse_color(part)</span>
<span class="gi">+    return Attrs(**attrs)</span>


<span class="w"> </span>CLASS_NAMES_RE = re.compile(&#39;^[a-z0-9.\\s_-]*$&#39;)
<span class="gu">@@ -110,14 +133,34 @@ class Style(BaseStyle):</span>
<span class="w"> </span>        :param style_dict: Style dictionary.
<span class="w"> </span>        :param priority: `Priority` value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if priority == Priority.DICT_KEY_ORDER:</span>
<span class="gi">+            return cls(list(style_dict.items()))</span>
<span class="gi">+        else:  # Priority.MOST_PRECISE</span>
<span class="gi">+            return cls(sorted(</span>
<span class="gi">+                style_dict.items(),</span>
<span class="gi">+                key=lambda item: (-len(item[0].split()), item[0]),</span>
<span class="gi">+                reverse=True</span>
<span class="gi">+            ))</span>

<span class="w"> </span>    def get_attrs_for_style_str(self, style_str: str, default: Attrs=
<span class="w"> </span>        DEFAULT_ATTRS) -&gt;Attrs:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get `Attrs` for the given style string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        list_of_attrs = [default]</span>
<span class="gi">+        class_names = set()</span>
<span class="gi">+</span>
<span class="gi">+        for part in style_str.split():</span>
<span class="gi">+            if part.startswith(&#39;class:&#39;):</span>
<span class="gi">+                class_names.update(_expand_classname(part[6:]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                list_of_attrs.append(_parse_style_str(part))</span>
<span class="gi">+</span>
<span class="gi">+        for names, attr in self.class_names_and_attrs:</span>
<span class="gi">+            if names &amp; class_names:</span>
<span class="gi">+                list_of_attrs.append(attr)</span>
<span class="gi">+</span>
<span class="gi">+        return _merge_attrs(list_of_attrs)</span>


<span class="w"> </span>_T = TypeVar(&#39;_T&#39;)
<span class="gu">@@ -129,14 +172,19 @@ def _merge_attrs(list_of_attrs: list[Attrs]) -&gt;Attrs:</span>
<span class="w"> </span>    Every `Attr` in the list can override the styling of the previous one. So,
<span class="w"> </span>    the last one has highest priority.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for attr in list_of_attrs:</span>
<span class="gi">+        for k, v in attr._asdict().items():</span>
<span class="gi">+            if v is not None:</span>
<span class="gi">+                result[k] = v</span>
<span class="gi">+    return Attrs(**result)</span>


<span class="w"> </span>def merge_styles(styles: list[BaseStyle]) -&gt;_MergedStyle:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge multiple `Style` objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _MergedStyle(styles)</span>


<span class="w"> </span>class _MergedStyle(BaseStyle):
<span class="gu">@@ -153,4 +201,13 @@ class _MergedStyle(BaseStyle):</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def _merged_style(self) -&gt;Style:
<span class="w"> </span>        &quot;&quot;&quot;The `Style` object that has the other styles merged together.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def get_style():</span>
<span class="gi">+            style_rules = []</span>
<span class="gi">+            for style in self.styles:</span>
<span class="gi">+                if isinstance(style, Style):</span>
<span class="gi">+                    style_rules.extend(style._style_rules)</span>
<span class="gi">+                elif isinstance(style, _MergedStyle):</span>
<span class="gi">+                    style_rules.extend(style._merged_style._style_rules)</span>
<span class="gi">+            return Style(style_rules)</span>
<span class="gi">+</span>
<span class="gi">+        return self._style.get(tuple(self.styles), get_style)</span>
<span class="gh">diff --git a/src/prompt_toolkit/styles/style_transformation.py b/src/prompt_toolkit/styles/style_transformation.py</span>
<span class="gh">index d15adc5c..ac34b6e4 100644</span>
<span class="gd">--- a/src/prompt_toolkit/styles/style_transformation.py</span>
<span class="gi">+++ b/src/prompt_toolkit/styles/style_transformation.py</span>
<span class="gu">@@ -69,7 +69,17 @@ class SwapLightAndDarkStyleTransformation(StyleTransformation):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the `Attrs` used when opposite luminosity should be used.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Attrs(</span>
<span class="gi">+            color=get_opposite_color(attrs.color),</span>
<span class="gi">+            bgcolor=get_opposite_color(attrs.bgcolor),</span>
<span class="gi">+            bold=attrs.bold,</span>
<span class="gi">+            italic=attrs.italic,</span>
<span class="gi">+            underline=attrs.underline,</span>
<span class="gi">+            strike=attrs.strike,</span>
<span class="gi">+            blink=attrs.blink,</span>
<span class="gi">+            reverse=attrs.reverse,</span>
<span class="gi">+            hidden=attrs.hidden</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ReverseStyleTransformation(StyleTransformation):
<span class="gu">@@ -129,14 +139,40 @@ class AdjustBrightnessStyleTransformation(StyleTransformation):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Parse `style.Attrs` color into RGB tuple.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if color.startswith(&#39;ansi&#39;):</span>
<span class="gi">+            # For ANSI colors, we&#39;ll use a predefined mapping</span>
<span class="gi">+            r, g, b = {</span>
<span class="gi">+                &#39;ansidefault&#39;: (0.5, 0.5, 0.5),</span>
<span class="gi">+                &#39;ansiblack&#39;: (0, 0, 0),</span>
<span class="gi">+                &#39;ansired&#39;: (0.5, 0, 0),</span>
<span class="gi">+                &#39;ansigreen&#39;: (0, 0.5, 0),</span>
<span class="gi">+                &#39;ansiyellow&#39;: (0.5, 0.5, 0),</span>
<span class="gi">+                &#39;ansiblue&#39;: (0, 0, 0.5),</span>
<span class="gi">+                &#39;ansimagenta&#39;: (0.5, 0, 0.5),</span>
<span class="gi">+                &#39;ansicyan&#39;: (0, 0.5, 0.5),</span>
<span class="gi">+                &#39;ansigray&#39;: (0.5, 0.5, 0.5),</span>
<span class="gi">+                &#39;ansiwhite&#39;: (1, 1, 1),</span>
<span class="gi">+                &#39;ansibrightblack&#39;: (0.25, 0.25, 0.25),</span>
<span class="gi">+                &#39;ansibrightred&#39;: (1, 0, 0),</span>
<span class="gi">+                &#39;ansibrightgreen&#39;: (0, 1, 0),</span>
<span class="gi">+                &#39;ansibrightyellow&#39;: (1, 1, 0),</span>
<span class="gi">+                &#39;ansibrightblue&#39;: (0, 0, 1),</span>
<span class="gi">+                &#39;ansibrightmagenta&#39;: (1, 0, 1),</span>
<span class="gi">+                &#39;ansibrightcyan&#39;: (0, 1, 1),</span>
<span class="gi">+            }.get(color, (0.5, 0.5, 0.5))  # Default to gray if not found</span>
<span class="gi">+        else:</span>
<span class="gi">+            # For hex colors</span>
<span class="gi">+            r = int(color[:2], 16) / 255.0</span>
<span class="gi">+            g = int(color[2:4], 16) / 255.0</span>
<span class="gi">+            b = int(color[4:], 16) / 255.0</span>
<span class="gi">+        return (r, g, b)</span>

<span class="w"> </span>    def _interpolate_brightness(self, value: float, min_brightness: float,
<span class="w"> </span>        max_brightness: float) -&gt;float:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Map the brightness to the (min_brightness..max_brightness) range.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return min_brightness + value * (max_brightness - min_brightness)</span>


<span class="w"> </span>class DummyStyleTransformation(StyleTransformation):
<span class="gu">@@ -182,7 +218,7 @@ def merge_style_transformations(style_transformations: Sequence[</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Merge multiple transformations together.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _MergedStyleTransformation(list(style_transformations))</span>


<span class="w"> </span>OPPOSITE_ANSI_COLOR_NAMES = {&#39;ansidefault&#39;: &#39;ansidefault&#39;, &#39;ansiblack&#39;:
<span class="gu">@@ -207,4 +243,18 @@ def get_opposite_color(colorname: (str | None)) -&gt;(str | None):</span>
<span class="w"> </span>    This is used for turning color schemes that work on a light background
<span class="w"> </span>    usable on a dark background.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if colorname is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if colorname in OPPOSITE_ANSI_COLOR_NAMES:</span>
<span class="gi">+        return OPPOSITE_ANSI_COLOR_NAMES[colorname]</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        r, g, b = int(colorname[:2], 16), int(colorname[2:4], 16), int(colorname[4:], 16)</span>
<span class="gi">+        h, l, s = rgb_to_hls(r / 255.0, g / 255.0, b / 255.0)</span>
<span class="gi">+        l = 1.0 - l  # Invert luminosity</span>
<span class="gi">+        r, g, b = [int(x * 255) for x in hls_to_rgb(h, l, s)]</span>
<span class="gi">+        return f&#39;{r:02x}{g:02x}{b:02x}&#39;</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # If we can&#39;t parse the color, return it unchanged</span>
<span class="gi">+        return colorname</span>
<span class="gh">diff --git a/src/prompt_toolkit/utils.py b/src/prompt_toolkit/utils.py</span>
<span class="gh">index 32a37c22..fdf68978 100644</span>
<span class="gd">--- a/src/prompt_toolkit/utils.py</span>
<span class="gi">+++ b/src/prompt_toolkit/utils.py</span>
<span class="gu">@@ -50,7 +50,7 @@ class Event(Generic[_Sender]):</span>

<span class="w"> </span>    def fire(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Alias for just calling the event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self()</span>

<span class="w"> </span>    def add_handler(self, handler: Callable[[_Sender], None]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -58,13 +58,13 @@ class Event(Generic[_Sender]):</span>
<span class="w"> </span>        (Handler should be a callable that takes exactly one parameter: the
<span class="w"> </span>        sender object.)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._handlers.append(handler)</span>

<span class="w"> </span>    def remove_handler(self, handler: Callable[[_Sender], None]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove a handler from this callback.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._handlers.remove(handler)</span>

<span class="w"> </span>    def __iadd__(self, handler: Callable[[_Sender], None]) -&gt;Event[_Sender]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -128,7 +128,7 @@ def get_cwidth(string: str) -&gt;int:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return width of a string. Wrapper around ``wcwidth``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _CHAR_SIZES_CACHE[string]</span>


<span class="w"> </span>def suspend_to_background_supported() -&gt;bool:
<span class="gu">@@ -136,47 +136,47 @@ def suspend_to_background_supported() -&gt;bool:</span>
<span class="w"> </span>    Returns `True` when the Python implementation supports
<span class="w"> </span>    suspend-to-background. This is typically `False&#39; on Windows systems.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(signal, &#39;SIGTSTP&#39;)</span>


<span class="w"> </span>def is_windows() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when we are using Windows.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sys.platform.startswith(&#39;win&#39;)</span>


<span class="w"> </span>def is_windows_vt100_supported() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when we are using Windows, but VT100 escape sequences are supported.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return is_windows() and &#39;WT_SESSION&#39; in os.environ</span>


<span class="w"> </span>def is_conemu_ansi() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the ConEmu Windows console is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return is_windows() and &#39;ConEmuANSI&#39; in os.environ</span>


<span class="w"> </span>def in_main_thread() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True when the current thread is the main thread.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return threading.current_thread() is threading.main_thread()</span>


<span class="w"> </span>def get_bell_environment_variable() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    True if env variable is set to true (true, TRUE, True, 1).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return os.environ.get(&#39;PROMPT_TOOLKIT_BELL&#39;, &#39;&#39;).lower() in (&#39;true&#39;, &#39;1&#39;)</span>


<span class="w"> </span>def get_term_environment_variable() -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Return the $TERM environment variable.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return os.environ.get(&#39;TERM&#39;, &#39;&#39;)</span>


<span class="w"> </span>_T = TypeVar(&#39;_T&#39;)
<span class="gu">@@ -196,17 +196,23 @@ def take_using_weights(items: list[_T], weights: list[int]) -&gt;Generator[_T,</span>
<span class="w"> </span>    :param weights: Integers representing the weight. (Numbers have to be
<span class="w"> </span>                    integers, not floats.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert len(items) == len(weights)</span>
<span class="gi">+    total_weight = sum(weights)</span>
<span class="gi">+    </span>
<span class="gi">+    while True:</span>
<span class="gi">+        for item, weight in zip(items, weights):</span>
<span class="gi">+            for _ in range(weight):</span>
<span class="gi">+                yield item</span>


<span class="w"> </span>def to_str(value: (Callable[[], str] | str)) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Turn callable or string into string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value() if callable(value) else value</span>


<span class="w"> </span>def to_int(value: (Callable[[], int] | int)) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Turn callable or int into int.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value() if callable(value) else value</span>


<span class="w"> </span>AnyFloat = Union[Callable[[], float], float]
<span class="gu">@@ -214,7 +220,7 @@ AnyFloat = Union[Callable[[], float], float]</span>

<span class="w"> </span>def to_float(value: AnyFloat) -&gt;float:
<span class="w"> </span>    &quot;&quot;&quot;Turn callable or float into float.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return value() if callable(value) else value</span>


<span class="w"> </span>def is_dumb_terminal(term: (str | None)=None) -&gt;bool:
<span class="gu">@@ -224,4 +230,6 @@ def is_dumb_terminal(term: (str | None)=None) -&gt;bool:</span>
<span class="w"> </span>    If so, we should fall back to the simplest possible form of line editing,
<span class="w"> </span>    without cursor positioning and color support.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if term is None:</span>
<span class="gi">+        term = get_term_environment_variable()</span>
<span class="gi">+    return term.lower() in (&#39;dumb&#39;, &#39;unknown&#39;)</span>
<span class="gh">diff --git a/src/prompt_toolkit/validation.py b/src/prompt_toolkit/validation.py</span>
<span class="gh">index 76ed1cda..8a618fdb 100644</span>
<span class="gd">--- a/src/prompt_toolkit/validation.py</span>
<span class="gi">+++ b/src/prompt_toolkit/validation.py</span>
<span class="gu">@@ -80,7 +80,7 @@ class Validator(metaclass=ABCMeta):</span>
<span class="w"> </span>        :param move_cursor_to_end: Move the cursor to the end of the input, if
<span class="w"> </span>            the input is invalid.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _ValidatorFromCallable(validate_func, error_message, move_cursor_to_end)</span>


<span class="w"> </span>class _ValidatorFromCallable(Validator):
<span class="gu">@@ -97,6 +97,14 @@ class _ValidatorFromCallable(Validator):</span>
<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return f&#39;Validator.from_callable({self.func!r})&#39;

<span class="gi">+    def validate(self, document: Document) -&gt;None:</span>
<span class="gi">+        if not self.func(document.text):</span>
<span class="gi">+            if self.move_cursor_to_end:</span>
<span class="gi">+                cursor_position = len(document.text)</span>
<span class="gi">+            else:</span>
<span class="gi">+                cursor_position = 0</span>
<span class="gi">+            raise ValidationError(cursor_position=cursor_position, message=self.error_message)</span>
<span class="gi">+</span>

<span class="w"> </span>class ThreadedValidator(Validator):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -112,13 +120,15 @@ class ThreadedValidator(Validator):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run the `validate` function in a thread.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        await run_in_executor_with_context(lambda: self.validator.validate(document))</span>


<span class="w"> </span>class DummyValidator(Validator):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Validator class that accepts any input.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def validate(self, document: Document) -&gt;None:</span>
<span class="gi">+        pass  # Always valid</span>


<span class="w"> </span>class ConditionalValidator(Validator):
<span class="gu">@@ -131,6 +141,10 @@ class ConditionalValidator(Validator):</span>
<span class="w"> </span>        self.validator = validator
<span class="w"> </span>        self.filter = to_filter(filter)

<span class="gi">+    def validate(self, document: Document) -&gt;None:</span>
<span class="gi">+        if self.filter():</span>
<span class="gi">+            self.validator.validate(document)</span>
<span class="gi">+</span>

<span class="w"> </span>class DynamicValidator(Validator):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -141,3 +155,8 @@ class DynamicValidator(Validator):</span>

<span class="w"> </span>    def __init__(self, get_validator: Callable[[], Validator | None]) -&gt;None:
<span class="w"> </span>        self.get_validator = get_validator
<span class="gi">+</span>
<span class="gi">+    def validate(self, document: Document) -&gt;None:</span>
<span class="gi">+        validator = self.get_validator()</span>
<span class="gi">+        if validator is not None:</span>
<span class="gi">+            validator.validate(document)</span>
<span class="gh">diff --git a/src/prompt_toolkit/widgets/base.py b/src/prompt_toolkit/widgets/base.py</span>
<span class="gh">index dbba3ba3..17f566ab 100644</span>
<span class="gd">--- a/src/prompt_toolkit/widgets/base.py</span>
<span class="gi">+++ b/src/prompt_toolkit/widgets/base.py</span>
<span class="gu">@@ -186,21 +186,21 @@ class TextArea:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The `Buffer` text.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.buffer.text</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def document(self) -&gt;Document:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The `Buffer` document (text + cursor position).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.buffer.document</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def accept_handler(self) -&gt;(BufferAcceptHandler | None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The accept handler. Called when the user accepts the input.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.buffer.accept_handler</span>

<span class="w"> </span>    def __pt_container__(self) -&gt;Container:
<span class="w"> </span>        return self.window
<span class="gu">@@ -286,7 +286,15 @@ class Button:</span>

<span class="w"> </span>    def _get_key_bindings(self) -&gt;KeyBindings:
<span class="w"> </span>        &quot;&quot;&quot;Key bindings for the Button.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kb = KeyBindings()</span>
<span class="gi">+</span>
<span class="gi">+        @kb.add(&#39; &#39;)</span>
<span class="gi">+        @kb.add(&#39;enter&#39;)</span>
<span class="gi">+        def _(event):</span>
<span class="gi">+            if self.handler is not None:</span>
<span class="gi">+                self.handler()</span>
<span class="gi">+</span>
<span class="gi">+        return kb</span>

<span class="w"> </span>    def __pt_container__(self) -&gt;Container:
<span class="w"> </span>        return self.window
<span class="gh">diff --git a/src/prompt_toolkit/widgets/toolbars.py b/src/prompt_toolkit/widgets/toolbars.py</span>
<span class="gh">index 69e19222..208772fd 100644</span>
<span class="gd">--- a/src/prompt_toolkit/widgets/toolbars.py</span>
<span class="gi">+++ b/src/prompt_toolkit/widgets/toolbars.py</span>
<span class="gu">@@ -111,17 +111,50 @@ class SearchToolbar:</span>


<span class="w"> </span>class _CompletionsToolbarControl(UIControl):
<span class="gd">-    pass</span>
<span class="gi">+    def create_content(self, width: int, height: int) -&gt; UIContent:</span>
<span class="gi">+        &quot;&quot;&quot;Create the content for the completions toolbar.&quot;&quot;&quot;</span>
<span class="gi">+        app = get_app()</span>
<span class="gi">+        if app.current_buffer.complete_state:</span>
<span class="gi">+            completions = app.current_buffer.complete_state.current_completions</span>
<span class="gi">+            index = app.current_buffer.complete_state.complete_index</span>
<span class="gi">+</span>
<span class="gi">+            # Format completions</span>
<span class="gi">+            formatted_completions = []</span>
<span class="gi">+            for i, completion in enumerate(completions):</span>
<span class="gi">+                if i == index:</span>
<span class="gi">+                    formatted_completions.append((&#39;class:completion-toolbar.completion.current&#39;, completion.display))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    formatted_completions.append((&#39;class:completion-toolbar.completion&#39;, completion.display))</span>
<span class="gi">+                </span>
<span class="gi">+                if i &lt; len(completions) - 1:</span>
<span class="gi">+                    formatted_completions.append((&#39;class:completion-toolbar.arrow&#39;, &#39; &gt; &#39;))</span>
<span class="gi">+</span>
<span class="gi">+            return UIContent(</span>
<span class="gi">+                lambda i: formatted_completions,</span>
<span class="gi">+                line_count=1,</span>
<span class="gi">+                show_cursor=False</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return UIContent(lambda i: [], line_count=1)</span>

<span class="gi">+    def is_focusable(self) -&gt; bool:</span>
<span class="gi">+        return False</span>

<span class="gd">-class CompletionsToolbar:</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self.container = ConditionalContainer(content=Window(</span>
<span class="gd">-            _CompletionsToolbarControl(), height=1, style=</span>
<span class="gd">-            &#39;class:completion-toolbar&#39;), filter=has_completions)</span>
<span class="gi">+class CompletionsToolbar:</span>

<span class="gd">-    def __pt_container__(self) -&gt;Container:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self.control = _CompletionsToolbarControl()</span>
<span class="gi">+        self.container = ConditionalContainer(</span>
<span class="gi">+            content=Window(</span>
<span class="gi">+                self.control,</span>
<span class="gi">+                height=1,</span>
<span class="gi">+                style=&#39;class:completion-toolbar&#39;</span>
<span class="gi">+            ),</span>
<span class="gi">+            filter=has_completions</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __pt_container__(self) -&gt; Container:</span>
<span class="w"> </span>        return self.container
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>