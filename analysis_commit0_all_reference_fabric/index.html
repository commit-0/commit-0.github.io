
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference fabric - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-fabric" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference fabric
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1must_be_given_explicit_env_arg" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::must_be_given_explicit_env_arg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1additional_kwargsforwards_arbitrary_kwargs_to_init" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::additional_kwargs::forwards_arbitrary_kwargs_to_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1additional_kwargssubservient_to_runtime_overrides" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::additional_kwargs::subservient_to_runtime_overrides
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1additional_kwargsconnect_kwargs_also_merged_with_imported_values" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::additional_kwargs::connect_kwargs_also_merged_with_imported_values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingsalways_use_pty" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::always_use_pty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingsforward_agent" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::forward_agent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingsgateway" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::gateway
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingskey_filenamebase" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::key_filename::base
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingskey_filenameis_not_set_if_none" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::key_filename::is_not_set_if_None
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingsno_agent" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::no_agent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingspasswordset_just_to_connect_kwargs_if_sudo_password_set" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::password::set_just_to_connect_kwargs_if_sudo_password_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingspasswordset_to_both_password_fields_if_necessary" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::password::set_to_both_password_fields_if_necessary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingsssh_config_path" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::ssh_config_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingssudo_password" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::sudo_password
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingssudo_prompt" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::sudo_prompt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingstimeout" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingsuse_ssh_config" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::use_ssh_config
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configpyconfig_from_v1var_mappingswarn_only" class="md-nav__link">
    <span class="md-ellipsis">
      config.py::Config_::from_v1::var_mappings::warn_only
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_initssh_configproxy_jumpwins_over_default" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::init::ssh_config::proxy_jump::wins_over_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_initssh_configproxy_jumpwins_over_configuration" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::init::ssh_config::proxy_jump::wins_over_configuration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_initssh_configproxy_jumpgateway_connections_get_parent_connection_configs" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::init::ssh_config::proxy_jump::gateway_Connections_get_parent_connection_configs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1must_be_given_explicit_env_arg" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::must_be_given_explicit_env_arg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1obtaining_configdefaults_to_calling_config_from_v1" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::obtaining_config::defaults_to_calling_Config_from_v1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1obtaining_configmay_be_given_config_explicitly" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::obtaining_config::may_be_given_config_explicitly
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1additional_kwargsforwards_arbitrary_kwargs_to_init" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::additional_kwargs::forwards_arbitrary_kwargs_to_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1additional_kwargsconflicting_kwargs_win_over_v1_env_values" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::additional_kwargs::conflicting_kwargs_win_over_v1_env_values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1var_mappingshost_string" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::var_mappings::host_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1var_mappingsnone_host_string_errors_usefully" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::var_mappings::None_host_string_errors_usefully
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1var_mappingsuser" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::var_mappings::user
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1var_mappingsportbasic" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::var_mappings::port::basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1var_mappingsportcasted_to_int" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::var_mappings::port::casted_to_int
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_from_v1var_mappingsportnot_supplied_if_given_in_host_string" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::from_v1::var_mappings::port::not_supplied_if_given_in_host_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_shellcalls_remoteshell_run_with_all_kwargs_and_returns_its_result" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::shell::calls_RemoteShell_run_with_all_kwargs_and_returns_its_result
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_shellraises_typeerror_for_disallowed_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::shell::raises_TypeError_for_disallowed_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#connectionpyconnection_shellhonors_config_system_for_allowed_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      connection.py::Connection_::shell::honors_config_system_for_allowed_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grouppythreadinggroup_executes_arguments_on_contents_run_via_threadingrun" class="md-nav__link">
    <span class="md-ellipsis">
      group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[run]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grouppythreadinggroup_executes_arguments_on_contents_run_via_threadingsudo" class="md-nav__link">
    <span class="md-ellipsis">
      group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[sudo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grouppythreadinggroup_executes_arguments_on_contents_run_via_threadingput" class="md-nav__link">
    <span class="md-ellipsis">
      group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[put]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grouppythreadinggroup_executes_arguments_on_contents_run_via_threadingget" class="md-nav__link">
    <span class="md-ellipsis">
      group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[get]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transferpytransfer_getmode_concernspreserves_remote_mode_by_default" class="md-nav__link">
    <span class="md-ellipsis">
      transfer.py::Transfer_::get::mode_concerns::preserves_remote_mode_by_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transferpytransfer_getmode_concernsallows_disabling_remote_mode_preservation" class="md-nav__link">
    <span class="md-ellipsis">
      transfer.py::Transfer_::get::mode_concerns::allows_disabling_remote_mode_preservation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-fabric"><strong>Reference (Gold)</strong>: fabric</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">353</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">41</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">7</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">401</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">401</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="configpyconfig_from_v1must_be_given_explicit_env_arg">config.py::Config_::from_v1::must_be_given_explicit_env_arg</h3>
<details><summary> <pre>config.py::Config_::from_v1::must_be_given_explicit_env_arg</pre></summary><pre>
self = <config.Config_.from_v1 object at 0x7ee71bdefb80>

    def must_be_given_explicit_env_arg(self):
        config = Config.from_v1(
>           env=Lexicon(self.env, sudo_password="sikrit")
        )
E       AttributeError: 'from_v1' object has no attribute 'env'

tests/config.py:77: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1additional_kwargsforwards_arbitrary_kwargs_to_init">config.py::Config_::from_v1::additional_kwargs::forwards_arbitrary_kwargs_to_init</h3>
<details><summary> <pre>config.py::Config_::from_v1::additional_kwargs::forwards_arbitrary_kwargs_to_init</pre></summary><pre>
self = <config.Config_.from_v1.additional_kwargs object at 0x7ee71bdef9a0>

    def forwards_arbitrary_kwargs_to_init(self):
        config = Config.from_v1(
>           self.env,
            # Vanilla Invoke
            overrides={"some": "value"},
            # Fabric
            system_ssh_path="/what/ever",
        )
E       AttributeError: 'additional_kwargs' object has no attribute 'env'

tests/config.py:84: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1additional_kwargssubservient_to_runtime_overrides">config.py::Config_::from_v1::additional_kwargs::subservient_to_runtime_overrides</h3>
<details><summary> <pre>config.py::Config_::from_v1::additional_kwargs::subservient_to_runtime_overrides</pre></summary><pre>
self = <config.Config_.from_v1.additional_kwargs object at 0x7ee71bded900>

    def subservient_to_runtime_overrides(self):
>       env = self.env
E       AttributeError: 'additional_kwargs' object has no attribute 'env'

tests/config.py:94: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1additional_kwargsconnect_kwargs_also_merged_with_imported_values">config.py::Config_::from_v1::additional_kwargs::connect_kwargs_also_merged_with_imported_values</h3>
<details><summary> <pre>config.py::Config_::from_v1::additional_kwargs::connect_kwargs_also_merged_with_imported_values</pre></summary><pre>
self = <config.Config_.from_v1.additional_kwargs object at 0x7ee71cd70c70>

    def connect_kwargs_also_merged_with_imported_values(self):
>       self.env["key_filename"] = "whatever"
E       AttributeError: 'additional_kwargs' object has no attribute 'env'

tests/config.py:102: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingsalways_use_pty">config.py::Config_::from_v1::var_mappings::always_use_pty</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::always_use_pty</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd70610>

    def always_use_pty(self):
        # Testing both due to v1-didn't-use-None-default issues
>       config = self._conf(always_use_pty=True)

tests/config.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd70610>
kwargs = {'always_use_pty': True}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingsforward_agent">config.py::Config_::from_v1::var_mappings::forward_agent</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::forward_agent</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd73c10>

    def forward_agent(self):
>       config = self._conf(forward_agent=True)

tests/config.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd73c10>
kwargs = {'forward_agent': True}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingsgateway">config.py::Config_::from_v1::var_mappings::gateway</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::gateway</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71bdefa90>

    def gateway(self):
>       config = self._conf(gateway="bastion.host")

tests/config.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings object at 0x7ee71bdefa90>
kwargs = {'gateway': 'bastion.host'}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingskey_filenamebase">config.py::Config_::from_v1::var_mappings::key_filename::base</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::key_filename::base</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings.key_filename object at 0x7ee71cd704f0>

    def base(self):
>       config = self._conf(key_filename="/some/path")

tests/config.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings.key_filename object at 0x7ee71cd704f0>
kwargs = {'key_filename': '/some/path'}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'key_filename' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingskey_filenameis_not_set_if_none">config.py::Config_::from_v1::var_mappings::key_filename::is_not_set_if_None</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::key_filename::is_not_set_if_None</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings.key_filename object at 0x7ee71bb90580>

    def is_not_set_if_None(self):
>       config = self._conf(key_filename=None)

tests/config.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings.key_filename object at 0x7ee71bb90580>
kwargs = {'key_filename': None}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'key_filename' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingsno_agent">config.py::Config_::from_v1::var_mappings::no_agent</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::no_agent</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71bded0f0>

    def no_agent(self):
>       config = self._conf()

tests/config.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings object at 0x7ee71bded0f0>
kwargs = {}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingspasswordset_just_to_connect_kwargs_if_sudo_password_set">config.py::Config_::from_v1::var_mappings::password::set_just_to_connect_kwargs_if_sudo_password_set</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::password::set_just_to_connect_kwargs_if_sudo_password_set</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings.password object at 0x7ee71bb91ab0>

    def set_just_to_connect_kwargs_if_sudo_password_set(self):
        # NOTE: default faux env has sudo_password set already...
>       config = self._conf(password="screaming-firehawks")

tests/config.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings.password object at 0x7ee71bb91ab0>
kwargs = {'password': 'screaming-firehawks'}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'password' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingspasswordset_to_both_password_fields_if_necessary">config.py::Config_::from_v1::var_mappings::password::set_to_both_password_fields_if_necessary</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::password::set_to_both_password_fields_if_necessary</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings.password object at 0x7ee71bb92320>

    def set_to_both_password_fields_if_necessary(self):
>       config = self._conf(password="sikrit", sudo_password=None)

tests/config.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings.password object at 0x7ee71bb92320>
kwargs = {'password': 'sikrit', 'sudo_password': None}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'password' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingsssh_config_path">config.py::Config_::from_v1::var_mappings::ssh_config_path</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::ssh_config_path</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71bdef610>

    def ssh_config_path(self):
>       self.env.ssh_config_path = "/where/ever"
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:155: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingssudo_password">config.py::Config_::from_v1::var_mappings::sudo_password</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::sudo_password</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd70ca0>

    def sudo_password(self):
>       config = self._conf(sudo_password="sikrit")

tests/config.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd70ca0>
kwargs = {'sudo_password': 'sikrit'}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingssudo_prompt">config.py::Config_::from_v1::var_mappings::sudo_prompt</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::sudo_prompt</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd72c50>

    def sudo_prompt(self):
>       config = self._conf(sudo_prompt="password???")

tests/config.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd72c50>
kwargs = {'sudo_prompt': 'password???'}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingstimeout">config.py::Config_::from_v1::var_mappings::timeout</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::timeout</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd737f0>

    def timeout(self):
>       config = self._conf(timeout=15)

tests/config.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd737f0>
kwargs = {'timeout': 15}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingsuse_ssh_config">config.py::Config_::from_v1::var_mappings::use_ssh_config</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::use_ssh_config</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd71540>

    def use_ssh_config(self):
        # Testing both due to v1-didn't-use-None-default issues
>       config = self._conf(use_ssh_config=True)

tests/config.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd71540>
kwargs = {'use_ssh_config': True}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="configpyconfig_from_v1var_mappingswarn_only">config.py::Config_::from_v1::var_mappings::warn_only</h3>
<details><summary> <pre>config.py::Config_::from_v1::var_mappings::warn_only</pre></summary><pre>
self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd70af0>

    def warn_only(self):
        # Testing both due to v1-didn't-use-None-default issues
>       config = self._conf(warn_only=True)

tests/config.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config.Config_.from_v1.var_mappings object at 0x7ee71cd70af0>
kwargs = {'warn_only': True}

    def _conf(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/config.py:72: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_initssh_configproxy_jumpwins_over_default">connection.py::Connection_::init::ssh_config::proxy_jump::wins_over_default</h3>
<details><summary> <pre>connection.py::Connection_::init::ssh_config::proxy_jump::wins_over_default</pre></summary><pre>
self = <connection.Connection_.init.ssh_config.proxy_jump object at 0x7ee71aa6c670>

    def wins_over_default(self):
        cxn = self._runtime_cxn(basename="proxyjump")
>       assert cxn.gateway == self._expected_gw
E       AttributeError: 'proxy_jump' object has no attribute '_expected_gw'

tests/connection.py:388: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_initssh_configproxy_jumpwins_over_configuration">connection.py::Connection_::init::ssh_config::proxy_jump::wins_over_configuration</h3>
<details><summary> <pre>connection.py::Connection_::init::ssh_config::proxy_jump::wins_over_configuration</pre></summary><pre>
self = <connection.Connection_.init.ssh_config.proxy_jump object at 0x7ee71aa6ffa0>

    def wins_over_configuration(self):
        cxn = self._runtime_cxn(
            basename="proxyjump", overrides={"gateway": "meh gw"}
        )
>       assert cxn.gateway == self._expected_gw
E       AttributeError: 'proxy_jump' object has no attribute '_expected_gw'

tests/connection.py:394: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_initssh_configproxy_jumpgateway_connections_get_parent_connection_configs">connection.py::Connection_::init::ssh_config::proxy_jump::gateway_Connections_get_parent_connection_configs</h3>
<details><summary> <pre>connection.py::Connection_::init::ssh_config::proxy_jump::gateway_Connections_get_parent_connection_configs</pre></summary><pre>
self = <connection.Connection_.init.ssh_config.proxy_jump object at 0x7ee71aa5bac0>

    def gateway_Connections_get_parent_connection_configs(self):
        conf = self._runtime_config(
            basename="proxyjump",
            overrides={"some_random_option": "a-value"},
        )
        cxn = Connection("runtime", config=conf)
        # Safety
        assert cxn.config is conf
>       assert cxn.gateway == self._expected_gw
E       AttributeError: 'proxy_jump' object has no attribute '_expected_gw'

tests/connection.py:449: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1must_be_given_explicit_env_arg">connection.py::Connection_::from_v1::must_be_given_explicit_env_arg</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::must_be_given_explicit_env_arg</pre></summary><pre>
self = <connection.Connection_.from_v1 object at 0x7ee71aa6f940>

    def must_be_given_explicit_env_arg(self):
>       cxn = Connection.from_v1(self.env)
E       AttributeError: 'from_v1' object has no attribute 'env'

tests/connection.py:526: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1obtaining_configdefaults_to_calling_config_from_v1">connection.py::Connection_::from_v1::obtaining_config::defaults_to_calling_Config_from_v1</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::obtaining_config::defaults_to_calling_Config_from_v1</pre></summary><pre>
self = <connection.Connection_.from_v1.obtaining_config object at 0x7ee71aa58a00>
Config_from_v1 = <MagicMock name='from_v1' id='139531069055536'>

    @patch("fabric.connection.Config.from_v1")
    def defaults_to_calling_Config_from_v1(self, Config_from_v1):
>       Connection.from_v1(self.env)
E       AttributeError: 'obtaining_config' object has no attribute 'env'

tests/connection.py:532: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1obtaining_configmay_be_given_config_explicitly">connection.py::Connection_::from_v1::obtaining_config::may_be_given_config_explicitly</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::obtaining_config::may_be_given_config_explicitly</pre></summary><pre>
self = <connection.Connection_.from_v1.obtaining_config object at 0x7ee71aa58ca0>
Config_from_v1 = <MagicMock name='from_v1' id='139531050104672'>

    @patch("fabric.connection.Config.from_v1")
    def may_be_given_config_explicitly(self, Config_from_v1):
        # Arguably a dupe of regular Connection constructor behavior,
        # but whatever.
>       Connection.from_v1(env=self.env, config=Config())
E       AttributeError: 'obtaining_config' object has no attribute 'env'

tests/connection.py:539: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1additional_kwargsforwards_arbitrary_kwargs_to_init">connection.py::Connection_::from_v1::additional_kwargs::forwards_arbitrary_kwargs_to_init</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::additional_kwargs::forwards_arbitrary_kwargs_to_init</pre></summary><pre>
self = <connection.Connection_.from_v1.additional_kwargs object at 0x7ee71aa5bd00>

    def forwards_arbitrary_kwargs_to_init(self):
        cxn = Connection.from_v1(
>           self.env,
            connect_kwargs={"foo": "bar"},
            inline_ssh_env=False,
            connect_timeout=15,
        )
E       AttributeError: 'additional_kwargs' object has no attribute 'env'

tests/connection.py:546: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1additional_kwargsconflicting_kwargs_win_over_v1_env_values">connection.py::Connection_::from_v1::additional_kwargs::conflicting_kwargs_win_over_v1_env_values</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::additional_kwargs::conflicting_kwargs_win_over_v1_env_values</pre></summary><pre>
self = <connection.Connection_.from_v1.additional_kwargs object at 0x7ee71aa59270>

    def conflicting_kwargs_win_over_v1_env_values(self):
>       env = Lexicon(self.env)
E       AttributeError: 'additional_kwargs' object has no attribute 'env'

tests/connection.py:556: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1var_mappingshost_string">connection.py::Connection_::from_v1::var_mappings::host_string</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::var_mappings::host_string</pre></summary><pre>
self = <connection.Connection_.from_v1.var_mappings object at 0x7ee71aa583a0>

    def host_string(self):
>       cxn = self._cxn()  # default is 'localghost'

tests/connection.py:566: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <connection.Connection_.from_v1.var_mappings object at 0x7ee71aa583a0>
kwargs = {}

    def _cxn(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/connection.py:522: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1var_mappingsnone_host_string_errors_usefully">connection.py::Connection_::from_v1::var_mappings::None_host_string_errors_usefully</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::var_mappings::None_host_string_errors_usefully</pre></summary><pre>
self = <connection.Connection_.from_v1.var_mappings object at 0x7ee71aa58160>

    @raises(InvalidV1Env)
    def None_host_string_errors_usefully(self):
>       self._cxn(host_string=None)

tests/connection.py:571: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <connection.Connection_.from_v1.var_mappings object at 0x7ee71aa58160>
kwargs = {'host_string': None}

    def _cxn(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/connection.py:522: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1var_mappingsuser">connection.py::Connection_::from_v1::var_mappings::user</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::var_mappings::user</pre></summary><pre>
self = <connection.Connection_.from_v1.var_mappings object at 0x7ee71aa582e0>

    def user(self):
>       cxn = self._cxn(user="space")

tests/connection.py:574: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <connection.Connection_.from_v1.var_mappings object at 0x7ee71aa582e0>
kwargs = {'user': 'space'}

    def _cxn(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'var_mappings' object has no attribute 'env'

tests/connection.py:522: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1var_mappingsportbasic">connection.py::Connection_::from_v1::var_mappings::port::basic</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::var_mappings::port::basic</pre></summary><pre>
self = <connection.Connection_.from_v1.var_mappings.port object at 0x7ee71aa5b2b0>

    def basic(self):
>       cxn = self._cxn(port=2222)

tests/connection.py:579: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <connection.Connection_.from_v1.var_mappings.port object at 0x7ee71aa5b2b0>
kwargs = {'port': 2222}

    def _cxn(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'port' object has no attribute 'env'

tests/connection.py:522: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1var_mappingsportcasted_to_int">connection.py::Connection_::from_v1::var_mappings::port::casted_to_int</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::var_mappings::port::casted_to_int</pre></summary><pre>
self = <connection.Connection_.from_v1.var_mappings.port object at 0x7ee71aa5afe0>

    def casted_to_int(self):
>       cxn = self._cxn(port="2222")

tests/connection.py:583: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <connection.Connection_.from_v1.var_mappings.port object at 0x7ee71aa5afe0>
kwargs = {'port': '2222'}

    def _cxn(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'port' object has no attribute 'env'

tests/connection.py:522: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_from_v1var_mappingsportnot_supplied_if_given_in_host_string">connection.py::Connection_::from_v1::var_mappings::port::not_supplied_if_given_in_host_string</h3>
<details><summary> <pre>connection.py::Connection_::from_v1::var_mappings::port::not_supplied_if_given_in_host_string</pre></summary><pre>
self = <connection.Connection_.from_v1.var_mappings.port object at 0x7ee71aa5ac50>

    def not_supplied_if_given_in_host_string(self):
>       cxn = self._cxn(host_string="localghost:3737", port=2222)

tests/connection.py:587: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <connection.Connection_.from_v1.var_mappings.port object at 0x7ee71aa5ac50>
kwargs = {'host_string': 'localghost:3737', 'port': 2222}

    def _cxn(self, **kwargs):
>       self.env.update(kwargs)
E       AttributeError: 'port' object has no attribute 'env'

tests/connection.py:522: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_shellcalls_remoteshell_run_with_all_kwargs_and_returns_its_result">connection.py::Connection_::shell::calls_RemoteShell_run_with_all_kwargs_and_returns_its_result</h3>
<details><summary> <pre>connection.py::Connection_::shell::calls_RemoteShell_run_with_all_kwargs_and_returns_its_result</pre></summary><pre>
self = <connection.Connection_.shell object at 0x7ee71b1b94b0>
RemoteShell = <MagicMock name='RemoteShell' id='139531068965456'>
client = <MagicMock name='SSHClient()' id='139531050737216'>

    @patch(remote_shell_path)
    def calls_RemoteShell_run_with_all_kwargs_and_returns_its_result(
        self, RemoteShell, client
    ):
        remote = RemoteShell.return_value
        cxn = Connection("host")
        kwargs = dict(
            env={"foo": "bar"},
            replace_env=True,
            encoding="utf-16",
            in_stream=StringIO("meh"),
            watchers=["meh"],
        )
        result = cxn.shell(**kwargs)
        RemoteShell.assert_any_call(context=cxn)
        assert remote.run.call_count == 1
        # Expect explicit use of default values for all kwarg-settings
        # besides what shell() itself tweaks
>       expected = dict(self.defaults, pty=True, command=None, **kwargs)
E       AttributeError: 'shell' object has no attribute 'defaults'

tests/connection.py:1079: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_shellraises_typeerror_for_disallowed_kwargs">connection.py::Connection_::shell::raises_TypeError_for_disallowed_kwargs</h3>
<details><summary> <pre>connection.py::Connection_::shell::raises_TypeError_for_disallowed_kwargs</pre></summary><pre>
self = <connection.Connection_.shell object at 0x7ee71b1b97e0>
client = <MagicMock name='SSHClient()' id='139531055947040'>

    def raises_TypeError_for_disallowed_kwargs(self, client):
>       for key in self.defaults.keys():
E       AttributeError: 'shell' object has no attribute 'defaults'

tests/connection.py:1084: AttributeError
</pre>
</details>
<h3 id="connectionpyconnection_shellhonors_config_system_for_allowed_kwargs">connection.py::Connection_::shell::honors_config_system_for_allowed_kwargs</h3>
<details><summary> <pre>connection.py::Connection_::shell::honors_config_system_for_allowed_kwargs</pre></summary><pre>
self = <connection.Connection_.shell object at 0x7ee71c335000>
RemoteShell = <MagicMock name='RemoteShell' id='139531067579200'>
client = <MagicMock name='SSHClient()' id='139531051286640'>

    @patch(remote_shell_path)
    def honors_config_system_for_allowed_kwargs(self, RemoteShell, client):
        remote = RemoteShell.return_value
        allowed = dict(
            env={"foo": "bar"},
            replace_env=True,
            encoding="utf-16",
            in_stream="sentinel",
            watchers=["sentinel"],
        )
        ignored = dict(echo=True, hide="foo")  # Spot check
        config = Config({"run": dict(allowed, **ignored)})
        cxn = Connection("host", config=config)
        cxn.shell()
        kwargs = remote.run.call_args[1]
        for key, value in allowed.items():
            assert kwargs[key] == value
        for key, value in ignored.items():
>           assert kwargs[key] == self.defaults[key]
E           AttributeError: 'shell' object has no attribute 'defaults'

tests/connection.py:1119: AttributeError
</pre>
</details>
<h3 id="grouppythreadinggroup_executes_arguments_on_contents_run_via_threadingrun">group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[run]</h3>
<details><summary> <pre>group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[run]</pre></summary><pre>
self = <group.ThreadingGroup_ object at 0x7ee71b1e55a0>
Thread = <MagicMock name='ExceptionHandlingThread' id='139531025413888'>
Queue = <MagicMock name='Queue' id='139531025408608'>, method = 'run'

    @mark.parametrize("method", ALL_METHODS)
    @patch("fabric.group.Queue")
    @patch("fabric.group.ExceptionHandlingThread")
    def executes_arguments_on_contents_run_via_threading(
        self, Thread, Queue, method
    ):
        queue = Queue.return_value
>       g = ThreadingGroup.from_connections(self.cxns)
E       AttributeError: 'ThreadingGroup_' object has no attribute 'cxns'

tests/group.py:193: AttributeError
</pre>
</details>
<h3 id="grouppythreadinggroup_executes_arguments_on_contents_run_via_threadingsudo">group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[sudo]</h3>
<details><summary> <pre>group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[sudo]</pre></summary><pre>
self = <group.ThreadingGroup_ object at 0x7ee71b1e5750>
Thread = <MagicMock name='ExceptionHandlingThread' id='139531055022384'>
Queue = <MagicMock name='Queue' id='139531055026032'>, method = 'sudo'

    @mark.parametrize("method", ALL_METHODS)
    @patch("fabric.group.Queue")
    @patch("fabric.group.ExceptionHandlingThread")
    def executes_arguments_on_contents_run_via_threading(
        self, Thread, Queue, method
    ):
        queue = Queue.return_value
>       g = ThreadingGroup.from_connections(self.cxns)
E       AttributeError: 'ThreadingGroup_' object has no attribute 'cxns'

tests/group.py:193: AttributeError
</pre>
</details>
<h3 id="grouppythreadinggroup_executes_arguments_on_contents_run_via_threadingput">group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[put]</h3>
<details><summary> <pre>group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[put]</pre></summary><pre>
self = <group.ThreadingGroup_ object at 0x7ee71b1e58a0>
Thread = <MagicMock name='ExceptionHandlingThread' id='139531054858000'>
Queue = <MagicMock name='Queue' id='139531054844560'>, method = 'put'

    @mark.parametrize("method", ALL_METHODS)
    @patch("fabric.group.Queue")
    @patch("fabric.group.ExceptionHandlingThread")
    def executes_arguments_on_contents_run_via_threading(
        self, Thread, Queue, method
    ):
        queue = Queue.return_value
>       g = ThreadingGroup.from_connections(self.cxns)
E       AttributeError: 'ThreadingGroup_' object has no attribute 'cxns'

tests/group.py:193: AttributeError
</pre>
</details>
<h3 id="grouppythreadinggroup_executes_arguments_on_contents_run_via_threadingget">group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[get]</h3>
<details><summary> <pre>group.py::ThreadingGroup_::executes_arguments_on_contents_run_via_threading[get]</pre></summary><pre>
self = <group.ThreadingGroup_ object at 0x7ee71b1e5960>
Thread = <MagicMock name='ExceptionHandlingThread' id='139531075984720'>
Queue = <MagicMock name='Queue' id='139531050177088'>, method = 'get'

    @mark.parametrize("method", ALL_METHODS)
    @patch("fabric.group.Queue")
    @patch("fabric.group.ExceptionHandlingThread")
    def executes_arguments_on_contents_run_via_threading(
        self, Thread, Queue, method
    ):
        queue = Queue.return_value
>       g = ThreadingGroup.from_connections(self.cxns)
E       AttributeError: 'ThreadingGroup_' object has no attribute 'cxns'

tests/group.py:193: AttributeError
</pre>
</details>
<h3 id="transferpytransfer_getmode_concernspreserves_remote_mode_by_default">transfer.py::Transfer_::get::mode_concerns::preserves_remote_mode_by_default</h3>
<details><summary> <pre>transfer.py::Transfer_::get::mode_concerns::preserves_remote_mode_by_default</pre></summary><pre>
self = <transfer.Transfer_.get.mode_concerns object at 0x7ee71aa2cb20>
sftp = (<fabric.transfer.Transfer object at 0x7ee719538940>, <MagicMock name='SSHClient().open_sftp()' id='139531027226608'>, <MagicMock name='os' id='139531027491440'>)

    def preserves_remote_mode_by_default(self, sftp):
        transfer, client, mock_os = sftp
        # Attributes obj reflecting a realistic 'extended' octal mode
>       client.stat.return_value = self.attrs
E       AttributeError: 'mode_concerns' object has no attribute 'attrs'

tests/transfer.py:139: AttributeError
</pre>
</details>
<h3 id="transferpytransfer_getmode_concernsallows_disabling_remote_mode_preservation">transfer.py::Transfer_::get::mode_concerns::allows_disabling_remote_mode_preservation</h3>
<details><summary> <pre>transfer.py::Transfer_::get::mode_concerns::allows_disabling_remote_mode_preservation</pre></summary><pre>
self = <transfer.Transfer_.get.mode_concerns object at 0x7ee71aa2c6a0>
sftp = (<fabric.transfer.Transfer object at 0x7ee7195c07f0>, <MagicMock name='SSHClient().open_sftp()' id='139531027654320'>, <MagicMock name='os' id='139531027610736'>)

    def allows_disabling_remote_mode_preservation(self, sftp):
        transfer, client, mock_os = sftp
>       client.stat.return_value = self.attrs
E       AttributeError: 'mode_concerns' object has no attribute 'attrs'

tests/transfer.py:147: AttributeError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/fabric/_version.py b/fabric/_version.py</span>
<span class="gh">index 16e1eb75..f9a16f88 100644</span>
<span class="gd">--- a/fabric/_version.py</span>
<span class="gi">+++ b/fabric/_version.py</span>
<span class="gu">@@ -1,2 +1,2 @@</span>
<span class="gd">-__version_info__ = 3, 2, 2</span>
<span class="gd">-__version__ = &#39;.&#39;.join(map(str, __version_info__))</span>
<span class="gi">+__version_info__ = (3, 2, 2)</span>
<span class="gi">+__version__ = &quot;.&quot;.join(map(str, __version_info__))</span>
<span class="gh">diff --git a/fabric/auth.py b/fabric/auth.py</span>
<span class="gh">index b3460d6b..b09529ad 100644</span>
<span class="gd">--- a/fabric/auth.py</span>
<span class="gi">+++ b/fabric/auth.py</span>
<span class="gu">@@ -1,8 +1,15 @@</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from getpass import getpass
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from paramiko import Agent, PKey
<span class="gd">-from paramiko.auth_strategy import AuthStrategy, Password, InMemoryPrivateKey, OnDiskPrivateKey</span>
<span class="gi">+from paramiko.auth_strategy import (</span>
<span class="gi">+    AuthStrategy,</span>
<span class="gi">+    Password,</span>
<span class="gi">+    InMemoryPrivateKey,</span>
<span class="gi">+    OnDiskPrivateKey,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from .util import win32


<span class="gu">@@ -30,6 +37,35 @@ class OpenSSHAuthStrategy(AuthStrategy):</span>
<span class="w"> </span>    .. versionadded:: 3.1
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    # Skimming openssh code (ssh.c and sshconnect2.c) gives us the following</span>
<span class="gi">+    # behavior to crib from:</span>
<span class="gi">+    # - parse cli (initializing identity_files if any given)</span>
<span class="gi">+    # - parse user config, then system config _unless_ user gave cli config</span>
<span class="gi">+    # path; this will also add to identity_files if any IdentityFile found</span>
<span class="gi">+    # (after the CLI ones)</span>
<span class="gi">+    # - lots of value init, string interpolation, etc</span>
<span class="gi">+    # - if no other identity_files exist at this point, fill in the ~/.ssh/</span>
<span class="gi">+    # defaults:</span>
<span class="gi">+    #   - in order: rsa, dsa, ecdsa, ecdsa_sk, ed25519, xmss (???)</span>
<span class="gi">+    # - initial connection (ssh_connect() - presumably handshake/hostkey/kex)</span>
<span class="gi">+    # - load all identity_files (and any implicit certs of those)</span>
<span class="gi">+    # - eventually runs pubkey_prepare() which, per its own comment,</span>
<span class="gi">+    # loads/assembles key material in this order:</span>
<span class="gi">+    #   - certs - config file, then cli, skipping any non-user (?) certs</span>
<span class="gi">+    #   - agent keys that are also listed in the config file</span>
<span class="gi">+    #   - agent keys _not_ listed in config files</span>
<span class="gi">+    #   - non-agent config file keys (this seems like it includes cli and</span>
<span class="gi">+    #   implicit defaults)</span>
<span class="gi">+    #   - once list is assembled, drop anything not listed in configured pubkey</span>
<span class="gi">+    #   algorithms list</span>
<span class="gi">+    # - auth_none to get list of acceptable authmethods</span>
<span class="gi">+    # - while-loops along that, or next returned, list of acceptable</span>
<span class="gi">+    # authmethods, using a handler table, so eg a &#39;standard&#39; openssh on both</span>
<span class="gi">+    # ends might start with &#39;publickey,password,keyboard-interactive&#39;; so it&#39;ll</span>
<span class="gi">+    # try all pubkeys found above before eventually trying a password prompt,</span>
<span class="gi">+    # and then if THAT fails, it will try kbdint call-and-response (similar to</span>
<span class="gi">+    # password but where server sends you the prompt(s) it wants displayed)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, ssh_config, fabric_config, username):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Extends superclass with additional inputs.
<span class="gu">@@ -48,10 +84,124 @@ class OpenSSHAuthStrategy(AuthStrategy):</span>
<span class="w"> </span>        super().__init__(ssh_config=ssh_config)
<span class="w"> </span>        self.username = username
<span class="w"> </span>        self.config = fabric_config
<span class="gi">+        # NOTE: Agent seems designed to always &#39;work&#39; even w/o a live agent, in</span>
<span class="gi">+        # which case it just yields an empty key list.</span>
<span class="w"> </span>        self.agent = Agent()

<span class="gi">+    def get_pubkeys(self):</span>
<span class="gi">+        # Similar to OpenSSH, we first obtain sources in arbitrary order,</span>
<span class="gi">+        # tracking where they came from and whether they were a cert.</span>
<span class="gi">+        config_certs, config_keys, cli_certs, cli_keys = [], [], [], []</span>
<span class="gi">+        # Our own configuration is treated like `ssh -i`, partly because that&#39;s</span>
<span class="gi">+        # where our -i flag ends up, partly because our config data has no</span>
<span class="gi">+        # direct OpenSSH analogue (it&#39;s _not_ in your ssh_config! it&#39;s</span>
<span class="gi">+        # elsewhere!)</span>
<span class="gi">+        for path in self.config.authentication.identities:</span>
<span class="gi">+            try:</span>
<span class="gi">+                key = PKey.from_path(path)</span>
<span class="gi">+            except FileNotFoundError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            source = OnDiskPrivateKey(</span>
<span class="gi">+                username=self.username,</span>
<span class="gi">+                source=&quot;python-config&quot;,</span>
<span class="gi">+                path=path,</span>
<span class="gi">+                pkey=key,</span>
<span class="gi">+            )</span>
<span class="gi">+            (cli_certs if key.public_blob else cli_keys).append(source)</span>
<span class="gi">+        # Now load ssh_config IdentityFile directives, sorting again into</span>
<span class="gi">+        # cert/key split.</span>
<span class="gi">+        # NOTE: Config&#39;s ssh_config loader already behaves OpenSSH-compatibly:</span>
<span class="gi">+        # if the user supplied a custom ssh_config file path, that is the only</span>
<span class="gi">+        # one loaded; otherwise, it loads and merges the user and system paths.</span>
<span class="gi">+        # TODO: CertificateFile support? Most people seem to rely on the</span>
<span class="gi">+        # implicit cert loading of IdentityFile...</span>
<span class="gi">+        for path in self.ssh_config.get(&quot;identityfile&quot;, []):</span>
<span class="gi">+            try:</span>
<span class="gi">+                key = PKey.from_path(path)</span>
<span class="gi">+            except FileNotFoundError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            source = OnDiskPrivateKey(</span>
<span class="gi">+                username=self.username,</span>
<span class="gi">+                source=&quot;ssh-config&quot;,</span>
<span class="gi">+                path=path,</span>
<span class="gi">+                pkey=key,</span>
<span class="gi">+            )</span>
<span class="gi">+            (config_certs if key.public_blob else config_keys).append(source)</span>
<span class="gi">+        # At this point, if we&#39;ve still got no keys or certs, look in the</span>
<span class="gi">+        # default user locations.</span>
<span class="gi">+        if not any((config_certs, config_keys, cli_certs, cli_keys)):</span>
<span class="gi">+            user_ssh = Path.home() / f&quot;{&#39;&#39; if win32 else &#39;.&#39;}ssh&quot;</span>
<span class="gi">+            # This is the same order OpenSSH documents as using.</span>
<span class="gi">+            for type_ in (&quot;rsa&quot;, &quot;ecdsa&quot;, &quot;ed25519&quot;, &quot;dsa&quot;):</span>
<span class="gi">+                path = user_ssh / f&quot;id_{type_}&quot;</span>
<span class="gi">+                try:</span>
<span class="gi">+                    key = PKey.from_path(path)</span>
<span class="gi">+                except FileNotFoundError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                source = OnDiskPrivateKey(</span>
<span class="gi">+                    username=self.username,</span>
<span class="gi">+                    source=&quot;implicit-home&quot;,</span>
<span class="gi">+                    path=path,</span>
<span class="gi">+                    pkey=key,</span>
<span class="gi">+                )</span>
<span class="gi">+                dest = config_certs if key.public_blob else config_keys</span>
<span class="gi">+                dest.append(source)</span>
<span class="gi">+        # TODO: set agent_keys to empty list if IdentitiesOnly is true</span>
<span class="gi">+        agent_keys = self.agent.get_keys()</span>
<span class="gi">+</span>
<span class="gi">+        # We&#39;ve finally loaded everything; now it&#39;s time to throw them upwards</span>
<span class="gi">+        # in the intended order...</span>
<span class="gi">+        # TODO: define subroutine that dedupes (&amp; honors</span>
<span class="gi">+        # PubkeyAcceptedAlgorithms) then rub that on all of the below.</span>
<span class="gi">+        # First, all local _certs_ (config wins over cli, for w/e reason)</span>
<span class="gi">+        for source in config_certs:</span>
<span class="gi">+            yield source</span>
<span class="gi">+        for source in cli_certs:</span>
<span class="gi">+            yield source</span>
<span class="gi">+        # Then all agent keys, first ones that were also mentioned in configs,</span>
<span class="gi">+        # then &#39;new&#39; ones not found in configs.</span>
<span class="gi">+        deferred_agent_keys = []</span>
<span class="gi">+        for key in agent_keys:</span>
<span class="gi">+            config_index = None</span>
<span class="gi">+            for i, config_key in enumerate(config_keys):</span>
<span class="gi">+                if config_key.pkey == key:</span>
<span class="gi">+                    config_index = i</span>
<span class="gi">+                    break</span>
<span class="gi">+            if config_index:</span>
<span class="gi">+                yield InMemoryPrivateKey(username=self.username, pkey=key)</span>
<span class="gi">+                # Nuke so it doesn&#39;t get re-yielded by regular conf keys bit</span>
<span class="gi">+                del config_keys[config_index]</span>
<span class="gi">+            else:</span>
<span class="gi">+                deferred_agent_keys.append(key)</span>
<span class="gi">+        for key in deferred_agent_keys:</span>
<span class="gi">+            yield InMemoryPrivateKey(username=self.username, pkey=key)</span>
<span class="gi">+        for source in cli_keys:</span>
<span class="gi">+            yield source</span>
<span class="gi">+        # This will now be just the config-borne keys that were NOT in agent</span>
<span class="gi">+        for source in config_keys:</span>
<span class="gi">+            yield source</span>
<span class="gi">+</span>
<span class="gi">+    def get_sources(self):</span>
<span class="gi">+        # TODO: initial none-auth + tracking the response&#39;s allowed types.</span>
<span class="gi">+        # however, SSHClient never did this deeply, and there&#39;s no guarantee a</span>
<span class="gi">+        # server _will_ send anything but &quot;any&quot; anyways...</span>
<span class="gi">+        # Public keys of all kinds typically first.</span>
<span class="gi">+        yield from self.get_pubkeys()</span>
<span class="gi">+        user = self.username</span>
<span class="gi">+        prompter = partial(getpass, f&quot;{user}&#39;s password: &quot;)</span>
<span class="gi">+        # Then password.</span>
<span class="gi">+        yield Password(username=self.username, password_getter=prompter)</span>
<span class="gi">+</span>
<span class="gi">+    def authenticate(self, *args, **kwargs):</span>
<span class="gi">+        # Just do what our parent would, except make sure we close() after.</span>
<span class="gi">+        try:</span>
<span class="gi">+            return super().authenticate(*args, **kwargs)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.close()</span>
<span class="gi">+</span>
<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Shut down any resources we ourselves opened up.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: bare try/except here as &quot;best effort&quot;? ugh</span>
<span class="gi">+        self.agent.close()</span>
<span class="gh">diff --git a/fabric/config.py b/fabric/config.py</span>
<span class="gh">index e501ed72..c56f3434 100644</span>
<span class="gd">--- a/fabric/config.py</span>
<span class="gi">+++ b/fabric/config.py</span>
<span class="gu">@@ -1,8 +1,10 @@</span>
<span class="w"> </span>import copy
<span class="w"> </span>import errno
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>from invoke.config import Config as InvokeConfig, merge_dicts
<span class="w"> </span>from paramiko.config import SSHConfig
<span class="gi">+</span>
<span class="w"> </span>from .runners import Remote, RemoteShell
<span class="w"> </span>from .util import get_local_user, debug

<span class="gu">@@ -33,7 +35,8 @@ class Config(InvokeConfig):</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    prefix = &#39;fabric&#39;</span>
<span class="gi">+</span>
<span class="gi">+    prefix = &quot;fabric&quot;</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_v1(cls, env, **kwargs):
<span class="gu">@@ -60,7 +63,43 @@ class Config(InvokeConfig):</span>

<span class="w"> </span>        .. versionadded:: 2.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: automagic import, if we can find a way to test that</span>
<span class="gi">+        # Use overrides level (and preserve whatever the user may have given)</span>
<span class="gi">+        # TODO: we really do want arbitrary number of config levels, don&#39;t we?</span>
<span class="gi">+        # TODO: most of these need more care re: only filling in when they</span>
<span class="gi">+        # differ from the v1 default. As-is these won&#39;t overwrite runtime</span>
<span class="gi">+        # overrides (due to .setdefault) but they may still be filling in empty</span>
<span class="gi">+        # values to stomp on lower level config levels...</span>
<span class="gi">+        data = kwargs.pop(&quot;overrides&quot;, {})</span>
<span class="gi">+        # TODO: just use a dataproxy or defaultdict??</span>
<span class="gi">+        for subdict in (&quot;connect_kwargs&quot;, &quot;run&quot;, &quot;sudo&quot;, &quot;timeouts&quot;):</span>
<span class="gi">+            data.setdefault(subdict, {})</span>
<span class="gi">+        # PTY use</span>
<span class="gi">+        data[&quot;run&quot;].setdefault(&quot;pty&quot;, env.always_use_pty)</span>
<span class="gi">+        # Gateway</span>
<span class="gi">+        data.setdefault(&quot;gateway&quot;, env.gateway)</span>
<span class="gi">+        # Agent forwarding</span>
<span class="gi">+        data.setdefault(&quot;forward_agent&quot;, env.forward_agent)</span>
<span class="gi">+        # Key filename(s)</span>
<span class="gi">+        if env.key_filename is not None:</span>
<span class="gi">+            data[&quot;connect_kwargs&quot;].setdefault(&quot;key_filename&quot;, env.key_filename)</span>
<span class="gi">+        # Load keys from agent?</span>
<span class="gi">+        data[&quot;connect_kwargs&quot;].setdefault(&quot;allow_agent&quot;, not env.no_agent)</span>
<span class="gi">+        data.setdefault(&quot;ssh_config_path&quot;, env.ssh_config_path)</span>
<span class="gi">+        # Sudo password</span>
<span class="gi">+        data[&quot;sudo&quot;].setdefault(&quot;password&quot;, env.sudo_password)</span>
<span class="gi">+        # Vanilla password (may be used for regular and/or sudo, depending)</span>
<span class="gi">+        passwd = env.password</span>
<span class="gi">+        data[&quot;connect_kwargs&quot;].setdefault(&quot;password&quot;, passwd)</span>
<span class="gi">+        if not data[&quot;sudo&quot;][&quot;password&quot;]:</span>
<span class="gi">+            data[&quot;sudo&quot;][&quot;password&quot;] = passwd</span>
<span class="gi">+        data[&quot;sudo&quot;].setdefault(&quot;prompt&quot;, env.sudo_prompt)</span>
<span class="gi">+        data[&quot;timeouts&quot;].setdefault(&quot;connect&quot;, env.timeout)</span>
<span class="gi">+        data.setdefault(&quot;load_ssh_configs&quot;, env.use_ssh_config)</span>
<span class="gi">+        data[&quot;run&quot;].setdefault(&quot;warn&quot;, env.warn_only)</span>
<span class="gi">+        # Put overrides back for real constructor and go</span>
<span class="gi">+        kwargs[&quot;overrides&quot;] = data</span>
<span class="gi">+        return cls(**kwargs)</span>

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -93,18 +132,33 @@ class Config(InvokeConfig):</span>
<span class="w"> </span>            `set_runtime_ssh_path`, which will inform exactly what
<span class="w"> </span>            `load_ssh_config` does.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        ssh_config = kwargs.pop(&#39;ssh_config&#39;, None)</span>
<span class="gd">-        lazy = kwargs.get(&#39;lazy&#39;, False)</span>
<span class="gd">-        self.set_runtime_ssh_path(kwargs.pop(&#39;runtime_ssh_path&#39;, None))</span>
<span class="gd">-        system_path = kwargs.pop(&#39;system_ssh_path&#39;, &#39;/etc/ssh/ssh_config&#39;)</span>
<span class="gi">+        # Tease out our own kwargs.</span>
<span class="gi">+        # TODO: consider moving more stuff out of __init__ and into methods so</span>
<span class="gi">+        # there&#39;s less of this sort of splat-args + pop thing? Eh.</span>
<span class="gi">+        ssh_config = kwargs.pop(&quot;ssh_config&quot;, None)</span>
<span class="gi">+        lazy = kwargs.get(&quot;lazy&quot;, False)</span>
<span class="gi">+        self.set_runtime_ssh_path(kwargs.pop(&quot;runtime_ssh_path&quot;, None))</span>
<span class="gi">+        system_path = kwargs.pop(&quot;system_ssh_path&quot;, &quot;/etc/ssh/ssh_config&quot;)</span>
<span class="w"> </span>        self._set(_system_ssh_path=system_path)
<span class="gd">-        self._set(_user_ssh_path=kwargs.pop(&#39;user_ssh_path&#39;, &#39;~/.ssh/config&#39;))</span>
<span class="gi">+        self._set(_user_ssh_path=kwargs.pop(&quot;user_ssh_path&quot;, &quot;~/.ssh/config&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        # Record whether we were given an explicit object (so other steps know</span>
<span class="gi">+        # whether to bother loading from disk or not)</span>
<span class="gi">+        # This needs doing before super __init__ as that calls our post_init</span>
<span class="w"> </span>        explicit = ssh_config is not None
<span class="w"> </span>        self._set(_given_explicit_object=explicit)
<span class="gi">+</span>
<span class="gi">+        # Arrive at some non-None SSHConfig object (upon which to run .parse()</span>
<span class="gi">+        # later, in _load_ssh_file())</span>
<span class="w"> </span>        if ssh_config is None:
<span class="w"> </span>            ssh_config = SSHConfig()
<span class="w"> </span>        self._set(base_ssh_config=ssh_config)
<span class="gi">+</span>
<span class="gi">+        # Now that our own attributes have been prepared &amp; kwargs yanked, we</span>
<span class="gi">+        # can fall up into parent __init__()</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="gi">+</span>
<span class="gi">+        # And finally perform convenience non-lazy bits if needed</span>
<span class="w"> </span>        if not lazy:
<span class="w"> </span>            self.load_ssh_config()

<span class="gu">@@ -117,7 +171,7 @@ class Config(InvokeConfig):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set(_runtime_ssh_path=path)</span>

<span class="w"> </span>    def load_ssh_config(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -128,7 +182,54 @@ class Config(InvokeConfig):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Update the runtime SSH config path (assumes enough regular config</span>
<span class="gi">+        # levels have been loaded that anyone wanting to transmit this info</span>
<span class="gi">+        # from a &#39;vanilla&#39; Invoke config, has gotten it set.)</span>
<span class="gi">+        if self.ssh_config_path:</span>
<span class="gi">+            self._runtime_ssh_path = self.ssh_config_path</span>
<span class="gi">+        # Load files from disk if we weren&#39;t given an explicit SSHConfig in</span>
<span class="gi">+        # __init__</span>
<span class="gi">+        if not self._given_explicit_object:</span>
<span class="gi">+            self._load_ssh_files()</span>
<span class="gi">+</span>
<span class="gi">+    def clone(self, *args, **kwargs):</span>
<span class="gi">+        # TODO: clone() at this point kinda-sorta feels like it&#39;s retreading</span>
<span class="gi">+        # __reduce__ and the related (un)pickling stuff...</span>
<span class="gi">+        # Get cloned obj.</span>
<span class="gi">+        # NOTE: Because we also extend .init_kwargs, the actual core SSHConfig</span>
<span class="gi">+        # data is passed in at init time (ensuring no files get loaded a 2nd,</span>
<span class="gi">+        # etc time) and will already be present, so we don&#39;t need to set</span>
<span class="gi">+        # .base_ssh_config ourselves. Similarly, there&#39;s no need to worry about</span>
<span class="gi">+        # how the SSH config paths may be inaccurate until below; nothing will</span>
<span class="gi">+        # be referencing them.</span>
<span class="gi">+        new = super().clone(*args, **kwargs)</span>
<span class="gi">+        # Copy over our custom attributes, so that the clone still resembles us</span>
<span class="gi">+        # re: recording where the data originally came from (in case anything</span>
<span class="gi">+        # re-runs ._load_ssh_files(), for example).</span>
<span class="gi">+        for attr in (</span>
<span class="gi">+            &quot;_runtime_ssh_path&quot;,</span>
<span class="gi">+            &quot;_system_ssh_path&quot;,</span>
<span class="gi">+            &quot;_user_ssh_path&quot;,</span>
<span class="gi">+        ):</span>
<span class="gi">+            setattr(new, attr, getattr(self, attr))</span>
<span class="gi">+        # Load SSH configs, in case they weren&#39;t prior to now (e.g. a vanilla</span>
<span class="gi">+        # Invoke clone(into), instead of a us-to-us clone.)</span>
<span class="gi">+        self.load_ssh_config()</span>
<span class="gi">+        # All done</span>
<span class="gi">+        return new</span>
<span class="gi">+</span>
<span class="gi">+    def _clone_init_kwargs(self, *args, **kw):</span>
<span class="gi">+        # Parent kwargs</span>
<span class="gi">+        kwargs = super()._clone_init_kwargs(*args, **kw)</span>
<span class="gi">+        # Transmit our internal SSHConfig via explicit-obj kwarg, thus</span>
<span class="gi">+        # bypassing any file loading. (Our extension of clone() above copies</span>
<span class="gi">+        # over other attributes as well so that the end result looks consistent</span>
<span class="gi">+        # with reality.)</span>
<span class="gi">+        new_config = SSHConfig()</span>
<span class="gi">+        # TODO: as with other spots, this implies SSHConfig needs a cleaner</span>
<span class="gi">+        # public API re: creating and updating its core data.</span>
<span class="gi">+        new_config._config = copy.deepcopy(self.base_ssh_config._config)</span>
<span class="gi">+        return dict(kwargs, ssh_config=new_config)</span>

<span class="w"> </span>    def _load_ssh_files(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -139,7 +240,20 @@ class Config(InvokeConfig):</span>

<span class="w"> </span>        :returns: ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: does this want to more closely ape the behavior of</span>
<span class="gi">+        # InvokeConfig.load_files? re: having a _found attribute for each that</span>
<span class="gi">+        # determines whether to load or skip</span>
<span class="gi">+        if self._runtime_ssh_path is not None:</span>
<span class="gi">+            path = self._runtime_ssh_path</span>
<span class="gi">+            # Manually blow up like open() (_load_ssh_file normally doesn&#39;t)</span>
<span class="gi">+            if not os.path.exists(path):</span>
<span class="gi">+                raise FileNotFoundError(</span>
<span class="gi">+                    errno.ENOENT, &quot;No such file or directory&quot;, path</span>
<span class="gi">+                )</span>
<span class="gi">+            self._load_ssh_file(os.path.expanduser(path))</span>
<span class="gi">+        elif self.load_ssh_configs:</span>
<span class="gi">+            for path in (self._user_ssh_path, self._system_ssh_path):</span>
<span class="gi">+                self._load_ssh_file(os.path.expanduser(path))</span>

<span class="w"> </span>    def _load_ssh_file(self, path):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -149,7 +263,15 @@ class Config(InvokeConfig):</span>

<span class="w"> </span>        :returns: ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if os.path.isfile(path):</span>
<span class="gi">+            old_rules = len(self.base_ssh_config._config)</span>
<span class="gi">+            with open(path) as fd:</span>
<span class="gi">+                self.base_ssh_config.parse(fd)</span>
<span class="gi">+            new_rules = len(self.base_ssh_config._config)</span>
<span class="gi">+            msg = &quot;Loaded {} new ssh_config rules from {!r}&quot;</span>
<span class="gi">+            debug(msg.format(new_rules - old_rules, path))</span>
<span class="gi">+        else:</span>
<span class="gi">+            debug(&quot;File not found, skipping&quot;)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def global_defaults():
<span class="gu">@@ -169,4 +291,41 @@ class Config(InvokeConfig):</span>
<span class="w"> </span>            Added the ``authentication`` settings section, plus sub-attributes
<span class="w"> </span>            such as ``authentication.strategy_class``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: hrm should the run-related things actually be derived from the</span>
<span class="gi">+        # runner_class? E.g. Local defines local stuff, Remote defines remote</span>
<span class="gi">+        # stuff? Doesn&#39;t help with the final config tree tho...</span>
<span class="gi">+        # TODO: as to that, this is a core problem, Fabric wants split</span>
<span class="gi">+        # local/remote stuff, eg replace_env wants to be False for local and</span>
<span class="gi">+        # True remotely; shell wants to differ depending on target (and either</span>
<span class="gi">+        # way, does not want to use local interrogation for remote)</span>
<span class="gi">+        # TODO: is it worth moving all of our &#39;new&#39; settings to a discrete</span>
<span class="gi">+        # namespace for cleanliness&#39; sake? e.g. ssh.port, ssh.user etc.</span>
<span class="gi">+        # It wouldn&#39;t actually simplify this code any, but it would make it</span>
<span class="gi">+        # easier for users to determine what came from which library/repo.</span>
<span class="gi">+        defaults = InvokeConfig.global_defaults()</span>
<span class="gi">+        # TODO 4.0: this is already a mess, strongly consider a new &#39;ssh&#39;</span>
<span class="gi">+        # subtree because otherwise it&#39;s guessing where, or whether, &#39;ssh&#39; is</span>
<span class="gi">+        # in the setting name! i.e. &#39;inline_ssh_env&#39; -&gt; ssh.use_inline_env,</span>
<span class="gi">+        # &#39;load_ssh_configs&#39; -&gt; ssh.load_configs, &#39;ssh_config_path&#39; -&gt;</span>
<span class="gi">+        # ssh.config_path, etc</span>
<span class="gi">+        ours = {</span>
<span class="gi">+            &quot;authentication&quot;: {</span>
<span class="gi">+                &quot;identities&quot;: [],</span>
<span class="gi">+                &quot;strategy_class&quot;: None,</span>
<span class="gi">+            },</span>
<span class="gi">+            &quot;connect_kwargs&quot;: {},</span>
<span class="gi">+            &quot;forward_agent&quot;: False,</span>
<span class="gi">+            &quot;gateway&quot;: None,</span>
<span class="gi">+            &quot;inline_ssh_env&quot;: True,</span>
<span class="gi">+            &quot;load_ssh_configs&quot;: True,</span>
<span class="gi">+            &quot;port&quot;: 22,</span>
<span class="gi">+            &quot;runners&quot;: {&quot;remote&quot;: Remote, &quot;remote_shell&quot;: RemoteShell},</span>
<span class="gi">+            &quot;ssh_config_path&quot;: None,</span>
<span class="gi">+            &quot;tasks&quot;: {&quot;collection_name&quot;: &quot;fabfile&quot;},</span>
<span class="gi">+            # TODO: this becomes an override/extend once Invoke grows execution</span>
<span class="gi">+            # timeouts (which should be timeouts.execute)</span>
<span class="gi">+            &quot;timeouts&quot;: {&quot;connect&quot;: None},</span>
<span class="gi">+            &quot;user&quot;: get_local_user(),</span>
<span class="gi">+        }</span>
<span class="gi">+        merge_dicts(defaults, ours)</span>
<span class="gi">+        return defaults</span>
<span class="gh">diff --git a/fabric/connection.py b/fabric/connection.py</span>
<span class="gh">index be567e3f..4d4c49b7 100644</span>
<span class="gd">--- a/fabric/connection.py</span>
<span class="gi">+++ b/fabric/connection.py</span>
<span class="gu">@@ -2,6 +2,7 @@ from contextlib import contextmanager</span>
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from threading import Event
<span class="w"> </span>import socket
<span class="gi">+</span>
<span class="w"> </span>from decorator import decorator
<span class="w"> </span>from invoke import Context
<span class="w"> </span>from invoke.exceptions import ThreadException
<span class="gu">@@ -9,12 +10,42 @@ from paramiko.agent import AgentRequestHandler</span>
<span class="w"> </span>from paramiko.client import SSHClient, AutoAddPolicy
<span class="w"> </span>from paramiko.config import SSHConfig
<span class="w"> </span>from paramiko.proxy import ProxyCommand
<span class="gi">+</span>
<span class="w"> </span>from .config import Config
<span class="w"> </span>from .exceptions import InvalidV1Env
<span class="w"> </span>from .transfer import Transfer
<span class="w"> </span>from .tunnels import TunnelManager, Tunnel


<span class="gi">+@decorator</span>
<span class="gi">+def opens(method, self, *args, **kwargs):</span>
<span class="gi">+    self.open()</span>
<span class="gi">+    return method(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def derive_shorthand(host_string):</span>
<span class="gi">+    user_hostport = host_string.rsplit(&quot;@&quot;, 1)</span>
<span class="gi">+    hostport = user_hostport.pop()</span>
<span class="gi">+    user = user_hostport[0] if user_hostport and user_hostport[0] else None</span>
<span class="gi">+</span>
<span class="gi">+    # IPv6: can&#39;t reliably tell where addr ends and port begins, so don&#39;t</span>
<span class="gi">+    # try (and don&#39;t bother adding special syntax either, user should avoid</span>
<span class="gi">+    # this situation by using port=).</span>
<span class="gi">+    if hostport.count(&quot;:&quot;) &gt; 1:</span>
<span class="gi">+        host = hostport</span>
<span class="gi">+        port = None</span>
<span class="gi">+    # IPv4: can split on &#39;:&#39; reliably.</span>
<span class="gi">+    else:</span>
<span class="gi">+        host_port = hostport.rsplit(&quot;:&quot;, 1)</span>
<span class="gi">+        host = host_port.pop(0) or None</span>
<span class="gi">+        port = host_port[0] if host_port and host_port[0] else None</span>
<span class="gi">+</span>
<span class="gi">+    if port is not None:</span>
<span class="gi">+        port = int(port)</span>
<span class="gi">+</span>
<span class="gi">+    return {&quot;user&quot;: user, &quot;host&quot;: host, &quot;port&quot;: port}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Connection(Context):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A connection to an SSH daemon, with methods for commands and file transfer.
<span class="gu">@@ -89,6 +120,13 @@ class Connection(Context):</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # NOTE: these are initialized here to hint to invoke.Config.__setattr__</span>
<span class="gi">+    # that they should be treated as real attributes instead of config proxies.</span>
<span class="gi">+    # (Additionally, we&#39;re doing this instead of using invoke.Config._set() so</span>
<span class="gi">+    # we can take advantage of Sphinx&#39;s attribute-doc-comment static analysis.)</span>
<span class="gi">+    # Once an instance is created, these values will usually be non-None</span>
<span class="gi">+    # because they default to the default config values.</span>
<span class="w"> </span>    host = None
<span class="w"> </span>    original_host = None
<span class="w"> </span>    user = None
<span class="gu">@@ -126,11 +164,60 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, host, user=None, port=None, config=None, gateway=</span>
<span class="gd">-        None, forward_agent=None, connect_timeout=None, connect_kwargs=None,</span>
<span class="gd">-        inline_ssh_env=None):</span>
<span class="gi">+        # TODO: import fabric.state.env (need good way to test it first...)</span>
<span class="gi">+        # TODO: how to handle somebody accidentally calling this in a process</span>
<span class="gi">+        # where &#39;fabric&#39; is fabric 2, and there&#39;s no fabric 1? Probably just a</span>
<span class="gi">+        # re-raise of ImportError??</span>
<span class="gi">+        # Our only requirement is a non-empty host_string</span>
<span class="gi">+        if not env.host_string:</span>
<span class="gi">+            raise InvalidV1Env(</span>
<span class="gi">+                &quot;Supplied v1 env has an empty `host_string` value! Please make sure you&#39;re calling Connection.from_v1 within a connected Fabric 1 session.&quot;  # noqa</span>
<span class="gi">+            )</span>
<span class="gi">+        # TODO: detect collisions with kwargs &amp; except instead of overwriting?</span>
<span class="gi">+        # (More Zen of Python compliant, but also, effort, and also, makes it</span>
<span class="gi">+        # harder for users to intentionally overwrite!)</span>
<span class="gi">+        connect_kwargs = kwargs.setdefault(&quot;connect_kwargs&quot;, {})</span>
<span class="gi">+        kwargs.setdefault(&quot;host&quot;, env.host_string)</span>
<span class="gi">+        shorthand = derive_shorthand(env.host_string)</span>
<span class="gi">+        # TODO: don&#39;t we need to do the below skipping for user too?</span>
<span class="gi">+        kwargs.setdefault(&quot;user&quot;, env.user)</span>
<span class="gi">+        # Skip port if host string seemed to have it; otherwise we hit our own</span>
<span class="gi">+        # ambiguity clause in __init__. v1 would also have been doing this</span>
<span class="gi">+        # anyways (host string wins over other settings).</span>
<span class="gi">+        if not shorthand[&quot;port&quot;]:</span>
<span class="gi">+            # Run port through int(); v1 inexplicably has a string default...</span>
<span class="gi">+            kwargs.setdefault(&quot;port&quot;, int(env.port))</span>
<span class="gi">+        # key_filename defaults to None in v1, but in v2, we expect it to be</span>
<span class="gi">+        # either unset, or set to a list. Thus, we only pull it over if it is</span>
<span class="gi">+        # not None.</span>
<span class="gi">+        if env.key_filename is not None:</span>
<span class="gi">+            connect_kwargs.setdefault(&quot;key_filename&quot;, env.key_filename)</span>
<span class="gi">+        # Obtain config values, if not given, from its own from_v1</span>
<span class="gi">+        # NOTE: not using setdefault as we truly only want to call</span>
<span class="gi">+        # Config.from_v1 when necessary.</span>
<span class="gi">+        if &quot;config&quot; not in kwargs:</span>
<span class="gi">+            kwargs[&quot;config&quot;] = Config.from_v1(env)</span>
<span class="gi">+        return cls(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: should &quot;reopening&quot; an existing Connection object that has been</span>
<span class="gi">+    # closed, be allowed? (See e.g. how v1 detects closed/semi-closed</span>
<span class="gi">+    # connections &amp; nukes them before creating a new client to the same host.)</span>
<span class="gi">+    # TODO: push some of this into paramiko.client.Client? e.g. expand what</span>
<span class="gi">+    # Client.exec_command does, it already allows configuring a subset of what</span>
<span class="gi">+    # we do / will eventually do / did in 1.x. It&#39;s silly to have to do</span>
<span class="gi">+    # .get_transport().open_session().</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host,</span>
<span class="gi">+        user=None,</span>
<span class="gi">+        port=None,</span>
<span class="gi">+        config=None,</span>
<span class="gi">+        gateway=None,</span>
<span class="gi">+        forward_agent=None,</span>
<span class="gi">+        connect_timeout=None,</span>
<span class="gi">+        connect_kwargs=None,</span>
<span class="gi">+        inline_ssh_env=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Set up a new object representing a server connection.

<span class="gu">@@ -282,67 +369,194 @@ class Connection(Context):</span>
<span class="w"> </span>            config value has now changed and defaults to ``True``, not
<span class="w"> </span>            ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # NOTE: parent __init__ sets self._config; for now we simply overwrite</span>
<span class="gi">+        # that below. If it&#39;s somehow problematic we would want to break parent</span>
<span class="gi">+        # __init__ up in a manner that is more cleanly overrideable.</span>
<span class="w"> </span>        super().__init__(config=config)
<span class="gi">+</span>
<span class="gi">+        #: The .Config object referenced when handling default values (for e.g.</span>
<span class="gi">+        #: user or port, when not explicitly given) or deciding how to behave.</span>
<span class="w"> </span>        if config is None:
<span class="w"> </span>            config = Config()
<span class="gi">+        # Handle &#39;vanilla&#39; Invoke config objects, which need cloning &#39;into&#39; one</span>
<span class="gi">+        # of our own Configs (which grants the new defaults, etc, while not</span>
<span class="gi">+        # squashing them if the Invoke-level config already accounted for them)</span>
<span class="w"> </span>        elif not isinstance(config, Config):
<span class="w"> </span>            config = config.clone(into=Config)
<span class="w"> </span>        self._set(_config=config)
<span class="gi">+        # TODO: when/how to run load_files, merge, load_shell_env, etc?</span>
<span class="gi">+        # TODO: i.e. what is the lib use case here (and honestly in invoke too)</span>
<span class="gi">+</span>
<span class="w"> </span>        shorthand = self.derive_shorthand(host)
<span class="gd">-        host = shorthand[&#39;host&#39;]</span>
<span class="gd">-        err = (</span>
<span class="gd">-            &#39;You supplied the {} via both shorthand and kwarg! Please pick one.&#39;</span>
<span class="gd">-            )</span>
<span class="gd">-        if shorthand[&#39;user&#39;] is not None:</span>
<span class="gi">+        host = shorthand[&quot;host&quot;]</span>
<span class="gi">+        err = &quot;You supplied the {} via both shorthand and kwarg! Please pick one.&quot;  # noqa</span>
<span class="gi">+        if shorthand[&quot;user&quot;] is not None:</span>
<span class="w"> </span>            if user is not None:
<span class="gd">-                raise ValueError(err.format(&#39;user&#39;))</span>
<span class="gd">-            user = shorthand[&#39;user&#39;]</span>
<span class="gd">-        if shorthand[&#39;port&#39;] is not None:</span>
<span class="gi">+                raise ValueError(err.format(&quot;user&quot;))</span>
<span class="gi">+            user = shorthand[&quot;user&quot;]</span>
<span class="gi">+        if shorthand[&quot;port&quot;] is not None:</span>
<span class="w"> </span>            if port is not None:
<span class="gd">-                raise ValueError(err.format(&#39;port&#39;))</span>
<span class="gd">-            port = shorthand[&#39;port&#39;]</span>
<span class="gi">+                raise ValueError(err.format(&quot;port&quot;))</span>
<span class="gi">+            port = shorthand[&quot;port&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE: we load SSH config data as early as possible as it has</span>
<span class="gi">+        # potential to affect nearly every other attribute.</span>
<span class="gi">+        #: The per-host SSH config data, if any. (See :ref:`ssh-config`.)</span>
<span class="w"> </span>        self.ssh_config = self.config.base_ssh_config.lookup(host)
<span class="gi">+</span>
<span class="w"> </span>        self.original_host = host
<span class="gi">+        #: The hostname of the target server.</span>
<span class="w"> </span>        self.host = host
<span class="gd">-        if &#39;hostname&#39; in self.ssh_config:</span>
<span class="gd">-            self.host = self.ssh_config[&#39;hostname&#39;]</span>
<span class="gd">-        self.user = user or self.ssh_config.get(&#39;user&#39;, self.config.user)</span>
<span class="gd">-        self.port = port or int(self.ssh_config.get(&#39;port&#39;, self.config.port))</span>
<span class="gi">+        if &quot;hostname&quot; in self.ssh_config:</span>
<span class="gi">+            # TODO: log that this occurred?</span>
<span class="gi">+            self.host = self.ssh_config[&quot;hostname&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        #: The username this connection will use to connect to the remote end.</span>
<span class="gi">+        self.user = user or self.ssh_config.get(&quot;user&quot;, self.config.user)</span>
<span class="gi">+        # TODO: is it _ever_ possible to give an empty user value (e.g.</span>
<span class="gi">+        # user=&#39;&#39;)? E.g. do some SSH server specs allow for that?</span>
<span class="gi">+</span>
<span class="gi">+        #: The network port to connect on.</span>
<span class="gi">+        self.port = port or int(self.ssh_config.get(&quot;port&quot;, self.config.port))</span>
<span class="gi">+</span>
<span class="gi">+        # Gateway/proxy/bastion/jump setting: non-None values - string,</span>
<span class="gi">+        # Connection, even eg False - get set directly; None triggers seek in</span>
<span class="gi">+        # config/ssh_config</span>
<span class="gi">+        #: The gateway `.Connection` or ``ProxyCommand`` string to be used,</span>
<span class="gi">+        #: if any.</span>
<span class="w"> </span>        self.gateway = gateway if gateway is not None else self.get_gateway()
<span class="gi">+        # NOTE: we use string above, vs ProxyCommand obj, to avoid spinning up</span>
<span class="gi">+        # the ProxyCommand subprocess at init time, vs open() time.</span>
<span class="gi">+        # TODO: make paramiko.proxy.ProxyCommand lazy instead?</span>
<span class="gi">+</span>
<span class="w"> </span>        if forward_agent is None:
<span class="gi">+            # Default to config...</span>
<span class="w"> </span>            forward_agent = self.config.forward_agent
<span class="gd">-            if &#39;forwardagent&#39; in self.ssh_config:</span>
<span class="gd">-                map_ = {&#39;yes&#39;: True, &#39;no&#39;: False}</span>
<span class="gd">-                forward_agent = map_[self.ssh_config[&#39;forwardagent&#39;]]</span>
<span class="gi">+            # But if ssh_config is present, it wins</span>
<span class="gi">+            if &quot;forwardagent&quot; in self.ssh_config:</span>
<span class="gi">+                # TODO: SSHConfig really, seriously needs some love here, god</span>
<span class="gi">+                map_ = {&quot;yes&quot;: True, &quot;no&quot;: False}</span>
<span class="gi">+                forward_agent = map_[self.ssh_config[&quot;forwardagent&quot;]]</span>
<span class="gi">+        #: Whether agent forwarding is enabled.</span>
<span class="w"> </span>        self.forward_agent = forward_agent
<span class="gi">+</span>
<span class="w"> </span>        if connect_timeout is None:
<span class="gd">-            connect_timeout = self.ssh_config.get(&#39;connecttimeout&#39;, self.</span>
<span class="gd">-                config.timeouts.connect)</span>
<span class="gi">+            connect_timeout = self.ssh_config.get(</span>
<span class="gi">+                &quot;connecttimeout&quot;, self.config.timeouts.connect</span>
<span class="gi">+            )</span>
<span class="w"> </span>        if connect_timeout is not None:
<span class="w"> </span>            connect_timeout = int(connect_timeout)
<span class="gi">+        #: Connection timeout</span>
<span class="w"> </span>        self.connect_timeout = connect_timeout
<span class="gi">+</span>
<span class="gi">+        #: Keyword arguments given to `paramiko.client.SSHClient.connect` when</span>
<span class="gi">+        #: `open` is called.</span>
<span class="w"> </span>        self.connect_kwargs = self.resolve_connect_kwargs(connect_kwargs)
<span class="gi">+</span>
<span class="gi">+        #: The `paramiko.client.SSHClient` instance this connection wraps.</span>
<span class="w"> </span>        client = SSHClient()
<span class="w"> </span>        client.set_missing_host_key_policy(AutoAddPolicy())
<span class="w"> </span>        self.client = client
<span class="gi">+</span>
<span class="gi">+        #: A convenience handle onto the return value of</span>
<span class="gi">+        #: ``self.client.get_transport()`` (after connection time).</span>
<span class="w"> </span>        self.transport = None
<span class="gi">+</span>
<span class="w"> </span>        if inline_ssh_env is None:
<span class="w"> </span>            inline_ssh_env = self.config.inline_ssh_env
<span class="gi">+        #: Whether to construct remote command lines with env vars prefixed</span>
<span class="gi">+        #: inline.</span>
<span class="w"> </span>        self.inline_ssh_env = inline_ssh_env

<span class="gi">+    def resolve_connect_kwargs(self, connect_kwargs):</span>
<span class="gi">+        # TODO: is it better to pre-empt conflicts w/ manually-handled</span>
<span class="gi">+        # connect() kwargs (hostname, username, etc) here or in open()? We&#39;re</span>
<span class="gi">+        # doing open() for now in case e.g. someone manually modifies</span>
<span class="gi">+        # .connect_kwargs attributewise, but otherwise it feels better to do it</span>
<span class="gi">+        # early instead of late.</span>
<span class="gi">+        constructor_kwargs = connect_kwargs or {}</span>
<span class="gi">+        config_kwargs = self.config.connect_kwargs</span>
<span class="gi">+        constructor_keys = constructor_kwargs.get(&quot;key_filename&quot;, [])</span>
<span class="gi">+        config_keys = config_kwargs.get(&quot;key_filename&quot;, [])</span>
<span class="gi">+        ssh_config_keys = self.ssh_config.get(&quot;identityfile&quot;, [])</span>
<span class="gi">+</span>
<span class="gi">+        # Default data: constructor if given, config otherwise</span>
<span class="gi">+        final_kwargs = constructor_kwargs or config_kwargs</span>
<span class="gi">+</span>
<span class="gi">+        # Key filename: merge, in order, config (which includes CLI flags),</span>
<span class="gi">+        # then constructor kwargs, and finally SSH config file data.</span>
<span class="gi">+        # Make sure all are normalized to list as well!</span>
<span class="gi">+        final_keys = []</span>
<span class="gi">+        for value in (config_keys, constructor_keys, ssh_config_keys):</span>
<span class="gi">+            if isinstance(value, str):</span>
<span class="gi">+                value = [value]</span>
<span class="gi">+            final_keys.extend(value)</span>
<span class="gi">+        # Only populate if non-empty.</span>
<span class="gi">+        if final_keys:</span>
<span class="gi">+            final_kwargs[&quot;key_filename&quot;] = final_keys</span>
<span class="gi">+</span>
<span class="gi">+        return final_kwargs</span>
<span class="gi">+</span>
<span class="gi">+    def get_gateway(self):</span>
<span class="gi">+        # SSH config wins over Invoke-style config</span>
<span class="gi">+        if &quot;proxyjump&quot; in self.ssh_config:</span>
<span class="gi">+            # Reverse hop1,hop2,hop3 style ProxyJump directive so we start</span>
<span class="gi">+            # with the final (itself non-gatewayed) hop and work up to</span>
<span class="gi">+            # the front (actual, supplied as our own gateway) hop</span>
<span class="gi">+            hops = reversed(self.ssh_config[&quot;proxyjump&quot;].split(&quot;,&quot;))</span>
<span class="gi">+            prev_gw = None</span>
<span class="gi">+            for hop in hops:</span>
<span class="gi">+                # Short-circuit if we appear to be our own proxy, which would</span>
<span class="gi">+                # be a RecursionError. Implies SSH config wildcards.</span>
<span class="gi">+                # TODO: in an ideal world we&#39;d check user/port too in case they</span>
<span class="gi">+                # differ, but...seriously? They can file a PR with those extra</span>
<span class="gi">+                # half dozen test cases in play, E_NOTIME</span>
<span class="gi">+                if self.derive_shorthand(hop)[&quot;host&quot;] == self.host:</span>
<span class="gi">+                    return None</span>
<span class="gi">+                # Happily, ProxyJump uses identical format to our host</span>
<span class="gi">+                # shorthand...</span>
<span class="gi">+                kwargs = dict(config=self.config.clone())</span>
<span class="gi">+                if prev_gw is not None:</span>
<span class="gi">+                    kwargs[&quot;gateway&quot;] = prev_gw</span>
<span class="gi">+                cxn = Connection(hop, **kwargs)</span>
<span class="gi">+                prev_gw = cxn</span>
<span class="gi">+            return prev_gw</span>
<span class="gi">+        elif &quot;proxycommand&quot; in self.ssh_config:</span>
<span class="gi">+            # Just a string, which we interpret as a proxy command..</span>
<span class="gi">+            return self.ssh_config[&quot;proxycommand&quot;]</span>
<span class="gi">+        # Fallback: config value (may be None).</span>
<span class="gi">+        return self.config.gateway</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        bits = [(&#39;host&#39;, self.host)]</span>
<span class="gi">+        # Host comes first as it&#39;s the most common differentiator by far</span>
<span class="gi">+        bits = [(&quot;host&quot;, self.host)]</span>
<span class="gi">+        # TODO: maybe always show user regardless? Explicit is good...</span>
<span class="w"> </span>        if self.user != self.config.user:
<span class="gd">-            bits.append((&#39;user&#39;, self.user))</span>
<span class="gi">+            bits.append((&quot;user&quot;, self.user))</span>
<span class="gi">+        # TODO: harder to make case for &#39;always show port&#39;; maybe if it&#39;s</span>
<span class="gi">+        # non-22 (even if config has overridden the local default)?</span>
<span class="w"> </span>        if self.port != self.config.port:
<span class="gd">-            bits.append((&#39;port&#39;, self.port))</span>
<span class="gi">+            bits.append((&quot;port&quot;, self.port))</span>
<span class="gi">+        # NOTE: sometimes self.gateway may be eg False if someone wants to</span>
<span class="gi">+        # explicitly override a configured non-None value (as otherwise it&#39;s</span>
<span class="gi">+        # impossible for __init__ to tell if a None means &quot;nothing given&quot; or</span>
<span class="gi">+        # &quot;seriously please no gatewaying&quot;. So, this must always be a vanilla</span>
<span class="gi">+        # truth test and not eg &quot;is not None&quot;.</span>
<span class="w"> </span>        if self.gateway:
<span class="gd">-            val = &#39;proxyjump&#39;</span>
<span class="gi">+            # Displaying type because gw params would probs be too verbose</span>
<span class="gi">+            val = &quot;proxyjump&quot;</span>
<span class="w"> </span>            if isinstance(self.gateway, str):
<span class="gd">-                val = &#39;proxycommand&#39;</span>
<span class="gd">-            bits.append((&#39;gw&#39;, val))</span>
<span class="gd">-        return &#39;&lt;Connection {}&gt;&#39;.format(&#39; &#39;.join(&#39;{}={}&#39;.format(*x) for x in</span>
<span class="gd">-            bits))</span>
<span class="gi">+                val = &quot;proxycommand&quot;</span>
<span class="gi">+            bits.append((&quot;gw&quot;, val))</span>
<span class="gi">+        return &quot;&lt;Connection {}&gt;&quot;.format(</span>
<span class="gi">+            &quot; &quot;.join(&quot;{}={}&quot;.format(*x) for x in bits)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _identity(self):</span>
<span class="gi">+        # TODO: consider including gateway and maybe even other init kwargs?</span>
<span class="gi">+        # Whether two cxns w/ same user/host/port but different</span>
<span class="gi">+        # gateway/keys/etc, should be considered &quot;the same&quot;, is unclear.</span>
<span class="gi">+        return (self.host, self.user, self.port)</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, Connection):
<span class="gu">@@ -353,8 +567,16 @@ class Connection(Context):</span>
<span class="w"> </span>        return self._identity() &lt; other._identity()

<span class="w"> </span>    def __hash__(self):
<span class="gi">+        # NOTE: this departs from Context/DataProxy, which is not usefully</span>
<span class="gi">+        # hashable.</span>
<span class="w"> </span>        return hash(self._identity())

<span class="gi">+    def derive_shorthand(self, host_string):</span>
<span class="gi">+        # NOTE: used to be defined inline; preserving API call for both</span>
<span class="gi">+        # backwards compatibility and because it seems plausible we may want to</span>
<span class="gi">+        # modify behavior later, using eg config or other attributes.</span>
<span class="gi">+        return derive_shorthand(host_string)</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def is_connected(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -362,7 +584,7 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.transport.active if self.transport else False</span>

<span class="w"> </span>    def open(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -387,7 +609,62 @@ class Connection(Context):</span>
<span class="w"> </span>            Now returns the inner Paramiko connect call&#39;s return value instead
<span class="w"> </span>            of always returning the implicit ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Short-circuit</span>
<span class="gi">+        if self.is_connected:</span>
<span class="gi">+            return</span>
<span class="gi">+        err = &quot;Refusing to be ambiguous: connect() kwarg &#39;{}&#39; was given both via regular arg and via connect_kwargs!&quot;  # noqa</span>
<span class="gi">+        # These may not be given, period</span>
<span class="gi">+        for key in &quot;&quot;&quot;</span>
<span class="gi">+            hostname</span>
<span class="gi">+            port</span>
<span class="gi">+            username</span>
<span class="gi">+        &quot;&quot;&quot;.split():</span>
<span class="gi">+            if key in self.connect_kwargs:</span>
<span class="gi">+                raise ValueError(err.format(key))</span>
<span class="gi">+        # These may be given one way or the other, but not both</span>
<span class="gi">+        if (</span>
<span class="gi">+            &quot;timeout&quot; in self.connect_kwargs</span>
<span class="gi">+            and self.connect_timeout is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise ValueError(err.format(&quot;timeout&quot;))</span>
<span class="gi">+        # No conflicts -&gt; merge &#39;em together</span>
<span class="gi">+        kwargs = dict(</span>
<span class="gi">+            self.connect_kwargs,</span>
<span class="gi">+            username=self.user,</span>
<span class="gi">+            hostname=self.host,</span>
<span class="gi">+            port=self.port,</span>
<span class="gi">+        )</span>
<span class="gi">+        if self.gateway:</span>
<span class="gi">+            kwargs[&quot;sock&quot;] = self.open_gateway()</span>
<span class="gi">+        if self.connect_timeout:</span>
<span class="gi">+            kwargs[&quot;timeout&quot;] = self.connect_timeout</span>
<span class="gi">+        # Strip out empty defaults for less noisy debugging</span>
<span class="gi">+        if &quot;key_filename&quot; in kwargs and not kwargs[&quot;key_filename&quot;]:</span>
<span class="gi">+            del kwargs[&quot;key_filename&quot;]</span>
<span class="gi">+        auth_strategy_class = self.authentication.strategy_class</span>
<span class="gi">+        if auth_strategy_class is not None:</span>
<span class="gi">+            # Pop connect_kwargs related to auth to avoid giving Paramiko</span>
<span class="gi">+            # conflicting signals.</span>
<span class="gi">+            for key in (</span>
<span class="gi">+                &quot;allow_agent&quot;,</span>
<span class="gi">+                &quot;key_filename&quot;,</span>
<span class="gi">+                &quot;look_for_keys&quot;,</span>
<span class="gi">+                &quot;passphrase&quot;,</span>
<span class="gi">+                &quot;password&quot;,</span>
<span class="gi">+                &quot;pkey&quot;,</span>
<span class="gi">+                &quot;username&quot;,</span>
<span class="gi">+            ):</span>
<span class="gi">+                kwargs.pop(key, None)</span>
<span class="gi">+</span>
<span class="gi">+            kwargs[&quot;auth_strategy&quot;] = auth_strategy_class(</span>
<span class="gi">+                ssh_config=self.ssh_config,</span>
<span class="gi">+                fabric_config=self.config,</span>
<span class="gi">+                username=self.user,</span>
<span class="gi">+            )</span>
<span class="gi">+        # Actually connect!</span>
<span class="gi">+        result = self.client.connect(**kwargs)</span>
<span class="gi">+        self.transport = self.client.get_transport()</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def open_gateway(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -400,7 +677,34 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # ProxyCommand is faster to set up, so do it first.</span>
<span class="gi">+        if isinstance(self.gateway, str):</span>
<span class="gi">+            # Leverage a dummy SSHConfig to ensure %h/%p/etc are parsed.</span>
<span class="gi">+            # TODO: use real SSH config once loading one properly is</span>
<span class="gi">+            # implemented.</span>
<span class="gi">+            ssh_conf = SSHConfig()</span>
<span class="gi">+            dummy = &quot;Host {}\n    ProxyCommand {}&quot;</span>
<span class="gi">+            ssh_conf.parse(StringIO(dummy.format(self.host, self.gateway)))</span>
<span class="gi">+            return ProxyCommand(ssh_conf.lookup(self.host)[&quot;proxycommand&quot;])</span>
<span class="gi">+        # Handle inner-Connection gateway type here.</span>
<span class="gi">+        # TODO: logging</span>
<span class="gi">+        self.gateway.open()</span>
<span class="gi">+        # TODO: expose the opened channel itself as an attribute? (another</span>
<span class="gi">+        # possible argument for separating the two gateway types...) e.g. if</span>
<span class="gi">+        # someone wanted to piggyback on it for other same-interpreter socket</span>
<span class="gi">+        # needs...</span>
<span class="gi">+        # TODO: and the inverse? allow users to supply their own socket/like</span>
<span class="gi">+        # object they got via $WHEREEVER?</span>
<span class="gi">+        # TODO: how best to expose timeout param? reuse general connection</span>
<span class="gi">+        # timeout from config?</span>
<span class="gi">+        return self.gateway.transport.open_channel(</span>
<span class="gi">+            kind=&quot;direct-tcpip&quot;,</span>
<span class="gi">+            dest_addr=(self.host, int(self.port)),</span>
<span class="gi">+            # NOTE: src_addr needs to be &#39;empty but not None&#39; values to</span>
<span class="gi">+            # correctly encode into a network message. Theoretically Paramiko</span>
<span class="gi">+            # could auto-interpret None sometime &amp; save us the trouble.</span>
<span class="gi">+            src_addr=(&quot;&quot;, 0),</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -414,7 +718,14 @@ class Connection(Context):</span>
<span class="w"> </span>        .. versionchanged:: 3.0
<span class="w"> </span>            Now closes SFTP sessions too (2.x required manually doing so).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._sftp is not None:</span>
<span class="gi">+            self._sftp.close()</span>
<span class="gi">+            self._sftp = None</span>
<span class="gi">+</span>
<span class="gi">+        if self.is_connected:</span>
<span class="gi">+            self.client.close()</span>
<span class="gi">+            if self.forward_agent and self._agent_handler is not None:</span>
<span class="gi">+                self._agent_handler.close()</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -422,6 +733,18 @@ class Connection(Context):</span>
<span class="w"> </span>    def __exit__(self, *exc):
<span class="w"> </span>        self.close()

<span class="gi">+    @opens</span>
<span class="gi">+    def create_session(self):</span>
<span class="gi">+        channel = self.transport.open_session()</span>
<span class="gi">+        if self.forward_agent:</span>
<span class="gi">+            self._agent_handler = AgentRequestHandler(channel)</span>
<span class="gi">+        return channel</span>
<span class="gi">+</span>
<span class="gi">+    def _remote_runner(self):</span>
<span class="gi">+        return self.config.runners.remote(</span>
<span class="gi">+            context=self, inline_env=self.inline_ssh_env</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>    @opens
<span class="w"> </span>    def run(self, command, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -437,7 +760,7 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._run(self._remote_runner(), command, **kwargs)</span>

<span class="w"> </span>    @opens
<span class="w"> </span>    def sudo(self, command, **kwargs):
<span class="gu">@@ -451,7 +774,7 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._sudo(self._remote_runner(), command, **kwargs)</span>

<span class="w"> </span>    @opens
<span class="w"> </span>    def shell(self, **kwargs):
<span class="gu">@@ -513,7 +836,25 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        runner = self.config.runners.remote_shell(context=self)</span>
<span class="gi">+        # Reinstate most defaults as explicit kwargs to ensure user&#39;s config</span>
<span class="gi">+        # doesn&#39;t make this mode break horribly. Then override a few that need</span>
<span class="gi">+        # to change, like pty.</span>
<span class="gi">+        allowed = (&quot;encoding&quot;, &quot;env&quot;, &quot;in_stream&quot;, &quot;replace_env&quot;, &quot;watchers&quot;)</span>
<span class="gi">+        new_kwargs = {}</span>
<span class="gi">+        for key, value in self.config.global_defaults()[&quot;run&quot;].items():</span>
<span class="gi">+            if key in allowed:</span>
<span class="gi">+                # Use allowed kwargs if given, otherwise also fill them from</span>
<span class="gi">+                # defaults</span>
<span class="gi">+                new_kwargs[key] = kwargs.pop(key, self.config.run[key])</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_kwargs[key] = value</span>
<span class="gi">+        new_kwargs.update(pty=True)</span>
<span class="gi">+        # At this point, any leftover kwargs would be ignored, so yell instead</span>
<span class="gi">+        if kwargs:</span>
<span class="gi">+            err = &quot;shell() got unexpected keyword arguments: {!r}&quot;</span>
<span class="gi">+            raise TypeError(err.format(list(kwargs.keys())))</span>
<span class="gi">+        return runner.run(command=None, **new_kwargs)</span>

<span class="w"> </span>    def local(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -524,7 +865,9 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Superclass run() uses runners.local, so we can literally just call it</span>
<span class="gi">+        # straight.</span>
<span class="gi">+        return super().run(*args, **kwargs)</span>

<span class="w"> </span>    @opens
<span class="w"> </span>    def sftp(self):
<span class="gu">@@ -538,7 +881,9 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._sftp is None:</span>
<span class="gi">+            self._sftp = self.client.open_sftp()</span>
<span class="gi">+        return self._sftp</span>

<span class="w"> </span>    def get(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -549,7 +894,7 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Transfer(self).get(*args, **kwargs)</span>

<span class="w"> </span>    def put(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -560,12 +905,20 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Transfer(self).put(*args, **kwargs)</span>

<span class="gi">+    # TODO: yield the socket for advanced users? Other advanced use cases</span>
<span class="gi">+    # (perhaps factor out socket creation itself)?</span>
<span class="gi">+    # TODO: probably push some of this down into Paramiko</span>
<span class="w"> </span>    @contextmanager
<span class="w"> </span>    @opens
<span class="gd">-    def forward_local(self, local_port, remote_port=None, remote_host=</span>
<span class="gd">-        &#39;localhost&#39;, local_host=&#39;localhost&#39;):</span>
<span class="gi">+    def forward_local(</span>
<span class="gi">+        self,</span>
<span class="gi">+        local_port,</span>
<span class="gi">+        remote_port=None,</span>
<span class="gi">+        remote_host=&quot;localhost&quot;,</span>
<span class="gi">+        local_host=&quot;localhost&quot;,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Open a tunnel connecting ``local_port`` to the server&#39;s environment.

<span class="gu">@@ -606,12 +959,65 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        if not remote_port:</span>
<span class="gi">+            remote_port = local_port</span>
<span class="gi">+</span>
<span class="gi">+        # TunnelManager does all of the work, sitting in the background (so we</span>
<span class="gi">+        # can yield) and spawning threads every time somebody connects to our</span>
<span class="gi">+        # local port.</span>
<span class="gi">+        finished = Event()</span>
<span class="gi">+        manager = TunnelManager(</span>
<span class="gi">+            local_port=local_port,</span>
<span class="gi">+            local_host=local_host,</span>
<span class="gi">+            remote_port=remote_port,</span>
<span class="gi">+            remote_host=remote_host,</span>
<span class="gi">+            # TODO: not a huge fan of handing in our transport, but...?</span>
<span class="gi">+            transport=self.transport,</span>
<span class="gi">+            finished=finished,</span>
<span class="gi">+        )</span>
<span class="gi">+        manager.start()</span>
<span class="gi">+</span>
<span class="gi">+        # Return control to caller now that things ought to be operational</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        # Teardown once user exits block</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # Signal to manager that it should close all open tunnels</span>
<span class="gi">+            finished.set()</span>
<span class="gi">+            # Then wait for it to do so</span>
<span class="gi">+            manager.join()</span>
<span class="gi">+            # Raise threading errors from within the manager, which would be</span>
<span class="gi">+            # one of:</span>
<span class="gi">+            # - an inner ThreadException, which was created by the manager on</span>
<span class="gi">+            # behalf of its Tunnels; this gets directly raised.</span>
<span class="gi">+            # - some other exception, which would thus have occurred in the</span>
<span class="gi">+            # manager itself; we wrap this in a new ThreadException.</span>
<span class="gi">+            # NOTE: in these cases, some of the metadata tracking in</span>
<span class="gi">+            # ExceptionHandlingThread/ExceptionWrapper/ThreadException (which</span>
<span class="gi">+            # is useful when dealing with multiple nearly-identical sibling IO</span>
<span class="gi">+            # threads) is superfluous, but it doesn&#39;t feel worth breaking</span>
<span class="gi">+            # things up further; we just ignore it for now.</span>
<span class="gi">+            wrapper = manager.exception()</span>
<span class="gi">+            if wrapper is not None:</span>
<span class="gi">+                if wrapper.type is ThreadException:</span>
<span class="gi">+                    raise wrapper.value</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ThreadException([wrapper])</span>
<span class="gi">+</span>
<span class="gi">+            # TODO: cancel port forward on transport? Does that even make sense</span>
<span class="gi">+            # here (where we used direct-tcpip) vs the opposite method (which</span>
<span class="gi">+            # is what uses forward-tcpip)?</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: probably push some of this down into Paramiko</span>
<span class="w"> </span>    @contextmanager
<span class="w"> </span>    @opens
<span class="gd">-    def forward_remote(self, remote_port, local_port=None, remote_host=</span>
<span class="gd">-        &#39;127.0.0.1&#39;, local_host=&#39;localhost&#39;):</span>
<span class="gi">+    def forward_remote(</span>
<span class="gi">+        self,</span>
<span class="gi">+        remote_port,</span>
<span class="gi">+        local_port=None,</span>
<span class="gi">+        remote_host=&quot;127.0.0.1&quot;,</span>
<span class="gi">+        local_host=&quot;localhost&quot;,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Open a tunnel connecting ``remote_port`` to the local environment.

<span class="gu">@@ -656,4 +1062,54 @@ class Connection(Context):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not local_port:</span>
<span class="gi">+            local_port = remote_port</span>
<span class="gi">+        # Callback executes on each connection to the remote port and is given</span>
<span class="gi">+        # a Channel hooked up to said port. (We don&#39;t actually care about the</span>
<span class="gi">+        # source/dest host/port pairs at all; only whether the channel has data</span>
<span class="gi">+        # to read and suchlike.)</span>
<span class="gi">+        # We then pair that channel with a new &#39;outbound&#39; socket connection to</span>
<span class="gi">+        # the local host/port being forwarded, in a new Tunnel.</span>
<span class="gi">+        # That Tunnel is then added to a shared data structure so we can track</span>
<span class="gi">+        # &amp; close them during shutdown.</span>
<span class="gi">+        #</span>
<span class="gi">+        # TODO: this approach is less than ideal because we have to share state</span>
<span class="gi">+        # between ourselves &amp; the callback handed into the transport&#39;s own</span>
<span class="gi">+        # thread handling (which is roughly analogous to our self-controlled</span>
<span class="gi">+        # TunnelManager for local forwarding). See if we can use more of</span>
<span class="gi">+        # Paramiko&#39;s API (or improve it and then do so) so that isn&#39;t</span>
<span class="gi">+        # necessary.</span>
<span class="gi">+        tunnels = []</span>
<span class="gi">+</span>
<span class="gi">+        def callback(channel, src_addr_tup, dst_addr_tup):</span>
<span class="gi">+            sock = socket.socket()</span>
<span class="gi">+            # TODO: handle connection failure such that channel, etc get closed</span>
<span class="gi">+            sock.connect((local_host, local_port))</span>
<span class="gi">+            # TODO: we don&#39;t actually need to generate the Events at our level,</span>
<span class="gi">+            # do we? Just let Tunnel.__init__ do it; all we do is &quot;press its</span>
<span class="gi">+            # button&quot; on shutdown...</span>
<span class="gi">+            tunnel = Tunnel(channel=channel, sock=sock, finished=Event())</span>
<span class="gi">+            tunnel.start()</span>
<span class="gi">+            # Communication between ourselves &amp; the Paramiko handling subthread</span>
<span class="gi">+            tunnels.append(tunnel)</span>
<span class="gi">+</span>
<span class="gi">+        # Ask Paramiko (really, the remote sshd) to call our callback whenever</span>
<span class="gi">+        # connections are established on the remote iface/port.</span>
<span class="gi">+        # transport.request_port_forward(remote_host, remote_port, callback)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.transport.request_port_forward(</span>
<span class="gi">+                address=remote_host, port=remote_port, handler=callback</span>
<span class="gi">+            )</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # TODO: see above re: lack of a TunnelManager</span>
<span class="gi">+            # TODO: and/or also refactor with TunnelManager re: shutdown logic.</span>
<span class="gi">+            # E.g. maybe have a non-thread TunnelManager-alike with a method</span>
<span class="gi">+            # that acts as the callback? At least then there&#39;s a tiny bit more</span>
<span class="gi">+            # encapsulation...meh.</span>
<span class="gi">+            for tunnel in tunnels:</span>
<span class="gi">+                tunnel.finished.set()</span>
<span class="gi">+                tunnel.join()</span>
<span class="gi">+            self.transport.cancel_port_forward(</span>
<span class="gi">+                address=remote_host, port=remote_port</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/fabric/exceptions.py b/fabric/exceptions.py</span>
<span class="gh">index 0343cf15..f965219e 100644</span>
<span class="gd">--- a/fabric/exceptions.py</span>
<span class="gi">+++ b/fabric/exceptions.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+# TODO: this may want to move to Invoke if we can find a use for it there too?</span>
<span class="gi">+# Or make it _more_ narrowly focused and stay here?</span>
<span class="w"> </span>class NothingToDo(Exception):
<span class="w"> </span>    pass

<span class="gu">@@ -10,6 +12,9 @@ class GroupException(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, result):
<span class="gi">+        #: The `.GroupResult` object which would have been returned, had there</span>
<span class="gi">+        #: been no errors. See its docstring (and that of `.Group`) for</span>
<span class="gi">+        #: details.</span>
<span class="w"> </span>        self.result = result


<span class="gu">@@ -17,4 +22,5 @@ class InvalidV1Env(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Raised when attempting to import a Fabric 1 ``env`` which is missing data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass
<span class="gh">diff --git a/fabric/executor.py b/fabric/executor.py</span>
<span class="gh">index 2bb16019..4ef06f68 100644</span>
<span class="gd">--- a/fabric/executor.py</span>
<span class="gi">+++ b/fabric/executor.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>import invoke
<span class="w"> </span>from invoke import Call, Task
<span class="gi">+</span>
<span class="w"> </span>from .tasks import ConnectionCall
<span class="w"> </span>from .exceptions import NothingToDo
<span class="w"> </span>from .util import debug
<span class="gu">@@ -38,7 +39,64 @@ class Executor(invoke.Executor):</span>

<span class="w"> </span>        :returns: Homogenous list of Connection init kwarg dicts.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dicts = []</span>
<span class="gi">+        for value in hosts or []:</span>
<span class="gi">+            # Assume first posarg to Connection() if not already a dict.</span>
<span class="gi">+            if not isinstance(value, dict):</span>
<span class="gi">+                value = dict(host=value)</span>
<span class="gi">+            dicts.append(value)</span>
<span class="gi">+        return dicts</span>
<span class="gi">+</span>
<span class="gi">+    def expand_calls(self, calls, apply_hosts=True):</span>
<span class="gi">+        # Generate new call list with per-host variants &amp; Connections inserted</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        cli_hosts = []</span>
<span class="gi">+        host_str = self.core[0].args.hosts.value</span>
<span class="gi">+        if apply_hosts and host_str:</span>
<span class="gi">+            cli_hosts = host_str.split(&quot;,&quot;)</span>
<span class="gi">+        for call in calls:</span>
<span class="gi">+            if isinstance(call, Task):</span>
<span class="gi">+                call = Call(task=call)</span>
<span class="gi">+            # TODO: expand this to allow multiple types of execution plans,</span>
<span class="gi">+            # pending outcome of invoke#461 (which, if flexible enough to</span>
<span class="gi">+            # handle intersect of dependencies+parameterization, just becomes</span>
<span class="gi">+            # &#39;honor that new feature of Invoke&#39;)</span>
<span class="gi">+            # TODO: roles, other non-runtime host parameterizations, etc</span>
<span class="gi">+            # Pre-tasks get added only once, not once per host.</span>
<span class="gi">+            ret.extend(self.expand_calls(call.pre, apply_hosts=False))</span>
<span class="gi">+            # Determine final desired host list based on CLI and task values</span>
<span class="gi">+            # (with CLI, being closer to runtime, winning) and normalize to</span>
<span class="gi">+            # Connection-init kwargs.</span>
<span class="gi">+            call_hosts = getattr(call, &quot;hosts&quot;, None)</span>
<span class="gi">+            cxn_params = self.normalize_hosts(cli_hosts or call_hosts)</span>
<span class="gi">+            # Main task, per host/connection</span>
<span class="gi">+            for init_kwargs in cxn_params:</span>
<span class="gi">+                ret.append(self.parameterize(call, init_kwargs))</span>
<span class="gi">+            # Deal with lack of hosts list (acts same as `inv` in that case)</span>
<span class="gi">+            # TODO: no tests for this branch?</span>
<span class="gi">+            if not cxn_params:</span>
<span class="gi">+                ret.append(call)</span>
<span class="gi">+            # Post-tasks added once, not once per host.</span>
<span class="gi">+            ret.extend(self.expand_calls(call.post, apply_hosts=False))</span>
<span class="gi">+        # Add remainder as anonymous task</span>
<span class="gi">+        if self.core.remainder:</span>
<span class="gi">+            # TODO: this will need to change once there are more options for</span>
<span class="gi">+            # setting host lists besides &quot;-H or 100% within-task&quot;</span>
<span class="gi">+            if not cli_hosts:</span>
<span class="gi">+                raise NothingToDo(</span>
<span class="gi">+                    &quot;Was told to run a command, but not given any hosts to run it on!&quot;  # noqa</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            def anonymous(c):</span>
<span class="gi">+                c.run(self.core.remainder)</span>
<span class="gi">+</span>
<span class="gi">+            anon = Call(Task(body=anonymous))</span>
<span class="gi">+            # TODO: see above TODOs about non-parameterized setups, roles etc</span>
<span class="gi">+            # TODO: will likely need to refactor that logic some more so it can</span>
<span class="gi">+            # be used both there and here.</span>
<span class="gi">+            for init_kwargs in self.normalize_hosts(cli_hosts):</span>
<span class="gi">+                ret.append(self.parameterize(anon, init_kwargs))</span>
<span class="gi">+        return ret</span>

<span class="w"> </span>    def parameterize(self, call, connection_init_kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -53,4 +111,17 @@ class Executor(invoke.Executor):</span>
<span class="w"> </span>        :returns:
<span class="w"> </span>            `.ConnectionCall`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        msg = &quot;Parameterizing {!r} with Connection kwargs {!r}&quot;</span>
<span class="gi">+        debug(msg.format(call, connection_init_kwargs))</span>
<span class="gi">+        # Generate a custom ConnectionCall that has init_kwargs (used for</span>
<span class="gi">+        # creating the Connection at runtime) set to the requested params.</span>
<span class="gi">+        new_call_kwargs = dict(init_kwargs=connection_init_kwargs)</span>
<span class="gi">+        clone = call.clone(into=ConnectionCall, with_=new_call_kwargs)</span>
<span class="gi">+        return clone</span>
<span class="gi">+</span>
<span class="gi">+    def dedupe(self, tasks):</span>
<span class="gi">+        # Don&#39;t perform deduping, we will often have &quot;duplicate&quot; tasks w/</span>
<span class="gi">+        # distinct host values/etc.</span>
<span class="gi">+        # TODO: might want some deduplication later on though - falls under</span>
<span class="gi">+        # &quot;how to mesh parameterization with pre/post/etc deduping&quot;.</span>
<span class="gi">+        return tasks</span>
<span class="gh">diff --git a/fabric/group.py b/fabric/group.py</span>
<span class="gh">index f30a24cd..506f2353 100644</span>
<span class="gd">--- a/fabric/group.py</span>
<span class="gi">+++ b/fabric/group.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>from queue import Queue
<span class="gi">+</span>
<span class="w"> </span>from invoke.util import ExceptionHandlingThread
<span class="gi">+</span>
<span class="w"> </span>from .connection import Connection
<span class="w"> </span>from .exceptions import GroupException

<span class="gu">@@ -78,6 +80,7 @@ class Group(list):</span>
<span class="w"> </span>        .. versionchanged:: 2.3
<span class="w"> </span>            Added ``**kwargs`` (was previously only ``*hosts``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # TODO: #563, #388 (could be here or higher up in Program area)</span>
<span class="w"> </span>        self.extend([Connection(host, **kwargs) for host in hosts])

<span class="w"> </span>    @classmethod
<span class="gu">@@ -87,7 +90,16 @@ class Group(list):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: *args here too; or maybe just fold into __init__ and type</span>
<span class="gi">+        # check?</span>
<span class="gi">+        group = cls()</span>
<span class="gi">+        group.extend(connections)</span>
<span class="gi">+        return group</span>
<span class="gi">+</span>
<span class="gi">+    def _do(self, method, *args, **kwargs):</span>
<span class="gi">+        # TODO: rename this something public &amp; commit to an API for user</span>
<span class="gi">+        # subclasses</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def run(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -97,7 +109,11 @@ class Group(list):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: how to change method of execution across contents? subclass,</span>
<span class="gi">+        # kwargs, additional methods, inject an executor? Doing subclass for</span>
<span class="gi">+        # now, but not 100% sure it&#39;s the best route.</span>
<span class="gi">+        # TODO: also need way to deal with duplicate connections (see THOUGHTS)</span>
<span class="gi">+        return self._do(&quot;run&quot;, *args, **kwargs)</span>

<span class="w"> </span>    def sudo(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -107,7 +123,18 @@ class Group(list):</span>

<span class="w"> </span>        .. versionadded:: 2.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: see run() TODOs</span>
<span class="gi">+        return self._do(&quot;sudo&quot;, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: this all needs to mesh well with similar strategies applied to</span>
<span class="gi">+    # entire tasks - so that may still end up factored out into Executors or</span>
<span class="gi">+    # something lower level than both those and these?</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: local? Invoke wants ability to do that on its own though, which</span>
<span class="gi">+    # would be distinct from Group. (May want to switch Group to use that,</span>
<span class="gi">+    # though, whatever it ends up being? Eg many cases where you do want to do</span>
<span class="gi">+    # some local thing either N times identically, or parameterized by remote</span>
<span class="gi">+    # cxn values)</span>

<span class="w"> </span>    def put(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -123,7 +150,7 @@ class Group(list):</span>

<span class="w"> </span>        .. versionadded:: 2.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._do(&quot;put&quot;, *args, **kwargs)</span>

<span class="w"> </span>    def get(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -150,7 +177,13 @@ class Group(list):</span>

<span class="w"> </span>        .. versionadded:: 2.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO 4.0: consider making many of these into kwarg-only methods? then</span>
<span class="gi">+        # below could become kwargs.setdefault() if desired.</span>
<span class="gi">+        # TODO: do we care enough to handle explicitly given, yet falsey,</span>
<span class="gi">+        # values? it&#39;s a lot more complexity for a corner case.</span>
<span class="gi">+        if len(args) &lt; 2 and &quot;local&quot; not in kwargs:</span>
<span class="gi">+            kwargs[&quot;local&quot;] = &quot;{host}/&quot;</span>
<span class="gi">+        return self._do(&quot;get&quot;, *args, **kwargs)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -158,7 +191,8 @@ class Group(list):</span>

<span class="w"> </span>        .. versionadded:: 2.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cxn in self:</span>
<span class="gi">+            cxn.close()</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -174,6 +208,25 @@ class SerialGroup(Group):</span>
<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def _do(self, method, *args, **kwargs):</span>
<span class="gi">+        results = GroupResult()</span>
<span class="gi">+        excepted = False</span>
<span class="gi">+        for cxn in self:</span>
<span class="gi">+            try:</span>
<span class="gi">+                results[cxn] = getattr(cxn, method)(*args, **kwargs)</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                results[cxn] = e</span>
<span class="gi">+                excepted = True</span>
<span class="gi">+        if excepted:</span>
<span class="gi">+            raise GroupException(results)</span>
<span class="gi">+        return results</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def thread_worker(cxn, queue, method, args, kwargs):</span>
<span class="gi">+    result = getattr(cxn, method)(*args, **kwargs)</span>
<span class="gi">+    # TODO: namedtuple or attrs object?</span>
<span class="gi">+    queue.put((cxn, result))</span>
<span class="gi">+</span>

<span class="w"> </span>class ThreadingGroup(Group):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -182,6 +235,53 @@ class ThreadingGroup(Group):</span>
<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def _do(self, method, *args, **kwargs):</span>
<span class="gi">+        results = GroupResult()</span>
<span class="gi">+        queue = Queue()</span>
<span class="gi">+        threads = []</span>
<span class="gi">+        for cxn in self:</span>
<span class="gi">+            thread = ExceptionHandlingThread(</span>
<span class="gi">+                target=thread_worker,</span>
<span class="gi">+                kwargs=dict(</span>
<span class="gi">+                    cxn=cxn,</span>
<span class="gi">+                    queue=queue,</span>
<span class="gi">+                    method=method,</span>
<span class="gi">+                    args=args,</span>
<span class="gi">+                    kwargs=kwargs,</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+            threads.append(thread)</span>
<span class="gi">+        for thread in threads:</span>
<span class="gi">+            thread.start()</span>
<span class="gi">+        for thread in threads:</span>
<span class="gi">+            # TODO: configurable join timeout</span>
<span class="gi">+            thread.join()</span>
<span class="gi">+        # Get non-exception results from queue</span>
<span class="gi">+        while not queue.empty():</span>
<span class="gi">+            # TODO: io-sleep? shouldn&#39;t matter if all threads are now joined</span>
<span class="gi">+            cxn, result = queue.get(block=False)</span>
<span class="gi">+            # TODO: outstanding musings about how exactly aggregate results</span>
<span class="gi">+            # ought to ideally operate...heterogenous obj like this, multiple</span>
<span class="gi">+            # objs, ??</span>
<span class="gi">+            results[cxn] = result</span>
<span class="gi">+        # Get exceptions from the threads themselves.</span>
<span class="gi">+        # TODO: in a non-thread setup, this would differ, e.g.:</span>
<span class="gi">+        # - a queue if using multiprocessing</span>
<span class="gi">+        # - some other state-passing mechanism if using e.g. coroutines</span>
<span class="gi">+        # - ???</span>
<span class="gi">+        excepted = False</span>
<span class="gi">+        for thread in threads:</span>
<span class="gi">+            wrapper = thread.exception()</span>
<span class="gi">+            if wrapper is not None:</span>
<span class="gi">+                # Outer kwargs is Thread instantiation kwargs, inner is kwargs</span>
<span class="gi">+                # passed to thread target/body.</span>
<span class="gi">+                cxn = wrapper.kwargs[&quot;kwargs&quot;][&quot;cxn&quot;]</span>
<span class="gi">+                results[cxn] = wrapper.value</span>
<span class="gi">+                excepted = True</span>
<span class="gi">+        if excepted:</span>
<span class="gi">+            raise GroupException(results)</span>
<span class="gi">+        return results</span>
<span class="gi">+</span>

<span class="w"> </span>class GroupResult(dict):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -209,6 +309,18 @@ class GroupResult(dict):</span>
<span class="w"> </span>        self._successes = {}
<span class="w"> </span>        self._failures = {}

<span class="gi">+    def _bifurcate(self):</span>
<span class="gi">+        # Short-circuit to avoid reprocessing every access.</span>
<span class="gi">+        if self._successes or self._failures:</span>
<span class="gi">+            return</span>
<span class="gi">+        # TODO: if we ever expect .succeeded/.failed to be useful before a</span>
<span class="gi">+        # GroupResult is fully initialized, this needs to become smarter.</span>
<span class="gi">+        for key, value in self.items():</span>
<span class="gi">+            if isinstance(value, BaseException):</span>
<span class="gi">+                self._failures[key] = value</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._successes[key] = value</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def succeeded(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -216,7 +328,8 @@ class GroupResult(dict):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bifurcate()</span>
<span class="gi">+        return self._successes</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def failed(self):
<span class="gu">@@ -225,4 +338,5 @@ class GroupResult(dict):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._bifurcate()</span>
<span class="gi">+        return self._failures</span>
<span class="gh">diff --git a/fabric/main.py b/fabric/main.py</span>
<span class="gh">index 18c45ce4..ce0f66e4 100644</span>
<span class="gd">--- a/fabric/main.py</span>
<span class="gi">+++ b/fabric/main.py</span>
<span class="gu">@@ -3,17 +3,191 @@ CLI entrypoint &amp; parser configuration.</span>

<span class="w"> </span>Builds on top of Invoke&#39;s core functionality for same.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import getpass
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from invoke import Argument, Collection, Exit, Program
<span class="w"> </span>from invoke import __version__ as invoke
<span class="w"> </span>from paramiko import __version__ as paramiko, Agent
<span class="gi">+</span>
<span class="w"> </span>from . import __version__ as fabric
<span class="w"> </span>from . import Config, Executor


<span class="w"> </span>class Fab(Program):
<span class="gd">-    pass</span>
<span class="gi">+    def print_version(self):</span>
<span class="gi">+        super().print_version()</span>
<span class="gi">+        print(&quot;Paramiko {}&quot;.format(paramiko))</span>
<span class="gi">+        print(&quot;Invoke {}&quot;.format(invoke))</span>
<span class="gi">+</span>
<span class="gi">+    def core_args(self):</span>
<span class="gi">+        core_args = super().core_args()</span>
<span class="gi">+        my_args = [</span>
<span class="gi">+            Argument(</span>
<span class="gi">+                names=(&quot;H&quot;, &quot;hosts&quot;),</span>
<span class="gi">+                help=&quot;Comma-separated host name(s) to execute tasks against.&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Argument(</span>
<span class="gi">+                names=(&quot;i&quot;, &quot;identity&quot;),</span>
<span class="gi">+                kind=list,  # Same as OpenSSH, can give &gt;1 key</span>
<span class="gi">+                # TODO: automatically add hint about iterable-ness to Invoke</span>
<span class="gi">+                # help display machinery?</span>
<span class="gi">+                help=&quot;Path to runtime SSH identity (key) file. May be given multiple times.&quot;,  # noqa</span>
<span class="gi">+            ),</span>
<span class="gi">+            Argument(</span>
<span class="gi">+                names=(&quot;list-agent-keys&quot;,),</span>
<span class="gi">+                kind=bool,</span>
<span class="gi">+                help=&quot;Display ssh-agent key list, and exit.&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            # TODO: worth having short flags for these prompt args?</span>
<span class="gi">+            Argument(</span>
<span class="gi">+                names=(&quot;prompt-for-login-password&quot;,),</span>
<span class="gi">+                kind=bool,</span>
<span class="gi">+                help=&quot;Request an upfront SSH-auth password prompt.&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Argument(</span>
<span class="gi">+                names=(&quot;prompt-for-passphrase&quot;,),</span>
<span class="gi">+                kind=bool,</span>
<span class="gi">+                help=&quot;Request an upfront SSH key passphrase prompt.&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Argument(</span>
<span class="gi">+                names=(&quot;S&quot;, &quot;ssh-config&quot;),</span>
<span class="gi">+                help=&quot;Path to runtime SSH config file.&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Argument(</span>
<span class="gi">+                names=(&quot;t&quot;, &quot;connect-timeout&quot;),</span>
<span class="gi">+                kind=int,</span>
<span class="gi">+                help=&quot;Specifies default connection timeout, in seconds.&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+        ]</span>
<span class="gi">+        return core_args + my_args</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _remainder_only(self):</span>
<span class="gi">+        # No &#39;unparsed&#39; (i.e. tokens intended for task contexts), and remainder</span>
<span class="gi">+        # (text after a double-dash) implies a contextless/taskless remainder</span>
<span class="gi">+        # execution of the style &#39;fab -H host -- command&#39;.</span>
<span class="gi">+        # NOTE: must ALSO check to ensure the double dash isn&#39;t being used for</span>
<span class="gi">+        # tab completion machinery...</span>
<span class="gi">+        return (</span>
<span class="gi">+            not self.core.unparsed</span>
<span class="gi">+            and self.core.remainder</span>
<span class="gi">+            and not self.args.complete.value</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def load_collection(self):</span>
<span class="gi">+        # Stick in a dummy Collection if it looks like we were invoked w/o any</span>
<span class="gi">+        # tasks, and with a remainder.</span>
<span class="gi">+        # This isn&#39;t super ideal, but Invoke proper has no obvious &quot;just run my</span>
<span class="gi">+        # remainder&quot; use case, so having it be capable of running w/o any task</span>
<span class="gi">+        # module, makes no sense. But we want that capability for testing &amp;</span>
<span class="gi">+        # things like &#39;fab -H x,y,z -- mycommand&#39;.</span>
<span class="gi">+        if self._remainder_only:</span>
<span class="gi">+            # TODO: hm we&#39;re probably not honoring project-specific configs in</span>
<span class="gi">+            # this branch; is it worth having it assume CWD==project, since</span>
<span class="gi">+            # that&#39;s often what users expect? Even tho no task collection to</span>
<span class="gi">+            # honor the real &quot;lives by task coll&quot;?</span>
<span class="gi">+            self.collection = Collection()</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().load_collection()</span>
<span class="gi">+</span>
<span class="gi">+    def no_tasks_given(self):</span>
<span class="gi">+        # As above, neuter the usual &quot;hey you didn&#39;t give me any tasks, let me</span>
<span class="gi">+        # print help for you&quot; behavior, if necessary.</span>
<span class="gi">+        if not self._remainder_only:</span>
<span class="gi">+            super().no_tasks_given()</span>
<span class="gi">+</span>
<span class="gi">+    def create_config(self):</span>
<span class="gi">+        # Create config, as parent does, but with lazy=True to avoid our own</span>
<span class="gi">+        # SSH config autoload. (Otherwise, we can&#39;t correctly load _just_ the</span>
<span class="gi">+        # runtime file if one&#39;s being given later.)</span>
<span class="gi">+        self.config = self.config_class(lazy=True)</span>
<span class="gi">+        # However, we don&#39;t really want the parent class&#39; lazy behavior (which</span>
<span class="gi">+        # skips loading system/global invoke-type conf files) so we manually do</span>
<span class="gi">+        # that here to match upstream behavior.</span>
<span class="gi">+        self.config.load_base_conf_files()</span>
<span class="gi">+        # And merge again so that data is available.</span>
<span class="gi">+        # TODO: really need to either A) stop giving fucks about calling</span>
<span class="gi">+        # merge() &quot;too many times&quot;, or B) make merge() itself determine whether</span>
<span class="gi">+        # it needs to run and/or just merge stuff that&#39;s changed, so log spam</span>
<span class="gi">+        # isn&#39;t as bad.</span>
<span class="gi">+        self.config.merge()</span>
<span class="gi">+</span>
<span class="gi">+    def update_config(self):</span>
<span class="gi">+        # Note runtime SSH path, if given, and load SSH configurations.</span>
<span class="gi">+        # NOTE: must do parent before our work, in case users want to disable</span>
<span class="gi">+        # SSH config loading within a runtime-level conf file/flag.</span>
<span class="gi">+        super().update_config(merge=False)</span>
<span class="gi">+        self.config.set_runtime_ssh_path(self.args[&quot;ssh-config&quot;].value)</span>
<span class="gi">+        self.config.load_ssh_config()</span>
<span class="gi">+        # Load -i identity file, if given, into connect_kwargs, at overrides</span>
<span class="gi">+        # level.</span>
<span class="gi">+        connect_kwargs = {}</span>
<span class="gi">+        paths = self.args[&quot;identity&quot;].value</span>
<span class="gi">+        if paths:</span>
<span class="gi">+            connect_kwargs[&quot;key_filename&quot;] = paths</span>
<span class="gi">+            # New, non-sshclient based config location</span>
<span class="gi">+            # Also new: Path! (which we couldn&#39;t use above until paramiko knew</span>
<span class="gi">+            # about it)</span>
<span class="gi">+            self.config._overrides[&quot;authentication&quot;] = dict(</span>
<span class="gi">+                identities=[Path(x) for x in paths]</span>
<span class="gi">+            )</span>
<span class="gi">+        # Ditto for connect timeout</span>
<span class="gi">+        timeout = self.args[&quot;connect-timeout&quot;].value</span>
<span class="gi">+        if timeout:</span>
<span class="gi">+            connect_kwargs[&quot;timeout&quot;] = timeout</span>
<span class="gi">+        # Secrets prompts that want to happen at handoff time instead of</span>
<span class="gi">+        # later/at user-time.</span>
<span class="gi">+        # TODO: should this become part of Invoke proper in case other</span>
<span class="gi">+        # downstreams have need of it? E.g. a prompt Argument &#39;type&#39;? We&#39;re</span>
<span class="gi">+        # already doing a similar thing there for sudo password...</span>
<span class="gi">+        if self.args[&quot;prompt-for-login-password&quot;].value:</span>
<span class="gi">+            prompt = &quot;Enter login password for use with SSH auth: &quot;</span>
<span class="gi">+            connect_kwargs[&quot;password&quot;] = getpass.getpass(prompt)</span>
<span class="gi">+        if self.args[&quot;prompt-for-passphrase&quot;].value:</span>
<span class="gi">+            prompt = &quot;Enter passphrase for use unlocking SSH keys: &quot;</span>
<span class="gi">+            connect_kwargs[&quot;passphrase&quot;] = getpass.getpass(prompt)</span>
<span class="gi">+        # TODO: this (directly manipulating _overrides) feels a little gross,</span>
<span class="gi">+        # but since the parent has already called load_overrides, this is best</span>
<span class="gi">+        # we can do for now w/o losing data. Still feels correct; just might be</span>
<span class="gi">+        # cleaner to have even more Config API members around this sort of</span>
<span class="gi">+        # thing. Shrug.</span>
<span class="gi">+        self.config._overrides[&quot;connect_kwargs&quot;] = connect_kwargs</span>
<span class="gi">+        # Since we gave merge=False above, we must do it ourselves here. (Also</span>
<span class="gi">+        # allows us to &#39;compile&#39; our overrides manipulation.)</span>
<span class="gi">+        self.config.merge()</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: make this an explicit hookpoint in Invoke, i.e. some default-noop</span>
<span class="gi">+    # method called at the end of parse_core() that we can override here</span>
<span class="gi">+    # instead of doing this.</span>
<span class="gi">+    def parse_core(self, *args, **kwargs):</span>
<span class="gi">+        super().parse_core(*args, **kwargs)</span>
<span class="gi">+        if self.args[&quot;list-agent-keys&quot;].value:</span>
<span class="gi">+            keys = Agent().get_keys()</span>
<span class="gi">+            for key in keys:</span>
<span class="gi">+                tpl = &quot;{} {} {} ({})&quot;</span>
<span class="gi">+                # TODO: _could_ use new PKey.__repr__ but I like the mimicry of</span>
<span class="gi">+                # OpenSSH ssh-add -l for now...</span>
<span class="gi">+                print(</span>
<span class="gi">+                    tpl.format(</span>
<span class="gi">+                        key.get_bits(),</span>
<span class="gi">+                        key.fingerprint,</span>
<span class="gi">+                        key.comment,</span>
<span class="gi">+                        key.algorithm_name,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            raise Exit</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Mostly a concession to testing.</span>
<span class="gi">+def make_program():</span>
<span class="gi">+    return Fab(</span>
<span class="gi">+        name=&quot;Fabric&quot;,</span>
<span class="gi">+        version=fabric,</span>
<span class="gi">+        executor_class=Executor,</span>
<span class="gi">+        config_class=Config,</span>
<span class="gi">+    )</span>


<span class="w"> </span>program = make_program()
<span class="gh">diff --git a/fabric/runners.py b/fabric/runners.py</span>
<span class="gh">index 53763d27..587e5f79 100644</span>
<span class="gd">--- a/fabric/runners.py</span>
<span class="gi">+++ b/fabric/runners.py</span>
<span class="gu">@@ -1,8 +1,16 @@</span>
<span class="w"> </span>import signal
<span class="w"> </span>import threading
<span class="gi">+</span>
<span class="w"> </span>from invoke import Runner, pty_size, Result as InvokeResult


<span class="gi">+def cares_about_SIGWINCH():</span>
<span class="gi">+    return (</span>
<span class="gi">+        hasattr(signal, &quot;SIGWINCH&quot;)</span>
<span class="gi">+        and threading.current_thread() is threading.main_thread()</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Remote(Runner):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Run a shell command over an SSH connection.
<span class="gu">@@ -34,20 +42,131 @@ class Remote(Runner):</span>
<span class="w"> </span>            Changed the default value of ``inline_env`` from ``False`` to
<span class="w"> </span>            ``True``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self.inline_env = kwargs.pop(&#39;inline_env&#39;, None)</span>
<span class="gi">+        self.inline_env = kwargs.pop(&quot;inline_env&quot;, None)</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gi">+    def start(self, command, shell, env, timeout=None):</span>
<span class="gi">+        self.channel = self.context.create_session()</span>
<span class="gi">+        if self.using_pty:</span>
<span class="gi">+            # Set initial size to match local size</span>
<span class="gi">+            cols, rows = pty_size()</span>
<span class="gi">+            self.channel.get_pty(width=cols, height=rows)</span>
<span class="gi">+            # If platform supports, also respond to SIGWINCH (window change) by</span>
<span class="gi">+            # sending the sshd a window-change message to update</span>
<span class="gi">+            if cares_about_SIGWINCH():</span>
<span class="gi">+                signal.signal(signal.SIGWINCH, self.handle_window_change)</span>
<span class="gi">+        if env:</span>
<span class="gi">+            # TODO: honor SendEnv from ssh_config (but if we do, _should_ we</span>
<span class="gi">+            # honor it even when prefixing? That would depart from OpenSSH</span>
<span class="gi">+            # somewhat (albeit as a &quot;what we can do that it cannot&quot; feature...)</span>
<span class="gi">+            if self.inline_env:</span>
<span class="gi">+                # TODO: escaping, if we can find a FOOLPROOF THIRD PARTY METHOD</span>
<span class="gi">+                # for doing so!</span>
<span class="gi">+                # TODO: switch to using a higher-level generic command</span>
<span class="gi">+                # prefixing functionality, when implemented.</span>
<span class="gi">+                parameters = &quot; &quot;.join(</span>
<span class="gi">+                    [&quot;{}={}&quot;.format(k, v) for k, v in sorted(env.items())]</span>
<span class="gi">+                )</span>
<span class="gi">+                # NOTE: we can assume &#39;export&#39; and &#39;&amp;&amp;&#39; relatively safely, as</span>
<span class="gi">+                # sshd always brings some shell into play, even if it&#39;s just</span>
<span class="gi">+                # /bin/sh.</span>
<span class="gi">+                command = &quot;export {} &amp;&amp; {}&quot;.format(parameters, command)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.channel.update_environment(env)</span>
<span class="gi">+        self.send_start_message(command)</span>
<span class="gi">+</span>
<span class="gi">+    def send_start_message(self, command):</span>
<span class="gi">+        self.channel.exec_command(command)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, command, **kwargs):</span>
<span class="gi">+        kwargs.setdefault(&quot;replace_env&quot;, True)</span>
<span class="gi">+        return super().run(command, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def read_proc_stdout(self, num_bytes):</span>
<span class="gi">+        return self.channel.recv(num_bytes)</span>
<span class="gi">+</span>
<span class="gi">+    def read_proc_stderr(self, num_bytes):</span>
<span class="gi">+        return self.channel.recv_stderr(num_bytes)</span>
<span class="gi">+</span>
<span class="gi">+    def _write_proc_stdin(self, data):</span>
<span class="gi">+        return self.channel.sendall(data)</span>
<span class="gi">+</span>
<span class="gi">+    def close_proc_stdin(self):</span>
<span class="gi">+        return self.channel.shutdown_write()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def process_is_finished(self):</span>
<span class="gi">+        return self.channel.exit_status_ready()</span>
<span class="gi">+</span>
<span class="gi">+    def send_interrupt(self, interrupt):</span>
<span class="gi">+        # NOTE: in v1, we just reraised the KeyboardInterrupt unless a PTY was</span>
<span class="gi">+        # present; this seems to have been because without a PTY, the</span>
<span class="gi">+        # below escape sequence is ignored, so all we can do is immediately</span>
<span class="gi">+        # terminate on our end.</span>
<span class="gi">+        # NOTE: also in v1, the raising of the KeyboardInterrupt completely</span>
<span class="gi">+        # skipped all thread joining &amp; cleanup; presumably regular interpreter</span>
<span class="gi">+        # shutdown suffices to tie everything off well enough.</span>
<span class="gi">+        if self.using_pty:</span>
<span class="gi">+            # Submit hex ASCII character 3, aka ETX, which most Unix PTYs</span>
<span class="gi">+            # interpret as a foreground SIGINT.</span>
<span class="gi">+            # TODO: is there anything else we can do here to be more portable?</span>
<span class="gi">+            self.channel.send(&quot;\x03&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise interrupt</span>
<span class="gi">+</span>
<span class="gi">+    def returncode(self):</span>
<span class="gi">+        return self.channel.recv_exit_status()</span>
<span class="gi">+</span>
<span class="gi">+    def generate_result(self, **kwargs):</span>
<span class="gi">+        kwargs[&quot;connection&quot;] = self.context</span>
<span class="gi">+        return Result(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self):</span>
<span class="gi">+        super().stop()</span>
<span class="gi">+        if hasattr(self, &quot;channel&quot;):</span>
<span class="gi">+            self.channel.close()</span>
<span class="gi">+        if cares_about_SIGWINCH():</span>
<span class="gi">+            signal.signal(signal.SIGWINCH, signal.SIG_DFL)</span>
<span class="gi">+</span>
<span class="gi">+    def kill(self):</span>
<span class="gi">+        # Just close the channel immediately, which is about as close as we can</span>
<span class="gi">+        # get to a local SIGKILL unfortunately.</span>
<span class="gi">+        # TODO: consider _also_ calling .send_interrupt() and only doing this</span>
<span class="gi">+        # after another few seconds; but A) kinda fragile/complex and B) would</span>
<span class="gi">+        # belong in invoke.Runner anyways?</span>
<span class="gi">+        self.channel.close()</span>
<span class="gi">+</span>
<span class="w"> </span>    def handle_window_change(self, signum, frame):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Respond to a `signal.SIGWINCH` (as a standard signal handler).

<span class="w"> </span>        Sends a window resize command via Paramiko channel method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.channel.resize_pty(*pty_size())</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: shit that is in fab 1 run() but could apply to invoke.Local too:</span>
<span class="gi">+    # * see rest of stuff in _run_command/_execute in operations.py...there is</span>
<span class="gi">+    # a bunch that applies generally like optional exit codes, etc</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: general shit not done yet</span>
<span class="gi">+    # * stdin; Local relies on local process management to ensure stdin is</span>
<span class="gi">+    # hooked up; we cannot do that.</span>
<span class="gi">+    # * output prefixing</span>
<span class="gi">+    # * agent forwarding</span>
<span class="gi">+    # * reading at 4096 bytes/time instead of whatever inv defaults to (also,</span>
<span class="gi">+    # document why we are doing that, iirc it changed recentlyish via ticket)</span>
<span class="gi">+    # * TODO: oh god so much more, go look it up</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: shit that has no Local equivalent that we probs need to backfill</span>
<span class="gi">+    # into Runner, probably just as a &quot;finish()&quot; or &quot;stop()&quot; (to mirror</span>
<span class="gi">+    # start()):</span>
<span class="gi">+    # * channel close()</span>
<span class="gi">+    # * agent-forward close()</span>


<span class="w"> </span>class RemoteShell(Remote):
<span class="gd">-    pass</span>
<span class="gi">+    def send_start_message(self, command):</span>
<span class="gi">+        self.channel.invoke_shell()</span>


<span class="w"> </span>class Result(InvokeResult):
<span class="gu">@@ -62,6 +181,9 @@ class Result(InvokeResult):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, **kwargs):
<span class="gd">-        connection = kwargs.pop(&#39;connection&#39;)</span>
<span class="gi">+        connection = kwargs.pop(&quot;connection&quot;)</span>
<span class="w"> </span>        super().__init__(**kwargs)
<span class="w"> </span>        self.connection = connection
<span class="gi">+</span>
<span class="gi">+    # TODO: have useful str/repr differentiation from invoke.Result,</span>
<span class="gi">+    # transfer.Result etc.</span>
<span class="gh">diff --git a/fabric/tasks.py b/fabric/tasks.py</span>
<span class="gh">index 093c8e74..acf89d0c 100644</span>
<span class="gd">--- a/fabric/tasks.py</span>
<span class="gi">+++ b/fabric/tasks.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>import invoke
<span class="gi">+</span>
<span class="w"> </span>from .connection import Connection


<span class="gu">@@ -14,7 +15,9 @@ class Task(invoke.Task):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="gd">-        self.hosts = kwargs.pop(&#39;hosts&#39;, None)</span>
<span class="gi">+        # Pull out our own kwargs before hitting super, which will TypeError on</span>
<span class="gi">+        # anything it doesn&#39;t know about.</span>
<span class="gi">+        self.hosts = kwargs.pop(&quot;hosts&quot;, None)</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)


<span class="gu">@@ -62,7 +65,10 @@ def task(*args, **kwargs):</span>

<span class="w"> </span>    .. versionadded:: 2.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Override klass to be our own Task, not Invoke&#39;s, unless somebody gave it</span>
<span class="gi">+    # explicitly.</span>
<span class="gi">+    kwargs.setdefault(&quot;klass&quot;, Task)</span>
<span class="gi">+    return invoke.task(*args, **kwargs)</span>


<span class="w"> </span>class ConnectionCall(invoke.Call):
<span class="gu">@@ -81,12 +87,30 @@ class ConnectionCall(invoke.Call):</span>
<span class="w"> </span>            Keyword arguments used to create a new `.Connection` when the
<span class="w"> </span>            wrapped task is executed. Default: ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        init_kwargs = kwargs.pop(&#39;init_kwargs&#39;)</span>
<span class="gi">+        init_kwargs = kwargs.pop(&quot;init_kwargs&quot;)  # , None)</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self.init_kwargs = init_kwargs

<span class="gi">+    def clone_kwargs(self):</span>
<span class="gi">+        # Extend superclass clone_kwargs to work in init_kwargs.</span>
<span class="gi">+        # TODO: this pattern comes up a lot; is there a better way to handle it</span>
<span class="gi">+        # without getting too crazy on the metaprogramming/over-engineering?</span>
<span class="gi">+        # Maybe something attrs library can help with (re: declaring &quot;These are</span>
<span class="gi">+        # my bag-of-attributes attributes I want common stuff done to/with&quot;)</span>
<span class="gi">+        kwargs = super().clone_kwargs()</span>
<span class="gi">+        kwargs[&quot;init_kwargs&quot;] = self.init_kwargs</span>
<span class="gi">+        return kwargs</span>
<span class="gi">+</span>
<span class="gi">+    def make_context(self, config):</span>
<span class="gi">+        kwargs = self.init_kwargs</span>
<span class="gi">+        # TODO: what about corner case of a decorator giving config in a hosts</span>
<span class="gi">+        # kwarg member?! For now let&#39;s stomp on it, and then if somebody runs</span>
<span class="gi">+        # into it, we can identify the use case &amp; decide how best to deal.</span>
<span class="gi">+        kwargs[&quot;config&quot;] = config</span>
<span class="gi">+        return Connection(**kwargs)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        ret = super().__repr__()
<span class="w"> </span>        if self.init_kwargs:
<span class="gd">-            ret = ret[:-1] + &quot;, host=&#39;{}&#39;&gt;&quot;.format(self.init_kwargs[&#39;host&#39;])</span>
<span class="gi">+            ret = ret[:-1] + &quot;, host=&#39;{}&#39;&gt;&quot;.format(self.init_kwargs[&quot;host&quot;])</span>
<span class="w"> </span>        return ret
<span class="gh">diff --git a/fabric/testing/base.py b/fabric/testing/base.py</span>
<span class="gh">index c232e492..97a4b441 100644</span>
<span class="gd">--- a/fabric/testing/base.py</span>
<span class="gi">+++ b/fabric/testing/base.py</span>
<span class="gu">@@ -14,14 +14,20 @@ purposes: ``pip install fabric[testing]``.</span>

<span class="w"> </span>.. versionadded:: 2.1
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from itertools import chain, repeat
<span class="w"> </span>from io import BytesIO
<span class="w"> </span>from unittest.mock import Mock, PropertyMock, call, patch, ANY
<span class="gi">+</span>
<span class="w"> </span>from deprecated.sphinx import deprecated
<span class="w"> </span>from deprecated.classic import deprecated as deprecated_no_docstring


<span class="gi">+# TODO 4.0: reorganize harder (eg building blocks in one module, central</span>
<span class="gi">+# classes in another?)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Command:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Data record specifying params of a command execution to mock/expect.
<span class="gu">@@ -44,7 +50,7 @@ class Command:</span>
<span class="w"> </span>    .. versionadded:: 2.1
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, cmd=None, out=b&#39;&#39;, err=b&#39;&#39;, in_=None, exit=0, waits=0):</span>
<span class="gi">+    def __init__(self, cmd=None, out=b&quot;&quot;, err=b&quot;&quot;, in_=None, exit=0, waits=0):</span>
<span class="w"> </span>        self.cmd = cmd
<span class="w"> </span>        self.out = out
<span class="w"> </span>        self.err = err
<span class="gu">@@ -53,7 +59,9 @@ class Command:</span>
<span class="w"> </span>        self.waits = waits

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;{} cmd={!r}&gt;&#39;.format(self.__class__.__name__, self.cmd)</span>
<span class="gi">+        # TODO: just leverage attrs, maybe vendored into Invoke so we don&#39;t</span>
<span class="gi">+        # grow more dependencies? Ehhh</span>
<span class="gi">+        return &quot;&lt;{} cmd={!r}&gt;&quot;.format(self.__class__.__name__, self.cmd)</span>

<span class="w"> </span>    def expect_execution(self, channel):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -61,7 +69,7 @@ class Command:</span>

<span class="w"> </span>        .. versionadded:: 2.7
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        channel.exec_command.assert_called_with(self.cmd or ANY)</span>


<span class="w"> </span>class ShellCommand(Command):
<span class="gu">@@ -71,6 +79,9 @@ class ShellCommand(Command):</span>
<span class="w"> </span>    .. versionadded:: 2.7
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def expect_execution(self, channel):</span>
<span class="gi">+        channel.invoke_shell.assert_called_once_with()</span>
<span class="gi">+</span>

<span class="w"> </span>class MockChannel(Mock):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -83,11 +94,27 @@ class MockChannel(Mock):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="gd">-        object.__setattr__(self, &#39;__stdout&#39;, kwargs.pop(&#39;stdout&#39;))</span>
<span class="gd">-        object.__setattr__(self, &#39;__stderr&#39;, kwargs.pop(&#39;stderr&#39;))</span>
<span class="gd">-        object.__setattr__(self, &#39;_stdin&#39;, BytesIO())</span>
<span class="gi">+        # TODO: worth accepting strings and doing the BytesIO setup ourselves?</span>
<span class="gi">+        # Stored privately to avoid any possible collisions ever. shrug.</span>
<span class="gi">+        object.__setattr__(self, &quot;__stdout&quot;, kwargs.pop(&quot;stdout&quot;))</span>
<span class="gi">+        object.__setattr__(self, &quot;__stderr&quot;, kwargs.pop(&quot;stderr&quot;))</span>
<span class="gi">+        # Stdin less private so it can be asserted about</span>
<span class="gi">+        object.__setattr__(self, &quot;_stdin&quot;, BytesIO())</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gi">+    def _get_child_mock(self, **kwargs):</span>
<span class="gi">+        # Don&#39;t return our own class on sub-mocks.</span>
<span class="gi">+        return Mock(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def recv(self, count):</span>
<span class="gi">+        return object.__getattribute__(self, &quot;__stdout&quot;).read(count)</span>
<span class="gi">+</span>
<span class="gi">+    def recv_stderr(self, count):</span>
<span class="gi">+        return object.__getattribute__(self, &quot;__stderr&quot;).read(count)</span>
<span class="gi">+</span>
<span class="gi">+    def sendall(self, data):</span>
<span class="gi">+        return object.__getattribute__(self, &quot;_stdin&quot;).write(data)</span>
<span class="gi">+</span>

<span class="w"> </span>class Session:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -131,33 +158,51 @@ class Session:</span>
<span class="w"> </span>        Added the ``enable_sftp`` and ``transfers`` parameters.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, host=None, user=None, port=None, commands=None, cmd=</span>
<span class="gd">-        None, out=None, in_=None, err=None, exit=None, waits=None,</span>
<span class="gd">-        enable_sftp=False, transfers=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        host=None,</span>
<span class="gi">+        user=None,</span>
<span class="gi">+        port=None,</span>
<span class="gi">+        commands=None,</span>
<span class="gi">+        cmd=None,</span>
<span class="gi">+        out=None,</span>
<span class="gi">+        in_=None,</span>
<span class="gi">+        err=None,</span>
<span class="gi">+        exit=None,</span>
<span class="gi">+        waits=None,</span>
<span class="gi">+        enable_sftp=False,</span>
<span class="gi">+        transfers=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Safety check</span>
<span class="w"> </span>        params = cmd or out or err or exit or waits
<span class="w"> </span>        if commands and params:
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &quot;You can&#39;t give both &#39;commands&#39; and individual Command parameters!&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+                &quot;You can&#39;t give both &#39;commands&#39; and individual &quot;</span>
<span class="gi">+                &quot;Command parameters!&quot;</span>
<span class="gi">+            )  # noqa</span>
<span class="gi">+        # Early test for &quot;did user actually request expectations?&quot;</span>
<span class="w"> </span>        self.guard_only = not (commands or cmd or transfers)
<span class="gi">+        # Fill in values</span>
<span class="w"> </span>        self.host = host
<span class="w"> </span>        self.user = user
<span class="w"> </span>        self.port = port
<span class="w"> </span>        self.commands = commands
<span class="w"> </span>        if params:
<span class="gi">+            # Honestly dunno which is dumber, this or duplicating Command&#39;s</span>
<span class="gi">+            # default kwarg values in this method&#39;s signature...sigh</span>
<span class="w"> </span>            kwargs = {}
<span class="w"> </span>            if cmd is not None:
<span class="gd">-                kwargs[&#39;cmd&#39;] = cmd</span>
<span class="gi">+                kwargs[&quot;cmd&quot;] = cmd</span>
<span class="w"> </span>            if out is not None:
<span class="gd">-                kwargs[&#39;out&#39;] = out</span>
<span class="gi">+                kwargs[&quot;out&quot;] = out</span>
<span class="w"> </span>            if err is not None:
<span class="gd">-                kwargs[&#39;err&#39;] = err</span>
<span class="gi">+                kwargs[&quot;err&quot;] = err</span>
<span class="w"> </span>            if in_ is not None:
<span class="gd">-                kwargs[&#39;in_&#39;] = in_</span>
<span class="gi">+                kwargs[&quot;in_&quot;] = in_</span>
<span class="w"> </span>            if exit is not None:
<span class="gd">-                kwargs[&#39;exit&#39;] = exit</span>
<span class="gi">+                kwargs[&quot;exit&quot;] = exit</span>
<span class="w"> </span>            if waits is not None:
<span class="gd">-                kwargs[&#39;waits&#39;] = waits</span>
<span class="gi">+                kwargs[&quot;waits&quot;] = waits</span>
<span class="w"> </span>            self.commands = [Command(**kwargs)]
<span class="w"> </span>        if not self.commands:
<span class="w"> </span>            self.commands = [Command()]
<span class="gu">@@ -184,7 +229,121 @@ class Session:</span>

<span class="w"> </span>        .. versionadded:: 2.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        client = Mock()</span>
<span class="gi">+        transport = client.get_transport.return_value  # another Mock</span>
<span class="gi">+</span>
<span class="gi">+        # NOTE: this originally did chain([False], repeat(True)) so that</span>
<span class="gi">+        # get_transport().active was False initially, then True. However,</span>
<span class="gi">+        # because we also have to consider when get_transport() comes back None</span>
<span class="gi">+        # (which it does initially), the case where we get back a non-None</span>
<span class="gi">+        # transport _and_ it&#39;s not active yet, isn&#39;t useful to test, and</span>
<span class="gi">+        # complicates text expectations. So we don&#39;t, for now.</span>
<span class="gi">+        actives = repeat(True)</span>
<span class="gi">+        # NOTE: setting PropertyMocks on a mock&#39;s type() is apparently</span>
<span class="gi">+        # How It Must Be Done, otherwise it sets the real attr value.</span>
<span class="gi">+        type(transport).active = PropertyMock(side_effect=actives)</span>
<span class="gi">+</span>
<span class="gi">+        channels = []</span>
<span class="gi">+        for command in self.commands:</span>
<span class="gi">+            # Mock of a Channel instance, not e.g. Channel-the-class.</span>
<span class="gi">+            # Specifically, one that can track individual state for recv*().</span>
<span class="gi">+            channel = MockChannel(</span>
<span class="gi">+                stdout=BytesIO(command.out), stderr=BytesIO(command.err)</span>
<span class="gi">+            )</span>
<span class="gi">+            channel.recv_exit_status.return_value = command.exit</span>
<span class="gi">+</span>
<span class="gi">+            # If requested, make exit_status_ready return False the first N</span>
<span class="gi">+            # times it is called in the wait() loop.</span>
<span class="gi">+            readies = chain(repeat(False, command.waits), repeat(True))</span>
<span class="gi">+            channel.exit_status_ready.side_effect = readies</span>
<span class="gi">+</span>
<span class="gi">+            channels.append(channel)</span>
<span class="gi">+</span>
<span class="gi">+        # Have our transport yield those channel mocks in order when</span>
<span class="gi">+        # open_session() is called.</span>
<span class="gi">+        transport.open_session.side_effect = channels</span>
<span class="gi">+</span>
<span class="gi">+        # SFTP, if enabled</span>
<span class="gi">+        if self._enable_sftp:</span>
<span class="gi">+            self._start_sftp(client)</span>
<span class="gi">+</span>
<span class="gi">+        self.client = client</span>
<span class="gi">+        self.channels = channels</span>
<span class="gi">+</span>
<span class="gi">+    def _start_sftp(self, client):</span>
<span class="gi">+        # Patch os module for local stat and similar</span>
<span class="gi">+        self.os_patcher = patch(&quot;fabric.transfer.os&quot;)</span>
<span class="gi">+        mock_os = self.os_patcher.start()</span>
<span class="gi">+        # Patch Path class inside transfer.py to prevent real fs touchery</span>
<span class="gi">+        self.path_patcher = patch(&quot;fabric.transfer.Path&quot;)</span>
<span class="gi">+        self.path_patcher.start()</span>
<span class="gi">+        self.sftp = sftp = client.open_sftp.return_value</span>
<span class="gi">+</span>
<span class="gi">+        # Handle common filepath massage actions; tests will assume these.</span>
<span class="gi">+        def fake_abspath(path):</span>
<span class="gi">+            # Run normpath to avoid tests not seeing abspath wrinkles (like</span>
<span class="gi">+            # trailing slash chomping)</span>
<span class="gi">+            return &quot;/local/{}&quot;.format(os.path.normpath(path))</span>
<span class="gi">+</span>
<span class="gi">+        mock_os.path.abspath.side_effect = fake_abspath</span>
<span class="gi">+        sftp.getcwd.return_value = &quot;/remote&quot;</span>
<span class="gi">+        # Ensure stat st_mode is a real number; Python 3&#39;s stat.S_IMODE doesn&#39;t</span>
<span class="gi">+        # like just being handed a MagicMock?</span>
<span class="gi">+        fake_mode = 0o644  # arbitrary real-ish mode</span>
<span class="gi">+        sftp.stat.return_value.st_mode = fake_mode</span>
<span class="gi">+        mock_os.stat.return_value.st_mode = fake_mode</span>
<span class="gi">+        # Not super clear to me why the &#39;wraps&#39; functionality in mock isn&#39;t</span>
<span class="gi">+        # working for this :( reinstate a bunch of os(.path) so it still works</span>
<span class="gi">+        mock_os.sep = os.sep</span>
<span class="gi">+        for name in (&quot;basename&quot;, &quot;split&quot;, &quot;join&quot;, &quot;normpath&quot;):</span>
<span class="gi">+            getattr(mock_os.path, name).side_effect = getattr(os.path, name)</span>
<span class="gi">+</span>
<span class="gi">+    @deprecated_no_docstring(</span>
<span class="gi">+        version=&quot;3.2&quot;,</span>
<span class="gi">+        reason=&quot;This method has been renamed to `safety_check` &amp; will be removed in 4.0&quot;,  # noqa</span>
<span class="gi">+    )</span>
<span class="gi">+    def sanity_check(self):</span>
<span class="gi">+        return self.safety_check()</span>
<span class="gi">+</span>
<span class="gi">+    def safety_check(self):</span>
<span class="gi">+        # Short-circuit if user didn&#39;t give any expectations; otherwise our</span>
<span class="gi">+        # assumptions below will be inaccurately violated and explode.</span>
<span class="gi">+        if self.guard_only:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Per-session we expect a single transport get</span>
<span class="gi">+        transport = self.client.get_transport</span>
<span class="gi">+        transport.assert_called_once_with()</span>
<span class="gi">+        # And a single connect to our target host.</span>
<span class="gi">+        self.client.connect.assert_called_once_with(</span>
<span class="gi">+            username=self.user or ANY,</span>
<span class="gi">+            hostname=self.host or ANY,</span>
<span class="gi">+            port=self.port or ANY,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Calls to open_session will be 1-per-command but are on transport, not</span>
<span class="gi">+        # channel, so we can only really inspect how many happened in</span>
<span class="gi">+        # aggregate. Save a list for later comparison to call_args.</span>
<span class="gi">+        session_opens = []</span>
<span class="gi">+</span>
<span class="gi">+        for channel, command in zip(self.channels, self.commands):</span>
<span class="gi">+            # Expect an open_session for each command exec</span>
<span class="gi">+            session_opens.append(call())</span>
<span class="gi">+            # Expect that the channel gets an exec_command or etc</span>
<span class="gi">+            command.expect_execution(channel=channel)</span>
<span class="gi">+            # Expect written stdin, if given</span>
<span class="gi">+            if command.in_:</span>
<span class="gi">+                assert channel._stdin.getvalue() == command.in_</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure open_session was called expected number of times.</span>
<span class="gi">+        calls = transport.return_value.open_session.call_args_list</span>
<span class="gi">+        assert calls == session_opens</span>
<span class="gi">+</span>
<span class="gi">+        # SFTP transfers</span>
<span class="gi">+        for transfer in self.transfers or []:</span>
<span class="gi">+            method_name = transfer.pop(&quot;method&quot;)</span>
<span class="gi">+            method = getattr(self.sftp, method_name)</span>
<span class="gi">+            method.assert_any_call(**transfer)</span>

<span class="w"> </span>    def stop(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -192,7 +351,10 @@ class Session:</span>

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(self, &quot;os_patcher&quot;):</span>
<span class="gi">+            self.os_patcher.stop()</span>
<span class="gi">+        if hasattr(self, &quot;path_patcher&quot;):</span>
<span class="gi">+            self.path_patcher.stop()</span>


<span class="w"> </span>class MockRemote:
<span class="gu">@@ -222,6 +384,7 @@ class MockRemote:</span>
<span class="w"> </span>        remember to call `safety`/`stop`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    # TODO 4.0: delete enable_sftp and make its behavior default</span>
<span class="w"> </span>    def __init__(self, enable_sftp=False):
<span class="w"> </span>        self._enable_sftp = enable_sftp
<span class="w"> </span>        self.expect_sessions(Session(enable_sftp=enable_sftp))
<span class="gu">@@ -234,7 +397,8 @@ class MockRemote:</span>

<span class="w"> </span>        .. versionadded:: 2.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        kwargs.setdefault(&quot;enable_sftp&quot;, self._enable_sftp)</span>
<span class="gi">+        return self.expect_sessions(Session(*args, **kwargs))[0]</span>

<span class="w"> </span>    def expect_sessions(self, *sessions):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -244,15 +408,39 @@ class MockRemote:</span>

<span class="w"> </span>        .. versionadded:: 2.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        # First, stop the default session to clean up its state, if it seems to</span>
<span class="gi">+        # be running.</span>
<span class="gi">+        self.stop()</span>
<span class="gi">+        # Update sessions list with new session(s)</span>
<span class="gi">+        self.sessions = sessions</span>
<span class="gi">+        # And start patching again, returning mocked channels</span>
<span class="gi">+        return self.start()</span>
<span class="gi">+</span>
<span class="gi">+    # TODO 4.0: definitely clean this up once the SFTP bit isn&#39;t opt-in, doing</span>
<span class="gi">+    # that backwards compatibly was real gross</span>
<span class="w"> </span>    def start(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Start patching SSHClient with the stored sessions, returning channels.

<span class="w"> </span>        .. versionadded:: 2.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Patch SSHClient so the sessions&#39; generated mocks can be set as its</span>
<span class="gi">+        # return values</span>
<span class="gi">+        self.patcher = patcher = patch(&quot;fabric.connection.SSHClient&quot;)</span>
<span class="gi">+        SSHClient = patcher.start()</span>
<span class="gi">+        # Mock clients, to be inspected afterwards during safety-checks</span>
<span class="gi">+        clients = []</span>
<span class="gi">+        for session in self.sessions:</span>
<span class="gi">+            session.generate_mocks()</span>
<span class="gi">+            clients.append(session.client)</span>
<span class="gi">+        # Each time the mocked SSHClient class is instantiated, it will</span>
<span class="gi">+        # yield one of our mocked clients (w/ mocked transport &amp; channel, and</span>
<span class="gi">+        # optionally SFTP subclient) generated above.</span>
<span class="gi">+        SSHClient.side_effect = clients</span>
<span class="gi">+        sessions = list(chain.from_iterable(x.channels for x in self.sessions))</span>
<span class="gi">+        # TODO: in future we _may_ want to change this so it returns SFTP file</span>
<span class="gi">+        # data as well?</span>
<span class="gi">+        return sessions</span>

<span class="w"> </span>    def stop(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -260,17 +448,26 @@ class MockRemote:</span>

<span class="w"> </span>        .. versionadded:: 2.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @deprecated(version=&#39;3.2&#39;, reason=</span>
<span class="gd">-        &#39;This method has been renamed to `safety` &amp; will be removed in 4.0&#39;)</span>
<span class="gi">+        # Short circuit if we don&#39;t seem to have start()ed yet.</span>
<span class="gi">+        if not hasattr(self, &quot;patcher&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        # Stop patching SSHClient</span>
<span class="gi">+        self.patcher.stop()</span>
<span class="gi">+        # Also ask all sessions to stop any of their self-owned mocks</span>
<span class="gi">+        for session in self.sessions:</span>
<span class="gi">+            session.stop()</span>
<span class="gi">+</span>
<span class="gi">+    @deprecated(</span>
<span class="gi">+        version=&quot;3.2&quot;,</span>
<span class="gi">+        reason=&quot;This method has been renamed to `safety` &amp; will be removed in 4.0&quot;,  # noqa</span>
<span class="gi">+    )</span>
<span class="w"> </span>    def sanity(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Run post-execution sanity checks (usually &#39;was X called&#39; tests.)

<span class="w"> </span>        .. versionadded:: 2.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.safety()</span>

<span class="w"> </span>    def safety(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -278,7 +475,8 @@ class MockRemote:</span>

<span class="w"> </span>        .. versionadded:: 3.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for session in self.sessions:</span>
<span class="gi">+            session.safety_check()</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -290,9 +488,10 @@ class MockRemote:</span>
<span class="w"> </span>            self.stop()


<span class="gd">-@deprecated(version=&#39;3.2&#39;, reason=</span>
<span class="gd">-    &#39;This class has been merged with `MockRemote` which can now handle SFTP mocking too. Please switch to it!&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+@deprecated(</span>
<span class="gi">+    version=&quot;3.2&quot;,</span>
<span class="gi">+    reason=&quot;This class has been merged with `MockRemote` which can now handle SFTP mocking too. Please switch to it!&quot;,  # noqa</span>
<span class="gi">+)</span>
<span class="w"> </span>class MockSFTP:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Class managing mocked SFTP remote state.
<span class="gu">@@ -306,3 +505,39 @@ class MockSFTP:</span>
<span class="w"> </span>    def __init__(self, autostart=True):
<span class="w"> </span>        if autostart:
<span class="w"> </span>            self.start()
<span class="gi">+</span>
<span class="gi">+    def start(self):</span>
<span class="gi">+        # Set up mocks</span>
<span class="gi">+        self.os_patcher = patch(&quot;fabric.transfer.os&quot;)</span>
<span class="gi">+        self.client_patcher = patch(&quot;fabric.connection.SSHClient&quot;)</span>
<span class="gi">+        self.path_patcher = patch(&quot;fabric.transfer.Path&quot;)</span>
<span class="gi">+        mock_os = self.os_patcher.start()</span>
<span class="gi">+        Client = self.client_patcher.start()</span>
<span class="gi">+        self.path_patcher.start()</span>
<span class="gi">+        sftp = Client.return_value.open_sftp.return_value</span>
<span class="gi">+</span>
<span class="gi">+        # Handle common filepath massage actions; tests will assume these.</span>
<span class="gi">+        def fake_abspath(path):</span>
<span class="gi">+            # Run normpath to avoid tests not seeing abspath wrinkles (like</span>
<span class="gi">+            # trailing slash chomping)</span>
<span class="gi">+            return &quot;/local/{}&quot;.format(os.path.normpath(path))</span>
<span class="gi">+</span>
<span class="gi">+        mock_os.path.abspath.side_effect = fake_abspath</span>
<span class="gi">+        sftp.getcwd.return_value = &quot;/remote&quot;</span>
<span class="gi">+        # Ensure stat st_mode is a real number; Python 3&#39;s stat.S_IMODE doesn&#39;t</span>
<span class="gi">+        # like just being handed a MagicMock?</span>
<span class="gi">+        fake_mode = 0o644  # arbitrary real-ish mode</span>
<span class="gi">+        sftp.stat.return_value.st_mode = fake_mode</span>
<span class="gi">+        mock_os.stat.return_value.st_mode = fake_mode</span>
<span class="gi">+        # Not super clear to me why the &#39;wraps&#39; functionality in mock isn&#39;t</span>
<span class="gi">+        # working for this :( reinstate a bunch of os(.path) so it still works</span>
<span class="gi">+        mock_os.sep = os.sep</span>
<span class="gi">+        for name in (&quot;basename&quot;, &quot;split&quot;, &quot;join&quot;, &quot;normpath&quot;):</span>
<span class="gi">+            getattr(mock_os.path, name).side_effect = getattr(os.path, name)</span>
<span class="gi">+        # Return the sftp and OS mocks for use by decorator use case.</span>
<span class="gi">+        return sftp, mock_os</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self):</span>
<span class="gi">+        self.os_patcher.stop()</span>
<span class="gi">+        self.client_patcher.stop()</span>
<span class="gi">+        self.path_patcher.stop()</span>
<span class="gh">diff --git a/fabric/testing/fixtures.py b/fabric/testing/fixtures.py</span>
<span class="gh">index 15717185..29c1b243 100644</span>
<span class="gd">--- a/fabric/testing/fixtures.py</span>
<span class="gi">+++ b/fabric/testing/fixtures.py</span>
<span class="gu">@@ -14,18 +14,24 @@ For example, if you intend to use the `remote` and `client` fixtures::</span>

<span class="w"> </span>.. versionadded:: 2.1
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from unittest.mock import patch, Mock
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from pytest import fixture
<span class="w"> </span>except ImportError:
<span class="w"> </span>    import warnings
<span class="gi">+</span>
<span class="w"> </span>    warning = (
<span class="gd">-        &quot;You appear to be missing some optional test-related dependencies;please &#39;pip install fabric[pytest]&#39;.&quot;</span>
<span class="gd">-        )</span>
<span class="gi">+        &quot;You appear to be missing some optional test-related dependencies;&quot;</span>
<span class="gi">+        &quot;please &#39;pip install fabric[pytest]&#39;.&quot;</span>
<span class="gi">+    )</span>
<span class="w"> </span>    warnings.warn(warning, ImportWarning)
<span class="w"> </span>    raise
<span class="gi">+</span>
<span class="w"> </span>from .. import Connection
<span class="w"> </span>from ..transfer import Transfer
<span class="gi">+</span>
<span class="w"> </span>from .base import MockRemote, MockSFTP


<span class="gu">@@ -45,12 +51,24 @@ def connection():</span>

<span class="w"> </span>    .. versionadded:: 2.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    c = Connection(host=&quot;host&quot;, user=&quot;user&quot;)</span>
<span class="gi">+    c.config.run.in_stream = False</span>
<span class="gi">+    c.run = Mock()</span>
<span class="gi">+    c.local = Mock()</span>
<span class="gi">+    # TODO: rest of API should get mocked too</span>
<span class="gi">+    # TODO: is there a nice way to mesh with MockRemote et al? Is that ever</span>
<span class="gi">+    # really that useful for code that just wants to assert about how run() and</span>
<span class="gi">+    # friends were called?</span>
<span class="gi">+    yield c</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: A convenience rebinding of `connection`.</span>
<span class="gi">+#:</span>
<span class="gi">+#: .. versionadded:: 2.1</span>
<span class="w"> </span>cxn = connection


<span class="gi">+# TODO 4.0: remove old remote() and make this the new remote()</span>
<span class="w"> </span>@fixture
<span class="w"> </span>def remote_with_sftp():
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -60,7 +78,11 @@ def remote_with_sftp():</span>
<span class="w"> </span>    functionality was called), note that the returned `MockRemote` object has a
<span class="w"> </span>    ``.sftp`` attribute when created in this mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # NOTE: recall that by default an instantiated MockRemote has a single</span>
<span class="gi">+    # internal anonymous session; so these fixtures are useful for autouse</span>
<span class="gi">+    # guardrails.</span>
<span class="gi">+    with MockRemote(enable_sftp=True) as remote:</span>
<span class="gi">+        yield remote</span>


<span class="w"> </span>@fixture
<span class="gu">@@ -75,7 +97,10 @@ def remote():</span>

<span class="w"> </span>    .. versionadded:: 2.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    remote = MockRemote()</span>
<span class="gi">+    yield remote</span>
<span class="gi">+    remote.safety()</span>
<span class="gi">+    remote.stop()</span>


<span class="w"> </span>@fixture
<span class="gu">@@ -91,7 +116,12 @@ def sftp():</span>

<span class="w"> </span>    .. versionadded:: 2.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mock = MockSFTP(autostart=False)</span>
<span class="gi">+    client, mock_os = mock.start()</span>
<span class="gi">+    # Regular ol transfer to save some time</span>
<span class="gi">+    transfer = Transfer(Connection(&quot;host&quot;))</span>
<span class="gi">+    yield transfer, client, mock_os</span>
<span class="gi">+    # TODO: old mock_sftp() lacked any &#39;stop&#39;...why? feels bad man</span>


<span class="w"> </span>@fixture
<span class="gu">@@ -101,7 +131,7 @@ def sftp_objs(sftp):</span>

<span class="w"> </span>    .. versionadded:: 2.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yield sftp[:2]</span>


<span class="w"> </span>@fixture
<span class="gu">@@ -111,7 +141,7 @@ def transfer(sftp):</span>

<span class="w"> </span>    .. versionadded:: 2.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yield sftp[0]</span>


<span class="w"> </span>@fixture
<span class="gu">@@ -154,4 +184,7 @@ def client():</span>

<span class="w"> </span>    .. versionadded:: 2.1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with patch(&quot;fabric.connection.SSHClient&quot;) as SSHClient:</span>
<span class="gi">+        client = SSHClient.return_value</span>
<span class="gi">+        client.get_transport.return_value = Mock(active=True)</span>
<span class="gi">+        yield client</span>
<span class="gh">diff --git a/fabric/transfer.py b/fabric/transfer.py</span>
<span class="gh">index a241aa09..337513e9 100644</span>
<span class="gd">--- a/fabric/transfer.py</span>
<span class="gi">+++ b/fabric/transfer.py</span>
<span class="gu">@@ -1,11 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>File transfer via SFTP and/or SCP.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import posixpath
<span class="w"> </span>import stat
<span class="gi">+</span>
<span class="w"> </span>from pathlib import Path
<span class="gd">-from .util import debug</span>
<span class="gi">+</span>
<span class="gi">+from .util import debug  # TODO: actual logging! LOL</span>
<span class="gi">+</span>
<span class="gi">+# TODO: figure out best way to direct folks seeking rsync, to patchwork&#39;s rsync</span>
<span class="gi">+# call (which needs updating to use invoke.run() &amp; fab 2 connection methods,</span>
<span class="gi">+# but is otherwise suitable).</span>
<span class="gi">+# UNLESS we want to try and shoehorn it into this module after all? Delegate</span>
<span class="gi">+# any recursive get/put to it? Requires users to have rsync available of</span>
<span class="gi">+# course.</span>


<span class="w"> </span>class Transfer:
<span class="gu">@@ -15,9 +25,21 @@ class Transfer:</span>
<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    # TODO: SFTP clear default, but how to do SCP? subclass? init kwarg?</span>
<span class="gi">+</span>
<span class="w"> </span>    def __init__(self, connection):
<span class="w"> </span>        self.connection = connection

<span class="gi">+    @property</span>
<span class="gi">+    def sftp(self):</span>
<span class="gi">+        return self.connection.sftp()</span>
<span class="gi">+</span>
<span class="gi">+    def is_remote_dir(self, path):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return stat.S_ISDIR(self.sftp.stat(path).st_mode)</span>
<span class="gi">+        except IOError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="w"> </span>    def get(self, remote, local=None, preserve_mode=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Copy a file from wrapped connection&#39;s host to the local filesystem.
<span class="gu">@@ -87,7 +109,80 @@ class Transfer:</span>
<span class="w"> </span>        .. versionchanged:: 2.6
<span class="w"> </span>            Create missing ``local`` directories automatically.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO: how does this API change if we want to implement</span>
<span class="gi">+        # remote-to-remote file transfer? (Is that even realistic?)</span>
<span class="gi">+        # TODO: callback support</span>
<span class="gi">+        # TODO: how best to allow changing the behavior/semantics of</span>
<span class="gi">+        # remote/local (e.g. users might want &#39;safer&#39; behavior that complains</span>
<span class="gi">+        # instead of overwriting existing files) - this likely ties into the</span>
<span class="gi">+        # &quot;how to handle recursive/rsync&quot; and &quot;how to handle scp&quot; questions</span>
<span class="gi">+</span>
<span class="gi">+        # Massage remote path</span>
<span class="gi">+        if not remote:</span>
<span class="gi">+            raise ValueError(&quot;Remote path must not be empty!&quot;)</span>
<span class="gi">+        orig_remote = remote</span>
<span class="gi">+        remote = posixpath.join(</span>
<span class="gi">+            self.sftp.getcwd() or self.sftp.normalize(&quot;.&quot;), remote</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Massage local path</span>
<span class="gi">+        orig_local = local</span>
<span class="gi">+        is_file_like = hasattr(local, &quot;write&quot;) and callable(local.write)</span>
<span class="gi">+        remote_filename = posixpath.basename(remote)</span>
<span class="gi">+        if not local:</span>
<span class="gi">+            local = remote_filename</span>
<span class="gi">+        # Path-driven local downloads need interpolation, abspath&#39;ing &amp;</span>
<span class="gi">+        # directory creation</span>
<span class="gi">+        if not is_file_like:</span>
<span class="gi">+            local = local.format(</span>
<span class="gi">+                host=self.connection.host,</span>
<span class="gi">+                user=self.connection.user,</span>
<span class="gi">+                port=self.connection.port,</span>
<span class="gi">+                dirname=posixpath.dirname(remote),</span>
<span class="gi">+                basename=remote_filename,</span>
<span class="gi">+            )</span>
<span class="gi">+            # Must treat dir vs file paths differently, lest we erroneously</span>
<span class="gi">+            # mkdir what was intended as a filename, and so that non-empty</span>
<span class="gi">+            # dir-like paths still get remote filename tacked on.</span>
<span class="gi">+            if local.endswith(os.sep):</span>
<span class="gi">+                dir_path = local</span>
<span class="gi">+                local = os.path.join(local, remote_filename)</span>
<span class="gi">+            else:</span>
<span class="gi">+                dir_path, _ = os.path.split(local)</span>
<span class="gi">+            local = os.path.abspath(local)</span>
<span class="gi">+            Path(dir_path).mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+            # TODO: reimplement mkdir (or otherwise write a testing function)</span>
<span class="gi">+            # allowing us to track what was created so we can revert if</span>
<span class="gi">+            # transfer fails.</span>
<span class="gi">+            # TODO: Alternately, transfer to temp location and then move, but</span>
<span class="gi">+            # that&#39;s basically inverse of v1&#39;s sudo-put which gets messy</span>
<span class="gi">+</span>
<span class="gi">+        # Run Paramiko-level .get() (side-effects only. womp.)</span>
<span class="gi">+        # TODO: push some of the path handling into Paramiko; it should be</span>
<span class="gi">+        # responsible for dealing with path cleaning etc.</span>
<span class="gi">+        # TODO: probably preserve warning message from v1 when overwriting</span>
<span class="gi">+        # existing files. Use logging for that obviously.</span>
<span class="gi">+        #</span>
<span class="gi">+        # If local appears to be a file-like object, use sftp.getfo, not get</span>
<span class="gi">+        if is_file_like:</span>
<span class="gi">+            self.sftp.getfo(remotepath=remote, fl=local)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.sftp.get(remotepath=remote, localpath=local)</span>
<span class="gi">+            # Set mode to same as remote end</span>
<span class="gi">+            # TODO: Push this down into SFTPClient sometime (requires backwards</span>
<span class="gi">+            # incompat release.)</span>
<span class="gi">+            if preserve_mode:</span>
<span class="gi">+                remote_mode = self.sftp.stat(remote).st_mode</span>
<span class="gi">+                mode = stat.S_IMODE(remote_mode)</span>
<span class="gi">+                os.chmod(local, mode)</span>
<span class="gi">+        # Return something useful</span>
<span class="gi">+        return Result(</span>
<span class="gi">+            orig_remote=orig_remote,</span>
<span class="gi">+            remote=remote,</span>
<span class="gi">+            orig_local=orig_local,</span>
<span class="gi">+            local=local,</span>
<span class="gi">+            connection=self.connection,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def put(self, local, remote=None, preserve_mode=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -135,7 +230,97 @@ class Transfer:</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not local:</span>
<span class="gi">+            raise ValueError(&quot;Local path must not be empty!&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        is_file_like = hasattr(local, &quot;write&quot;) and callable(local.write)</span>
<span class="gi">+</span>
<span class="gi">+        # Massage remote path</span>
<span class="gi">+        orig_remote = remote</span>
<span class="gi">+        if is_file_like:</span>
<span class="gi">+            local_base = getattr(local, &quot;name&quot;, None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            local_base = os.path.basename(local)</span>
<span class="gi">+        if not remote:</span>
<span class="gi">+            if is_file_like:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;Must give non-empty remote path when local is a file-like object!&quot;  # noqa</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                remote = local_base</span>
<span class="gi">+                debug(&quot;Massaged empty remote path into {!r}&quot;.format(remote))</span>
<span class="gi">+        elif self.is_remote_dir(remote):</span>
<span class="gi">+            # non-empty local_base implies a) text file path or b) FLO which</span>
<span class="gi">+            # had a non-empty .name attribute. huzzah!</span>
<span class="gi">+            if local_base:</span>
<span class="gi">+                remote = posixpath.join(remote, local_base)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if is_file_like:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;Can&#39;t put a file-like-object into a directory unless it has a non-empty .name attribute!&quot;  # noqa</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # TODO: can we ever really end up here? implies we want to</span>
<span class="gi">+                    # reorganize all this logic so it has fewer potential holes</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;Somehow got an empty local file basename ({!r}) when uploading to a directory ({!r})!&quot;.format(  # noqa</span>
<span class="gi">+                            local_base, remote</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+        prejoined_remote = remote</span>
<span class="gi">+        remote = posixpath.join(</span>
<span class="gi">+            self.sftp.getcwd() or self.sftp.normalize(&quot;.&quot;), remote</span>
<span class="gi">+        )</span>
<span class="gi">+        if remote != prejoined_remote:</span>
<span class="gi">+            msg = &quot;Massaged relative remote path {!r} into {!r}&quot;</span>
<span class="gi">+            debug(msg.format(prejoined_remote, remote))</span>
<span class="gi">+</span>
<span class="gi">+        # Massage local path</span>
<span class="gi">+        orig_local = local</span>
<span class="gi">+        if not is_file_like:</span>
<span class="gi">+            local = os.path.abspath(local)</span>
<span class="gi">+            if local != orig_local:</span>
<span class="gi">+                debug(</span>
<span class="gi">+                    &quot;Massaged relative local path {!r} into {!r}&quot;.format(</span>
<span class="gi">+                        orig_local, local</span>
<span class="gi">+                    )</span>
<span class="gi">+                )  # noqa</span>
<span class="gi">+</span>
<span class="gi">+        # Run Paramiko-level .put() (side-effects only. womp.)</span>
<span class="gi">+        # TODO: push some of the path handling into Paramiko; it should be</span>
<span class="gi">+        # responsible for dealing with path cleaning etc.</span>
<span class="gi">+        # TODO: probably preserve warning message from v1 when overwriting</span>
<span class="gi">+        # existing files. Use logging for that obviously.</span>
<span class="gi">+        #</span>
<span class="gi">+        # If local appears to be a file-like object, use sftp.putfo, not put</span>
<span class="gi">+        if is_file_like:</span>
<span class="gi">+            msg = &quot;Uploading file-like object {!r} to {!r}&quot;</span>
<span class="gi">+            debug(msg.format(local, remote))</span>
<span class="gi">+            pointer = local.tell()</span>
<span class="gi">+            try:</span>
<span class="gi">+                local.seek(0)</span>
<span class="gi">+                self.sftp.putfo(fl=local, remotepath=remote)</span>
<span class="gi">+            finally:</span>
<span class="gi">+                local.seek(pointer)</span>
<span class="gi">+        else:</span>
<span class="gi">+            debug(&quot;Uploading {!r} to {!r}&quot;.format(local, remote))</span>
<span class="gi">+            self.sftp.put(localpath=local, remotepath=remote)</span>
<span class="gi">+            # Set mode to same as local end</span>
<span class="gi">+            # TODO: Push this down into SFTPClient sometime (requires backwards</span>
<span class="gi">+            # incompat release.)</span>
<span class="gi">+            if preserve_mode:</span>
<span class="gi">+                local_mode = os.stat(local).st_mode</span>
<span class="gi">+                mode = stat.S_IMODE(local_mode)</span>
<span class="gi">+                self.sftp.chmod(remote, mode)</span>
<span class="gi">+        # Return something useful</span>
<span class="gi">+        return Result(</span>
<span class="gi">+            orig_remote=orig_remote,</span>
<span class="gi">+            remote=remote,</span>
<span class="gi">+            orig_local=orig_local,</span>
<span class="gi">+            local=local,</span>
<span class="gi">+            connection=self.connection,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class Result:
<span class="gu">@@ -154,9 +339,26 @@ class Result:</span>
<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    # TODO: how does this differ from put vs get? field stating which? (feels</span>
<span class="gi">+    # meh) distinct classes differing, for now, solely by name? (also meh)</span>
<span class="w"> </span>    def __init__(self, local, orig_local, remote, orig_remote, connection):
<span class="gi">+        #: The local path the file was saved as, or the object it was saved</span>
<span class="gi">+        #: into if a file-like object was given instead.</span>
<span class="gi">+        #:</span>
<span class="gi">+        #: If a string path, this value is massaged to be absolute; see</span>
<span class="gi">+        #: `.orig_local` for the original argument value.</span>
<span class="w"> </span>        self.local = local
<span class="gi">+        #: The original value given as the returning method&#39;s ``local``</span>
<span class="gi">+        #: argument.</span>
<span class="w"> </span>        self.orig_local = orig_local
<span class="gi">+        #: The remote path downloaded from. Massaged to be absolute; see</span>
<span class="gi">+        #: `.orig_remote` for the original argument value.</span>
<span class="w"> </span>        self.remote = remote
<span class="gi">+        #: The original argument value given as the returning method&#39;s</span>
<span class="gi">+        #: ``remote`` argument.</span>
<span class="w"> </span>        self.orig_remote = orig_remote
<span class="gi">+        #: The `.Connection` object this result was obtained from.</span>
<span class="w"> </span>        self.connection = connection
<span class="gi">+</span>
<span class="gi">+    # TODO: ensure str/repr makes it easily differentiable from run() or</span>
<span class="gi">+    # local() result objects (and vice versa).</span>
<span class="gh">diff --git a/fabric/tunnels.py b/fabric/tunnels.py</span>
<span class="gh">index c0a117ba..bec69b51 100644</span>
<span class="gd">--- a/fabric/tunnels.py</span>
<span class="gi">+++ b/fabric/tunnels.py</span>
<span class="gu">@@ -4,10 +4,12 @@ Tunnel and connection forwarding internals.</span>
<span class="w"> </span>If you&#39;re looking for simple, end-user-focused connection forwarding, please
<span class="w"> </span>see `.Connection`, e.g. `.Connection.forward_local`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import select
<span class="w"> </span>import socket
<span class="w"> </span>import time
<span class="w"> </span>from threading import Event
<span class="gi">+</span>
<span class="w"> </span>from invoke.exceptions import ThreadException
<span class="w"> </span>from invoke.util import ExceptionHandlingThread

<span class="gu">@@ -27,14 +29,82 @@ class TunnelManager(ExceptionHandlingThread):</span>
<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, local_host, local_port, remote_host, remote_port,</span>
<span class="gd">-        transport, finished):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        local_host,</span>
<span class="gi">+        local_port,</span>
<span class="gi">+        remote_host,</span>
<span class="gi">+        remote_port,</span>
<span class="gi">+        transport,</span>
<span class="gi">+        finished,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__()
<span class="gd">-        self.local_address = local_host, local_port</span>
<span class="gd">-        self.remote_address = remote_host, remote_port</span>
<span class="gi">+        self.local_address = (local_host, local_port)</span>
<span class="gi">+        self.remote_address = (remote_host, remote_port)</span>
<span class="w"> </span>        self.transport = transport
<span class="w"> </span>        self.finished = finished

<span class="gi">+    def _run(self):</span>
<span class="gi">+        # Track each tunnel that gets opened during our lifetime</span>
<span class="gi">+        tunnels = []</span>
<span class="gi">+</span>
<span class="gi">+        # Set up OS-level listener socket on forwarded port</span>
<span class="gi">+        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span>
<span class="gi">+        # TODO: why do we want REUSEADDR exactly? and is it portable?</span>
<span class="gi">+        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span>
<span class="gi">+        # NOTE: choosing to deal with nonblocking semantics and a fast loop,</span>
<span class="gi">+        # versus an older approach which blocks &amp; expects outer scope to cause</span>
<span class="gi">+        # a socket exception by close()ing the socket.</span>
<span class="gi">+        sock.setblocking(0)</span>
<span class="gi">+        sock.bind(self.local_address)</span>
<span class="gi">+        sock.listen(1)</span>
<span class="gi">+</span>
<span class="gi">+        while not self.finished.is_set():</span>
<span class="gi">+            # Main loop-wait: accept connections on the local listener</span>
<span class="gi">+            # NOTE: EAGAIN means &quot;you&#39;re nonblocking and nobody happened to</span>
<span class="gi">+            # connect at this point in time&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                tun_sock, local_addr = sock.accept()</span>
<span class="gi">+                # Set TCP_NODELAY to match OpenSSH&#39;s forwarding socket behavior</span>
<span class="gi">+                tun_sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)</span>
<span class="gi">+            except BlockingIOError:  # ie errno.EAGAIN</span>
<span class="gi">+                # TODO: make configurable</span>
<span class="gi">+                time.sleep(0.01)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Set up direct-tcpip channel on server end</span>
<span class="gi">+            # TODO: refactor w/ what&#39;s used for gateways</span>
<span class="gi">+            channel = self.transport.open_channel(</span>
<span class="gi">+                &quot;direct-tcpip&quot;, self.remote_address, local_addr</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Set up &#39;worker&#39; thread for this specific connection to our</span>
<span class="gi">+            # tunnel, plus its dedicated signal event (which will appear as a</span>
<span class="gi">+            # public attr, no need to track both independently).</span>
<span class="gi">+            finished = Event()</span>
<span class="gi">+            tunnel = Tunnel(channel=channel, sock=tun_sock, finished=finished)</span>
<span class="gi">+            tunnel.start()</span>
<span class="gi">+            tunnels.append(tunnel)</span>
<span class="gi">+</span>
<span class="gi">+        exceptions = []</span>
<span class="gi">+        # Propogate shutdown signal to all tunnels &amp; wait for closure</span>
<span class="gi">+        # TODO: would be nice to have some output or at least logging here,</span>
<span class="gi">+        # especially for &quot;sets up a handful of tunnels&quot; use cases like</span>
<span class="gi">+        # forwarding nontrivial HTTP traffic.</span>
<span class="gi">+        for tunnel in tunnels:</span>
<span class="gi">+            tunnel.finished.set()</span>
<span class="gi">+            tunnel.join()</span>
<span class="gi">+            wrapper = tunnel.exception()</span>
<span class="gi">+            if wrapper:</span>
<span class="gi">+                exceptions.append(wrapper)</span>
<span class="gi">+        # Handle exceptions</span>
<span class="gi">+        if exceptions:</span>
<span class="gi">+            raise ThreadException(exceptions)</span>
<span class="gi">+</span>
<span class="gi">+        # All we have left to close is our own sock.</span>
<span class="gi">+        # TODO: use try/finally?</span>
<span class="gi">+        sock.close()</span>
<span class="gi">+</span>

<span class="w"> </span>class Tunnel(ExceptionHandlingThread):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -51,6 +121,25 @@ class Tunnel(ExceptionHandlingThread):</span>
<span class="w"> </span>        self.channel_chunk_size = 1024
<span class="w"> </span>        super().__init__()

<span class="gi">+    def _run(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            empty_sock, empty_chan = None, None</span>
<span class="gi">+            while not self.finished.is_set():</span>
<span class="gi">+                r, w, x = select.select([self.sock, self.channel], [], [], 1)</span>
<span class="gi">+                if self.sock in r:</span>
<span class="gi">+                    empty_sock = self.read_and_write(</span>
<span class="gi">+                        self.sock, self.channel, self.socket_chunk_size</span>
<span class="gi">+                    )</span>
<span class="gi">+                if self.channel in r:</span>
<span class="gi">+                    empty_chan = self.read_and_write(</span>
<span class="gi">+                        self.channel, self.sock, self.channel_chunk_size</span>
<span class="gi">+                    )</span>
<span class="gi">+                if empty_sock or empty_chan:</span>
<span class="gi">+                    break</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.channel.close()</span>
<span class="gi">+            self.sock.close()</span>
<span class="gi">+</span>
<span class="w"> </span>    def read_and_write(self, reader, writer, chunk_size):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Read ``chunk_size`` from ``reader``, writing result to ``writer``.
<span class="gu">@@ -59,4 +148,7 @@ class Tunnel(ExceptionHandlingThread):</span>

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = reader.recv(chunk_size)</span>
<span class="gi">+        if len(data) == 0:</span>
<span class="gi">+            return True</span>
<span class="gi">+        writer.sendall(data)</span>
<span class="gh">diff --git a/fabric/util.py b/fabric/util.py</span>
<span class="gh">index f39ab255..c47c422b 100644</span>
<span class="gd">--- a/fabric/util.py</span>
<span class="gi">+++ b/fabric/util.py</span>
<span class="gu">@@ -1,9 +1,16 @@</span>
<span class="w"> </span>import logging
<span class="w"> </span>import sys
<span class="gd">-log = logging.getLogger(&#39;fabric&#39;)</span>
<span class="gd">-for x in (&#39;debug&#39;,):</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Ape the half-assed logging junk from Invoke, but ensuring the logger reflects</span>
<span class="gi">+# our name, not theirs. (Assume most contexts will rely on Invoke itself to</span>
<span class="gi">+# literally enable/disable logging, for now.)</span>
<span class="gi">+log = logging.getLogger(&quot;fabric&quot;)</span>
<span class="gi">+for x in (&quot;debug&quot;,):</span>
<span class="w"> </span>    globals()[x] = getattr(log, x)
<span class="gd">-win32 = sys.platform == &#39;win32&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+win32 = sys.platform == &quot;win32&quot;</span>


<span class="w"> </span>def get_local_user():
<span class="gu">@@ -12,4 +19,27 @@ def get_local_user():</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO: I don&#39;t understand why these lines were added outside the</span>
<span class="gi">+    # try/except, since presumably it means the attempt at catching ImportError</span>
<span class="gi">+    # wouldn&#39;t work. However, that&#39;s how the contributing user committed it.</span>
<span class="gi">+    # Need an older Windows box to test it out, most likely.</span>
<span class="gi">+    import getpass</span>
<span class="gi">+</span>
<span class="gi">+    username = None</span>
<span class="gi">+    # All Unix and most Windows systems support the getpass module.</span>
<span class="gi">+    try:</span>
<span class="gi">+        username = getpass.getuser()</span>
<span class="gi">+    # Some SaaS platforms raise KeyError, implying there is no real user</span>
<span class="gi">+    # involved. They get the default value of None.</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    # Older (?) Windows systems don&#39;t support getpass well; they should</span>
<span class="gi">+    # have the `win32` module instead.</span>
<span class="gi">+    except ImportError:  # pragma: nocover</span>
<span class="gi">+        if win32:</span>
<span class="gi">+            import win32api</span>
<span class="gi">+            import win32security  # noqa</span>
<span class="gi">+            import win32profile  # noqa</span>
<span class="gi">+</span>
<span class="gi">+            username = win32api.GetUserName()</span>
<span class="gi">+    return username</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>