
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin pylint - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-pylint" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin pylint
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-pylint"><strong>Claude Sonnet 3.5 - Fill-in</strong>: pylint</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:15: in &lt;module&gt;
    from pylint import checkers
pylint/checkers/__init__.py:47: in &lt;module&gt;
    from pylint.checkers.base_checker import (
pylint/checkers/base_checker.py:9: in &lt;module&gt;
    from pylint.config.arguments_provider import _ArgumentsProvider
pylint/config/arguments_provider.py:5: in &lt;module&gt;
    from pylint.config.arguments_manager import _ArgumentsManager
pylint/config/arguments_manager.py:11: in &lt;module&gt;
    from pylint import utils
pylint/utils/__init__.py:13: in &lt;module&gt;
    from pylint.utils.utils import (
E   ImportError: cannot import name &#39;_check_csv&#39; from &#39;pylint.utils.utils&#39; (/testbed/pylint/utils/utils.py)
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/doc/requirements.txt b/doc/requirements.txt</span>
<span class="gh">index f4373c3de..a61c04145 100644</span>
<span class="gd">--- a/doc/requirements.txt</span>
<span class="gi">+++ b/doc/requirements.txt</span>
<span class="gu">@@ -2,4 +2,5 @@ Sphinx==7.3.7</span>
<span class="w"> </span>sphinx-reredirects&lt;1
<span class="w"> </span>towncrier~=23.11
<span class="w"> </span>furo==2024.5.6
<span class="gi">+psutil==5.9.5</span>
<span class="w"> </span>-e .
<span class="gh">diff --git a/pylint/__pkginfo__.py b/pylint/__pkginfo__.py</span>
<span class="gh">index 74986243c..2aa1e84f7 100644</span>
<span class="gd">--- a/pylint/__pkginfo__.py</span>
<span class="gi">+++ b/pylint/__pkginfo__.py</span>
<span class="gu">@@ -12,7 +12,7 @@ def get_numversion_from_version(v: str) -&gt;tuple[int, int, int]:</span>
<span class="w"> </span>    See https://github.com/pylint-dev/pylint/issues/4399
<span class="w"> </span>    https://github.com/pylint-dev/pylint/issues/4420,
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return tuple(map(int, v.split(&#39;.&#39;)))</span>


<span class="w"> </span>numversion = get_numversion_from_version(__version__)
<span class="gh">diff --git a/pylint/checkers/base/basic_checker.py b/pylint/checkers/base/basic_checker.py</span>
<span class="gh">index 2c39eeb46..2fe8a4704 100644</span>
<span class="gd">--- a/pylint/checkers/base/basic_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/basic_checker.py</span>
<span class="gu">@@ -131,25 +131,36 @@ class BasicChecker(_BasicChecker):</span>

<span class="w"> </span>    def open(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Initialize visit variables and statistics.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._try_finally_nodes = []</span>
<span class="gi">+        self._init_branch_stack()</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _name_holds_generator(test: nodes.Name) -&gt;tuple[bool, nodes.Call | None</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def _name_holds_generator(test: nodes.Name) -&gt;tuple[bool, nodes.Call | None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return whether `test` tests a name certain to hold a generator, or optionally
<span class="w"> </span>        a call that should be then tested to see if *it* returns only generators.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_module(self, _: nodes.Module) -&gt;None:</span>
<span class="gi">+        if isinstance(test, nodes.Name):</span>
<span class="gi">+            if test.name in (&#39;iter&#39;, &#39;generator&#39;):</span>
<span class="gi">+                return True, None</span>
<span class="gi">+            inferred = utils.safe_infer(test)</span>
<span class="gi">+            if isinstance(inferred, astroid.FunctionDef) and inferred.is_generator():</span>
<span class="gi">+                return True, None</span>
<span class="gi">+        elif isinstance(test, nodes.Call):</span>
<span class="gi">+            return False, test</span>
<span class="gi">+        return False, None</span>
<span class="gi">+</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt;None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check module name, docstring and required arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_docstring(node)</span>
<span class="gi">+        self._check_required_attributes(node)</span>

<span class="gd">-    def visit_classdef(self, _: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check module name, docstring and redefinition
<span class="w"> </span>        increment branch counter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_docstring(node)</span>
<span class="gi">+        self._check_redefinition(node)</span>
<span class="gi">+        self._init_branch_stack()</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;pointless-statement&#39;,
<span class="w"> </span>        &#39;pointless-exception-statement&#39;, &#39;pointless-string-statement&#39;,
<span class="gu">@@ -173,90 +184,119 @@ class BasicChecker(_BasicChecker):</span>

<span class="w"> </span>    def _check_dangerous_default(self, node: nodes.FunctionDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check for dangerous default values as arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for default in node.args.defaults:</span>
<span class="gi">+            if isinstance(default, (nodes.List, nodes.Dict, nodes.Set)):</span>
<span class="gi">+                self.add_message(&#39;dangerous-default-value&#39;, node=default, args=(default.as_string(),))</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;unreachable&#39;, &#39;lost-exception&#39;)
<span class="w"> </span>    def visit_return(self, node: nodes.Return) -&gt;None:
<span class="gd">-        &quot;&quot;&quot;Return node visitor.</span>
<span class="gd">-</span>
<span class="gd">-        1 - check if the node has a right sibling (if so, that&#39;s some</span>
<span class="gd">-        unreachable code)</span>
<span class="gd">-        2 - check if the node is inside the &#39;finally&#39; clause of a &#39;try...finally&#39;</span>
<span class="gd">-        block</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Return node visitor.&quot;&quot;&quot;</span>
<span class="gi">+        self._check_unreachable(node)</span>
<span class="gi">+        self._check_not_in_finally(node, &#39;return&#39;)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;unreachable&#39;)
<span class="w"> </span>    def visit_continue(self, node: nodes.Continue) -&gt;None:
<span class="gd">-        &quot;&quot;&quot;Check is the node has a right sibling (if so, that&#39;s some unreachable</span>
<span class="gd">-        code).</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Check if the node has a right sibling (if so, that&#39;s some unreachable code).&quot;&quot;&quot;</span>
<span class="gi">+        self._check_unreachable(node)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;unreachable&#39;, &#39;lost-exception&#39;)
<span class="w"> </span>    def visit_break(self, node: nodes.Break) -&gt;None:
<span class="gd">-        &quot;&quot;&quot;Break node visitor.</span>
<span class="gd">-</span>
<span class="gd">-        1 - check if the node has a right sibling (if so, that&#39;s some</span>
<span class="gd">-        unreachable code)</span>
<span class="gd">-        2 - check if the node is inside the &#39;finally&#39; clause of a &#39;try...finally&#39;</span>
<span class="gd">-        block</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Break node visitor.&quot;&quot;&quot;</span>
<span class="gi">+        self._check_unreachable(node)</span>
<span class="gi">+        self._check_not_in_finally(node, &#39;break&#39;)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;unreachable&#39;)
<span class="w"> </span>    def visit_raise(self, node: nodes.Raise) -&gt;None:
<span class="gd">-        &quot;&quot;&quot;Check if the node has a right sibling (if so, that&#39;s some unreachable</span>
<span class="gd">-        code).</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Check if the node has a right sibling (if so, that&#39;s some unreachable code).&quot;&quot;&quot;</span>
<span class="gi">+        self._check_unreachable(node)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;eval-used&#39;, &#39;exec-used&#39;,
<span class="w"> </span>        &#39;bad-reversed-sequence&#39;, &#39;misplaced-format-function&#39;, &#39;unreachable&#39;)
<span class="w"> </span>    def visit_call(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit a Call node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Name):</span>
<span class="gi">+            if node.func.name == &#39;eval&#39;:</span>
<span class="gi">+                self.add_message(&#39;eval-used&#39;, node=node)</span>
<span class="gi">+            elif node.func.name == &#39;exec&#39;:</span>
<span class="gi">+                self.add_message(&#39;exec-used&#39;, node=node)</span>
<span class="gi">+            elif node.func.name == &#39;reversed&#39;:</span>
<span class="gi">+                self._check_reversed(node)</span>
<span class="gi">+        self._check_unreachable(node)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;assert-on-tuple&#39;,
<span class="w"> </span>        &#39;assert-on-string-literal&#39;)
<span class="w"> </span>    def visit_assert(self, node: nodes.Assert) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check whether assert is used on a tuple or string literal.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.test, nodes.Tuple) and node.test.elts:</span>
<span class="gi">+            self.add_message(&#39;assert-on-tuple&#39;, node=node)</span>
<span class="gi">+        elif isinstance(node.test, nodes.Const) and isinstance(node.test.value, str):</span>
<span class="gi">+            self.add_message(&#39;assert-on-string-literal&#39;, node=node, args=(&#39;always&#39; if node.test.value else &#39;never&#39;,))</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;duplicate-key&#39;)
<span class="w"> </span>    def visit_dict(self, node: nodes.Dict) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check duplicate key in dictionary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        keys = set()</span>
<span class="gi">+        for key, _ in node.items:</span>
<span class="gi">+            if isinstance(key, nodes.Const):</span>
<span class="gi">+                if key.value in keys:</span>
<span class="gi">+                    self.add_message(&#39;duplicate-key&#39;, node=key, args=(key.value,))</span>
<span class="gi">+                keys.add(key.value)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;duplicate-value&#39;)
<span class="w"> </span>    def visit_set(self, node: nodes.Set) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check duplicate value in set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        values = set()</span>
<span class="gi">+        for elt in node.elts:</span>
<span class="gi">+            if isinstance(elt, nodes.Const):</span>
<span class="gi">+                if elt.value in values:</span>
<span class="gi">+                    self.add_message(&#39;duplicate-value&#39;, node=elt, args=(elt.value,))</span>
<span class="gi">+                values.add(elt.value)</span>

<span class="w"> </span>    def visit_try(self, node: nodes.Try) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Update try block flag.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._trys.append(node)</span>

<span class="w"> </span>    def leave_try(self, _: nodes.Try) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Update try block flag.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._trys.pop()</span>

<span class="w"> </span>    def _check_unreachable(self, node: (nodes.Return | nodes.Continue |
<span class="w"> </span>        nodes.Break | nodes.Raise | nodes.Call), confidence: Confidence=HIGH
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check unreachable code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.parent, nodes.If):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node.parent, (nodes.ExceptHandler, nodes.TryExcept)):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node.parent, nodes.Try) and node.parent.finalbody:</span>
<span class="gi">+            return</span>
<span class="gi">+        siblings = list(node.parent.get_children())</span>
<span class="gi">+        index = siblings.index(node)</span>
<span class="gi">+        if index &lt; len(siblings) - 1:</span>
<span class="gi">+            self.add_message(&#39;unreachable&#39;, node=siblings[index + 1], confidence=confidence)</span>

<span class="w"> </span>    def _check_not_in_finally(self, node: (nodes.Break | nodes.Return),
<span class="w"> </span>        node_name: str, breaker_classes: tuple[nodes.NodeNG, ...]=()) -&gt;None:
<span class="gd">-        &quot;&quot;&quot;Check that a node is not inside a &#39;finally&#39; clause of a</span>
<span class="gd">-        &#39;try...finally&#39; statement.</span>
<span class="gd">-</span>
<span class="gd">-        If we find a parent which type is in breaker_classes before</span>
<span class="gd">-        a &#39;try...finally&#39; block we skip the whole check.</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Check that a node is not inside a &#39;finally&#39; clause of a &#39;try...finally&#39; statement.&quot;&quot;&quot;</span>
<span class="gi">+        current = node</span>
<span class="gi">+        while current and not isinstance(current, breaker_classes):</span>
<span class="gi">+            if isinstance(current, nodes.TryFinally):</span>
<span class="gi">+                if current.finalbody and node in current.finalbody:</span>
<span class="gi">+                    self.add_message(&#39;lost-exception&#39;, node=node, args=(node_name,))</span>
<span class="gi">+                    return</span>
<span class="gi">+            current = current.parent</span>

<span class="w"> </span>    def _check_reversed(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check that the argument to `reversed` is a sequence.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(node.args) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+        arg = utils.safe_infer(node.args[0])</span>
<span class="gi">+        if arg:</span>
<span class="gi">+            if isinstance(arg, astroid.Instance):</span>
<span class="gi">+                if arg.getattr(&#39;__reversed__&#39;):</span>
<span class="gi">+                    return</span>
<span class="gi">+                if arg.getattr(&#39;__getitem__&#39;) and arg.getattr(&#39;__len__&#39;):</span>
<span class="gi">+                    return</span>
<span class="gi">+            elif isinstance(arg, nodes.List):</span>
<span class="gi">+                return</span>
<span class="gi">+        self.add_message(&#39;bad-reversed-sequence&#39;, node=node)</span>
<span class="gh">diff --git a/pylint/checkers/base/basic_error_checker.py b/pylint/checkers/base/basic_error_checker.py</span>
<span class="gh">index 14c962bfb..90c4b6f2f 100644</span>
<span class="gd">--- a/pylint/checkers/base/basic_error_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/basic_error_checker.py</span>
<span class="gu">@@ -25,7 +25,10 @@ def _get_break_loop_node(break_node: nodes.Break) -&gt;(nodes.For | nodes.</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        astroid.For or astroid.While: the loop node holding the break node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent = break_node.parent</span>
<span class="gi">+    while parent and not isinstance(parent, (nodes.For, nodes.While)):</span>
<span class="gi">+        parent = parent.parent</span>
<span class="gi">+    return parent</span>


<span class="w"> </span>def _loop_exits_early(loop: (nodes.For | nodes.While)) -&gt;bool:
<span class="gu">@@ -37,7 +40,24 @@ def _loop_exits_early(loop: (nodes.For | nodes.While)) -&gt;bool:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        bool: True if the loop may end with a break statement, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for child in loop.get_children():</span>
<span class="gi">+        if isinstance(child, nodes.Break):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(child, (nodes.For, nodes.While)):</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(child, nodes.If) and _if_statement_exits_early(child):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+def _if_statement_exits_early(if_node: nodes.If) -&gt;bool:</span>
<span class="gi">+    &quot;&quot;&quot;Helper function to check if an if statement contains a break.&quot;&quot;&quot;</span>
<span class="gi">+    for child in if_node.get_children():</span>
<span class="gi">+        if isinstance(child, nodes.Break):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(child, nodes.If):</span>
<span class="gi">+            if _if_statement_exits_early(child):</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _has_abstract_methods(node: nodes.ClassDef) -&gt;bool:
<span class="gu">@@ -46,7 +66,16 @@ def _has_abstract_methods(node: nodes.ClassDef) -&gt;bool:</span>
<span class="w"> </span>    The methods should be made abstract by decorating them
<span class="w"> </span>    with `abc` decorators.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for method in node.mymethods():</span>
<span class="gi">+        if method.decorators:</span>
<span class="gi">+            for decorator in method.decorators.nodes:</span>
<span class="gi">+                if isinstance(decorator, nodes.Name):</span>
<span class="gi">+                    if decorator.name in (&#39;abstractmethod&#39;, &#39;abstractproperty&#39;):</span>
<span class="gi">+                        return True</span>
<span class="gi">+                elif isinstance(decorator, nodes.Attribute):</span>
<span class="gi">+                    if decorator.attrname in (&#39;abstractmethod&#39;, &#39;abstractproperty&#39;):</span>
<span class="gi">+                        return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def redefined_by_decorator(node: nodes.FunctionDef) -&gt;bool:
<span class="gu">@@ -58,7 +87,13 @@ def redefined_by_decorator(node: nodes.FunctionDef) -&gt;bool:</span>
<span class="w"> </span>        @x.setter
<span class="w"> </span>        def x(self, value): self._x = value
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not node.decorators:</span>
<span class="gi">+        return False</span>
<span class="gi">+    for decorator in node.decorators.nodes:</span>
<span class="gi">+        if (isinstance(decorator, nodes.Attribute) and</span>
<span class="gi">+            decorator.attrname in (&#39;setter&#39;, &#39;deleter&#39;)):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class BasicErrorChecker(_BasicChecker):
<span class="gu">@@ -116,24 +151,50 @@ class BasicErrorChecker(_BasicChecker):</span>
<span class="w"> </span>    @utils.only_required_for_messages(&#39;star-needs-assignment-target&#39;)
<span class="w"> </span>    def visit_starred(self, node: nodes.Starred) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check that a Starred expression is used in an assignment target.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.parent, (nodes.Assign, nodes.AnnAssign)):</span>
<span class="gi">+            self.add_message(&#39;star-needs-assignment-target&#39;, node=node)</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="w"> </span>    def _check_nonlocal_and_global(self, node: nodes.FunctionDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check that a name is both nonlocal and global.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        nonlocal_names = set()</span>
<span class="gi">+        global_names = set()</span>
<span class="gi">+</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            if isinstance(child, nodes.Global):</span>
<span class="gi">+                global_names.update(child.names)</span>
<span class="gi">+            elif isinstance(child, nodes.Nonlocal):</span>
<span class="gi">+                nonlocal_names.update(child.names)</span>
<span class="gi">+</span>
<span class="gi">+        for name in nonlocal_names.intersection(global_names):</span>
<span class="gi">+            self.add_message(&#39;nonlocal-and-global&#39;, args=name, node=node)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;nonexistent-operator&#39;)
<span class="w"> </span>    def visit_unaryop(self, node: nodes.UnaryOp) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check use of the non-existent ++ and -- operators.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.op in (&#39;++&#39;, &#39;--&#39;):</span>
<span class="gi">+            self.add_message(&#39;nonexistent-operator&#39;, args=node.op, node=node)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;abstract-class-instantiated&#39;)
<span class="w"> </span>    def visit_call(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check instantiating abstract class with
<span class="w"> </span>        abc.ABCMeta as metaclass.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Name):</span>
<span class="gi">+            inferred = utils.safe_infer(node.func)</span>
<span class="gi">+            if (isinstance(inferred, nodes.ClassDef) and</span>
<span class="gi">+                _has_abstract_methods(inferred) and</span>
<span class="gi">+                _is_abc_metaclass(inferred)):</span>
<span class="gi">+                self.add_message(&#39;abstract-class-instantiated&#39;,</span>
<span class="gi">+                                 args=inferred.name, node=node)</span>
<span class="gi">+</span>
<span class="gi">+def _is_abc_metaclass(node: nodes.ClassDef) -&gt;bool:</span>
<span class="gi">+    &quot;&quot;&quot;Check if the class uses ABC as a metaclass.&quot;&quot;&quot;</span>
<span class="gi">+    metaclass = node.metaclass()</span>
<span class="gi">+    if metaclass:</span>
<span class="gi">+        return (utils.is_node_in_typing_guarded_import_block(metaclass) and</span>
<span class="gi">+                metaclass.qname() in ABC_METACLASSES)</span>
<span class="gi">+    return False</span>

<span class="w"> </span>    def _check_else_on_loop(self, node: (nodes.For | nodes.While)) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check that any loop with an else clause has a break statement.&quot;&quot;&quot;
<span class="gh">diff --git a/pylint/checkers/base/comparison_checker.py b/pylint/checkers/base/comparison_checker.py</span>
<span class="gh">index 5eefa2387..d354d8ffc 100644</span>
<span class="gd">--- a/pylint/checkers/base/comparison_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/comparison_checker.py</span>
<span class="gu">@@ -12,7 +12,11 @@ TYPE_QNAME = &#39;builtins.type&#39;</span>

<span class="w"> </span>def _is_one_arg_pos_call(call: nodes.NodeNG) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Is this a call with exactly 1 positional argument ?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(call, nodes.Call)</span>
<span class="gi">+        and len(call.args) == 1</span>
<span class="gi">+        and not call.keywords</span>
<span class="gi">+    )</span>


<span class="w"> </span>class ComparisonChecker(_BasicChecker):
<span class="gu">@@ -50,12 +54,41 @@ class ComparisonChecker(_BasicChecker):</span>
<span class="w"> </span>        right_value: nodes.NodeNG, root_node: nodes.Compare,
<span class="w"> </span>        checking_for_absence: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if == or != is being used to compare a singleton value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        singleton_values = (True, False, None)</span>
<span class="gi">+        for value in (left_value, right_value):</span>
<span class="gi">+            if isinstance(value, nodes.Const) and value.value in singleton_values:</span>
<span class="gi">+                singleton = value.value</span>
<span class="gi">+                if checking_for_absence:</span>
<span class="gi">+                    suggestion = &quot;is not&quot; if singleton is not None else &quot;is&quot;</span>
<span class="gi">+                    bad_op = &quot;!=&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    suggestion = &quot;is&quot;</span>
<span class="gi">+                    bad_op = &quot;==&quot;</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &#39;singleton-comparison&#39;,</span>
<span class="gi">+                    node=root_node,</span>
<span class="gi">+                    args=(bad_op, suggestion),</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>

<span class="w"> </span>    def _check_literal_comparison(self, literal: nodes.NodeNG, node: nodes.
<span class="w"> </span>        Compare) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if we compare to a literal, which is usually what we do not want to do.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(literal, LITERAL_NODE_TYPES):</span>
<span class="gi">+            operator = node.ops[0][0]</span>
<span class="gi">+            left = node.left</span>
<span class="gi">+            right = node.ops[0][1]</span>
<span class="gi">+</span>
<span class="gi">+            if operator in COMPARISON_OPERATORS:</span>
<span class="gi">+                if isinstance(left, LITERAL_NODE_TYPES) and not isinstance(right, LITERAL_NODE_TYPES):</span>
<span class="gi">+                    suggested = f&quot;{right.as_string()} {operator} {left.as_string()}&quot;</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &#39;literal-comparison&#39;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=(node.as_string(), suggested, operator, left.as_string()),</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>

<span class="w"> </span>    def _check_logical_tautology(self, node: nodes.Compare) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if identifier is compared against itself.
<span class="gu">@@ -66,13 +99,42 @@ class ComparisonChecker(_BasicChecker):</span>
<span class="w"> </span>        if val == val:  # [comparison-with-itself]
<span class="w"> </span>            pass
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        left = node.left</span>
<span class="gi">+        for operator, right in node.ops:</span>
<span class="gi">+            if isinstance(left, nodes.Name) and isinstance(right, nodes.Name):</span>
<span class="gi">+                if left.name == right.name:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &#39;comparison-with-itself&#39;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=node.as_string(),</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>
<span class="gi">+            left = right</span>

<span class="w"> </span>    def _check_constants_comparison(self, node: nodes.Compare) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;When two constants are being compared it is always a logical tautology.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        left = node.left</span>
<span class="gi">+        for operator, right in node.ops:</span>
<span class="gi">+            if (isinstance(left, nodes.Const) and isinstance(right, nodes.Const) and</span>
<span class="gi">+                    left.value.__class__ == right.value.__class__):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &#39;comparison-of-constants&#39;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(left.value, operator, right.value),</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+            left = right</span>

<span class="w"> </span>    def _check_type_x_is_y(self, node: nodes.Compare, left: nodes.NodeNG,
<span class="w"> </span>        operator: str, right: nodes.NodeNG) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check for expressions like type(x) == Y.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (isinstance(left, nodes.Call) and</span>
<span class="gi">+                isinstance(left.func, nodes.Name) and</span>
<span class="gi">+                left.func.name == &#39;type&#39; and</span>
<span class="gi">+                operator in TYPECHECK_COMPARISON_OPERATORS):</span>
<span class="gi">+            if _is_one_arg_pos_call(left):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &#39;unidiomatic-typecheck&#39;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gh">diff --git a/pylint/checkers/base/docstring_checker.py b/pylint/checkers/base/docstring_checker.py</span>
<span class="gh">index c691ef0c0..9368c66f1 100644</span>
<span class="gd">--- a/pylint/checkers/base/docstring_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/docstring_checker.py</span>
<span class="gu">@@ -39,4 +39,35 @@ class DocStringChecker(_BasicChecker):</span>
<span class="w"> </span>        FunctionDef), report_missing: bool=True, confidence: interfaces.
<span class="w"> </span>        Confidence=interfaces.HIGH) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if the node has a non-empty docstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        docstring = node.doc_node.value if node.doc_node else None</span>
<span class="gi">+        if docstring is None:</span>
<span class="gi">+            if not report_missing:</span>
<span class="gi">+                return</span>
<span class="gi">+            if node_type == &#39;module&#39; and not node.body:</span>
<span class="gi">+                # Empty module, don&#39;t require docstring</span>
<span class="gi">+                return</span>
<span class="gi">+            if node_type in (&#39;function&#39;, &#39;method&#39;):</span>
<span class="gi">+                if node.name.startswith(&#39;_&#39;) and not node.name.endswith(&#39;__&#39;):</span>
<span class="gi">+                    # Don&#39;t require docstrings for non-public methods</span>
<span class="gi">+                    return</span>
<span class="gi">+                if is_property_setter(node) or is_property_deleter(node):</span>
<span class="gi">+                    # Don&#39;t require docstrings for property setters/deleters</span>
<span class="gi">+                    return</span>
<span class="gi">+                if is_overload_stub(node):</span>
<span class="gi">+                    # Don&#39;t require docstrings for overload stubs</span>
<span class="gi">+                    return</span>
<span class="gi">+            </span>
<span class="gi">+            # Check if the node matches the no-docstring-rgx</span>
<span class="gi">+            if self.linter.config.no_docstring_rgx.match(node.name):</span>
<span class="gi">+                return</span>
<span class="gi">+            </span>
<span class="gi">+            # Check if the node is shorter than docstring-min-length</span>
<span class="gi">+            if self.linter.config.docstring_min_length &gt; -1:</span>
<span class="gi">+                if node.end_lineno - node.lineno + 1 &lt; self.linter.config.docstring_min_length:</span>
<span class="gi">+                    return</span>
<span class="gi">+            </span>
<span class="gi">+            # Report missing docstring</span>
<span class="gi">+            self.add_message(f&#39;missing-{node_type}-docstring&#39;, node=node, confidence=confidence)</span>
<span class="gi">+        elif not docstring.strip():</span>
<span class="gi">+            # Report empty docstring</span>
<span class="gi">+            self.add_message(&#39;empty-docstring&#39;, node=node, args=(node_type,))</span>
<span class="gh">diff --git a/pylint/checkers/base/function_checker.py b/pylint/checkers/base/function_checker.py</span>
<span class="gh">index 8a0108704..03a04dd0e 100644</span>
<span class="gd">--- a/pylint/checkers/base/function_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/function_checker.py</span>
<span class="gu">@@ -23,7 +23,19 @@ class FunctionChecker(_BasicChecker):</span>
<span class="w"> </span>        :param node: FunctionDef node to check
<span class="w"> </span>        :type node: nodes.FunctionDef
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not node.is_generator():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        yield_nodes = list(node.nodes_of_class(nodes.Yield))</span>
<span class="gi">+        if not yield_nodes:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self._node_fails_contextmanager_cleanup(node, yield_nodes):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &#39;contextmanager-generator-missing-cleanup&#39;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(node.name,)</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _node_fails_contextmanager_cleanup(node: nodes.FunctionDef,
<span class="gu">@@ -42,4 +54,20 @@ class FunctionChecker(_BasicChecker):</span>
<span class="w"> </span>        :type yield_nodes: list[nodes.Yield]
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check if the yield value is non-constant</span>
<span class="gi">+        if any(not utils.is_const_node(yield_node.value) for yield_node in yield_nodes):</span>
<span class="gi">+            # Check if there&#39;s a finally block or GeneratorExit is caught</span>
<span class="gi">+            try_finally = next(node.nodes_of_class(nodes.TryFinally), None)</span>
<span class="gi">+            if not try_finally:</span>
<span class="gi">+                # Check if GeneratorExit is caught</span>
<span class="gi">+                try_except = next(node.nodes_of_class(nodes.TryExcept), None)</span>
<span class="gi">+                if not try_except or not any(</span>
<span class="gi">+                    isinstance(handler.type, nodes.Name) and handler.type.name == &#39;GeneratorExit&#39;</span>
<span class="gi">+                    for handler in try_except.handlers</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Check if there are statements after the yield</span>
<span class="gi">+                    for yield_node in yield_nodes:</span>
<span class="gi">+                        if any(isinstance(sibling, (nodes.Assign, nodes.Expr))</span>
<span class="gi">+                               for sibling in yield_node.get_siblings()):</span>
<span class="gi">+                            return True</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/pylint/checkers/base/name_checker/checker.py b/pylint/checkers/base/name_checker/checker.py</span>
<span class="gh">index 1ef68f6ca..8ba6d4c9a 100644</span>
<span class="gd">--- a/pylint/checkers/base/name_checker/checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/name_checker/checker.py</span>
<span class="gu">@@ -42,7 +42,9 @@ def _get_properties(config: argparse.Namespace) -&gt;tuple[set[str], set[str]]:</span>
<span class="w"> </span>    Property classes are fully qualified, such as &#39;abc.abstractproperty&#39; and
<span class="w"> </span>    property names are the actual names, such as &#39;abstract_property&#39;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    property_classes = set(config.property_classes)</span>
<span class="gi">+    property_names = {prop.rsplit(&#39;.&#39;, 1)[-1] for prop in property_classes}</span>
<span class="gi">+    return property_classes, property_names</span>


<span class="w"> </span>def _redefines_import(node: nodes.AssignName) -&gt;bool:
<span class="gu">@@ -51,7 +53,23 @@ def _redefines_import(node: nodes.AssignName) -&gt;bool:</span>

<span class="w"> </span>    Returns True if the node redefines an import, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current = node</span>
<span class="gi">+    while current and not isinstance(current, (nodes.ExceptHandler, nodes.TryExcept)):</span>
<span class="gi">+        current = current.parent</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(current, (nodes.ExceptHandler, nodes.TryExcept)):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    try_block = current.body if isinstance(current, nodes.TryExcept) else current.parent.body</span>
<span class="gi">+    for import_node in try_block:</span>
<span class="gi">+        if isinstance(import_node, (nodes.Import, nodes.ImportFrom)):</span>
<span class="gi">+            for name, alias in import_node.names:</span>
<span class="gi">+                if alias:</span>
<span class="gi">+                    if alias == node.name:</span>
<span class="gi">+                        return True</span>
<span class="gi">+                elif name == node.name:</span>
<span class="gi">+                    return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _determine_function_name_type(node: nodes.FunctionDef, config: argparse
<span class="gu">@@ -63,7 +81,37 @@ def _determine_function_name_type(node: nodes.FunctionDef, config: argparse</span>

<span class="w"> </span>    :returns: One of (&#39;function&#39;, &#39;method&#39;, &#39;attr&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not node.is_method():</span>
<span class="gi">+        return &#39;function&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    if node.decorators:</span>
<span class="gi">+        decorators = node.decorators.nodes</span>
<span class="gi">+    else:</span>
<span class="gi">+        decorators = []</span>
<span class="gi">+    </span>
<span class="gi">+    property_classes, property_names = _get_properties(config)</span>
<span class="gi">+    </span>
<span class="gi">+    for decorator in decorators:</span>
<span class="gi">+        if (isinstance(decorator, nodes.Name) and decorator.name in property_names or</span>
<span class="gi">+            isinstance(decorator, nodes.Attribute) and decorator.attrname in property_names or</span>
<span class="gi">+            isinstance(decorator, nodes.Call) and isinstance(decorator.func, nodes.Name) and</span>
<span class="gi">+            decorator.func.name in property_names):</span>
<span class="gi">+            return &#39;attr&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(decorator, nodes.Attribute):</span>
<span class="gi">+            if decorator.attrname in (&#39;setter&#39;, &#39;deleter&#39;):</span>
<span class="gi">+                return &#39;attr&#39;</span>
<span class="gi">+            if (decorator.expr.name == &#39;property&#39; and decorator.attrname in (&#39;getter&#39;, &#39;setter&#39;, &#39;deleter&#39;)):</span>
<span class="gi">+                return &#39;attr&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    if (node.name == &#39;__new__&#39; or</span>
<span class="gi">+        node.name.startswith(&#39;__&#39;) and node.name.endswith(&#39;__&#39;)):</span>
<span class="gi">+        return &#39;method&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    if node.name == &#39;__init_subclass__&#39;:</span>
<span class="gi">+        return &#39;classmethod&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    return &#39;method&#39;</span>


<span class="w"> </span>EXEMPT_NAME_CATEGORIES = {&#39;exempt&#39;, &#39;ignore&#39;}
<span class="gh">diff --git a/pylint/checkers/base_checker.py b/pylint/checkers/base_checker.py</span>
<span class="gh">index 7979baa3b..d10d398f4 100644</span>
<span class="gd">--- a/pylint/checkers/base_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base_checker.py</span>
<span class="gu">@@ -84,15 +84,30 @@ class BaseChecker(_ArgumentsProvider):</span>
<span class="w"> </span>        :raises InvalidMessageError: If the checker id in the messages are not
<span class="w"> </span>        always the same.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        checker_id = None</span>
<span class="gi">+        for msgid, msg in self.msgs.items():</span>
<span class="gi">+            if len(msgid) != 4:</span>
<span class="gi">+                raise InvalidMessageError(</span>
<span class="gi">+                    f&quot;Message id &#39;{msgid}&#39; should be a string of length 4&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if checker_id is None:</span>
<span class="gi">+                checker_id = msgid[:2]</span>
<span class="gi">+            elif msgid[:2] != checker_id:</span>
<span class="gi">+                raise InvalidMessageError(</span>
<span class="gi">+                    f&quot;Inconsistent checker id in message &#39;{msgid}&#39;&quot;</span>
<span class="gi">+                )</span>

<span class="w"> </span>    def open(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called before visiting project (i.e. set of modules).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This method can be used for initialization if needed</span>
<span class="gi">+        # For now, we&#39;ll keep it as a no-op</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called after visiting project (i.e set of modules).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This method can be used for cleanup if needed</span>
<span class="gi">+        # For now, we&#39;ll keep it as a no-op</span>
<span class="gi">+        return</span>


<span class="w"> </span>class BaseTokenChecker(BaseChecker):
<span class="gh">diff --git a/pylint/checkers/classes/class_checker.py b/pylint/checkers/classes/class_checker.py</span>
<span class="gh">index 01bad6883..cf8fa636d 100644</span>
<span class="gd">--- a/pylint/checkers/classes/class_checker.py</span>
<span class="gi">+++ b/pylint/checkers/classes/class_checker.py</span>
<span class="gu">@@ -299,23 +299,54 @@ class ClassChecker(BaseChecker):</span>
<span class="w"> </span>        &#39;subclassed-final-class&#39;, &#39;implicit-flag-alias&#39;)
<span class="w"> </span>    def visit_classdef(self, node: nodes.ClassDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Init visit variable _accessed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._accessed = ScopeAccessMap()</span>
<span class="gi">+        self._check_bases_classes(node)</span>
<span class="gi">+        self._check_classmethod_declaration(node)</span>
<span class="gi">+        self._check_proper_bases(node)</span>
<span class="gi">+        self._check_consistent_mro(node)</span>
<span class="gi">+        self._check_redefined_slots(node)</span>
<span class="gi">+        self._check_typing_final(node)</span>

<span class="w"> </span>    def _check_consistent_mro(self, node: nodes.ClassDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Detect that a class has a consistent mro or duplicate bases.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            node.mro()</span>
<span class="gi">+        except astroid.exceptions.InconsistentMroError:</span>
<span class="gi">+            self.add_message(&#39;inconsistent-mro&#39;, args=(node.name,), node=node)</span>
<span class="gi">+        except astroid.exceptions.DuplicateBasesError:</span>
<span class="gi">+            self.add_message(&#39;duplicate-bases&#39;, args=(node.name,), node=node)</span>

<span class="w"> </span>    def _check_proper_bases(self, node: nodes.ClassDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Detect that a class inherits something which is not
<span class="w"> </span>        a class or a type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for base in node.bases:</span>
<span class="gi">+            ancestor = safe_infer(base)</span>
<span class="gi">+            if ancestor in (astroid.Uninferable, None):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if (isinstance(ancestor, astroid.Instance) and</span>
<span class="gi">+                ancestor.is_subtype_of(&#39;builtins.type&#39;)):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not isinstance(ancestor, astroid.ClassDef):</span>
<span class="gi">+                self.add_message(&#39;inherit-non-class&#39;,</span>
<span class="gi">+                                 args=(ancestor.name,),</span>
<span class="gi">+                                 node=node)</span>

<span class="w"> </span>    def _check_typing_final(self, node: nodes.ClassDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Detect that a class does not subclass a class decorated with
<span class="w"> </span>        `typing.final`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for base in node.bases:</span>
<span class="gi">+            ancestor = safe_infer(base)</span>
<span class="gi">+            if ancestor in (astroid.Uninferable, None):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if isinstance(ancestor, astroid.ClassDef):</span>
<span class="gi">+                if utils.is_node_in_typing_guarded_import_block(ancestor):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if utils.is_decorated_with_final(ancestor):</span>
<span class="gi">+                    self.add_message(&#39;subclassed-final-class&#39;,</span>
<span class="gi">+                                     args=(node.name, ancestor.name),</span>
<span class="gi">+                                     node=node)</span>

<span class="w"> </span>    @only_required_for_messages(&#39;unused-private-member&#39;,
<span class="w"> </span>        &#39;attribute-defined-outside-init&#39;, &#39;access-member-before-definition&#39;)
<span class="gh">diff --git a/pylint/checkers/classes/special_methods_checker.py b/pylint/checkers/classes/special_methods_checker.py</span>
<span class="gh">index 98a772892..1fc6b039f 100644</span>
<span class="gd">--- a/pylint/checkers/classes/special_methods_checker.py</span>
<span class="gi">+++ b/pylint/checkers/classes/special_methods_checker.py</span>
<span class="gu">@@ -19,7 +19,11 @@ def _safe_infer_call_result(node: nodes.FunctionDef, caller: nodes.</span>
<span class="w"> </span>    Returns None if inference failed or if there is some ambiguity (more than
<span class="w"> </span>    one node has been inferred). Otherwise, returns inferred value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        inferit = node.infer_call_result(caller, context=context)</span>
<span class="gi">+        return next(inferit, None)</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class SpecialMethodsChecker(BaseChecker):
<span class="gu">@@ -82,4 +86,76 @@ class SpecialMethodsChecker(BaseChecker):</span>
<span class="w"> </span>            _check_length_hint, &#39;__format__&#39;: self._check_format,
<span class="w"> </span>            &#39;__getnewargs__&#39;: self._check_getnewargs, &#39;__getnewargs_ex__&#39;:
<span class="w"> </span>            self._check_getnewargs_ex}
<span class="gi">+    </span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        if not node.is_method():</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        if node.name in self._protocol_map:</span>
<span class="gi">+            result = _safe_infer_call_result(node, node)</span>
<span class="gi">+            if result:</span>
<span class="gi">+                self._protocol_map[node.name](node, result)</span>
<span class="gi">+        </span>
<span class="gi">+        if node.name in PYMETHODS:</span>
<span class="gi">+            expected_params = SPECIAL_METHODS_PARAMS[node.name]</span>
<span class="gi">+            actual_params = len(node.args.args) - 1  # Subtract 1 for &#39;self&#39;</span>
<span class="gi">+            if actual_params != expected_params:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &#39;unexpected-special-method-signature&#39;,</span>
<span class="gi">+                    args=(node.name, expected_params, actual_params, &#39;was&#39; if actual_params == 1 else &#39;were&#39;),</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef
<span class="gi">+</span>
<span class="gi">+    def _check_iter(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not hasattr(result, NEXT_METHOD) and not hasattr(result, &#39;__iter__&#39;):</span>
<span class="gi">+            self.add_message(&#39;non-iterator-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_len(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (bases.Instance, nodes.ClassDef)):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(result, (int, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, int)):</span>
<span class="gi">+            self.add_message(&#39;invalid-length-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_bool(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (bool, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, bool)):</span>
<span class="gi">+            self.add_message(&#39;invalid-bool-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_index(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (int, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, int)):</span>
<span class="gi">+            self.add_message(&#39;invalid-index-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_repr(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (str, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, str)):</span>
<span class="gi">+            self.add_message(&#39;invalid-repr-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_str(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (str, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, str)):</span>
<span class="gi">+            self.add_message(&#39;invalid-str-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_bytes(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (bytes, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, bytes)):</span>
<span class="gi">+            self.add_message(&#39;invalid-bytes-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_hash(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (int, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, int)):</span>
<span class="gi">+            self.add_message(&#39;invalid-hash-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_length_hint(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (int, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, int)):</span>
<span class="gi">+            self.add_message(&#39;invalid-length-hint-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_format(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (str, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, str)):</span>
<span class="gi">+            self.add_message(&#39;invalid-format-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_getnewargs(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (tuple, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, tuple)):</span>
<span class="gi">+            self.add_message(&#39;invalid-getnewargs-returned&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_getnewargs_ex(self, node: nodes.FunctionDef, result: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not isinstance(result, (tuple, bases.Instance)) or (isinstance(result, bases.Instance) and not issubclass(result._proxied.type, tuple)):</span>
<span class="gi">+            self.add_message(&#39;invalid-getnewargs-ex-returned&#39;, node=node)</span>
<span class="gi">+        elif isinstance(result, tuple) and (len(result) != 2 or not isinstance(result[0], tuple) or not isinstance(result[1], dict)):</span>
<span class="gi">+            self.add_message(&#39;invalid-getnewargs-ex-returned&#39;, node=node)</span>
<span class="gh">diff --git a/pylint/checkers/dataclass_checker.py b/pylint/checkers/dataclass_checker.py</span>
<span class="gh">index bf68dc00a..189f9a788 100644</span>
<span class="gd">--- a/pylint/checkers/dataclass_checker.py</span>
<span class="gi">+++ b/pylint/checkers/dataclass_checker.py</span>
<span class="gu">@@ -11,7 +11,7 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def _is_dataclasses_module(node: nodes.Module) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Utility function to check if node is from dataclasses_module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return node.name in DATACLASS_MODULES</span>


<span class="w"> </span>def _check_name_or_attrname_eq_to(node: (nodes.Name | nodes.Attribute),
<span class="gu">@@ -19,7 +19,9 @@ def _check_name_or_attrname_eq_to(node: (nodes.Name | nodes.Attribute),</span>
<span class="w"> </span>    &quot;&quot;&quot;Utility function to check either a Name/Attribute node&#39;s name/attrname with a
<span class="w"> </span>    given string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, nodes.Name):</span>
<span class="gi">+        return node.name == check_with</span>
<span class="gi">+    return node.attrname == check_with</span>


<span class="w"> </span>class DataclassChecker(BaseChecker):
<span class="gu">@@ -42,11 +44,29 @@ class DataclassChecker(BaseChecker):</span>
<span class="w"> </span>        @dataclass decorator and outside make_dataclass() function, or when it
<span class="w"> </span>        is used improperly within a dataclass.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not _check_name_or_attrname_eq_to(node.func, &quot;field&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        scope = node.scope()</span>
<span class="gi">+        if isinstance(scope, nodes.ClassDef):</span>
<span class="gi">+            if not utils.is_dataclass(scope):</span>
<span class="gi">+                self.add_message(&quot;invalid-field-call&quot;, node=node, args=&quot;used outside of a dataclass&quot;)</span>
<span class="gi">+            elif not isinstance(node.parent, nodes.Assign):</span>
<span class="gi">+                self.add_message(&quot;invalid-field-call&quot;, node=node, args=&quot;not used as a class variable&quot;)</span>
<span class="gi">+        elif isinstance(scope, nodes.FunctionDef):</span>
<span class="gi">+            self._check_invalid_field_call_within_call(node, scope)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_message(&quot;invalid-field-call&quot;, node=node, args=&quot;used outside of a dataclass or make_dataclass()&quot;)</span>

<span class="w"> </span>    def _check_invalid_field_call_within_call(self, node: nodes.Call,
<span class="w"> </span>        scope_node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks for special case where calling field is valid as an argument of the
<span class="w"> </span>        make_dataclass() function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not _check_name_or_attrname_eq_to(scope_node.func, &quot;make_dataclass&quot;):</span>
<span class="gi">+            self.add_message(&quot;invalid-field-call&quot;, node=node, args=&quot;used outside of make_dataclass()&quot;)</span>
<span class="gi">+        elif node not in scope_node.args and not any(</span>
<span class="gi">+            isinstance(kw.value, nodes.Call) and kw.value == node</span>
<span class="gi">+            for kw in scope_node.keywords</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;invalid-field-call&quot;, node=node, args=&quot;not used as an argument to make_dataclass()&quot;)</span>
<span class="gh">diff --git a/pylint/checkers/deprecated.py b/pylint/checkers/deprecated.py</span>
<span class="gh">index fbe3222fa..fb0f76d25 100644</span>
<span class="gd">--- a/pylint/checkers/deprecated.py</span>
<span class="gi">+++ b/pylint/checkers/deprecated.py</span>
<span class="gu">@@ -50,18 +50,21 @@ class DeprecatedMixin(BaseChecker):</span>
<span class="w"> </span>    @utils.only_required_for_messages(&#39;deprecated-attribute&#39;)
<span class="w"> </span>    def visit_attribute(self, node: astroid.Attribute) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called when an `astroid.Attribute` node is visited.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.check_deprecated_attribute(node)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;deprecated-method&#39;,
<span class="w"> </span>        &#39;deprecated-argument&#39;, &#39;deprecated-class&#39;)
<span class="w"> </span>    def visit_call(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called when a :class:`nodes.Call` node is visited.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for inferred in infer_all(node.func):</span>
<span class="gi">+            self.check_deprecated_method(node, inferred)</span>
<span class="gi">+        self.check_deprecated_class_in_call(node)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;deprecated-module&#39;, &#39;deprecated-class&#39;)
<span class="w"> </span>    def visit_import(self, node: nodes.Import) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Triggered when an import statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, _ in node.names:</span>
<span class="gi">+            self.check_deprecated_module(node, name.split(&#39;.&#39;)[0])</span>

<span class="w"> </span>    def deprecated_decorators(self) -&gt;Iterable[str]:
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated decorators.
<span class="gu">@@ -69,17 +72,25 @@ class DeprecatedMixin(BaseChecker):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            collections.abc.Container of deprecated decorator names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []  # Implement this in the subclass if needed</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;deprecated-decorator&#39;)
<span class="w"> </span>    def visit_decorators(self, node: nodes.Decorators) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Triggered when a decorator statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for decorator in node.nodes:</span>
<span class="gi">+            if isinstance(decorator, nodes.Call):</span>
<span class="gi">+                for inferred in infer_all(decorator.func):</span>
<span class="gi">+                    if isinstance(inferred, ACCEPTABLE_NODES):</span>
<span class="gi">+                        qname = inferred.qname()</span>
<span class="gi">+                        if any(qname.endswith(&#39;.&#39; + name) or qname == name for name in self.deprecated_decorators()):</span>
<span class="gi">+                            self.add_message(&#39;deprecated-decorator&#39;, node=decorator, args=qname)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;deprecated-module&#39;, &#39;deprecated-class&#39;)
<span class="w"> </span>    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Triggered when a from statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.check_deprecated_module(node, node.modname)</span>
<span class="gi">+        for name, _ in node.names:</span>
<span class="gi">+            self.check_deprecated_class(node, node.modname, [name])</span>

<span class="w"> </span>    def deprecated_methods(self) -&gt;Container[str]:
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated methods/functions.
<span class="gu">@@ -87,7 +98,7 @@ class DeprecatedMixin(BaseChecker):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            collections.abc.Container of deprecated function/method names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []  # Implement this in the subclass if needed</span>

<span class="w"> </span>    def deprecated_arguments(self, method: str) -&gt;Iterable[tuple[int | None,
<span class="w"> </span>        str]]:
<span class="gu">@@ -113,7 +124,7 @@ class DeprecatedMixin(BaseChecker):</span>
<span class="w"> </span>            .. code-block:: python
<span class="w"> </span>                ((1, &#39;arg2&#39;), (3, &#39;arg4&#39;))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []  # Implement this in the subclass if needed</span>

<span class="w"> </span>    def deprecated_modules(self) -&gt;Iterable[str]:
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated modules.
<span class="gu">@@ -121,7 +132,7 @@ class DeprecatedMixin(BaseChecker):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            collections.abc.Container of deprecated module names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []  # Implement this in the subclass if needed</span>

<span class="w"> </span>    def deprecated_classes(self, module: str) -&gt;Iterable[str]:
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated classes of module.
<span class="gu">@@ -132,20 +143,23 @@ class DeprecatedMixin(BaseChecker):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            collections.abc.Container of deprecated class names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []  # Implement this in the subclass if needed</span>

<span class="w"> </span>    def deprecated_attributes(self) -&gt;Iterable[str]:
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated attributes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []  # Implement this in the subclass if needed</span>

<span class="w"> </span>    def check_deprecated_attribute(self, node: astroid.Attribute) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks if the attribute is deprecated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for attr_name in self.deprecated_attributes():</span>
<span class="gi">+            if node.attrname == attr_name:</span>
<span class="gi">+                self.add_message(&#39;deprecated-attribute&#39;, node=node, args=attr_name)</span>

<span class="w"> </span>    def check_deprecated_module(self, node: nodes.Import, mod_path: (str |
<span class="w"> </span>        None)) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks if the module is deprecated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mod_path in self.deprecated_modules():</span>
<span class="gi">+            self.add_message(&#39;deprecated-module&#39;, node=node, args=mod_path)</span>

<span class="w"> </span>    def check_deprecated_method(self, node: nodes.Call, inferred: nodes.NodeNG
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -153,13 +167,35 @@ class DeprecatedMixin(BaseChecker):</span>

<span class="w"> </span>        This method should be called from the checker implementing this mixin.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(inferred, ACCEPTABLE_NODES):</span>
<span class="gi">+            qname = inferred.qname()</span>
<span class="gi">+            if any(qname.endswith(&#39;.&#39; + name) or qname == name for name in self.deprecated_methods()):</span>
<span class="gi">+                self.add_message(&#39;deprecated-method&#39;, node=node, args=qname)</span>
<span class="gi">+</span>
<span class="gi">+            # Check for deprecated arguments</span>
<span class="gi">+            if isinstance(node.func, astroid.Attribute):</span>
<span class="gi">+                method_name = node.func.attrname</span>
<span class="gi">+            elif isinstance(node.func, astroid.Name):</span>
<span class="gi">+                method_name = node.func.name</span>
<span class="gi">+            else:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            for pos, kw in chain(enumerate(node.args), ((None, arg) for arg in node.keywords)):</span>
<span class="gi">+                argname = kw.arg if isinstance(kw, nodes.Keyword) else None</span>
<span class="gi">+                for deprecated_pos, deprecated_name in self.deprecated_arguments(method_name):</span>
<span class="gi">+                    if (argname and argname == deprecated_name) or (pos == deprecated_pos):</span>
<span class="gi">+                        self.add_message(&#39;deprecated-argument&#39;, node=node, args=(deprecated_name, method_name))</span>

<span class="w"> </span>    def check_deprecated_class(self, node: nodes.NodeNG, mod_name: str,
<span class="w"> </span>        class_names: Iterable[str]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks if the class is deprecated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for class_name in class_names:</span>
<span class="gi">+            if class_name in self.deprecated_classes(mod_name):</span>
<span class="gi">+                self.add_message(&#39;deprecated-class&#39;, node=node, args=(class_name, mod_name))</span>

<span class="w"> </span>    def check_deprecated_class_in_call(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks if call the deprecated class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, astroid.Name):</span>
<span class="gi">+            inferred = safe_infer(node.func)</span>
<span class="gi">+            if isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+                self.check_deprecated_class(node, inferred.root().name, [inferred.name])</span>
<span class="gh">diff --git a/pylint/checkers/design_analysis.py b/pylint/checkers/design_analysis.py</span>
<span class="gh">index 0c785dc35..d3a3c9575 100644</span>
<span class="gd">--- a/pylint/checkers/design_analysis.py</span>
<span class="gi">+++ b/pylint/checkers/design_analysis.py</span>
<span class="gu">@@ -83,7 +83,21 @@ STDLIB_CLASSES_IGNORE_ANCESTOR = frozenset((&#39;builtins.object&#39;,</span>

<span class="w"> </span>def _is_exempt_from_public_methods(node: astroid.ClassDef) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if a class is exempt from too-few-public-methods.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check if the class is a dataclass</span>
<span class="gi">+    if any(decorator.name in DATACLASSES_DECORATORS for decorator in node.decorators.nodes):</span>
<span class="gi">+        return True</span>
<span class="gi">+    </span>
<span class="gi">+    # Check if the class is an Enum</span>
<span class="gi">+    if is_enum(node):</span>
<span class="gi">+        return True</span>
<span class="gi">+    </span>
<span class="gi">+    # Check if the class is a NamedTuple or TypedDict</span>
<span class="gi">+    if node.bases:</span>
<span class="gi">+        base_qname = node.bases[0].qname()</span>
<span class="gi">+        if base_qname in (TYPING_NAMEDTUPLE, TYPING_TYPEDDICT, TYPING_EXTENSIONS_TYPEDDICT):</span>
<span class="gi">+            return True</span>
<span class="gi">+    </span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _count_boolean_expressions(bool_op: nodes.BoolOp) -&gt;int:
<span class="gu">@@ -91,7 +105,13 @@ def _count_boolean_expressions(bool_op: nodes.BoolOp) -&gt;int:</span>

<span class="w"> </span>    example: a and (b or c or (d and e)) ==&gt; 5 boolean expressions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    count = 0</span>
<span class="gi">+    for value in bool_op.values:</span>
<span class="gi">+        if isinstance(value, nodes.BoolOp):</span>
<span class="gi">+            count += _count_boolean_expressions(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            count += 1</span>
<span class="gi">+    return count</span>


<span class="w"> </span>def _get_parents_iter(node: nodes.ClassDef, ignored_parents: frozenset[str]
<span class="gu">@@ -111,7 +131,17 @@ def _get_parents_iter(node: nodes.ClassDef, ignored_parents: frozenset[str]</span>
<span class="w"> </span>    And ``ignored_parents`` is ``{&quot;E&quot;}``, then this function will return
<span class="w"> </span>    ``{A, B, C, D}`` -- both ``E`` and its ancestors are excluded.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _get_parents(cls: nodes.ClassDef) -&gt;Iterator[nodes.ClassDef]:</span>
<span class="gi">+        for parent in cls.bases:</span>
<span class="gi">+            if isinstance(parent, nodes.Name):</span>
<span class="gi">+                parent = parent.infer().next()</span>
<span class="gi">+            if isinstance(parent, nodes.ClassDef):</span>
<span class="gi">+                if parent.qname() not in ignored_parents:</span>
<span class="gi">+                    yield parent</span>
<span class="gi">+                    yield from _get_parents(parent)</span>
<span class="gi">+</span>
<span class="gi">+    yield node</span>
<span class="gi">+    yield from _get_parents(node)</span>


<span class="w"> </span>class MisdesignChecker(BaseChecker):
<span class="gu">@@ -164,7 +194,9 @@ class MisdesignChecker(BaseChecker):</span>

<span class="w"> </span>    def open(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Initialize visit variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._returns = []</span>
<span class="gi">+        self._branches = defaultdict(int)</span>
<span class="gi">+        self._stmts = []</span>

<span class="w"> </span>    @only_required_for_messages(&#39;too-many-ancestors&#39;,
<span class="w"> </span>        &#39;too-many-instance-attributes&#39;, &#39;too-few-public-methods&#39;,
<span class="gu">@@ -201,17 +233,18 @@ class MisdesignChecker(BaseChecker):</span>

<span class="w"> </span>    def visit_return(self, _: nodes.Return) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Count number of returns.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._returns[-1] += 1</span>

<span class="w"> </span>    def visit_default(self, node: nodes.NodeNG) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Default visit method -&gt; increments the statements counter if
<span class="w"> </span>        necessary.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, (nodes.Statement, nodes.ExceptHandler)):</span>
<span class="gi">+            self._stmts[-1] += 1</span>

<span class="w"> </span>    def visit_try(self, node: nodes.Try) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increments the branches counter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._inc_branch(node, len(node.handlers) + len(node.orelse) + bool(node.finalbody))</span>

<span class="w"> </span>    @only_required_for_messages(&#39;too-many-boolean-expressions&#39;,
<span class="w"> </span>        &#39;too-many-branches&#39;)
<span class="gu">@@ -223,7 +256,14 @@ class MisdesignChecker(BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;Go through &quot;if&quot; node `node` and count its boolean expressions
<span class="w"> </span>        if the &#39;if&#39; node test is a BoolOp node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.test, nodes.BoolOp):</span>
<span class="gi">+            num_bool_expr = _count_boolean_expressions(node.test)</span>
<span class="gi">+            if num_bool_expr &gt; self.linter.config.max_bool_expr:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;too-many-boolean-expressions&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(num_bool_expr, self.linter.config.max_bool_expr),</span>
<span class="gi">+                )</span>

<span class="w"> </span>    def visit_while(self, node: nodes.While) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increments the branches counter.&quot;&quot;&quot;
<span class="gu">@@ -232,4 +272,4 @@ class MisdesignChecker(BaseChecker):</span>

<span class="w"> </span>    def _inc_branch(self, node: nodes.NodeNG, branchesnum: int=1) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increments the branches counter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._branches[node.scope()] += branchesnum</span>
<span class="gh">diff --git a/pylint/checkers/dunder_methods.py b/pylint/checkers/dunder_methods.py</span>
<span class="gh">index 461ad9d7e..85a536cf7 100644</span>
<span class="gd">--- a/pylint/checkers/dunder_methods.py</span>
<span class="gi">+++ b/pylint/checkers/dunder_methods.py</span>
<span class="gu">@@ -34,8 +34,43 @@ class DunderCallChecker(BaseChecker):</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def within_dunder_or_lambda_def(node: nodes.NodeNG) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Check if dunder method call is within a dunder method definition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        while parent:</span>
<span class="gi">+            if isinstance(parent, (nodes.FunctionDef, nodes.Lambda)):</span>
<span class="gi">+                if isinstance(parent, nodes.FunctionDef) and parent.name.startswith(&#39;__&#39;) and parent.name.endswith(&#39;__&#39;):</span>
<span class="gi">+                    return True</span>
<span class="gi">+                if isinstance(parent, nodes.Lambda) and parent.parent and isinstance(parent.parent, nodes.Call):</span>
<span class="gi">+                    func = parent.parent.func</span>
<span class="gi">+                    if isinstance(func, nodes.Attribute) and func.attrname in UNNECESSARY_DUNDER_CALL_LAMBDA_EXCEPTIONS:</span>
<span class="gi">+                        return True</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def visit_call(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if method being called is an unnecessary dunder method.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if node.func.attrname not in DUNDER_METHODS:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self.within_dunder_or_lambda_def(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        inferred = safe_infer(node.func)</span>
<span class="gi">+        if isinstance(inferred, UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(inferred, Instance):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.func.expr, nodes.Call) and isinstance(node.func.expr.func, nodes.Name) and node.func.expr.func.name == &#39;super&#39;:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        alternative = DUNDER_METHODS[node.func.attrname]</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &#39;unnecessary-dunder-call&#39;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=(node.func.attrname, alternative),</span>
<span class="gi">+            confidence=HIGH,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/pylint/checkers/ellipsis_checker.py b/pylint/checkers/ellipsis_checker.py</span>
<span class="gh">index 95b4666d6..16dde23b1 100644</span>
<span class="gd">--- a/pylint/checkers/ellipsis_checker.py</span>
<span class="gi">+++ b/pylint/checkers/ellipsis_checker.py</span>
<span class="gu">@@ -16,7 +16,7 @@ class EllipsisChecker(BaseChecker):</span>
<span class="w"> </span>        )}

<span class="w"> </span>    @only_required_for_messages(&#39;unnecessary-ellipsis&#39;)
<span class="gd">-    def visit_const(self, node: nodes.Const) -&gt;None:</span>
<span class="gi">+    def visit_const(self, node: nodes.Const) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the ellipsis constant is used unnecessarily.

<span class="w"> </span>        Emits a warning when:
<span class="gu">@@ -25,4 +25,19 @@ class EllipsisChecker(BaseChecker):</span>
<span class="w"> </span>           For example: A function consisting of an ellipsis followed by a
<span class="w"> </span>           return statement on the next line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.value is Ellipsis:</span>
<span class="gi">+            parent = node.parent</span>
<span class="gi">+            if isinstance(parent, nodes.Expr) and parent.lineno == node.lineno:</span>
<span class="gi">+                # Check if the ellipsis is preceded by a docstring</span>
<span class="gi">+                if isinstance(parent.previous_sibling(), nodes.Expr) and \</span>
<span class="gi">+                   isinstance(parent.previous_sibling().value, nodes.Const) and \</span>
<span class="gi">+                   isinstance(parent.previous_sibling().value.value, str):</span>
<span class="gi">+                    self.add_message(&#39;unnecessary-ellipsis&#39;, node=node)</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                # Check if there&#39;s another statement in the same scope</span>
<span class="gi">+                scope = node.scope()</span>
<span class="gi">+                for child in scope.body:</span>
<span class="gi">+                    if child is not parent and not isinstance(child, nodes.Pass):</span>
<span class="gi">+                        self.add_message(&#39;unnecessary-ellipsis&#39;, node=node)</span>
<span class="gi">+                        return</span>
<span class="gh">diff --git a/pylint/checkers/exceptions.py b/pylint/checkers/exceptions.py</span>
<span class="gh">index fe18d2c24..af80b256b 100644</span>
<span class="gd">--- a/pylint/checkers/exceptions.py</span>
<span class="gi">+++ b/pylint/checkers/exceptions.py</span>
<span class="gu">@@ -25,12 +25,20 @@ def _annotated_unpack_infer(stmt: nodes.NodeNG, context: (InferenceContext |</span>
<span class="w"> </span>    Returns an iterator which yields tuples in the format
<span class="w"> </span>    (&#39;original node&#39;, &#39;inferred node&#39;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(stmt, (nodes.List, nodes.Tuple)):</span>
<span class="gi">+        for elt in stmt.elts:</span>
<span class="gi">+            yield from _annotated_unpack_infer(elt, context)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for inferred in stmt.infer(context):</span>
<span class="gi">+            if isinstance(inferred, (nodes.List, nodes.Tuple)):</span>
<span class="gi">+                yield from _annotated_unpack_infer(inferred, context)</span>
<span class="gi">+            elif not isinstance(inferred, util.Uninferable):</span>
<span class="gi">+                yield stmt, inferred</span>


<span class="w"> </span>def _is_raising(body: list[nodes.NodeNG]) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return whether the given statement node raises an exception.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(isinstance(node, nodes.Raise) for node in body)</span>


<span class="w"> </span>MSGS: dict[str, MessageDefinitionTuple] = {&#39;E0701&#39;: (
<span class="gu">@@ -123,15 +131,89 @@ class ExceptionsChecker(checkers.BaseChecker):</span>

<span class="w"> </span>        An exception cause can be only `None` or an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.cause is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        cause = utils.safe_infer(node.cause)</span>
<span class="gi">+        if cause in (None, util.Uninferable):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(cause, nodes.Const) and cause.value is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(cause, nodes.ClassDef) and not utils.inherit_from_std_ex(cause):</span>
<span class="gi">+            self.add_message(&#39;bad-exception-cause&#39;, node=node)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;bare-except&#39;,
<span class="w"> </span>        &#39;broad-exception-caught&#39;, &#39;try-except-raise&#39;, &#39;binary-op-exception&#39;,
<span class="w"> </span>        &#39;bad-except-order&#39;, &#39;catching-non-exception&#39;, &#39;duplicate-except&#39;)
<span class="w"> </span>    def visit_trystar(self, node: nodes.TryStar) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check for empty except*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for handler in node.handlers:</span>
<span class="gi">+            if handler.type is None:</span>
<span class="gi">+                self.add_message(&#39;bare-except&#39;, node=handler)</span>
<span class="gi">+            elif isinstance(handler.type, nodes.BoolOp):</span>
<span class="gi">+                self.add_message(&#39;binary-op-exception&#39;, node=handler, args=handler.type.op)</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    excs = list(_annotated_unpack_infer(handler.type))</span>
<span class="gi">+                except astroid.InferenceError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                for exc in excs:</span>
<span class="gi">+                    if not utils.inherit_from_std_ex(exc[1]):</span>
<span class="gi">+                        self.add_message(&#39;catching-non-exception&#39;, node=handler.type, args=exc[1].name)</span>
<span class="gi">+</span>
<span class="gi">+        # Check for duplicate except handlers</span>
<span class="gi">+        seen_exc_types = set()</span>
<span class="gi">+        for handler in node.handlers:</span>
<span class="gi">+            if handler.type is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            exc_type = handler.type.as_string()</span>
<span class="gi">+            if exc_type in seen_exc_types:</span>
<span class="gi">+                self.add_message(&#39;duplicate-except&#39;, node=handler, args=exc_type)</span>
<span class="gi">+            else:</span>
<span class="gi">+                seen_exc_types.add(exc_type)</span>
<span class="gi">+</span>
<span class="gi">+        # Check for try-except-raise</span>
<span class="gi">+        if len(node.handlers) == 1 and len(node.handlers[0].body) == 1:</span>
<span class="gi">+            if isinstance(node.handlers[0].body[0], nodes.Raise):</span>
<span class="gi">+                self.add_message(&#39;try-except-raise&#39;, node=node.handlers[0])</span>

<span class="w"> </span>    def visit_try(self, node: nodes.Try) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check for empty except.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for handler in node.handlers:</span>
<span class="gi">+            if handler.type is None:</span>
<span class="gi">+                self.add_message(&#39;bare-except&#39;, node=handler)</span>
<span class="gi">+            elif isinstance(handler.type, nodes.BoolOp):</span>
<span class="gi">+                self.add_message(&#39;binary-op-exception&#39;, node=handler, args=handler.type.op)</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    excs = list(_annotated_unpack_infer(handler.type))</span>
<span class="gi">+                except astroid.InferenceError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                for exc in excs:</span>
<span class="gi">+                    if not utils.inherit_from_std_ex(exc[1]):</span>
<span class="gi">+                        self.add_message(&#39;catching-non-exception&#39;, node=handler.type, args=exc[1].name)</span>
<span class="gi">+</span>
<span class="gi">+        # Check for bad except clauses order</span>
<span class="gi">+        handlers = node.handlers</span>
<span class="gi">+        for index, handler in enumerate(handlers[:-1]):</span>
<span class="gi">+            if handler.type is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            for next_handler in handlers[index + 1:]:</span>
<span class="gi">+                if next_handler.type is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if _is_exception_tuple(handler.type):</span>
<span class="gi">+                    if _is_exception_tuple(next_handler.type):</span>
<span class="gi">+                        if _exception_tuple_contains(handler.type, next_handler.type):</span>
<span class="gi">+                            self.add_message(&#39;bad-except-order&#39;, node=next_handler, args=handler.type.as_string())</span>
<span class="gi">+                elif not _is_exception_tuple(next_handler.type):</span>
<span class="gi">+                    if utils.is_subclass_of(handler.type, next_handler.type):</span>
<span class="gi">+                        self.add_message(&#39;bad-except-order&#39;, node=next_handler, args=handler.type.as_string())</span>
<span class="gi">+</span>
<span class="gi">+        # Check for try-except-raise</span>
<span class="gi">+        if len(node.handlers) == 1 and len(node.handlers[0].body) == 1:</span>
<span class="gi">+            if isinstance(node.handlers[0].body[0], nodes.Raise):</span>
<span class="gi">+                self.add_message(&#39;try-except-raise&#39;, node=node.handlers[0])</span>
<span class="gh">diff --git a/pylint/checkers/format.py b/pylint/checkers/format.py</span>
<span class="gh">index 1b31de075..755d0b23b 100644</span>
<span class="gd">--- a/pylint/checkers/format.py</span>
<span class="gi">+++ b/pylint/checkers/format.py</span>
<span class="gu">@@ -102,7 +102,8 @@ class FormatChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>    def new_line(self, tokens: TokenWrapper, line_end: int, line_start: int
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;A new line has been encountered, process it if necessary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        line = tokens._tokens[line_start:line_end]</span>
<span class="gi">+        self.check_lines(tokens, line_start, &#39;&#39;.join(tok.string for tok in line), tokens._tokens[line_start].start[0])</span>

<span class="w"> </span>    def _check_keyword_parentheses(self, tokens: list[tokenize.TokenInfo],
<span class="w"> </span>        start: int) -&gt;None:
<span class="gu">@@ -115,7 +116,32 @@ class FormatChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>        tokens: The entire list of Tokens.
<span class="w"> </span>        start: The position of the keyword in the token list.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if start &gt;= len(tokens) - 2:</span>
<span class="gi">+            return  # Not enough tokens remaining.</span>
<span class="gi">+</span>
<span class="gi">+        if tokens[start + 1].string != &#39;(&#39;:</span>
<span class="gi">+            return  # Next token is not an opening parenthesis.</span>
<span class="gi">+</span>
<span class="gi">+        found_closing = False</span>
<span class="gi">+        opening_count = 0</span>
<span class="gi">+        has_comma = False</span>
<span class="gi">+        for token in tokens[start + 1:]:</span>
<span class="gi">+            if token.string == &#39;(&#39;:</span>
<span class="gi">+                opening_count += 1</span>
<span class="gi">+            elif token.string == &#39;)&#39;:</span>
<span class="gi">+                opening_count -= 1</span>
<span class="gi">+                if opening_count == 0:</span>
<span class="gi">+                    found_closing = True</span>
<span class="gi">+                    break</span>
<span class="gi">+            elif token.string == &#39;,&#39; and opening_count == 1:</span>
<span class="gi">+                has_comma = True</span>
<span class="gi">+            elif token.type == tokenize.NEWLINE:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if found_closing and not has_comma:</span>
<span class="gi">+            self.add_message(&#39;superfluous-parens&#39;,</span>
<span class="gi">+                             line=tokens[start].start[0],</span>
<span class="gi">+                             args=(tokens[start].string,))</span>

<span class="w"> </span>    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process tokens and search for:
<span class="gu">@@ -124,43 +150,112 @@ class FormatChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>        - optionally bad construct (if given, bad_construct must be a compiled
<span class="w"> </span>          regular expression).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token_wrapper = TokenWrapper(tokens)</span>
<span class="gi">+        indents = [0]</span>
<span class="gi">+        check_equal = False</span>
<span class="gi">+        line_num = 0</span>
<span class="gi">+        line_start = 0</span>
<span class="gi">+        for idx, token in enumerate(tokens):</span>
<span class="gi">+            if token.type == tokenize.NEWLINE:</span>
<span class="gi">+                line_num = token.end[0]</span>
<span class="gi">+                self.new_line(token_wrapper, idx, line_start)</span>
<span class="gi">+                line_start = idx + 1</span>
<span class="gi">+            elif token.type == tokenize.INDENT:</span>
<span class="gi">+                indents.append(indents[-1] + 1)</span>
<span class="gi">+                check_equal = True</span>
<span class="gi">+            elif token.type == tokenize.DEDENT:</span>
<span class="gi">+                if len(indents) &gt; 1:</span>
<span class="gi">+                    indents.pop()</span>
<span class="gi">+                check_equal = True</span>
<span class="gi">+            elif token.type == tokenize.NAME and token.string in _KEYWORD_TOKENS:</span>
<span class="gi">+                self._check_keyword_parentheses(tokens, idx)</span>
<span class="gi">+</span>
<span class="gi">+        self.check_lines(token_wrapper, line_start, &#39;&#39;, line_num)</span>

<span class="w"> </span>    @only_required_for_messages(&#39;multiple-statements&#39;)
<span class="w"> </span>    def visit_default(self, node: nodes.NodeNG) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check the node line number and check it if not yet done.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, (nodes.Module, nodes.ClassDef, nodes.FunctionDef)):</span>
<span class="gi">+            return</span>
<span class="gi">+        if node.root().file.endswith(&#39;__init__.py&#39;):</span>
<span class="gi">+            return</span>
<span class="gi">+        line = node.fromlineno</span>
<span class="gi">+        if line in self._visited_lines:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._visited_lines[line] = 1</span>
<span class="gi">+        self._check_multi_statement_line(node, line)</span>

<span class="w"> </span>    def _check_multi_statement_line(self, node: nodes.NodeNG, line: int
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check for lines containing multiple statements.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.parent, nodes.If):</span>
<span class="gi">+            if node.parent.body[0] is node and node.parent.orelse and node.parent.orelse[0].fromlineno == line:</span>
<span class="gi">+                return</span>
<span class="gi">+        if isinstance(node, (nodes.Lambda, nodes.ListComp, nodes.SetComp, nodes.GeneratorExp)):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node, nodes.Expr) and isinstance(node.value, nodes.Yield):</span>
<span class="gi">+            return</span>
<span class="gi">+        sibling = node.next_sibling()</span>
<span class="gi">+        if sibling is not None and sibling.fromlineno == line:</span>
<span class="gi">+            self.add_message(&#39;multiple-statements&#39;, node=node)</span>

<span class="w"> </span>    def check_trailing_whitespace_ending(self, line: str, i: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check that there is no trailing white-space.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stripped_line = line.rstrip(&#39;\n\r&#39;)</span>
<span class="gi">+        if stripped_line != line.rstrip():</span>
<span class="gi">+            self.add_message(&#39;trailing-whitespace&#39;, line=i)</span>

<span class="w"> </span>    def check_line_length(self, line: str, i: int, checker_off: bool) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check that the line length is less than the authorized value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        max_chars = self.config.max_line_length</span>
<span class="gi">+        ignore_long_line = self.config.ignore_long_lines</span>
<span class="gi">+        line = line.rstrip()</span>
<span class="gi">+        if len(line) &gt; max_chars and not checker_off:</span>
<span class="gi">+            if not ignore_long_line.search(line):</span>
<span class="gi">+                self.add_message(&#39;line-too-long&#39;, line=i, args=(len(line), max_chars))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def remove_pylint_option_from_lines(options_pattern_obj: Match[str]) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Remove the `# pylint ...` pattern from lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return options_pattern_obj.group(1)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def is_line_length_check_activated(pylint_pattern_match_object: Match[str]
<span class="w"> </span>        ) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Return True if the line length check is activated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            for pragma in parse_pragma(pylint_pattern_match_object.group(2)):</span>
<span class="gi">+                if pragma.action == OPTION_PO.disable and &#39;line-too-long&#39; in pragma.messages:</span>
<span class="gi">+                    return False</span>
<span class="gi">+                if pragma.action == OPTION_PO.enable and &#39;line-too-long&#39; in pragma.messages:</span>
<span class="gi">+                    return True</span>
<span class="gi">+        except PragmaParserError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def specific_splitlines(lines: str) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Split lines according to universal newlines except those in a specific
<span class="w"> </span>        sets.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        unsplit_ends = {&#39;\v&#39;, &#39;\x0b&#39;, &#39;\f&#39;, &#39;\x0c&#39;, &#39;\x1c&#39;, &#39;\x1d&#39;, &#39;\x1e&#39;, &#39;\x85&#39;, &#39;\u2028&#39;, &#39;\u2029&#39;}</span>
<span class="gi">+        res = []</span>
<span class="gi">+        buffer = []</span>
<span class="gi">+        for char in lines:</span>
<span class="gi">+            if char in &#39;\n\r&#39;:</span>
<span class="gi">+                if buffer:</span>
<span class="gi">+                    res.append(&#39;&#39;.join(buffer))</span>
<span class="gi">+                    buffer = []</span>
<span class="gi">+                if (not res) or (res[-1] != &#39;\n&#39;):</span>
<span class="gi">+                    res.append(&#39;\n&#39;)</span>
<span class="gi">+            elif char in unsplit_ends:</span>
<span class="gi">+                if buffer:</span>
<span class="gi">+                    buffer.append(char)</span>
<span class="gi">+            else:</span>
<span class="gi">+                buffer.append(char)</span>
<span class="gi">+        if buffer:</span>
<span class="gi">+            res.append(&#39;&#39;.join(buffer))</span>
<span class="gi">+        return res</span>

<span class="w"> </span>    def check_lines(self, tokens: TokenWrapper, line_start: int, lines: str,
<span class="w"> </span>        lineno: int) -&gt;None:
<span class="gu">@@ -171,9 +266,38 @@ class FormatChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>        - no trailing white-space
<span class="w"> </span>        - less than a maximum number of characters
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines = self.specific_splitlines(lines)</span>
<span class="gi">+        if lines and not lines[-1].endswith(&#39;\n&#39;):</span>
<span class="gi">+            self.add_message(&#39;missing-final-newline&#39;, line=lineno)</span>
<span class="gi">+        </span>
<span class="gi">+        for i, line in enumerate(lines, start=lineno):</span>
<span class="gi">+            self.check_trailing_whitespace_ending(line, i)</span>
<span class="gi">+</span>
<span class="gi">+            if line.endswith(&#39;\n&#39;):</span>
<span class="gi">+                line = line[:-1]</span>
<span class="gi">+</span>
<span class="gi">+            checker_off = False</span>
<span class="gi">+            pylint_pattern_match = OPTION_PO.search(line)</span>
<span class="gi">+            if pylint_pattern_match:</span>
<span class="gi">+                checker_off = not self.is_line_length_check_activated(pylint_pattern_match)</span>
<span class="gi">+                line = self.remove_pylint_option_from_lines(pylint_pattern_match)</span>
<span class="gi">+</span>
<span class="gi">+            self.check_line_length(line, i, checker_off)</span>

<span class="w"> </span>    def check_indent_level(self, string: str, expected: int, line_num: int
<span class="w"> </span>        ) -&gt;None:
<span class="gd">-        &quot;&quot;&quot;Return the indent level of the string.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Check the indent level of the string.&quot;&quot;&quot;</span>
<span class="gi">+        indent = self.config.indent_string</span>
<span class="gi">+        if indent == &#39;\\t&#39;:</span>
<span class="gi">+            indent = &#39;\t&#39;</span>
<span class="gi">+        level = 0</span>
<span class="gi">+        for char in string:</span>
<span class="gi">+            if char == &#39; &#39;:</span>
<span class="gi">+                level += 1</span>
<span class="gi">+            elif char == &#39;\t&#39;:</span>
<span class="gi">+                level += len(indent)</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        if level != expected:</span>
<span class="gi">+            self.add_message(&#39;bad-indentation&#39;, line=line_num,</span>
<span class="gi">+                             args=(level, &#39;spaces&#39; if indent == &#39;    &#39; else &#39;tabs&#39;, expected))</span>
<span class="gh">diff --git a/pylint/checkers/imports.py b/pylint/checkers/imports.py</span>
<span class="gh">index 14add5d0f..11b540b65 100644</span>
<span class="gd">--- a/pylint/checkers/imports.py</span>
<span class="gi">+++ b/pylint/checkers/imports.py</span>
<span class="gu">@@ -167,27 +167,61 @@ class ImportsChecker(DeprecatedMixin, BaseChecker):</span>

<span class="w"> </span>    def open(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called before visiting project (i.e set of modules).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._allow_any_import_level = set(self.linter.config.allow_any_import_level)</span>

<span class="w"> </span>    def close(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Called before visiting project (i.e set of modules).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._module_pkg.clear()</span>
<span class="gi">+        self._imports_stack.clear()</span>
<span class="gi">+        self._first_non_import_node = None</span>

<span class="w"> </span>    def deprecated_modules(self) -&gt;set[str]:
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated modules.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        python_version = sys.version_info[:3]</span>
<span class="gi">+        deprecated = set(self.linter.config.deprecated_modules)</span>
<span class="gi">+        for since_version, modules in DEPRECATED_MODULES.items():</span>
<span class="gi">+            if python_version &gt;= since_version:</span>
<span class="gi">+                deprecated.update(modules)</span>
<span class="gi">+        return deprecated</span>

<span class="w"> </span>    def visit_module(self, node: nodes.Module) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Store if current module is a package, i.e. an __init__ file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._module_pkg[node] = node.package</span>

<span class="w"> </span>    def visit_import(self, node: nodes.Import) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Triggered when an import statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_imports(node)</span>
<span class="gi">+        self._check_position(node)</span>
<span class="gi">+</span>
<span class="gi">+        for name, alias in node.names:</span>
<span class="gi">+            self._check_reimport(node, name, alias)</span>
<span class="gi">+            imported_module = self._get_imported_module(node, name)</span>
<span class="gi">+            if imported_module is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            self._check_deprecated_module(node, name)</span>
<span class="gi">+            self._add_imported_module(node, name)</span>
<span class="gi">+            self._check_preferred_module(node, name)</span>

<span class="w"> </span>    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Triggered when a from statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_imports(node)</span>
<span class="gi">+        self._check_position(node)</span>
<span class="gi">+</span>
<span class="gi">+        basename = node.modname</span>
<span class="gi">+        imported_module = self._get_imported_module(node, basename)</span>
<span class="gi">+</span>
<span class="gi">+        if imported_module is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._check_deprecated_module(node, basename)</span>
<span class="gi">+        self._add_imported_module(node, basename)</span>
<span class="gi">+        self._check_preferred_module(node, basename)</span>
<span class="gi">+</span>
<span class="gi">+        for name, alias in node.names:</span>
<span class="gi">+            self._check_reimport(node, name, alias, basename, node.level)</span>
<span class="gi">+</span>
<span class="gi">+        if node.names[0][0] == &#39;*&#39;:</span>
<span class="gi">+            self._check_wildcard_imports(node, imported_module)</span>
<span class="w"> </span>    (visit_try) = (visit_assignattr) = (visit_assign) = (visit_ifexp) = (
<span class="w"> </span>        visit_comprehension) = (visit_expr) = (visit_if
<span class="w"> </span>        ) = compute_first_non_import_node
<span class="gh">diff --git a/pylint/checkers/lambda_expressions.py b/pylint/checkers/lambda_expressions.py</span>
<span class="gh">index a4466072b..1337e9e59 100644</span>
<span class="gd">--- a/pylint/checkers/lambda_expressions.py</span>
<span class="gi">+++ b/pylint/checkers/lambda_expressions.py</span>
<span class="gu">@@ -24,8 +24,19 @@ class LambdaExpressionChecker(BaseChecker):</span>

<span class="w"> </span>    def visit_assign(self, node: nodes.Assign) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if lambda expression is assigned to a variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for target in node.targets:</span>
<span class="gi">+            if isinstance(node.value, nodes.Lambda):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &#39;unnecessary-lambda-assignment&#39;,</span>
<span class="gi">+                    node=target,</span>
<span class="gi">+                    confidence=HIGH</span>
<span class="gi">+                )</span>

<span class="w"> </span>    def visit_call(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if lambda expression is called directly.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Lambda):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &#39;unnecessary-direct-lambda-call&#39;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=HIGH</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/pylint/checkers/logging.py b/pylint/checkers/logging.py</span>
<span class="gh">index e7eeb4359..d03066638 100644</span>
<span class="gd">--- a/pylint/checkers/logging.py</span>
<span class="gi">+++ b/pylint/checkers/logging.py</span>
<span class="gu">@@ -52,7 +52,13 @@ def is_method_call(func: bases.BoundMethod, types: tuple[str, ...]=(),</span>
<span class="w"> </span>      true if the node represents a method call for the given type and
<span class="w"> </span>      method names, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(func, bases.BoundMethod):</span>
<span class="gi">+        if types and func.bound.name not in types:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if methods and func.name not in methods:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class LoggingChecker(checkers.BaseChecker):
<span class="gu">@@ -70,41 +76,90 @@ class LoggingChecker(checkers.BaseChecker):</span>

<span class="w"> </span>    def visit_module(self, _: nodes.Module) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Clears any state left in this checker from last module checked.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # No state to clear in this implementation</span>
<span class="gi">+        return</span>

<span class="w"> </span>    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks to see if a module uses a non-Python logging module.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.modname in self.options.logging_modules:</span>
<span class="gi">+            self._logging_modules.add(node.modname)</span>

<span class="w"> </span>    def visit_import(self, node: nodes.Import) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks to see if this module uses Python&#39;s built-in logging.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, _ in node.names:</span>
<span class="gi">+            if name in self.options.logging_modules:</span>
<span class="gi">+                self._logging_modules.add(name)</span>

<span class="w"> </span>    def visit_call(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks calls to logging methods.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+            for logging_module in self._logging_modules:</span>
<span class="gi">+                if node.func.attrname in CHECKED_CONVENIENCE_FUNCTIONS:</span>
<span class="gi">+                    if isinstance(node.func.expr, nodes.Name):</span>
<span class="gi">+                        if node.func.expr.name == logging_module:</span>
<span class="gi">+                            self._check_log_method(node, node.func.attrname)</span>
<span class="gi">+                elif node.func.attrname == &#39;log&#39;:</span>
<span class="gi">+                    if isinstance(node.func.expr, nodes.Name):</span>
<span class="gi">+                        if node.func.expr.name == logging_module:</span>
<span class="gi">+                            self._check_log_method(node, &#39;log&#39;)</span>

<span class="w"> </span>    def _check_log_method(self, node: nodes.Call, name: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks calls to logging.log(level, format, *format_args).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name == &#39;log&#39; and len(node.args) &gt;= 2:</span>
<span class="gi">+            format_pos = 1</span>
<span class="gi">+        elif len(node.args) &gt;= 1:</span>
<span class="gi">+            format_pos = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.args[format_pos], nodes.JoinedStr):</span>
<span class="gi">+            self.add_message(&#39;logging-fstring-interpolation&#39;, node=node,</span>
<span class="gi">+                             args=(self._helper_string(node),))</span>
<span class="gi">+        elif isinstance(node.args[format_pos], nodes.Call):</span>
<span class="gi">+            self._check_call_func(node.args[format_pos])</span>
<span class="gi">+        elif isinstance(node.args[format_pos], nodes.Const):</span>
<span class="gi">+            self._check_format_string(node, format_pos)</span>

<span class="w"> </span>    def _helper_string(self, node: nodes.Call) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Create a string that lists the valid types of formatting for this node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        valid_formats = []</span>
<span class="gi">+        if not self.linter.is_message_enabled(&#39;logging-not-lazy&#39;):</span>
<span class="gi">+            valid_formats.append(&#39;%&#39;)</span>
<span class="gi">+        if not self.linter.is_message_enabled(&#39;logging-format-interpolation&#39;):</span>
<span class="gi">+            valid_formats.append(&#39;.format()&#39;)</span>
<span class="gi">+        if not self.linter.is_message_enabled(&#39;logging-fstring-interpolation&#39;):</span>
<span class="gi">+            valid_formats.append(&#39;f-string&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if len(valid_formats) &gt; 1:</span>
<span class="gi">+            return f&quot;{&#39;, &#39;.join(valid_formats[:-1])} or {valid_formats[-1]}&quot;</span>
<span class="gi">+        elif len(valid_formats) == 1:</span>
<span class="gi">+            return valid_formats[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &quot;another type of string formatting&quot;</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _is_operand_literal_str(operand: (InferenceResult | None)) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Return True if the operand in argument is a literal string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(operand, nodes.Const):</span>
<span class="gi">+            return isinstance(operand.value, str)</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _is_node_explicit_str_concatenation(node: nodes.NodeNG) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Return True if the node represents an explicitly concatenated string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, nodes.BinOp) and node.op == &#39;+&#39;:</span>
<span class="gi">+            left_operand = node.left</span>
<span class="gi">+            right_operand = node.right</span>
<span class="gi">+            return (LoggingChecker._is_operand_literal_str(left_operand) and</span>
<span class="gi">+                    LoggingChecker._is_operand_literal_str(right_operand))</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def _check_call_func(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks that function call is not format_string.format().&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+            if node.func.attrname == &#39;format&#39;:</span>
<span class="gi">+                self.add_message(&#39;logging-format-interpolation&#39;, node=node,</span>
<span class="gi">+                                 args=(self._helper_string(node),))</span>

<span class="w"> </span>    def _check_format_string(self, node: nodes.Call, format_arg: Literal[0, 1]
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -114,12 +169,34 @@ class LoggingChecker(checkers.BaseChecker):</span>
<span class="w"> </span>          node: AST node to be checked.
<span class="w"> </span>          format_arg: Index of the format string in the node arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        format_string = node.args[format_arg].value</span>
<span class="gi">+        if not isinstance(format_string, str):</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            required_args = tuple(string.Formatter().parse(format_string))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            self.add_message(&#39;logging-format-truncated&#39;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        positional_args = len(node.args) - format_arg - 1</span>
<span class="gi">+        keyword_args = len(node.keywords)</span>
<span class="gi">+</span>
<span class="gi">+        if positional_args + keyword_args &gt; len(required_args):</span>
<span class="gi">+            self.add_message(&#39;logging-too-many-args&#39;, node=node)</span>
<span class="gi">+        elif positional_args + keyword_args &lt; len(required_args):</span>
<span class="gi">+            self.add_message(&#39;logging-too-few-args&#39;, node=node)</span>


<span class="w"> </span>def is_complex_format_str(node: nodes.NodeNG) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return whether the node represents a string with complex formatting specs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, nodes.Const) and isinstance(node.value, str):</span>
<span class="gi">+        try:</span>
<span class="gi">+            format_specs = [spec for _, _, spec, _ in string.Formatter().parse(node.value) if spec]</span>
<span class="gi">+            return any(spec for spec in format_specs if set(spec) - set(string.digits))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return False</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _count_supplied_tokens(args: list[nodes.NodeNG]) -&gt;int:
<span class="gu">@@ -135,7 +212,7 @@ def _count_supplied_tokens(args: list[nodes.NodeNG]) -&gt;int:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      Number of AST nodes that aren&#39;t keywords.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(1 for arg in args if not isinstance(arg, nodes.Keyword))</span>


<span class="w"> </span>def str_formatting_in_f_string(node: nodes.JoinedStr) -&gt;bool:
<span class="gu">@@ -143,4 +220,7 @@ def str_formatting_in_f_string(node: nodes.JoinedStr) -&gt;bool:</span>

<span class="w"> </span>    For example: `f&#39;Hello %s&#39;`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for value in node.values:</span>
<span class="gi">+        if isinstance(value, nodes.Const) and &#39;%&#39; in value.value:</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gh">diff --git a/pylint/checkers/method_args.py b/pylint/checkers/method_args.py</span>
<span class="gh">index b9264d586..ac2c641a2 100644</span>
<span class="gd">--- a/pylint/checkers/method_args.py</span>
<span class="gi">+++ b/pylint/checkers/method_args.py</span>
<span class="gu">@@ -40,11 +40,38 @@ class MethodArgsChecker(BaseChecker):</span>

<span class="w"> </span>        Package uses inferred node in order to know the package imported.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            func = node.func.inferred()[0]</span>
<span class="gi">+            qname = func.qname()</span>
<span class="gi">+            if qname in self.linter.config.timeout_methods:</span>
<span class="gi">+                if &#39;timeout&#39; not in node.keywords and len(node.args) &lt; func.argnames().index(&#39;timeout&#39;) + 1:</span>
<span class="gi">+                    self.add_message(&#39;missing-timeout&#39;, node=node, args=(qname,))</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>

<span class="w"> </span>    def _check_positional_only_arguments_expected(self, node: nodes.Call
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if positional only arguments have been passed as keyword arguments by
<span class="w"> </span>        inspecting its method definition.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            func = node.func.inferred()[0]</span>
<span class="gi">+            if isinstance(func, astroid.BoundMethod):</span>
<span class="gi">+                func = func._proxied</span>
<span class="gi">+</span>
<span class="gi">+            if not isinstance(func, (astroid.FunctionDef, astroid.UnboundMethod)):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            positional_only = []</span>
<span class="gi">+            for arg in func.args.posonlyargs:</span>
<span class="gi">+                if arg.name in node.keywords:</span>
<span class="gi">+                    positional_only.append(arg.name)</span>
<span class="gi">+</span>
<span class="gi">+            if positional_only:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &#39;positional-only-arguments-expected&#39;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(func.name, &quot;, &quot;.join(positional_only))</span>
<span class="gi">+                )</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gh">diff --git a/pylint/checkers/misc.py b/pylint/checkers/misc.py</span>
<span class="gh">index c7fce6781..ab3596c9a 100644</span>
<span class="gd">--- a/pylint/checkers/misc.py</span>
<span class="gi">+++ b/pylint/checkers/misc.py</span>
<span class="gu">@@ -20,7 +20,20 @@ class ByIdManagedMessagesChecker(BaseRawFileChecker):</span>

<span class="w"> </span>    def process_module(self, node: nodes.Module) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Inspect the source file to find messages activated or deactivated by id.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for comment in node.file_encoding.encoding_line, node.file_encoding.shebang:</span>
<span class="gi">+            if comment and comment.strip().lower().startswith(&#39;pylint:&#39;):</span>
<span class="gi">+                self._check_message_id(comment)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_message_id(self, comment):</span>
<span class="gi">+        &quot;&quot;&quot;Check if the comment contains a message enabled or disabled by id.&quot;&quot;&quot;</span>
<span class="gi">+        match = re.search(r&#39;(?:enable|disable)=([^,\s]+)&#39;, comment)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            messages = match.group(1).split(&#39;,&#39;)</span>
<span class="gi">+            for message in messages:</span>
<span class="gi">+                if message.startswith(&#39;C&#39;) or message.startswith(&#39;R&#39;):</span>
<span class="gi">+                    self.add_message(&#39;use-symbolic-message-instead&#39;,</span>
<span class="gi">+                                     line=1,</span>
<span class="gi">+                                     args=f&quot;Message &#39;{message}&#39; is referred to by its id, use its symbolic name instead&quot;)</span>


<span class="w"> </span>class EncodingChecker(BaseTokenChecker, BaseRawFileChecker):
<span class="gu">@@ -43,8 +56,24 @@ class EncodingChecker(BaseTokenChecker, BaseRawFileChecker):</span>

<span class="w"> </span>    def process_module(self, node: nodes.Module) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Inspect the source file to find encoding problem.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        encoding = node.file_encoding.encoding</span>
<span class="gi">+        if encoding is None:</span>
<span class="gi">+            self.add_message(&#39;no-encoding-declaration&#39;, line=1)</span>
<span class="gi">+        elif encoding.lower() != &#39;utf-8&#39;:</span>
<span class="gi">+            self.add_message(&#39;non-utf8-encoding&#39;, line=1, args=encoding)</span>

<span class="w"> </span>    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Inspect the source to find fixme problems.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        notes_re = &#39;|&#39;.join(map(re.escape, self.config.notes))</span>
<span class="gi">+        if self.config.notes_rgx:</span>
<span class="gi">+            notes_re = f&#39;({notes_re}|{self.config.notes_rgx})&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            notes_re = f&#39;({notes_re})&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        for token in tokens:</span>
<span class="gi">+            if token.type == tokenize.COMMENT:</span>
<span class="gi">+                comment = token.string.lstrip(&#39;#&#39;)</span>
<span class="gi">+                match = re.search(notes_re, comment, re.IGNORECASE)</span>
<span class="gi">+                if match:</span>
<span class="gi">+                    note = match.group(1)</span>
<span class="gi">+                    self.add_message(&#39;fixme&#39;, args=comment, line=token.start[0])</span>
<span class="gh">diff --git a/pylint/checkers/modified_iterating_checker.py b/pylint/checkers/modified_iterating_checker.py</span>
<span class="gh">index a2395f574..9f6062e6b 100644</span>
<span class="gd">--- a/pylint/checkers/modified_iterating_checker.py</span>
<span class="gi">+++ b/pylint/checkers/modified_iterating_checker.py</span>
<span class="gu">@@ -33,4 +33,28 @@ class ModifiedIterationChecker(checkers.BaseChecker):</span>
<span class="w"> </span>    def _modified_iterating_check_on_node_and_children(self, body_node:
<span class="w"> </span>        nodes.NodeNG, iter_obj: nodes.NodeNG) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;See if node or any of its children raises modified iterating messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(body_node, nodes.Call):</span>
<span class="gi">+            self._check_call_node(body_node, iter_obj)</span>
<span class="gi">+        elif isinstance(body_node, (nodes.Assign, nodes.AugAssign)):</span>
<span class="gi">+            self._check_assign_node(body_node, iter_obj)</span>
<span class="gi">+        </span>
<span class="gi">+        for child in body_node.get_children():</span>
<span class="gi">+            self._modified_iterating_check_on_node_and_children(child, iter_obj)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_call_node(self, call_node: nodes.Call, iter_obj: nodes.NodeNG) -&gt; None:</span>
<span class="gi">+        if isinstance(call_node.func, nodes.Attribute):</span>
<span class="gi">+            if isinstance(call_node.func.expr, nodes.Name) and call_node.func.expr.name == iter_obj.name:</span>
<span class="gi">+                if isinstance(iter_obj, nodes.List) and call_node.func.attrname in _LIST_MODIFIER_METHODS:</span>
<span class="gi">+                    self.add_message(&#39;modified-iterating-list&#39;, node=call_node, args=iter_obj.name)</span>
<span class="gi">+                elif isinstance(iter_obj, nodes.Dict) and call_node.func.attrname in _SET_MODIFIER_METHODS:</span>
<span class="gi">+                    self.add_message(&#39;modified-iterating-dict&#39;, node=call_node, args=iter_obj.name)</span>
<span class="gi">+                elif isinstance(iter_obj, nodes.Set) and call_node.func.attrname in _SET_MODIFIER_METHODS:</span>
<span class="gi">+                    self.add_message(&#39;modified-iterating-set&#39;, node=call_node, args=iter_obj.name)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_assign_node(self, assign_node: nodes.Assign, iter_obj: nodes.NodeNG) -&gt; None:</span>
<span class="gi">+        if isinstance(assign_node.targets[0], nodes.Subscript):</span>
<span class="gi">+            if isinstance(assign_node.targets[0].value, nodes.Name) and assign_node.targets[0].value.name == iter_obj.name:</span>
<span class="gi">+                if isinstance(iter_obj, nodes.Dict):</span>
<span class="gi">+                    self.add_message(&#39;modified-iterating-dict&#39;, node=assign_node, args=iter_obj.name)</span>
<span class="gi">+                elif isinstance(iter_obj, nodes.List):</span>
<span class="gi">+                    self.add_message(&#39;modified-iterating-list&#39;, node=assign_node, args=iter_obj.name)</span>
<span class="gh">diff --git a/pylint/checkers/nested_min_max.py b/pylint/checkers/nested_min_max.py</span>
<span class="gh">index 043bee27a..cf882da99 100644</span>
<span class="gd">--- a/pylint/checkers/nested_min_max.py</span>
<span class="gi">+++ b/pylint/checkers/nested_min_max.py</span>
<span class="gu">@@ -32,4 +32,12 @@ class NestedMinMaxChecker(BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns true if expression under min/max could be converted to splat
<span class="w"> </span>        expression.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(arg, nodes.Call):</span>
<span class="gi">+            inferred = safe_infer(arg.func)</span>
<span class="gi">+            if isinstance(inferred, nodes.FunctionDef):</span>
<span class="gi">+                return inferred.qname() in self.FUNC_NAMES</span>
<span class="gi">+        elif isinstance(arg, (nodes.List, nodes.Tuple, nodes.Set)):</span>
<span class="gi">+            return True</span>
<span class="gi">+        elif isinstance(arg, DICT_TYPES):</span>
<span class="gi">+            return PY39_PLUS</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/pylint/checkers/newstyle.py b/pylint/checkers/newstyle.py</span>
<span class="gh">index c0588ddc5..8a0f47a3a 100644</span>
<span class="gd">--- a/pylint/checkers/newstyle.py</span>
<span class="gi">+++ b/pylint/checkers/newstyle.py</span>
<span class="gu">@@ -28,5 +28,23 @@ class NewStyleConflictChecker(BaseChecker):</span>
<span class="w"> </span>    @only_required_for_messages(&#39;bad-super-call&#39;)
<span class="w"> </span>    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check use of super.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.is_method():</span>
<span class="gi">+            klass = node_frame_class(node)</span>
<span class="gi">+            for stmt in node.body:</span>
<span class="gi">+                if isinstance(stmt, nodes.Expr):</span>
<span class="gi">+                    call = stmt.value</span>
<span class="gi">+                    if isinstance(call, nodes.Call) and isinstance(call.func, nodes.Name):</span>
<span class="gi">+                        if call.func.name == &#39;super&#39;:</span>
<span class="gi">+                            if not call.args:</span>
<span class="gi">+                                continue</span>
<span class="gi">+</span>
<span class="gi">+                            # Check if the first argument to super() is the current class</span>
<span class="gi">+                            arg = call.args[0]</span>
<span class="gi">+                            if isinstance(arg, nodes.Name):</span>
<span class="gi">+                                if arg.name != klass.name:</span>
<span class="gi">+                                    self.add_message(&#39;bad-super-call&#39;, node=call, args=(arg.name,))</span>
<span class="gi">+                            elif isinstance(arg, nodes.Attribute):</span>
<span class="gi">+                                if arg.attrname != klass.name:</span>
<span class="gi">+                                    self.add_message(&#39;bad-super-call&#39;, node=call, args=(arg.attrname,))</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef
<span class="gh">diff --git a/pylint/checkers/non_ascii_names.py b/pylint/checkers/non_ascii_names.py</span>
<span class="gh">index 3105ba332..a248f9f1b 100644</span>
<span class="gd">--- a/pylint/checkers/non_ascii_names.py</span>
<span class="gi">+++ b/pylint/checkers/non_ascii_names.py</span>
<span class="gu">@@ -34,15 +34,18 @@ class NonAsciiNameChecker(base_checker.BaseChecker):</span>
<span class="w"> </span>    def _check_name(self, node_type: str, name: (str | None), node: nodes.
<span class="w"> </span>        NodeNG) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check whether a name is using non-ASCII characters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name and not name.isascii():</span>
<span class="gi">+            self.add_message(&#39;non-ascii-name&#39;, node=node, args=(node_type, name))</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="w"> </span>    @utils.only_required_for_messages(&#39;non-ascii-name&#39;)
<span class="w"> </span>    def visit_assignname(self, node: nodes.AssignName) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check module level assigned names.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.parent, nodes.AssignAttr):</span>
<span class="gi">+            self._check_name(&#39;Variable&#39;, node.name, node)</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;non-ascii-name&#39;)
<span class="w"> </span>    def visit_call(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if the used keyword args are correct.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for keyword in node.keywords:</span>
<span class="gi">+            self._check_name(&#39;Keyword argument&#39;, keyword.arg, keyword)</span>
<span class="gh">diff --git a/pylint/checkers/raw_metrics.py b/pylint/checkers/raw_metrics.py</span>
<span class="gh">index 205644431..134096696 100644</span>
<span class="gd">--- a/pylint/checkers/raw_metrics.py</span>
<span class="gi">+++ b/pylint/checkers/raw_metrics.py</span>
<span class="gu">@@ -11,7 +11,23 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>def report_raw_stats(sect: Section, stats: LinterStats, old_stats: (
<span class="w"> </span>    LinterStats | None)) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Calculate percentage of code / doc / comment / empty.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total_lines = stats.code_lines + stats.docstring_lines + stats.comment_lines + stats.empty_lines</span>
<span class="gi">+    sect.append(Table(children=[</span>
<span class="gi">+        [&quot;type&quot;, &quot;number&quot;, &quot;%&quot;, &quot;previous&quot;, &quot;difference&quot;],</span>
<span class="gi">+        [&quot;code&quot;, stats.code_lines, f&quot;{stats.code_lines / total_lines:.2%}&quot;,</span>
<span class="gi">+         old_stats.code_lines if old_stats else &quot;NC&quot;,</span>
<span class="gi">+         diff_string(old_stats.code_lines if old_stats else 0, stats.code_lines)],</span>
<span class="gi">+        [&quot;docstring&quot;, stats.docstring_lines, f&quot;{stats.docstring_lines / total_lines:.2%}&quot;,</span>
<span class="gi">+         old_stats.docstring_lines if old_stats else &quot;NC&quot;,</span>
<span class="gi">+         diff_string(old_stats.docstring_lines if old_stats else 0, stats.docstring_lines)],</span>
<span class="gi">+        [&quot;comment&quot;, stats.comment_lines, f&quot;{stats.comment_lines / total_lines:.2%}&quot;,</span>
<span class="gi">+         old_stats.comment_lines if old_stats else &quot;NC&quot;,</span>
<span class="gi">+         diff_string(old_stats.comment_lines if old_stats else 0, stats.comment_lines)],</span>
<span class="gi">+        [&quot;empty&quot;, stats.empty_lines, f&quot;{stats.empty_lines / total_lines:.2%}&quot;,</span>
<span class="gi">+         old_stats.empty_lines if old_stats else &quot;NC&quot;,</span>
<span class="gi">+         diff_string(old_stats.empty_lines if old_stats else 0, stats.empty_lines)],</span>
<span class="gi">+    ]))</span>
<span class="gi">+    sect.append(Paragraph([Text(f&quot;Total lines: {total_lines}&quot;)]))</span>


<span class="w"> </span>class RawMetricsChecker(BaseTokenChecker):
<span class="gu">@@ -31,11 +47,23 @@ class RawMetricsChecker(BaseTokenChecker):</span>

<span class="w"> </span>    def open(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Init statistics.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.stats = LinterStats()</span>
<span class="gi">+        self.stats.reset_code_type_count()</span>

<span class="w"> </span>    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Update stats.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for index, token in enumerate(tokens):</span>
<span class="gi">+            if token.type == tokenize.NEWLINE:</span>
<span class="gi">+                self.stats.total_lines += 1</span>
<span class="gi">+                _, _, line_type = get_type(tokens, index)</span>
<span class="gi">+                if line_type == &#39;code&#39;:</span>
<span class="gi">+                    self.stats.code_lines += 1</span>
<span class="gi">+                elif line_type == &#39;docstring&#39;:</span>
<span class="gi">+                    self.stats.docstring_lines += 1</span>
<span class="gi">+                elif line_type == &#39;comment&#39;:</span>
<span class="gi">+                    self.stats.comment_lines += 1</span>
<span class="gi">+                elif line_type == &#39;empty&#39;:</span>
<span class="gi">+                    self.stats.empty_lines += 1</span>


<span class="w"> </span>JUNK = tokenize.NL, tokenize.INDENT, tokenize.NEWLINE, tokenize.ENDMARKER
<span class="gu">@@ -44,4 +72,16 @@ JUNK = tokenize.NL, tokenize.INDENT, tokenize.NEWLINE, tokenize.ENDMARKER</span>
<span class="w"> </span>def get_type(tokens: list[tokenize.TokenInfo], start_index: int) -&gt;tuple[
<span class="w"> </span>    int, int, Literal[&#39;code&#39;, &#39;docstring&#39;, &#39;comment&#39;, &#39;empty&#39;]]:
<span class="w"> </span>    &quot;&quot;&quot;Return the line type : docstring, comment, code, empty.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    i = start_index</span>
<span class="gi">+    while i &gt;= 0 and tokens[i].type in JUNK:</span>
<span class="gi">+        i -= 1</span>
<span class="gi">+    if i &lt; 0:</span>
<span class="gi">+        return 0, 0, &#39;empty&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    tok = tokens[i]</span>
<span class="gi">+    if tok.type == tokenize.STRING:</span>
<span class="gi">+        return tok.start[0], tok.end[0], &#39;docstring&#39;</span>
<span class="gi">+    if tok.type == tokenize.COMMENT:</span>
<span class="gi">+        return tok.start[0], tok.end[0], &#39;comment&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    return tok.start[0], tok.end[0], &#39;code&#39;</span>
<span class="gh">diff --git a/pylint/checkers/refactoring/implicit_booleaness_checker.py b/pylint/checkers/refactoring/implicit_booleaness_checker.py</span>
<span class="gh">index b7c28e71f..4d8e54c79 100644</span>
<span class="gd">--- a/pylint/checkers/refactoring/implicit_booleaness_checker.py</span>
<span class="gi">+++ b/pylint/checkers/refactoring/implicit_booleaness_checker.py</span>
<span class="gu">@@ -73,17 +73,48 @@ class ImplicitBooleanessChecker(checkers.BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;`not len(S)` must become `not S` regardless if the parent block is a test
<span class="w"> </span>        condition or something else (boolean expression) e.g. `if not len(S):`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, nodes.UnaryOp) and node.op == &#39;not&#39;:</span>
<span class="gi">+            operand = node.operand</span>
<span class="gi">+            if isinstance(operand, nodes.Call) and isinstance(operand.func, nodes.Name):</span>
<span class="gi">+                if operand.func.name == &#39;len&#39; and len(operand.args) == 1:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &#39;use-implicit-booleaness-not-len&#39;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        confidence=INFERENCE,</span>
<span class="gi">+                    )</span>

<span class="w"> </span>    def _check_use_implicit_booleaness_not_comparison(self, node: nodes.Compare
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check for left side and right side of the node for empty literals.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(node.ops) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        operator, right = node.ops[0]</span>
<span class="gi">+        if operator not in self._operators:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        left = node.left</span>
<span class="gi">+        empty_literals = (nodes.List, nodes.Tuple, nodes.Dict)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(left, empty_literals) and not left.elts:</span>
<span class="gi">+            message_args = self._implicit_booleaness_message_args(left, operator, right)</span>
<span class="gi">+            self.add_message(&#39;use-implicit-booleaness-not-comparison&#39;, node=node, args=message_args)</span>
<span class="gi">+        elif isinstance(right, empty_literals) and not right.elts:</span>
<span class="gi">+            message_args = self._implicit_booleaness_message_args(right, operator, left)</span>
<span class="gi">+            self.add_message(&#39;use-implicit-booleaness-not-comparison&#39;, node=node, args=message_args)</span>

<span class="w"> </span>    def _implicit_booleaness_message_args(self, literal_node: nodes.NodeNG,
<span class="w"> </span>        operator: str, target_node: nodes.NodeNG) -&gt;tuple[str, str, str]:
<span class="w"> </span>        &quot;&quot;&quot;Helper to get the right message for &quot;use-implicit-booleaness-not-comparison&quot;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        literal_type = type(literal_node).__name__.lower()</span>
<span class="gi">+        original = f&quot;{target_node.as_string()} {operator} {literal_node.as_string()}&quot;</span>
<span class="gi">+        </span>
<span class="gi">+        if operator in (&#39;==&#39;, &#39;is&#39;):</span>
<span class="gi">+            suggestion = f&quot;not {target_node.as_string()}&quot;</span>
<span class="gi">+        else:  # operator in (&#39;!=&#39;, &#39;is not&#39;)</span>
<span class="gi">+            suggestion = f&quot;{target_node.as_string()}&quot;</span>
<span class="gi">+        </span>
<span class="gi">+        return original, suggestion, literal_type</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def base_names_of_instance(node: (util.UninferableBase | bases.Instance)
<span class="gu">@@ -93,4 +124,14 @@ class ImplicitBooleanessChecker(checkers.BaseChecker):</span>

<span class="w"> </span>        The inherited names include &#39;object&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, util.UninferableBase):</span>
<span class="gi">+            return []</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            class_node = node._proxied</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return []</span>
<span class="gi">+        </span>
<span class="gi">+        return [</span>
<span class="gi">+            base.name for base in itertools.chain([class_node], class_node.ancestors())</span>
<span class="gi">+        ]</span>
<span class="gh">diff --git a/pylint/checkers/refactoring/recommendation_checker.py b/pylint/checkers/refactoring/recommendation_checker.py</span>
<span class="gh">index 187ef26fc..61cce4b39 100644</span>
<span class="gd">--- a/pylint/checkers/refactoring/recommendation_checker.py</span>
<span class="gi">+++ b/pylint/checkers/refactoring/recommendation_checker.py</span>
<span class="gu">@@ -34,20 +34,49 @@ class RecommendationChecker(checkers.BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add message when accessing first or last elements of a str.split() or
<span class="w"> </span>        str.rsplit().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Attribute) and node.func.attrname in (&#39;split&#39;, &#39;rsplit&#39;):</span>
<span class="gi">+            if len(node.args) == 0 or (len(node.args) == 1 and not isinstance(node.args[0], nodes.Const)):</span>
<span class="gi">+                parent = node.parent</span>
<span class="gi">+                if isinstance(parent, nodes.Subscript):</span>
<span class="gi">+                    if isinstance(parent.slice, nodes.Const):</span>
<span class="gi">+                        index = parent.slice.value</span>
<span class="gi">+                        if index in (0, -1):</span>
<span class="gi">+                            method = &#39;split&#39; if index == 0 else &#39;rsplit&#39;</span>
<span class="gi">+                            suggestion = f&quot;str.{method}(sep, maxsplit=1)[{index}]&quot;</span>
<span class="gi">+                            self.add_message(&#39;use-maxsplit-arg&#39;, node=parent, args=(suggestion,))</span>

<span class="w"> </span>    def _check_consider_using_enumerate(self, node: nodes.For) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Emit a convention whenever range and len are used for indexing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.iter, nodes.Call) and isinstance(node.iter.func, nodes.Name):</span>
<span class="gi">+            if node.iter.func.name == &#39;range&#39;:</span>
<span class="gi">+                if len(node.iter.args) == 1 and isinstance(node.iter.args[0], nodes.Call):</span>
<span class="gi">+                    if isinstance(node.iter.args[0].func, nodes.Name) and node.iter.args[0].func.name == &#39;len&#39;:</span>
<span class="gi">+                        self.add_message(&#39;consider-using-enumerate&#39;, node=node)</span>

<span class="w"> </span>    def _check_consider_using_dict_items(self, node: nodes.For) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add message when accessing dict values by index lookup.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.iter, nodes.Name):</span>
<span class="gi">+            dict_name = node.iter.name</span>
<span class="gi">+            for child in node.body:</span>
<span class="gi">+                if isinstance(child, nodes.Assign):</span>
<span class="gi">+                    if isinstance(child.targets[0], nodes.AssignName) and isinstance(child.value, nodes.Subscript):</span>
<span class="gi">+                        if isinstance(child.value.value, nodes.Name) and child.value.value.name == dict_name:</span>
<span class="gi">+                            self.add_message(&#39;consider-using-dict-items&#39;, node=node)</span>
<span class="gi">+                            break</span>

<span class="w"> </span>    def _check_consider_using_dict_items_comprehension(self, node: nodes.
<span class="w"> </span>        Comprehension) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add message when accessing dict values by index lookup.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.iter, nodes.Name):</span>
<span class="gi">+            dict_name = node.iter.name</span>
<span class="gi">+            parent = node.parent</span>
<span class="gi">+            if isinstance(parent, (nodes.ListComp, nodes.DictComp, nodes.SetComp, nodes.GeneratorExp)):</span>
<span class="gi">+                if isinstance(parent.elt, nodes.Tuple):</span>
<span class="gi">+                    if len(parent.elt.elts) == 2:</span>
<span class="gi">+                        key, value = parent.elt.elts</span>
<span class="gi">+                        if isinstance(value, nodes.Subscript) and isinstance(value.value, nodes.Name):</span>
<span class="gi">+                            if value.value.name == dict_name:</span>
<span class="gi">+                                self.add_message(&#39;consider-using-dict-items&#39;, node=parent)</span>

<span class="w"> </span>    def _check_use_sequence_for_iteration(self, node: (nodes.For | nodes.
<span class="w"> </span>        Comprehension)) -&gt;None:
<span class="gu">@@ -55,10 +84,17 @@ class RecommendationChecker(checkers.BaseChecker):</span>

<span class="w"> </span>        Sets using `*` are not considered in-place.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.iter, nodes.Set):</span>
<span class="gi">+            if not any(isinstance(elt, nodes.Starred) for elt in node.iter.elts):</span>
<span class="gi">+                self.add_message(&#39;use-sequence-for-iteration&#39;, node=node)</span>

<span class="w"> </span>    def _detect_replacable_format_call(self, node: nodes.Const) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check whether a string is used in a call to format() or &#39;%&#39; and whether it
<span class="w"> </span>        can be replaced by an f-string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.parent, nodes.Call):</span>
<span class="gi">+            if isinstance(node.parent.func, nodes.Attribute):</span>
<span class="gi">+                if node.parent.func.attrname == &#39;format&#39;:</span>
<span class="gi">+                    self.add_message(&#39;consider-using-f-string&#39;, node=node)</span>
<span class="gi">+        elif isinstance(node.parent, nodes.BinOp) and node.parent.op == &#39;%&#39;:</span>
<span class="gi">+            self.add_message(&#39;consider-using-f-string&#39;, node=node)</span>
<span class="gh">diff --git a/pylint/checkers/refactoring/refactoring_checker.py b/pylint/checkers/refactoring/refactoring_checker.py</span>
<span class="gh">index bfd096850..21e8ad55a 100644</span>
<span class="gd">--- a/pylint/checkers/refactoring/refactoring_checker.py</span>
<span class="gi">+++ b/pylint/checkers/refactoring/refactoring_checker.py</span>
<span class="gu">@@ -255,7 +255,11 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        Unfortunately we need to know the exact type in certain
<span class="w"> </span>        cases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        if not isinstance(parent, (nodes.If, nodes.Try)):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return (parent.orelse and parent.orelse[0] is node and</span>
<span class="gi">+                parent.lineno == node.lineno)</span>

<span class="w"> </span>    def _check_simplifiable_if(self, node: nodes.If) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if the given if node can be simplified.
<span class="gu">@@ -275,13 +279,34 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>

<span class="w"> </span>    def _check_stop_iteration_inside_generator(self, node: nodes.Raise) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if an exception of type StopIteration is raised inside a generator.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        frame = node.frame()</span>
<span class="gi">+        if not isinstance(frame, nodes.FunctionDef) or not frame.is_generator():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.exc, nodes.Call):</span>
<span class="gi">+            exc = utils.safe_infer(node.exc.func)</span>
<span class="gi">+        else:</span>
<span class="gi">+            exc = utils.safe_infer(node.exc)</span>
<span class="gi">+</span>
<span class="gi">+        if exc and self._check_exception_inherit_from_stopiteration(exc):</span>
<span class="gi">+            self.add_message(&#39;stop-iteration-return&#39;, node=node)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _check_exception_inherit_from_stopiteration(exc: (nodes.ClassDef |
<span class="w"> </span>        bases.Instance)) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Return True if the exception node in argument inherit from StopIteration.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(exc, nodes.ClassDef):</span>
<span class="gi">+            return any(</span>
<span class="gi">+                base.name == &#39;StopIteration&#39; or</span>
<span class="gi">+                RefactoringChecker._check_exception_inherit_from_stopiteration(base)</span>
<span class="gi">+                for base in exc.bases</span>
<span class="gi">+            )</span>
<span class="gi">+        if isinstance(exc, bases.Instance):</span>
<span class="gi">+            return exc.name == &#39;StopIteration&#39; or any(</span>
<span class="gi">+                RefactoringChecker._check_exception_inherit_from_stopiteration(base)</span>
<span class="gi">+                for base in exc.mro()[1:]</span>
<span class="gi">+            )</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def _check_raising_stopiteration_in_generator_next_call(self, node:
<span class="w"> </span>        nodes.Call) -&gt;None:
<span class="gu">@@ -296,7 +321,19 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>

<span class="w"> </span>    def _check_nested_blocks(self, node: NodesWithNestedBlocks) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Update and check the number of nested blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        nested_blocks = 1</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        while parent and not isinstance(parent, nodes.FunctionDef):</span>
<span class="gi">+            if isinstance(parent, (nodes.If, nodes.While, nodes.For, nodes.Try)):</span>
<span class="gi">+                nested_blocks += 1</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+</span>
<span class="gi">+        if nested_blocks &gt; self.linter.config.max_nested_blocks:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &#39;too-many-nested-blocks&#39;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(nested_blocks, self.linter.config.max_nested_blocks),</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _duplicated_isinstance_types(node: nodes.BoolOp) -&gt;dict[str, set[str]]:
<span class="gu">@@ -307,7 +344,30 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>                  to duplicate values from consecutive calls.
<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        duplicated_types = {}</span>
<span class="gi">+        all_types = set()</span>
<span class="gi">+</span>
<span class="gi">+        for call in node.values:</span>
<span class="gi">+            if not isinstance(call, nodes.Call) or not call.func or not isinstance(call.func, nodes.Name):</span>
<span class="gi">+                continue</span>
<span class="gi">+            </span>
<span class="gi">+            if call.func.name != &#39;isinstance&#39;:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if len(call.args) != 2:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            obj = call.args[0].as_string()</span>
<span class="gi">+            if isinstance(call.args[1], nodes.Tuple):</span>
<span class="gi">+                types = {arg.as_string() for arg in call.args[1].elts}</span>
<span class="gi">+            else:</span>
<span class="gi">+                types = {call.args[1].as_string()}</span>
<span class="gi">+</span>
<span class="gi">+            duplicated_types.setdefault(obj, set())</span>
<span class="gi">+            duplicated_types[obj].update(all_types.intersection(types))</span>
<span class="gi">+            all_types.update(types)</span>
<span class="gi">+</span>
<span class="gi">+        return {key: value for key, value in duplicated_types.items() if value}</span>

<span class="w"> </span>    def _check_consider_merging_isinstance(self, node: nodes.BoolOp) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check isinstance calls which can be merged together.&quot;&quot;&quot;
<span class="gu">@@ -335,7 +395,15 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        2) False values in OR expressions are only relevant if all values are
<span class="w"> </span>           false, and the reverse for AND
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if operator == &#39;or&#39;:</span>
<span class="gi">+            if any(isinstance(value, nodes.Const) and value.value is True for value in values):</span>
<span class="gi">+                return [nodes.Const(True)]</span>
<span class="gi">+            return [value for value in values if not (isinstance(value, nodes.Const) and value.value is False)]</span>
<span class="gi">+        elif operator == &#39;and&#39;:</span>
<span class="gi">+            if any(isinstance(value, nodes.Const) and value.value is False for value in values):</span>
<span class="gi">+                return [nodes.Const(False)]</span>
<span class="gi">+            return [value for value in values if not (isinstance(value, nodes.Const) and value.value is True)]</span>
<span class="gi">+        return values</span>

<span class="w"> </span>    def _simplify_boolean_operation(self, bool_op: nodes.BoolOp
<span class="w"> </span>        ) -&gt;nodes.BoolOp:
<span class="gu">@@ -365,11 +433,31 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _dict_literal_suggestion(node: nodes.Call) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return a suggestion of reasonable length.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not node.args:</span>
<span class="gi">+            return &#39;{}&#39;</span>
<span class="gi">+        if len(node.args) == 1 and isinstance(node.args[0], nodes.Dict):</span>
<span class="gi">+            items = node.args[0].items</span>
<span class="gi">+            if len(items) &lt;= 3:</span>
<span class="gi">+                return &#39;{&#39; + &#39;, &#39;.join(f&#39;{k.as_string()}: {v.as_string()}&#39; for k, v in items) + &#39;}&#39;</span>
<span class="gi">+            return &#39;{...}&#39;  # for longer dicts</span>
<span class="gi">+        return &#39;{...}&#39;  # for other cases</span>

<span class="w"> </span>    def _name_to_concatenate(self, node: nodes.NodeNG) -&gt;(str | None):
<span class="w"> </span>        &quot;&quot;&quot;Try to extract the name used in a concatenation loop.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, nodes.Name):</span>
<span class="gi">+            return node.name</span>
<span class="gi">+        if isinstance(node, nodes.Subscript):</span>
<span class="gi">+            return self._name_to_concatenate(node.value)</span>
<span class="gi">+        if isinstance(node, nodes.Attribute):</span>
<span class="gi">+            names = []</span>
<span class="gi">+            current = node</span>
<span class="gi">+            while isinstance(current, nodes.Attribute):</span>
<span class="gi">+                names.append(current.attrname)</span>
<span class="gi">+                current = current.expr</span>
<span class="gi">+            if isinstance(current, nodes.Name):</span>
<span class="gi">+                names.append(current.name)</span>
<span class="gi">+                return &#39;.&#39;.join(reversed(names))</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def _check_consider_using_join(self, aug_assign: nodes.AugAssign) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;We start with the augmented assignment and work our way upwards.
<span class="gu">@@ -437,7 +525,11 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _has_return_in_siblings(node: nodes.NodeNG) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Returns True if there is at least one return in the node&#39;s siblings.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        siblings = node.parent.get_children()</span>
<span class="gi">+        return any(</span>
<span class="gi">+            isinstance(sibling, nodes.Return)</span>
<span class="gi">+            for sibling in itertools.dropwhile(lambda n: n != node, siblings)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _is_function_def_never_returning(self, node: (nodes.FunctionDef |
<span class="w"> </span>        astroid.BoundMethod)) -&gt;bool:
<span class="gh">diff --git a/pylint/checkers/similar.py b/pylint/checkers/similar.py</span>
<span class="gh">index b85648de9..2d2c6576c 100644</span>
<span class="gd">--- a/pylint/checkers/similar.py</span>
<span class="gi">+++ b/pylint/checkers/similar.py</span>
<span class="gu">@@ -164,7 +164,19 @@ def hash_lineset(lineset: LineSet, min_common_lines: int=</span>
<span class="w"> </span>    :return: a dict linking hashes to corresponding start index and a dict that links this
<span class="w"> </span>             index to the start and end lines in the file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hash_to_index = defaultdict(list)</span>
<span class="gi">+    index_to_lines = {}</span>
<span class="gi">+    </span>
<span class="gi">+    for i in range(len(lineset) - min_common_lines + 1):</span>
<span class="gi">+        lines = [lineset[j].text for j in range(i, i + min_common_lines)]</span>
<span class="gi">+        chunk = LinesChunk(lineset.name, i, *lines)</span>
<span class="gi">+        hash_to_index[chunk].append(Index(i))</span>
<span class="gi">+        index_to_lines[Index(i)] = SuccessiveLinesLimits(</span>
<span class="gi">+            LineNumber(lineset[i].line_number),</span>
<span class="gi">+            LineNumber(lineset[i + min_common_lines - 1].line_number)</span>
<span class="gi">+        )</span>
<span class="gi">+    </span>
<span class="gi">+    return hash_to_index, index_to_lines</span>


<span class="w"> </span>def remove_successive(all_couples: CplIndexToCplLines_T) -&gt;None:
<span class="gu">@@ -192,7 +204,17 @@ def remove_successive(all_couples: CplIndexToCplLines_T) -&gt;None:</span>
<span class="w"> </span>    {(11, 34): ([5, 10], [27, 32]),
<span class="w"> </span>     (23, 79): ([15, 19], [45, 49])}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    keys = sorted(all_couples.keys())</span>
<span class="gi">+    for i in range(len(keys) - 1):</span>
<span class="gi">+        current_key, next_key = keys[i], keys[i + 1]</span>
<span class="gi">+        if (current_key[0] + 1 == next_key[0] and</span>
<span class="gi">+            current_key[1] + 1 == next_key[1]):</span>
<span class="gi">+            current_value = all_couples[current_key]</span>
<span class="gi">+            next_value = all_couples[next_key]</span>
<span class="gi">+            current_value.first_file._end = next_value.first_file._end</span>
<span class="gi">+            current_value.second_file._end = next_value.second_file._end</span>
<span class="gi">+            current_value.effective_cmn_lines_nb += next_value.effective_cmn_lines_nb - 1</span>
<span class="gi">+            del all_couples[next_key]</span>


<span class="w"> </span>def filter_noncode_lines(ls_1: LineSet, stindex_1: Index, ls_2: LineSet,
<span class="gu">@@ -211,7 +233,13 @@ def filter_noncode_lines(ls_1: LineSet, stindex_1: Index, ls_2: LineSet,</span>
<span class="w"> </span>    :param common_lines_nb: number of common successive stripped lines before being filtered from non code lines
<span class="w"> </span>    :return: the number of common successive stripped lines that contain code
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    effective_common_lines = 0</span>
<span class="gi">+    for i in range(common_lines_nb):</span>
<span class="gi">+        line1 = ls_1[stindex_1 + i].text</span>
<span class="gi">+        line2 = ls_2[stindex_2 + i].text</span>
<span class="gi">+        if REGEX_FOR_LINES_WITH_CONTENT.match(line1) and REGEX_FOR_LINES_WITH_CONTENT.match(line2):</span>
<span class="gi">+            effective_common_lines += 1</span>
<span class="gi">+    return effective_common_lines</span>


<span class="w"> </span>class Commonality(NamedTuple):
<span class="gh">diff --git a/pylint/checkers/spelling.py b/pylint/checkers/spelling.py</span>
<span class="gh">index 110818045..eab3c1efe 100644</span>
<span class="gd">--- a/pylint/checkers/spelling.py</span>
<span class="gi">+++ b/pylint/checkers/spelling.py</span>
<span class="gu">@@ -98,7 +98,7 @@ def _strip_code_flanked_in_backticks(line: str) -&gt;str:</span>
<span class="w"> </span>    Pyenchant automatically strips back-ticks when parsing tokens,
<span class="w"> </span>    so this cannot be done at the individual filter level.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return CODE_FLANKED_IN_BACKTICK_REGEX.sub(r&#39;\1\5&#39;, line)</span>


<span class="w"> </span>class SpellingChecker(BaseTokenChecker):
<span class="gu">@@ -143,4 +143,17 @@ Did you mean: &#39;%s&#39;?&quot;&quot;&quot;</span>
<span class="w"> </span>    def _check_docstring(self, node: (nodes.FunctionDef | nodes.
<span class="w"> </span>        AsyncFunctionDef | nodes.ClassDef | nodes.Module)) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if the node has any spelling errors.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not node.doc:</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        for lineno, line in enumerate(node.doc.splitlines(), node.lineno):</span>
<span class="gi">+            stripped_line = _strip_code_flanked_in_backticks(line)</span>
<span class="gi">+            for word, pos in self.tokenize_string(stripped_line):</span>
<span class="gi">+                if not self.check_spelling(word):</span>
<span class="gi">+                    suggestions = self.spelling_dict.suggest(word)[:self.max_spelling_suggestions]</span>
<span class="gi">+                    misspelled = line[pos:pos+len(word)]</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &#39;wrong-spelling-in-docstring&#39;,</span>
<span class="gi">+                        args=(misspelled, line, &#39; &#39; * pos + &#39;^&#39;, &#39; or &#39;.join(suggestions)),</span>
<span class="gi">+                        line=lineno</span>
<span class="gi">+                    )</span>
<span class="gh">diff --git a/pylint/checkers/stdlib.py b/pylint/checkers/stdlib.py</span>
<span class="gh">index 0baac8efa..1650d33df 100644</span>
<span class="gd">--- a/pylint/checkers/stdlib.py</span>
<span class="gi">+++ b/pylint/checkers/stdlib.py</span>
<span class="gu">@@ -248,17 +248,62 @@ class StdlibChecker(DeprecatedMixin, BaseChecker):</span>
<span class="w"> </span>        &#39;forgotten-debug-statement&#39;)
<span class="w"> </span>    def visit_call(self, node: nodes.Call) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit a Call node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+            self._check_deprecated_method(node)</span>
<span class="gi">+            self._check_subprocess_run(node)</span>
<span class="gi">+            self._check_subprocess_popen(node)</span>
<span class="gi">+            self._check_shallow_copy_environ(node)</span>
<span class="gi">+        elif isinstance(node.func, nodes.Name):</span>
<span class="gi">+            self._check_open_call(node, &quot;&quot;, node.func.name)</span>
<span class="gi">+            self._check_bad_thread_instantiation(node)</span>
<span class="gi">+            self._check_env_function(node)</span>
<span class="gi">+            self._check_forgotten_debug_statement(node)</span>
<span class="gi">+        self._check_deprecated_argument(node)</span>
<span class="gi">+        self._check_redundant_assert(node)</span>
<span class="gi">+        self._check_datetime(node)</span>

<span class="w"> </span>    def _check_lru_cache_decorators(self, node: nodes.FunctionDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if instance methods are decorated with functools.lru_cache.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not node.decorators:</span>
<span class="gi">+            return</span>
<span class="gi">+        for decorator in node.decorators.nodes:</span>
<span class="gi">+            if isinstance(decorator, nodes.Call):</span>
<span class="gi">+                if isinstance(decorator.func, nodes.Name) and decorator.func.name in LRU_CACHE:</span>
<span class="gi">+                    self.add_message(&#39;method-cache-max-size-none&#39;, node=node)</span>
<span class="gi">+            elif isinstance(decorator, nodes.Name) and decorator.name in LRU_CACHE:</span>
<span class="gi">+                self.add_message(&#39;method-cache-max-size-none&#39;, node=node)</span>

<span class="w"> </span>    def _check_datetime(self, node: nodes.NodeNG) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check that a datetime was inferred, if so, emit boolean-datetime warning.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            inferred = next(node.infer())</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+        if (isinstance(inferred, nodes.Instance) and</span>
<span class="gi">+            inferred.qname() == &#39;datetime.time&#39; and</span>
<span class="gi">+            isinstance(node.parent, (nodes.If, nodes.IfExp, nodes.BoolOp))):</span>
<span class="gi">+            self.add_message(&#39;boolean-datetime&#39;, node=node)</span>

<span class="w"> </span>    def _check_open_call(self, node: nodes.Call, open_module: str,
<span class="w"> </span>        func_name: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Various checks for an open call.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if func_name not in OPEN_FILES_FUNCS:</span>
<span class="gi">+            return</span>
<span class="gi">+        if node.keywords:</span>
<span class="gi">+            kwargs = {keyword.arg: keyword.value for keyword in node.keywords}</span>
<span class="gi">+            if &#39;encoding&#39; not in kwargs and open_module not in OPEN_MODULE:</span>
<span class="gi">+                self.add_message(&#39;unspecified-encoding&#39;, node=node)</span>
<span class="gi">+        elif len(node.args) &lt; 3 and open_module not in OPEN_MODULE:</span>
<span class="gi">+            self.add_message(&#39;unspecified-encoding&#39;, node=node)</span>
<span class="gi">+        </span>
<span class="gi">+        if not node.args:</span>
<span class="gi">+            return</span>
<span class="gi">+        mode = node.args[1] if len(node.args) &gt;= 2 else None</span>
<span class="gi">+        if not mode:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(mode, nodes.Const) or not isinstance(mode.value, str):</span>
<span class="gi">+            return</span>
<span class="gi">+        mode_value = mode.value</span>
<span class="gi">+        if mode_value not in (&#39;r&#39;, &#39;w&#39;, &#39;a&#39;, &#39;x&#39;, &#39;r+&#39;, &#39;w+&#39;, &#39;a+&#39;, &#39;x+&#39;,</span>
<span class="gi">+                              &#39;rb&#39;, &#39;wb&#39;, &#39;ab&#39;, &#39;xb&#39;, &#39;r+b&#39;, &#39;w+b&#39;, &#39;a+b&#39;, &#39;x+b&#39;):</span>
<span class="gi">+            self.add_message(&#39;bad-open-mode&#39;, node=node, args=(mode_value,))</span>
<span class="gh">diff --git a/pylint/checkers/strings.py b/pylint/checkers/strings.py</span>
<span class="gh">index bb0cd648f..a47c4280b 100644</span>
<span class="gd">--- a/pylint/checkers/strings.py</span>
<span class="gi">+++ b/pylint/checkers/strings.py</span>
<span class="gu">@@ -98,7 +98,13 @@ def get_access_path(key: (str | Literal[0]), parts: list[tuple[bool, str]]</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a list of format specifiers, returns
<span class="w"> </span>    the final access path (e.g. a.b.c[0][1]).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = str(key)</span>
<span class="gi">+    for is_attribute, part in parts:</span>
<span class="gi">+        if is_attribute:</span>
<span class="gi">+            path += f&quot;.{part}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            path += f&quot;[{part}]&quot;</span>
<span class="gi">+    return path</span>


<span class="w"> </span>class StringFormatChecker(BaseChecker):
<span class="gu">@@ -111,7 +117,35 @@ class StringFormatChecker(BaseChecker):</span>
<span class="w"> </span>    def _check_new_format(self, node: nodes.Call, func: bases.BoundMethod
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check the new string formatting.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+            format_string = node.func.expr</span>
<span class="gi">+        else:</span>
<span class="gi">+            format_string = node.args[0]</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(format_string, nodes.Const):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            fields, num_args, manual_pos = utils.parse_format_string(format_string.value)</span>
<span class="gi">+        except utils.IncompleteFormatString:</span>
<span class="gi">+            self.add_message(&#39;bad-format-string&#39;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        named = {}</span>
<span class="gi">+        for name, nested, pos in fields:</span>
<span class="gi">+            if name is not None:</span>
<span class="gi">+                named[name] = nested</span>
<span class="gi">+</span>
<span class="gi">+        if num_args and manual_pos:</span>
<span class="gi">+            self.add_message(&#39;format-combined-specification&#39;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        args = node.args[1:]</span>
<span class="gi">+        if isinstance(func, nodes.Attribute) and args:</span>
<span class="gi">+            args = args[1:]</span>
<span class="gi">+</span>
<span class="gi">+        if named:</span>
<span class="gi">+            self._check_new_format_specifiers(node, fields, named)</span>

<span class="w"> </span>    def _check_new_format_specifiers(self, node: nodes.Call, fields: list[
<span class="w"> </span>        tuple[str, list[tuple[bool, str]]]], named: dict[str,
<span class="gu">@@ -119,7 +153,42 @@ class StringFormatChecker(BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;Check attribute and index access in the format
<span class="w"> </span>        string (&quot;{0.a}&quot; and &quot;{0[a]}&quot;).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key, parts in fields:</span>
<span class="gi">+            if key is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not parts:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                arg = named[key]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not hasattr(arg, &#39;value&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            previous = arg.value</span>
<span class="gi">+            for is_attribute, attr in parts:</span>
<span class="gi">+                if is_attribute:</span>
<span class="gi">+                    if not hasattr(previous, attr):</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &#39;missing-format-attribute&#39;,</span>
<span class="gi">+                            node=node,</span>
<span class="gi">+                            args=(attr, get_access_path(key, parts))</span>
<span class="gi">+                        )</span>
<span class="gi">+                        break</span>
<span class="gi">+                    previous = getattr(previous, attr)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        previous = previous[attr]</span>
<span class="gi">+                    except (TypeError, KeyError):</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &#39;invalid-format-index&#39;,</span>
<span class="gi">+                            node=node,</span>
<span class="gi">+                            args=(attr, get_access_path(key, parts))</span>
<span class="gi">+                        )</span>
<span class="gi">+                        break</span>


<span class="w"> </span>class StringConstantChecker(BaseTokenChecker, BaseRawFileChecker):
<span class="gu">@@ -174,7 +243,23 @@ class StringConstantChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          tokens: The tokens to be checked against for consistent usage.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        string_tokens = [t for t in tokens if t.type == tokenize.STRING]</span>
<span class="gi">+        if not string_tokens:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        quote_delimiter = _get_quote_delimiter(string_tokens[0].string)</span>
<span class="gi">+        for token in string_tokens[1:]:</span>
<span class="gi">+            if _is_long_string(token.string):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            current_delimiter = _get_quote_delimiter(token.string)</span>
<span class="gi">+            if current_delimiter != quote_delimiter:</span>
<span class="gi">+                if _is_quote_delimiter_chosen_freely(token.string):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &#39;inconsistent-quotes&#39;,</span>
<span class="gi">+                        line=token.start[0],</span>
<span class="gi">+                        args=(current_delimiter,)</span>
<span class="gi">+                    )</span>

<span class="w"> </span>    def process_non_raw_string_token(self, prefix: str, string_body: str,
<span class="w"> </span>        start_row: int, string_start_col: int) -&gt;None:
<span class="gu">@@ -186,11 +271,28 @@ class StringConstantChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>        start_row: line number in the source.
<span class="w"> </span>        string_start_col: col number of the string start in the source.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for match in re.finditer(r&#39;[^\\]\\(?P&lt;char&gt;.)&#39;, string_body):</span>
<span class="gi">+            char = match.group(&#39;char&#39;)</span>
<span class="gi">+            if char not in self.ESCAPE_CHARACTERS:</span>
<span class="gi">+                col_offset = string_start_col + match.start() + 1</span>
<span class="gi">+                if &#39;u&#39; in prefix:</span>
<span class="gi">+                    if char not in self.UNICODE_ESCAPE_CHARACTERS:</span>
<span class="gi">+                        self.add_message(&#39;anomalous-unicode-escape-in-string&#39;,</span>
<span class="gi">+                                         line=start_row,</span>
<span class="gi">+                                         args=(char,),</span>
<span class="gi">+                                         col_offset=col_offset)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_message(&#39;anomalous-backslash-in-string&#39;,</span>
<span class="gi">+                                     line=start_row,</span>
<span class="gi">+                                     args=(char,),</span>
<span class="gi">+                                     col_offset=col_offset)</span>

<span class="w"> </span>    def _detect_u_string_prefix(self, node: nodes.Const) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check whether strings include a &#39;u&#39; prefix like u&#39;String&#39;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.value, str) and node.raw_string:</span>
<span class="gi">+            prefix = node.raw_string.split(&quot;&#39;&quot;)[0].lower()</span>
<span class="gi">+            if &#39;u&#39; in prefix:</span>
<span class="gi">+                self.add_message(&#39;redundant-u-string-prefix&#39;, node=node)</span>


<span class="w"> </span>def str_eval(token: str) -&gt;str:
<span class="gu">@@ -200,7 +302,31 @@ def str_eval(token: str) -&gt;str:</span>
<span class="w"> </span>    We have to support all string literal notations:
<span class="w"> </span>    https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if token.startswith((&#39;f&#39;, &#39;F&#39;)):</span>
<span class="gi">+        # For f-strings, we can&#39;t evaluate them, so we return the raw string</span>
<span class="gi">+        return token[2:-1] if token[1] in &quot;\&quot;&#39;&quot; else token[1:-1]</span>
<span class="gi">+    </span>
<span class="gi">+    prefix = &#39;&#39;</span>
<span class="gi">+    while token and token[0] in &#39;rRbBuU&#39;:</span>
<span class="gi">+        prefix += token[0].lower()</span>
<span class="gi">+        token = token[1:]</span>
<span class="gi">+</span>
<span class="gi">+    if token.startswith(&quot;&#39;&#39;&#39;&quot;) or token.startswith(&#39;&quot;&quot;&quot;&#39;):</span>
<span class="gi">+        quote = token[:3]</span>
<span class="gi">+        token = token[3:-3]</span>
<span class="gi">+    elif token.startswith(&quot;&#39;&quot;) or token.startswith(&#39;&quot;&#39;):</span>
<span class="gi">+        quote = token[0]</span>
<span class="gi">+        token = token[1:-1]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(&quot;Invalid string token&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;r&#39; in prefix:</span>
<span class="gi">+        return token</span>
<span class="gi">+    </span>
<span class="gi">+    result = token.encode(&#39;ascii&#39;, &#39;backslashreplace&#39;).decode(&#39;unicode-escape&#39;)</span>
<span class="gi">+    if &#39;b&#39; in prefix:</span>
<span class="gi">+        return result.encode(&#39;ascii&#39;)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def _is_long_string(string_token: str) -&gt;bool:
<span class="gu">@@ -220,7 +346,7 @@ def _is_long_string(string_token: str) -&gt;bool:</span>
<span class="w"> </span>        A boolean representing whether this token matches a longstring
<span class="w"> </span>        regex.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bool(SINGLE_QUOTED_REGEX.match(string_token) or DOUBLE_QUOTED_REGEX.match(string_token))</span>


<span class="w"> </span>def _get_quote_delimiter(string_token: str) -&gt;str:
<span class="gu">@@ -238,7 +364,10 @@ def _get_quote_delimiter(string_token: str) -&gt;str:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      ValueError: No quote delimiter characters are present.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = QUOTE_DELIMITER_REGEX.match(string_token)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise ValueError(&quot;No quote delimiter found in string token.&quot;)</span>
<span class="gi">+    return match.group(2)</span>


<span class="w"> </span>def _is_quote_delimiter_chosen_freely(string_token: str) -&gt;bool:
<span class="gu">@@ -253,4 +382,11 @@ def _is_quote_delimiter_chosen_freely(string_token: str) -&gt;bool:</span>
<span class="w"> </span>        strings are excepted from this analysis under the assumption that their
<span class="w"> </span>        quote characters are set by policy.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if _is_long_string(string_token):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    delimiter = _get_quote_delimiter(string_token)</span>
<span class="gi">+    other_delimiter = &#39;&quot;&#39; if delimiter == &quot;&#39;&quot; else &quot;&#39;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Check if the string contains the other delimiter without a backslash before it</span>
<span class="gi">+    return not re.search(r&#39;(?&lt;!\\)&#39; + re.escape(other_delimiter), string_token)</span>
<span class="gh">diff --git a/pylint/checkers/typecheck.py b/pylint/checkers/typecheck.py</span>
<span class="gh">index f7ac53ca5..a39f6d294 100644</span>
<span class="gd">--- a/pylint/checkers/typecheck.py</span>
<span class="gi">+++ b/pylint/checkers/typecheck.py</span>
<span class="gu">@@ -58,7 +58,17 @@ def _is_owner_ignored(owner: SuccessfulInferenceResult, attrname: (str |</span>
<span class="w"> </span>    matches any name from the *ignored_classes* or if its qualified
<span class="w"> </span>    name can be found in *ignored_classes*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(owner, nodes.Module):</span>
<span class="gi">+        return (owner.name in ignored_modules or</span>
<span class="gi">+                owner.qname() in ignored_modules or</span>
<span class="gi">+                any(owner.qname().startswith(mod) for mod in ignored_modules))</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(owner, nodes.ClassDef):</span>
<span class="gi">+        return (owner.name in ignored_classes or</span>
<span class="gi">+                owner.qname() in ignored_classes or</span>
<span class="gi">+                any(owner.qname().startswith(cls) for cls in ignored_classes))</span>
<span class="gi">+    </span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _similar_names(owner: SuccessfulInferenceResult, attrname: (str | None),
<span class="gu">@@ -68,7 +78,25 @@ def _similar_names(owner: SuccessfulInferenceResult, attrname: (str | None),</span>
<span class="w"> </span>    The similar names are searched given a distance metric and only
<span class="w"> </span>    a given number of choices will be returned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from difflib import SequenceMatcher</span>
<span class="gi">+</span>
<span class="gi">+    if attrname is None:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    attributes = owner.getattr(&#39;__dict__&#39;, [])</span>
<span class="gi">+    if not attributes:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    similar_names = []</span>
<span class="gi">+    for attr in attributes:</span>
<span class="gi">+        if not isinstance(attr, nodes.AssignName):</span>
<span class="gi">+            continue</span>
<span class="gi">+        similarity = SequenceMatcher(None, attrname, attr.name).ratio()</span>
<span class="gi">+        if similarity &gt;= distance_threshold:</span>
<span class="gi">+            similar_names.append((similarity, attr.name))</span>
<span class="gi">+</span>
<span class="gi">+    similar_names.sort(reverse=True)</span>
<span class="gi">+    return [name for _, name in similar_names[:max_choices]]</span>


<span class="w"> </span>MSGS: dict[str, MessageDefinitionTuple] = {&#39;E1101&#39;: (
<span class="gu">@@ -186,13 +214,47 @@ def _emit_no_member(node: (nodes.Attribute | nodes.AssignAttr | nodes.</span>
<span class="w"> </span>          AttributeError, Exception or bare except.
<span class="w"> </span>        * The node is guarded behind and `IF` or `IFExp` node
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(owner, astroid.FunctionDef) and owner.decorators:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(owner, astroid.Instance):</span>
<span class="gi">+        if owner.has_dynamic_getattr():</span>
<span class="gi">+            return False</span>
<span class="gi">+        if any(owner.getattr(attr) for attr in (&#39;__getattr__&#39;, &#39;__getattribute__&#39;)):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(owner, astroid.Module) and owner.name in node.root().file_ignored_lines:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(owner, astroid.ClassDef):</span>
<span class="gi">+        metaclass = owner.metaclass()</span>
<span class="gi">+        if metaclass and node.attrname in metaclass.locals:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    if utils.node_ignores_exception(node, AttributeError):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if utils.is_node_in_guarded_import_block(node):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if ignored_mixins and mixin_class_rgx.match(owner_name or &#39;&#39;):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if ignored_none and isinstance(owner, nodes.Const) and owner.value is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def _has_parent_of_type(node: nodes.Call, node_type: (nodes.Keyword | nodes
<span class="w"> </span>    .Starred), statement: _base_nodes.Statement) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if the given node has a parent of the given type.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent = node.parent</span>
<span class="gi">+    while parent and parent != statement:</span>
<span class="gi">+        if isinstance(parent, node_type):</span>
<span class="gi">+            return True</span>
<span class="gi">+        parent = parent.parent</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _no_context_variadic(node: nodes.Call, variadic_name: (str | None),
<span class="gu">@@ -208,7 +270,18 @@ def _no_context_variadic(node: nodes.Call, variadic_name: (str | None),</span>
<span class="w"> </span>    This can lead pylint to believe that a function call receives
<span class="w"> </span>    too few arguments.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not variadic_name:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    for variadic in variadics:</span>
<span class="gi">+        if not isinstance(variadic, variadic_type):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        inferred = safe_infer(variadic.value)</span>
<span class="gi">+        if isinstance(inferred, (astroid.Tuple, astroid.Dict)) and not inferred.elts:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _infer_from_metaclass_constructor(cls: nodes.ClassDef, func: nodes.
<span class="gu">@@ -229,7 +302,17 @@ def _infer_from_metaclass_constructor(cls: nodes.ClassDef, func: nodes.</span>
<span class="w"> </span>        if we couldn&#39;t infer it.
<span class="w"> </span>    :rtype: astroid.ClassDef
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(func.args.args) != 3:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    name = cls.name</span>
<span class="gi">+    bases = [base for base in cls.bases if isinstance(base, nodes.Name)]</span>
<span class="gi">+    attrs = cls.locals</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return next(func.infer_call_result(func, [nodes.Const(name), nodes.List(bases), nodes.Dict(attrs)]))</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class TypeChecker(BaseChecker):
<span class="gh">diff --git a/pylint/checkers/unicode.py b/pylint/checkers/unicode.py</span>
<span class="gh">index b6fd71f21..176b760d7 100644</span>
<span class="gd">--- a/pylint/checkers/unicode.py</span>
<span class="gi">+++ b/pylint/checkers/unicode.py</span>
<span class="gu">@@ -35,11 +35,11 @@ class _BadChar(NamedTuple):</span>

<span class="w"> </span>    def description(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Used for the detailed error message description.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;Found {self.name} character ({self.escaped})&quot;</span>

<span class="w"> </span>    def human_code(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Used to generate the human readable error message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&quot;bad-{self.name}-character&quot;</span>


<span class="w"> </span>BAD_CHARS = [_BadChar(&#39;backspace&#39;, &#39;\x08&#39;, &#39;\\b&#39;, &#39;E2510&#39;,
<span class="gu">@@ -59,7 +59,9 @@ BAD_ASCII_SEARCH_DICT = {char.unescaped: char for char in BAD_CHARS}</span>

<span class="w"> </span>def _line_length(line: _StrLike, codec: str) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Get the length of a string like line as displayed in an editor.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(line, bytes):</span>
<span class="gi">+        return len(line.decode(codec))</span>
<span class="gi">+    return len(line)</span>


<span class="w"> </span>def _map_positions_to_result(line: _StrLike, search_dict: dict[_StrLike,
<span class="gu">@@ -71,7 +73,11 @@ def _map_positions_to_result(line: _StrLike, search_dict: dict[_StrLike,</span>
<span class="w"> </span>    Also takes care of encodings for which the length of an encoded code point does not
<span class="w"> </span>    default to 8 Bit.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for i, char in enumerate(line):</span>
<span class="gi">+        if char in search_dict:</span>
<span class="gi">+            result[i * byte_str_length] = search_dict[char]</span>
<span class="gi">+    return result</span>


<span class="w"> </span>UNICODE_BOMS = {&#39;utf-8&#39;: codecs.BOM_UTF8, &#39;utf-16&#39;: codecs.BOM_UTF16,
<span class="gu">@@ -86,28 +92,40 @@ UTF_NAME_REGEX_COMPILED = re.compile(&#39;utf[ -]?(8|16|32)[ -]?(le|be|)?(sig)?&#39;,</span>

<span class="w"> </span>def _normalize_codec_name(codec: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Make sure the codec name is always given as defined in the BOM dict.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = UTF_NAME_REGEX_COMPILED.match(codec)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        utf, endian, _ = match.groups()</span>
<span class="gi">+        return f&quot;utf-{utf}{endian or &#39;&#39;}&quot;.lower()</span>
<span class="gi">+    return codec.lower()</span>


<span class="w"> </span>def _remove_bom(encoded: bytes, encoding: str) -&gt;bytes:
<span class="w"> </span>    &quot;&quot;&quot;Remove the bom if given from a line.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bom = UNICODE_BOMS.get(_normalize_codec_name(encoding))</span>
<span class="gi">+    if bom and encoded.startswith(bom):</span>
<span class="gi">+        return encoded[len(bom):]</span>
<span class="gi">+    return encoded</span>


<span class="w"> </span>def _encode_without_bom(string: str, encoding: str) -&gt;bytes:
<span class="w"> </span>    &quot;&quot;&quot;Encode a string but remove the BOM.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    encoded = string.encode(encoding)</span>
<span class="gi">+    return _remove_bom(encoded, encoding)</span>


<span class="w"> </span>def _byte_to_str_length(codec: str) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Return how many byte are usually(!) a character point.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if codec.startswith(&#39;utf-16&#39;):</span>
<span class="gi">+        return 2</span>
<span class="gi">+    if codec.startswith(&#39;utf-32&#39;):</span>
<span class="gi">+        return 4</span>
<span class="gi">+    return 1</span>


<span class="w"> </span>@lru_cache(maxsize=1000)
<span class="w"> </span>def _cached_encode_search(string: str, encoding: str) -&gt;bytes:
<span class="w"> </span>    &quot;&quot;&quot;A cached version of encode used for search pattern.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return string.encode(encoding)</span>


<span class="w"> </span>def _fix_utf16_32_line_stream(steam: Iterable[bytes], codec: str) -&gt;Iterable[
<span class="gu">@@ -117,7 +135,11 @@ def _fix_utf16_32_line_stream(steam: Iterable[bytes], codec: str) -&gt;Iterable[</span>
<span class="w"> </span>    Currently, Python simply strips the required zeros after \\n after the
<span class="w"> </span>    line ending. Leading to lines that can&#39;t be decoded properly
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    byte_length = _byte_to_str_length(codec)</span>
<span class="gi">+    for line in steam:</span>
<span class="gi">+        if len(line) % byte_length != 0:</span>
<span class="gi">+            line += b&#39;\x00&#39; * (byte_length - (len(line) % byte_length))</span>
<span class="gi">+        yield line</span>


<span class="w"> </span>def extract_codec_from_bom(first_line: bytes) -&gt;str:
<span class="gu">@@ -134,7 +156,10 @@ def extract_codec_from_bom(first_line: bytes) -&gt;str:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        ValueError: if no codec was found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for bom, codec in BOM_SORTED_TO_CODEC.items():</span>
<span class="gi">+        if first_line.startswith(bom):</span>
<span class="gi">+            return codec</span>
<span class="gi">+    raise ValueError(&quot;No BOM found&quot;)</span>


<span class="w"> </span>class UnicodeChecker(checkers.BaseRawFileChecker):
<span class="gu">@@ -185,7 +210,8 @@ https://trojansource.codes/&quot;&quot;&quot;</span>
<span class="w"> </span>        Return:
<span class="w"> </span>            A dictionary with the column offset and the BadASCIIChar
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        decoded_line = line.decode(codec)</span>
<span class="gi">+        return _map_positions_to_result(decoded_line, BAD_ASCII_SEARCH_DICT, line, _byte_to_str_length(codec))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _determine_codec(stream: io.BytesIO) -&gt;tuple[str, int]:
<span class="gu">@@ -205,21 +231,50 @@ https://trojansource.codes/&quot;&quot;&quot;</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            SyntaxError: if failing to detect codec
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            encoding, lines = detect_encoding(stream.readline)</span>
<span class="gi">+            return _normalize_codec_name(encoding), lines</span>
<span class="gi">+        except SyntaxError:</span>
<span class="gi">+            stream.seek(0)</span>
<span class="gi">+            first_line = stream.readline()</span>
<span class="gi">+            try:</span>
<span class="gi">+                codec = extract_codec_from_bom(first_line)</span>
<span class="gi">+                return _normalize_codec_name(codec), 1</span>
<span class="gi">+            except ValueError as e:</span>
<span class="gi">+                raise SyntaxError(&quot;Unable to determine file encoding&quot;) from e</span>

<span class="w"> </span>    def _check_codec(self, codec: str, codec_definition_line: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check validity of the codec.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if codec.startswith((&#39;utf-16&#39;, &#39;utf-32&#39;)):</span>
<span class="gi">+            self.add_message(&#39;invalid-unicode-codec&#39;, line=codec_definition_line)</span>
<span class="gi">+        elif codec != &#39;utf-8&#39;:</span>
<span class="gi">+            self.add_message(&#39;bad-file-encoding&#39;, line=codec_definition_line)</span>

<span class="w"> </span>    def _check_invalid_chars(self, line: bytes, lineno: int, codec: str
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Look for chars considered bad.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for col, bad_char in self._find_line_matches(line, codec).items():</span>
<span class="gi">+            self.add_message(bad_char.code, line=lineno, col_offset=col, args=(bad_char.escaped,))</span>

<span class="w"> </span>    def _check_bidi_chars(self, line: bytes, lineno: int, codec: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Look for Bidirectional Unicode, if we use unicode.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        decoded_line = line.decode(codec)</span>
<span class="gi">+        for col, char in enumerate(decoded_line):</span>
<span class="gi">+            if char in BIDI_UNICODE:</span>
<span class="gi">+                self.add_message(&#39;bidirectional-unicode&#39;, line=lineno, col_offset=col)</span>

<span class="w"> </span>    def process_module(self, node: nodes.Module) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Perform the actual check by checking module stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with node.stream() as stream:</span>
<span class="gi">+            try:</span>
<span class="gi">+                codec, codec_line = self._determine_codec(stream)</span>
<span class="gi">+            except SyntaxError:</span>
<span class="gi">+                self.add_message(&#39;invalid-unicode-codec&#39;, line=1)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self._check_codec(codec, codec_line)</span>
<span class="gi">+</span>
<span class="gi">+            stream.seek(0)</span>
<span class="gi">+            for lineno, line in enumerate(stream, start=1):</span>
<span class="gi">+                self._check_invalid_chars(line, lineno, codec)</span>
<span class="gi">+                self._check_bidi_chars(line, lineno, codec)</span>
<span class="gh">diff --git a/pylint/checkers/unsupported_version.py b/pylint/checkers/unsupported_version.py</span>
<span class="gh">index 8be4654c4..712b426d4 100644</span>
<span class="gd">--- a/pylint/checkers/unsupported_version.py</span>
<span class="gi">+++ b/pylint/checkers/unsupported_version.py</span>
<span class="gu">@@ -27,20 +27,28 @@ class UnsupportedVersionChecker(BaseChecker):</span>

<span class="w"> </span>    def open(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Initialize visit variables and statistics.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.py_version = self.linter.config.py_version</span>

<span class="w"> </span>    @only_required_for_messages(&#39;using-f-string-in-unsupported-version&#39;)
<span class="w"> </span>    def visit_joinedstr(self, node: nodes.JoinedStr) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check f-strings.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.py_version &lt; (3, 6):</span>
<span class="gi">+            self.add_message(&#39;using-f-string-in-unsupported-version&#39;, node=node)</span>

<span class="w"> </span>    @only_required_for_messages(&#39;using-final-decorator-in-unsupported-version&#39;)
<span class="w"> </span>    def visit_decorators(self, node: nodes.Decorators) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check decorators.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_typing_final(node)</span>

<span class="w"> </span>    def _check_typing_final(self, node: nodes.Decorators) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add a message when the `typing.final` decorator is used and the
<span class="w"> </span>        py-version is lower than 3.8.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.py_version &lt; (3, 8):</span>
<span class="gi">+            for decorator in node.nodes:</span>
<span class="gi">+                if isinstance(decorator, nodes.Name) and decorator.name == &#39;final&#39;:</span>
<span class="gi">+                    self.add_message(&#39;using-final-decorator-in-unsupported-version&#39;, node=decorator)</span>
<span class="gi">+                elif isinstance(decorator, nodes.Attribute) and decorator.attrname == &#39;final&#39;:</span>
<span class="gi">+                    inferred = safe_infer(decorator)</span>
<span class="gi">+                    if inferred and inferred.qname() == &#39;typing.final&#39;:</span>
<span class="gi">+                        self.add_message(&#39;using-final-decorator-in-unsupported-version&#39;, node=decorator)</span>
<span class="gh">diff --git a/pylint/checkers/utils.py b/pylint/checkers/utils.py</span>
<span class="gh">index 83788746a..47259637c 100644</span>
<span class="gd">--- a/pylint/checkers/utils.py</span>
<span class="gi">+++ b/pylint/checkers/utils.py</span>
<span class="gu">@@ -102,17 +102,24 @@ class InferredTypeError(Exception):</span>

<span class="w"> </span>def get_all_elements(node: nodes.NodeNG) -&gt;Iterable[nodes.NodeNG]:
<span class="w"> </span>    &quot;&quot;&quot;Recursively returns all atoms in nested lists and tuples.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, (nodes.List, nodes.Tuple)):</span>
<span class="gi">+        for child in node.elts:</span>
<span class="gi">+            yield from get_all_elements(child)</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield node</span>


<span class="w"> </span>def is_super(node: nodes.NodeNG) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return True if the node is referencing the &quot;super&quot; builtin function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, nodes.Name):</span>
<span class="gi">+        return node.name == &#39;super&#39; and node.root().name == &#39;builtins&#39;</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def is_error(node: nodes.FunctionDef) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if the given function node only raises an exception.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (len(node.body) == 1 and</span>
<span class="gi">+            isinstance(node.body[0], nodes.Raise))</span>


<span class="w"> </span>builtins = builtins.__dict__.copy()
<span class="gu">@@ -121,12 +128,14 @@ SPECIAL_BUILTINS = &#39;__builtins__&#39;,</span>

<span class="w"> </span>def is_builtin_object(node: nodes.NodeNG) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Returns True if the given node is an object from the __builtin__ module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (isinstance(node, nodes.Name) and</span>
<span class="gi">+            node.name in builtins and</span>
<span class="gi">+            node.root().name == &#39;builtins&#39;)</span>


<span class="w"> </span>def is_builtin(name: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Return true if &lt;name&gt; could be considered as a builtin defined by python.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return name in builtins or name in SPECIAL_BUILTINS</span>


<span class="w"> </span>def is_defined_before(var_node: nodes.Name) -&gt;bool:
<span class="gu">@@ -138,7 +147,19 @@ def is_defined_before(var_node: nodes.Name) -&gt;bool:</span>
<span class="w"> </span>    or in a previous sibling node on the same line
<span class="w"> </span>    (statement_defining ; statement_using).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stmt = var_node.statement()</span>
<span class="gi">+    stmt_parent = stmt.parent</span>
<span class="gi">+    for child in stmt_parent.get_children():</span>
<span class="gi">+        if child is stmt:</span>
<span class="gi">+            break</span>
<span class="gi">+        if isinstance(child, (nodes.Assign, nodes.AnnAssign, nodes.With)):</span>
<span class="gi">+            for target in child.targets:</span>
<span class="gi">+                if isinstance(target, nodes.AssignName) and target.name == var_node.name:</span>
<span class="gi">+                    return True</span>
<span class="gi">+        elif isinstance(child, (nodes.ListComp, nodes.SetComp, nodes.DictComp, nodes.GeneratorExp, nodes.Lambda)):</span>
<span class="gi">+            if var_node.name in child.locals:</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def is_default_argument(node: nodes.NodeNG, scope: (nodes.NodeNG | None)=None
<span class="gh">diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py</span>
<span class="gh">index 822aebe55..81379481c 100644</span>
<span class="gd">--- a/pylint/checkers/variables.py</span>
<span class="gi">+++ b/pylint/checkers/variables.py</span>
<span class="gu">@@ -59,7 +59,7 @@ class VariableVisitConsumerAction(Enum):</span>

<span class="w"> </span>def _is_from_future_import(stmt: nodes.ImportFrom, name: str) -&gt;(bool | None):
<span class="w"> </span>    &quot;&quot;&quot;Check if the name is a future import from another module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return stmt.modname == FUTURE and name in stmt.names</span>


<span class="w"> </span>def _get_unpacking_extra_info(node: nodes.Assign, inferred: InferenceResult
<span class="gu">@@ -67,7 +67,14 @@ def _get_unpacking_extra_info(node: nodes.Assign, inferred: InferenceResult</span>
<span class="w"> </span>    &quot;&quot;&quot;Return extra information to add to the message for unpacking-non-sequence
<span class="w"> </span>    and unbalanced-tuple/dict-unpacking errors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    more = &quot;&quot;</span>
<span class="gi">+    if isinstance(inferred, astroid.Instance):</span>
<span class="gi">+        actual_type = inferred._proxied.name</span>
<span class="gi">+        expected_type = &quot;sequence&quot; if isinstance(node.targets[0], nodes.Tuple) else &quot;mapping&quot;</span>
<span class="gi">+        more = f&quot; (type is {actual_type}, expected {expected_type})&quot;</span>
<span class="gi">+    elif isinstance(inferred, astroid.ClassDef):</span>
<span class="gi">+        more = f&quot; (type is {inferred.name})&quot;</span>
<span class="gi">+    return more</span>


<span class="w"> </span>def _detect_global_scope(node: nodes.Name, frame: nodes.LocalsDictNodeNG,
<span class="gu">@@ -94,7 +101,18 @@ def _detect_global_scope(node: nodes.Name, frame: nodes.LocalsDictNodeNG,</span>
<span class="w"> </span>                class B(C): ...
<span class="w"> </span>        class C: ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def_scope = defframe.scope()</span>
<span class="gi">+    frame_scope = frame.scope()</span>
<span class="gi">+    </span>
<span class="gi">+    while def_scope and frame_scope:</span>
<span class="gi">+        if isinstance(def_scope, nodes.FunctionDef) or isinstance(frame_scope, nodes.FunctionDef):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if def_scope == frame_scope:</span>
<span class="gi">+            return True</span>
<span class="gi">+        def_scope = def_scope.parent</span>
<span class="gi">+        frame_scope = frame_scope.parent</span>
<span class="gi">+    </span>
<span class="gi">+    return True</span>


<span class="w"> </span>def _fix_dot_imports(not_consumed: dict[str, list[nodes.NodeNG]]) -&gt;list[tuple
<span class="gu">@@ -106,7 +124,19 @@ def _fix_dot_imports(not_consumed: dict[str, list[nodes.NodeNG]]) -&gt;list[tuple</span>
<span class="w"> </span>    like &#39;xml&#39; (when we have both &#39;xml.etree&#39; and &#39;xml.sax&#39;), to &#39;xml.etree&#39;
<span class="w"> </span>    and &#39;xml.sax&#39; respectively.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def expand_import(name, node):</span>
<span class="gi">+        for child_name, child_node in list(not_consumed.items()):</span>
<span class="gi">+            if child_name.startswith(name + &#39;.&#39;):</span>
<span class="gi">+                # Remove the child from not_consumed</span>
<span class="gi">+                del not_consumed[child_name]</span>
<span class="gi">+                # Expand the name</span>
<span class="gi">+                return child_name, node</span>
<span class="gi">+        return name, node</span>
<span class="gi">+</span>
<span class="gi">+    # Create a new list of expanded imports</span>
<span class="gi">+    expanded_imports = [expand_import(name, nodes[0]) for name, nodes in not_consumed.items()]</span>
<span class="gi">+    </span>
<span class="gi">+    return expanded_imports</span>


<span class="w"> </span>def _find_frame_imports(name: str, frame: nodes.LocalsDictNodeNG) -&gt;bool:
<span class="gu">@@ -115,12 +145,21 @@ def _find_frame_imports(name: str, frame: nodes.LocalsDictNodeNG) -&gt;bool:</span>
<span class="w"> </span>    Such imports can be considered assignments if they are not globals.
<span class="w"> </span>    Returns True if an import for the given name was found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    imports = frame.nodes_of_class((nodes.Import, nodes.ImportFrom))</span>
<span class="gi">+    for import_node in imports:</span>
<span class="gi">+        if isinstance(import_node, nodes.Import):</span>
<span class="gi">+            if name in [alias[0] for alias in import_node.names]:</span>
<span class="gi">+                return True</span>
<span class="gi">+        elif isinstance(import_node, nodes.ImportFrom):</span>
<span class="gi">+            if name in [alias[0] for alias in import_node.names]:</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _assigned_locally(name_node: nodes.Name) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Checks if name_node has corresponding assign statement in same scope.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assign_nodes = name_node.scope().nodes_of_class(nodes.AssignName)</span>
<span class="gi">+    return any(a.name == name_node.name for a in assign_nodes)</span>


<span class="w"> </span>MSGS: dict[str, MessageDefinitionTuple] = {&#39;E0601&#39;: (
<span class="gh">diff --git a/pylint/config/_pylint_config/generate_command.py b/pylint/config/_pylint_config/generate_command.py</span>
<span class="gh">index 51798cfff..f07e642f4 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/generate_command.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/generate_command.py</span>
<span class="gu">@@ -10,4 +10,7 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def handle_generate_command(linter: PyLinter) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Handle &#39;pylint-config generate&#39;.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    output = StringIO()</span>
<span class="gi">+    utils.print_full_documentation(linter, output)</span>
<span class="gi">+    print(output.getvalue())</span>
<span class="gi">+    return 0</span>
<span class="gh">diff --git a/pylint/config/_pylint_config/help_message.py b/pylint/config/_pylint_config/help_message.py</span>
<span class="gh">index ef3e26de2..eed14cfed 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/help_message.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/help_message.py</span>
<span class="gu">@@ -8,7 +8,17 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def get_subparser_help(linter: PyLinter, command: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Get the help message for one of the subcommands.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = argparse.ArgumentParser()</span>
<span class="gi">+    subparsers = parser.add_subparsers()</span>
<span class="gi">+    linter.register_plugins(parser, subparsers)</span>
<span class="gi">+    </span>
<span class="gi">+    for action in subparsers._actions:</span>
<span class="gi">+        if isinstance(action, argparse._SubParsersAction):</span>
<span class="gi">+            for choice, subparser in action.choices.items():</span>
<span class="gi">+                if choice == command:</span>
<span class="gi">+                    return subparser.format_help()</span>
<span class="gi">+    </span>
<span class="gi">+    return f&quot;No help available for command: {command}&quot;</span>


<span class="w"> </span>def get_help(parser: argparse.ArgumentParser) -&gt;str:
<span class="gu">@@ -16,4 +26,24 @@ def get_help(parser: argparse.ArgumentParser) -&gt;str:</span>

<span class="w"> </span>    Taken from argparse.ArgumentParser.format_help.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    formatter = parser._get_formatter()</span>
<span class="gi">+</span>
<span class="gi">+    # usage</span>
<span class="gi">+    formatter.add_usage(parser.usage, parser._actions,</span>
<span class="gi">+                        parser._mutually_exclusive_groups)</span>
<span class="gi">+</span>
<span class="gi">+    # description</span>
<span class="gi">+    formatter.add_text(parser.description)</span>
<span class="gi">+</span>
<span class="gi">+    # positionals, optionals and user-defined groups</span>
<span class="gi">+    for action_group in parser._action_groups:</span>
<span class="gi">+        formatter.start_section(action_group.title)</span>
<span class="gi">+        formatter.add_text(action_group.description)</span>
<span class="gi">+        formatter.add_arguments(action_group._group_actions)</span>
<span class="gi">+        formatter.end_section()</span>
<span class="gi">+</span>
<span class="gi">+    # epilog</span>
<span class="gi">+    formatter.add_text(parser.epilog)</span>
<span class="gi">+</span>
<span class="gi">+    # determine help from format above</span>
<span class="gi">+    return formatter.format_help()</span>
<span class="gh">diff --git a/pylint/config/_pylint_config/main.py b/pylint/config/_pylint_config/main.py</span>
<span class="gh">index 37f7adc06..82b18ec72 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/main.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/main.py</span>
<span class="gu">@@ -9,4 +9,11 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def _handle_pylint_config_commands(linter: PyLinter) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Handle whichever command is passed to &#39;pylint-config&#39;.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if linter.config.generate:</span>
<span class="gi">+        return handle_generate_command(linter)</span>
<span class="gi">+    elif linter.config.help_message:</span>
<span class="gi">+        print(get_help(linter.option_manager.parser))</span>
<span class="gi">+        return 0</span>
<span class="gi">+    else:</span>
<span class="gi">+        print(&quot;Error: No valid command specified for pylint-config.&quot;)</span>
<span class="gi">+        return 1</span>
<span class="gh">diff --git a/pylint/config/_pylint_config/setup.py b/pylint/config/_pylint_config/setup.py</span>
<span class="gh">index def43d8bc..85104174d 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/setup.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/setup.py</span>
<span class="gu">@@ -17,4 +17,22 @@ class _HelpAction(_AccessParserAction):</span>

<span class="w"> </span>def _register_generate_config_options(parser: argparse.ArgumentParser) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Registers the necessary arguments on the parser.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &quot;--output-format&quot;,</span>
<span class="gi">+        dest=&quot;output_format&quot;,</span>
<span class="gi">+        default=&quot;text&quot;,</span>
<span class="gi">+        choices=[&quot;text&quot;, &quot;toml&quot;],</span>
<span class="gi">+        help=&quot;Output format for the generated config (default: text)&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &quot;--rcfile&quot;,</span>
<span class="gi">+        dest=&quot;rcfile&quot;,</span>
<span class="gi">+        default=None,</span>
<span class="gi">+        help=&quot;Specify a configuration file to load&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &quot;--include-all&quot;,</span>
<span class="gi">+        dest=&quot;include_all&quot;,</span>
<span class="gi">+        action=&quot;store_true&quot;,</span>
<span class="gi">+        help=&quot;Include all options in the generated config&quot;,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pylint/config/_pylint_config/utils.py b/pylint/config/_pylint_config/utils.py</span>
<span class="gh">index d36cab5cc..22d9ddfd5 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/utils.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/utils.py</span>
<span class="gu">@@ -27,27 +27,61 @@ class InvalidUserInput(Exception):</span>
<span class="w"> </span>def should_retry_after_invalid_input(func: Callable[_P, _ReturnValueT]
<span class="w"> </span>    ) -&gt;Callable[_P, _ReturnValueT]:
<span class="w"> </span>    &quot;&quot;&quot;Decorator that handles InvalidUserInput exceptions and retries.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(*args: _P.args, **kwargs: _P.kwargs) -&gt;_ReturnValueT:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return func(*args, **kwargs)</span>
<span class="gi">+            except InvalidUserInput as e:</span>
<span class="gi">+                print(f&quot;Invalid input. {e.valid}. You entered: {e.input}&quot;)</span>
<span class="gi">+                print(&quot;Please try again.&quot;)</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>@should_retry_after_invalid_input
<span class="w"> </span>def get_and_validate_format() -&gt;Literal[&#39;toml&#39;, &#39;ini&#39;]:
<span class="w"> </span>    &quot;&quot;&quot;Make sure that the output format is either .toml or .ini.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    format_input = input(&quot;Enter the output format (toml/ini): &quot;).lower().strip()</span>
<span class="gi">+    if format_input in {&#39;t&#39;, &#39;toml&#39;}:</span>
<span class="gi">+        return &#39;toml&#39;</span>
<span class="gi">+    if format_input in {&#39;i&#39;, &#39;ini&#39;}:</span>
<span class="gi">+        return &#39;ini&#39;</span>
<span class="gi">+    raise InvalidUserInput(&quot;Valid inputs are &#39;toml&#39; or &#39;ini&#39;&quot;, format_input)</span>


<span class="w"> </span>@should_retry_after_invalid_input
<span class="w"> </span>def validate_yes_no(question: str, default: (Literal[&#39;yes&#39;, &#39;no&#39;] | None)
<span class="w"> </span>    ) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Validate that a yes or no answer is correct.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if default is None:</span>
<span class="gi">+        prompt = f&quot;{question} (yes/no): &quot;</span>
<span class="gi">+    elif default == &#39;yes&#39;:</span>
<span class="gi">+        prompt = f&quot;{question} [Y/n]: &quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        prompt = f&quot;{question} [y/N]: &quot;</span>
<span class="gi">+</span>
<span class="gi">+    answer = input(prompt).lower().strip()</span>
<span class="gi">+    if not answer and default:</span>
<span class="gi">+        return default == &#39;yes&#39;</span>
<span class="gi">+    if answer in {&#39;y&#39;, &#39;yes&#39;}:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if answer in {&#39;n&#39;, &#39;no&#39;}:</span>
<span class="gi">+        return False</span>
<span class="gi">+    raise InvalidUserInput(&quot;Please answer &#39;yes&#39; or &#39;no&#39;&quot;, answer)</span>


<span class="w"> </span>def get_minimal_setting() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Ask the user if they want to use the minimal setting.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return validate_yes_no(&quot;Do you want to use the minimal setting?&quot;, default=&#39;no&#39;)</span>


<span class="w"> </span>def get_and_validate_output_file() -&gt;tuple[bool, Path]:
<span class="w"> </span>    &quot;&quot;&quot;Make sure that the output file is correct.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    file_path = Path(input(&quot;Enter the output file path: &quot;).strip())</span>
<span class="gi">+    </span>
<span class="gi">+    if file_path.exists():</span>
<span class="gi">+        overwrite = validate_yes_no(f&quot;The file {file_path} already exists. Do you want to overwrite it?&quot;, default=&#39;no&#39;)</span>
<span class="gi">+        return overwrite, file_path</span>
<span class="gi">+    </span>
<span class="gi">+    # Ensure the directory exists</span>
<span class="gi">+    file_path.parent.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+    return True, file_path</span>
<span class="gh">diff --git a/pylint/config/argument.py b/pylint/config/argument.py</span>
<span class="gh">index 0ac2e1955..6209ed226 100644</span>
<span class="gd">--- a/pylint/config/argument.py</span>
<span class="gi">+++ b/pylint/config/argument.py</span>
<span class="gu">@@ -21,12 +21,12 @@ _ArgumentTypes = Union[str, int, float, bool, Pattern[str], Sequence[str],</span>

<span class="w"> </span>def _confidence_transformer(value: str) -&gt;Sequence[str]:
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated string of confidence values.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [v.strip().upper() for v in value.split(&#39;,&#39;) if v.strip()]</span>


<span class="w"> </span>def _csv_transformer(value: str) -&gt;Sequence[str]:
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [v.strip() for v in value.split(&#39;,&#39;) if v.strip()]</span>


<span class="w"> </span>YES_VALUES = {&#39;y&#39;, &#39;yes&#39;, &#39;true&#39;}
<span class="gu">@@ -35,44 +35,59 @@ NO_VALUES = {&#39;n&#39;, &#39;no&#39;, &#39;false&#39;}</span>

<span class="w"> </span>def _yn_transformer(value: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Transforms a yes/no or stringified bool into a bool.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value = value.lower()</span>
<span class="gi">+    if value in YES_VALUES:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if value in NO_VALUES:</span>
<span class="gi">+        return False</span>
<span class="gi">+    raise ValueError(f&quot;Invalid yes/no value: {value}&quot;)</span>


<span class="w"> </span>def _non_empty_string_transformer(value: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Check that a string is not empty and remove quotes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value = value.strip()</span>
<span class="gi">+    if not value:</span>
<span class="gi">+        raise ValueError(&quot;Empty string is not allowed&quot;)</span>
<span class="gi">+    return pylint_utils._unquote(value)</span>


<span class="w"> </span>def _path_transformer(value: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Expand user and variables in a path.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return os.path.expandvars(os.path.expanduser(value))</span>


<span class="w"> </span>def _glob_paths_csv_transformer(value: str) -&gt;Sequence[str]:
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated list of paths while expanding user and
<span class="w"> </span>    variables and glob patterns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    paths = _csv_transformer(value)</span>
<span class="gi">+    expanded_paths = []</span>
<span class="gi">+    for path in paths:</span>
<span class="gi">+        expanded_path = _path_transformer(path)</span>
<span class="gi">+        globbed_paths = glob(expanded_path, recursive=True)</span>
<span class="gi">+        expanded_paths.extend(globbed_paths if globbed_paths else [expanded_path])</span>
<span class="gi">+    return expanded_paths</span>


<span class="w"> </span>def _py_version_transformer(value: str) -&gt;tuple[int, ...]:
<span class="w"> </span>    &quot;&quot;&quot;Transforms a version string into a version tuple.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return tuple(int(v) for v in re.findall(r&#39;\d+&#39;, value))</span>


<span class="w"> </span>def _regex_transformer(value: str) -&gt;Pattern[str]:
<span class="w"> </span>    &quot;&quot;&quot;Return `re.compile(value)`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return re.compile(value)</span>


<span class="w"> </span>def _regexp_csv_transfomer(value: str) -&gt;Sequence[Pattern[str]]:
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated list of regular expressions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [_regex_transformer(v) for v in _csv_transformer(value)]</span>


<span class="w"> </span>def _regexp_paths_csv_transfomer(value: str) -&gt;Sequence[Pattern[str]]:
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated list of regular expressions paths.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    paths = _glob_paths_csv_transformer(value)</span>
<span class="gi">+    return [_regex_transformer(re.escape(str(pathlib.Path(p)))) for p in paths]</span>


<span class="w"> </span>_TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {&#39;choice&#39;:
<span class="gh">diff --git a/pylint/config/arguments_manager.py b/pylint/config/arguments_manager.py</span>
<span class="gh">index c9417f90a..6a9f01ea1 100644</span>
<span class="gd">--- a/pylint/config/arguments_manager.py</span>
<span class="gi">+++ b/pylint/config/arguments_manager.py</span>
<span class="gu">@@ -51,53 +51,181 @@ class _ArgumentsManager:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def config(self) -&gt;argparse.Namespace:
<span class="w"> </span>        &quot;&quot;&quot;Namespace for all options.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._config</span>

<span class="w"> </span>    def _register_options_provider(self, provider: _ArgumentsProvider) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Register an options provider and load its defaults.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for section, options in provider.options:</span>
<span class="gi">+            for option in options:</span>
<span class="gi">+                argument = _convert_option_to_argument(option)</span>
<span class="gi">+                self._add_arguments_to_parser(section, provider.name, argument)</span>
<span class="gi">+                self._option_dicts[option.name] = option.__dict__</span>
<span class="gi">+        self._load_default_argument_values()</span>

<span class="w"> </span>    def _add_arguments_to_parser(self, section: str, section_desc: (str |
<span class="w"> </span>        None), argument: _Argument) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add an argument to the correct argument section/group.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if section not in self._argument_groups_dict:</span>
<span class="gi">+            self._argument_groups_dict[section] = self._arg_parser.add_argument_group(</span>
<span class="gi">+                title=section.capitalize(), description=section_desc)</span>
<span class="gi">+        section_group = self._argument_groups_dict[section]</span>
<span class="gi">+        self._add_parser_option(section_group, argument)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _add_parser_option(section_group: argparse._ArgumentGroup, argument:
<span class="w"> </span>        _Argument) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add an argument.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(argument, _StoreArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                dest=argument.dest,</span>
<span class="gi">+                action=argument.action,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                type=argument.type,</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+                metavar=argument.metavar,</span>
<span class="gi">+                choices=argument.choices,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(argument, _StoreTrueArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                dest=argument.dest,</span>
<span class="gi">+                action=&quot;store_true&quot;,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(argument, (_StoreOldNamesArgument, _StoreNewNamesArgument)):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                dest=argument.dest,</span>
<span class="gi">+                action=argument.action,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                type=argument.type,</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+                metavar=argument.metavar,</span>
<span class="gi">+                choices=argument.choices,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(argument, _ExtendArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                dest=argument.dest,</span>
<span class="gi">+                action=&quot;extend&quot;,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                type=argument.type,</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+                metavar=argument.metavar,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(argument, _CallableArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                dest=argument.dest,</span>
<span class="gi">+                action=argument.action,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                type=argument.type,</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+                metavar=argument.metavar,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise UnrecognizedArgumentAction(</span>
<span class="gi">+                f&quot;Unrecognized argument action: {type(argument)}&quot;</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def _load_default_argument_values(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Loads the default values of all registered options.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        defaults = {}</span>
<span class="gi">+        for option_dict in self._option_dicts.values():</span>
<span class="gi">+            dest = option_dict[&#39;dest&#39;]</span>
<span class="gi">+            if dest not in defaults:</span>
<span class="gi">+                defaults[dest] = option_dict.get(&#39;default&#39;)</span>
<span class="gi">+        self._config.__dict__.update(defaults)</span>

<span class="w"> </span>    def _parse_configuration_file(self, arguments: list[str]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Parse the arguments found in a configuration file into the namespace.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        config_file = None</span>
<span class="gi">+        for arg in arguments:</span>
<span class="gi">+            if arg.startswith(&#39;--rcfile=&#39;):</span>
<span class="gi">+                config_file = arg.split(&#39;=&#39;)[1]</span>
<span class="gi">+                break</span>
<span class="gi">+        </span>
<span class="gi">+        if config_file:</span>
<span class="gi">+            try:</span>
<span class="gi">+                with open(config_file, &#39;rb&#39;) as file:</span>
<span class="gi">+                    if config_file.endswith(&#39;.toml&#39;):</span>
<span class="gi">+                        config = tomlkit.load(file)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        config = tomllib.load(file)</span>
<span class="gi">+                </span>
<span class="gi">+                for section, options in config.items():</span>
<span class="gi">+                    for option, value in options.items():</span>
<span class="gi">+                        self.set_option(f&quot;{section}-{option}&quot;, value)</span>
<span class="gi">+            except (FileNotFoundError, PermissionError) as e:</span>
<span class="gi">+                warnings.warn(f&quot;Error reading configuration file: {e}&quot;)</span>

<span class="w"> </span>    def _parse_command_line_configuration(self, arguments: (Sequence[str] |
<span class="w"> </span>        None)=None) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Parse the arguments found on the command line into the namespace.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        args = self._arg_parser.parse_args(args=arguments)</span>
<span class="gi">+        self._config.__dict__.update(args.__dict__)</span>
<span class="gi">+        return args.__dict__.get(&#39;files&#39;, [])</span>

<span class="w"> </span>    def _generate_config(self, stream: (TextIO | None)=None, skipsections:
<span class="w"> </span>        tuple[str, ...]=()) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write a configuration file according to the current configuration
<span class="w"> </span>        into the given stream or stdout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if stream is None:</span>
<span class="gi">+            stream = sys.stdout</span>
<span class="gi">+</span>
<span class="gi">+        config = {}</span>
<span class="gi">+        for option_name, option_dict in self._option_dicts.items():</span>
<span class="gi">+            section = option_dict.get(&#39;group&#39;, MAIN_CHECKER_NAME).lower()</span>
<span class="gi">+            if section in skipsections:</span>
<span class="gi">+                continue</span>
<span class="gi">+            </span>
<span class="gi">+            if section not in config:</span>
<span class="gi">+                config[section] = {}</span>
<span class="gi">+            </span>
<span class="gi">+            value = getattr(self._config, option_dict[&#39;dest&#39;])</span>
<span class="gi">+            if value != option_dict.get(&#39;default&#39;):</span>
<span class="gi">+                config[section][option_name] = value</span>
<span class="gi">+</span>
<span class="gi">+        tomlkit.dump(config, stream)</span>

<span class="w"> </span>    def help(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return the usage string based on the available options.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._arg_parser.format_help()</span>

<span class="w"> </span>    def _generate_config_file(self, *, minimal: bool=False) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Write a configuration file according to the current configuration into
<span class="w"> </span>        stdout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        config = {}</span>
<span class="gi">+        for option_name, option_dict in self._option_dicts.items():</span>
<span class="gi">+            section = option_dict.get(&#39;group&#39;, MAIN_CHECKER_NAME).lower()</span>
<span class="gi">+            if section not in config:</span>
<span class="gi">+                config[section] = {}</span>
<span class="gi">+            </span>
<span class="gi">+            value = getattr(self._config, option_dict[&#39;dest&#39;])</span>
<span class="gi">+            if not minimal or value != option_dict.get(&#39;default&#39;):</span>
<span class="gi">+                config[section][option_name] = value</span>
<span class="gi">+</span>
<span class="gi">+        return tomlkit.dumps(config)</span>

<span class="w"> </span>    def set_option(self, optname: str, value: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set an option on the namespace object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;-&#39; in optname:</span>
<span class="gi">+            section, option = optname.split(&#39;-&#39;, 1)</span>
<span class="gi">+            if section in self._option_dicts:</span>
<span class="gi">+                if option in self._option_dicts[section]:</span>
<span class="gi">+                    dest = self._option_dicts[section][option][&#39;dest&#39;]</span>
<span class="gi">+                    setattr(self._config, dest, value)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise _UnrecognizedOptionError(f&quot;Unrecognized option: {optname}&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise _UnrecognizedOptionError(f&quot;Unrecognized section: {section}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if optname in self._option_dicts:</span>
<span class="gi">+                dest = self._option_dicts[optname][&#39;dest&#39;]</span>
<span class="gi">+                setattr(self._config, dest, value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise _UnrecognizedOptionError(f&quot;Unrecognized option: {optname}&quot;)</span>
<span class="gh">diff --git a/pylint/config/arguments_provider.py b/pylint/config/arguments_provider.py</span>
<span class="gh">index 2aa77d702..3b36df60c 100644</span>
<span class="gd">--- a/pylint/config/arguments_provider.py</span>
<span class="gi">+++ b/pylint/config/arguments_provider.py</span>
<span class="gu">@@ -22,7 +22,7 @@ class _ArgumentsProvider:</span>

<span class="w"> </span>    def _option_value(self, opt: str) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;Get the current value for the given option.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._arguments_manager.get_option_value(opt)</span>

<span class="w"> </span>    def _options_by_section(self) -&gt;Iterator[tuple[str, list[tuple[str,
<span class="w"> </span>        OptionDict, Any]]] | tuple[None, dict[str, list[tuple[str,
<span class="gu">@@ -31,9 +31,20 @@ class _ArgumentsProvider:</span>

<span class="w"> </span>        (section, [list of (optname, optdict, optvalue)])
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sections = {}</span>
<span class="gi">+        for optname, optdict in self.options:</span>
<span class="gi">+            section = optdict.get(&#39;group&#39;)</span>
<span class="gi">+            if section not in sections:</span>
<span class="gi">+                sections[section] = []</span>
<span class="gi">+            sections[section].append((optname, optdict, self._option_value(optname)))</span>
<span class="gi">+        </span>
<span class="gi">+        if len(sections) == 1 and None in sections:</span>
<span class="gi">+            return None, sections[None]</span>
<span class="gi">+        return ((section, values) for section, values in sections.items())</span>

<span class="w"> </span>    def _options_and_values(self, options: (Options | None)=None) -&gt;Iterator[
<span class="w"> </span>        tuple[str, OptionDict, Any]]:
<span class="w"> </span>        &quot;&quot;&quot;DEPRECATED.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        options_to_use = options if options is not None else self.options</span>
<span class="gi">+        for optname, optdict in options_to_use:</span>
<span class="gi">+            yield optname, optdict, self._option_value(optname)</span>
<span class="gh">diff --git a/pylint/config/config_file_parser.py b/pylint/config/config_file_parser.py</span>
<span class="gh">index 1f6cefb0d..f472390a8 100644</span>
<span class="gd">--- a/pylint/config/config_file_parser.py</span>
<span class="gi">+++ b/pylint/config/config_file_parser.py</span>
<span class="gu">@@ -24,12 +24,24 @@ class _RawConfParser:</span>

<span class="w"> </span>        Raises ``configparser.Error``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser = configparser.ConfigParser()</span>
<span class="gi">+        parser.read(file_path)</span>
<span class="gi">+        </span>
<span class="gi">+        if _RawConfParser._ini_file_with_sections(file_path):</span>
<span class="gi">+            config_data = {f&quot;{section}.{option}&quot;: value</span>
<span class="gi">+                           for section in parser.sections()</span>
<span class="gi">+                           for option, value in parser.items(section)}</span>
<span class="gi">+        else:</span>
<span class="gi">+            config_data = dict(parser.items(&quot;DEFAULT&quot;))</span>
<span class="gi">+        </span>
<span class="gi">+        return config_data, []</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _ini_file_with_sections(file_path: Path) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Return whether the file uses sections.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(file_path, &quot;r&quot;) as file:</span>
<span class="gi">+            return any(line.strip().startswith(&quot;[&quot;) and line.strip().endswith(&quot;]&quot;)</span>
<span class="gi">+                       for line in file)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def parse_toml_file(file_path: Path) -&gt;PylintConfigFileData:
<span class="gu">@@ -37,7 +49,18 @@ class _RawConfParser:</span>

<span class="w"> </span>        Raises ``tomllib.TOMLDecodeError``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(file_path, &quot;rb&quot;) as file:</span>
<span class="gi">+            toml_dict = tomllib.load(file)</span>
<span class="gi">+        </span>
<span class="gi">+        config_data = {}</span>
<span class="gi">+        for section, options in toml_dict.items():</span>
<span class="gi">+            if isinstance(options, dict):</span>
<span class="gi">+                for option, value in options.items():</span>
<span class="gi">+                    config_data[f&quot;{section}.{option}&quot;] = _parse_rich_type_value(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                config_data[section] = _parse_rich_type_value(options)</span>
<span class="gi">+        </span>
<span class="gi">+        return config_data, []</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def parse_config_file(file_path: (Path | None), verbose: bool
<span class="gu">@@ -46,7 +69,16 @@ class _RawConfParser:</span>

<span class="w"> </span>        Raises ``tomllib.TOMLDecodeError``, ``configparser.Error``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if file_path is None:</span>
<span class="gi">+            return {}, []</span>
<span class="gi">+        </span>
<span class="gi">+        if verbose:</span>
<span class="gi">+            print(f&quot;Using config file {file_path}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        if file_path.suffix.lower() == &quot;.toml&quot;:</span>
<span class="gi">+            return _RawConfParser.parse_toml_file(file_path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _RawConfParser.parse_ini_file(file_path)</span>


<span class="w"> </span>class _ConfigurationFileParser:
<span class="gu">@@ -59,4 +91,8 @@ class _ConfigurationFileParser:</span>
<span class="w"> </span>    def parse_config_file(self, file_path: (Path | None)
<span class="w"> </span>        ) -&gt;PylintConfigFileData:
<span class="w"> </span>        &quot;&quot;&quot;Parse a config file and return str-str pairs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _RawConfParser.parse_config_file(file_path, self.verbose_mode)</span>
<span class="gi">+        except (tomllib.TOMLDecodeError, configparser.Error) as exc:</span>
<span class="gi">+            self.linter.add_message(&quot;config-parse-error&quot;, line=0, args=(file_path, exc))</span>
<span class="gi">+            return {}, []</span>
<span class="gh">diff --git a/pylint/config/config_initialization.py b/pylint/config/config_initialization.py</span>
<span class="gh">index 526dbe95e..88898948d 100644</span>
<span class="gd">--- a/pylint/config/config_initialization.py</span>
<span class="gi">+++ b/pylint/config/config_initialization.py</span>
<span class="gu">@@ -20,7 +20,29 @@ def _config_initialization(linter: PyLinter, args_list: list[str], reporter:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse all available options, read config files and command line arguments and
<span class="w"> </span>    set options accordingly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    config_parser = _ConfigurationFileParser()</span>
<span class="gi">+    </span>
<span class="gi">+    # Read configuration from file if specified</span>
<span class="gi">+    if config_file:</span>
<span class="gi">+        config_file = Path(config_file)</span>
<span class="gi">+        if config_file.is_file():</span>
<span class="gi">+            config_parser.read_config_file(config_file)</span>
<span class="gi">+    </span>
<span class="gi">+    # Parse command line arguments</span>
<span class="gi">+    try:</span>
<span class="gi">+        args_list = linter.option_manager.parse_command_line(args_list)</span>
<span class="gi">+    except _UnrecognizedOptionError as e:</span>
<span class="gi">+        raise ArgumentPreprocessingError(str(e)) from e</span>
<span class="gi">+    </span>
<span class="gi">+    # Set reporter if provided</span>
<span class="gi">+    if reporter:</span>
<span class="gi">+        linter.set_reporter(reporter)</span>
<span class="gi">+    </span>
<span class="gi">+    # Apply configuration</span>
<span class="gi">+    linter.read_config_file(config_parser=config_parser)</span>
<span class="gi">+    linter.load_configuration_from_config(verbose=verbose_mode)</span>
<span class="gi">+    </span>
<span class="gi">+    return args_list</span>


<span class="w"> </span>def _order_all_first(config_args: list[str], *, joined: bool) -&gt;list[str]:
<span class="gu">@@ -31,4 +53,32 @@ def _order_all_first(config_args: list[str], *, joined: bool) -&gt;list[str]:</span>
<span class="w"> </span>    If joined is True, expect args in the form &#39;--enable=all,for-any-all&#39;.
<span class="w"> </span>    If joined is False, expect args in the form &#39;--enable&#39;, &#39;all,for-any-all&#39;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    enable_all = None</span>
<span class="gi">+    disable_all = None</span>
<span class="gi">+    other_args = []</span>
<span class="gi">+</span>
<span class="gi">+    for arg in config_args:</span>
<span class="gi">+        if joined:</span>
<span class="gi">+            if arg.startswith(&#39;--enable=all&#39;):</span>
<span class="gi">+                enable_all = arg</span>
<span class="gi">+            elif arg.startswith(&#39;--disable=all&#39;):</span>
<span class="gi">+                disable_all = arg</span>
<span class="gi">+            else:</span>
<span class="gi">+                other_args.append(arg)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if arg == &#39;--enable&#39; and &#39;all&#39; in config_args[config_args.index(arg) + 1].split(&#39;,&#39;):</span>
<span class="gi">+                enable_all = arg</span>
<span class="gi">+            elif arg == &#39;--disable&#39; and &#39;all&#39; in config_args[config_args.index(arg) + 1].split(&#39;,&#39;):</span>
<span class="gi">+                disable_all = arg</span>
<span class="gi">+            else:</span>
<span class="gi">+                other_args.append(arg)</span>
<span class="gi">+</span>
<span class="gi">+    if enable_all and disable_all:</span>
<span class="gi">+        raise ValueError(&quot;Cannot use both --enable=all and --disable=all&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if enable_all:</span>
<span class="gi">+        return [enable_all] + other_args</span>
<span class="gi">+    elif disable_all:</span>
<span class="gi">+        return [disable_all] + other_args</span>
<span class="gi">+    else:</span>
<span class="gi">+        return other_args</span>
<span class="gh">diff --git a/pylint/config/find_default_config_files.py b/pylint/config/find_default_config_files.py</span>
<span class="gh">index feee8e083..b271e89af 100644</span>
<span class="gd">--- a/pylint/config/find_default_config_files.py</span>
<span class="gi">+++ b/pylint/config/find_default_config_files.py</span>
<span class="gu">@@ -14,32 +14,64 @@ PYPROJECT_NAME = Path(&#39;pyproject.toml&#39;)</span>
<span class="w"> </span>CONFIG_NAMES = *RC_NAMES, PYPROJECT_NAME, Path(&#39;setup.cfg&#39;)


<span class="gd">-def _find_pyproject() -&gt;Path:</span>
<span class="gi">+def _find_pyproject() -&gt; Path:</span>
<span class="w"> </span>    &quot;&quot;&quot;Search for file pyproject.toml in the parent directories recursively.

<span class="w"> </span>    It resolves symlinks, so if there is any symlink up in the tree, it does not respect them
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current_dir = Path.cwd().resolve()</span>
<span class="gi">+    while current_dir != current_dir.parent:</span>
<span class="gi">+        pyproject = current_dir / PYPROJECT_NAME</span>
<span class="gi">+        if pyproject.is_file():</span>
<span class="gi">+            return pyproject</span>
<span class="gi">+        current_dir = current_dir.parent</span>
<span class="gi">+    return Path()</span>


<span class="gd">-def _yield_default_files() -&gt;Iterator[Path]:</span>
<span class="gi">+def _yield_default_files() -&gt; Iterator[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over the default config file names and see if they exist.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for config_name in CONFIG_NAMES:</span>
<span class="gi">+        config_path = Path.cwd() / config_name</span>
<span class="gi">+        if config_path.is_file():</span>
<span class="gi">+            yield config_path</span>


<span class="gd">-def _find_project_config() -&gt;Iterator[Path]:</span>
<span class="gi">+def _find_project_config() -&gt; Iterator[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Traverse up the directory tree to find a config file.

<span class="w"> </span>    Stop if no &#39;__init__&#39; is found and thus we are no longer in a package.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current_dir = Path.cwd()</span>
<span class="gi">+    while current_dir != current_dir.parent:</span>
<span class="gi">+        if not (current_dir / &#39;__init__.py&#39;).exists():</span>
<span class="gi">+            break</span>
<span class="gi">+        for config_name in CONFIG_NAMES:</span>
<span class="gi">+            config_path = current_dir / config_name</span>
<span class="gi">+            if config_path.is_file():</span>
<span class="gi">+                yield config_path</span>
<span class="gi">+        current_dir = current_dir.parent</span>


<span class="gd">-def _find_config_in_home_or_environment() -&gt;Iterator[Path]:</span>
<span class="gi">+def _find_config_in_home_or_environment() -&gt; Iterator[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find a config file in the specified environment var or the home directory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    env_config = os.environ.get(&#39;PYLINTRC&#39;)</span>
<span class="gi">+    if env_config:</span>
<span class="gi">+        env_path = Path(env_config)</span>
<span class="gi">+        if env_path.is_file():</span>
<span class="gi">+            yield env_path</span>

<span class="gi">+    home = Path.home()</span>
<span class="gi">+    for rc_name in RC_NAMES:</span>
<span class="gi">+        rc_path = home / rc_name</span>
<span class="gi">+        if rc_path.is_file():</span>
<span class="gi">+            yield rc_path</span>

<span class="gd">-def find_default_config_files() -&gt;Iterator[Path]:</span>
<span class="gi">+</span>
<span class="gi">+def find_default_config_files() -&gt; Iterator[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find all possible config files.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yield from _yield_default_files()</span>
<span class="gi">+    yield from _find_project_config()</span>
<span class="gi">+    yield from _find_config_in_home_or_environment()</span>
<span class="gi">+    pyproject = _find_pyproject()</span>
<span class="gi">+    if pyproject.is_file():</span>
<span class="gi">+        yield pyproject</span>
<span class="gh">diff --git a/pylint/config/help_formatter.py b/pylint/config/help_formatter.py</span>
<span class="gh">index 0bcc08da4..53893f2c9 100644</span>
<span class="gd">--- a/pylint/config/help_formatter.py</span>
<span class="gi">+++ b/pylint/config/help_formatter.py</span>
<span class="gu">@@ -7,6 +7,12 @@ from pylint.constants import DEFAULT_PYLINT_HOME</span>
<span class="w"> </span>class _HelpFormatter(argparse.RawDescriptionHelpFormatter):
<span class="w"> </span>    &quot;&quot;&quot;Formatter for the help message emitted by argparse.&quot;&quot;&quot;

<span class="gd">-    def _get_help_string(self, action: argparse.Action) -&gt;(str | None):</span>
<span class="gi">+    def _get_help_string(self, action: argparse.Action) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Copied from argparse.ArgumentDefaultsHelpFormatter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        help_text = action.help</span>
<span class="gi">+        if &#39;%(default)&#39; not in action.help:</span>
<span class="gi">+            if action.default is not argparse.SUPPRESS:</span>
<span class="gi">+                defaulting_nargs = [argparse.OPTIONAL, argparse.ZERO_OR_MORE]</span>
<span class="gi">+                if action.option_strings or action.nargs in defaulting_nargs:</span>
<span class="gi">+                    help_text += &#39; (default: %(default)s)&#39;</span>
<span class="gi">+        return help_text</span>
<span class="gh">diff --git a/pylint/config/utils.py b/pylint/config/utils.py</span>
<span class="gh">index 3da9282b3..7ec176f2c 100644</span>
<span class="gd">--- a/pylint/config/utils.py</span>
<span class="gi">+++ b/pylint/config/utils.py</span>
<span class="gu">@@ -16,12 +16,29 @@ def _convert_option_to_argument(opt: str, optdict: dict[str, Any]) -&gt;(</span>
<span class="w"> </span>    _StoreArgument | _StoreTrueArgument | _CallableArgument |
<span class="w"> </span>    _StoreOldNamesArgument | _StoreNewNamesArgument | _ExtendArgument):
<span class="w"> </span>    &quot;&quot;&quot;Convert an optdict to an Argument class instance.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    action = optdict.get(&#39;action&#39;)</span>
<span class="gi">+    if action == &#39;store_true&#39;:</span>
<span class="gi">+        return _StoreTrueArgument(opt, **optdict)</span>
<span class="gi">+    elif action == &#39;callback&#39;:</span>
<span class="gi">+        return _CallableArgument(opt, **optdict)</span>
<span class="gi">+    elif action == &#39;store_old_names&#39;:</span>
<span class="gi">+        return _StoreOldNamesArgument(opt, **optdict)</span>
<span class="gi">+    elif action == &#39;store_new_names&#39;:</span>
<span class="gi">+        return _StoreNewNamesArgument(opt, **optdict)</span>
<span class="gi">+    elif action == &#39;extend&#39;:</span>
<span class="gi">+        return _ExtendArgument(opt, **optdict)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _StoreArgument(opt, **optdict)</span>


<span class="w"> </span>def _parse_rich_type_value(value: Any) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Parse rich (toml) types into strings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, (list, tuple)):</span>
<span class="gi">+        return &#39;,&#39;.join(str(item) for item in value)</span>
<span class="gi">+    elif isinstance(value, dict):</span>
<span class="gi">+        return &#39;,&#39;.join(f&quot;{k}={v}&quot; for k, v in value.items())</span>
<span class="gi">+    else:</span>
<span class="gi">+        return str(value)</span>


<span class="w"> </span>def _init_hook(run: Run, value: (str | None)) -&gt;None:
<span class="gu">@@ -29,27 +46,31 @@ def _init_hook(run: Run, value: (str | None)) -&gt;None:</span>

<span class="w"> </span>    This can be used to set the &#39;sys.path&#39; for example.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value:</span>
<span class="gi">+        exec(value)</span>


<span class="w"> </span>def _set_rcfile(run: Run, value: (str | None)) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Set the rcfile.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value:</span>
<span class="gi">+        run.rcfile = Path(value).expanduser().resolve()</span>


<span class="w"> </span>def _set_output(run: Run, value: (str | None)) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Set the output.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value:</span>
<span class="gi">+        run.reporter.set_output(value)</span>


<span class="w"> </span>def _add_plugins(run: Run, value: (str | None)) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Add plugins to the list of loadable plugins.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value:</span>
<span class="gi">+        run.plugins.extend(utils._splitstrip(value))</span>


<span class="w"> </span>def _enable_all_extensions(run: Run, value: (str | None)) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Enable all extensions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    run.plugins.extend(extensions.all())</span>


<span class="w"> </span>PREPROCESSABLE_OPTIONS: dict[str, tuple[bool, Callable[[Run, str | None],
<span class="gu">@@ -62,4 +83,36 @@ PREPROCESSABLE_OPTIONS: dict[str, tuple[bool, Callable[[Run, str | None],</span>

<span class="w"> </span>def _preprocess_options(run: Run, args: Sequence[str]) -&gt;list[str]:
<span class="w"> </span>    &quot;&quot;&quot;Pre-process options before full config parsing has started.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    remaining_args = list(args)</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while i &lt; len(remaining_args):</span>
<span class="gi">+        arg = remaining_args[i]</span>
<span class="gi">+        if arg.startswith(&#39;--&#39;):</span>
<span class="gi">+            option = arg.split(&#39;=&#39;)[0]</span>
<span class="gi">+        elif arg.startswith(&#39;-&#39;):</span>
<span class="gi">+            option = arg[:2]</span>
<span class="gi">+        else:</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if option in PREPROCESSABLE_OPTIONS:</span>
<span class="gi">+            is_option_with_value, callback, _ = PREPROCESSABLE_OPTIONS[option]</span>
<span class="gi">+            if is_option_with_value:</span>
<span class="gi">+                if &#39;=&#39; in arg:</span>
<span class="gi">+                    _, value = arg.split(&#39;=&#39;, 1)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    i += 1</span>
<span class="gi">+                    if i &gt;= len(remaining_args):</span>
<span class="gi">+                        raise ArgumentPreprocessingError(f&quot;Option {option} requires a value.&quot;)</span>
<span class="gi">+                    value = remaining_args[i]</span>
<span class="gi">+                callback(run, value)</span>
<span class="gi">+                remaining_args.pop(i)</span>
<span class="gi">+                if is_option_with_value:</span>
<span class="gi">+                    remaining_args.pop(i - 1)</span>
<span class="gi">+                i -= 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                callback(run, None)</span>
<span class="gi">+                remaining_args.pop(i)</span>
<span class="gi">+                i -= 1</span>
<span class="gi">+        i += 1</span>
<span class="gi">+    return remaining_args</span>
<span class="gh">diff --git a/pylint/constants.py b/pylint/constants.py</span>
<span class="gh">index 915082479..4391e5076 100644</span>
<span class="gd">--- a/pylint/constants.py</span>
<span class="gi">+++ b/pylint/constants.py</span>
<span class="gu">@@ -45,9 +45,15 @@ INCOMPATIBLE_WITH_USELESS_SUPPRESSION = frozenset([&#39;R0401&#39;, &#39;W0402&#39;,</span>
<span class="w"> </span>    &#39;W1505&#39;, &#39;W1511&#39;, &#39;W1512&#39;, &#39;W1513&#39;, &#39;R0801&#39;])


<span class="gd">-def _get_pylint_home() -&gt;str:</span>
<span class="gi">+def _get_pylint_home() -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the pylint home.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;PYLINTHOME&#39; in os.environ:</span>
<span class="gi">+        return os.environ[&#39;PYLINTHOME&#39;]</span>
<span class="gi">+    </span>
<span class="gi">+    if os.path.isfile(&#39;.pylint.d&#39;):</span>
<span class="gi">+        return os.path.abspath(&#39;.pylint.d&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return DEFAULT_PYLINT_HOME</span>


<span class="w"> </span>PYLINT_HOME = _get_pylint_home()
<span class="gh">diff --git a/pylint/extensions/_check_docs_utils.py b/pylint/extensions/_check_docs_utils.py</span>
<span class="gh">index 4e60e6372..c9f92ff4f 100644</span>
<span class="gd">--- a/pylint/extensions/_check_docs_utils.py</span>
<span class="gi">+++ b/pylint/extensions/_check_docs_utils.py</span>
<span class="gu">@@ -17,7 +17,7 @@ def space_indentation(s: str) -&gt;int:</span>
<span class="w"> </span>    :rtype: int
<span class="w"> </span>    :return: number of leading spaces
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(s) - len(s.lstrip())</span>


<span class="w"> </span>def get_setters_property_name(node: nodes.FunctionDef) -&gt;(str | None):
<span class="gu">@@ -30,7 +30,14 @@ def get_setters_property_name(node: nodes.FunctionDef) -&gt;(str | None):</span>
<span class="w"> </span>    :returns: The name of the property that the node is a setter for,
<span class="w"> </span>        or None if one could not be found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not node.decorators:</span>
<span class="gi">+        return None</span>
<span class="gi">+    for decorator in node.decorators.nodes:</span>
<span class="gi">+        if (isinstance(decorator, nodes.Attribute) and</span>
<span class="gi">+            decorator.attrname == &quot;setter&quot; and</span>
<span class="gi">+            isinstance(decorator.expr, nodes.Name)):</span>
<span class="gi">+            return decorator.expr.name</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def get_setters_property(node: nodes.FunctionDef) -&gt;(nodes.FunctionDef | None):
<span class="gu">@@ -43,7 +50,17 @@ def get_setters_property(node: nodes.FunctionDef) -&gt;(nodes.FunctionDef | None):</span>
<span class="w"> </span>    :returns: The node relating to the property of the given setter node,
<span class="w"> </span>        or None if one could not be found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    property_name = get_setters_property_name(node)</span>
<span class="gi">+    if property_name is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    class_node = node.parent.frame()</span>
<span class="gi">+    for member in class_node.body:</span>
<span class="gi">+        if (isinstance(member, nodes.FunctionDef) and</span>
<span class="gi">+            member.name == property_name and</span>
<span class="gi">+            utils.decorated_with_property(member)):</span>
<span class="gi">+            return member</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def returns_something(return_node: nodes.Return) -&gt;bool:
<span class="gu">@@ -56,7 +73,9 @@ def returns_something(return_node: nodes.Return) -&gt;bool:</span>
<span class="w"> </span>    :return: True if the return node returns a value other than None,
<span class="w"> </span>        False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if return_node.value is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return not (isinstance(return_node.value, nodes.Const) and return_node.value.value is None)</span>


<span class="w"> </span>def possible_exc_types(node: nodes.NodeNG) -&gt;set[nodes.ClassDef]:
<span class="gu">@@ -70,7 +89,21 @@ def possible_exc_types(node: nodes.NodeNG) -&gt;set[nodes.ClassDef]:</span>

<span class="w"> </span>    :returns: A list of exception types possibly raised by :param:`node`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    exc_types = set()</span>
<span class="gi">+    if isinstance(node, nodes.Raise):</span>
<span class="gi">+        if node.exc is not None:</span>
<span class="gi">+            inferred = utils.safe_infer(node.exc)</span>
<span class="gi">+            if inferred:</span>
<span class="gi">+                exc_types.add(inferred)</span>
<span class="gi">+        elif node.cause is not None:</span>
<span class="gi">+            inferred = utils.safe_infer(node.cause)</span>
<span class="gi">+            if inferred:</span>
<span class="gi">+                exc_types.add(inferred)</span>
<span class="gi">+    elif isinstance(node, nodes.Call):</span>
<span class="gi">+        inferred = utils.safe_infer(node.func)</span>
<span class="gi">+        if inferred and isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+            exc_types.add(inferred)</span>
<span class="gi">+    return {exc for exc in exc_types if isinstance(exc, nodes.ClassDef)}</span>


<span class="w"> </span>def _annotations_list(args_node: nodes.Arguments) -&gt;list[nodes.NodeNG]:
<span class="gu">@@ -85,7 +118,23 @@ def _annotations_list(args_node: nodes.Arguments) -&gt;list[nodes.NodeNG]:</span>
<span class="w"> </span>    :param args_node: The node to get the annotations for.
<span class="w"> </span>    :returns: The annotations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    annotations = []</span>
<span class="gi">+    </span>
<span class="gi">+    # Real type annotations</span>
<span class="gi">+    if args_node.annotations:</span>
<span class="gi">+        annotations.extend(args_node.annotations)</span>
<span class="gi">+    </span>
<span class="gi">+    # Type comment on the function</span>
<span class="gi">+    if args_node.parent and isinstance(args_node.parent, nodes.FunctionDef):</span>
<span class="gi">+        if args_node.parent.type_comment_args:</span>
<span class="gi">+            annotations.extend(args_node.parent.type_comment_args)</span>
<span class="gi">+    </span>
<span class="gi">+    # Type comment on individual arguments</span>
<span class="gi">+    for arg in args_node.args + args_node.kwonlyargs:</span>
<span class="gi">+        if arg.type_comment:</span>
<span class="gi">+            annotations.append(arg.type_comment)</span>
<span class="gi">+    </span>
<span class="gi">+    return annotations</span>


<span class="w"> </span>class Docstring:
<span class="gu">@@ -109,7 +158,7 @@ class Docstring:</span>

<span class="w"> </span>    def matching_sections(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of matching docstring sections.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sum(1 for _ in re.finditer(self.re_for_parameters_see, self.doc))</span>


<span class="w"> </span>class SphinxDocstring(Docstring):
<span class="gh">diff --git a/pylint/extensions/check_elif.py b/pylint/extensions/check_elif.py</span>
<span class="gh">index b9e5190a4..f500b7a0d 100644</span>
<span class="gd">--- a/pylint/extensions/check_elif.py</span>
<span class="gi">+++ b/pylint/extensions/check_elif.py</span>
<span class="gu">@@ -25,9 +25,24 @@ class ElseifUsedChecker(BaseTokenChecker):</span>

<span class="w"> </span>    def process_tokens(self, tokens: list[TokenInfo]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process tokens and look for &#39;if&#39; or &#39;elif&#39;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for index, token in enumerate(tokens):</span>
<span class="gi">+            if token.type == tokenize.NAME and token.string == &#39;else&#39;:</span>
<span class="gi">+                # Check if the next non-whitespace token is &#39;if&#39;</span>
<span class="gi">+                next_token = self._find_next_token(tokens, index + 1)</span>
<span class="gi">+                if next_token and next_token.type == tokenize.NAME and next_token.string == &#39;if&#39;:</span>
<span class="gi">+                    self.add_message(&#39;else-if-used&#39;, line=token.start[0])</span>

<span class="w"> </span>    @only_required_for_messages(&#39;else-if-used&#39;)
<span class="w"> </span>    def visit_if(self, node: nodes.If) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Current if node must directly follow an &#39;else&#39;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        if isinstance(parent, nodes.If) and parent.orelse == [node]:</span>
<span class="gi">+            # This &#39;if&#39; is part of an &#39;else if&#39; statement</span>
<span class="gi">+            self.add_message(&#39;else-if-used&#39;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _find_next_token(self, tokens: list[TokenInfo], start_index: int) -&gt; TokenInfo | None:</span>
<span class="gi">+        &quot;&quot;&quot;Find the next non-whitespace token.&quot;&quot;&quot;</span>
<span class="gi">+        for token in tokens[start_index:]:</span>
<span class="gi">+            if token.type != tokenize.NEWLINE and token.type != tokenize.INDENT:</span>
<span class="gi">+                return token</span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/pylint/extensions/code_style.py b/pylint/extensions/code_style.py</span>
<span class="gh">index cc8634462..f16e5b53d 100644</span>
<span class="gd">--- a/pylint/extensions/code_style.py</span>
<span class="gi">+++ b/pylint/extensions/code_style.py</span>
<span class="gu">@@ -56,7 +56,15 @@ Disabled by default!&quot;&quot;&quot;</span>
<span class="w"> </span>    def _check_dict_consider_namedtuple_dataclass(self, node: nodes.Dict
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if dictionary values can be replaced by Namedtuple or Dataclass.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.parent, (nodes.Assign, nodes.AnnAssign)):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if len(node.items) &lt; 2:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        values = [item[1] for item in node.items]</span>
<span class="gi">+        if all(isinstance(value, (nodes.List, nodes.Tuple)) for value in values):</span>
<span class="gi">+            self.add_message(&#39;consider-using-namedtuple-or-dataclass&#39;, node=node)</span>

<span class="w"> </span>    def _check_consider_using_assignment_expr(self, node: nodes.If) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check if an assignment expression (walrus operator) can be used.
<span class="gu">@@ -72,7 +80,30 @@ Disabled by default!&quot;&quot;&quot;</span>

<span class="w"> </span>        Note: Assignment expressions were added in Python 3.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if sys.version_info &lt; (3, 8):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        prev_sibling = node.previous_sibling()</span>
<span class="gi">+        if not isinstance(prev_sibling, (nodes.Assign, nodes.AnnAssign)):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if len(prev_sibling.targets) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        target = prev_sibling.targets[0]</span>
<span class="gi">+        if not isinstance(target, nodes.AssignName):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        name = target.name</span>
<span class="gi">+        if not self._check_prev_sibling_to_if_stmt(prev_sibling, name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self._check_ignore_assignment_expr_suggestion(node, name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        value = prev_sibling.value</span>
<span class="gi">+        suggestion = f&quot;if ({name} := {value.as_string()}):&quot;</span>
<span class="gi">+        self.add_message(&#39;consider-using-assignment-expr&#39;, node=node, args=(suggestion,))</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _check_prev_sibling_to_if_stmt(prev_sibling: (nodes.NodeNG | None),
<span class="gu">@@ -81,7 +112,17 @@ Disabled by default!&quot;&quot;&quot;</span>

<span class="w"> </span>        Ignore statements which span multiple lines.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(prev_sibling, (nodes.Assign, nodes.AnnAssign)):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if prev_sibling.lineno != prev_sibling.end_lineno:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if len(prev_sibling.targets) != 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        target = prev_sibling.targets[0]</span>
<span class="gi">+        return isinstance(target, nodes.AssignName) and target.name == name</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _check_ignore_assignment_expr_suggestion(node: nodes.If, name: (str |
<span class="gu">@@ -91,4 +132,22 @@ Disabled by default!&quot;&quot;&quot;</span>
<span class="w"> </span>        E.g., in cases where a match statement would be a better fit
<span class="w"> </span>        (multiple conditions).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.test, nodes.Compare):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if len(node.test.ops) != 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        left = node.test.left</span>
<span class="gi">+        if not isinstance(left, nodes.Name) or left.name != name:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Check if there are multiple conditions (e.g., elif statements)</span>
<span class="gi">+        current = node</span>
<span class="gi">+        while current.orelse:</span>
<span class="gi">+            if len(current.orelse) == 1 and isinstance(current.orelse[0], nodes.If):</span>
<span class="gi">+                current = current.orelse[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        return len(node.orelse) &gt; 0 or current != node</span>
<span class="gh">diff --git a/pylint/extensions/consider_refactoring_into_while_condition.py b/pylint/extensions/consider_refactoring_into_while_condition.py</span>
<span class="gh">index c2135c90d..8ef02f5a5 100644</span>
<span class="gd">--- a/pylint/extensions/consider_refactoring_into_while_condition.py</span>
<span class="gi">+++ b/pylint/extensions/consider_refactoring_into_while_condition.py</span>
<span class="gu">@@ -27,6 +27,26 @@ class ConsiderRefactorIntoWhileConditionChecker(checkers.BaseChecker):</span>
<span class="w"> </span>        &#39;Emitted when `while True:` loop is used and the first statement is a break condition. The ``if / break`` construct can be removed if the check is inverted and moved to the ``while`` statement.&#39;
<span class="w"> </span>        )}

<span class="gd">-    def _check_breaking_after_while_true(self, node: nodes.While) -&gt;None:</span>
<span class="gi">+    def _check_breaking_after_while_true(self, node: nodes.While) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that any loop with an ``if`` clause has a break statement.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.test, nodes.Const) or not node.test.value:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not node.body:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        first_stmt = node.body[0]</span>
<span class="gi">+        if not isinstance(first_stmt, nodes.If):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if_body = first_stmt.body</span>
<span class="gi">+        if not if_body or not isinstance(if_body[0], nodes.Break):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        condition = utils.node_to_string(first_stmt.test)</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &#39;consider-refactoring-into-while-condition&#39;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=(f&quot;not ({condition})&quot;, node.test.value),</span>
<span class="gi">+            confidence=HIGH,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/pylint/extensions/dict_init_mutate.py b/pylint/extensions/dict_init_mutate.py</span>
<span class="gh">index e54d20198..a473dc550 100644</span>
<span class="gd">--- a/pylint/extensions/dict_init_mutate.py</span>
<span class="gi">+++ b/pylint/extensions/dict_init_mutate.py</span>
<span class="gu">@@ -24,4 +24,25 @@ class DictInitMutateChecker(BaseChecker):</span>

<span class="w"> </span>        At this time, detecting nested mutation is not supported.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.value, nodes.Dict):</span>
<span class="gi">+            # Dictionary initialization</span>
<span class="gi">+            for target in node.targets:</span>
<span class="gi">+                if isinstance(target, nodes.AssignName):</span>
<span class="gi">+                    dict_name = target.name</span>
<span class="gi">+                    self._check_dict_mutation(node.parent, dict_name)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_dict_mutation(self, parent: nodes.NodeNG, dict_name: str) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;Check for dictionary mutation in the next statements.&quot;&quot;&quot;</span>
<span class="gi">+        for sibling in parent.get_children():</span>
<span class="gi">+            if isinstance(sibling, nodes.Assign) and sibling.targets[0].as_string() == dict_name:</span>
<span class="gi">+                break</span>
<span class="gi">+            if isinstance(sibling, nodes.AugAssign) and sibling.target.as_string() == dict_name:</span>
<span class="gi">+                self.add_message(&#39;dict-init-mutate&#39;, node=sibling)</span>
<span class="gi">+            if isinstance(sibling, (nodes.Call, nodes.Subscript)):</span>
<span class="gi">+                if sibling.func.as_string() == f&quot;{dict_name}.update&quot; or \</span>
<span class="gi">+                   (isinstance(sibling.func, nodes.Attribute) and </span>
<span class="gi">+                    sibling.func.expr.as_string() == dict_name and </span>
<span class="gi">+                    sibling.func.attrname in (&#39;setdefault&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;clear&#39;)):</span>
<span class="gi">+                    self.add_message(&#39;dict-init-mutate&#39;, node=sibling)</span>
<span class="gi">+                elif isinstance(sibling, nodes.Subscript) and sibling.value.as_string() == dict_name:</span>
<span class="gi">+                    self.add_message(&#39;dict-init-mutate&#39;, node=sibling)</span>
<span class="gh">diff --git a/pylint/extensions/docparams.py b/pylint/extensions/docparams.py</span>
<span class="gh">index 2c5c09d6b..92596154d 100644</span>
<span class="gd">--- a/pylint/extensions/docparams.py</span>
<span class="gi">+++ b/pylint/extensions/docparams.py</span>
<span class="gu">@@ -100,7 +100,23 @@ class DocstringParameterChecker(BaseChecker):</span>
<span class="w"> </span>        :param node: Node for a function or method definition in the AST
<span class="w"> </span>        :type node: :class:`astroid.scoped_nodes.Function`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        function_name = node.name</span>
<span class="gi">+        if node.decorators and checker_utils.decorated_with(node, [&#39;property&#39;]):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        doc = utils.docstring_find_by_name(node.doc, &quot;sphinx&quot;)</span>
<span class="gi">+        if doc is None:</span>
<span class="gi">+            doc = utils.docstring_find_by_name(node.doc, self.config.default_docstring_type)</span>
<span class="gi">+        </span>
<span class="gi">+        if not doc:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if node.name in self.constructor_names:</span>
<span class="gi">+            self._check_constructor_params(node, doc)</span>
<span class="gi">+</span>
<span class="gi">+        self.check_arguments_in_docstring(doc, node.args, node)</span>
<span class="gi">+        self._check_raises(node, doc)</span>
<span class="gi">+        self._check_returns(node, doc)</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef
<span class="w"> </span>    visit_yieldfrom = visit_yield

<span class="gu">@@ -120,7 +136,12 @@ class DocstringParameterChecker(BaseChecker):</span>

<span class="w"> </span>        :param warning_node: The node to be analyzed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        missing_args = (expected_argument_names - found_argument_names -</span>
<span class="gi">+                        not_needed_names)</span>
<span class="gi">+        if missing_args:</span>
<span class="gi">+            for missing_arg in sorted(missing_args):</span>
<span class="gi">+                self.add_message(message_id, args=(missing_arg,),</span>
<span class="gi">+                                 node=warning_node)</span>

<span class="w"> </span>    def _compare_different_args(self, found_argument_names: set[str],
<span class="w"> </span>        message_id: str, not_needed_names: set[str],
<span class="gu">@@ -138,7 +159,12 @@ class DocstringParameterChecker(BaseChecker):</span>

<span class="w"> </span>        :param warning_node: The node to be analyzed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        different_args = (found_argument_names - expected_argument_names -</span>
<span class="gi">+                          not_needed_names)</span>
<span class="gi">+        if different_args:</span>
<span class="gi">+            for different_arg in sorted(different_args):</span>
<span class="gi">+                self.add_message(message_id, args=(different_arg,),</span>
<span class="gi">+                                 node=warning_node)</span>

<span class="w"> </span>    def _compare_ignored_args(self, found_argument_names: set[str],
<span class="w"> </span>        message_id: str, ignored_argument_names: set[str], warning_node:
<span class="gu">@@ -151,7 +177,11 @@ class DocstringParameterChecker(BaseChecker):</span>
<span class="w"> </span>        :param ignored_argument_names: Expected argument names
<span class="w"> </span>        :param warning_node: The node to be analyzed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ignored_args = found_argument_names &amp; ignored_argument_names</span>
<span class="gi">+        if ignored_args:</span>
<span class="gi">+            for ignored_arg in sorted(ignored_args):</span>
<span class="gi">+                self.add_message(message_id, args=(ignored_arg,),</span>
<span class="gi">+                                 node=warning_node)</span>

<span class="w"> </span>    def check_arguments_in_docstring(self, doc: Docstring, arguments_node:
<span class="w"> </span>        astroid.Arguments, warning_node: astroid.NodeNG,
<span class="gu">@@ -186,7 +216,52 @@ class DocstringParameterChecker(BaseChecker):</span>
<span class="w"> </span>            documented. If None then this value is read from the configuration.
<span class="w"> </span>        :type accept_no_param_doc: bool or None
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if accept_no_param_doc is None:</span>
<span class="gi">+            accept_no_param_doc = self.config.accept_no_param_doc</span>
<span class="gi">+        </span>
<span class="gi">+        expected_argument_names = set(arguments_node.arguments)</span>
<span class="gi">+        expected_argument_names.update(arguments_node.kwonlyargs)</span>
<span class="gi">+        </span>
<span class="gi">+        if arguments_node.vararg:</span>
<span class="gi">+            expected_argument_names.add(arguments_node.vararg)</span>
<span class="gi">+        if arguments_node.kwarg:</span>
<span class="gi">+            expected_argument_names.add(arguments_node.kwarg)</span>
<span class="gi">+        </span>
<span class="gi">+        found_argument_names = set(doc.params.keys())</span>
<span class="gi">+        found_argument_types = set(doc.types.keys())</span>
<span class="gi">+        </span>
<span class="gi">+        if not found_argument_names and not found_argument_types:</span>
<span class="gi">+            if not accept_no_param_doc:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &#39;missing-any-param-doc&#39;,</span>
<span class="gi">+                    args=(warning_node.name,),</span>
<span class="gi">+                    node=warning_node,</span>
<span class="gi">+                )</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        self._compare_missing_args(</span>
<span class="gi">+            found_argument_names, &#39;missing-param-doc&#39;,</span>
<span class="gi">+            self.not_needed_param_in_docstring, expected_argument_names,</span>
<span class="gi">+            warning_node</span>
<span class="gi">+        )</span>
<span class="gi">+        </span>
<span class="gi">+        self._compare_different_args(</span>
<span class="gi">+            found_argument_names, &#39;differing-param-doc&#39;,</span>
<span class="gi">+            self.not_needed_param_in_docstring, expected_argument_names,</span>
<span class="gi">+            warning_node</span>
<span class="gi">+        )</span>
<span class="gi">+        </span>
<span class="gi">+        self._compare_missing_args(</span>
<span class="gi">+            found_argument_types, &#39;missing-type-doc&#39;,</span>
<span class="gi">+            self.not_needed_param_in_docstring, expected_argument_names,</span>
<span class="gi">+            warning_node</span>
<span class="gi">+        )</span>
<span class="gi">+        </span>
<span class="gi">+        self._compare_different_args(</span>
<span class="gi">+            found_argument_types, &#39;differing-type-doc&#39;,</span>
<span class="gi">+            self.not_needed_param_in_docstring, expected_argument_names,</span>
<span class="gi">+            warning_node</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _add_raise_message(self, missing_exceptions: set[str], node: nodes.
<span class="w"> </span>        FunctionDef) -&gt;None:
<span class="gu">@@ -195,4 +270,7 @@ class DocstringParameterChecker(BaseChecker):</span>
<span class="w"> </span>        :param missing_exceptions: A list of missing exception types.
<span class="w"> </span>        :param node: The node show the message on.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for missing in sorted(missing_exceptions):</span>
<span class="gi">+            self.add_message(&#39;missing-raises-doc&#39;,</span>
<span class="gi">+                             args=(missing,),</span>
<span class="gi">+                             node=node)</span>
<span class="gh">diff --git a/pylint/extensions/dunder.py b/pylint/extensions/dunder.py</span>
<span class="gh">index 40e8f7fe8..a89058058 100644</span>
<span class="gd">--- a/pylint/extensions/dunder.py</span>
<span class="gi">+++ b/pylint/extensions/dunder.py</span>
<span class="gu">@@ -23,4 +23,15 @@ class DunderChecker(BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if known dunder method is misspelled or dunder name is not one
<span class="w"> </span>        of the pre-defined names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = node.name</span>
<span class="gi">+        if name.startswith(&#39;__&#39;) and name.endswith(&#39;__&#39;):</span>
<span class="gi">+            if len(name) &gt; 4:  # Ignore &#39;__&#39;</span>
<span class="gi">+                valid_dunder_names = set(DUNDER_METHODS + DUNDER_PROPERTIES + EXTRA_DUNDER_METHODS + self.linter.config.good_dunder_names)</span>
<span class="gi">+                if name not in valid_dunder_names:</span>
<span class="gi">+                    # Check for possible misspellings</span>
<span class="gi">+                    for valid_name in valid_dunder_names:</span>
<span class="gi">+                        if name.lower() == valid_name.lower():</span>
<span class="gi">+                            self.add_message(&#39;bad-dunder-name&#39;, node=node, args=(name,), confidence=HIGH)</span>
<span class="gi">+                            return</span>
<span class="gi">+                    # If not a misspelling, it&#39;s an unknown dunder name</span>
<span class="gi">+                    self.add_message(&#39;bad-dunder-name&#39;, node=node, args=(name,), confidence=HIGH)</span>
<span class="gh">diff --git a/pylint/extensions/empty_comment.py b/pylint/extensions/empty_comment.py</span>
<span class="gh">index 54f595eb6..e6a0157e7 100644</span>
<span class="gd">--- a/pylint/extensions/empty_comment.py</span>
<span class="gi">+++ b/pylint/extensions/empty_comment.py</span>
<span class="gu">@@ -8,12 +8,32 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def is_line_commented(line: bytes) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Checks if a `# symbol that is not part of a string was found in line.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for i, char in enumerate(line):</span>
<span class="gi">+        if char == ord(b&#39;#&#39;):</span>
<span class="gi">+            if not comment_part_of_string(line, i):</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def comment_part_of_string(line: bytes, comment_idx: int) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Checks if the symbol at comment_idx is part of a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    in_single_quote = False</span>
<span class="gi">+    in_double_quote = False</span>
<span class="gi">+    escape_next = False</span>
<span class="gi">+</span>
<span class="gi">+    for i, char in enumerate(line[:comment_idx]):</span>
<span class="gi">+        if escape_next:</span>
<span class="gi">+            escape_next = False</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if char == ord(b&#39;\\&#39;):</span>
<span class="gi">+            escape_next = True</span>
<span class="gi">+        elif char == ord(b&quot;&#39;&quot;) and not in_double_quote:</span>
<span class="gi">+            in_single_quote = not in_single_quote</span>
<span class="gi">+        elif char == ord(b&#39;&quot;&#39;) and not in_single_quote:</span>
<span class="gi">+            in_double_quote = not in_double_quote</span>
<span class="gi">+</span>
<span class="gi">+    return in_single_quote or in_double_quote</span>


<span class="w"> </span>class CommentChecker(BaseRawFileChecker):
<span class="gh">diff --git a/pylint/extensions/for_any_all.py b/pylint/extensions/for_any_all.py</span>
<span class="gh">index 8176cac2e..e1b7a7b4b 100644</span>
<span class="gd">--- a/pylint/extensions/for_any_all.py</span>
<span class="gi">+++ b/pylint/extensions/for_any_all.py</span>
<span class="gu">@@ -28,7 +28,23 @@ class ConsiderUsingAnyOrAllChecker(BaseChecker):</span>
<span class="w"> </span>                        return True
<span class="w"> </span>                return False
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(if_children) != 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        if_child = if_children[0]</span>
<span class="gi">+        if not isinstance(if_child, nodes.Return):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        if not isinstance(if_child.value, nodes.Const) or not isinstance(if_child.value.value, bool):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        if not isinstance(node_after_loop, nodes.Return):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        if not isinstance(node_after_loop.value, nodes.Const) or not isinstance(node_after_loop.value.value, bool):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        return if_child.value.value != node_after_loop.value.value</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _assigned_reassigned_returned(node: nodes.For, if_children: list[
<span class="gu">@@ -44,7 +60,36 @@ class ConsiderUsingAnyOrAllChecker(BaseChecker):</span>
<span class="w"> </span>                    # no elif / else statement
<span class="w"> </span>                return long_line
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.parent, nodes.FunctionDef):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        # Check for boolean assignment before the loop</span>
<span class="gi">+        if len(node.parent.body) &lt; 2 or not isinstance(node.parent.body[0], nodes.Assign):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        assign_node = node.parent.body[0]</span>
<span class="gi">+        if not assigned_bool(assign_node):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        # Check if the loop reassigns the boolean</span>
<span class="gi">+        if len(if_children) != 1 or not isinstance(if_children[0], nodes.Assign):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        reassign_node = if_children[0]</span>
<span class="gi">+        if not isinstance(reassign_node.targets[0], nodes.AssignName) or reassign_node.targets[0].name != assign_node.targets[0].name:</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        if not isinstance(reassign_node.value, nodes.Const) or not isinstance(reassign_node.value.value, bool):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        # Check if the boolean is returned after the loop</span>
<span class="gi">+        if not isinstance(node_after_loop, nodes.Return):</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        if not isinstance(node_after_loop.value, nodes.Name) or node_after_loop.value.name != assign_node.targets[0].name:</span>
<span class="gi">+            return False</span>
<span class="gi">+        </span>
<span class="gi">+        return True</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _build_suggested_string(node: nodes.For, final_return_bool: bool
<span class="gu">@@ -55,4 +100,16 @@ class ConsiderUsingAnyOrAllChecker(BaseChecker):</span>
<span class="w"> </span>        &#39;final_return_bool&#39; is the boolean literal returned after the for loop if all
<span class="w"> </span>        conditions fail.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if_node = node.body[0]</span>
<span class="gi">+        condition = if_node.test</span>
<span class="gi">+        </span>
<span class="gi">+        # Determine if we should use &#39;any&#39; or &#39;all&#39;</span>
<span class="gi">+        func = &#39;any&#39; if not final_return_bool else &#39;all&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        # If the condition is a &#39;not&#39; operation, we need to adjust</span>
<span class="gi">+        if isinstance(condition, nodes.UnaryOp) and condition.op == &#39;not&#39;:</span>
<span class="gi">+            func = &#39;all&#39; if func == &#39;any&#39; else &#39;any&#39;</span>
<span class="gi">+            condition = condition.operand</span>
<span class="gi">+        </span>
<span class="gi">+        # Build the suggested string</span>
<span class="gi">+        return f&quot;{func}({condition} for {node.target.as_string()} in {node.iter.as_string()})&quot;</span>
<span class="gh">diff --git a/pylint/extensions/magic_value.py b/pylint/extensions/magic_value.py</span>
<span class="gh">index 285fb59f4..eab3eeb75 100644</span>
<span class="gd">--- a/pylint/extensions/magic_value.py</span>
<span class="gi">+++ b/pylint/extensions/magic_value.py</span>
<span class="gu">@@ -32,4 +32,16 @@ class MagicValueChecker(BaseChecker):</span>
<span class="w"> </span>        Magic values in any side of the comparison should be avoided,
<span class="w"> </span>        Detects comparisons that `comparison-of-constants` core checker cannot detect.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def is_magic_value(value):</span>
<span class="gi">+            if isinstance(value, (nodes.Const, nodes.UnaryOp)):</span>
<span class="gi">+                const_value = value.value if isinstance(value, nodes.Const) else value.operand.value</span>
<span class="gi">+                return not (isinstance(const_value, (int, float, str)) and const_value in self.valid_magic_vals)</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        left = node.left</span>
<span class="gi">+        for op, right in node.ops:</span>
<span class="gi">+            if is_magic_value(left):</span>
<span class="gi">+                self.add_message(&#39;magic-value-comparison&#39;, node=left, args=left.as_string(), confidence=HIGH)</span>
<span class="gi">+            if is_magic_value(right):</span>
<span class="gi">+                self.add_message(&#39;magic-value-comparison&#39;, node=right, args=right.as_string(), confidence=HIGH)</span>
<span class="gi">+            left = right</span>
<span class="gh">diff --git a/pylint/extensions/mccabe.py b/pylint/extensions/mccabe.py</span>
<span class="gh">index 789246edf..3a121d962 100644</span>
<span class="gd">--- a/pylint/extensions/mccabe.py</span>
<span class="gi">+++ b/pylint/extensions/mccabe.py</span>
<span class="gu">@@ -43,12 +43,41 @@ class PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):</span>
<span class="w"> </span>    def _subgraph(self, node: _SubGraphNodes, name: str, extra_blocks:
<span class="w"> </span>        Sequence[nodes.ExceptHandler]=()) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Create the subgraphs representing any `if` and `for` statements.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.graph is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        self._bottom_counter += 1</span>
<span class="gi">+        subgraph_node = self.graph.new_node(f&#39;subgraph{self._bottom_counter}&#39;)</span>
<span class="gi">+        self.tail = subgraph_node</span>
<span class="gi">+        self.dispatch_list(node.body)</span>
<span class="gi">+        self._subgraph_parse(node, subgraph_node, extra_blocks)</span>

<span class="w"> </span>    def _subgraph_parse(self, node: _SubGraphNodes, pathnode:
<span class="w"> </span>        _SubGraphNodes, extra_blocks: Sequence[nodes.ExceptHandler]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Parse the body and any `else` block of `if` and `for` statements.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.graph is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        </span>
<span class="gi">+        bottom = self.graph.new_node(f&#39;bottom{self._bottom_counter}&#39;)</span>
<span class="gi">+        self.graph.connect(self.tail, bottom)</span>
<span class="gi">+        self.tail = bottom</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(node, (nodes.If, nodes.Try)):</span>
<span class="gi">+            if node.orelse:</span>
<span class="gi">+                self._subgraph(node, &#39;else&#39;)</span>
<span class="gi">+            if isinstance(node, nodes.Try):</span>
<span class="gi">+                for handler in node.handlers:</span>
<span class="gi">+                    self._subgraph(handler, &#39;except&#39;)</span>
<span class="gi">+        elif isinstance(node, nodes.For):</span>
<span class="gi">+            if node.orelse:</span>
<span class="gi">+                self._subgraph(node, &#39;else&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if extra_blocks:</span>
<span class="gi">+            for extra in extra_blocks:</span>
<span class="gi">+                self._subgraph(extra, &#39;except&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        self.graph.connect(pathnode, bottom)</span>
<span class="gi">+        self.tail = bottom</span>


<span class="w"> </span>class McCabeMethodChecker(checkers.BaseChecker):
<span class="gu">@@ -68,4 +97,17 @@ class McCabeMethodChecker(checkers.BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Module node to check too complex rating and
<span class="w"> </span>        add message if is greater than max_complexity stored from options.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        visitor = PathGraphingAstVisitor()</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            if isinstance(child, (nodes.FunctionDef, nodes.AsyncFunctionDef, nodes.ClassDef)):</span>
<span class="gi">+                visitor.graph = None</span>
<span class="gi">+                visitor.visit(child)</span>
<span class="gi">+                if visitor.graph is not None:</span>
<span class="gi">+                    complexity = len(visitor.graph.edges) - len(visitor.graph.nodes) + 2</span>
<span class="gi">+                    if complexity &gt; self.linter.config.max_complexity:</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &#39;too-complex&#39;,</span>
<span class="gi">+                            node=child,</span>
<span class="gi">+                            args=(child.name, complexity),</span>
<span class="gi">+                            confidence=HIGH,</span>
<span class="gi">+                        )</span>
<span class="gh">diff --git a/pylint/extensions/no_self_use.py b/pylint/extensions/no_self_use.py</span>
<span class="gh">index 2f2372c39..41221fe0a 100644</span>
<span class="gd">--- a/pylint/extensions/no_self_use.py</span>
<span class="gi">+++ b/pylint/extensions/no_self_use.py</span>
<span class="gu">@@ -23,12 +23,17 @@ class NoSelfUseChecker(BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the name handle an access to a class member
<span class="w"> </span>        if so, register it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.parent, nodes.Attribute):</span>
<span class="gi">+            if node.name == &#39;self&#39;:</span>
<span class="gi">+                self._first_attrs.append(node.parent.attrname)</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="w"> </span>    def _check_first_arg_for_type(self, node: nodes.FunctionDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check the name of first argument.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.args.args:</span>
<span class="gi">+            first_arg = node.args.args[0]</span>
<span class="gi">+            self._first_attrs = []</span>
<span class="gi">+            self._meth_could_be_func = first_arg.name == &#39;self&#39;</span>

<span class="w"> </span>    def leave_functiondef(self, node: nodes.FunctionDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;On method node, check if this method couldn&#39;t be a function.
<span class="gu">@@ -36,5 +41,24 @@ class NoSelfUseChecker(BaseChecker):</span>
<span class="w"> </span>        ignore class, static and abstract methods, initializer,
<span class="w"> </span>        methods overridden from a parent class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._meth_could_be_func:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t emit a warning if the method is:</span>
<span class="gi">+        if (node.is_method()</span>
<span class="gi">+            and (node.type == &#39;classmethod&#39;</span>
<span class="gi">+                 or node.type == &#39;staticmethod&#39;</span>
<span class="gi">+                 or node.name in PYMETHODS</span>
<span class="gi">+                 or overrides_a_method(node)</span>
<span class="gi">+                 or decorated_with_property(node)</span>
<span class="gi">+                 or is_overload_stub(node)</span>
<span class="gi">+                 or (isinstance(node.parent.frame(), nodes.ClassDef)</span>
<span class="gi">+                     and is_protocol_class(node.parent.frame())))):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t emit a warning if any method attribute is accessed</span>
<span class="gi">+        if set(node.body[0].nodes_of_class(nodes.Attribute)).intersection(self._first_attrs):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&#39;no-self-use&#39;, node=node)</span>
<span class="w"> </span>    leave_asyncfunctiondef = leave_functiondef
<span class="gh">diff --git a/pylint/extensions/overlapping_exceptions.py b/pylint/extensions/overlapping_exceptions.py</span>
<span class="gh">index 518cd8c09..77d5ce5ee 100644</span>
<span class="gd">--- a/pylint/extensions/overlapping_exceptions.py</span>
<span class="gi">+++ b/pylint/extensions/overlapping_exceptions.py</span>
<span class="gu">@@ -23,5 +23,42 @@ class OverlappingExceptionsChecker(checkers.BaseChecker):</span>

<span class="w"> </span>    @utils.only_required_for_messages(&#39;overlapping-except&#39;)
<span class="w"> </span>    def visit_try(self, node: nodes.Try) -&gt;None:
<span class="gd">-        &quot;&quot;&quot;Check for empty except.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;Check for overlapping exceptions in except handlers.&quot;&quot;&quot;</span>
<span class="gi">+        handlers = node.handlers</span>
<span class="gi">+        for i, handler in enumerate(handlers):</span>
<span class="gi">+            if handler.type is None:</span>
<span class="gi">+                # Skip bare except clauses</span>
<span class="gi">+                continue</span>
<span class="gi">+            exceptions = self._get_exceptions(handler.type)</span>
<span class="gi">+            for other_handler in handlers[i + 1:]:</span>
<span class="gi">+                if other_handler.type is None:</span>
<span class="gi">+                    # Skip bare except clauses</span>
<span class="gi">+                    continue</span>
<span class="gi">+                other_exceptions = self._get_exceptions(other_handler.type)</span>
<span class="gi">+                overlapping = self._find_overlapping(exceptions, other_exceptions)</span>
<span class="gi">+                if overlapping:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &#39;overlapping-except&#39;,</span>
<span class="gi">+                        node=handler,</span>
<span class="gi">+                        args=&#39;, &#39;.join(str(ex) for ex in overlapping)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_exceptions(self, node: nodes.NodeNG) -&gt; list[Any]:</span>
<span class="gi">+        &quot;&quot;&quot;Get a list of exception types from an except handler type.&quot;&quot;&quot;</span>
<span class="gi">+        if isinstance(node, nodes.Tuple):</span>
<span class="gi">+            return [</span>
<span class="gi">+                exception</span>
<span class="gi">+                for elt in node.elts</span>
<span class="gi">+                for exception in self._get_exceptions(elt)</span>
<span class="gi">+            ]</span>
<span class="gi">+        return list(_annotated_unpack_infer(node))</span>
<span class="gi">+</span>
<span class="gi">+    def _find_overlapping(self, exceptions1: list[Any], exceptions2: list[Any]) -&gt; list[Any]:</span>
<span class="gi">+        &quot;&quot;&quot;Find overlapping exceptions between two lists of exception types.&quot;&quot;&quot;</span>
<span class="gi">+        overlapping = []</span>
<span class="gi">+        for ex1 in exceptions1:</span>
<span class="gi">+            for ex2 in exceptions2:</span>
<span class="gi">+                if ex1 == ex2 or util.is_subclass(ex1, ex2) or util.is_subclass(ex2, ex1):</span>
<span class="gi">+                    overlapping.append(ex1)</span>
<span class="gi">+                    break</span>
<span class="gi">+        return overlapping</span>
<span class="gh">diff --git a/pylint/extensions/private_import.py b/pylint/extensions/private_import.py</span>
<span class="gh">index 3390b4be5..8d622fca7 100644</span>
<span class="gd">--- a/pylint/extensions/private_import.py</span>
<span class="gi">+++ b/pylint/extensions/private_import.py</span>
<span class="gu">@@ -22,35 +22,50 @@ class PrivateImportChecker(BaseChecker):</span>

<span class="w"> </span>    def _get_private_imports(self, names: list[str]) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Returns the private names from input names by a simple string check.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [name for name in names if self._name_is_private(name)]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _name_is_private(name: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Returns true if the name exists, starts with `_`, and if len(name) &gt; 4
<span class="w"> </span>        it is not a dunder, i.e. it does not begin and end with two underscores.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(name) and name.startswith(&#39;_&#39;) and (len(name) &lt;= 4 or not (name.startswith(&#39;__&#39;) and name.endswith(&#39;__&#39;)))</span>

<span class="w"> </span>    def _get_type_annotation_names(self, node: (nodes.Import | nodes.
<span class="w"> </span>        ImportFrom), names: list[str]) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Removes from names any names that are used as type annotations with no other
<span class="w"> </span>        illegal usages.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.populated_annotations:</span>
<span class="gi">+            self._populate_type_annotations(node.root(), self.all_used_type_annotations)</span>
<span class="gi">+            self.populated_annotations = True</span>
<span class="gi">+        </span>
<span class="gi">+        return [name for name in names if name not in self.all_used_type_annotations or not self.all_used_type_annotations[name]]</span>

<span class="w"> </span>    def _populate_type_annotations(self, node: nodes.LocalsDictNodeNG,
<span class="w"> </span>        all_used_type_annotations: dict[str, bool]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Adds to `all_used_type_annotations` all names ever used as a type annotation
<span class="w"> </span>        in the node&#39;s (nested) scopes and whether they are only used as annotation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child in node.get_children():</span>
<span class="gi">+            if isinstance(child, nodes.FunctionDef):</span>
<span class="gi">+                self._populate_type_annotations_function(child, all_used_type_annotations)</span>
<span class="gi">+            elif isinstance(child, nodes.AnnAssign):</span>
<span class="gi">+                self._populate_type_annotations_annotation(child.annotation, all_used_type_annotations)</span>
<span class="gi">+            elif isinstance(child, nodes.LocalsDictNodeNG):</span>
<span class="gi">+                self._populate_type_annotations(child, all_used_type_annotations)</span>

<span class="w"> </span>    def _populate_type_annotations_function(self, node: nodes.FunctionDef,
<span class="w"> </span>        all_used_type_annotations: dict[str, bool]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Adds all names used as type annotation in the arguments and return type of
<span class="w"> </span>        the function node into the dict `all_used_type_annotations`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for arg in node.args.args + node.args.kwonlyargs:</span>
<span class="gi">+            if arg.annotation:</span>
<span class="gi">+                self._populate_type_annotations_annotation(arg.annotation, all_used_type_annotations)</span>
<span class="gi">+        </span>
<span class="gi">+        if node.returns:</span>
<span class="gi">+            self._populate_type_annotations_annotation(node.returns, all_used_type_annotations)</span>

<span class="w"> </span>    def _populate_type_annotations_annotation(self, node: (nodes.Attribute |
<span class="w"> </span>        nodes.Subscript | nodes.Name | None), all_used_type_annotations:
<span class="gu">@@ -58,16 +73,32 @@ class PrivateImportChecker(BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles the possibility of an annotation either being a Name, i.e. just type,
<span class="w"> </span>        or a Subscript e.g. `Optional[type]` or an Attribute, e.g. `pylint.lint.linter`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, nodes.Name):</span>
<span class="gi">+            all_used_type_annotations[node.name] = all_used_type_annotations.get(node.name, True)</span>
<span class="gi">+            return node.name</span>
<span class="gi">+        elif isinstance(node, nodes.Attribute):</span>
<span class="gi">+            return self._populate_type_annotations_annotation(node.expr, all_used_type_annotations)</span>
<span class="gi">+        elif isinstance(node, nodes.Subscript):</span>
<span class="gi">+            return self._populate_type_annotations_annotation(node.value, all_used_type_annotations)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _assignments_call_private_name(assignments: list[nodes.AnnAssign |
<span class="w"> </span>        nodes.Assign], private_name: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Returns True if no assignments involve accessing `private_name`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for assignment in assignments:</span>
<span class="gi">+            if isinstance(assignment, nodes.AnnAssign):</span>
<span class="gi">+                if private_name in assignment.target.as_string():</span>
<span class="gi">+                    return True</span>
<span class="gi">+            elif isinstance(assignment, nodes.Assign):</span>
<span class="gi">+                if any(private_name in target.as_string() for target in assignment.targets):</span>
<span class="gi">+                    return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def same_root_dir(node: (nodes.Import | nodes.ImportFrom),
<span class="w"> </span>        import_mod_name: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Does the node&#39;s file&#39;s path contain the base name of `import_mod_name`?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node_path = Path(node.root().file)</span>
<span class="gi">+        import_base_name = import_mod_name.split(&#39;.&#39;)[0]</span>
<span class="gi">+        return import_base_name in node_path.parts</span>
<span class="gh">diff --git a/pylint/extensions/set_membership.py b/pylint/extensions/set_membership.py</span>
<span class="gh">index c38482bbd..b9227b8ae 100644</span>
<span class="gd">--- a/pylint/extensions/set_membership.py</span>
<span class="gi">+++ b/pylint/extensions/set_membership.py</span>
<span class="gu">@@ -18,6 +18,20 @@ class SetMembershipChecker(BaseChecker):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize checker instance.&quot;&quot;&quot;
<span class="w"> </span>        super().__init__(linter=linter)

<span class="gi">+    @only_required_for_messages(&#39;use-set-for-membership&#39;)</span>
<span class="gi">+    def visit_compare(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Visit a comparison node.&quot;&quot;&quot;</span>
<span class="gi">+        self._check_in_comparison(node)</span>
<span class="gi">+</span>
<span class="w"> </span>    def _check_in_comparison(self, comparator: nodes.NodeNG) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Checks for membership comparisons with in-place container objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(comparator, nodes.Compare):</span>
<span class="gi">+            if comparator.ops[0][0] in (&#39;in&#39;, &#39;not in&#39;):</span>
<span class="gi">+                right_side = comparator.ops[0][1]</span>
<span class="gi">+                if isinstance(right_side, (nodes.List, nodes.Tuple)):</span>
<span class="gi">+                    # Check if the container has more than 5 elements</span>
<span class="gi">+                    if len(right_side.elts) &gt; 5:</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &#39;use-set-for-membership&#39;,</span>
<span class="gi">+                            node=comparator,</span>
<span class="gi">+                        )</span>
<span class="gh">diff --git a/pylint/extensions/typing.py b/pylint/extensions/typing.py</span>
<span class="gh">index 6458902ba..24c9fb522 100644</span>
<span class="gd">--- a/pylint/extensions/typing.py</span>
<span class="gi">+++ b/pylint/extensions/typing.py</span>
<span class="gu">@@ -115,7 +115,9 @@ class TypingChecker(BaseChecker):</span>

<span class="w"> </span>    def _msg_postponed_eval_hint(self, node: nodes.NodeNG) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Message hint if postponed evaluation isn&#39;t enabled.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not is_postponed_evaluation_enabled(node):</span>
<span class="gi">+            return &quot; (Recommendation only applicable with postponed evaluation enabled)&quot;</span>
<span class="gi">+        return &quot;&quot;</span>

<span class="w"> </span>    def _check_for_alternative_union_syntax(self, node: (nodes.Name | nodes
<span class="w"> </span>        .Attribute), name: str) -&gt;None:
<span class="gu">@@ -126,7 +128,17 @@ class TypingChecker(BaseChecker):</span>
<span class="w"> </span>        - OR: Python 3.7+ with postponed evaluation in
<span class="w"> </span>              a type annotation context
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._should_check_alternative_union_syntax:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if name in UNION_NAMES and is_node_in_type_annotation_context(node):</span>
<span class="gi">+            hint = self._msg_postponed_eval_hint(node)</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-alternative-union-syntax&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(name, hint),</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def _check_for_typing_alias(self, node: (nodes.Name | nodes.Attribute)
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -141,7 +153,22 @@ class TypingChecker(BaseChecker):</span>
<span class="w"> </span>            any name collisions, only ever used in a type annotation
<span class="w"> </span>            context, and can safely be replaced.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._should_check_typing_alias:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        qname = node.as_string()</span>
<span class="gi">+        if qname in DEPRECATED_TYPING_ALIASES:</span>
<span class="gi">+            alias = DEPRECATED_TYPING_ALIASES[qname]</span>
<span class="gi">+            if alias.name_collision:</span>
<span class="gi">+                self._alias_name_collisions.add(alias.name)</span>
<span class="gi">+</span>
<span class="gi">+            parent_subscript = isinstance(node.parent, nodes.Subscript)</span>
<span class="gi">+            msg = DeprecatedTypingAliasMsg(node, qname, alias.name, parent_subscript)</span>
<span class="gi">+</span>
<span class="gi">+            if is_node_in_type_annotation_context(node):</span>
<span class="gi">+                self._consider_using_alias_msgs.append(msg)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._deprecated_typing_alias_msgs.append(msg)</span>

<span class="w"> </span>    @only_required_for_messages(&#39;consider-using-alias&#39;,
<span class="w"> </span>        &#39;deprecated-typing-alias&#39;)
<span class="gu">@@ -151,19 +178,55 @@ class TypingChecker(BaseChecker):</span>

<span class="w"> </span>        Make sure results are safe to recommend / collision free.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for msg in self._deprecated_typing_alias_msgs:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;deprecated-typing-alias&quot;,</span>
<span class="gi">+                node=msg.node,</span>
<span class="gi">+                args=(msg.qname, msg.alias),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        for msg in self._consider_using_alias_msgs:</span>
<span class="gi">+            if msg.alias not in self._alias_name_collisions:</span>
<span class="gi">+                hint = self._msg_postponed_eval_hint(msg.node)</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;consider-using-alias&quot;,</span>
<span class="gi">+                    node=msg.node,</span>
<span class="gi">+                    args=(msg.qname, msg.alias, hint),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        self._deprecated_typing_alias_msgs.clear()</span>
<span class="gi">+        self._consider_using_alias_msgs.clear()</span>
<span class="gi">+        self._alias_name_collisions.clear()</span>

<span class="w"> </span>    def _check_broken_noreturn(self, node: (nodes.Name | nodes.Attribute)
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check for &#39;NoReturn&#39; inside compound types.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.as_string() == TYPING_NORETURN:</span>
<span class="gi">+            parent = node.parent</span>
<span class="gi">+            if isinstance(parent, nodes.Subscript):</span>
<span class="gi">+                self.add_message(&quot;broken-noreturn&quot;, node=node, confidence=HIGH)</span>

<span class="w"> </span>    def _check_broken_callable(self, node: (nodes.Name | nodes.Attribute)
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check for &#39;collections.abc.Callable&#39; inside Optional and Union.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            node.as_string() == &quot;collections.abc.Callable&quot;</span>
<span class="gi">+            and self._broken_callable_location(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;broken-collections-callable&quot;, node=node, confidence=HIGH)</span>

<span class="w"> </span>    def _broken_callable_location(self, node: (nodes.Name | nodes.Attribute)
<span class="w"> </span>        ) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Check if node would be a broken location for collections.abc.Callable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        if isinstance(parent, nodes.Subscript):</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        if isinstance(parent, (nodes.List, nodes.Tuple, nodes.Set)):</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        if isinstance(parent, nodes.Subscript):</span>
<span class="gi">+            value = safe_infer(parent.value)</span>
<span class="gi">+            if value:</span>
<span class="gi">+                return value.qname() in (&quot;typing.Union&quot;, &quot;typing.Optional&quot;)</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/pylint/graph.py b/pylint/graph.py</span>
<span class="gh">index a76f38ae0..28358679a 100644</span>
<span class="gd">--- a/pylint/graph.py</span>
<span class="gi">+++ b/pylint/graph.py</span>
<span class="gu">@@ -14,7 +14,9 @@ from typing import Any</span>

<span class="w"> </span>def target_info_from_filename(filename: str) -&gt;tuple[str, str, str]:
<span class="w"> </span>    &quot;&quot;&quot;Transforms /some/path/foo.png into (&#39;/some/path&#39;, &#39;foo.png&#39;, &#39;png&#39;).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    directory, full_filename = os.path.split(filename)</span>
<span class="gi">+    name, extension = os.path.splitext(full_filename)</span>
<span class="gi">+    return directory, full_filename, extension[1:]  # Remove the dot from extension</span>


<span class="w"> </span>class DotBackend:
<span class="gu">@@ -45,7 +47,9 @@ class DotBackend:</span>

<span class="w"> </span>    def get_source(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns self._source.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._source is None:</span>
<span class="gi">+            self._source = &#39;\n&#39;.join(self.lines)</span>
<span class="gi">+        return self._source</span>
<span class="w"> </span>    source = property(get_source)

<span class="w"> </span>    def generate(self, outputfile: (str | None)=None, mapfile: (str | None)
<span class="gu">@@ -59,30 +63,58 @@ class DotBackend:</span>
<span class="w"> </span>        :return: a path to the generated file
<span class="w"> </span>        :raises RuntimeError: if the executable for rendering was not found
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.emit(&#39;}&#39;)</span>
<span class="gi">+        if outputfile is None:</span>
<span class="gi">+            outputfile = f&#39;{self.graphname}.png&#39;</span>
<span class="gi">+        outputdir, outputfile, outputext = target_info_from_filename(outputfile)</span>
<span class="gi">+        if outputext == &#39;dot&#39;:</span>
<span class="gi">+            with codecs.open(outputfile, &#39;w&#39;, encoding=&#39;utf8&#39;) as outfile:</span>
<span class="gi">+                outfile.write(self.source)</span>
<span class="gi">+            return outputfile</span>
<span class="gi">+</span>
<span class="gi">+        dotfile = tempfile.NamedTemporaryFile(&#39;w&#39;, dir=outputdir, encoding=&#39;utf8&#39;, delete=False)</span>
<span class="gi">+        dotfile.write(self.source)</span>
<span class="gi">+        dotfile.close()</span>
<span class="gi">+        </span>
<span class="gi">+        if shutil.which(self.renderer) is None:</span>
<span class="gi">+            raise RuntimeError(f&quot;&#39;{self.renderer}&#39; executable not found&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        cmdline = [self.renderer, &#39;-T&#39;, outputext, &#39;-o&#39;, outputfile, dotfile.name]</span>
<span class="gi">+        if mapfile:</span>
<span class="gi">+            cmdline.extend([&#39;-Tcmapx&#39;, &#39;-o&#39;, mapfile])</span>
<span class="gi">+        subprocess.run(cmdline, check=True, capture_output=True, text=True)</span>
<span class="gi">+        </span>
<span class="gi">+        os.unlink(dotfile.name)</span>
<span class="gi">+        return outputfile</span>

<span class="w"> </span>    def emit(self, line: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Adds &lt;line&gt; to final output.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.lines.append(line)</span>

<span class="w"> </span>    def emit_edge(self, name1: str, name2: str, **props: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Emit an edge from &lt;name1&gt; to &lt;name2&gt;.

<span class="w"> </span>        For edge properties: see https://www.graphviz.org/doc/info/attrs.html
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        edge = f&#39;{normalize_node_id(name1)} -&gt; {normalize_node_id(name2)}&#39;</span>
<span class="gi">+        if props:</span>
<span class="gi">+            edge += &#39; [&#39; + &#39;,&#39;.join(f&#39;{key}=&quot;{value}&quot;&#39; for key, value in props.items()) + &#39;]&#39;</span>
<span class="gi">+        self.emit(edge + &#39;;&#39;)</span>

<span class="w"> </span>    def emit_node(self, name: str, **props: Any) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Emit a node with given properties.

<span class="w"> </span>        For node properties: see https://www.graphviz.org/doc/info/attrs.html
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node = normalize_node_id(name)</span>
<span class="gi">+        if props:</span>
<span class="gi">+            node += &#39; [&#39; + &#39;,&#39;.join(f&#39;{key}=&quot;{value}&quot;&#39; for key, value in props.items()) + &#39;]&#39;</span>
<span class="gi">+        self.emit(node + &#39;;&#39;)</span>


<span class="w"> </span>def normalize_node_id(nid: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Returns a suitable DOT node id for `nid`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;&quot;%s&quot;&#39; % nid.replace(&#39;&quot;&#39;, &#39;\\&quot;&#39;)</span>


<span class="w"> </span>def get_cycles(graph_dict: dict[str, set[str]], vertices: (list[str] | None
<span class="gu">@@ -90,10 +122,24 @@ def get_cycles(graph_dict: dict[str, set[str]], vertices: (list[str] | None</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a list of detected cycles based on an ordered graph (i.e. keys are
<span class="w"> </span>    vertices and values are lists of destination vertices representing edges).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if vertices is None:</span>
<span class="gi">+        vertices = list(graph_dict.keys())</span>
<span class="gi">+    result: list[list[str]] = []</span>
<span class="gi">+    visited: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+    for vertice in vertices:</span>
<span class="gi">+        if vertice not in visited:</span>
<span class="gi">+            _get_cycles(graph_dict, [vertice], visited, result, vertice)</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def _get_cycles(graph_dict: dict[str, set[str]], path: list[str], visited:
<span class="w"> </span>    set[str], result: list[list[str]], vertice: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Recursive function doing the real work for get_cycles.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    visited.add(vertice)</span>
<span class="gi">+    for neighbor in graph_dict.get(vertice, set()):</span>
<span class="gi">+        if neighbor not in path:</span>
<span class="gi">+            _get_cycles(graph_dict, path + [neighbor], visited, result, neighbor)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result.append(path[path.index(neighbor):])</span>
<span class="gh">diff --git a/pylint/lint/base_options.py b/pylint/lint/base_options.py</span>
<span class="gh">index af170fd04..394b96278 100644</span>
<span class="gd">--- a/pylint/lint/base_options.py</span>
<span class="gi">+++ b/pylint/lint/base_options.py</span>
<span class="gu">@@ -12,9 +12,163 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def _make_linter_options(linter: PyLinter) -&gt;Options:
<span class="w"> </span>    &quot;&quot;&quot;Return the options used in a PyLinter class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;file&gt;[,&lt;file&gt;...]&quot;,</span>
<span class="gi">+                &quot;dest&quot;: &quot;black_list&quot;,</span>
<span class="gi">+                &quot;default&quot;: constants.DEFAULT_IGNORE_LIST,</span>
<span class="gi">+                &quot;help&quot;: &quot;Files or directories to be skipped. They should be base names, not paths.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-patterns&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp_csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;pattern&gt;[,&lt;pattern&gt;...]&quot;,</span>
<span class="gi">+                &quot;dest&quot;: &quot;black_list_re&quot;,</span>
<span class="gi">+                &quot;default&quot;: [],</span>
<span class="gi">+                &quot;help&quot;: &quot;Files or directories matching the regex patterns are skipped. The regex matches against base names, not paths.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;persistent&quot;,</span>
<span class="gi">+            {&quot;help&quot;: &quot;Pickle collected data for later comparisons.&quot;, &quot;type&quot;: &quot;yn&quot;, &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;, &quot;default&quot;: True},</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;load-plugins&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;modules&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: [],</span>
<span class="gi">+                &quot;help&quot;: &quot;List of plugins (as comma separated values of python module names) to load, usually to register additional checkers.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;output-format&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;text&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;format&gt;&quot;,</span>
<span class="gi">+                &quot;short&quot;: &quot;f&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Reports&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Set the output format. Available formats are text,&quot;</span>
<span class="gi">+                &quot; parseable, colorized, json and msvs (visual studio).&quot;</span>
<span class="gi">+                &quot; You can also give a reporter class, e.g.&quot;</span>
<span class="gi">+                &quot; mypackage.mymodule.MyReporterClass.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;reports&quot;,</span>
<span class="gi">+            {&quot;type&quot;: &quot;yn&quot;, &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;, &quot;default&quot;: False, &quot;short&quot;: &quot;r&quot;, &quot;group&quot;: &quot;Reports&quot;, &quot;help&quot;: &quot;Tells whether to display a full report or only the messages.&quot;},</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;evaluation&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;python_expression&gt;&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Reports&quot;,</span>
<span class="gi">+                &quot;default&quot;: &quot;10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Python expression which should return a score less than or equal to 10. You have access to the variables &#39;error&#39;, &#39;warning&#39;, &#39;refactor&#39;, and &#39;convention&#39; which contain the number of messages in each category, as well as &#39;statement&#39; which is the total number of statements analyzed. This score is used by the global evaluation report (RP0004).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;score&quot;,</span>
<span class="gi">+            {&quot;type&quot;: &quot;yn&quot;, &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;, &quot;default&quot;: True, &quot;group&quot;: &quot;Reports&quot;, &quot;help&quot;: &quot;Activate the evaluation score.&quot;},</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;confidence&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;multiple_choice&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;levels&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: [],</span>
<span class="gi">+                &quot;choices&quot;: [c.name for c in interfaces.CONFIDENCE_LEVELS],</span>
<span class="gi">+                &quot;group&quot;: &quot;Messages control&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Only show warnings with the listed confidence levels. Leave empty to show all. Valid levels: %s.&quot; % (&quot;, &quot;.join(c.name for c in interfaces.CONFIDENCE_LEVELS),),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;enable&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;msg ids&gt;&quot;,</span>
<span class="gi">+                &quot;short&quot;: &quot;e&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Messages control&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Enable the message, report, category or checker with the given id(s). You can either give multiple identifier separated by comma (,) or put this option multiple time (only on the command line, not in the configuration file where it should appear only once). See also the &#39;--disable&#39; option for examples.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;disable&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;msg ids&gt;&quot;,</span>
<span class="gi">+                &quot;short&quot;: &quot;d&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Messages control&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Disable the message, report, category or checker with the given id(s). You can either give multiple identifiers separated by comma (,) or put this option multiple times (only on the command line, not in the configuration file where it should appear only once). You can also use &#39;--disable=all&#39; to disable everything first and then re-enable specific checks. For example, if you want to run only the similarities checker, you can use &#39;--disable=all --enable=similarities&#39;. If you want to run only the classes checker, but have no Warning level messages displayed, use &#39;--disable=all --enable=classes --disable=W&#39;.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>def _make_run_options(self: Run) -&gt;Options:
<span class="w"> </span>    &quot;&quot;&quot;Return the options used in a Run class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;version&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;help&quot;: &quot;show program&#39;s version number and exit&quot;,</span>
<span class="gi">+                &quot;action&quot;: &quot;version&quot;,</span>
<span class="gi">+                &quot;version&quot;: f&quot;pylint {constants.__version__}&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;full-documentation&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;help&quot;: &quot;generate pylint&#39;s full documentation&quot;,</span>
<span class="gi">+                &quot;action&quot;: _FullDocumentationAction,</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;generate-rcfile&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;help&quot;: &quot;generate a sample configuration file according to the current configuration&quot;,</span>
<span class="gi">+                &quot;action&quot;: _GenerateRCFileAction,</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;generate-toml-config&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;help&quot;: &quot;generate a configuration file in TOML format&quot;,</span>
<span class="gi">+                &quot;action&quot;: _GenerateConfigFileAction,</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;errors-only&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;help&quot;: &quot;Only display errors&quot;,</span>
<span class="gi">+                &quot;action&quot;: _ErrorsOnlyModeAction,</span>
<span class="gi">+                &quot;group&quot;: &quot;Messages control&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;py3k&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;help&quot;: &quot;Activate Python 3 compatibility checker&quot;,</span>
<span class="gi">+                &quot;action&quot;: _EnableAction,</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;verbose&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;help&quot;: &quot;In verbose mode, extra non-checker-related info will be displayed&quot;,</span>
<span class="gi">+                &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Miscellaneous&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    ]</span>
<span class="gh">diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py</span>
<span class="gh">index e14142cd7..3eda93f33 100644</span>
<span class="gd">--- a/pylint/lint/expand_modules.py</span>
<span class="gi">+++ b/pylint/lint/expand_modules.py</span>
<span class="gu">@@ -10,13 +10,17 @@ from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict</span>

<span class="w"> </span>def discover_package_path(modulepath: str, source_roots: Sequence[str]) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Discover package path from one its modules and source roots.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for source_root in source_roots:</span>
<span class="gi">+        package_path = os.path.commonpath([source_root, modulepath])</span>
<span class="gi">+        if package_path == source_root:</span>
<span class="gi">+            return package_path</span>
<span class="gi">+    return os.path.dirname(modulepath)</span>


<span class="w"> </span>def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]
<span class="w"> </span>    ) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Determines if the element is matched in a regex ignore-list.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(pattern.search(element) for pattern in ignore_list_re)</span>


<span class="w"> </span>def expand_modules(files_or_modules: Sequence[str], source_roots: Sequence[
<span class="gu">@@ -26,4 +30,31 @@ def expand_modules(files_or_modules: Sequence[str], source_roots: Sequence[</span>
<span class="w"> </span>    &quot;&quot;&quot;Take a list of files/modules/packages and return the list of tuple
<span class="w"> </span>    (file, module name) which have to be actually checked.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result: dict[str, ModuleDescriptionDict] = {}</span>
<span class="gi">+    errors: list[ErrorDescriptionDict] = []</span>
<span class="gi">+</span>
<span class="gi">+    for name in files_or_modules:</span>
<span class="gi">+        try:</span>
<span class="gi">+            modname = modutils.get_module_name(name, source_roots)</span>
<span class="gi">+            if modname in ignore_list or _is_in_ignore_list_re(modname, ignore_list_re):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            filepath = modutils.file_from_modpath(modname.split(&#39;.&#39;))</span>
<span class="gi">+            if _is_in_ignore_list_re(str(filepath), ignore_list_paths_re):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            package_path = discover_package_path(str(filepath), source_roots)</span>
<span class="gi">+            result[name] = {</span>
<span class="gi">+                &#39;path&#39;: str(filepath),</span>
<span class="gi">+                &#39;name&#39;: modname,</span>
<span class="gi">+                &#39;package&#39;: package_path,</span>
<span class="gi">+                &#39;basepath&#39;: None,</span>
<span class="gi">+            }</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            errors.append({</span>
<span class="gi">+                &#39;key&#39;: name,</span>
<span class="gi">+                &#39;mod&#39;: modname,</span>
<span class="gi">+                &#39;ex&#39;: sys.exc_info()[1],</span>
<span class="gi">+            })</span>
<span class="gi">+</span>
<span class="gi">+    return result, errors</span>
<span class="gh">diff --git a/pylint/lint/message_state_handler.py b/pylint/lint/message_state_handler.py</span>
<span class="gh">index db36d7947..1a68705db 100644</span>
<span class="gd">--- a/pylint/lint/message_state_handler.py</span>
<span class="gi">+++ b/pylint/lint/message_state_handler.py</span>
<span class="gu">@@ -37,49 +37,82 @@ class _MessageStateHandler:</span>
<span class="w"> </span>    def _set_one_msg_status(self, scope: str, msg: MessageDefinition, line:
<span class="w"> </span>        (int | None), enable: bool) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set the status of an individual message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scope == MSG_STATE_SCOPE_CONFIG:</span>
<span class="gi">+            self._msgs_state[msg.msgid] = enable</span>
<span class="gi">+        elif scope == MSG_STATE_SCOPE_MODULE:</span>
<span class="gi">+            self.file_state.set_msg_status(msg, line, enable)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid scope: {scope}&quot;)</span>

<span class="w"> </span>    def _get_messages_to_set(self, msgid: str, enable: bool, ignore_unknown:
<span class="w"> </span>        bool=False) -&gt;list[MessageDefinition]:
<span class="w"> </span>        &quot;&quot;&quot;Do some tests and find the actual messages of which the status should be set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msgid == &#39;all&#39;:</span>
<span class="gi">+            return list(self.linter.msgs_store.messages)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return [self.linter.msgs_store.get_message_definition(msgid)]</span>
<span class="gi">+        except exceptions.UnknownMessageError:</span>
<span class="gi">+            if ignore_unknown:</span>
<span class="gi">+                return []</span>
<span class="gi">+            raise</span>

<span class="w"> </span>    def _set_msg_status(self, msgid: str, enable: bool, scope: str=
<span class="w"> </span>        &#39;package&#39;, line: (int | None)=None, ignore_unknown: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Do some tests and then iterate over message definitions to set state.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert scope in (MSG_STATE_SCOPE_CONFIG, MSG_STATE_SCOPE_MODULE)</span>
<span class="gi">+        messages = self._get_messages_to_set(msgid, enable, ignore_unknown)</span>
<span class="gi">+        for msg in messages:</span>
<span class="gi">+            self._set_one_msg_status(scope, msg, line, enable)</span>

<span class="w"> </span>    def _register_by_id_managed_msg(self, msgid_or_symbol: str, line: (int |
<span class="w"> </span>        None), is_disabled: bool=True) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;If the msgid is a numeric one, then register it to inform the user
<span class="w"> </span>        it could furnish instead a symbolic msgid.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msgid_or_symbol.isdigit():</span>
<span class="gi">+            try:</span>
<span class="gi">+                symbol = self.linter.msgs_store.get_symbol(msgid_or_symbol)</span>
<span class="gi">+                self.file_state.handle_ignored_message(</span>
<span class="gi">+                    ManagedMessage(msgid_or_symbol, symbol, line, is_disabled)</span>
<span class="gi">+                )</span>
<span class="gi">+            except exceptions.UnknownMessageError:</span>
<span class="gi">+                pass</span>

<span class="w"> </span>    def disable(self, msgid: str, scope: str=&#39;package&#39;, line: (int | None)=
<span class="w"> </span>        None, ignore_unknown: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Disable a message for a scope.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_msg_status(msgid, enable=False, scope=scope, line=line, ignore_unknown=ignore_unknown)</span>

<span class="w"> </span>    def disable_next(self, msgid: str, _: str=&#39;package&#39;, line: (int | None)
<span class="w"> </span>        =None, ignore_unknown: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Disable a message for the next line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if line is None:</span>
<span class="gi">+            line = self.file_state.current_line</span>
<span class="gi">+        self._set_msg_status(msgid, enable=False, scope=MSG_STATE_SCOPE_MODULE, line=line + 1, ignore_unknown=ignore_unknown)</span>

<span class="w"> </span>    def enable(self, msgid: str, scope: str=&#39;package&#39;, line: (int | None)=
<span class="w"> </span>        None, ignore_unknown: bool=False) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Enable a message for a scope.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_msg_status(msgid, enable=True, scope=scope, line=line, ignore_unknown=ignore_unknown)</span>

<span class="w"> </span>    def disable_noerror_messages(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Disable message categories other than `error` and `fatal`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for msgcat, msgids in self.linter.msgs_store._msgs_by_category.items():</span>
<span class="gi">+            if msgcat not in (&#39;error&#39;, &#39;fatal&#39;):</span>
<span class="gi">+                for msgid in msgids:</span>
<span class="gi">+                    self.disable(msgid)</span>

<span class="w"> </span>    def _get_message_state_scope(self, msgid: str, line: (int | None)=None,
<span class="w"> </span>        confidence: (interfaces.Confidence | None)=None) -&gt;(Literal[0, 1, 2
<span class="w"> </span>        ] | None):
<span class="w"> </span>        &quot;&quot;&quot;Returns the scope at which a message was enabled/disabled.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._msgs_state.get(msgid):</span>
<span class="gi">+            return MSG_STATE_SCOPE_CONFIG</span>
<span class="gi">+        if self.file_state.is_message_enabled(msgid, line):</span>
<span class="gi">+            return MSG_STATE_SCOPE_MODULE</span>
<span class="gi">+        if confidence is not None and confidence &gt; HIGH:</span>
<span class="gi">+            return MSG_STATE_CONFIDENCE</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def _is_one_message_enabled(self, msgid: str, line: (int | None)) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Checks state of a single message for the current file.
<span class="gu">@@ -87,7 +120,9 @@ class _MessageStateHandler:</span>
<span class="w"> </span>        This function can&#39;t be cached as it depends on self.file_state which can
<span class="w"> </span>        change.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msgid in self._msgs_state:</span>
<span class="gi">+            return self._msgs_state[msgid]</span>
<span class="gi">+        return self.file_state.is_message_enabled(msgid, line)</span>

<span class="w"> </span>    def is_message_enabled(self, msg_descr: str, line: (int | None)=None,
<span class="w"> </span>        confidence: (interfaces.Confidence | None)=None) -&gt;bool:
<span class="gu">@@ -104,7 +139,16 @@ class _MessageStateHandler:</span>
<span class="w"> </span>        :param line: The line of the currently analysed file
<span class="w"> </span>        :param confidence: The confidence of the message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            msgid = self.linter.msgs_store.get_msg_id(msg_descr)</span>
<span class="gi">+        except exceptions.UnknownMessageError:</span>
<span class="gi">+            # The message doesn&#39;t exist in the store yet, so it must be enabled</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if self._get_message_state_scope(msgid, line, confidence) is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return self._is_one_message_enabled(msgid, line)</span>

<span class="w"> </span>    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Process tokens from the current module to search for module/block level
<span class="gu">@@ -112,4 +156,17 @@ class _MessageStateHandler:</span>

<span class="w"> </span>        See func_block_disable_msg.py test case for expected behaviour.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for (tok_type, content, start, _, _) in tokens:</span>
<span class="gi">+            if tok_type != tokenize.COMMENT:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            match = OPTION_PO.search(content)</span>
<span class="gi">+            if match is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                for pragma_repr in parse_pragma(match.group(&#39;arguments&#39;)):</span>
<span class="gi">+                    pragma = self._parse_pragma(pragma_repr)</span>
<span class="gi">+                    self._handle_pragma(pragma, start[0])</span>
<span class="gi">+            except (InvalidPragmaError, UnRecognizedOptionError):</span>
<span class="gi">+                pass  # Ignore invalid pragmas</span>
<span class="gh">diff --git a/pylint/lint/parallel.py b/pylint/lint/parallel.py</span>
<span class="gh">index a5b179dbe..ede7a4743 100644</span>
<span class="gd">--- a/pylint/lint/parallel.py</span>
<span class="gi">+++ b/pylint/lint/parallel.py</span>
<span class="gu">@@ -29,13 +29,19 @@ def _worker_initialize(linter: bytes, extra_packages_paths: (Sequence[str] |</span>
<span class="w"> </span>    :param linter: A linter-class (PyLinter) instance pickled with dill
<span class="w"> </span>    :param extra_packages_paths: Extra entries to be added to `sys.path`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _worker_linter</span>
<span class="gi">+    _worker_linter = dill.loads(linter)</span>
<span class="gi">+    if extra_packages_paths:</span>
<span class="gi">+        _augment_sys_path(extra_packages_paths)</span>


<span class="w"> </span>def _merge_mapreduce_data(linter: PyLinter, all_mapreduce_data: defaultdict
<span class="w"> </span>    [int, list[defaultdict[str, list[Any]]]]) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Merges map/reduce data across workers, invoking relevant APIs on checkers.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for checker_id, mapreduce_data_list in all_mapreduce_data.items():</span>
<span class="gi">+        checker = linter.get_checker_by_id(checker_id)</span>
<span class="gi">+        if hasattr(checker, &#39;reduce_map_data&#39;):</span>
<span class="gi">+            checker.reduce_map_data(mapreduce_data_list)</span>


<span class="w"> </span>def check_parallel(linter: PyLinter, jobs: int, files: Iterable[FileItem],
<span class="gu">@@ -45,4 +51,29 @@ def check_parallel(linter: PyLinter, jobs: int, files: Iterable[FileItem],</span>
<span class="w"> </span>    This splits the work filestream-by-filestream. If you need to do work across
<span class="w"> </span>    multiple files, as in the similarity-checker, then implement the map/reduce functionality.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if multiprocessing is None or ProcessPoolExecutor is None:</span>
<span class="gi">+        raise ImportError(&quot;Multiprocessing is not available.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    linter_pickle = dill.dumps(linter)</span>
<span class="gi">+    initializer = functools.partial(_worker_initialize, linter_pickle, extra_packages_paths)</span>
<span class="gi">+</span>
<span class="gi">+    with ProcessPoolExecutor(max_workers=jobs, initializer=initializer) as executor:</span>
<span class="gi">+        all_stats = []</span>
<span class="gi">+        all_messages = []</span>
<span class="gi">+        all_mapreduce_data = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        for result in executor.map(lambda f: _worker_linter.check_single_file(f), files):</span>
<span class="gi">+            stats, messages, mapreduce_data = result</span>
<span class="gi">+            all_stats.append(stats)</span>
<span class="gi">+            all_messages.extend(messages)</span>
<span class="gi">+            for checker_id, data in mapreduce_data.items():</span>
<span class="gi">+                all_mapreduce_data[checker_id].append(data)</span>
<span class="gi">+</span>
<span class="gi">+    linter.set_current_module(&quot;&quot;)</span>
<span class="gi">+    linter.stats = merge_stats(all_stats)</span>
<span class="gi">+    linter.stats.current_module = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    for msg in all_messages:</span>
<span class="gi">+        linter.reporter.handle_message(msg)</span>
<span class="gi">+</span>
<span class="gi">+    _merge_mapreduce_data(linter, all_mapreduce_data)</span>
<span class="gh">diff --git a/pylint/lint/pylinter.py b/pylint/lint/pylinter.py</span>
<span class="gh">index 3f632fa03..596c60ccc 100644</span>
<span class="gd">--- a/pylint/lint/pylinter.py</span>
<span class="gi">+++ b/pylint/lint/pylinter.py</span>
<span class="gu">@@ -183,7 +183,18 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>        If `force` is True (useful when multiprocessing), then the plugin is
<span class="w"> </span>        reloaded regardless if an entry exists in self._dynamic_plugins.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for modname in modnames:</span>
<span class="gi">+            if modname in self._dynamic_plugins and not force:</span>
<span class="gi">+                continue</span>
<span class="gi">+            try:</span>
<span class="gi">+                module = utils.load_module_from_name(modname)</span>
<span class="gi">+                self._dynamic_plugins[modname] = module</span>
<span class="gi">+                self.register_plugin(module)</span>
<span class="gi">+            except ModuleNotFoundError as e:</span>
<span class="gi">+                self._dynamic_plugins[modname] = e</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                self._dynamic_plugins[modname] = e</span>
<span class="gi">+                print(f&quot;Failed to load plugin {modname}: {e}&quot;, file=sys.stderr)</span>

<span class="w"> </span>    def load_plugin_configuration(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Call the configuration hook for plugins.
<span class="gu">@@ -201,11 +212,21 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>            in GitHub issue #7264. Making it use the stored result is more efficient, and
<span class="w"> </span>            means that we avoid the ``init-hook`` problems from before.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for plugin_name, plugin in self._dynamic_plugins.items():</span>
<span class="gi">+            if isinstance(plugin, ModuleType):</span>
<span class="gi">+                if hasattr(plugin, &#39;load_configuration&#39;):</span>
<span class="gi">+                    plugin.load_configuration(self)</span>
<span class="gi">+            elif isinstance(plugin, Exception):</span>
<span class="gi">+                print(f&quot;Skipping configuration for plugin {plugin_name} due to previous load error: {plugin}&quot;, file=sys.stderr)</span>

<span class="w"> </span>    def _load_reporters(self, reporter_names: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Load the reporters if they are available on _reporters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for reporter_name in reporter_names.split(&#39;,&#39;):</span>
<span class="gi">+            reporter_name = reporter_name.strip()</span>
<span class="gi">+            if reporter_name in self._reporters:</span>
<span class="gi">+                self.set_reporter(self._reporters[reporter_name]())</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise exceptions.InvalidReporterError(reporter_name)</span>

<span class="w"> </span>    def set_reporter(self, reporter: (reporters.BaseReporter | reporters.
<span class="w"> </span>        MultiReporter)) -&gt;None:
<span class="gh">diff --git a/pylint/lint/report_functions.py b/pylint/lint/report_functions.py</span>
<span class="gh">index eec3528bf..ae4b2ed6d 100644</span>
<span class="gd">--- a/pylint/lint/report_functions.py</span>
<span class="gi">+++ b/pylint/lint/report_functions.py</span>
<span class="gu">@@ -11,16 +11,50 @@ from pylint.utils import LinterStats</span>
<span class="w"> </span>def report_total_messages_stats(sect: Section, stats: LinterStats,
<span class="w"> </span>    previous_stats: (LinterStats | None)) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Make total errors / warnings report.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total = sum(stats.by_msg.values())</span>
<span class="gi">+    sect.append(Table(children=[</span>
<span class="gi">+        (&quot;type&quot;, &quot;number&quot;, &quot;previous&quot;, &quot;difference&quot;),</span>
<span class="gi">+        (&quot;convention&quot;, stats.convention, previous_stats.convention if previous_stats else None,</span>
<span class="gi">+         stats.convention - previous_stats.convention if previous_stats else None),</span>
<span class="gi">+        (&quot;refactor&quot;, stats.refactor, previous_stats.refactor if previous_stats else None,</span>
<span class="gi">+         stats.refactor - previous_stats.refactor if previous_stats else None),</span>
<span class="gi">+        (&quot;warning&quot;, stats.warning, previous_stats.warning if previous_stats else None,</span>
<span class="gi">+         stats.warning - previous_stats.warning if previous_stats else None),</span>
<span class="gi">+        (&quot;error&quot;, stats.error, previous_stats.error if previous_stats else None,</span>
<span class="gi">+         stats.error - previous_stats.error if previous_stats else None),</span>
<span class="gi">+        (&quot;fatal&quot;, stats.fatal, previous_stats.fatal if previous_stats else None,</span>
<span class="gi">+         stats.fatal - previous_stats.fatal if previous_stats else None),</span>
<span class="gi">+        (&quot;total&quot;, total, sum(previous_stats.by_msg.values()) if previous_stats else None,</span>
<span class="gi">+         total - sum(previous_stats.by_msg.values()) if previous_stats else None),</span>
<span class="gi">+    ]))</span>


<span class="w"> </span>def report_messages_stats(sect: Section, stats: LinterStats, _: (
<span class="w"> </span>    LinterStats | None)) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Make messages type report.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    msgs = cast(MessageTypesFullName, collections.Counter(stats.by_msg).most_common())</span>
<span class="gi">+    if msgs:</span>
<span class="gi">+        sect.append(Table(children=[</span>
<span class="gi">+            (&quot;message id&quot;, &quot;occurrences&quot;),</span>
<span class="gi">+            *((msg_id, str(count)) for msg_id, count in msgs)</span>
<span class="gi">+        ]))</span>


<span class="w"> </span>def report_messages_by_module_stats(sect: Section, stats: LinterStats, _: (
<span class="w"> </span>    LinterStats | None)) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Make errors / warnings by modules report.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    by_mod = defaultdict(lambda: defaultdict(int))</span>
<span class="gi">+    for msg_id, msg_info in stats.by_msg.items():</span>
<span class="gi">+        for module in msg_info[&#39;modules&#39;]:</span>
<span class="gi">+            by_mod[module][msg_id] += 1</span>
<span class="gi">+</span>
<span class="gi">+    if by_mod:</span>
<span class="gi">+        sect.append(Table(children=[</span>
<span class="gi">+            (&quot;module&quot;, &quot;error&quot;, &quot;warning&quot;, &quot;refactor&quot;, &quot;convention&quot;),</span>
<span class="gi">+            *((mod,</span>
<span class="gi">+               str(sum(1 for msg_id in msgs if msg_id[0] == &#39;E&#39;)),</span>
<span class="gi">+               str(sum(1 for msg_id in msgs if msg_id[0] == &#39;W&#39;)),</span>
<span class="gi">+               str(sum(1 for msg_id in msgs if msg_id[0] == &#39;R&#39;)),</span>
<span class="gi">+               str(sum(1 for msg_id in msgs if msg_id[0] == &#39;C&#39;)))</span>
<span class="gi">+              for mod, msgs in sorted(by_mod.items()))</span>
<span class="gi">+        ]))</span>
<span class="gh">diff --git a/pylint/lint/run.py b/pylint/lint/run.py</span>
<span class="gh">index 646f5ae00..f03eabb89 100644</span>
<span class="gd">--- a/pylint/lint/run.py</span>
<span class="gi">+++ b/pylint/lint/run.py</span>
<span class="gu">@@ -32,14 +32,38 @@ def _query_cpu() -&gt;(int | None):</span>
<span class="w"> </span>    This is based on discussion and copied from suggestions in
<span class="w"> </span>    https://bugs.python.org/issue36054.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        with open(&#39;/sys/fs/cgroup/cpu/cpu.cfs_quota_us&#39;) as quota_file:</span>
<span class="gi">+            quota = int(quota_file.read())</span>
<span class="gi">+        with open(&#39;/sys/fs/cgroup/cpu/cpu.cfs_period_us&#39;) as period_file:</span>
<span class="gi">+            period = int(period_file.read())</span>
<span class="gi">+        if quota &gt; 0 and period &gt; 0:</span>
<span class="gi">+            return max(1, quota // period)</span>
<span class="gi">+    except (FileNotFoundError, ValueError, ZeroDivisionError):</span>
<span class="gi">+        pass</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def _cpu_count() -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Use sched_affinity if available for virtualized or containerized
<span class="w"> </span>    environments.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        import psutil</span>
<span class="gi">+        return len(psutil.Process().cpu_affinity())</span>
<span class="gi">+    except (ImportError, AttributeError):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    docker_cpu = _query_cpu()</span>
<span class="gi">+    if docker_cpu:</span>
<span class="gi">+        return docker_cpu</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return len(os.sched_getaffinity(0))</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return os.cpu_count() or 1</span>


<span class="w"> </span>class Run:
<span class="gh">diff --git a/pylint/lint/utils.py b/pylint/lint/utils.py</span>
<span class="gh">index ec27fb7a9..bc60c7af6 100644</span>
<span class="gd">--- a/pylint/lint/utils.py</span>
<span class="gi">+++ b/pylint/lint/utils.py</span>
<span class="gu">@@ -12,7 +12,14 @@ from pylint.constants import PYLINT_HOME, full_version</span>
<span class="w"> </span>@contextlib.contextmanager
<span class="w"> </span>def augmented_sys_path(additional_paths: Sequence[str]) -&gt;Iterator[None]:
<span class="w"> </span>    &quot;&quot;&quot;Augment &#39;sys.path&#39; by adding non-existent entries from additional_paths.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    original_sys_path = sys.path.copy()</span>
<span class="gi">+    try:</span>
<span class="gi">+        for path in additional_paths:</span>
<span class="gi">+            if path not in sys.path:</span>
<span class="gi">+                sys.path.insert(0, path)</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        sys.path[:] = original_sys_path</span>


<span class="w"> </span>def _is_relative_to(self: Path, *other: Path) -&gt;bool:
<span class="gu">@@ -21,4 +28,8 @@ def _is_relative_to(self: Path, *other: Path) -&gt;bool:</span>
<span class="w"> </span>    Backport of pathlib.Path.is_relative_to for Python &lt;3.9
<span class="w"> </span>    TODO: py39: Remove this backport and use stdlib function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        self.relative_to(*other)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/pylint/message/_deleted_message_ids.py b/pylint/message/_deleted_message_ids.py</span>
<span class="gh">index dbcd3d0ab..e5c14b31c 100644</span>
<span class="gd">--- a/pylint/message/_deleted_message_ids.py</span>
<span class="gi">+++ b/pylint/message/_deleted_message_ids.py</span>
<span class="gu">@@ -86,22 +86,41 @@ MOVED_TO_EXTENSIONS = {</span>
<span class="w"> </span>@lru_cache(maxsize=None)
<span class="w"> </span>def is_deleted_symbol(symbol: str) -&gt;(str | None):
<span class="w"> </span>    &quot;&quot;&quot;Return the explanation for removal if the message was removed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for explanation, messages in DELETED_MESSAGES_IDS.items():</span>
<span class="gi">+        for message in messages:</span>
<span class="gi">+            if symbol == message.symbol or any(symbol == old[1] for old in message.old_names):</span>
<span class="gi">+                return explanation</span>
<span class="gi">+    return None</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="w"> </span>def is_deleted_msgid(msgid: str) -&gt;(str | None):
<span class="w"> </span>    &quot;&quot;&quot;Return the explanation for removal if the message was removed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for explanation, messages in DELETED_MESSAGES_IDS.items():</span>
<span class="gi">+        for message in messages:</span>
<span class="gi">+            if msgid == message.msgid or any(msgid == old[0] for old in message.old_names):</span>
<span class="gi">+                return explanation</span>
<span class="gi">+    for prefix in DELETED_MSGID_PREFIXES:</span>
<span class="gi">+        if msgid.startswith(f&quot;{prefix:04d}&quot;):</span>
<span class="gi">+            return &quot;This message ID prefix has been deleted.&quot;</span>
<span class="gi">+    return None</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="w"> </span>def is_moved_symbol(symbol: str) -&gt;(str | None):
<span class="w"> </span>    &quot;&quot;&quot;Return the explanation for moving if the message was moved to extensions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for explanation, messages in MOVED_TO_EXTENSIONS.items():</span>
<span class="gi">+        for message in messages:</span>
<span class="gi">+            if symbol == message.symbol or any(symbol == old[1] for old in message.old_names):</span>
<span class="gi">+                return explanation</span>
<span class="gi">+    return None</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="w"> </span>def is_moved_msgid(msgid: str) -&gt;(str | None):
<span class="w"> </span>    &quot;&quot;&quot;Return the explanation for moving if the message was moved to extensions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for explanation, messages in MOVED_TO_EXTENSIONS.items():</span>
<span class="gi">+        for message in messages:</span>
<span class="gi">+            if msgid == message.msgid or any(msgid == old[0] for old in message.old_names):</span>
<span class="gi">+                return explanation</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/pylint/message/message.py b/pylint/message/message.py</span>
<span class="gh">index f8eac91be..8b766efcc 100644</span>
<span class="gd">--- a/pylint/message/message.py</span>
<span class="gi">+++ b/pylint/message/message.py</span>
<span class="gu">@@ -47,4 +47,4 @@ class Message:</span>
<span class="w"> </span>        The template format is the one of the format method :
<span class="w"> </span>        cf. https://docs.python.org/2/library/string.html#formatstrings
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return template.format(**asdict(self))</span>
<span class="gh">diff --git a/pylint/message/message_definition.py b/pylint/message/message_definition.py</span>
<span class="gh">index 4ae7655d2..4e406ce1d 100644</span>
<span class="gd">--- a/pylint/message/message_definition.py</span>
<span class="gi">+++ b/pylint/message/message_definition.py</span>
<span class="gu">@@ -46,13 +46,33 @@ class MessageDefinition:</span>
<span class="w"> </span>    def may_be_emitted(self, py_version: (tuple[int, ...] | sys._version_info)
<span class="w"> </span>        ) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;May the message be emitted using the configured py_version?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.minversion is not None and py_version &lt; self.minversion:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if self.maxversion is not None and py_version &gt; self.maxversion:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def format_help(self, checkerref: bool=False) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Return the help string for the given message id.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = f&#39;{self.msg} ({self.symbol})&#39;</span>
<span class="gi">+        if checkerref:</span>
<span class="gi">+            result += f&#39;\n    ({self.checker_name})&#39;</span>
<span class="gi">+        result += f&#39;\n{normalize_text(self.description)}&#39;</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def check_message_definition(self, line: (int | None), node: (nodes.
<span class="w"> </span>        NodeNG | None)) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Check MessageDefinition for possible errors.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.msgid[1] not in MSG_TYPES:</span>
<span class="gi">+            raise InvalidMessageError(</span>
<span class="gi">+                f&#39;Invalid message type {self.msgid[1]} in {self.msgid}&#39;)</span>
<span class="gi">+        if self.symbol in _SCOPE_EXEMPT:</span>
<span class="gi">+            return</span>
<span class="gi">+        if self.scope == WarningScope.LINE:</span>
<span class="gi">+            if line is None:</span>
<span class="gi">+                raise InvalidMessageError(</span>
<span class="gi">+                    f&#39;Message {self.msgid} must provide line, got None&#39;)</span>
<span class="gi">+        elif self.scope == WarningScope.NODE:</span>
<span class="gi">+            if node is None:</span>
<span class="gi">+                raise InvalidMessageError(</span>
<span class="gi">+                    f&#39;Message {self.msgid} must provide node, got None&#39;)</span>
<span class="gh">diff --git a/pylint/message/message_definition_store.py b/pylint/message/message_definition_store.py</span>
<span class="gh">index 98137664d..6d3063705 100644</span>
<span class="gd">--- a/pylint/message/message_definition_store.py</span>
<span class="gi">+++ b/pylint/message/message_definition_store.py</span>
<span class="gu">@@ -27,15 +27,18 @@ class MessageDefinitionStore:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def messages(self) -&gt;ValuesView[MessageDefinition]:
<span class="w"> </span>        &quot;&quot;&quot;The list of all active messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._messages_definitions.values()</span>

<span class="w"> </span>    def register_messages_from_checker(self, checker: BaseChecker) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Register all messages definitions from a checker.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for message in checker.messages:</span>
<span class="gi">+            self.register_message(message)</span>

<span class="w"> </span>    def register_message(self, message: MessageDefinition) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Register a MessageDefinition with consistency in mind.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.message_id_store.register_message_definition(message)</span>
<span class="gi">+        self._messages_definitions[message.symbol] = message</span>
<span class="gi">+        self._msgs_by_category[message.category].append(message.symbol)</span>

<span class="w"> </span>    @functools.lru_cache(maxsize=None)
<span class="w"> </span>    def get_message_definitions(self, msgid_or_symbol: str) -&gt;list[
<span class="gu">@@ -46,21 +49,55 @@ class MessageDefinitionStore:</span>
<span class="w"> </span>        about 1000 characters, so even if we would have 1000 messages the cache would only
<span class="w"> </span>        take up ~= 1 Mb.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return [self._messages_definitions[msgid_or_symbol]]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return [self._messages_definitions[self.message_id_store.get_symbol(msgid_or_symbol)]]</span>
<span class="gi">+            except UnknownMessageError:</span>
<span class="gi">+                return []</span>

<span class="w"> </span>    def get_msg_display_string(self, msgid_or_symbol: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Generates a user-consumable representation of a message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message_definitions = self.get_message_definitions(msgid_or_symbol)</span>
<span class="gi">+        if not message_definitions:</span>
<span class="gi">+            raise UnknownMessageError(msgid_or_symbol)</span>
<span class="gi">+        message = message_definitions[0]</span>
<span class="gi">+        return f&quot;{message.symbol} ({message.msgid}): {message.msg}&quot;</span>

<span class="w"> </span>    def help_message(self, msgids_or_symbols: Sequence[str]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Display help messages for the given message identifiers.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for msgid_or_symbol in msgids_or_symbols:</span>
<span class="gi">+            try:</span>
<span class="gi">+                for message in self.get_message_definitions(msgid_or_symbol):</span>
<span class="gi">+                    print(self.get_msg_display_string(msgid_or_symbol))</span>
<span class="gi">+                    print(f&quot;  {message.description}&quot;)</span>
<span class="gi">+            except UnknownMessageError:</span>
<span class="gi">+                print(f&quot;No such message id or symbol &#39;{msgid_or_symbol}&#39;&quot;)</span>

<span class="w"> </span>    def list_messages(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Output full messages list documentation in ReST format.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        by_category = sorted(self._msgs_by_category.items())</span>
<span class="gi">+        for category, symbols in by_category:</span>
<span class="gi">+            print(f&quot;:{category}:&quot;)</span>
<span class="gi">+            print(f&quot;  Messages related to {category}&quot;)</span>
<span class="gi">+            print()</span>
<span class="gi">+            for symbol in sorted(symbols):</span>
<span class="gi">+                message = self._messages_definitions[symbol]</span>
<span class="gi">+                print(f&quot;:{symbol}: *{message.msgid}*&quot;)</span>
<span class="gi">+                print(f&quot;  {message.msg}&quot;)</span>
<span class="gi">+                print()</span>
<span class="gi">+                print(f&quot;  {message.description}&quot;)</span>
<span class="gi">+                print()</span>

<span class="w"> </span>    def find_emittable_messages(self) -&gt;tuple[list[MessageDefinition], list
<span class="w"> </span>        [MessageDefinition]]:
<span class="w"> </span>        &quot;&quot;&quot;Finds all emittable and non-emittable messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        emittable = []</span>
<span class="gi">+        non_emittable = []</span>
<span class="gi">+        for message in self.messages:</span>
<span class="gi">+            if message.may_be_emitted():</span>
<span class="gi">+                emittable.append(message)</span>
<span class="gi">+            else:</span>
<span class="gi">+                non_emittable.append(message)</span>
<span class="gi">+        return emittable, non_emittable</span>
<span class="gh">diff --git a/pylint/message/message_id_store.py b/pylint/message/message_id_store.py</span>
<span class="gh">index 64562013d..d78d2bc4c 100644</span>
<span class="gd">--- a/pylint/message/message_id_store.py</span>
<span class="gi">+++ b/pylint/message/message_id_store.py</span>
<span class="gu">@@ -31,7 +31,12 @@ class MessageIdStore:</span>
<span class="w"> </span>        There is a little duplication with add_legacy_msgid_and_symbol to avoid a function call,
<span class="w"> </span>        this is called a lot at initialization.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if symbol in self.__symbol_to_msgid:</span>
<span class="gi">+            self._raise_duplicate_symbol(msgid, symbol, self.__symbol_to_msgid[symbol])</span>
<span class="gi">+        if msgid in self.__msgid_to_symbol:</span>
<span class="gi">+            self._raise_duplicate_msgid(symbol, msgid, self.__msgid_to_symbol[msgid])</span>
<span class="gi">+        self.__symbol_to_msgid[symbol] = msgid</span>
<span class="gi">+        self.__msgid_to_symbol[msgid] = symbol</span>

<span class="w"> </span>    def add_legacy_msgid_and_symbol(self, msgid: str, symbol: str,
<span class="w"> </span>        new_msgid: str) -&gt;None:
<span class="gu">@@ -40,23 +45,53 @@ class MessageIdStore:</span>
<span class="w"> </span>        There is a little duplication with add_msgid_and_symbol to avoid a function call,
<span class="w"> </span>        this is called a lot at initialization.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if symbol in self.__symbol_to_msgid:</span>
<span class="gi">+            self._raise_duplicate_symbol(msgid, symbol, self.__symbol_to_msgid[symbol])</span>
<span class="gi">+        if msgid in self.__msgid_to_symbol:</span>
<span class="gi">+            self._raise_duplicate_msgid(symbol, msgid, self.__msgid_to_symbol[msgid])</span>
<span class="gi">+        self.__symbol_to_msgid[symbol] = new_msgid</span>
<span class="gi">+        self.__msgid_to_symbol[msgid] = symbol</span>
<span class="gi">+        self.__old_names.setdefault(new_msgid, []).append(msgid)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _raise_duplicate_symbol(msgid: str, symbol: str, other_symbol: str
<span class="w"> </span>        ) -&gt;NoReturn:
<span class="w"> </span>        &quot;&quot;&quot;Raise an error when a symbol is duplicated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise InvalidMessageError(</span>
<span class="gi">+            f&quot;Message symbol &#39;{symbol}&#39; cannot be associated to &#39;{msgid}&#39; because it is &quot;</span>
<span class="gi">+            f&quot;already associated to message id &#39;{other_symbol}&#39;&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _raise_duplicate_msgid(symbol: str, msgid: str, other_msgid: str
<span class="w"> </span>        ) -&gt;NoReturn:
<span class="w"> </span>        &quot;&quot;&quot;Raise an error when a msgid is duplicated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise InvalidMessageError(</span>
<span class="gi">+            f&quot;Message id &#39;{msgid}&#39; cannot be associated to &#39;{symbol}&#39; because it is &quot;</span>
<span class="gi">+            f&quot;already associated to message symbol &#39;{other_msgid}&#39;&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def get_active_msgids(self, msgid_or_symbol: str) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Return msgids but the input can be a symbol.

<span class="w"> </span>        self.__active_msgids is used to implement a primitive cache for this function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msgid_or_symbol in self.__active_msgids:</span>
<span class="gi">+            return self.__active_msgids[msgid_or_symbol]</span>
<span class="gi">+</span>
<span class="gi">+        if msgid_or_symbol in self.__symbol_to_msgid:</span>
<span class="gi">+            msgid = self.__symbol_to_msgid[msgid_or_symbol]</span>
<span class="gi">+        elif msgid_or_symbol in self.__msgid_to_symbol:</span>
<span class="gi">+            msgid = msgid_or_symbol</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise UnknownMessageError(f&quot;No such message id or symbol &#39;{msgid_or_symbol}&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if is_deleted_msgid(msgid) or is_deleted_symbol(msgid_or_symbol):</span>
<span class="gi">+            raise DeletedMessageError(f&quot;Message &#39;{msgid_or_symbol}&#39; has been deleted&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if is_moved_msgid(msgid) or is_moved_symbol(msgid_or_symbol):</span>
<span class="gi">+            raise MessageBecameExtensionError(f&quot;Message &#39;{msgid_or_symbol}&#39; has been moved to an extension&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        active_msgids = [msgid] + self.__old_names.get(msgid, [])</span>
<span class="gi">+        self.__active_msgids[msgid_or_symbol] = active_msgids</span>
<span class="gi">+        return active_msgids</span>
<span class="gh">diff --git a/pylint/pyreverse/diadefslib.py b/pylint/pyreverse/diadefslib.py</span>
<span class="gh">index 4865d5ddc..4605d82e6 100644</span>
<span class="gd">--- a/pylint/pyreverse/diadefslib.py</span>
<span class="gi">+++ b/pylint/pyreverse/diadefslib.py</span>
<span class="gu">@@ -24,42 +24,70 @@ class DiaDefGenerator:</span>

<span class="w"> </span>    def get_title(self, node: nodes.ClassDef) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Get title for objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return node.name if self.module_names else node.root().name + &#39;.&#39; + node.name</span>

<span class="w"> </span>    def _set_option(self, option: (bool | None)) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Activate some options if not explicitly deactivated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return bool(option) if option is not None else self.config.all_ancestors</span>

<span class="w"> </span>    def _set_default_options(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set different default options with _default dictionary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.show_ancestors = self._set_option(self.config.show_ancestors)</span>
<span class="gi">+        self.all_ancestors = self._set_option(self.config.all_ancestors)</span>
<span class="gi">+        self.show_associated = self._set_option(self.config.show_associated)</span>
<span class="gi">+        self.show_builtin = self._set_option(self.config.show_builtin)</span>
<span class="gi">+        self.module_names = self._set_option(self.config.module_names)</span>

<span class="w"> </span>    def _get_levels(self) -&gt;tuple[int, int]:
<span class="w"> </span>        &quot;&quot;&quot;Help function for search levels.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (self.config.show_ancestors, self.config.show_associated)</span>

<span class="w"> </span>    def show_node(self, node: nodes.ClassDef) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Determine if node should be shown based on config.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, nodes.Module):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(node, nodes.ClassDef):</span>
<span class="gi">+            if self.show_builtin or not is_stdlib_module(node.root().name):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def add_class(self, node: nodes.ClassDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit one class and add it to diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.show_node(node):</span>
<span class="gi">+            self.classdiagram.add_object(self.get_title(node), node)</span>

<span class="w"> </span>    def get_ancestors(self, node: nodes.ClassDef, level: int) -&gt;Generator[
<span class="w"> </span>        nodes.ClassDef, None, None]:
<span class="w"> </span>        &quot;&quot;&quot;Return ancestor nodes of a class node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if level == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        for ancestor in node.ancestors():</span>
<span class="gi">+            if self.show_node(ancestor):</span>
<span class="gi">+                yield ancestor</span>
<span class="gi">+            if self.all_ancestors:</span>
<span class="gi">+                yield from self.get_ancestors(ancestor, level - 1)</span>

<span class="w"> </span>    def get_associated(self, klass_node: nodes.ClassDef, level: int
<span class="w"> </span>        ) -&gt;Generator[nodes.ClassDef, None, None]:
<span class="w"> </span>        &quot;&quot;&quot;Return associated nodes of a class node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if level == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        for ass_nodes in klass_node.instance_attrs_type.values():</span>
<span class="gi">+            for ass_node in ass_nodes:</span>
<span class="gi">+                if isinstance(ass_node, nodes.ClassDef) and self.show_node(ass_node):</span>
<span class="gi">+                    yield ass_node</span>
<span class="gi">+                    yield from self.get_associated(ass_node, level - 1)</span>

<span class="w"> </span>    def extract_classes(self, klass_node: nodes.ClassDef, anc_level: int,
<span class="w"> </span>        association_level: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Extract recursively classes related to klass_node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_class(klass_node)</span>
<span class="gi">+        for ancestor in self.get_ancestors(klass_node, anc_level):</span>
<span class="gi">+            self.add_class(ancestor)</span>
<span class="gi">+            self.classdiagram.add_relationship(klass_node, ancestor, &#39;specialization&#39;)</span>
<span class="gi">+        for associated in self.get_associated(klass_node, association_level):</span>
<span class="gi">+            self.add_class(associated)</span>
<span class="gi">+            self.classdiagram.add_relationship(klass_node, associated, &#39;association&#39;)</span>


<span class="w"> </span>class DefaultDiadefGenerator(LocalsVisitor, DiaDefGenerator):
<span class="gu">@@ -78,32 +106,33 @@ class DefaultDiadefGenerator(LocalsVisitor, DiaDefGenerator):</span>

<span class="w"> </span>        create a diagram definition for packages
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.pkgdiagram = PackageDiagram(&#39;packages&#39;, node)</span>

<span class="w"> </span>    def leave_project(self, _: Project) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;Leave the pyreverse.utils.Project node.

<span class="w"> </span>        return the generated diagram definition
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.pkgdiagram</span>

<span class="w"> </span>    def visit_module(self, node: nodes.Module) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Module node.

<span class="w"> </span>        add this class to the package diagram definition
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.pkgdiagram.add_object(node.name, node)</span>

<span class="w"> </span>    def visit_classdef(self, node: nodes.ClassDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Class node.

<span class="w"> </span>        add this class to the class diagram definition
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_class(node)</span>

<span class="w"> </span>    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit astroid.ImportFrom  and catch modules for package diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.level == 0 and not node.modname.startswith(&#39;.&#39;):</span>
<span class="gi">+            self.pkgdiagram.add_relationship(node.root(), node.modname, &#39;imports&#39;)</span>


<span class="w"> </span>class ClassDiadefGenerator(DiaDefGenerator):
<span class="gu">@@ -114,7 +143,10 @@ class ClassDiadefGenerator(DiaDefGenerator):</span>
<span class="w"> </span>    def class_diagram(self, project: Project, klass: nodes.ClassDef
<span class="w"> </span>        ) -&gt;ClassDiagram:
<span class="w"> </span>        &quot;&quot;&quot;Return a class diagram definition for the class and related classes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.classdiagram = ClassDiagram(klass.name, klass)</span>
<span class="gi">+        self.linker.project = project</span>
<span class="gi">+        self.extract_classes(klass, self.config.show_ancestors, self.config.show_associated)</span>
<span class="gi">+        return self.classdiagram</span>


<span class="w"> </span>class DiadefsHandler:
<span class="gu">@@ -135,4 +167,12 @@ class DiadefsHandler:</span>
<span class="w"> </span>        :returns: The list of diagram definitions
<span class="w"> </span>        :rtype: list(:class:`pylint.pyreverse.diagrams.ClassDiagram`)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        diagrams = []</span>
<span class="gi">+        generator = DefaultDiadefGenerator(linker, self)</span>
<span class="gi">+        diagrams.append(generator.visit(project))</span>
<span class="gi">+        </span>
<span class="gi">+        for klass in project.get_classes():</span>
<span class="gi">+            generator = ClassDiadefGenerator(linker, self)</span>
<span class="gi">+            diagrams.append(generator.class_diagram(project, klass))</span>
<span class="gi">+        </span>
<span class="gi">+        return diagrams</span>
<span class="gh">diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py</span>
<span class="gh">index e1f5e7682..acf1fde8f 100644</span>
<span class="gd">--- a/pylint/pyreverse/diagrams.py</span>
<span class="gi">+++ b/pylint/pyreverse/diagrams.py</span>
<span class="gu">@@ -70,48 +70,82 @@ class ClassDiagram(Figure, FilterMixIn):</span>
<span class="w"> </span>    def add_relationship(self, from_object: DiagramEntity, to_object:
<span class="w"> </span>        DiagramEntity, relation_type: str, name: (str | None)=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Create a relationship.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rel = Relationship(from_object, to_object, relation_type, name)</span>
<span class="gi">+        self.relationships.setdefault(relation_type, []).append(rel)</span>

<span class="w"> </span>    def get_relationship(self, from_object: DiagramEntity, relation_type: str
<span class="w"> </span>        ) -&gt;Relationship:
<span class="w"> </span>        &quot;&quot;&quot;Return a relationship or None.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rel in self.relationships.get(relation_type, []):</span>
<span class="gi">+            if rel.from_object == from_object:</span>
<span class="gi">+                return rel</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_attrs(self, node: nodes.ClassDef) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Return visible attributes, possibly with class name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attrs = []</span>
<span class="gi">+        for attr in node.instance_attrs.items():</span>
<span class="gi">+            if self.show_attr(attr):</span>
<span class="gi">+                attrs.append(attr[0])</span>
<span class="gi">+        for attr in node.locals.items():</span>
<span class="gi">+            if self.show_attr(attr):</span>
<span class="gi">+                attrs.append(attr[0])</span>
<span class="gi">+        return attrs</span>

<span class="w"> </span>    def get_methods(self, node: nodes.ClassDef) -&gt;list[nodes.FunctionDef]:
<span class="w"> </span>        &quot;&quot;&quot;Return visible methods.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        methods = []</span>
<span class="gi">+        for method in node.mymethods():</span>
<span class="gi">+            if self.show_attr(method):</span>
<span class="gi">+                methods.append(method)</span>
<span class="gi">+        return methods</span>

<span class="w"> </span>    def add_object(self, title: str, node: nodes.ClassDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Create a diagram object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        entity = ClassEntity(title, node)</span>
<span class="gi">+        entity.attrs = self.get_attrs(node)</span>
<span class="gi">+        entity.methods = self.get_methods(node)</span>
<span class="gi">+        self.objects.append(entity)</span>
<span class="gi">+        self._nodes[node] = entity</span>

<span class="w"> </span>    def class_names(self, nodes_lst: Iterable[nodes.NodeNG]) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;Return class names if needed in diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [n.name for n in nodes_lst if isinstance(n, nodes.ClassDef) and self.has_node(n)]</span>

<span class="w"> </span>    def has_node(self, node: nodes.NodeNG) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Return true if the given node is included in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return node in self._nodes</span>

<span class="w"> </span>    def object_from_node(self, node: nodes.NodeNG) -&gt;DiagramEntity:
<span class="w"> </span>        &quot;&quot;&quot;Return the diagram object mapped to node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._nodes.get(node)</span>

<span class="w"> </span>    def classes(self) -&gt;list[ClassEntity]:
<span class="w"> </span>        &quot;&quot;&quot;Return all class nodes in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [o for o in self.objects if isinstance(o, ClassEntity)]</span>

<span class="w"> </span>    def classe(self, name: str) -&gt;ClassEntity:
<span class="w"> </span>        &quot;&quot;&quot;Return a class by its name, raise KeyError if not found.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cls in self.classes():</span>
<span class="gi">+            if cls.node.name == name:</span>
<span class="gi">+                return cls</span>
<span class="gi">+        raise KeyError(f&quot;No class named {name}&quot;)</span>

<span class="w"> </span>    def extract_relationships(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Extract relationships between nodes in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for obj in self.classes():</span>
<span class="gi">+            node = obj.node</span>
<span class="gi">+            for parent in node.bases:</span>
<span class="gi">+                parent_node = parent.inferred()[0]</span>
<span class="gi">+                if self.has_node(parent_node):</span>
<span class="gi">+                    parent_obj = self.object_from_node(parent_node)</span>
<span class="gi">+                    self.add_relationship(obj, parent_obj, &quot;inherits&quot;)</span>
<span class="gi">+            for member in node.body:</span>
<span class="gi">+                if isinstance(member, nodes.AnnAssign):</span>
<span class="gi">+                    member_node = member.annotation.inferred()[0]</span>
<span class="gi">+                    if self.has_node(member_node):</span>
<span class="gi">+                        member_obj = self.object_from_node(member_node)</span>
<span class="gi">+                        self.add_relationship(obj, member_obj, &quot;association&quot;)</span>


<span class="w"> </span>class PackageDiagram(ClassDiagram):
<span class="gu">@@ -120,26 +154,59 @@ class PackageDiagram(ClassDiagram):</span>

<span class="w"> </span>    def modules(self) -&gt;list[PackageEntity]:
<span class="w"> </span>        &quot;&quot;&quot;Return all module nodes in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [o for o in self.objects if isinstance(o, PackageEntity)]</span>

<span class="w"> </span>    def module(self, name: str) -&gt;PackageEntity:
<span class="w"> </span>        &quot;&quot;&quot;Return a module by its name, raise KeyError if not found.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for mod in self.modules():</span>
<span class="gi">+            if mod.node.name == name:</span>
<span class="gi">+                return mod</span>
<span class="gi">+        raise KeyError(f&quot;No module named {name}&quot;)</span>

<span class="w"> </span>    def add_object(self, title: str, node: nodes.Module) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Create a diagram object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        entity = PackageEntity(title, node)</span>
<span class="gi">+        self.objects.append(entity)</span>
<span class="gi">+        self._nodes[node] = entity</span>

<span class="w"> </span>    def get_module(self, name: str, node: nodes.Module) -&gt;PackageEntity:
<span class="w"> </span>        &quot;&quot;&quot;Return a module by its name, looking also for relative imports;
<span class="w"> </span>        raise KeyError if not found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.module(name)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # Try relative import</span>
<span class="gi">+            package = node.package()</span>
<span class="gi">+            if package:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return self.module(f&quot;{package}.{name}&quot;)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+        raise KeyError(f&quot;No module named {name}&quot;)</span>

<span class="w"> </span>    def add_from_depend(self, node: nodes.ImportFrom, from_module: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add dependencies created by from-imports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            imported_module = self.get_module(from_module, node)</span>
<span class="gi">+            for name, _ in node.names:</span>
<span class="gi">+                if name == &quot;*&quot;:</span>
<span class="gi">+                    self.add_relationship(self.object_from_node(node.root()), imported_module, &quot;uses&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_relationship(self.object_from_node(node.root()), imported_module, &quot;uses&quot;, name)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # Module not found, ignore</span>
<span class="gi">+            pass</span>

<span class="w"> </span>    def extract_relationships(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Extract relationships between nodes in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for obj in self.modules():</span>
<span class="gi">+            node = obj.node</span>
<span class="gi">+            for dep in node.deps:</span>
<span class="gi">+                if isinstance(dep, nodes.Import):</span>
<span class="gi">+                    for name, _ in dep.names:</span>
<span class="gi">+                        if self.has_node(name):</span>
<span class="gi">+                            imported = self.object_from_node(name)</span>
<span class="gi">+                            self.add_relationship(obj, imported, &quot;depends&quot;)</span>
<span class="gi">+                elif isinstance(dep, nodes.ImportFrom):</span>
<span class="gi">+                    self.add_from_depend(dep, dep.modname)</span>
<span class="gh">diff --git a/pylint/pyreverse/dot_printer.py b/pylint/pyreverse/dot_printer.py</span>
<span class="gh">index 30da959a1..2ebf9741f 100644</span>
<span class="gd">--- a/pylint/pyreverse/dot_printer.py</span>
<span class="gi">+++ b/pylint/pyreverse/dot_printer.py</span>
<span class="gu">@@ -37,7 +37,10 @@ class DotPrinter(Printer):</span>

<span class="w"> </span>    def _open_graph(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Emit the header lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        print(f&#39;digraph &quot;{self.title}&quot; {{&#39;)</span>
<span class="gi">+        print(f&#39;  charset=&quot;{self.charset}&quot;&#39;)</span>
<span class="gi">+        print(f&#39;  rankdir={self.layout.value}&#39;)</span>
<span class="gi">+        print(&#39;  node [shape=&quot;box&quot;]&#39;)</span>

<span class="w"> </span>    def emit_node(self, name: str, type_: NodeType, properties: (
<span class="w"> </span>        NodeProperties | None)=None) -&gt;None:
<span class="gu">@@ -45,13 +48,26 @@ class DotPrinter(Printer):</span>

<span class="w"> </span>        Nodes can be classes, packages, participants etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        properties = properties or {}</span>
<span class="gi">+        shape = SHAPES.get(type_, &#39;box&#39;)</span>
<span class="gi">+        label = properties.get(&#39;label&#39;, name)</span>
<span class="gi">+        </span>
<span class="gi">+        attrs = [f&#39;shape=&quot;{shape}&quot;&#39;, f&#39;label=&quot;{label}&quot;&#39;]</span>
<span class="gi">+        if &#39;color&#39; in properties:</span>
<span class="gi">+            attrs.append(f&#39;color=&quot;{properties[&quot;color&quot;]}&quot;&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        print(f&#39;  &quot;{name}&quot; [{&quot;, &quot;.join(attrs)}]&#39;)</span>

<span class="w"> </span>    def emit_edge(self, from_node: str, to_node: str, type_: EdgeType,
<span class="w"> </span>        label: (str | None)=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Create an edge from one node to another to display relationships.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attrs = ARROWS.get(type_, {}).copy()</span>
<span class="gi">+        if label:</span>
<span class="gi">+            attrs[&#39;label&#39;] = f&#39;&quot;{label}&quot;&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        attr_str = &#39;, &#39;.join(f&#39;{k}=&quot;{v}&quot;&#39; for k, v in attrs.items())</span>
<span class="gi">+        print(f&#39;  &quot;{from_node}&quot; -&gt; &quot;{to_node}&quot; [{attr_str}]&#39;)</span>

<span class="w"> </span>    def _close_graph(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Emit the lines needed to properly close the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        print(&#39;}&#39;)</span>
<span class="gh">diff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py</span>
<span class="gh">index 6af79d52a..cc5477caf 100644</span>
<span class="gd">--- a/pylint/pyreverse/inspector.py</span>
<span class="gi">+++ b/pylint/pyreverse/inspector.py</span>
<span class="gu">@@ -24,11 +24,12 @@ class IdGeneratorMixIn:</span>

<span class="w"> </span>    def init_counter(self, start_value: int=0) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Init the id counter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.id_count = start_value</span>

<span class="w"> </span>    def generate_id(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Generate a new identifier.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.id_count += 1</span>
<span class="gi">+        return self.id_count</span>


<span class="w"> </span>class Project:
<span class="gu">@@ -91,7 +92,8 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):</span>

<span class="w"> </span>        * optionally tag the node with a unique id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.tag:</span>
<span class="gi">+            node.uid = self.generate_id()</span>

<span class="w"> </span>    def visit_module(self, node: nodes.Module) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Module node.
<span class="gu">@@ -100,7 +102,10 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):</span>
<span class="w"> </span>        * set the depends mapping
<span class="w"> </span>        * optionally tag the node with a unique id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node.locals_type = {}</span>
<span class="gi">+        node.depends = []</span>
<span class="gi">+        if self.tag:</span>
<span class="gi">+            node.uid = self.generate_id()</span>

<span class="w"> </span>    def visit_classdef(self, node: nodes.ClassDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Class node.
<span class="gu">@@ -108,7 +113,10 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):</span>
<span class="w"> </span>        * set the locals_type and instance_attrs_type mappings
<span class="w"> </span>        * optionally tag the node with a unique id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node.locals_type = {}</span>
<span class="gi">+        node.instance_attrs_type = {}</span>
<span class="gi">+        if self.tag:</span>
<span class="gi">+            node.uid = self.generate_id()</span>

<span class="w"> </span>    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Function node.
<span class="gu">@@ -116,14 +124,18 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):</span>
<span class="w"> </span>        * set the locals_type mapping
<span class="w"> </span>        * optionally tag the node with a unique id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node.locals_type = {}</span>
<span class="gi">+        if self.tag:</span>
<span class="gi">+            node.uid = self.generate_id()</span>

<span class="w"> </span>    def visit_assignname(self, node: nodes.AssignName) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.AssignName node.

<span class="w"> </span>        handle locals_type
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        frame = node.frame()</span>
<span class="gi">+        if isinstance(frame, (nodes.FunctionDef, nodes.Module, nodes.ClassDef)):</span>
<span class="gi">+            frame.locals_type[node.name] = node.parent.value</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def handle_assignattr_type(node: nodes.AssignAttr, parent: nodes.ClassDef
<span class="gu">@@ -132,30 +144,42 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):</span>

<span class="w"> </span>        handle instance_attrs_type
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(parent, nodes.ClassDef):</span>
<span class="gi">+            parent.instance_attrs_type[node.attrname] = node.expr</span>

<span class="w"> </span>    def visit_import(self, node: nodes.Import) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Import node.

<span class="w"> </span>        resolve module dependencies
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, _ in node.names:</span>
<span class="gi">+            self._imported_module(node, name, False)</span>

<span class="w"> </span>    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.ImportFrom node.

<span class="w"> </span>        resolve module dependencies
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._imported_module(node, node.modname, node.level &gt; 0)</span>

<span class="w"> </span>    def compute_module(self, context_name: str, mod_path: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Should the module be added to dependencies ?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        package = self.project.name</span>
<span class="gi">+        if context_name == mod_path:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if mod_path.startswith(package) and context_name.startswith(package):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def _imported_module(self, node: (nodes.Import | nodes.ImportFrom),
<span class="w"> </span>        mod_path: str, relative: bool) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Notify an imported module, used to analyze dependencies.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        context_name = node.root().name</span>
<span class="gi">+        if relative:</span>
<span class="gi">+            pkg = context_name.rsplit(&quot;.&quot;, 1)[0]</span>
<span class="gi">+            mod_path = f&quot;{pkg}.{mod_path}&quot;</span>
<span class="gi">+        if self.compute_module(context_name, mod_path):</span>
<span class="gi">+            node.root().depends.append(mod_path)</span>


<span class="w"> </span>class AssociationHandlerInterface(ABC):
<span class="gu">@@ -175,17 +199,63 @@ class AbstractAssociationHandler(AssociationHandlerInterface):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    _next_handler: AssociationHandlerInterface

<span class="gi">+    def set_next(self, handler: AssociationHandlerInterface) -&gt; AssociationHandlerInterface:</span>
<span class="gi">+        self._next_handler = handler</span>
<span class="gi">+        return handler</span>
<span class="gi">+</span>
<span class="gi">+    def handle(self, node: nodes.NodeNG, parent: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        if self._next_handler:</span>
<span class="gi">+            self._next_handler.handle(node, parent)</span>
<span class="gi">+</span>

<span class="w"> </span>class AggregationsHandler(AbstractAssociationHandler):
<span class="gd">-    pass</span>
<span class="gi">+    def handle(self, node: nodes.NodeNG, parent: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        if isinstance(node, nodes.AnnAssign) and isinstance(node.annotation, nodes.Subscript):</span>
<span class="gi">+            if node.annotation.value.name in (&#39;list&#39;, &#39;set&#39;, &#39;dict&#39;):</span>
<span class="gi">+                parent.aggregations_type[node.target.name] = node.annotation</span>
<span class="gi">+            else:</span>
<span class="gi">+                super().handle(node, parent)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().handle(node, parent)</span>


<span class="w"> </span>class OtherAssociationsHandler(AbstractAssociationHandler):
<span class="gd">-    pass</span>
<span class="gi">+    def handle(self, node: nodes.NodeNG, parent: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        if isinstance(node, (nodes.AnnAssign, nodes.Assign)):</span>
<span class="gi">+            if isinstance(node, nodes.AnnAssign):</span>
<span class="gi">+                target = node.target</span>
<span class="gi">+                value = node.annotation</span>
<span class="gi">+            else:</span>
<span class="gi">+                target = node.targets[0]</span>
<span class="gi">+                value = node.value</span>
<span class="gi">+            </span>
<span class="gi">+            if isinstance(target, nodes.AssignName):</span>
<span class="gi">+                parent.associations_type[target.name] = value</span>


<span class="w"> </span>def project_from_files(files: list[str], func_wrapper: _WrapperFuncT=
<span class="w"> </span>    _astroid_wrapper, project_name: str=&#39;no name&#39;, black_list: tuple[str,
<span class="w"> </span>    ...]=constants.DEFAULT_IGNORE_LIST, verbose: bool=False) -&gt;Project:
<span class="w"> </span>    &quot;&quot;&quot;Return a Project from a list of files or modules.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    project = Project(project_name)</span>
<span class="gi">+    </span>
<span class="gi">+    for file in files:</span>
<span class="gi">+        if file.endswith(&#39;.py&#39;):</span>
<span class="gi">+            module_name = os.path.splitext(os.path.basename(file))[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            module_name = file</span>
<span class="gi">+        </span>
<span class="gi">+        if module_name in black_list:</span>
<span class="gi">+            continue</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            module = func_wrapper(astroid.MANAGER.ast_from_file, file, True)</span>
<span class="gi">+            if module:</span>
<span class="gi">+                project.modules.append(module)</span>
<span class="gi">+                project.locals[module.name] = module</span>
<span class="gi">+                project.path = module.file</span>
<span class="gi">+        except astroid.AstroidBuildingException:</span>
<span class="gi">+            if verbose:</span>
<span class="gi">+                traceback.print_exc()</span>
<span class="gi">+    </span>
<span class="gi">+    return project</span>
<span class="gh">diff --git a/pylint/pyreverse/main.py b/pylint/pyreverse/main.py</span>
<span class="gh">index e8743de5e..1c3303c37 100644</span>
<span class="gd">--- a/pylint/pyreverse/main.py</span>
<span class="gi">+++ b/pylint/pyreverse/main.py</span>
<span class="gu">@@ -106,7 +106,28 @@ class Run(_ArgumentsManager, _ArgumentsProvider):</span>

<span class="w"> </span>    def run(self, args: list[str]) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Checking arguments and run project.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            print(&quot;No packages to analyze.&quot;, file=sys.stderr)</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+        with augmented_sys_path(self.config.source_roots):</span>
<span class="gi">+            project = project_from_files(</span>
<span class="gi">+                args,</span>
<span class="gi">+                project_name=self.config.project,</span>
<span class="gi">+                black_list=self.config.ignore_list,</span>
<span class="gi">+                verbose=self.config.verbose,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        linker = Linker(project, tag=True)</span>
<span class="gi">+        handler = DiadefsHandler(self.config)</span>
<span class="gi">+        diadefs = handler.get_diadefs(project, linker)</span>
<span class="gi">+</span>
<span class="gi">+        if self.config.output_format.lower() == &quot;plantuml&quot;:</span>
<span class="gi">+            self.config.output_format = &quot;puml&quot;</span>
<span class="gi">+</span>
<span class="gi">+        wrt = writer.get_writer(self.config.output_format, self.config)</span>
<span class="gi">+        wrt.write(diadefs)</span>
<span class="gi">+        return 0</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/pylint/pyreverse/mermaidjs_printer.py b/pylint/pyreverse/mermaidjs_printer.py</span>
<span class="gh">index 5c9dac6c4..39f6ba3bd 100644</span>
<span class="gd">--- a/pylint/pyreverse/mermaidjs_printer.py</span>
<span class="gi">+++ b/pylint/pyreverse/mermaidjs_printer.py</span>
<span class="gu">@@ -15,7 +15,7 @@ class MermaidJSPrinter(Printer):</span>

<span class="w"> </span>    def _open_graph(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Emit the header lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.emit(&quot;classDiagram&quot;)</span>

<span class="w"> </span>    def emit_node(self, name: str, type_: NodeType, properties: (
<span class="w"> </span>        NodeProperties | None)=None) -&gt;None:
<span class="gu">@@ -23,15 +23,26 @@ class MermaidJSPrinter(Printer):</span>

<span class="w"> </span>        Nodes can be classes, packages, participants etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node_type = self.NODES.get(type_, &quot;class&quot;)</span>
<span class="gi">+        self.emit(f&quot;{node_type} {name}&quot;)</span>
<span class="gi">+        if properties:</span>
<span class="gi">+            for prop in properties.attrs:</span>
<span class="gi">+                self.emit(f&quot;    {name} : {get_annotation_label(prop)}&quot;)</span>
<span class="gi">+            for method in properties.methods:</span>
<span class="gi">+                self.emit(f&quot;    {name} : {method}()&quot;)</span>

<span class="w"> </span>    def emit_edge(self, from_node: str, to_node: str, type_: EdgeType,
<span class="w"> </span>        label: (str | None)=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Create an edge from one node to another to display relationships.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        arrow = self.ARROWS.get(type_, &quot;--&quot;)</span>
<span class="gi">+        edge = f&quot;{from_node} {arrow} {to_node}&quot;</span>
<span class="gi">+        if label:</span>
<span class="gi">+            edge += f&quot; : {label}&quot;</span>
<span class="gi">+        self.emit(edge)</span>

<span class="w"> </span>    def _close_graph(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Emit the lines needed to properly close the graph.&quot;&quot;&quot;
<span class="gi">+        # MermaidJS doesn&#39;t require any closing statements</span>
<span class="w"> </span>        pass


<span class="gu">@@ -44,3 +55,17 @@ class HTMLMermaidJSPrinter(MermaidJSPrinter):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    HTML_CLOSE_BOILERPLATE = &#39;\n       &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&#39;
<span class="w"> </span>    GRAPH_INDENT_LEVEL = 4
<span class="gi">+</span>
<span class="gi">+    def __init__(self):</span>
<span class="gi">+        super().__init__()</span>
<span class="gi">+        self.content = []</span>
<span class="gi">+</span>
<span class="gi">+    def emit(self, line: str) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Emit a line of MermaidJS content.&quot;&quot;&quot;</span>
<span class="gi">+        indent = &#39; &#39; * self.GRAPH_INDENT_LEVEL</span>
<span class="gi">+        self.content.append(f&quot;{indent}{line}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def generate(self) -&gt; str:</span>
<span class="gi">+        &quot;&quot;&quot;Generate the complete HTML output.&quot;&quot;&quot;</span>
<span class="gi">+        mermaid_content = &#39;\n&#39;.join(self.content)</span>
<span class="gi">+        return f&quot;{self.HTML_OPEN_BOILERPLATE}{mermaid_content}{self.HTML_CLOSE_BOILERPLATE}&quot;</span>
<span class="gh">diff --git a/pylint/pyreverse/plantuml_printer.py b/pylint/pyreverse/plantuml_printer.py</span>
<span class="gh">index ed05f0b13..34bf755c0 100644</span>
<span class="gd">--- a/pylint/pyreverse/plantuml_printer.py</span>
<span class="gi">+++ b/pylint/pyreverse/plantuml_printer.py</span>
<span class="gu">@@ -15,7 +15,7 @@ class PlantUmlPrinter(Printer):</span>

<span class="w"> </span>    def _open_graph(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Emit the header lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        print(&quot;@startuml&quot;)</span>

<span class="w"> </span>    def emit_node(self, name: str, type_: NodeType, properties: (
<span class="w"> </span>        NodeProperties | None)=None) -&gt;None:
<span class="gu">@@ -23,13 +23,23 @@ class PlantUmlPrinter(Printer):</span>

<span class="w"> </span>        Nodes can be classes, packages, participants etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node_type = self.NODES.get(type_, &quot;object&quot;)</span>
<span class="gi">+        properties_str = &quot;&quot;</span>
<span class="gi">+        if properties:</span>
<span class="gi">+            if properties.attrs:</span>
<span class="gi">+                properties_str += &quot;\n    &quot;.join(properties.attrs)</span>
<span class="gi">+            if properties.methods:</span>
<span class="gi">+                properties_str += &quot;\n    &quot; + &quot;\n    &quot;.join(properties.methods)</span>
<span class="gi">+        </span>
<span class="gi">+        print(f&quot;{node_type} {name} {{{properties_str}}}&quot;)</span>

<span class="w"> </span>    def emit_edge(self, from_node: str, to_node: str, type_: EdgeType,
<span class="w"> </span>        label: (str | None)=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Create an edge from one node to another to display relationships.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        arrow = self.ARROWS.get(type_, &quot;--&quot;)</span>
<span class="gi">+        label_str = f&quot; : {label}&quot; if label else &quot;&quot;</span>
<span class="gi">+        print(f&quot;{from_node} {arrow} {to_node}{label_str}&quot;)</span>

<span class="w"> </span>    def _close_graph(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Emit the lines needed to properly close the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        print(&quot;@enduml&quot;)</span>
<span class="gh">diff --git a/pylint/pyreverse/printer.py b/pylint/pyreverse/printer.py</span>
<span class="gh">index 289b213ad..36d1fc268 100644</span>
<span class="gd">--- a/pylint/pyreverse/printer.py</span>
<span class="gi">+++ b/pylint/pyreverse/printer.py</span>
<span class="gu">@@ -49,11 +49,11 @@ class Printer(ABC):</span>

<span class="w"> </span>    def _inc_indent(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increment indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._indent += &#39;    &#39;</span>

<span class="w"> </span>    def _dec_indent(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Decrement indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._indent = self._indent[:-4]</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def _open_graph(self) -&gt;None:
<span class="gu">@@ -79,7 +79,9 @@ class Printer(ABC):</span>

<span class="w"> </span>    def generate(self, outputfile: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Generate and save the final outputfile.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._close_graph()</span>
<span class="gi">+        with open(outputfile, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+            f.write(&#39;\n&#39;.join(self.lines))</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def _close_graph(self) -&gt;None:
<span class="gh">diff --git a/pylint/pyreverse/utils.py b/pylint/pyreverse/utils.py</span>
<span class="gh">index 4d75d3e1a..11d604572 100644</span>
<span class="gd">--- a/pylint/pyreverse/utils.py</span>
<span class="gi">+++ b/pylint/pyreverse/utils.py</span>
<span class="gu">@@ -19,12 +19,17 @@ RCFILE = &#39;.pyreverserc&#39;</span>

<span class="w"> </span>def get_default_options() -&gt;list[str]:
<span class="w"> </span>    &quot;&quot;&quot;Read config file and return list of options.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    options = []</span>
<span class="gi">+    if os.path.exists(RCFILE):</span>
<span class="gi">+        with open(RCFILE, &#39;r&#39;) as rcfile:</span>
<span class="gi">+            options = [line.strip() for line in rcfile if line.strip() and not line.startswith(&#39;#&#39;)]</span>
<span class="gi">+    return options</span>


<span class="w"> </span>def insert_default_options() -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Insert default options to sys.argv.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    options = get_default_options()</span>
<span class="gi">+    sys.argv[1:1] = options</span>


<span class="w"> </span>SPECIAL = re.compile(&#39;^__([^\\W_]_*)+__$&#39;)
<span class="gu">@@ -34,7 +39,13 @@ PROTECTED = re.compile(&#39;^_\\w*$&#39;)</span>

<span class="w"> </span>def get_visibility(name: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Return the visibility from a name: public, protected, private or special.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if SPECIAL.match(name):</span>
<span class="gi">+        return &#39;special&#39;</span>
<span class="gi">+    if PRIVATE.match(name):</span>
<span class="gi">+        return &#39;private&#39;</span>
<span class="gi">+    if PROTECTED.match(name):</span>
<span class="gi">+        return &#39;protected&#39;</span>
<span class="gi">+    return &#39;public&#39;</span>


<span class="w"> </span>_SPECIAL = 2
<span class="gu">@@ -61,7 +72,8 @@ class FilterMixIn:</span>

<span class="w"> </span>    def show_attr(self, node: (nodes.NodeNG | str)) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Return true if the node should be treated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        visibility = get_visibility(node.name if isinstance(node, nodes.NodeNG) else node)</span>
<span class="gi">+        return not (self.__mode &amp; VIS_MOD[visibility])</span>


<span class="w"> </span>class LocalsVisitor:
<span class="gu">@@ -80,17 +92,39 @@ class LocalsVisitor:</span>

<span class="w"> </span>    def get_callbacks(self, node: nodes.NodeNG) -&gt;_CallbackTupleT:
<span class="w"> </span>        &quot;&quot;&quot;Get callbacks from handler for the visited node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        klass = node.__class__</span>
<span class="gi">+        if klass not in self._cache:</span>
<span class="gi">+            visit = getattr(self, f&#39;visit_{klass.__name__.lower()}&#39;, None)</span>
<span class="gi">+            leave = getattr(self, f&#39;leave_{klass.__name__.lower()}&#39;, None)</span>
<span class="gi">+            self._cache[klass] = (visit, leave)</span>
<span class="gi">+        return self._cache[klass]</span>

<span class="w"> </span>    def visit(self, node: nodes.NodeNG) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;Launch the visit starting from the given node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node in self._visited:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._visited.add(node)</span>
<span class="gi">+        visit, leave = self.get_callbacks(node)</span>
<span class="gi">+</span>
<span class="gi">+        if visit:</span>
<span class="gi">+            visit(node)</span>
<span class="gi">+</span>
<span class="gi">+        for child_node in node.get_children():</span>
<span class="gi">+            self.visit(child_node)</span>
<span class="gi">+</span>
<span class="gi">+        if leave:</span>
<span class="gi">+            leave(node)</span>


<span class="w"> </span>def get_annotation(node: (nodes.AssignAttr | nodes.AssignName)) -&gt;(nodes.
<span class="w"> </span>    Name | nodes.Subscript | None):
<span class="w"> </span>    &quot;&quot;&quot;Return the annotation for `node`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, nodes.AssignName):</span>
<span class="gi">+        return node.parent.annotation</span>
<span class="gi">+    elif isinstance(node, nodes.AssignAttr):</span>
<span class="gi">+        return node.annotation</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def infer_node(node: (nodes.AssignAttr | nodes.AssignName)) -&gt;set[
<span class="gu">@@ -98,7 +132,10 @@ def infer_node(node: (nodes.AssignAttr | nodes.AssignName)) -&gt;set[</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a set containing the node annotation if it exists
<span class="w"> </span>    otherwise return a set of the inferred types using the NodeNG.infer method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    annotation = get_annotation(node)</span>
<span class="gi">+    if annotation:</span>
<span class="gi">+        return {annotation}</span>
<span class="gi">+    return set(node.infer())</span>


<span class="w"> </span>def check_graphviz_availability() -&gt;None:
<span class="gu">@@ -107,7 +144,12 @@ def check_graphviz_availability() -&gt;None:</span>
<span class="w"> </span>    This is needed if image output is desired and ``dot`` is used to convert
<span class="w"> </span>    from *.dot or *.gv into the final output format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if shutil.which(&quot;dot&quot;) is None:</span>
<span class="gi">+        raise RuntimeError(</span>
<span class="gi">+            &quot;The &#39;dot&#39; command from Graphviz is required for image output. &quot;</span>
<span class="gi">+            &quot;Please install Graphviz (https://graphviz.org/) and ensure the &#39;dot&#39; &quot;</span>
<span class="gi">+            &quot;command is available in your system&#39;s PATH.&quot;</span>
<span class="gi">+        )</span>


<span class="w"> </span>def check_if_graphviz_supports_format(output_format: str) -&gt;None:
<span class="gu">@@ -116,4 +158,17 @@ def check_if_graphviz_supports_format(output_format: str) -&gt;None:</span>
<span class="w"> </span>    This is needed if image output is desired and ``dot`` is used to convert
<span class="w"> </span>    from *.gv into the final output format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    check_graphviz_availability()</span>
<span class="gi">+    try:</span>
<span class="gi">+        subprocess.run(</span>
<span class="gi">+            [&quot;dot&quot;, f&quot;-T{output_format}&quot;, &quot;-o&quot;, os.devnull],</span>
<span class="gi">+            input=&quot;digraph { a -&gt; b }&quot;,</span>
<span class="gi">+            text=True,</span>
<span class="gi">+            capture_output=True,</span>
<span class="gi">+            check=True,</span>
<span class="gi">+        )</span>
<span class="gi">+    except subprocess.CalledProcessError as e:</span>
<span class="gi">+        raise RuntimeError(</span>
<span class="gi">+            f&quot;The &#39;dot&#39; command does not support the &#39;{output_format}&#39; output format. &quot;</span>
<span class="gi">+            f&quot;Error: {e.stderr.strip()}&quot;</span>
<span class="gi">+        ) from e</span>
<span class="gh">diff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py</span>
<span class="gh">index 55d8714f1..2a685e24e 100644</span>
<span class="gd">--- a/pylint/pyreverse/writer.py</span>
<span class="gi">+++ b/pylint/pyreverse/writer.py</span>
<span class="gu">@@ -27,32 +27,72 @@ class DiagramWriter:</span>

<span class="w"> </span>    def write(self, diadefs: Iterable[ClassDiagram | PackageDiagram]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write files for &lt;project&gt; according to &lt;diadefs&gt;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for diagram in diadefs:</span>
<span class="gi">+            if isinstance(diagram, PackageDiagram):</span>
<span class="gi">+                self.write_packages(diagram)</span>
<span class="gi">+            elif isinstance(diagram, ClassDiagram):</span>
<span class="gi">+                self.write_classes(diagram)</span>

<span class="w"> </span>    def write_packages(self, diagram: PackageDiagram) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write a package diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_printer(diagram.name, &quot;packages&quot;)</span>
<span class="gi">+        for obj in diagram.modules():</span>
<span class="gi">+            properties = self.get_package_properties(obj)</span>
<span class="gi">+            self.printer.emit_node(obj.fig_id, properties)</span>
<span class="gi">+        for rel in diagram.relationships:</span>
<span class="gi">+            self.printer.emit_edge(rel.from_object.fig_id, rel.to_object.fig_id, EdgeType.USES)</span>
<span class="gi">+        self.save()</span>

<span class="w"> </span>    def write_classes(self, diagram: ClassDiagram) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write a class diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_printer(diagram.name, &quot;classes&quot;)</span>
<span class="gi">+        for obj in diagram.objects:</span>
<span class="gi">+            properties = self.get_class_properties(obj)</span>
<span class="gi">+            self.printer.emit_node(obj.fig_id, properties)</span>
<span class="gi">+        for rel in diagram.relationships:</span>
<span class="gi">+            self.printer.emit_edge(rel.from_object.fig_id, rel.to_object.fig_id, rel.type)</span>
<span class="gi">+        self.save()</span>

<span class="w"> </span>    def set_printer(self, file_name: str, basename: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set printer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.file_name = f&quot;{basename}_{file_name}&quot;</span>
<span class="gi">+        self.printer = self.printer_class(self.file_name)</span>

<span class="w"> </span>    def get_package_properties(self, obj: PackageEntity) -&gt;NodeProperties:
<span class="w"> </span>        &quot;&quot;&quot;Get label and shape for packages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return NodeProperties(</span>
<span class="gi">+            label=obj.title,</span>
<span class="gi">+            shape=&quot;box&quot;,</span>
<span class="gi">+            style=&quot;filled&quot;,</span>
<span class="gi">+            color=self.get_shape_color(obj),</span>
<span class="gi">+            fontcolor=&quot;black&quot;,</span>
<span class="gi">+            fontname=&quot;Helvetica&quot;,</span>
<span class="gi">+            fontsize=10,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def get_class_properties(self, obj: ClassEntity) -&gt;NodeProperties:
<span class="w"> </span>        &quot;&quot;&quot;Get label and shape for classes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        label = f&quot;{obj.title}|{obj.attrs}|{obj.methods}&quot; if obj.attrs or obj.methods else obj.title</span>
<span class="gi">+        return NodeProperties(</span>
<span class="gi">+            label=label,</span>
<span class="gi">+            shape=&quot;record&quot;,</span>
<span class="gi">+            style=&quot;filled&quot;,</span>
<span class="gi">+            color=self.get_shape_color(obj),</span>
<span class="gi">+            fontcolor=&quot;black&quot;,</span>
<span class="gi">+            fontname=&quot;Helvetica&quot;,</span>
<span class="gi">+            fontsize=10,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def get_shape_color(self, obj: DiagramEntity) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Get shape color.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if obj.node_type == NodeType.PACKAGE:</span>
<span class="gi">+            return &quot;#ADD8E6&quot;  # Light blue for packages</span>
<span class="gi">+        elif obj.node_type == NodeType.CLASS:</span>
<span class="gi">+            if is_exception(obj):</span>
<span class="gi">+                return &quot;#FFA07A&quot;  # Light salmon for exceptions</span>
<span class="gi">+            return &quot;#98FB98&quot;  # Pale green for regular classes</span>
<span class="gi">+        return &quot;#FFFFFF&quot;  # White for unknown types</span>

<span class="w"> </span>    def save(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write to disk.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.printer.generate(self.file_name)</span>
<span class="gh">diff --git a/pylint/reporters/base_reporter.py b/pylint/reporters/base_reporter.py</span>
<span class="gh">index 2a79b16e1..3f96222f8 100644</span>
<span class="gd">--- a/pylint/reporters/base_reporter.py</span>
<span class="gi">+++ b/pylint/reporters/base_reporter.py</span>
<span class="gu">@@ -28,19 +28,23 @@ class BaseReporter:</span>

<span class="w"> </span>    def handle_message(self, msg: Message) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Handle a new message triggered on the current file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.messages.append(msg)</span>

<span class="w"> </span>    def writeln(self, string: str=&#39;&#39;) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write a line in the output buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        print(string, file=self.out)</span>

<span class="w"> </span>    def display_reports(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Display results encapsulated in the layout tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._display(layout)</span>

<span class="w"> </span>    def _display(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Display the layout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child in layout.children:</span>
<span class="gi">+            if isinstance(child, Text):</span>
<span class="gi">+                self.writeln(child.data)</span>
<span class="gi">+            elif isinstance(child, Section):</span>
<span class="gi">+                self._display(child)</span>

<span class="w"> </span>    def display_messages(self, layout: (Section | None)) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Hook for displaying the messages of the reporter.
<span class="gu">@@ -52,14 +56,21 @@ class BaseReporter:</span>
<span class="w"> </span>        This method can be implemented to display them after they&#39;ve
<span class="w"> </span>        been aggregated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for msg in self.messages:</span>
<span class="gi">+            self.writeln(f&quot;{msg.path}:{msg.line}: {msg.symbol} {msg.msg}&quot;)</span>

<span class="w"> </span>    def on_set_current_module(self, module: str, filepath: (str | None)
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Hook called when a module starts to be analysed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.writeln(f&quot;Analyzing module: {module}&quot;)</span>
<span class="gi">+        if filepath:</span>
<span class="gi">+            self.writeln(f&quot;File path: {filepath}&quot;)</span>

<span class="w"> </span>    def on_close(self, stats: LinterStats, previous_stats: (LinterStats | None)
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Hook called when a module finished analyzing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.writeln(&quot;Analysis completed&quot;)</span>
<span class="gi">+        self.writeln(f&quot;Total messages: {stats.total_errors}&quot;)</span>
<span class="gi">+        if previous_stats:</span>
<span class="gi">+            diff = stats.total_errors - previous_stats.total_errors</span>
<span class="gi">+            self.writeln(f&quot;Difference from previous run: {diff}&quot;)</span>
<span class="gh">diff --git a/pylint/reporters/json_reporter.py b/pylint/reporters/json_reporter.py</span>
<span class="gh">index ddf8abc09..546beedd5 100644</span>
<span class="gd">--- a/pylint/reporters/json_reporter.py</span>
<span class="gi">+++ b/pylint/reporters/json_reporter.py</span>
<span class="gu">@@ -26,15 +26,32 @@ class JSONReporter(BaseReporter):</span>

<span class="w"> </span>    def display_messages(self, layout: (Section | None)) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Launch layouts display.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        messages = [self._export_message(msg) for msg in self.messages]</span>
<span class="gi">+        print(json.dumps(messages, indent=4))</span>

<span class="w"> </span>    def display_reports(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Don&#39;t do anything in this reporter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This method intentionally does nothing as per the docstring</span>

<span class="w"> </span>    def _display(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Do nothing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This method intentionally does nothing as per the docstring</span>
<span class="gi">+</span>
<span class="gi">+    def _export_message(self, msg: Message) -&gt; OldJsonExport:</span>
<span class="gi">+        &quot;&quot;&quot;Export a message to the old JSON format.&quot;&quot;&quot;</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;type&quot;: msg.category,</span>
<span class="gi">+            &quot;module&quot;: msg.module,</span>
<span class="gi">+            &quot;obj&quot;: msg.obj,</span>
<span class="gi">+            &quot;line&quot;: msg.line,</span>
<span class="gi">+            &quot;column&quot;: msg.column,</span>
<span class="gi">+            &quot;endLine&quot;: msg.end_line,</span>
<span class="gi">+            &quot;endColumn&quot;: msg.end_column,</span>
<span class="gi">+            &quot;path&quot;: msg.path,</span>
<span class="gi">+            &quot;symbol&quot;: msg.symbol,</span>
<span class="gi">+            &quot;message&quot;: msg.msg or &quot;&quot;,</span>
<span class="gi">+            &quot;message-id&quot;: msg.msg_id,</span>
<span class="gi">+        }</span>


<span class="w"> </span>class JSONMessage(TypedDict):
<span class="gu">@@ -59,16 +76,51 @@ class JSON2Reporter(BaseReporter):</span>

<span class="w"> </span>    def display_reports(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Don&#39;t do anything in this reporter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This method intentionally does nothing as per the docstring</span>

<span class="w"> </span>    def _display(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Do nothing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This method intentionally does nothing as per the docstring</span>

<span class="w"> </span>    def display_messages(self, layout: (Section | None)) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Launch layouts display.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        messages = [self._format_message(msg) for msg in self.messages]</span>
<span class="gi">+        result = {</span>
<span class="gi">+            &quot;messages&quot;: messages,</span>
<span class="gi">+            &quot;statistics&quot;: self.serialize_stats(),</span>
<span class="gi">+        }</span>
<span class="gi">+        print(json.dumps(result, indent=2))</span>

<span class="w"> </span>    def serialize_stats(self) -&gt;dict[str, str | int | dict[str, int]]:
<span class="w"> </span>        &quot;&quot;&quot;Serialize the linter stats into something JSON dumpable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stats = self.linter.stats</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;by_module&quot;: stats.by_module,</span>
<span class="gi">+            &quot;message_count&quot;: stats.message_count,</span>
<span class="gi">+            &quot;module_count&quot;: stats.module_count,</span>
<span class="gi">+            &quot;statement_count&quot;: stats.statement_count,</span>
<span class="gi">+            &quot;error&quot;: stats.error,</span>
<span class="gi">+            &quot;warning&quot;: stats.warning,</span>
<span class="gi">+            &quot;refactor&quot;: stats.refactor,</span>
<span class="gi">+            &quot;convention&quot;: stats.convention,</span>
<span class="gi">+            &quot;info&quot;: stats.info,</span>
<span class="gi">+            &quot;fatal&quot;: stats.fatal,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def _format_message(self, msg: Message) -&gt; JSONMessage:</span>
<span class="gi">+        &quot;&quot;&quot;Format a message for JSON output.&quot;&quot;&quot;</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;type&quot;: msg.category,</span>
<span class="gi">+            &quot;message&quot;: msg.msg or &quot;&quot;,</span>
<span class="gi">+            &quot;messageId&quot;: msg.msg_id,</span>
<span class="gi">+            &quot;symbol&quot;: msg.symbol,</span>
<span class="gi">+            &quot;confidence&quot;: CONFIDENCE_MAP[msg.confidence] if msg.confidence != UNDEFINED else &quot;undefined&quot;,</span>
<span class="gi">+            &quot;module&quot;: msg.module,</span>
<span class="gi">+            &quot;path&quot;: msg.path,</span>
<span class="gi">+            &quot;absolutePath&quot;: str(msg.abspath),</span>
<span class="gi">+            &quot;line&quot;: msg.line,</span>
<span class="gi">+            &quot;endLine&quot;: msg.end_line,</span>
<span class="gi">+            &quot;column&quot;: msg.column,</span>
<span class="gi">+            &quot;endColumn&quot;: msg.end_column,</span>
<span class="gi">+            &quot;obj&quot;: msg.obj,</span>
<span class="gi">+        }</span>
<span class="gh">diff --git a/pylint/reporters/multi_reporter.py b/pylint/reporters/multi_reporter.py</span>
<span class="gh">index 933044920..fdca72aa5 100644</span>
<span class="gd">--- a/pylint/reporters/multi_reporter.py</span>
<span class="gi">+++ b/pylint/reporters/multi_reporter.py</span>
<span class="gu">@@ -39,26 +39,33 @@ class MultiReporter:</span>

<span class="w"> </span>    def handle_message(self, msg: Message) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Handle a new message triggered on the current file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for reporter in self._sub_reporters:</span>
<span class="gi">+            reporter.handle_message(msg)</span>
<span class="gi">+        self.messages.append(msg)</span>

<span class="w"> </span>    def writeln(self, string: str=&#39;&#39;) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write a line in the output buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for reporter in self._sub_reporters:</span>
<span class="gi">+            reporter.writeln(string)</span>

<span class="w"> </span>    def display_reports(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Display results encapsulated in the layout tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for reporter in self._sub_reporters:</span>
<span class="gi">+            reporter.display_reports(layout)</span>

<span class="w"> </span>    def display_messages(self, layout: (Section | None)) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Hook for displaying the messages of the reporter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for reporter in self._sub_reporters:</span>
<span class="gi">+            reporter.display_messages(layout)</span>

<span class="w"> </span>    def on_set_current_module(self, module: str, filepath: (str | None)
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Hook called when a module starts to be analysed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for reporter in self._sub_reporters:</span>
<span class="gi">+            reporter.on_set_current_module(module, filepath)</span>

<span class="w"> </span>    def on_close(self, stats: LinterStats, previous_stats: (LinterStats | None)
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Hook called when a module finished analyzing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for reporter in self._sub_reporters:</span>
<span class="gi">+            reporter.on_close(stats, previous_stats)</span>
<span class="gh">diff --git a/pylint/reporters/reports_handler_mix_in.py b/pylint/reporters/reports_handler_mix_in.py</span>
<span class="gh">index c68428765..3f74f82a6 100644</span>
<span class="gd">--- a/pylint/reporters/reports_handler_mix_in.py</span>
<span class="gi">+++ b/pylint/reporters/reports_handler_mix_in.py</span>
<span class="gu">@@ -24,7 +24,9 @@ class ReportsHandlerMixIn:</span>

<span class="w"> </span>    def report_order(self) -&gt;MutableSequence[BaseChecker]:
<span class="w"> </span>        &quot;&quot;&quot;Return a list of reporters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [checker for checker, _ in sorted(</span>
<span class="gi">+            self._reports.items(), key=lambda x: x[0].name.lower()</span>
<span class="gi">+        )]</span>

<span class="w"> </span>    def register_report(self, reportid: str, r_title: str, r_cb:
<span class="w"> </span>        ReportsCallable, checker: BaseChecker) -&gt;None:
<span class="gu">@@ -35,21 +37,32 @@ class ReportsHandlerMixIn:</span>
<span class="w"> </span>        :param r_cb: The method to call to make the report
<span class="w"> </span>        :param checker: The checker defining the report
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._reports[checker].append((reportid, r_title, r_cb))</span>

<span class="w"> </span>    def enable_report(self, reportid: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Enable the report of the given id.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._reports_state[reportid] = True</span>

<span class="w"> </span>    def disable_report(self, reportid: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Disable the report of the given id.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._reports_state[reportid] = False</span>

<span class="w"> </span>    def report_is_enabled(self, reportid: str) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Is the report associated to the given identifier enabled ?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._reports_state.get(reportid, True)</span>

<span class="w"> </span>    def make_reports(self: PyLinter, stats: LinterStats, old_stats: (
<span class="w"> </span>        LinterStats | None)) -&gt;Section:
<span class="w"> </span>        &quot;&quot;&quot;Render registered reports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sect = Section(&quot;Report&quot;)</span>
<span class="gi">+        for checker in self.report_order():</span>
<span class="gi">+            for reportid, r_title, r_cb in self._reports[checker]:</span>
<span class="gi">+                if not self.report_is_enabled(reportid):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                report_sect = Section(r_title)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    r_cb(report_sect, stats, old_stats)</span>
<span class="gi">+                except EmptyReportError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                sect.append(report_sect)</span>
<span class="gi">+        return sect</span>
<span class="gh">diff --git a/pylint/reporters/text.py b/pylint/reporters/text.py</span>
<span class="gh">index 913080584..99d4b8dfc 100644</span>
<span class="gd">--- a/pylint/reporters/text.py</span>
<span class="gi">+++ b/pylint/reporters/text.py</span>
<span class="gu">@@ -34,7 +34,15 @@ class MessageStyle(NamedTuple):</span>

<span class="w"> </span>        :return: the built escape code
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        code = []</span>
<span class="gi">+        if self.color:</span>
<span class="gi">+            if self.color.isdigit():</span>
<span class="gi">+                code.append(f&quot;38;5;{self.color}&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                code.append(ANSI_COLORS[self.color])</span>
<span class="gi">+        for style in self.style:</span>
<span class="gi">+            code.append(ANSI_STYLES[style])</span>
<span class="gi">+        return ANSI_PREFIX + &#39;;&#39;.join(code) + ANSI_END</span>


<span class="w"> </span>ColorMappingDict = Dict[str, MessageStyle]
<span class="gu">@@ -52,7 +60,9 @@ MESSAGE_FIELDS = {i.name for i in fields(Message)}</span>

<span class="w"> </span>def colorize_ansi(msg: str, msg_style: MessageStyle) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Colorize message by wrapping it with ANSI escape codes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not msg_style.color and not msg_style.style:</span>
<span class="gi">+        return msg</span>
<span class="gi">+    return f&quot;{msg_style.__get_ansi_code()}{msg}{ANSI_RESET}&quot;</span>


<span class="w"> </span>class TextReporter(BaseReporter):
<span class="gu">@@ -71,21 +81,34 @@ class TextReporter(BaseReporter):</span>
<span class="w"> </span>    def on_set_current_module(self, module: str, filepath: (str | None)
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set the format template to be used and check for unrecognized arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._modules.add(module)</span>
<span class="gi">+        self._template = self.line_format</span>
<span class="gi">+        if filepath is None:</span>
<span class="gi">+            filepath = module</span>
<span class="gi">+        self._fixed_template = self._template.format(</span>
<span class="gi">+            path=filepath,</span>
<span class="gi">+            module=module,</span>
<span class="gi">+            **{name: &#39;{&#39; + name + &#39;}&#39; for name in MESSAGE_FIELDS}</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def write_message(self, msg: Message) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Convenience method to write a formatted message with class default
<span class="w"> </span>        template.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.writeln(self._fixed_template.format(**asdict(msg)))</span>

<span class="w"> </span>    def handle_message(self, msg: Message) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Manage message of different type and in the context of path.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msg.module not in self._modules:</span>
<span class="gi">+            if msg.module and msg.module != &quot;global&quot;:</span>
<span class="gi">+                self.writeln(f&quot;************* Module {msg.module}&quot;)</span>
<span class="gi">+                self._modules.add(msg.module)</span>
<span class="gi">+        self.write_message(msg)</span>

<span class="w"> </span>    def _display(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Launch layouts display.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writer = TextWriter(self.out)</span>
<span class="gi">+        writer.format_section(layout)</span>


<span class="w"> </span>class NoHeaderReporter(TextReporter):
<span class="gu">@@ -94,7 +117,7 @@ class NoHeaderReporter(TextReporter):</span>

<span class="w"> </span>    def handle_message(self, msg: Message) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write message(s) without module header.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write_message(msg)</span>


<span class="w"> </span>class ParseableTextReporter(TextReporter):
<span class="gu">@@ -141,13 +164,17 @@ class ColorizedTextReporter(TextReporter):</span>

<span class="w"> </span>    def _get_decoration(self, msg_id: str) -&gt;MessageStyle:
<span class="w"> </span>        &quot;&quot;&quot;Returns the message style as defined in self.color_mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.color_mapping.get(msg_id[0], MessageStyle(None))</span>

<span class="w"> </span>    def handle_message(self, msg: Message) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Manage message of different types, and colorize output
<span class="w"> </span>        using ANSI escape codes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msg.module not in self._modules:</span>
<span class="gi">+            if msg.module and msg.module != &quot;global&quot;:</span>
<span class="gi">+                self.writeln(colorize_ansi(f&quot;************* Module {msg.module}&quot;, MessageStyle(&quot;green&quot;, (&quot;bold&quot;,))))</span>
<span class="gi">+                self._modules.add(msg.module)</span>
<span class="gi">+        self.write_message(colorize_ansi(self._fixed_template.format(**asdict(msg)), self._get_decoration(msg.C)))</span>


<span class="w"> </span>class GithubReporter(TextReporter):
<span class="gh">diff --git a/pylint/reporters/ureports/base_writer.py b/pylint/reporters/ureports/base_writer.py</span>
<span class="gh">index 8b1244c33..2d66c3cf3 100644</span>
<span class="gd">--- a/pylint/reporters/ureports/base_writer.py</span>
<span class="gi">+++ b/pylint/reporters/ureports/base_writer.py</span>
<span class="gu">@@ -23,37 +23,57 @@ class BaseWriter:</span>
<span class="w"> </span>        try to call &#39;stream.write&#39; with it, but give it back encoded using
<span class="w"> </span>        the given encoding if it fails
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.encoding = encoding</span>
<span class="gi">+        self.out = stream</span>
<span class="gi">+        self.begin_format()</span>
<span class="gi">+        layout.accept(self)</span>
<span class="gi">+        self.end_format()</span>

<span class="w"> </span>    def format_children(self, layout: (EvaluationSection | Paragraph | Section)
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Recurse on the layout children and call their accept method
<span class="w"> </span>        (see the Visitor pattern).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child in layout.children:</span>
<span class="gi">+            child.accept(self)</span>

<span class="w"> </span>    def writeln(self, string: str=&#39;&#39;) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write a line in the output buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(string + &#39;\n&#39;)</span>

<span class="w"> </span>    def write(self, string: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write a string in the output buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(string, str):</span>
<span class="gi">+            self.out.write(string)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.out.write(string.encode(self.encoding or &#39;utf-8&#39;))</span>

<span class="w"> </span>    def begin_format(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Begin to format a layout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.section = 0</span>

<span class="w"> </span>    def end_format(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Finished formatting a layout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.out is not sys.stdout:</span>
<span class="gi">+            self.out.flush()</span>

<span class="w"> </span>    def get_table_content(self, table: Table) -&gt;list[list[str]]:
<span class="w"> </span>        &quot;&quot;&quot;Trick to get table content without actually writing it.

<span class="w"> </span>        return an aligned list of lists containing table cells values as string
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for row in table.data:</span>
<span class="gi">+            result_row = []</span>
<span class="gi">+            for cell in row:</span>
<span class="gi">+                if isinstance(cell, BaseLayout):</span>
<span class="gi">+                    stream = StringIO()</span>
<span class="gi">+                    self.format(cell, stream)</span>
<span class="gi">+                    result_row.append(stream.getvalue().strip())</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result_row.append(str(cell).strip())</span>
<span class="gi">+            result.append(result_row)</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def compute_content(self, layout: BaseLayout) -&gt;Iterator[str]:
<span class="w"> </span>        &quot;&quot;&quot;Trick to compute the formatting of children layout before actually
<span class="gu">@@ -61,4 +81,9 @@ class BaseWriter:</span>

<span class="w"> </span>        return an iterator on strings (one for each child element)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stream = StringIO()</span>
<span class="gi">+        for child in layout.children:</span>
<span class="gi">+            child.accept(self)</span>
<span class="gi">+            yield stream.getvalue()</span>
<span class="gi">+            stream.seek(0)</span>
<span class="gi">+            stream.truncate()</span>
<span class="gh">diff --git a/pylint/reporters/ureports/nodes.py b/pylint/reporters/ureports/nodes.py</span>
<span class="gh">index 9787ce5b8..09099f672 100644</span>
<span class="gd">--- a/pylint/reporters/ureports/nodes.py</span>
<span class="gi">+++ b/pylint/reporters/ureports/nodes.py</span>
<span class="gu">@@ -39,19 +39,26 @@ class BaseLayout(VNode):</span>

<span class="w"> </span>    def append(self, child: VNode) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add a node to children.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.children.append(child)</span>
<span class="gi">+        child.parent = self</span>

<span class="w"> </span>    def insert(self, index: int, child: VNode) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Insert a child node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.children.insert(index, child)</span>
<span class="gi">+        child.parent = self</span>

<span class="w"> </span>    def parents(self) -&gt;list[BaseLayout]:
<span class="w"> </span>        &quot;&quot;&quot;Return the ancestor nodes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ancestors = []</span>
<span class="gi">+        parent = self.parent</span>
<span class="gi">+        while parent:</span>
<span class="gi">+            ancestors.append(parent)</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        return ancestors</span>

<span class="w"> </span>    def add_text(self, text: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Shortcut to add text data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.append(Text(text))</span>


<span class="w"> </span>class Text(VNode):
<span class="gh">diff --git a/pylint/reporters/ureports/text_writer.py b/pylint/reporters/ureports/text_writer.py</span>
<span class="gh">index a827d6c5f..96f2e7b04 100644</span>
<span class="gd">--- a/pylint/reporters/ureports/text_writer.py</span>
<span class="gi">+++ b/pylint/reporters/ureports/text_writer.py</span>
<span class="gu">@@ -19,29 +19,49 @@ class TextWriter(BaseWriter):</span>

<span class="w"> </span>    def visit_section(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Display a section as text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.section += 1</span>
<span class="gi">+        if self.section &gt; 1:</span>
<span class="gi">+            self.writeln()</span>
<span class="gi">+        self.format_children(layout)</span>
<span class="gi">+        self.section -= 1</span>

<span class="w"> </span>    def visit_evaluationsection(self, layout: EvaluationSection) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Display an evaluation section as a text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit_section(layout)</span>

<span class="w"> </span>    def visit_paragraph(self, layout: Paragraph) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Enter a paragraph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.format_children(layout)</span>
<span class="gi">+        self.writeln()</span>

<span class="w"> </span>    def visit_table(self, layout: Table) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Display a table as text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        table_content = self.get_table_content(layout)</span>
<span class="gi">+        cols_width = self.get_table_cols_width(table_content)</span>
<span class="gi">+        self.default_table(layout, table_content, cols_width)</span>

<span class="w"> </span>    def default_table(self, layout: Table, table_content: list[list[str]],
<span class="w"> </span>        cols_width: list[int]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Format a table.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cols_width = [max(width, 4) for width in cols_width]</span>
<span class="gi">+        table_width = sum(cols_width) + len(cols_width) * 3 + 1</span>
<span class="gi">+        self.writeln(&#39;=&#39; * table_width)</span>
<span class="gi">+        for row in table_content:</span>
<span class="gi">+            self.write(&#39;| &#39;)</span>
<span class="gi">+            for width, cell in zip(cols_width, row):</span>
<span class="gi">+                self.write(cell.ljust(width))</span>
<span class="gi">+                self.write(&#39; | &#39;)</span>
<span class="gi">+            self.writeln()</span>
<span class="gi">+            self.writeln(&#39;=&#39; * table_width)</span>

<span class="w"> </span>    def visit_verbatimtext(self, layout: VerbatimText) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Display a verbatim layout as text (so difficult ;).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.writeln(&#39;::&#39;)</span>
<span class="gi">+        self.writeln()</span>
<span class="gi">+        for line in layout.data.splitlines():</span>
<span class="gi">+            self.writeln(&#39;    &#39; + line)</span>
<span class="gi">+        self.writeln()</span>

<span class="w"> </span>    def visit_text(self, layout: Text) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add some text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(layout.data)</span>
<span class="gh">diff --git a/pylint/testutils/_primer/package_to_lint.py b/pylint/testutils/_primer/package_to_lint.py</span>
<span class="gh">index ff547e409..4dfa9e7f3 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/package_to_lint.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/package_to_lint.py</span>
<span class="gu">@@ -56,12 +56,12 @@ class PackageToLint:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def clone_directory(self) -&gt;Path:
<span class="w"> </span>        &quot;&quot;&quot;Directory to clone repository into.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return PRIMER_DIRECTORY_PATH / self.url.split(&#39;/&#39;)[-1].replace(&#39;.git&#39;, &#39;&#39;)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def paths_to_lint(self) -&gt;list[str]:
<span class="w"> </span>        &quot;&quot;&quot;The paths we need to lint.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [str(self.clone_directory / directory) for directory in self.directories]</span>

<span class="w"> </span>    def lazy_clone(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Concatenates the target directory and clones the file.
<span class="gu">@@ -72,4 +72,19 @@ class PackageToLint:</span>
<span class="w"> </span>        we&#39;ll probably notice because we&#39;ll have a fatal when launching the
<span class="w"> </span>        primer locally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.clone_directory.exists():</span>
<span class="gi">+            logging.info(&quot;Cloning %s&quot;, self.url)</span>
<span class="gi">+            Repo.clone_from(self.url, self.clone_directory, branch=self.branch)</span>
<span class="gi">+        else:</span>
<span class="gi">+            logging.info(&quot;Repository already exists, pulling latest changes&quot;)</span>
<span class="gi">+            repo = Repo(self.clone_directory)</span>
<span class="gi">+            try:</span>
<span class="gi">+                repo.remotes.origin.pull()</span>
<span class="gi">+            except GitCommandError:</span>
<span class="gi">+                raise DirtyPrimerDirectoryException(self.clone_directory)</span>
<span class="gi">+</span>
<span class="gi">+        if self.commit:</span>
<span class="gi">+            repo = Repo(self.clone_directory)</span>
<span class="gi">+            repo.git.checkout(self.commit)</span>
<span class="gi">+</span>
<span class="gi">+        return str(self.clone_directory)</span>
<span class="gh">diff --git a/pylint/testutils/_primer/primer_compare_command.py b/pylint/testutils/_primer/primer_compare_command.py</span>
<span class="gh">index f71c9c3a6..4537c051f 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/primer_compare_command.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/primer_compare_command.py</span>
<span class="gu">@@ -10,4 +10,7 @@ class CompareCommand(PrimerCommand):</span>

<span class="w"> </span>    def _truncate_comment(self, comment: str) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;GitHub allows only a set number of characters in a comment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(comment) &lt;= MAX_GITHUB_COMMENT_LENGTH:</span>
<span class="gi">+            return comment</span>
<span class="gi">+        truncated = comment[:MAX_GITHUB_COMMENT_LENGTH - 3] + &quot;...&quot;</span>
<span class="gi">+        return truncated</span>
<span class="gh">diff --git a/pylint/testutils/_primer/primer_prepare_command.py b/pylint/testutils/_primer/primer_prepare_command.py</span>
<span class="gh">index 6ceb3a886..043fed10e 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/primer_prepare_command.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/primer_prepare_command.py</span>
<span class="gu">@@ -1,9 +1,48 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>import sys
<span class="gi">+import os</span>
<span class="w"> </span>from git.cmd import Git
<span class="w"> </span>from git.repo import Repo
<span class="w"> </span>from pylint.testutils._primer.primer_command import PrimerCommand


<span class="w"> </span>class PrepareCommand(PrimerCommand):
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self, repo_path: str, branch: str):</span>
<span class="gi">+        super().__init__()</span>
<span class="gi">+        self.repo_path = repo_path</span>
<span class="gi">+        self.branch = branch</span>
<span class="gi">+        self.repo = None</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; int:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.repo = Repo(self.repo_path)</span>
<span class="gi">+            self._prepare_repository()</span>
<span class="gi">+            return 0</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            print(f&quot;Error: {e}&quot;, file=sys.stderr)</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+    def _prepare_repository(self) -&gt; None:</span>
<span class="gi">+        self._ensure_clean_working_tree()</span>
<span class="gi">+        self._checkout_branch()</span>
<span class="gi">+        self._pull_latest_changes()</span>
<span class="gi">+</span>
<span class="gi">+    def _ensure_clean_working_tree(self) -&gt; None:</span>
<span class="gi">+        if self.repo.is_dirty():</span>
<span class="gi">+            raise ValueError(&quot;Working tree is not clean. Please commit or stash your changes.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _checkout_branch(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.repo.git.checkout(self.branch)</span>
<span class="gi">+        except Git.GitCommandError:</span>
<span class="gi">+            print(f&quot;Branch &#39;{self.branch}&#39; not found. Creating a new branch.&quot;, file=sys.stderr)</span>
<span class="gi">+            self.repo.git.checkout(&#39;-b&#39;, self.branch)</span>
<span class="gi">+</span>
<span class="gi">+    def _pull_latest_changes(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.repo.git.pull(&#39;origin&#39;, self.branch)</span>
<span class="gi">+        except Git.GitCommandError as e:</span>
<span class="gi">+            if &quot;There is no tracking information for the current branch&quot; in str(e):</span>
<span class="gi">+                print(f&quot;No upstream branch set for &#39;{self.branch}&#39;. Skipping pull.&quot;, file=sys.stderr)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gh">diff --git a/pylint/testutils/_primer/primer_run_command.py b/pylint/testutils/_primer/primer_run_command.py</span>
<span class="gh">index 9a5876619..61f683b41 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/primer_run_command.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/primer_run_command.py</span>
<span class="gu">@@ -18,4 +18,8 @@ class RunCommand(PrimerCommand):</span>
<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _filter_fatal_errors(messages: list[OldJsonExport]) -&gt;list[Message]:
<span class="w"> </span>        &quot;&quot;&quot;Separate fatal errors so we can report them independently.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [</span>
<span class="gi">+            Message(**msg)</span>
<span class="gi">+            for msg in messages</span>
<span class="gi">+            if msg.get(&#39;type&#39;) == &#39;fatal&#39;</span>
<span class="gi">+        ]</span>
<span class="gh">diff --git a/pylint/testutils/_run.py b/pylint/testutils/_run.py</span>
<span class="gh">index 8752caca2..ed1b71a6e 100644</span>
<span class="gd">--- a/pylint/testutils/_run.py</span>
<span class="gi">+++ b/pylint/testutils/_run.py</span>
<span class="gu">@@ -11,7 +11,9 @@ from pylint.testutils.lint_module_test import PYLINTRC</span>

<span class="w"> </span>def _add_rcfile_default_pylintrc(args: list[str]) -&gt;list[str]:
<span class="w"> </span>    &quot;&quot;&quot;Add a default pylintrc with the rcfile option in a list of pylint args.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;--rcfile&quot; not in args:</span>
<span class="gi">+        args.extend([&quot;--rcfile&quot;, PYLINTRC])</span>
<span class="gi">+    return args</span>


<span class="w"> </span>class _Run(LintRun):
<span class="gh">diff --git a/pylint/testutils/checker_test_case.py b/pylint/testutils/checker_test_case.py</span>
<span class="gh">index fa4a782ae..b192c073d 100644</span>
<span class="gd">--- a/pylint/testutils/checker_test_case.py</span>
<span class="gi">+++ b/pylint/testutils/checker_test_case.py</span>
<span class="gu">@@ -18,7 +18,12 @@ class CheckerTestCase:</span>
<span class="w"> </span>    @contextlib.contextmanager
<span class="w"> </span>    def assertNoMessages(self) -&gt;Iterator[None]:
<span class="w"> </span>        &quot;&quot;&quot;Assert that no messages are added by the given method.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        old_messages = linter.reporter.messages[:]</span>
<span class="gi">+        yield</span>
<span class="gi">+        new_messages = linter.reporter.messages[:]</span>
<span class="gi">+        added_messages = new_messages[len(old_messages):]</span>
<span class="gi">+        if added_messages:</span>
<span class="gi">+            raise AssertionError(f&quot;Unexpected message(s) added: {added_messages}&quot;)</span>

<span class="w"> </span>    @contextlib.contextmanager
<span class="w"> </span>    def assertAddsMessages(self, *messages: MessageTest, ignore_position:
<span class="gu">@@ -33,8 +38,26 @@ class CheckerTestCase:</span>
<span class="w"> </span>        arguments (line, col_offset, ...) will be skipped. This can be used to
<span class="w"> </span>        just test messages for the correct node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        old_messages = linter.reporter.messages[:]</span>
<span class="gi">+        yield</span>
<span class="gi">+        new_messages = linter.reporter.messages[:]</span>
<span class="gi">+        added_messages = new_messages[len(old_messages):]</span>
<span class="gi">+        </span>
<span class="gi">+        if len(added_messages) != len(messages):</span>
<span class="gi">+            raise AssertionError(</span>
<span class="gi">+                f&quot;Expected {len(messages)} message(s), got {len(added_messages)}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        </span>
<span class="gi">+        for expected, actual in zip(messages, added_messages):</span>
<span class="gi">+            if not ignore_position:</span>
<span class="gi">+                assert expected.line == actual.line, f&quot;Line mismatch: expected {expected.line}, got {actual.line}&quot;</span>
<span class="gi">+                assert expected.column == actual.column, f&quot;Column mismatch: expected {expected.column}, got {actual.column}&quot;</span>
<span class="gi">+            </span>
<span class="gi">+            assert expected.msg_id == actual.msg_id, f&quot;Message ID mismatch: expected {expected.msg_id}, got {actual.msg_id}&quot;</span>
<span class="gi">+            assert expected.symbol == actual.symbol, f&quot;Symbol mismatch: expected {expected.symbol}, got {actual.symbol}&quot;</span>
<span class="gi">+            assert expected.msg == actual.msg, f&quot;Message mismatch: expected {expected.msg}, got {actual.msg}&quot;</span>

<span class="w"> </span>    def walk(self, node: nodes.NodeNG) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Recursive walk on the given node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        walker = ASTWalker(linter)</span>
<span class="gi">+        walker.walk(node)</span>
<span class="gh">diff --git a/pylint/testutils/configuration_test.py b/pylint/testutils/configuration_test.py</span>
<span class="gh">index 3c00e103a..3d131fed2 100644</span>
<span class="gd">--- a/pylint/testutils/configuration_test.py</span>
<span class="gi">+++ b/pylint/testutils/configuration_test.py</span>
<span class="gu">@@ -15,7 +15,11 @@ PylintConfiguration = Dict[str, ConfigurationValue]</span>
<span class="w"> </span>def get_expected_or_default(tested_configuration_file: (str | Path), suffix:
<span class="w"> </span>    str, default: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Return the expected value from the file if it exists, or the given default.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    expected_file = Path(tested_configuration_file).with_suffix(suffix)</span>
<span class="gi">+    if expected_file.exists():</span>
<span class="gi">+        with expected_file.open(&quot;r&quot;) as f:</span>
<span class="gi">+            return f.read().strip()</span>
<span class="gi">+    return default</span>


<span class="w"> </span>EXPECTED_CONF_APPEND_KEY = &#39;functional_append&#39;
<span class="gu">@@ -25,22 +29,62 @@ EXPECTED_CONF_REMOVE_KEY = &#39;functional_remove&#39;</span>
<span class="w"> </span>def get_expected_configuration(configuration_path: str,
<span class="w"> </span>    default_configuration: PylintConfiguration) -&gt;PylintConfiguration:
<span class="w"> </span>    &quot;&quot;&quot;Get the expected parsed configuration of a configuration functional test.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    expected_configuration = copy.deepcopy(default_configuration)</span>
<span class="gi">+    expected_file = Path(configuration_path).with_suffix(&#39;.json&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    if expected_file.exists():</span>
<span class="gi">+        with expected_file.open(&quot;r&quot;) as f:</span>
<span class="gi">+            expected_json = json.load(f)</span>
<span class="gi">+        </span>
<span class="gi">+        for key, value in expected_json.get(EXPECTED_CONF_APPEND_KEY, {}).items():</span>
<span class="gi">+            if key in expected_configuration:</span>
<span class="gi">+                expected_configuration[key].extend(value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                expected_configuration[key] = value</span>
<span class="gi">+        </span>
<span class="gi">+        for key, value in expected_json.get(EXPECTED_CONF_REMOVE_KEY, {}).items():</span>
<span class="gi">+            if key in expected_configuration:</span>
<span class="gi">+                for item in value:</span>
<span class="gi">+                    if item in expected_configuration[key]:</span>
<span class="gi">+                        expected_configuration[key].remove(item)</span>
<span class="gi">+    </span>
<span class="gi">+    return expected_configuration</span>


<span class="w"> </span>def get_related_files(tested_configuration_file: (str | Path),
<span class="w"> </span>    suffix_filter: str) -&gt;list[Path]:
<span class="w"> </span>    &quot;&quot;&quot;Return all the file related to a test conf file ending with a suffix.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    base_path = Path(tested_configuration_file).with_suffix(&#39;&#39;)</span>
<span class="gi">+    return list(base_path.parent.glob(f&quot;{base_path.name}*{suffix_filter}&quot;))</span>


<span class="w"> </span>def get_expected_output(configuration_path: (str | Path),
<span class="w"> </span>    user_specific_path: Path) -&gt;tuple[int, str]:
<span class="w"> </span>    &quot;&quot;&quot;Get the expected output of a functional test.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    expected_output_file = Path(configuration_path).with_suffix(&#39;.out&#39;)</span>
<span class="gi">+    if expected_output_file.exists():</span>
<span class="gi">+        with expected_output_file.open(&quot;r&quot;) as f:</span>
<span class="gi">+            content = f.read().strip()</span>
<span class="gi">+        lines = content.splitlines()</span>
<span class="gi">+        return_code = int(lines[0])</span>
<span class="gi">+        output = &quot;\n&quot;.join(lines[1:])</span>
<span class="gi">+        return return_code, output</span>
<span class="gi">+    else:</span>
<span class="gi">+        return 0, &quot;&quot;</span>


<span class="w"> </span>def run_using_a_configuration_file(configuration_path: (Path | str),
<span class="w"> </span>    file_to_lint: str=__file__) -&gt;tuple[Mock, Mock, Run]:
<span class="w"> </span>    &quot;&quot;&quot;Simulate a run with a configuration without really launching the checks.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    args = [&quot;--rcfile&quot;, str(configuration_path), file_to_lint]</span>
<span class="gi">+    </span>
<span class="gi">+    reporter = Mock()</span>
<span class="gi">+    linter = Mock()</span>
<span class="gi">+    linter.config = Mock()</span>
<span class="gi">+    linter.reporter = reporter</span>
<span class="gi">+</span>
<span class="gi">+    with unittest.mock.patch(&quot;pylint.lint.pylinter.PyLinter&quot;, return_value=linter):</span>
<span class="gi">+        with unittest.mock.patch(&quot;pylint.lint.run._do_run&quot;):</span>
<span class="gi">+            run = Run(args)</span>
<span class="gi">+    </span>
<span class="gi">+    return reporter, linter, run</span>
<span class="gh">diff --git a/pylint/testutils/decorator.py b/pylint/testutils/decorator.py</span>
<span class="gh">index 50a300f10..bd145ef2d 100644</span>
<span class="gd">--- a/pylint/testutils/decorator.py</span>
<span class="gi">+++ b/pylint/testutils/decorator.py</span>
<span class="gu">@@ -12,4 +12,22 @@ def set_config(**kwargs: Any) -&gt;Callable[[Callable[..., None]], Callable[</span>
<span class="w"> </span>    Passing the args and kwargs back to the test function itself
<span class="w"> </span>    allows this decorator to be used on parameterized test cases.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(test):</span>
<span class="gi">+        @functools.wraps(test)</span>
<span class="gi">+        def wrapper(self, *args, **test_kwargs):</span>
<span class="gi">+            if not isinstance(self, CheckerTestCase):</span>
<span class="gi">+                raise TypeError(&quot;set_config can only be used with CheckerTestCase&quot;)</span>
<span class="gi">+            </span>
<span class="gi">+            original_config = {}</span>
<span class="gi">+            for key, value in kwargs.items():</span>
<span class="gi">+                original_config[key] = getattr(self.checker, key)</span>
<span class="gi">+                setattr(self.checker, key, value)</span>
<span class="gi">+            </span>
<span class="gi">+            try:</span>
<span class="gi">+                return test(self, *args, **test_kwargs)</span>
<span class="gi">+            finally:</span>
<span class="gi">+                for key, value in original_config.items():</span>
<span class="gi">+                    setattr(self.checker, key, value)</span>
<span class="gi">+        </span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    return decorator</span>
<span class="gh">diff --git a/pylint/testutils/functional/find_functional_tests.py b/pylint/testutils/functional/find_functional_tests.py</span>
<span class="gh">index 79a06c358..e804e602d 100644</span>
<span class="gd">--- a/pylint/testutils/functional/find_functional_tests.py</span>
<span class="gi">+++ b/pylint/testutils/functional/find_functional_tests.py</span>
<span class="gu">@@ -19,7 +19,21 @@ def get_functional_test_files_from_directory(input_dir: (Path | str),</span>
<span class="w"> </span>    max_file_per_directory: int=REASONABLY_DISPLAYABLE_VERTICALLY) -&gt;list[
<span class="w"> </span>    FunctionalTestFile]:
<span class="w"> </span>    &quot;&quot;&quot;Get all functional tests in the input_dir.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    input_path = Path(input_dir)</span>
<span class="gi">+    _check_functional_tests_structure(input_path, max_file_per_directory)</span>
<span class="gi">+    </span>
<span class="gi">+    functional_test_files = []</span>
<span class="gi">+    for root, _, files in os.walk(input_path):</span>
<span class="gi">+        root_path = Path(root)</span>
<span class="gi">+        if root_path.name.startswith(&#39;_&#39;) or root_path.name in IGNORED_PARENT_DIRS or root_path.parent.name in IGNORED_PARENT_PARENT_DIRS:</span>
<span class="gi">+            continue</span>
<span class="gi">+        </span>
<span class="gi">+        for file in files:</span>
<span class="gi">+            if file.endswith(&#39;.py&#39;) and not file.startswith(&#39;_&#39;):</span>
<span class="gi">+                file_path = root_path / file</span>
<span class="gi">+                functional_test_files.append(FunctionalTestFile(file_path))</span>
<span class="gi">+    </span>
<span class="gi">+    return functional_test_files</span>


<span class="w"> </span>def _check_functional_tests_structure(directory: Path,
<span class="gu">@@ -28,4 +42,20 @@ def _check_functional_tests_structure(directory: Path,</span>

<span class="w"> </span>    Ignore underscored directories or files.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for root, dirs, files in os.walk(directory):</span>
<span class="gi">+        root_path = Path(root)</span>
<span class="gi">+        if root_path.name.startswith(&#39;_&#39;):</span>
<span class="gi">+            continue</span>
<span class="gi">+        </span>
<span class="gi">+        py_files = [f for f in files if f.endswith(&#39;.py&#39;) and not f.startswith(&#39;_&#39;)]</span>
<span class="gi">+        </span>
<span class="gi">+        if len(py_files) &gt; max_file_per_directory:</span>
<span class="gi">+            raise ValueError(f&quot;Directory {root} contains {len(py_files)} Python files, &quot;</span>
<span class="gi">+                             f&quot;which exceeds the maximum of {max_file_per_directory}.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        for dir_name in dirs:</span>
<span class="gi">+            if not dir_name.startswith(&#39;_&#39;):</span>
<span class="gi">+                subdir = root_path / dir_name</span>
<span class="gi">+                if any(f.endswith(&#39;.py&#39;) for f in os.listdir(subdir) if not f.startswith(&#39;_&#39;)):</span>
<span class="gi">+                    raise ValueError(f&quot;Subdirectory {subdir} contains Python files. &quot;</span>
<span class="gi">+                                     f&quot;All Python files should be in the top-level directory.&quot;)</span>
<span class="gh">diff --git a/pylint/testutils/functional/lint_module_output_update.py b/pylint/testutils/functional/lint_module_output_update.py</span>
<span class="gh">index d8e3eb6ac..1eacee6e2 100644</span>
<span class="gd">--- a/pylint/testutils/functional/lint_module_output_update.py</span>
<span class="gi">+++ b/pylint/testutils/functional/lint_module_output_update.py</span>
<span class="gu">@@ -20,4 +20,14 @@ class LintModuleOutputUpdate(LintModuleTest):</span>
<span class="w"> </span>    def _check_output_text(self, _: MessageCounter, expected_output: list[
<span class="w"> </span>        OutputLine], actual_output: list[OutputLine]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Overwrite or remove the expected output file based on actual output.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        expected_output_file = self._test_file.expected_output</span>
<span class="gi">+        if actual_output:</span>
<span class="gi">+            # If there&#39;s actual output, overwrite the expected output file</span>
<span class="gi">+            with open(expected_output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;&#39;) as f:</span>
<span class="gi">+                writer = csv.writer(f, dialect=&#39;test&#39;)</span>
<span class="gi">+                for line in actual_output:</span>
<span class="gi">+                    writer.writerow([str(line.symbol), line.msg, line.line, line.column, line.path, line.module, line.obj])</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If there&#39;s no actual output, remove the expected output file if it exists</span>
<span class="gi">+            if os.path.exists(expected_output_file):</span>
<span class="gi">+                os.remove(expected_output_file)</span>
<span class="gh">diff --git a/pylint/testutils/functional/test_file.py b/pylint/testutils/functional/test_file.py</span>
<span class="gh">index 6fe0e17be..1f8cb2bfb 100644</span>
<span class="gd">--- a/pylint/testutils/functional/test_file.py</span>
<span class="gi">+++ b/pylint/testutils/functional/test_file.py</span>
<span class="gu">@@ -7,11 +7,14 @@ from typing import TypedDict</span>

<span class="w"> </span>def parse_python_version(ver_str: str) -&gt;tuple[int, ...]:
<span class="w"> </span>    &quot;&quot;&quot;Convert python version to a tuple of integers for easy comparison.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return tuple(int(v) for v in ver_str.split(&#39;.&#39;))</span>


<span class="w"> </span>class NoFileError(Exception):
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;Exception raised when a file is not found.&quot;&quot;&quot;</span>
<span class="gi">+    def __init__(self, filename: str) -&gt; None:</span>
<span class="gi">+        super().__init__(f&quot;File not found: {filename}&quot;)</span>
<span class="gi">+        self.filename = filename</span>


<span class="w"> </span>class TestFileOptions(TypedDict):
<span class="gh">diff --git a/pylint/testutils/get_test_info.py b/pylint/testutils/get_test_info.py</span>
<span class="gh">index 4d1b573f1..9b0a54e6b 100644</span>
<span class="gd">--- a/pylint/testutils/get_test_info.py</span>
<span class="gi">+++ b/pylint/testutils/get_test_info.py</span>
<span class="gu">@@ -16,4 +16,25 @@ def _get_tests_info(input_dir: str, msg_dir: str, prefix: str, suffix: str</span>
<span class="w"> </span>        message for python &gt;=  x.y -&gt;  message =  &lt;name&gt;_pyxy.txt
<span class="w"> </span>        lower versions             -&gt;  message with highest num
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for input_file in glob(join(input_dir, prefix + &#39;*&#39; + suffix)):</span>
<span class="gi">+        base_name = splitext(basename(input_file))[0]</span>
<span class="gi">+        msg_file = _get_message_file(msg_dir, base_name)</span>
<span class="gi">+        if msg_file:</span>
<span class="gi">+            result.append((input_file, msg_file))</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+def _get_message_file(msg_dir: str, base_name: str) -&gt; str:</span>
<span class="gi">+    &quot;&quot;&quot;Get the message file with the highest version number for the given base name.&quot;&quot;&quot;</span>
<span class="gi">+    candidates = glob(join(msg_dir, base_name + &#39;*.txt&#39;))</span>
<span class="gi">+    if not candidates:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    # Sort candidates by version number</span>
<span class="gi">+    sorted_candidates = sorted(</span>
<span class="gi">+        candidates,</span>
<span class="gi">+        key=lambda x: tuple(map(int, splitext(basename(x))[0].split(&#39;_&#39;)[-1][2:]))</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    # Return the candidate with the highest version number</span>
<span class="gi">+    return sorted_candidates[-1]</span>
<span class="gh">diff --git a/pylint/testutils/lint_module_test.py b/pylint/testutils/lint_module_test.py</span>
<span class="gh">index 646c8986f..d9877e617 100644</span>
<span class="gd">--- a/pylint/testutils/lint_module_test.py</span>
<span class="gi">+++ b/pylint/testutils/lint_module_test.py</span>
<span class="gu">@@ -90,7 +90,18 @@ class LintModuleTest:</span>
<span class="w"> </span>        :returns: A dict mapping line,msg-symbol tuples to the count on this line.
<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        messages = Counter()</span>
<span class="gi">+        for lineno, line in enumerate(stream, start=1):</span>
<span class="gi">+            match = _EXPECTED_RE.search(line)</span>
<span class="gi">+            if match:</span>
<span class="gi">+                line = match.group(&#39;line&#39;)</span>
<span class="gi">+                if line is None:</span>
<span class="gi">+                    line = lineno</span>
<span class="gi">+                else:</span>
<span class="gi">+                    line = int(line)</span>
<span class="gi">+                msg_id = match.group(&#39;msg_id&#39;)</span>
<span class="gi">+                messages[(line, msg_id)] += 1</span>
<span class="gi">+        return messages</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def multiset_difference(expected_entries: MessageCounter,
<span class="gu">@@ -100,11 +111,29 @@ class LintModuleTest:</span>

<span class="w"> </span>        A multiset is a dict with the cardinality of the key as the value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        missing = Counter()</span>
<span class="gi">+        unexpected = {}</span>
<span class="gi">+        for key, count in expected_entries.items():</span>
<span class="gi">+            if actual_entries[key] &lt; count:</span>
<span class="gi">+                missing[key] = count - actual_entries[key]</span>
<span class="gi">+        for key, count in actual_entries.items():</span>
<span class="gi">+            if expected_entries[key] &lt; count:</span>
<span class="gi">+                unexpected[key] = count - expected_entries[key]</span>
<span class="gi">+        return missing, unexpected</span>

<span class="w"> </span>    def _check_output_text(self, _: MessageCounter, expected_output: list[
<span class="w"> </span>        OutputLine], actual_output: list[OutputLine]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;This is a function because we want to be able to update the text in
<span class="w"> </span>        LintModuleOutputUpdate.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if expected_output != actual_output:</span>
<span class="gi">+            diff = &#39;\n&#39;.join(</span>
<span class="gi">+                difflib.unified_diff(</span>
<span class="gi">+                    [str(l) for l in expected_output],</span>
<span class="gi">+                    [str(l) for l in actual_output],</span>
<span class="gi">+                    fromfile=&#39;expected&#39;,</span>
<span class="gi">+                    tofile=&#39;actual&#39;,</span>
<span class="gi">+                    n=0,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            pytest.fail(f&#39;\n{diff}&#39;)</span>
<span class="gh">diff --git a/pylint/testutils/output_line.py b/pylint/testutils/output_line.py</span>
<span class="gh">index 50d52257c..3e7a319a7 100644</span>
<span class="gd">--- a/pylint/testutils/output_line.py</span>
<span class="gi">+++ b/pylint/testutils/output_line.py</span>
<span class="gu">@@ -35,19 +35,32 @@ class OutputLine(NamedTuple):</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_msg(cls, msg: Message, check_endline: bool=True) -&gt;OutputLine:
<span class="w"> </span>        &quot;&quot;&quot;Create an OutputLine from a Pylint Message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            symbol=msg.symbol,</span>
<span class="gi">+            lineno=msg.line,</span>
<span class="gi">+            column=cls._get_column(msg.column),</span>
<span class="gi">+            end_lineno=cls._get_py38_none_value(msg.end_line, check_endline),</span>
<span class="gi">+            end_column=cls._get_py38_none_value(msg.end_column, check_endline),</span>
<span class="gi">+            object=msg.obj or &quot;&quot;,</span>
<span class="gi">+            msg=msg.msg or &quot;&quot;,</span>
<span class="gi">+            confidence=msg.confidence.name</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _get_column(column: (str | int)) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Handle column numbers.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(column, str):</span>
<span class="gi">+            return int(column)</span>
<span class="gi">+        return column or 0</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _get_py38_none_value(value: _T, check_endline: bool) -&gt;(_T | None):
<span class="w"> </span>        &quot;&quot;&quot;Used to make end_line and end_column None as indicated by our version
<span class="w"> </span>        compared to `min_pyver_end_position`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if check_endline:</span>
<span class="gi">+            return value</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def from_csv(cls, row: (Sequence[str] | str), check_endline: bool=True
<span class="gu">@@ -55,15 +68,38 @@ class OutputLine(NamedTuple):</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an OutputLine from a comma separated list (the functional tests
<span class="w"> </span>        expected output .txt files).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(row, str):</span>
<span class="gi">+            row = row.split(&#39;,&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        return cls(</span>
<span class="gi">+            symbol=row[0],</span>
<span class="gi">+            lineno=int(row[1]),</span>
<span class="gi">+            column=cls._get_column(row[2]),</span>
<span class="gi">+            end_lineno=cls._get_py38_none_value(cls._value_to_optional_int(row[3]), check_endline),</span>
<span class="gi">+            end_column=cls._get_py38_none_value(cls._value_to_optional_int(row[4]), check_endline),</span>
<span class="gi">+            object=row[5],</span>
<span class="gi">+            msg=row[6],</span>
<span class="gi">+            confidence=row[7]</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def to_csv(self) -&gt;tuple[str, str, str, str, str, str, str, str]:
<span class="w"> </span>        &quot;&quot;&quot;Convert an OutputLine to a tuple of string to be written by a
<span class="w"> </span>        csv-writer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.symbol,</span>
<span class="gi">+            str(self.lineno),</span>
<span class="gi">+            str(self.column),</span>
<span class="gi">+            str(self.end_lineno) if self.end_lineno is not None else &#39;&#39;,</span>
<span class="gi">+            str(self.end_column) if self.end_column is not None else &#39;&#39;,</span>
<span class="gi">+            self.object,</span>
<span class="gi">+            self.msg,</span>
<span class="gi">+            self.confidence</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _value_to_optional_int(value: (str | None)) -&gt;(int | None):
<span class="w"> </span>        &quot;&quot;&quot;Checks if a (stringified) value should be None or a Python integer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if value is None or value == &#39;&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return int(value)</span>
<span class="gh">diff --git a/pylint/testutils/pyreverse.py b/pylint/testutils/pyreverse.py</span>
<span class="gh">index f9eeb3f8c..96e2fb655 100644</span>
<span class="gd">--- a/pylint/testutils/pyreverse.py</span>
<span class="gi">+++ b/pylint/testutils/pyreverse.py</span>
<span class="gu">@@ -58,7 +58,22 @@ class FunctionalPyreverseTestfile(NamedTuple):</span>
<span class="w"> </span>    options: TestFileOptions


<span class="gd">-def get_functional_test_files(root_directory: Path) -&gt;list[</span>
<span class="gd">-    FunctionalPyreverseTestfile]:</span>
<span class="gi">+def get_functional_test_files(root_directory: Path) -&gt; list[FunctionalPyreverseTestfile]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get all functional test files from the given directory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    functional_test_files = []</span>
<span class="gi">+    for source_file in root_directory.rglob(&#39;*.py&#39;):</span>
<span class="gi">+        if source_file.name.startswith(&#39;func_&#39;):</span>
<span class="gi">+            config_file = source_file.with_suffix(&#39;.rc&#39;)</span>
<span class="gi">+            if config_file.exists():</span>
<span class="gi">+                config = configparser.ConfigParser()</span>
<span class="gi">+                config.read(config_file)</span>
<span class="gi">+                </span>
<span class="gi">+                options = TestFileOptions(</span>
<span class="gi">+                    source_roots=config.get(&#39;testoptions&#39;, &#39;source_roots&#39;, fallback=&#39;&#39;).split(&#39;,&#39;),</span>
<span class="gi">+                    output_formats=config.get(&#39;testoptions&#39;, &#39;output_formats&#39;, fallback=&#39;&#39;).split(&#39;,&#39;),</span>
<span class="gi">+                    command_line_args=shlex.split(config.get(&#39;testoptions&#39;, &#39;command_line_args&#39;, fallback=&#39;&#39;))</span>
<span class="gi">+                )</span>
<span class="gi">+                </span>
<span class="gi">+                functional_test_files.append(FunctionalPyreverseTestfile(source=source_file, options=options))</span>
<span class="gi">+    </span>
<span class="gi">+    return functional_test_files</span>
<span class="gh">diff --git a/pylint/testutils/reporter_for_tests.py b/pylint/testutils/reporter_for_tests.py</span>
<span class="gh">index 194c5b93e..60564b4c6 100644</span>
<span class="gd">--- a/pylint/testutils/reporter_for_tests.py</span>
<span class="gi">+++ b/pylint/testutils/reporter_for_tests.py</span>
<span class="gu">@@ -18,11 +18,11 @@ class GenericTestReporter(BaseReporter):</span>

<span class="w"> </span>    def handle_message(self, msg: Message) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Append messages to the list of messages of the reporter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.out.write(f&quot;{msg.path[len(self.path_strip_prefix):]}:{msg.line}: {msg.symbol} {msg.msg}\n&quot;)</span>

<span class="w"> </span>    def finalize(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Format and print messages in the context of the path.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.out.getvalue()</span>

<span class="w"> </span>    def display_reports(self, layout: Section) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Ignore layouts.&quot;&quot;&quot;
<span class="gu">@@ -30,7 +30,15 @@ class GenericTestReporter(BaseReporter):</span>


<span class="w"> </span>class MinimalTestReporter(BaseReporter):
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self) -&gt;None:</span>
<span class="gi">+        super().__init__()</span>
<span class="gi">+        self.messages: list[Message] = []</span>
<span class="gi">+</span>
<span class="gi">+    def handle_message(self, msg: Message) -&gt;None:</span>
<span class="gi">+        self.messages.append(msg)</span>
<span class="gi">+</span>
<span class="gi">+    def finalize(self) -&gt;None:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>class FunctionalTestReporter(BaseReporter):
<span class="gh">diff --git a/pylint/testutils/unittest_linter.py b/pylint/testutils/unittest_linter.py</span>
<span class="gh">index e3aec6085..fe685a61d 100644</span>
<span class="gd">--- a/pylint/testutils/unittest_linter.py</span>
<span class="gi">+++ b/pylint/testutils/unittest_linter.py</span>
<span class="gu">@@ -18,4 +18,14 @@ class UnittestLinter(PyLinter):</span>
<span class="w"> </span>        None)=None, col_offset: (int | None)=None, end_lineno: (int | None)
<span class="w"> </span>        =None, end_col_offset: (int | None)=None) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Add a MessageTest to the _messages attribute of the linter class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message = MessageTest(</span>
<span class="gi">+            msg_id=msgid,</span>
<span class="gi">+            line=line,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=args,</span>
<span class="gi">+            confidence=confidence or UNDEFINED,</span>
<span class="gi">+            col=col_offset,</span>
<span class="gi">+            end_line=end_lineno,</span>
<span class="gi">+            end_col=end_col_offset,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._messages.append(message)</span>
<span class="gh">diff --git a/pylint/testutils/utils.py b/pylint/testutils/utils.py</span>
<span class="gh">index 8ca619cfa..230a68b58 100644</span>
<span class="gd">--- a/pylint/testutils/utils.py</span>
<span class="gi">+++ b/pylint/testutils/utils.py</span>
<span class="gu">@@ -11,7 +11,15 @@ from typing import TextIO</span>
<span class="w"> </span>@contextlib.contextmanager
<span class="w"> </span>def _patch_streams(out: TextIO) -&gt;Iterator[None]:
<span class="w"> </span>    &quot;&quot;&quot;Patch and subsequently reset a text stream.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    old_stdout = sys.stdout</span>
<span class="gi">+    old_stderr = sys.stderr</span>
<span class="gi">+    sys.stdout = out</span>
<span class="gi">+    sys.stderr = out</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        sys.stdout = old_stdout</span>
<span class="gi">+        sys.stderr = old_stderr</span>


<span class="w"> </span>def create_files(paths: list[str], chroot: str=&#39;.&#39;) -&gt;None:
<span class="gu">@@ -33,4 +41,10 @@ def create_files(paths: list[str], chroot: str=&#39;.&#39;) -&gt;None:</span>
<span class="w"> </span>    &gt;&gt;&gt; isfile(&#39;/tmp/a/b/foo.py&#39;)
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for path in paths:</span>
<span class="gi">+        full_path = Path(chroot) / path</span>
<span class="gi">+        if path.endswith(&#39;/&#39;):</span>
<span class="gi">+            full_path.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            full_path.parent.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+            full_path.touch()</span>
<span class="gh">diff --git a/pylint/utils/ast_walker.py b/pylint/utils/ast_walker.py</span>
<span class="gh">index 8872be9e0..5f4e2c841 100644</span>
<span class="gd">--- a/pylint/utils/ast_walker.py</span>
<span class="gi">+++ b/pylint/utils/ast_walker.py</span>
<span class="gu">@@ -24,10 +24,30 @@ class ASTWalker:</span>

<span class="w"> </span>    def add_checker(self, checker: BaseChecker) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Walk to the checker&#39;s dir and collect visit and leave methods.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for member in dir(checker):</span>
<span class="gi">+            if member.startswith(&#39;visit_&#39;):</span>
<span class="gi">+                self.visit_events[member[6:]].append(getattr(checker, member))</span>
<span class="gi">+            elif member.startswith(&#39;leave_&#39;):</span>
<span class="gi">+                self.leave_events[member[6:]].append(getattr(checker, member))</span>

<span class="w"> </span>    def walk(self, astroid: nodes.NodeNG) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Call visit events of astroid checkers for the given node, recurse on
<span class="w"> </span>        its children, then leave events.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            callbacks = self.visit_events[astroid.__class__.__name__]</span>
<span class="gi">+            for cb in callbacks:</span>
<span class="gi">+                cb(astroid)</span>
<span class="gi">+            </span>
<span class="gi">+            for child in astroid.get_children():</span>
<span class="gi">+                self.walk(child)</span>
<span class="gi">+            </span>
<span class="gi">+            callbacks = self.leave_events[astroid.__class__.__name__]</span>
<span class="gi">+            for cb in callbacks:</span>
<span class="gi">+                cb(astroid)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if not self.exception_msg:</span>
<span class="gi">+                self.exception_msg = True</span>
<span class="gi">+                exc_info = sys.exc_info()</span>
<span class="gi">+                traceback.print_exception(*exc_info)</span>
<span class="gi">+                self.linter.add_message(&#39;astroid-error&#39;, args=str(exc_info[1]))</span>
<span class="gh">diff --git a/pylint/utils/docs.py b/pylint/utils/docs.py</span>
<span class="gh">index 69b539e48..baebab595 100644</span>
<span class="gd">--- a/pylint/utils/docs.py</span>
<span class="gi">+++ b/pylint/utils/docs.py</span>
<span class="gu">@@ -10,21 +10,63 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>def _get_checkers_infos(linter: PyLinter) -&gt;dict[str, dict[str, Any]]:
<span class="w"> </span>    &quot;&quot;&quot;Get info from a checker and handle KeyError.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    checkers_infos = {}</span>
<span class="gi">+    for checker in linter.get_checkers():</span>
<span class="gi">+        name = checker.name</span>
<span class="gi">+        try:</span>
<span class="gi">+            checkers_infos[name] = {</span>
<span class="gi">+                &quot;name&quot;: name,</span>
<span class="gi">+                &quot;options&quot;: list(checker.options),</span>
<span class="gi">+                &quot;msgs&quot;: dict(checker.msgs),</span>
<span class="gi">+                &quot;reports&quot;: list(checker.reports),</span>
<span class="gi">+            }</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # Ignore checkers without options or messages</span>
<span class="gi">+            continue</span>
<span class="gi">+    return checkers_infos</span>


<span class="w"> </span>def _get_global_options_documentation(linter: PyLinter) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Get documentation for the main checker.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for checker in linter.get_checkers():</span>
<span class="gi">+        if checker.name == MAIN_CHECKER_NAME:</span>
<span class="gi">+            result.append(get_rst_title(&quot;Global options&quot;, &quot;-&quot;))</span>
<span class="gi">+            result.extend(checker.options_and_values())</span>
<span class="gi">+            break</span>
<span class="gi">+    return &quot;\n&quot;.join(result)</span>


<span class="w"> </span>def _get_checkers_documentation(linter: PyLinter, show_options: bool=True
<span class="w"> </span>    ) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Get documentation for individual checkers.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for checker in sorted(linter.get_checkers(), key=lambda x: x.name):</span>
<span class="gi">+        if checker.name == MAIN_CHECKER_NAME:</span>
<span class="gi">+            continue</span>
<span class="gi">+        result.append(get_rst_title(checker.name.capitalize(), &quot;~&quot;))</span>
<span class="gi">+        if checker.options and show_options:</span>
<span class="gi">+            result.append(&quot;Options:&quot;)</span>
<span class="gi">+            result.append(&quot;--------&quot;)</span>
<span class="gi">+            result.extend(checker.options_and_values())</span>
<span class="gi">+            result.append(&quot;&quot;)</span>
<span class="gi">+        if checker.msgs:</span>
<span class="gi">+            result.append(&quot;Messages:&quot;)</span>
<span class="gi">+            result.append(&quot;---------&quot;)</span>
<span class="gi">+            for message in sorted(checker.msgs.values(), key=lambda x: x.msgid):</span>
<span class="gi">+                result.append(f&quot;{message.msgid} ({message.symbol}): {message.msg}&quot;)</span>
<span class="gi">+            result.append(&quot;&quot;)</span>
<span class="gi">+    return &quot;\n&quot;.join(result)</span>


<span class="w"> </span>def print_full_documentation(linter: PyLinter, stream: TextIO=sys.stdout,
<span class="w"> </span>    show_options: bool=True) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Output a full documentation in ReST format.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stream.write(get_rst_title(&quot;Pylint Global Options and Switches&quot;, &quot;=&quot;))</span>
<span class="gi">+    stream.write(&quot;\n&quot;)</span>
<span class="gi">+    stream.write(_get_global_options_documentation(linter))</span>
<span class="gi">+    stream.write(&quot;\n\n&quot;)</span>
<span class="gi">+    stream.write(get_rst_title(&quot;Pylint checkers&#39; options and switches&quot;, &quot;=&quot;))</span>
<span class="gi">+    stream.write(&quot;\n&quot;)</span>
<span class="gi">+    stream.write(_get_checkers_documentation(linter, show_options))</span>
<span class="gi">+    stream.write(&quot;\n&quot;)</span>
<span class="gh">diff --git a/pylint/utils/file_state.py b/pylint/utils/file_state.py</span>
<span class="gh">index 91b309b26..4bfa2cb0f 100644</span>
<span class="gd">--- a/pylint/utils/file_state.py</span>
<span class="gi">+++ b/pylint/utils/file_state.py</span>
<span class="gu">@@ -39,22 +39,49 @@ class FileState:</span>
<span class="w"> </span>        &quot;&quot;&quot;Recursively walk (depth first) AST to collect block level options
<span class="w"> </span>        line numbers and set the state correctly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        first_child = None</span>
<span class="gi">+        if isinstance(node, nodes.Module):</span>
<span class="gi">+            first_child = node.body[0] if node.body else None</span>
<span class="gi">+        elif isinstance(node, nodes.FunctionDef):</span>
<span class="gi">+            first_child = node.body[0] if node.body else None</span>
<span class="gi">+        elif isinstance(node, nodes.ClassDef):</span>
<span class="gi">+            first_child = node.body[0] if node.body else None</span>
<span class="gi">+</span>
<span class="gi">+        if first_child:</span>
<span class="gi">+            self._set_message_state_in_block(msg, msg_state, node, first_child.lineno)</span>
<span class="gi">+</span>
<span class="gi">+        for child in node.get_children():</span>
<span class="gi">+            self._set_state_on_block_lines(msgs_store, child, msg, msg_state)</span>

<span class="w"> </span>    def _set_message_state_in_block(self, msg: MessageDefinition, lines:
<span class="w"> </span>        dict[int, bool], node: nodes.NodeNG, firstchildlineno: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set the state of a message in a block of lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        start = node.fromlineno</span>
<span class="gi">+        end = node.tolineno</span>
<span class="gi">+        for line in range(start, firstchildlineno):</span>
<span class="gi">+            self._set_message_state_on_line(msg, line, lines.get(start, True), start)</span>
<span class="gi">+        for line in range(firstchildlineno, end + 1):</span>
<span class="gi">+            self._set_message_state_on_line(msg, line, lines.get(line, True), line)</span>

<span class="w"> </span>    def _set_message_state_on_line(self, msg: MessageDefinition, line: int,
<span class="w"> </span>        state: bool, original_lineno: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set the state of a message on a line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        msg_id = msg.msgid</span>
<span class="gi">+        if msg_id not in self._module_msgs_state:</span>
<span class="gi">+            self._module_msgs_state[msg_id] = {}</span>
<span class="gi">+        self._module_msgs_state[msg_id][line] = state</span>
<span class="gi">+        self._raw_module_msgs_state[msg_id][original_lineno] = state</span>

<span class="w"> </span>    def set_msg_status(self, msg: MessageDefinition, line: int, status:
<span class="w"> </span>        bool, scope: str=&#39;package&#39;) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Set status (enabled/disable) for a given message at a given line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert line &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+        if scope != &#39;package&#39;:</span>
<span class="gi">+            self._set_message_state_on_line(msg, line, status, line)</span>
<span class="gi">+</span>
<span class="gi">+        if self._module and not self._is_base_filestate:</span>
<span class="gi">+            self._set_state_on_block_lines(self._msgs_store, self._module, msg, {line: status})</span>

<span class="w"> </span>    def handle_ignored_message(self, state_scope: (Literal[0, 1, 2] | None),
<span class="w"> </span>        msgid: str, line: (int | None)) -&gt;None:
<span class="gu">@@ -64,4 +91,12 @@ class FileState:</span>
<span class="w"> </span>        depending on whether the message was disabled locally in the module,
<span class="w"> </span>        or globally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if state_scope == MSG_STATE_SCOPE_MODULE:</span>
<span class="gi">+            if line in self._suppression_mapping:</span>
<span class="gi">+                self._suppression_mapping[(msgid, line)] = self._suppression_mapping.pop(line)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._suppression_mapping[(msgid, line)] = line</span>
<span class="gi">+</span>
<span class="gi">+        if line is None:</span>
<span class="gi">+            line = 0</span>
<span class="gi">+        self._ignored_msgs[(msgid, line)].add(state_scope)</span>
<span class="gh">diff --git a/pylint/utils/linterstats.py b/pylint/utils/linterstats.py</span>
<span class="gh">index 3950c7b35..c87f2a5c9 100644</span>
<span class="gd">--- a/pylint/utils/linterstats.py</span>
<span class="gi">+++ b/pylint/utils/linterstats.py</span>
<span class="gu">@@ -122,81 +122,131 @@ class LinterStats:</span>
<span class="w"> </span>        &quot;&quot;&quot;Use through PyLinter.set_current_module so PyLinter.current_name is
<span class="w"> </span>        consistent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.by_module[module_name] = ModuleStats(convention=0, error=0, fatal=0, info=0, refactor=0, statement=0, warning=0)</span>

<span class="w"> </span>    def get_bad_names(self, node_name: Literal[&#39;argument&#39;, &#39;attr&#39;, &#39;class&#39;,
<span class="w"> </span>        &#39;class_attribute&#39;, &#39;class_const&#39;, &#39;const&#39;, &#39;inlinevar&#39;, &#39;function&#39;,
<span class="w"> </span>        &#39;method&#39;, &#39;module&#39;, &#39;variable&#39;, &#39;typevar&#39;, &#39;typealias&#39;]) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Get a bad names node count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.bad_names[node_name]</span>

<span class="w"> </span>    def increase_bad_name(self, node_name: str, increase: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increase a bad names node count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.bad_names[node_name] += increase</span>

<span class="w"> </span>    def reset_bad_names(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resets the bad_names attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.bad_names = BadNames(argument=0, attr=0, klass=0, class_attribute=0, class_const=0, const=0, inlinevar=0,</span>
<span class="gi">+                                  function=0, method=0, module=0, variable=0, typevar=0, typealias=0)</span>

<span class="w"> </span>    def get_code_count(self, type_name: Literal[&#39;code&#39;, &#39;comment&#39;,
<span class="w"> </span>        &#39;docstring&#39;, &#39;empty&#39;, &#39;total&#39;]) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Get a code type count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.code_type_count[type_name]</span>

<span class="w"> </span>    def reset_code_count(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resets the code_type_count attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.code_type_count = CodeTypeCount(code=0, comment=0, docstring=0, empty=0, total=0)</span>

<span class="w"> </span>    def reset_duplicated_lines(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resets the duplicated_lines attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.duplicated_lines = DuplicatedLines(nb_duplicated_lines=0, percent_duplicated_lines=0.0)</span>

<span class="w"> </span>    def get_node_count(self, node_name: Literal[&#39;function&#39;, &#39;class&#39;,
<span class="w"> </span>        &#39;method&#39;, &#39;module&#39;]) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Get a node count while handling some extra conditions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.node_count[node_name]</span>

<span class="w"> </span>    def reset_node_count(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resets the node count attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.node_count = NodeCount(function=0, klass=0, method=0, module=0)</span>

<span class="w"> </span>    def get_undocumented(self, node_name: Literal[&#39;function&#39;, &#39;class&#39;,
<span class="w"> </span>        &#39;method&#39;, &#39;module&#39;]) -&gt;float:
<span class="w"> </span>        &quot;&quot;&quot;Get a undocumented node count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.undocumented[node_name]</span>

<span class="w"> </span>    def reset_undocumented(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resets the undocumented attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.undocumented = UndocumentedNodes(function=0, klass=0, method=0, module=0)</span>

<span class="w"> </span>    def get_global_message_count(self, type_name: str) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Get a global message count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return getattr(self, type_name)</span>

<span class="w"> </span>    def get_module_message_count(self, modname: str, type_name:
<span class="w"> </span>        MessageTypesFullName) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Get a module message count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.by_module.get(modname, {}).get(type_name, 0)</span>

<span class="w"> </span>    def increase_single_message_count(self, type_name: str, increase: int
<span class="w"> </span>        ) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increase the message type count of an individual message type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        setattr(self, type_name, getattr(self, type_name) + increase)</span>

<span class="w"> </span>    def increase_single_module_message_count(self, modname: str, type_name:
<span class="w"> </span>        MessageTypesFullName, increase: int) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Increase the message type count of an individual message type of a
<span class="w"> </span>        module.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if modname not in self.by_module:</span>
<span class="gi">+            self.init_single_module(modname)</span>
<span class="gi">+        self.by_module[modname][type_name] += increase</span>

<span class="w"> </span>    def reset_message_count(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Resets the message type count of the stats object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.convention = 0</span>
<span class="gi">+        self.error = 0</span>
<span class="gi">+        self.fatal = 0</span>
<span class="gi">+        self.info = 0</span>
<span class="gi">+        self.refactor = 0</span>
<span class="gi">+        self.warning = 0</span>
<span class="gi">+        self.by_module.clear()</span>


<span class="w"> </span>def merge_stats(stats: list[LinterStats]) -&gt;LinterStats:
<span class="w"> </span>    &quot;&quot;&quot;Used to merge multiple stats objects into a new one when pylint is run in
<span class="w"> </span>    parallel mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    merged = LinterStats()</span>
<span class="gi">+    for stat in stats:</span>
<span class="gi">+        for attr, value in stat.bad_names.items():</span>
<span class="gi">+            merged.bad_names[attr] += value</span>
<span class="gi">+        for modname, mod_stats in stat.by_module.items():</span>
<span class="gi">+            if modname not in merged.by_module:</span>
<span class="gi">+                merged.by_module[modname] = ModuleStats(**mod_stats)</span>
<span class="gi">+            else:</span>
<span class="gi">+                for key, value in mod_stats.items():</span>
<span class="gi">+                    merged.by_module[modname][key] += value</span>
<span class="gi">+        for msg, count in stat.by_msg.items():</span>
<span class="gi">+            merged.by_msg[msg] = merged.by_msg.get(msg, 0) + count</span>
<span class="gi">+        for key, value in stat.code_type_count.items():</span>
<span class="gi">+            merged.code_type_count[key] += value</span>
<span class="gi">+        for dep, deps in stat.dependencies.items():</span>
<span class="gi">+            if dep not in merged.dependencies:</span>
<span class="gi">+                merged.dependencies[dep] = deps.copy()</span>
<span class="gi">+            else:</span>
<span class="gi">+                merged.dependencies[dep].update(deps)</span>
<span class="gi">+        merged.duplicated_lines[&#39;nb_duplicated_lines&#39;] += stat.duplicated_lines[&#39;nb_duplicated_lines&#39;]</span>
<span class="gi">+        merged.duplicated_lines[&#39;percent_duplicated_lines&#39;] += stat.duplicated_lines[&#39;percent_duplicated_lines&#39;]</span>
<span class="gi">+        for key, value in stat.node_count.items():</span>
<span class="gi">+            merged.node_count[key] += value</span>
<span class="gi">+        for key, value in stat.undocumented.items():</span>
<span class="gi">+            merged.undocumented[key] += value</span>
<span class="gi">+        merged.convention += stat.convention</span>
<span class="gi">+        merged.error += stat.error</span>
<span class="gi">+        merged.fatal += stat.fatal</span>
<span class="gi">+        merged.info += stat.info</span>
<span class="gi">+        merged.refactor += stat.refactor</span>
<span class="gi">+        merged.statement += stat.statement</span>
<span class="gi">+        merged.warning += stat.warning</span>
<span class="gi">+        merged.global_note += stat.global_note</span>
<span class="gi">+        merged.nb_duplicated_lines += stat.nb_duplicated_lines</span>
<span class="gi">+        merged.percent_duplicated_lines += stat.percent_duplicated_lines</span>
<span class="gi">+    </span>
<span class="gi">+    # Calculate average for percent_duplicated_lines</span>
<span class="gi">+    if stats:</span>
<span class="gi">+        merged.percent_duplicated_lines /= len(stats)</span>
<span class="gi">+        merged.duplicated_lines[&#39;percent_duplicated_lines&#39;] /= len(stats)</span>
<span class="gi">+    </span>
<span class="gi">+    return merged</span>
<span class="gh">diff --git a/pylint/utils/utils.py b/pylint/utils/utils.py</span>
<span class="gh">index 12fbd9948..f20171c1a 100644</span>
<span class="gd">--- a/pylint/utils/utils.py</span>
<span class="gi">+++ b/pylint/utils/utils.py</span>
<span class="gu">@@ -43,7 +43,8 @@ T_GlobalOptionReturnTypes = TypeVar(&#39;T_GlobalOptionReturnTypes&#39;, bool, int,</span>
<span class="w"> </span>def normalize_text(text: str, line_len: int=DEFAULT_LINE_LENGTH, indent: str=&#39;&#39;
<span class="w"> </span>    ) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Wrap the text on the given line length.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = textwrap.wrap(text, width=line_len)</span>
<span class="gi">+    return &#39;\n&#39;.join(indent + line for line in lines)</span>


<span class="w"> </span>CMPS = [&#39;=&#39;, &#39;-&#39;, &#39;+&#39;]
<span class="gu">@@ -51,32 +52,68 @@ CMPS = [&#39;=&#39;, &#39;-&#39;, &#39;+&#39;]</span>

<span class="w"> </span>def diff_string(old: float, new: float) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Given an old and new value, return a string representing the difference.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    diff = new - old</span>
<span class="gi">+    if diff == 0:</span>
<span class="gi">+        return &#39;=&#39;</span>
<span class="gi">+    sign = &#39;+&#39; if diff &gt; 0 else &#39;-&#39;</span>
<span class="gi">+    return f&quot;{sign}{abs(diff):.2f}&quot;</span>


<span class="w"> </span>def get_module_and_frameid(node: nodes.NodeNG) -&gt;tuple[str, str]:
<span class="w"> </span>    &quot;&quot;&quot;Return the module name and the frame id in the module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    frame = node.frame()</span>
<span class="gi">+    module = node.root()</span>
<span class="gi">+    name = module.name</span>
<span class="gi">+    if isinstance(frame, Module):</span>
<span class="gi">+        return name, &#39;0&#39;</span>
<span class="gi">+    return name, f&quot;{frame.lineno}.{frame.col_offset}&quot;</span>


<span class="w"> </span>def get_rst_title(title: str, character: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Permit to get a title formatted as ReStructuredText test (underlined with a
<span class="w"> </span>    chosen character).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return f&quot;{title}\n{character * len(title)}&quot;</span>


<span class="w"> </span>def get_rst_section(section: (str | None), options: list[tuple[str,
<span class="w"> </span>    OptionDict, Any]], doc: (str | None)=None) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Format an option&#39;s section using as a ReStructuredText formatted output.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    if section:</span>
<span class="gi">+        result.append(get_rst_title(section, &quot;=&quot;))</span>
<span class="gi">+    if doc:</span>
<span class="gi">+        result.append(normalize_text(doc))</span>
<span class="gi">+    result.append(&quot;\n&quot;)</span>
<span class="gi">+    for optname, optdict, value in options:</span>
<span class="gi">+        help_text = optdict.get(&quot;help&quot;)</span>
<span class="gi">+        result.append(f&quot;:{optname}:&quot;)</span>
<span class="gi">+        if help_text:</span>
<span class="gi">+            result.append(normalize_text(help_text, indent=&quot;  &quot;))</span>
<span class="gi">+        if value:</span>
<span class="gi">+            result.append(f&quot;  Default: ``{value}``&quot;)</span>
<span class="gi">+        result.append(&quot;&quot;)</span>
<span class="gi">+    return &quot;\n&quot;.join(result)</span>


<span class="w"> </span>def register_plugins(linter: PyLinter, directory: str) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Load all module and package in the given directory, looking for a
<span class="w"> </span>    &#39;register&#39; function in each one, used to register pylint checkers.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    imported_modules = []</span>
<span class="gi">+    for filename in os.listdir(directory):</span>
<span class="gi">+        name, ext = os.path.splitext(filename)</span>
<span class="gi">+        if ext in PY_EXTS and name != &#39;__init__&#39;:</span>
<span class="gi">+            module_path = os.path.join(directory, filename)</span>
<span class="gi">+            spec = modutils.file_from_modpath([module_path])</span>
<span class="gi">+            if spec is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            module = modutils.load_module_from_file(spec.loader.get_filename())</span>
<span class="gi">+            imported_modules.append(module)</span>
<span class="gi">+    </span>
<span class="gi">+    for module in imported_modules:</span>
<span class="gi">+        if hasattr(module, &#39;register&#39;):</span>
<span class="gi">+            module.register(linter)</span>


<span class="w"> </span>def _splitstrip(string: str, sep: str=&#39;,&#39;) -&gt;list[str]:
<span class="gu">@@ -99,7 +136,7 @@ def _splitstrip(string: str, sep: str=&#39;,&#39;) -&gt;list[str]:</span>
<span class="w"> </span>    :rtype: str or unicode
<span class="w"> </span>    :return: the unquoted string (or the input string if it wasn&#39;t quoted)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [s.strip() for s in string.split(sep) if s.strip()]</span>


<span class="w"> </span>def _unquote(string: str) -&gt;str:
<span class="gu">@@ -108,14 +145,18 @@ def _unquote(string: str) -&gt;str:</span>
<span class="w"> </span>    :param string: an optionally quoted string
<span class="w"> </span>    :return: the unquoted string (or the input string if it wasn&#39;t quoted)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(string) &gt; 2 and string[0] == string[-1] and string[0] in &#39;&quot;\&#39;&#39;:</span>
<span class="gi">+        return string[1:-1]</span>
<span class="gi">+    return string</span>


<span class="w"> </span>def _check_regexp_csv(value: (list[str] | tuple[str] | str)) -&gt;Iterable[str]:
<span class="w"> </span>    &quot;&quot;&quot;Split a comma-separated list of regexps, taking care to avoid splitting
<span class="w"> </span>    a regex employing a comma as quantifier, as in `\\d{1,2}`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        value = _splitstrip(value)</span>
<span class="gi">+    return [_unquote(v) for v in value]</span>


<span class="w"> </span>def _comment(string: str) -&gt;str:
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>