
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin web3.py - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-web3py" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin web3.py
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-web3py"><strong>Claude Sonnet 3.5 - Fill-in</strong>: web3.py</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>Traceback (most recent call last):
  File &quot;/testbed/.venv/bin/pytest&quot;, line 8, in &lt;module&gt;
    sys.exit(console_main())
             ^^^^^^^^^^^^^^
  File &quot;/testbed/.venv/lib/python3.12/site-packages/_pytest/config/__init__.py&quot;, line 201, in console_main
    code = main()
           ^^^^^^
  File &quot;/testbed/.venv/lib/python3.12/site-packages/_pytest/config/__init__.py&quot;, line 156, in main
    config = _prepareconfig(args, plugins)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/testbed/.venv/lib/python3.12/site-packages/_pytest/config/__init__.py&quot;, line 341, in _prepareconfig
    config = pluginmanager.hook.pytest_cmdline_parse(
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/testbed/.venv/lib/python3.12/site-packages/pluggy/_hooks.py&quot;, line 513, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/testbed/.venv/lib/python3.12/site-packages/pluggy/_manager.py&quot;, line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/testbed/.venv/lib/python3.12/site-packages/pluggy/_callers.py&quot;, line 139, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File &quot;/testbed/.venv/lib/python3.12/site-packages/pluggy/_callers.py&quot;, line 122, in _multicall
    teardown.throw(exception)  # type: ignore[union-attr]
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/testbed/.venv/lib/python3.12/site-packages/_pytest/helpconfig.py&quot;, line 105, in pytest_cmdline_parse
    config = yield
             ^^^^^
  File &quot;/testbed/.venv/lib/python3.12/site-packages/pluggy/_callers.py&quot;, line 103, in _multicall
    res = hook_impl.function(*args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/testbed/.venv/lib/python3.12/site-packages/_pytest/config/__init__.py&quot;, line 1140, in pytest_cmdline_parse
    self.parse(args)
  File &quot;/testbed/.venv/lib/python3.12/site-packages/_pytest/config/__init__.py&quot;, line 1494, in parse
    self._preparse(args, addopts=addopts)
  File &quot;/testbed/.venv/lib/python3.12/site-packages/_pytest/config/__init__.py&quot;, line 1381, in _preparse
    self.pluginmanager.load_setuptools_entrypoints(&quot;pytest11&quot;)
  File &quot;/testbed/.venv/lib/python3.12/site-packages/pluggy/_manager.py&quot;, line 421, in load_setuptools_entrypoints
    plugin = ep.load()
             ^^^^^^^^^
  File &quot;/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/importlib/metadata/__init__.py&quot;, line 205, in load
    module = import_module(match.group(&#39;module&#39;))
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/importlib/__init__.py&quot;, line 90, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1387, in _gcd_import
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1360, in _find_and_load
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1310, in _find_and_load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 488, in _call_with_frames_removed
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1387, in _gcd_import
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1360, in _find_and_load
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1310, in _find_and_load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 488, in _call_with_frames_removed
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1387, in _gcd_import
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1360, in _find_and_load
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1310, in _find_and_load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 488, in _call_with_frames_removed
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1387, in _gcd_import
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1360, in _find_and_load
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1331, in _find_and_load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 935, in _load_unlocked
  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 995, in exec_module
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 488, in _call_with_frames_removed
  File &quot;/testbed/web3/__init__.py&quot;, line 4, in &lt;module&gt;
    from web3.providers import (
  File &quot;/testbed/web3/providers/__init__.py&quot;, line 1, in &lt;module&gt;
    from .async_base import (
  File &quot;/testbed/web3/providers/async_base.py&quot;, line 4, in &lt;module&gt;
    from web3._utils.encoding import FriendlyJsonSerde, Web3JsonEncoder
  File &quot;/testbed/web3/_utils/encoding.py&quot;, line 9, in &lt;module&gt;
    from web3._utils.abi import is_address_type, is_array_type, is_bool_type, is_bytes_type, is_int_type, is_string_type, is_uint_type, size_of_type, sub_type_of_array_type
  File &quot;/testbed/web3/_utils/abi.py&quot;, line 17, in &lt;module&gt;
    from web3._utils.ens import is_ens_name
ImportError: cannot import name &#39;is_ens_name&#39; from &#39;web3._utils.ens&#39; (/testbed/web3/_utils/ens.py)
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/web3/_utils/abi.py b/web3/_utils/abi.py</span>
<span class="gh">index 4fca64f0..47eb8332 100644</span>
<span class="gd">--- a/web3/_utils/abi.py</span>
<span class="gi">+++ b/web3/_utils/abi.py</span>
<span class="gu">@@ -30,7 +30,7 @@ def get_normalized_abi_arg_type(abi_arg: ABIEventParams) -&gt;str:</span>
<span class="w"> </span>    makes use of `collapse_if_tuple()` to collapse the appropriate component
<span class="w"> </span>    types within a tuple type, if present.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return collapse_if_tuple(dict(abi_arg)[&quot;type&quot;])</span>


<span class="w"> </span>class AddressEncoder(encoding.AddressEncoder):
<span class="gu">@@ -84,7 +84,34 @@ def merge_args_and_kwargs(function_abi: ABIFunction, args: Sequence[Any],</span>
<span class="w"> </span>    given.  Returns a list of argument values aligned to the order of inputs
<span class="w"> </span>    defined in ``function_abi``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(args) + len(kwargs) &gt; len(function_abi.get(&#39;inputs&#39;, [])):</span>
<span class="gi">+        raise TypeError(</span>
<span class="gi">+            &quot;Too many arguments: got {0} args and {1} kwargs, expected {2}&quot;.format(</span>
<span class="gi">+                len(args), len(kwargs), len(function_abi.get(&#39;inputs&#39;, []))</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    args_as_kwargs = {}</span>
<span class="gi">+    for arg_name, arg_value in zip(get_abi_input_names(function_abi), args):</span>
<span class="gi">+        args_as_kwargs[arg_name] = arg_value</span>
<span class="gi">+</span>
<span class="gi">+    for key, value in kwargs.items():</span>
<span class="gi">+        if key in args_as_kwargs:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Duplicate argument name found: {0}&quot;.format(key)</span>
<span class="gi">+            )</span>
<span class="gi">+        args_as_kwargs[key] = value</span>
<span class="gi">+</span>
<span class="gi">+    unknown_kwargs = set(args_as_kwargs.keys()) - set(get_abi_input_names(function_abi))</span>
<span class="gi">+    if unknown_kwargs:</span>
<span class="gi">+        raise TypeError(</span>
<span class="gi">+            &quot;Unknown arguments found: {0}&quot;.format(&quot;, &quot;.join(unknown_kwargs))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return tuple(</span>
<span class="gi">+        args_as_kwargs.get(arg_abi[&#39;name&#39;])</span>
<span class="gi">+        for arg_abi in function_abi.get(&#39;inputs&#39;, [])</span>
<span class="gi">+    )</span>


<span class="w"> </span>TUPLE_TYPE_STR_RE = re.compile(&#39;^(tuple)((\\[([1-9]\\d*\\b)?])*)??$&#39;)
<span class="gu">@@ -95,7 +122,12 @@ def get_tuple_type_str_parts(s: str) -&gt;Optional[Tuple[str, Optional[str]]]:</span>
<span class="w"> </span>    Takes a JSON ABI type string.  For tuple type strings, returns the separated
<span class="w"> </span>    prefix and array dimension parts.  For all other strings, returns ``None``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = TUPLE_TYPE_STR_RE.match(s)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        tuple_prefix = match.group(1)</span>
<span class="gi">+        tuple_dims = match.group(2) or None</span>
<span class="gi">+        return tuple_prefix, tuple_dims</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def _align_abi_input(arg_abi: ABIFunctionParams, arg: Any) -&gt;Tuple[Any, ...]:
<span class="gu">@@ -103,7 +135,19 @@ def _align_abi_input(arg_abi: ABIFunctionParams, arg: Any) -&gt;Tuple[Any, ...]:</span>
<span class="w"> </span>    Aligns the values of any mapping at any level of nesting in ``arg``
<span class="w"> </span>    according to the layout of the corresponding abi spec.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(arg, abc.Mapping):</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            _align_abi_input(component_abi, arg.get(component_abi[&#39;name&#39;], None))</span>
<span class="gi">+            for component_abi in arg_abi[&#39;components&#39;]</span>
<span class="gi">+        )</span>
<span class="gi">+    elif isinstance(arg, abc.Iterable) and not isinstance(arg, str):</span>
<span class="gi">+        return tuple(</span>
<span class="gi">+            _align_abi_input(component_abi, component)</span>
<span class="gi">+            for component_abi, component</span>
<span class="gi">+            in zip(arg_abi[&#39;components&#39;], arg)</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        return arg,</span>


<span class="w"> </span>def get_aligned_abi_inputs(abi: ABIFunction, args: Union[Tuple[Any, ...],
<span class="gu">@@ -115,7 +159,24 @@ def get_aligned_abi_inputs(abi: ABIFunction, args: Union[Tuple[Any, ...],</span>
<span class="w"> </span>    contained in ``args`` may contain nested mappings or sequences corresponding
<span class="w"> </span>    to tuple-encoded values in ``abi``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(args, abc.Mapping):</span>
<span class="gi">+        kwargs = args</span>
<span class="gi">+    elif isinstance(args, abc.Sequence):</span>
<span class="gi">+        kwargs = merge_args_and_kwargs(abi, args, {})</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Expected mapping or sequence, got {}&quot;.format(type(args)))</span>
<span class="gi">+</span>
<span class="gi">+    aligned_inputs = tuple(</span>
<span class="gi">+        _align_abi_input(arg_abi, kwargs.get(arg_abi[&#39;name&#39;]))</span>
<span class="gi">+        for arg_abi in abi.get(&#39;inputs&#39;, [])</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    input_types = tuple(</span>
<span class="gi">+        arg_abi[&#39;type&#39;]</span>
<span class="gi">+        for arg_abi in abi.get(&#39;inputs&#39;, [])</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return input_types, aligned_inputs</span>


<span class="w"> </span>DYNAMIC_TYPES = [&#39;bytes&#39;, &#39;string&#39;]
<span class="gu">@@ -137,7 +198,21 @@ def size_of_type(abi_type: TypeStr) -&gt;int:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns size in bits of abi_type
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;string&#39; in abi_type:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if &#39;byte&#39; in abi_type:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if &#39;[&#39; in abi_type:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if abi_type == &#39;bool&#39;:</span>
<span class="gi">+        return 8</span>
<span class="gi">+    if abi_type == &#39;address&#39;:</span>
<span class="gi">+        return 160</span>
<span class="gi">+    if abi_type.startswith(&#39;uint&#39;):</span>
<span class="gi">+        return int(abi_type[4:])</span>
<span class="gi">+    if abi_type.startswith(&#39;int&#39;):</span>
<span class="gi">+        return int(abi_type[3:])</span>
<span class="gi">+    raise ValueError(&quot;Unknown type: {}&quot;.format(abi_type))</span>


<span class="w"> </span>END_BRACKETS_OF_ARRAY_TYPE_REGEX = &#39;\\[[^]]*\\]$&#39;
<span class="gh">diff --git a/web3/_utils/async_transactions.py b/web3/_utils/async_transactions.py</span>
<span class="gh">index 2285b1d0..47481deb 100644</span>
<span class="gd">--- a/web3/_utils/async_transactions.py</span>
<span class="gi">+++ b/web3/_utils/async_transactions.py</span>
<span class="gu">@@ -20,4 +20,33 @@ async def async_fill_transaction_defaults(async_w3: &#39;AsyncWeb3&#39;,</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    if async_w3 is None, fill as much as possible while offline
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    filled_transaction = cast(TxParams, {})</span>
<span class="gi">+    for key, default_getter in TRANSACTION_DEFAULTS.items():</span>
<span class="gi">+        if key not in transaction:</span>
<span class="gi">+            if callable(default_getter):</span>
<span class="gi">+                if async_w3 is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                default_val = (</span>
<span class="gi">+                    await default_getter(async_w3, transaction)</span>
<span class="gi">+                    if key in DYNAMIC_FEE_TXN_PARAMS</span>
<span class="gi">+                    else await default_getter(async_w3, filled_transaction)</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                default_val = default_getter</span>
<span class="gi">+            filled_transaction[key] = default_val</span>
<span class="gi">+    </span>
<span class="gi">+    filled_transaction = merge(filled_transaction, transaction)</span>
<span class="gi">+    </span>
<span class="gi">+    if async_w3 is not None:</span>
<span class="gi">+        if &#39;from&#39; not in filled_transaction:</span>
<span class="gi">+            filled_transaction[&#39;from&#39;] = await async_w3.eth.default_account</span>
<span class="gi">+        </span>
<span class="gi">+        if filled_transaction.get(&#39;nonce&#39;) is None:</span>
<span class="gi">+            filled_transaction[&#39;nonce&#39;] = await async_w3.eth.get_transaction_count(</span>
<span class="gi">+                filled_transaction[&#39;from&#39;]</span>
<span class="gi">+            )</span>
<span class="gi">+        </span>
<span class="gi">+        if &#39;chainId&#39; not in filled_transaction:</span>
<span class="gi">+            filled_transaction[&#39;chainId&#39;] = await async_w3.eth.chain_id</span>
<span class="gi">+    </span>
<span class="gi">+    return filled_transaction</span>
<span class="gh">diff --git a/web3/_utils/caching.py b/web3/_utils/caching.py</span>
<span class="gh">index bd619a5d..e0d704ff 100644</span>
<span class="gd">--- a/web3/_utils/caching.py</span>
<span class="gi">+++ b/web3/_utils/caching.py</span>
<span class="gu">@@ -6,11 +6,26 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from web3.types import RPCEndpoint


<span class="gd">-def generate_cache_key(value: Any) -&gt;str:</span>
<span class="gi">+def generate_cache_key(value: Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Generates a cache key for the *args and **kwargs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_null(value):</span>
<span class="gi">+        return &quot;null&quot;</span>
<span class="gi">+    elif is_boolean(value):</span>
<span class="gi">+        return &quot;bool:%s&quot; % str(value).lower()</span>
<span class="gi">+    elif is_number(value):</span>
<span class="gi">+        return &quot;num:%d&quot; % value</span>
<span class="gi">+    elif is_text(value):</span>
<span class="gi">+        return &quot;text:%s&quot; % value</span>
<span class="gi">+    elif is_bytes(value):</span>
<span class="gi">+        return &quot;bytes:%s&quot; % hashlib.md5(value).hexdigest()</span>
<span class="gi">+    elif is_list_like(value):</span>
<span class="gi">+        return &quot;list:%s&quot; % hashlib.md5(to_bytes(str(value))).hexdigest()</span>
<span class="gi">+    elif is_dict(value):</span>
<span class="gi">+        return &quot;dict:%s&quot; % hashlib.md5(to_bytes(str(sorted(value.items())))).hexdigest()</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &quot;obj:%s&quot; % hashlib.md5(to_bytes(str(value))).hexdigest()</span>


<span class="w"> </span>class RequestInformation:
<span class="gh">diff --git a/web3/_utils/contracts.py b/web3/_utils/contracts.py</span>
<span class="gh">index 264553ef..ef2aa3ec 100644</span>
<span class="gd">--- a/web3/_utils/contracts.py</span>
<span class="gi">+++ b/web3/_utils/contracts.py</span>
<span class="gu">@@ -23,7 +23,23 @@ def extract_argument_types(*args: Sequence[Any]) -&gt;str:</span>
<span class="w"> </span>    Takes a list of arguments and returns a string representation of the argument types,
<span class="w"> </span>    appropriately collapsing `tuple` types into the respective nested types.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def get_type(arg):</span>
<span class="gi">+        if isinstance(arg, tuple):</span>
<span class="gi">+            return f&quot;({&#39;,&#39;.join(get_type(a) for a in arg)})&quot;</span>
<span class="gi">+        elif isinstance(arg, list):</span>
<span class="gi">+            return f&quot;{get_type(arg[0]) if arg else &#39;unknown&#39;}[]&quot;</span>
<span class="gi">+        elif isinstance(arg, int):</span>
<span class="gi">+            return &quot;uint256&quot;  # Assuming uint256 for integers</span>
<span class="gi">+        elif isinstance(arg, bool):</span>
<span class="gi">+            return &quot;bool&quot;</span>
<span class="gi">+        elif isinstance(arg, str):</span>
<span class="gi">+            return &quot;string&quot;</span>
<span class="gi">+        elif isinstance(arg, bytes):</span>
<span class="gi">+            return &quot;bytes&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &quot;unknown&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    return &quot;,&quot;.join(get_type(arg) for arg in args)</span>


<span class="w"> </span>def prepare_transaction(address: ChecksumAddress, w3: Union[&#39;AsyncWeb3&#39;,
<span class="gu">@@ -37,11 +53,56 @@ def prepare_transaction(address: ChecksumAddress, w3: Union[&#39;AsyncWeb3&#39;,</span>
<span class="w"> </span>    TODO: make this a public API
<span class="w"> </span>    TODO: add new prepare_deploy_transaction API
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if transaction is None:</span>
<span class="gi">+        transaction = {}</span>
<span class="gi">+    </span>
<span class="gi">+    if fn_identifier is FallbackFn:</span>
<span class="gi">+        fn_abi = get_fallback_func_abi(contract_abi)</span>
<span class="gi">+    elif fn_identifier is ReceiveFn:</span>
<span class="gi">+        fn_abi = get_receive_func_abi(contract_abi)</span>
<span class="gi">+    elif not is_text(fn_identifier):</span>
<span class="gi">+        raise TypeError(&quot;Unsupported function identifier&quot;)</span>
<span class="gi">+    elif fn_abi is None:</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(contract_abi, fn_identifier, fn_args, fn_kwargs)</span>
<span class="gi">+    </span>
<span class="gi">+    validate_payable(transaction, fn_abi)</span>
<span class="gi">+</span>
<span class="gi">+    if transaction.get(&#39;data&#39;):</span>
<span class="gi">+        raise ValueError(&quot;Transaction parameter may not contain a &#39;data&#39; key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if transaction.get(&#39;to&#39;) and transaction[&#39;to&#39;] != address:</span>
<span class="gi">+        raise ValueError(&quot;Supplied &#39;to&#39; address in transaction does not match the contract address&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;to&#39; not in transaction:</span>
<span class="gi">+        transaction[&#39;to&#39;] = address</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;value&#39; not in transaction:</span>
<span class="gi">+        transaction[&#39;value&#39;] = 0</span>
<span class="gi">+</span>
<span class="gi">+    if fn_identifier is FallbackFn:</span>
<span class="gi">+        transaction[&#39;data&#39;] = &#39;0x&#39;</span>
<span class="gi">+    elif fn_identifier is ReceiveFn:</span>
<span class="gi">+        transaction[&#39;data&#39;] = &#39;0x&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        transaction[&#39;data&#39;] = encode_transaction_data(</span>
<span class="gi">+            w3,</span>
<span class="gi">+            fn_identifier,</span>
<span class="gi">+            contract_abi,</span>
<span class="gi">+            fn_abi,</span>
<span class="gi">+            fn_args,</span>
<span class="gi">+            fn_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return transaction</span>


<span class="w"> </span>def validate_payable(transaction: TxParams, abi: ABIFunction) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Raise Web3ValidationError if non-zero ether
<span class="w"> </span>    is sent to a non-payable function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;value&#39; in transaction:</span>
<span class="gi">+        if transaction[&#39;value&#39;] != 0:</span>
<span class="gi">+            if &quot;payable&quot; not in abi.get(&#39;stateMutability&#39;, &#39;&#39;) and not abi.get(&#39;payable&#39;, False):</span>
<span class="gi">+                raise Web3ValidationError(</span>
<span class="gi">+                    &quot;Sending non-zero ether to a non-payable function&quot;</span>
<span class="gi">+                )</span>
<span class="gh">diff --git a/web3/_utils/decorators.py b/web3/_utils/decorators.py</span>
<span class="gh">index 3a2d3a9a..ac21d200 100644</span>
<span class="gd">--- a/web3/_utils/decorators.py</span>
<span class="gi">+++ b/web3/_utils/decorators.py</span>
<span class="gu">@@ -9,7 +9,27 @@ def reject_recursive_repeats(to_wrap: Callable[..., Any]) -&gt;Callable[..., Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Prevent simple cycles by returning None when called recursively with same instance
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    thread_local = threading.local()</span>
<span class="gi">+</span>
<span class="gi">+    @functools.wraps(to_wrap)</span>
<span class="gi">+    def wrapped(*args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+        arg_instances = tuple(map(id, args))</span>
<span class="gi">+        kwarg_instances = tuple(map(id, kwargs.values()))</span>
<span class="gi">+        key = (to_wrap, arg_instances, kwarg_instances)</span>
<span class="gi">+        </span>
<span class="gi">+        if hasattr(thread_local, &#39;reject_recursive_repeats_func_args&#39;):</span>
<span class="gi">+            if key in thread_local.reject_recursive_repeats_func_args:</span>
<span class="gi">+                return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            thread_local.reject_recursive_repeats_func_args = set()</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            thread_local.reject_recursive_repeats_func_args.add(key)</span>
<span class="gi">+            return to_wrap(*args, **kwargs)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            thread_local.reject_recursive_repeats_func_args.remove(key)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapped</span>


<span class="w"> </span>def deprecate_method(replacement_method: str=None, deprecation_msg: str=None
<span class="gu">@@ -28,4 +48,27 @@ def deprecate_method(replacement_method: str=None, deprecation_msg: str=None</span>
<span class="w"> </span>    def some_method(arg):
<span class="w"> </span>        ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func: TFunc) -&gt; TFunc:</span>
<span class="gi">+        @functools.wraps(func)</span>
<span class="gi">+        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+            if replacement_method:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&quot;{func.__name__} is deprecated. Use {replacement_method} instead.&quot;,</span>
<span class="gi">+                    DeprecationWarning,</span>
<span class="gi">+                    stacklevel=2</span>
<span class="gi">+                )</span>
<span class="gi">+            elif deprecation_msg:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&quot;{func.__name__} is deprecated. {deprecation_msg}&quot;,</span>
<span class="gi">+                    DeprecationWarning,</span>
<span class="gi">+                    stacklevel=2</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&quot;{func.__name__} is deprecated.&quot;,</span>
<span class="gi">+                    DeprecationWarning,</span>
<span class="gi">+                    stacklevel=2</span>
<span class="gi">+                )</span>
<span class="gi">+            return func(*args, **kwargs)</span>
<span class="gi">+        return cast(TFunc, wrapper)</span>
<span class="gi">+    return decorator</span>
<span class="gh">diff --git a/web3/_utils/encoding.py b/web3/_utils/encoding.py</span>
<span class="gh">index 0797d189..95c8cccd 100644</span>
<span class="gd">--- a/web3/_utils/encoding.py</span>
<span class="gi">+++ b/web3/_utils/encoding.py</span>
<span class="gu">@@ -16,28 +16,62 @@ def hex_encode_abi_type(abi_type: TypeStr, value: Any, force_size: Optional</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Encodes value into a hex string in format of abi_type
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    validate_abi_type(abi_type)</span>
<span class="gi">+    validate_abi_value(abi_type, value)</span>
<span class="gi">+</span>
<span class="gi">+    if is_address_type(abi_type):</span>
<span class="gi">+        return to_hex(value)</span>
<span class="gi">+    elif is_bool_type(abi_type):</span>
<span class="gi">+        return to_hex_with_size(value, 8)</span>
<span class="gi">+    elif is_uint_type(abi_type):</span>
<span class="gi">+        return to_hex_with_size(value, size_of_type(abi_type))</span>
<span class="gi">+    elif is_int_type(abi_type):</span>
<span class="gi">+        return to_hex_twos_compliment(value, size_of_type(abi_type))</span>
<span class="gi">+    elif is_bytes_type(abi_type):</span>
<span class="gi">+        if force_size is not None:</span>
<span class="gi">+            return pad_hex(to_hex(value), force_size)</span>
<span class="gi">+        else:</span>
<span class="gi">+            size = size_of_type(abi_type)</span>
<span class="gi">+            return pad_hex(to_hex(value), size)</span>
<span class="gi">+    elif is_string_type(abi_type):</span>
<span class="gi">+        return to_hex(text_if_str(to_bytes, value))</span>
<span class="gi">+    elif is_array_type(abi_type):</span>
<span class="gi">+        sub_type = sub_type_of_array_type(abi_type)</span>
<span class="gi">+        return &quot;&quot;.join([remove_0x_prefix(hex_encode_abi_type(sub_type, v)) for v in value])</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported ABI type: {abi_type}&quot;)</span>


<span class="w"> </span>def to_hex_twos_compliment(value: Any, bit_size: int) -&gt;HexStr:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Converts integer value to twos compliment hex representation with given bit_size
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value &gt;= 0:</span>
<span class="gi">+        return to_hex_with_size(value, bit_size)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return to_hex(value &amp; ((1 &lt;&lt; bit_size) - 1))</span>


<span class="w"> </span>def to_hex_with_size(value: Any, bit_size: int) -&gt;HexStr:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Converts a value to hex with given bit_size:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        value = int(value, 16)</span>
<span class="gi">+    if isinstance(value, int):</span>
<span class="gi">+        hex_value = hex(value)[2:]  # remove &#39;0x&#39; prefix</span>
<span class="gi">+        return pad_hex(hex_value, bit_size)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Cannot convert {value} to hex with size {bit_size}&quot;)</span>


<span class="w"> </span>def pad_hex(value: Any, bit_size: int) -&gt;HexStr:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Pads a hex string up to the given bit_size
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value = remove_0x_prefix(value)</span>
<span class="gi">+    padded = value.zfill(bit_size // 4)</span>
<span class="gi">+    return add_0x_prefix(padded)</span>


<span class="w"> </span>zpad_bytes = pad_bytes(b&#39;\x00&#39;)
<span class="gu">@@ -53,7 +87,10 @@ def text_if_str(to_type: Callable[..., str], text_or_primitive: Union[</span>
<span class="w"> </span>        text=text), eg~ to_bytes, to_text, to_hex, to_int, etc
<span class="w"> </span>    @param text_or_primitive in bytes, str, or int.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(text_or_primitive, str):</span>
<span class="gi">+        return to_type(text=text_or_primitive)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return to_type(text_or_primitive)</span>


<span class="w"> </span>@curry
<span class="gu">@@ -66,7 +103,10 @@ def hexstr_if_str(to_type: Callable[..., HexStr], hexstr_or_primitive:</span>
<span class="w"> </span>        text=text), eg~ to_bytes, to_text, to_hex, to_int, etc
<span class="w"> </span>    @param hexstr_or_primitive in bytes, str, or int.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(hexstr_or_primitive, str):</span>
<span class="gi">+        return to_type(hexstr=hexstr_or_primitive)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return to_type(hexstr_or_primitive)</span>


<span class="w"> </span>class FriendlyJsonSerde:
<span class="gu">@@ -91,4 +131,4 @@ def to_json(obj: Dict[Any, Any]) -&gt;str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Convert a complex object (like a transaction object) to a JSON string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return json.dumps(obj, cls=Web3JsonEncoder)</span>
<span class="gh">diff --git a/web3/_utils/ens.py b/web3/_utils/ens.py</span>
<span class="gh">index 1bddc8b2..c7c23b7d 100644</span>
<span class="gd">--- a/web3/_utils/ens.py</span>
<span class="gi">+++ b/web3/_utils/ens.py</span>
<span class="gu">@@ -25,4 +25,9 @@ def contract_ens_addresses(contract: &#39;Contract&#39;, name_addr_pairs: Dict[str,</span>
<span class="w"> </span>    with contract_ens_addresses(mycontract, [(&#39;resolve-as-1s.eth&#39;, &#39;0x111...111&#39;)]):
<span class="w"> </span>        # any contract call or transaction in here would only resolve the above ENS pair
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    original_ens = contract.w3.ens</span>
<span class="gi">+    try:</span>
<span class="gi">+        contract.w3.ens = StaticENS(name_addr_pairs)</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        contract.w3.ens = original_ens</span>
<span class="gh">diff --git a/web3/_utils/error_formatters_utils.py b/web3/_utils/error_formatters_utils.py</span>
<span class="gh">index f81e35c0..e3de343c 100644</span>
<span class="gd">--- a/web3/_utils/error_formatters_utils.py</span>
<span class="gi">+++ b/web3/_utils/error_formatters_utils.py</span>
<span class="gu">@@ -24,15 +24,28 @@ PANIC_ERROR_CODES = {&#39;00&#39;:</span>
<span class="w"> </span>MISSING_DATA = &#39;no data&#39;


<span class="gd">-def _parse_error_with_reverted_prefix(data: str) -&gt;str:</span>
<span class="gi">+def _parse_error_with_reverted_prefix(data: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse errors from the data string which begin with the &quot;Reverted&quot; prefix.
<span class="w"> </span>    &quot;Reverted&quot;, function selector and offset are always the same for revert errors
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data.startswith(&#39;Reverted &#39;):</span>
<span class="gi">+        data = data[9:]  # Remove &quot;Reverted &quot; prefix</span>
<span class="gi">+    if data.startswith(&#39;0x&#39;):</span>
<span class="gi">+        data = data[2:]  # Remove &quot;0x&quot; prefix if present</span>
<span class="gi">+    if len(data) &lt; 8 + 64 + 64:  # Minimum length for a valid revert error</span>
<span class="gi">+        return MISSING_DATA</span>
<span class="gi">+    # Skip function selector (4 bytes) and offset (32 bytes)</span>
<span class="gi">+    error_data = data[8 + 64:]</span>
<span class="gi">+    # Decode the error message</span>
<span class="gi">+    try:</span>
<span class="gi">+        error_message = abi.decode([&#39;string&#39;], to_bytes(hexstr=error_data))[0]</span>
<span class="gi">+        return error_message</span>
<span class="gi">+    except:</span>
<span class="gi">+        return MISSING_DATA</span>


<span class="gd">-def _raise_contract_error(response_error_data: str) -&gt;None:</span>
<span class="gi">+def _raise_contract_error(response_error_data: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Decode response error from data string and raise appropriate exception.

<span class="gu">@@ -42,10 +55,29 @@ def _raise_contract_error(response_error_data: str) -&gt;None:</span>
<span class="w"> </span>        String length (32 bytes)
<span class="w"> </span>        Reason string (padded, use string length from above to get meaningful part)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if response_error_data.startswith(&#39;Reverted &#39;):</span>
<span class="gi">+        response_error_data = response_error_data[9:]</span>
<span class="gi">+    if response_error_data.startswith(&#39;0x&#39;):</span>
<span class="gi">+        response_error_data = response_error_data[2:]</span>

<span class="gi">+    if response_error_data.startswith(SOLIDITY_ERROR_FUNC_SELECTOR[2:]):</span>
<span class="gi">+        error_msg = _parse_error_with_reverted_prefix(response_error_data)</span>
<span class="gi">+        raise ContractLogicError(error_msg)</span>
<span class="gi">+    elif response_error_data.startswith(PANIC_ERROR_FUNC_SELECTOR[2:]):</span>
<span class="gi">+        panic_code = response_error_data[8:10]</span>
<span class="gi">+        panic_msg = PANIC_ERROR_CODES.get(panic_code, f&quot;Unknown panic error code: {panic_code}&quot;)</span>
<span class="gi">+        raise ContractPanicError(panic_msg)</span>
<span class="gi">+    elif response_error_data.startswith(OFFCHAIN_LOOKUP_FUNC_SELECTOR[2:]):</span>
<span class="gi">+        try:</span>
<span class="gi">+            decoded = abi.decode(list(OFFCHAIN_LOOKUP_FIELDS.values()), to_bytes(hexstr=response_error_data[10:]))</span>
<span class="gi">+            raise OffchainLookup(dict(zip(OFFCHAIN_LOOKUP_FIELDS.keys(), decoded)))</span>
<span class="gi">+        except:</span>
<span class="gi">+            raise ContractLogicError(&quot;Failed to decode OffchainLookup error&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ContractCustomError(f&quot;Unknown error: {response_error_data}&quot;)</span>

<span class="gd">-def raise_contract_logic_error_on_revert(response: RPCResponse) -&gt;RPCResponse:</span>
<span class="gi">+</span>
<span class="gi">+def raise_contract_logic_error_on_revert(response: RPCResponse) -&gt; RPCResponse:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Revert responses contain an error with the following optional attributes:
<span class="w"> </span>        `code` - in this context, used for an unknown edge case when code = &#39;3&#39;
<span class="gu">@@ -54,13 +86,40 @@ def raise_contract_logic_error_on_revert(response: RPCResponse) -&gt;RPCResponse:</span>

<span class="w"> </span>    See also https://solidity.readthedocs.io/en/v0.6.3/control-structures.html#revert
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;error&#39; not in response:</span>
<span class="gi">+        return response</span>
<span class="gi">+</span>
<span class="gi">+    error = response[&#39;error&#39;]</span>
<span class="gi">+    message = error.get(&#39;message&#39;, &#39;&#39;)</span>
<span class="gi">+    code = error.get(&#39;code&#39;)</span>
<span class="gi">+    data = error.get(&#39;data&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if code == 3:</span>
<span class="gi">+        raise ContractLogicError(message)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(data, str):</span>
<span class="gi">+        if data.startswith(&#39;Reverted &#39;) or data.startswith(&#39;0x&#39;):</span>
<span class="gi">+            _raise_contract_error(data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ContractLogicError(data)</span>
<span class="gi">+    elif isinstance(data, dict) and isinstance(data.get(&#39;message&#39;), str):</span>
<span class="gi">+        raise ContractLogicError(data[&#39;message&#39;])</span>
<span class="gi">+    elif message:</span>
<span class="gi">+        raise ContractLogicError(message)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ContractLogicError(&quot;Unspecified contract error&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return response  # This line will never be reached, but it&#39;s kept for consistency</span>


<span class="gd">-def raise_transaction_indexing_error_if_indexing(response: RPCResponse</span>
<span class="gd">-    ) -&gt;RPCResponse:</span>
<span class="gi">+def raise_transaction_indexing_error_if_indexing(response: RPCResponse) -&gt; RPCResponse:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Raise an error if ``eth_getTransactionReceipt`` returns an error indicating that
<span class="w"> </span>    transactions are still being indexed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;error&#39; in response:</span>
<span class="gi">+        error = response[&#39;error&#39;]</span>
<span class="gi">+        message = error.get(&#39;message&#39;, &#39;&#39;)</span>
<span class="gi">+        if &#39;still indexing&#39; in message.lower():</span>
<span class="gi">+            raise TransactionIndexingInProgress(message)</span>
<span class="gi">+    return response</span>
<span class="gh">diff --git a/web3/_utils/events.py b/web3/_utils/events.py</span>
<span class="gh">index 98c9092d..d1ebf623 100644</span>
<span class="gd">--- a/web3/_utils/events.py</span>
<span class="gi">+++ b/web3/_utils/events.py</span>
<span class="gu">@@ -29,7 +29,11 @@ def get_event_abi_types_for_decoding(event_inputs: Sequence[ABIEventParams]</span>
<span class="w"> </span>    `string`.  Because of this we need to modify the types so that we can
<span class="w"> </span>    decode the log entries using the correct types.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for input in event_inputs:</span>
<span class="gi">+        if input[&#39;indexed&#39;] and input[&#39;type&#39;] in (&#39;string&#39;, &#39;bytes&#39;):</span>
<span class="gi">+            yield &#39;bytes32&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield input[&#39;type&#39;]</span>


<span class="w"> </span>@curry
<span class="gu">@@ -39,7 +43,47 @@ def get_event_data(abi_codec: ABICodec, event_abi: ABIEvent, log_entry:</span>
<span class="w"> </span>    Given an event ABI and a log entry for that event, return the decoded
<span class="w"> </span>    event data
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    log_topics = log_entry[&#39;topics&#39;]</span>
<span class="gi">+    log_data = log_entry[&#39;data&#39;]</span>
<span class="gi">+    </span>
<span class="gi">+    # Validate that the first topic is the event signature</span>
<span class="gi">+    if event_abi_to_log_topic(event_abi) != log_topics[0]:</span>
<span class="gi">+        raise MismatchedABI(&quot;Event signature mismatch&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    indexed_inputs = get_indexed_event_inputs(event_abi)</span>
<span class="gi">+    non_indexed_inputs = exclude_indexed_event_inputs(event_abi)</span>
<span class="gi">+    </span>
<span class="gi">+    # Decode indexed inputs</span>
<span class="gi">+    decoded_indexed_data = abi_codec.decode(</span>
<span class="gi">+        [input[&#39;type&#39;] for input in indexed_inputs],</span>
<span class="gi">+        b&#39;&#39;.join(log_topics[1:])</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    # Decode non-indexed inputs</span>
<span class="gi">+    decoded_non_indexed_data = abi_codec.decode(</span>
<span class="gi">+        [input[&#39;type&#39;] for input in non_indexed_inputs],</span>
<span class="gi">+        log_data</span>
<span class="gi">+    )</span>
<span class="gi">+    </span>
<span class="gi">+    # Combine decoded data</span>
<span class="gi">+    decoded_data = list(decoded_indexed_data) + list(decoded_non_indexed_data)</span>
<span class="gi">+    </span>
<span class="gi">+    # Create a dictionary of decoded data</span>
<span class="gi">+    event_data = {</span>
<span class="gi">+        &#39;args&#39;: AttributeDict(dict(zip(</span>
<span class="gi">+            [input[&#39;name&#39;] for input in event_abi[&#39;inputs&#39;]],</span>
<span class="gi">+            decoded_data</span>
<span class="gi">+        ))),</span>
<span class="gi">+        &#39;event&#39;: event_abi[&#39;name&#39;],</span>
<span class="gi">+        &#39;logIndex&#39;: log_entry[&#39;logIndex&#39;],</span>
<span class="gi">+        &#39;transactionIndex&#39;: log_entry[&#39;transactionIndex&#39;],</span>
<span class="gi">+        &#39;transactionHash&#39;: log_entry[&#39;transactionHash&#39;],</span>
<span class="gi">+        &#39;address&#39;: log_entry[&#39;address&#39;],</span>
<span class="gi">+        &#39;blockHash&#39;: log_entry[&#39;blockHash&#39;],</span>
<span class="gi">+        &#39;blockNumber&#39;: log_entry[&#39;blockNumber&#39;],</span>
<span class="gi">+    }</span>
<span class="gi">+    </span>
<span class="gi">+    return AttributeDict(event_data)</span>


<span class="w"> </span>normalize_topic_list = compose(remove_trailing_from_seq(remove_value=None),
<span class="gh">diff --git a/web3/_utils/filters.py b/web3/_utils/filters.py</span>
<span class="gh">index ef9ab1d2..abe78a49 100644</span>
<span class="gd">--- a/web3/_utils/filters.py</span>
<span class="gi">+++ b/web3/_utils/filters.py</span>
<span class="gu">@@ -34,13 +34,13 @@ class BaseFilter:</span>
<span class="w"> </span>        Hook for subclasses to change the format of the value that is passed
<span class="w"> </span>        into the callback functions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return entry</span>

<span class="w"> </span>    def is_valid_entry(self, entry: LogReceipt) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Hook for subclasses to implement additional filtering layers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>


<span class="w"> </span>class Filter(BaseFilter):
<span class="gu">@@ -95,7 +95,15 @@ class LogFilter(Filter):</span>
<span class="w"> </span>        Expects a set of tuples with the type and value, e.g.:
<span class="w"> </span>        ((&#39;uint256&#39;, [12345, 54321]), (&#39;string&#39;, (&#39;a-single-string&#39;,)))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.data_filter_set = data_filter_set</span>
<span class="gi">+        self.data_filter_set_regex = []</span>
<span class="gi">+        self.data_filter_set_function = []</span>
<span class="gi">+</span>
<span class="gi">+        for data_type, data_value in data_filter_set:</span>
<span class="gi">+            if is_string(data_value) and not is_hex(data_value):</span>
<span class="gi">+                self.data_filter_set_regex.append((data_type, data_value))</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.data_filter_set_function.append((data_type, data_value))</span>


<span class="w"> </span>class AsyncLogFilter(AsyncFilter):
<span class="gu">@@ -120,7 +128,15 @@ class AsyncLogFilter(AsyncFilter):</span>
<span class="w"> </span>        Expects a set of tuples with the type and value, e.g.:
<span class="w"> </span>        ((&#39;uint256&#39;, [12345, 54321]), (&#39;string&#39;, (&#39;a-single-string&#39;,)))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.data_filter_set = data_filter_set</span>
<span class="gi">+        self.data_filter_set_regex = []</span>
<span class="gi">+        self.data_filter_set_function = []</span>
<span class="gi">+</span>
<span class="gi">+        for data_type, data_value in data_filter_set:</span>
<span class="gi">+            if is_string(data_value) and not is_hex(data_value):</span>
<span class="gi">+                self.data_filter_set_regex.append((data_type, data_value))</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.data_filter_set_function.append((data_type, data_value))</span>


<span class="w"> </span>not_text = complement(is_text)
<span class="gu">@@ -133,7 +149,10 @@ def normalize_data_values(type_string: TypeStr, data_value: Any) -&gt;Any:</span>
<span class="w"> </span>    eth-abi v1 returns utf-8 bytes for string values.
<span class="w"> </span>    This can be removed once eth-abi v2 is required.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if type_string == &#39;string&#39;:</span>
<span class="gi">+        return normalize_to_text(data_value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return data_value</span>


<span class="w"> </span>@curry
<span class="gu">@@ -144,7 +163,18 @@ def match_fn(codec: ABICodec, match_values_and_abi: Collection[Tuple[str,</span>
<span class="w"> </span>    Values provided through the match_values_and_abi parameter are
<span class="w"> </span>    compared to the abi decoded log data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    types, match_values = zip(*match_values_and_abi)</span>
<span class="gi">+    decoded_values = codec.decode(types, HexBytes(data))</span>
<span class="gi">+    normalized_decoded_values = [</span>
<span class="gi">+        normalize_data_values(type_string, data_value)</span>
<span class="gi">+        for type_string, data_value</span>
<span class="gi">+        in zip(types, decoded_values)</span>
<span class="gi">+    ]</span>
<span class="gi">+    return all(</span>
<span class="gi">+        match_value == decoded_value</span>
<span class="gi">+        for match_value, decoded_value</span>
<span class="gi">+        in zip(match_values, normalized_decoded_values)</span>
<span class="gi">+    )</span>


<span class="w"> </span>class _UseExistingFilter(Exception):
<span class="gh">diff --git a/web3/_utils/formatters.py b/web3/_utils/formatters.py</span>
<span class="gh">index 542d1594..2ef72506 100644</span>
<span class="gd">--- a/web3/_utils/formatters.py</span>
<span class="gi">+++ b/web3/_utils/formatters.py</span>
<span class="gu">@@ -15,7 +15,11 @@ def map_collection(func: Callable[..., TReturn], collection: Any) -&gt;Any:</span>
<span class="w"> </span>    Apply func to each element of a collection, or value of a dictionary.
<span class="w"> </span>    If the value is not a collection, return it unmodified
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(collection, Mapping):</span>
<span class="gi">+        return {key: func(val) for key, val in collection.items()}</span>
<span class="gi">+    elif is_list_like(collection):</span>
<span class="gi">+        return [func(val) for val in collection]</span>
<span class="gi">+    return collection</span>


<span class="w"> </span>@reject_recursive_repeats
<span class="gu">@@ -25,4 +29,4 @@ def recursive_map(func: Callable[..., TReturn], data: Any) -&gt;TReturn:</span>
<span class="w"> </span>    Define func so that it only applies to the type of value that you
<span class="w"> </span>    want it to apply to.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return map_collection(lambda item: recursive_map(func, item), func(data))</span>
<span class="gh">diff --git a/web3/_utils/function_identifiers.py b/web3/_utils/function_identifiers.py</span>
<span class="gh">index b3f650b7..064855ae 100644</span>
<span class="gd">--- a/web3/_utils/function_identifiers.py</span>
<span class="gi">+++ b/web3/_utils/function_identifiers.py</span>
<span class="gu">@@ -1,6 +1,34 @@</span>
<span class="w"> </span>class FallbackFn:
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Represents a fallback function in Solidity contracts.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    def __init__(self):</span>
<span class="gi">+        self.selector = b&#39;&#39;</span>
<span class="gi">+        self.abi = {</span>
<span class="gi">+            &#39;type&#39;: &#39;fallback&#39;,</span>
<span class="gi">+            &#39;stateMutability&#39;: &#39;payable&#39;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self):</span>
<span class="gi">+        return &#39;&lt;fallback&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self):</span>
<span class="gi">+        return f&#39;FallbackFn()&#39;</span>


<span class="w"> </span>class ReceiveFn:
<span class="gd">-    pass</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Represents a receive function in Solidity contracts.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    def __init__(self):</span>
<span class="gi">+        self.selector = b&#39;&#39;</span>
<span class="gi">+        self.abi = {</span>
<span class="gi">+            &#39;type&#39;: &#39;receive&#39;,</span>
<span class="gi">+            &#39;stateMutability&#39;: &#39;payable&#39;</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self):</span>
<span class="gi">+        return &#39;&lt;receive&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self):</span>
<span class="gi">+        return f&#39;ReceiveFn()&#39;</span>
<span class="gh">diff --git a/web3/_utils/math.py b/web3/_utils/math.py</span>
<span class="gh">index e2ea76f7..e51fe133 100644</span>
<span class="gd">--- a/web3/_utils/math.py</span>
<span class="gi">+++ b/web3/_utils/math.py</span>
<span class="gu">@@ -5,4 +5,24 @@ from web3.exceptions import InsufficientData</span>
<span class="w"> </span>def percentile(values: Optional[Sequence[int]]=None, percentile: Optional[
<span class="w"> </span>    float]=None) -&gt;float:
<span class="w"> </span>    &quot;&quot;&quot;Calculates a simplified weighted average percentile&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if values is None or percentile is None:</span>
<span class="gi">+        raise InsufficientData(&quot;Both &#39;values&#39; and &#39;percentile&#39; must be provided&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if not 0 &lt;= percentile &lt;= 100:</span>
<span class="gi">+        raise ValueError(&quot;Percentile must be between 0 and 100&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if not values:</span>
<span class="gi">+        raise InsufficientData(&quot;The &#39;values&#39; sequence cannot be empty&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    sorted_values = sorted(values)</span>
<span class="gi">+    index = (len(sorted_values) - 1) * percentile / 100</span>
<span class="gi">+    </span>
<span class="gi">+    if index.is_integer():</span>
<span class="gi">+        return float(sorted_values[int(index)])</span>
<span class="gi">+    else:</span>
<span class="gi">+        lower_index = int(index)</span>
<span class="gi">+        upper_index = lower_index + 1</span>
<span class="gi">+        lower_value = sorted_values[lower_index]</span>
<span class="gi">+        upper_value = sorted_values[upper_index]</span>
<span class="gi">+        fraction = index - lower_index</span>
<span class="gi">+        return lower_value + (upper_value - lower_value) * fraction</span>
<span class="gh">diff --git a/web3/_utils/method_formatters.py b/web3/_utils/method_formatters.py</span>
<span class="gh">index 96fd37e1..aae675c4 100644</span>
<span class="gd">--- a/web3/_utils/method_formatters.py</span>
<span class="gi">+++ b/web3/_utils/method_formatters.py</span>
<span class="gu">@@ -37,7 +37,10 @@ def type_aware_apply_formatters_to_dict(formatters: Formatters, value:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Preserve ``AttributeDict`` types if original ``value`` was an ``AttributeDict``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    formatted_dict = apply_formatters_to_dict(formatters, value)</span>
<span class="gi">+    if isinstance(value, AttributeDict):</span>
<span class="gi">+        return AttributeDict.recursive(formatted_dict)</span>
<span class="gi">+    return formatted_dict</span>


<span class="w"> </span>def type_aware_apply_formatters_to_dict_keys_and_values(key_formatters:
<span class="gu">@@ -47,7 +50,13 @@ def type_aware_apply_formatters_to_dict_keys_and_values(key_formatters:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Preserve ``AttributeDict`` types if original ``value`` was an ``AttributeDict``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    formatted_dict = {</span>
<span class="gi">+        key_formatters(key): value_formatters(value)</span>
<span class="gi">+        for key, value in dict_like_object.items()</span>
<span class="gi">+    }</span>
<span class="gi">+    if isinstance(dict_like_object, AttributeDict):</span>
<span class="gi">+        return AttributeDict.recursive(formatted_dict)</span>
<span class="gi">+    return formatted_dict</span>


<span class="w"> </span>ACCESS_LIST_FORMATTER = type_aware_apply_formatters_to_dict({&#39;address&#39;:
<span class="gh">diff --git a/web3/_utils/module_testing/eth_module.py b/web3/_utils/module_testing/eth_module.py</span>
<span class="gh">index 2f158deb..def52f16 100644</span>
<span class="gd">--- a/web3/_utils/module_testing/eth_module.py</span>
<span class="gi">+++ b/web3/_utils/module_testing/eth_module.py</span>
<span class="gu">@@ -50,8 +50,266 @@ if TYPE_CHECKING:</span>


<span class="w"> </span>class AsyncEthModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    async def test_eth_gas_price(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        gas_price = await async_w3.eth.gas_price</span>
<span class="gi">+        assert is_integer(gas_price)</span>
<span class="gi">+        assert gas_price &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_max_priority_fee(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        max_priority_fee = await async_w3.eth.max_priority_fee</span>
<span class="gi">+        assert is_integer(max_priority_fee)</span>
<span class="gi">+        assert max_priority_fee &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_accounts(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        accounts = await async_w3.eth.accounts</span>
<span class="gi">+        assert is_list_like(accounts)</span>
<span class="gi">+        assert len(accounts) != 0</span>
<span class="gi">+        assert all(is_checksum_address(account) for account in accounts)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_block_number(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        block_number = await async_w3.eth.block_number</span>
<span class="gi">+        assert is_integer(block_number)</span>
<span class="gi">+        assert block_number &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_block_number(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        block_number = await async_w3.eth.get_block_number()</span>
<span class="gi">+        assert is_integer(block_number)</span>
<span class="gi">+        assert block_number &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_balance(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = await async_w3.eth.coinbase</span>
<span class="gi">+        balance = await async_w3.eth.get_balance(coinbase)</span>
<span class="gi">+        assert is_integer(balance)</span>
<span class="gi">+        assert balance &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_storage_at(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = await async_w3.eth.coinbase</span>
<span class="gi">+        storage = await async_w3.eth.get_storage_at(coinbase, 0)</span>
<span class="gi">+        assert isinstance(storage, HexBytes)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_transaction_count(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = await async_w3.eth.coinbase</span>
<span class="gi">+        transaction_count = await async_w3.eth.get_transaction_count(coinbase)</span>
<span class="gi">+        assert is_integer(transaction_count)</span>
<span class="gi">+        assert transaction_count &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_block(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        latest_block = await async_w3.eth.get_block(&#39;latest&#39;)</span>
<span class="gi">+        assert isinstance(latest_block, BlockData)</span>
<span class="gi">+        assert latest_block[&#39;number&#39;] &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_code(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = await async_w3.eth.coinbase</span>
<span class="gi">+        code = await async_w3.eth.get_code(coinbase)</span>
<span class="gi">+        assert isinstance(code, HexBytes)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_sign(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = await async_w3.eth.coinbase</span>
<span class="gi">+        signature = await async_w3.eth.sign(coinbase, text=&#39;Hello World&#39;)</span>
<span class="gi">+        assert isinstance(signature, HexBytes)</span>
<span class="gi">+        assert len(signature) == 65</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_send_transaction(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = await async_w3.eth.coinbase</span>
<span class="gi">+        transaction = {</span>
<span class="gi">+            &#39;to&#39;: UNKNOWN_ADDRESS,</span>
<span class="gi">+            &#39;from&#39;: coinbase,</span>
<span class="gi">+            &#39;value&#39;: 1,</span>
<span class="gi">+        }</span>
<span class="gi">+        tx_hash = await async_w3.eth.send_transaction(transaction)</span>
<span class="gi">+        assert isinstance(tx_hash, HexBytes)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_transaction(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = await async_w3.eth.coinbase</span>
<span class="gi">+        transaction = {</span>
<span class="gi">+            &#39;to&#39;: UNKNOWN_ADDRESS,</span>
<span class="gi">+            &#39;from&#39;: coinbase,</span>
<span class="gi">+            &#39;value&#39;: 1,</span>
<span class="gi">+        }</span>
<span class="gi">+        tx_hash = await async_w3.eth.send_transaction(transaction)</span>
<span class="gi">+        tx = await async_w3.eth.get_transaction(tx_hash)</span>
<span class="gi">+        assert isinstance(tx, TxData)</span>
<span class="gi">+        assert tx[&#39;hash&#39;] == tx_hash</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_transaction_receipt(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = await async_w3.eth.coinbase</span>
<span class="gi">+        transaction = {</span>
<span class="gi">+            &#39;to&#39;: UNKNOWN_ADDRESS,</span>
<span class="gi">+            &#39;from&#39;: coinbase,</span>
<span class="gi">+            &#39;value&#39;: 1,</span>
<span class="gi">+        }</span>
<span class="gi">+        tx_hash = await async_w3.eth.send_transaction(transaction)</span>
<span class="gi">+        receipt = await async_w3.eth.wait_for_transaction_receipt(tx_hash)</span>
<span class="gi">+        assert isinstance(receipt, TxData)</span>
<span class="gi">+        assert receipt[&#39;transactionHash&#39;] == tx_hash</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_transaction_receipt_unmined(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        with pytest.raises(TransactionNotFound):</span>
<span class="gi">+            await async_w3.eth.get_transaction_receipt(UNKNOWN_HASH)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_transaction_by_block(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        block = await async_w3.eth.get_block(&#39;latest&#39;)</span>
<span class="gi">+        if len(block[&#39;transactions&#39;]) &gt; 0:</span>
<span class="gi">+            transaction = await async_w3.eth.get_transaction_by_block(block[&#39;number&#39;], 0)</span>
<span class="gi">+            assert isinstance(transaction, TxData)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_uncle_by_block(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        block = await async_w3.eth.get_block(&#39;latest&#39;)</span>
<span class="gi">+        if len(block[&#39;uncles&#39;]) &gt; 0:</span>
<span class="gi">+            uncle = await async_w3.eth.get_uncle_by_block(block[&#39;number&#39;], 0)</span>
<span class="gi">+            assert isinstance(uncle, BlockData)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_get_compilers(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        compilers = await async_w3.eth.get_compilers()</span>
<span class="gi">+        assert is_list_like(compilers)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_syncing(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        syncing = await async_w3.eth.syncing</span>
<span class="gi">+        assert is_boolean(syncing) or isinstance(syncing, SyncStatus)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_mining(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        mining = await async_w3.eth.mining</span>
<span class="gi">+        assert is_boolean(mining)</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_hashrate(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        hashrate = await async_w3.eth.hashrate</span>
<span class="gi">+        assert is_integer(hashrate)</span>
<span class="gi">+        assert hashrate &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    async def test_eth_chain_id(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        chain_id = await async_w3.eth.chain_id</span>
<span class="gi">+        assert is_integer(chain_id)</span>
<span class="gi">+        assert chain_id &gt; 0</span>


<span class="w"> </span>class EthModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    def test_eth_gas_price(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        gas_price = web3.eth.gas_price</span>
<span class="gi">+        assert is_integer(gas_price)</span>
<span class="gi">+        assert gas_price &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_max_priority_fee(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        max_priority_fee = web3.eth.max_priority_fee</span>
<span class="gi">+        assert is_integer(max_priority_fee)</span>
<span class="gi">+        assert max_priority_fee &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_accounts(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        accounts = web3.eth.accounts</span>
<span class="gi">+        assert is_list_like(accounts)</span>
<span class="gi">+        assert len(accounts) != 0</span>
<span class="gi">+        assert all(is_checksum_address(account) for account in accounts)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_block_number(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        block_number = web3.eth.block_number</span>
<span class="gi">+        assert is_integer(block_number)</span>
<span class="gi">+        assert block_number &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_block_number(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        block_number = web3.eth.get_block_number()</span>
<span class="gi">+        assert is_integer(block_number)</span>
<span class="gi">+        assert block_number &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_balance(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = web3.eth.coinbase</span>
<span class="gi">+        balance = web3.eth.get_balance(coinbase)</span>
<span class="gi">+        assert is_integer(balance)</span>
<span class="gi">+        assert balance &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_storage_at(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = web3.eth.coinbase</span>
<span class="gi">+        storage = web3.eth.get_storage_at(coinbase, 0)</span>
<span class="gi">+        assert isinstance(storage, HexBytes)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_transaction_count(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = web3.eth.coinbase</span>
<span class="gi">+        transaction_count = web3.eth.get_transaction_count(coinbase)</span>
<span class="gi">+        assert is_integer(transaction_count)</span>
<span class="gi">+        assert transaction_count &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_block(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        latest_block = web3.eth.get_block(&#39;latest&#39;)</span>
<span class="gi">+        assert isinstance(latest_block, BlockData)</span>
<span class="gi">+        assert latest_block[&#39;number&#39;] &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_code(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = web3.eth.coinbase</span>
<span class="gi">+        code = web3.eth.get_code(coinbase)</span>
<span class="gi">+        assert isinstance(code, HexBytes)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_sign(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = web3.eth.coinbase</span>
<span class="gi">+        signature = web3.eth.sign(coinbase, text=&#39;Hello World&#39;)</span>
<span class="gi">+        assert isinstance(signature, HexBytes)</span>
<span class="gi">+        assert len(signature) == 65</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_send_transaction(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = web3.eth.coinbase</span>
<span class="gi">+        transaction = {</span>
<span class="gi">+            &#39;to&#39;: UNKNOWN_ADDRESS,</span>
<span class="gi">+            &#39;from&#39;: coinbase,</span>
<span class="gi">+            &#39;value&#39;: 1,</span>
<span class="gi">+        }</span>
<span class="gi">+        tx_hash = web3.eth.send_transaction(transaction)</span>
<span class="gi">+        assert isinstance(tx_hash, HexBytes)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_transaction(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = web3.eth.coinbase</span>
<span class="gi">+        transaction = {</span>
<span class="gi">+            &#39;to&#39;: UNKNOWN_ADDRESS,</span>
<span class="gi">+            &#39;from&#39;: coinbase,</span>
<span class="gi">+            &#39;value&#39;: 1,</span>
<span class="gi">+        }</span>
<span class="gi">+        tx_hash = web3.eth.send_transaction(transaction)</span>
<span class="gi">+        tx = web3.eth.get_transaction(tx_hash)</span>
<span class="gi">+        assert isinstance(tx, TxData)</span>
<span class="gi">+        assert tx[&#39;hash&#39;] == tx_hash</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_transaction_receipt(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        coinbase = web3.eth.coinbase</span>
<span class="gi">+        transaction = {</span>
<span class="gi">+            &#39;to&#39;: UNKNOWN_ADDRESS,</span>
<span class="gi">+            &#39;from&#39;: coinbase,</span>
<span class="gi">+            &#39;value&#39;: 1,</span>
<span class="gi">+        }</span>
<span class="gi">+        tx_hash = web3.eth.send_transaction(transaction)</span>
<span class="gi">+        receipt = web3.eth.wait_for_transaction_receipt(tx_hash)</span>
<span class="gi">+        assert isinstance(receipt, TxData)</span>
<span class="gi">+        assert receipt[&#39;transactionHash&#39;] == tx_hash</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_transaction_receipt_unmined(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        with pytest.raises(TransactionNotFound):</span>
<span class="gi">+            web3.eth.get_transaction_receipt(UNKNOWN_HASH)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_transaction_by_block(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        block = web3.eth.get_block(&#39;latest&#39;)</span>
<span class="gi">+        if len(block[&#39;transactions&#39;]) &gt; 0:</span>
<span class="gi">+            transaction = web3.eth.get_transaction_by_block(block[&#39;number&#39;], 0)</span>
<span class="gi">+            assert isinstance(transaction, TxData)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_uncle_by_block(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        block = web3.eth.get_block(&#39;latest&#39;)</span>
<span class="gi">+        if len(block[&#39;uncles&#39;]) &gt; 0:</span>
<span class="gi">+            uncle = web3.eth.get_uncle_by_block(block[&#39;number&#39;], 0)</span>
<span class="gi">+            assert isinstance(uncle, BlockData)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_get_compilers(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        compilers = web3.eth.get_compilers()</span>
<span class="gi">+        assert is_list_like(compilers)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_syncing(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        syncing = web3.eth.syncing</span>
<span class="gi">+        assert is_boolean(syncing) or isinstance(syncing, SyncStatus)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_mining(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        mining = web3.eth.mining</span>
<span class="gi">+        assert is_boolean(mining)</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_hashrate(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        hashrate = web3.eth.hashrate</span>
<span class="gi">+        assert is_integer(hashrate)</span>
<span class="gi">+        assert hashrate &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_eth_chain_id(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        chain_id = web3.eth.chain_id</span>
<span class="gi">+        assert is_integer(chain_id)</span>
<span class="gi">+        assert chain_id &gt; 0</span>
<span class="gh">diff --git a/web3/_utils/module_testing/go_ethereum_admin_module.py b/web3/_utils/module_testing/go_ethereum_admin_module.py</span>
<span class="gh">index fb599253..52013020 100644</span>
<span class="gd">--- a/web3/_utils/module_testing/go_ethereum_admin_module.py</span>
<span class="gi">+++ b/web3/_utils/module_testing/go_ethereum_admin_module.py</span>
<span class="gu">@@ -7,8 +7,90 @@ if TYPE_CHECKING:</span>


<span class="w"> </span>class GoEthereumAdminModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    def test_add_peer(self, w3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        enode = &quot;enode://f1a6b0bdbf014355587c3018454d070ac57801f05d3b39fe85da574f002a32e929f683d72aa5a8318382e4d3c7a05c9b91687b0d997a39619fb8a6e7ad88e512@1.1.1.1:30303&quot;</span>
<span class="gi">+        result = w3.geth.admin.add_peer(enode)</span>
<span class="gi">+        assert result</span>
<span class="gi">+</span>
<span class="gi">+    def test_datadir(self, w3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        datadir = w3.geth.admin.datadir()</span>
<span class="gi">+        assert isinstance(datadir, str)</span>
<span class="gi">+        assert len(datadir) &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_node_info(self, w3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        node_info = w3.geth.admin.node_info()</span>
<span class="gi">+        assert isinstance(node_info, AttributeDict)</span>
<span class="gi">+        assert &#39;enode&#39; in node_info</span>
<span class="gi">+        assert &#39;id&#39; in node_info</span>
<span class="gi">+        assert &#39;ip&#39; in node_info</span>
<span class="gi">+        assert &#39;listenAddr&#39; in node_info</span>
<span class="gi">+        assert &#39;name&#39; in node_info</span>
<span class="gi">+</span>
<span class="gi">+    def test_peers(self, w3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        peers = w3.geth.admin.peers()</span>
<span class="gi">+        assert isinstance(peers, List)</span>
<span class="gi">+</span>
<span class="gi">+    def test_start_rpc(self, w3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        result = w3.geth.admin.start_rpc()</span>
<span class="gi">+        assert result</span>
<span class="gi">+</span>
<span class="gi">+    def test_start_ws(self, w3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        result = w3.geth.admin.start_ws()</span>
<span class="gi">+        assert result</span>
<span class="gi">+</span>
<span class="gi">+    def test_stop_rpc(self, w3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        result = w3.geth.admin.stop_rpc()</span>
<span class="gi">+        assert result</span>
<span class="gi">+</span>
<span class="gi">+    def test_stop_ws(self, w3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        result = w3.geth.admin.stop_ws()</span>
<span class="gi">+        assert result</span>


<span class="w"> </span>class GoEthereumAsyncAdminModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_add_peer(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        enode = &quot;enode://f1a6b0bdbf014355587c3018454d070ac57801f05d3b39fe85da574f002a32e929f683d72aa5a8318382e4d3c7a05c9b91687b0d997a39619fb8a6e7ad88e512@1.1.1.1:30303&quot;</span>
<span class="gi">+        result = await async_w3.geth.admin.add_peer(enode)</span>
<span class="gi">+        assert result</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_datadir(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        datadir = await async_w3.geth.admin.datadir()</span>
<span class="gi">+        assert isinstance(datadir, str)</span>
<span class="gi">+        assert len(datadir) &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_node_info(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        node_info = await async_w3.geth.admin.node_info()</span>
<span class="gi">+        assert isinstance(node_info, AttributeDict)</span>
<span class="gi">+        assert &#39;enode&#39; in node_info</span>
<span class="gi">+        assert &#39;id&#39; in node_info</span>
<span class="gi">+        assert &#39;ip&#39; in node_info</span>
<span class="gi">+        assert &#39;listenAddr&#39; in node_info</span>
<span class="gi">+        assert &#39;name&#39; in node_info</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_peers(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        peers = await async_w3.geth.admin.peers()</span>
<span class="gi">+        assert isinstance(peers, List)</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_start_rpc(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        result = await async_w3.geth.admin.start_rpc()</span>
<span class="gi">+        assert result</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_start_ws(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        result = await async_w3.geth.admin.start_ws()</span>
<span class="gi">+        assert result</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_stop_rpc(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        result = await async_w3.geth.admin.stop_rpc()</span>
<span class="gi">+        assert result</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_stop_ws(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        result = await async_w3.geth.admin.stop_ws()</span>
<span class="gi">+        assert result</span>
<span class="gh">diff --git a/web3/_utils/module_testing/go_ethereum_personal_module.py b/web3/_utils/module_testing/go_ethereum_personal_module.py</span>
<span class="gh">index 5bc203d7..ccafdab9 100644</span>
<span class="gd">--- a/web3/_utils/module_testing/go_ethereum_personal_module.py</span>
<span class="gi">+++ b/web3/_utils/module_testing/go_ethereum_personal_module.py</span>
<span class="gu">@@ -24,8 +24,118 @@ ACCOUNT_FOR_UNLOCK = &#39;0x12efDc31B1a8FA1A1e756DFD8A1601055C971E13&#39;</span>


<span class="w"> </span>class GoEthereumPersonalModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    def test_personal_import_raw_key(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        actual = web3.geth.personal.import_raw_key(PRIVATE_KEY_HEX, PASSWORD)</span>
<span class="gi">+        assert actual == ADDRESS</span>
<span class="gi">+</span>
<span class="gi">+    def test_personal_list_accounts(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        accounts = web3.geth.personal.list_accounts()</span>
<span class="gi">+        assert is_list_like(accounts)</span>
<span class="gi">+        assert len(accounts) &gt; 0</span>
<span class="gi">+        assert all((is_checksum_address(item) for item in accounts))</span>
<span class="gi">+</span>
<span class="gi">+    def test_personal_list_wallets(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        wallets = web3.geth.personal.list_wallets()</span>
<span class="gi">+        assert is_list_like(wallets)</span>
<span class="gi">+        assert len(wallets) &gt; 0</span>
<span class="gi">+        assert all((isinstance(item, AttributeDict) for item in wallets))</span>
<span class="gi">+        assert all((is_checksum_address(item[&#39;accounts&#39;][0][&#39;address&#39;]) for item in wallets))</span>
<span class="gi">+</span>
<span class="gi">+    def test_personal_lock_account(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        # Unlock the account first</span>
<span class="gi">+        web3.geth.personal.unlock_account(ACCOUNT_FOR_UNLOCK, PASSWORD)</span>
<span class="gi">+        # Now lock it</span>
<span class="gi">+        result = web3.geth.personal.lock_account(ACCOUNT_FOR_UNLOCK)</span>
<span class="gi">+        assert result is True</span>
<span class="gi">+</span>
<span class="gi">+    def test_personal_new_account(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        new_account = web3.geth.personal.new_account(PASSWORD)</span>
<span class="gi">+        assert is_checksum_address(new_account)</span>
<span class="gi">+</span>
<span class="gi">+    def test_personal_send_transaction(self, web3: &quot;Web3&quot;, unlockable_account_dual_type: ChecksumAddress) -&gt; None:</span>
<span class="gi">+        assert unlockable_account_dual_type.startswith(&#39;0x&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        tx_params: TxParams = {</span>
<span class="gi">+            &#39;from&#39;: unlockable_account_dual_type,</span>
<span class="gi">+            &#39;to&#39;: unlockable_account_dual_type,</span>
<span class="gi">+            &#39;value&#39;: Wei(1),</span>
<span class="gi">+            &#39;gas&#39;: 21000,</span>
<span class="gi">+            &#39;gasPrice&#39;: web3.eth.gas_price,</span>
<span class="gi">+        }</span>
<span class="gi">+        txn_hash = web3.geth.personal.send_transaction(tx_params, PASSWORD)</span>
<span class="gi">+        assert txn_hash</span>
<span class="gi">+        assert isinstance(txn_hash, HexBytes)</span>
<span class="gi">+</span>
<span class="gi">+    def test_personal_sign_and_ecrecover(self, web3: &quot;Web3&quot;, unlockable_account_dual_type: ChecksumAddress) -&gt; None:</span>
<span class="gi">+        message = &#39;test message&#39;</span>
<span class="gi">+        signature = web3.geth.personal.sign(message, unlockable_account_dual_type, PASSWORD)</span>
<span class="gi">+        assert isinstance(signature, HexBytes)</span>
<span class="gi">+        recovered = web3.geth.personal.ec_recover(message, signature)</span>
<span class="gi">+        assert is_same_address(recovered, unlockable_account_dual_type)</span>
<span class="gi">+</span>
<span class="gi">+    def test_personal_unlock_account(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        result = web3.geth.personal.unlock_account(ACCOUNT_FOR_UNLOCK, PASSWORD)</span>
<span class="gi">+        assert result is True</span>


<span class="w"> </span>class GoEthereumAsyncPersonalModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_personal_import_raw_key(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        actual = await async_w3.geth.personal.import_raw_key(PRIVATE_KEY_HEX, PASSWORD)</span>
<span class="gi">+        assert actual == ADDRESS</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_personal_list_accounts(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        accounts = await async_w3.geth.personal.list_accounts()</span>
<span class="gi">+        assert is_list_like(accounts)</span>
<span class="gi">+        assert len(accounts) &gt; 0</span>
<span class="gi">+        assert all((is_checksum_address(item) for item in accounts))</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_personal_list_wallets(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        wallets = await async_w3.geth.personal.list_wallets()</span>
<span class="gi">+        assert is_list_like(wallets)</span>
<span class="gi">+        assert len(wallets) &gt; 0</span>
<span class="gi">+        assert all((isinstance(item, AttributeDict) for item in wallets))</span>
<span class="gi">+        assert all((is_checksum_address(item[&#39;accounts&#39;][0][&#39;address&#39;]) for item in wallets))</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_personal_lock_account(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        # Unlock the account first</span>
<span class="gi">+        await async_w3.geth.personal.unlock_account(ACCOUNT_FOR_UNLOCK, PASSWORD)</span>
<span class="gi">+        # Now lock it</span>
<span class="gi">+        result = await async_w3.geth.personal.lock_account(ACCOUNT_FOR_UNLOCK)</span>
<span class="gi">+        assert result is True</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_personal_new_account(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        new_account = await async_w3.geth.personal.new_account(PASSWORD)</span>
<span class="gi">+        assert is_checksum_address(new_account)</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_personal_send_transaction(self, async_w3: &quot;AsyncWeb3&quot;, unlockable_account_dual_type: ChecksumAddress) -&gt; None:</span>
<span class="gi">+        assert unlockable_account_dual_type.startswith(&#39;0x&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        tx_params: TxParams = {</span>
<span class="gi">+            &#39;from&#39;: unlockable_account_dual_type,</span>
<span class="gi">+            &#39;to&#39;: unlockable_account_dual_type,</span>
<span class="gi">+            &#39;value&#39;: Wei(1),</span>
<span class="gi">+            &#39;gas&#39;: 21000,</span>
<span class="gi">+            &#39;gasPrice&#39;: await async_w3.eth.gas_price,</span>
<span class="gi">+        }</span>
<span class="gi">+        txn_hash = await async_w3.geth.personal.send_transaction(tx_params, PASSWORD)</span>
<span class="gi">+        assert txn_hash</span>
<span class="gi">+        assert isinstance(txn_hash, HexBytes)</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_personal_sign_and_ecrecover(self, async_w3: &quot;AsyncWeb3&quot;, unlockable_account_dual_type: ChecksumAddress) -&gt; None:</span>
<span class="gi">+        message = &#39;test message&#39;</span>
<span class="gi">+        signature = await async_w3.geth.personal.sign(message, unlockable_account_dual_type, PASSWORD)</span>
<span class="gi">+        assert isinstance(signature, HexBytes)</span>
<span class="gi">+        recovered = await async_w3.geth.personal.ec_recover(message, signature)</span>
<span class="gi">+        assert is_same_address(recovered, unlockable_account_dual_type)</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_personal_unlock_account(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        result = await async_w3.geth.personal.unlock_account(ACCOUNT_FOR_UNLOCK, PASSWORD)</span>
<span class="gi">+        assert result is True</span>
<span class="gh">diff --git a/web3/_utils/module_testing/go_ethereum_txpool_module.py b/web3/_utils/module_testing/go_ethereum_txpool_module.py</span>
<span class="gh">index 6c443674..1e916976 100644</span>
<span class="gd">--- a/web3/_utils/module_testing/go_ethereum_txpool_module.py</span>
<span class="gi">+++ b/web3/_utils/module_testing/go_ethereum_txpool_module.py</span>
<span class="gu">@@ -3,8 +3,37 @@ from web3 import AsyncWeb3, Web3</span>


<span class="w"> </span>class GoEthereumAsyncTxPoolModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_txpool_content(self, async_w3: AsyncWeb3):</span>
<span class="gi">+        content = await async_w3.txpool.content()</span>
<span class="gi">+        assert isinstance(content, dict)</span>
<span class="gi">+        assert all(key in content for key in (&#39;pending&#39;, &#39;queued&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_txpool_inspect(self, async_w3: AsyncWeb3):</span>
<span class="gi">+        inspect = await async_w3.txpool.inspect()</span>
<span class="gi">+        assert isinstance(inspect, dict)</span>
<span class="gi">+        assert all(key in inspect for key in (&#39;pending&#39;, &#39;queued&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_txpool_status(self, async_w3: AsyncWeb3):</span>
<span class="gi">+        status = await async_w3.txpool.status()</span>
<span class="gi">+        assert isinstance(status, dict)</span>
<span class="gi">+        assert all(key in status for key in (&#39;pending&#39;, &#39;queued&#39;))</span>


<span class="w"> </span>class GoEthereumTxPoolModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    def test_txpool_content(self, w3: Web3):</span>
<span class="gi">+        content = w3.txpool.content()</span>
<span class="gi">+        assert isinstance(content, dict)</span>
<span class="gi">+        assert all(key in content for key in (&#39;pending&#39;, &#39;queued&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def test_txpool_inspect(self, w3: Web3):</span>
<span class="gi">+        inspect = w3.txpool.inspect()</span>
<span class="gi">+        assert isinstance(inspect, dict)</span>
<span class="gi">+        assert all(key in inspect for key in (&#39;pending&#39;, &#39;queued&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def test_txpool_status(self, w3: Web3):</span>
<span class="gi">+        status = w3.txpool.status()</span>
<span class="gi">+        assert isinstance(status, dict)</span>
<span class="gi">+        assert all(key in status for key in (&#39;pending&#39;, &#39;queued&#39;))</span>
<span class="gh">diff --git a/web3/_utils/module_testing/net_module.py b/web3/_utils/module_testing/net_module.py</span>
<span class="gh">index b5708289..86a218f0 100644</span>
<span class="gd">--- a/web3/_utils/module_testing/net_module.py</span>
<span class="gi">+++ b/web3/_utils/module_testing/net_module.py</span>
<span class="gu">@@ -6,8 +6,33 @@ if TYPE_CHECKING:</span>


<span class="w"> </span>class NetModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    def test_net_version(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        version = web3.net.version</span>
<span class="gi">+        assert is_string(version)</span>
<span class="gi">+        assert version.isdigit()</span>
<span class="gi">+</span>
<span class="gi">+    def test_net_listening(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        listening = web3.net.listening</span>
<span class="gi">+        assert is_boolean(listening)</span>
<span class="gi">+</span>
<span class="gi">+    def test_net_peer_count(self, web3: &quot;Web3&quot;) -&gt; None:</span>
<span class="gi">+        peer_count = web3.net.peer_count</span>
<span class="gi">+        assert is_integer(peer_count)</span>


<span class="w"> </span>class AsyncNetModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_net_version(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        version = await async_w3.net.version</span>
<span class="gi">+        assert is_string(version)</span>
<span class="gi">+        assert version.isdigit()</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_net_listening(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        listening = await async_w3.net.listening</span>
<span class="gi">+        assert is_boolean(listening)</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_async_net_peer_count(self, async_w3: &quot;AsyncWeb3&quot;) -&gt; None:</span>
<span class="gi">+        peer_count = await async_w3.net.peer_count</span>
<span class="gi">+        assert is_integer(peer_count)</span>
<span class="gh">diff --git a/web3/_utils/module_testing/persistent_connection_provider.py b/web3/_utils/module_testing/persistent_connection_provider.py</span>
<span class="gh">index 4724376e..2bfd5561 100644</span>
<span class="gd">--- a/web3/_utils/module_testing/persistent_connection_provider.py</span>
<span class="gi">+++ b/web3/_utils/module_testing/persistent_connection_provider.py</span>
<span class="gu">@@ -11,4 +11,74 @@ if TYPE_CHECKING:</span>


<span class="w"> </span>class PersistentConnectionProviderTest:
<span class="gd">-    pass</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_persistent_connection_provider(self, async_w3: &quot;_PersistentConnectionWeb3&quot;) -&gt; None:</span>
<span class="gi">+        async_w3.middleware_onion.inject(async_geth_poa_middleware, layer=0)</span>
<span class="gi">+        </span>
<span class="gi">+        async with async_w3.persistent_websocket() as ws:</span>
<span class="gi">+            subscription_id = await ws.eth.subscribe(&quot;newHeads&quot;)</span>
<span class="gi">+            assert is_hexstr(subscription_id)</span>
<span class="gi">+</span>
<span class="gi">+            # Wait for the next block</span>
<span class="gi">+            response = await ws.receive()</span>
<span class="gi">+            formatted_response = self._format_subscription_response(response)</span>
<span class="gi">+</span>
<span class="gi">+            assert formatted_response[&quot;subscription&quot;] == subscription_id</span>
<span class="gi">+            assert &quot;result&quot; in formatted_response</span>
<span class="gi">+            assert isinstance(formatted_response[&quot;result&quot;], AttributeDict)</span>
<span class="gi">+            assert &quot;number&quot; in formatted_response[&quot;result&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            # Unsubscribe</span>
<span class="gi">+            success = await ws.eth.unsubscribe(subscription_id)</span>
<span class="gi">+            assert success is True</span>
<span class="gi">+</span>
<span class="gi">+    def _format_subscription_response(</span>
<span class="gi">+        self, response: Dict[str, Any]</span>
<span class="gi">+    ) -&gt; FormattedEthSubscriptionResponse:</span>
<span class="gi">+        return cast(</span>
<span class="gi">+            FormattedEthSubscriptionResponse,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;subscription&quot;: HexBytes(response[&quot;params&quot;][&quot;subscription&quot;]).hex(),</span>
<span class="gi">+                &quot;result&quot;: AttributeDict(response[&quot;params&quot;][&quot;result&quot;]),</span>
<span class="gi">+            },</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_persistent_connection_provider_with_middleware(</span>
<span class="gi">+        self, async_w3: &quot;_PersistentConnectionWeb3&quot;</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        async def middleware(make_request, w3):</span>
<span class="gi">+            async def middleware_fn(method, params):</span>
<span class="gi">+                if method == &quot;eth_blockNumber&quot;:</span>
<span class="gi">+                    return {&quot;result&quot;: &quot;0x1234&quot;}</span>
<span class="gi">+                return await make_request(method, params)</span>
<span class="gi">+            return middleware_fn</span>
<span class="gi">+</span>
<span class="gi">+        async_w3.middleware_onion.add(middleware)</span>
<span class="gi">+</span>
<span class="gi">+        async with async_w3.persistent_websocket() as ws:</span>
<span class="gi">+            block_number = await ws.eth.block_number</span>
<span class="gi">+            assert block_number == 0x1234</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_persistent_connection_provider_multiple_requests(</span>
<span class="gi">+        self, async_w3: &quot;_PersistentConnectionWeb3&quot;</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        async with async_w3.persistent_websocket() as ws:</span>
<span class="gi">+            tasks = [</span>
<span class="gi">+                ws.eth.chain_id,</span>
<span class="gi">+                ws.eth.block_number,</span>
<span class="gi">+                ws.eth.gas_price,</span>
<span class="gi">+            ]</span>
<span class="gi">+            results = await asyncio.gather(*tasks)</span>
<span class="gi">+            </span>
<span class="gi">+            assert len(results) == 3</span>
<span class="gi">+            assert all(isinstance(result, int) for result in results)</span>
<span class="gi">+</span>
<span class="gi">+    @pytest.mark.asyncio</span>
<span class="gi">+    async def test_persistent_connection_provider_error_handling(</span>
<span class="gi">+        self, async_w3: &quot;_PersistentConnectionWeb3&quot;</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        async with async_w3.persistent_websocket() as ws:</span>
<span class="gi">+            with pytest.raises(ValueError):</span>
<span class="gi">+                await ws.eth.get_block(&quot;invalid_block_identifier&quot;)</span>
<span class="gh">diff --git a/web3/_utils/module_testing/web3_module.py b/web3/_utils/module_testing/web3_module.py</span>
<span class="gh">index fbc05357..89846a84 100644</span>
<span class="gd">--- a/web3/_utils/module_testing/web3_module.py</span>
<span class="gi">+++ b/web3/_utils/module_testing/web3_module.py</span>
<span class="gu">@@ -8,4 +8,51 @@ from web3.exceptions import InvalidAddress</span>


<span class="w"> </span>class Web3ModuleTest:
<span class="gd">-    pass</span>
<span class="gi">+    def test_web3_clientVersion(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        client_version = web3.clientVersion</span>
<span class="gi">+        assert isinstance(client_version, str)</span>
<span class="gi">+        assert len(client_version) &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+    def test_web3_api_deprecated(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        with pytest.warns(DeprecationWarning):</span>
<span class="gi">+            assert web3.api == &quot;web3&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def test_web3_sha3(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        assert web3.sha3(0x678901) == HexBytes(&#39;0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45&#39;)</span>
<span class="gi">+        assert web3.sha3(text=&#39;web3.py&#39;) == HexBytes(&#39;0x64e604787cbf194841e7b68d7cd28786f6c9a0a3ab9f8b0a0e87cb4387ab0107&#39;)</span>
<span class="gi">+        assert web3.sha3(hexstr=&#39;0x80&#39;) == HexBytes(&#39;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&#39;)</span>
<span class="gi">+        assert web3.sha3(b&#39;\x01\x02\x03&#39;) == HexBytes(&#39;0x6e519b1ba5fabfa25f89f1dbe6037ec016d3dc33c0a6e4f56a5f33a93b99db80&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def test_web3_to_hex(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        assert web3.to_hex(b&#39;\x01\x02\x03&#39;) == &#39;0x010203&#39;</span>
<span class="gi">+        assert web3.to_hex(&#39;abc&#39;) == &#39;0x616263&#39;</span>
<span class="gi">+        assert web3.to_hex(12345) == &#39;0x3039&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def test_web3_to_text(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        assert web3.to_text(HexBytes(&#39;0x666f6f626172&#39;)) == &#39;foobar&#39;</span>
<span class="gi">+        assert web3.to_text(&#39;0x666f6f626172&#39;) == &#39;foobar&#39;</span>
<span class="gi">+        assert web3.to_text(b&#39;foobar&#39;) == &#39;foobar&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def test_web3_to_bytes(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        assert web3.to_bytes(HexBytes(&#39;0x666f6f626172&#39;)) == b&#39;foobar&#39;</span>
<span class="gi">+        assert web3.to_bytes(&#39;0x666f6f626172&#39;) == b&#39;foobar&#39;</span>
<span class="gi">+        assert web3.to_bytes(b&#39;foobar&#39;) == b&#39;foobar&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def test_web3_is_address(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        assert web3.is_address(&#39;0xd3CdA913deB6f67967B99D67aCDFa1712C293601&#39;)</span>
<span class="gi">+        assert not web3.is_address(&#39;0xd3CdA913deB6f67967B99D67aCDFa1712C293601#&#39;)</span>
<span class="gi">+        assert not web3.is_address(&#39;0xd3CdA913deB6f67967B99D67aCDFa1712C293601#&#39;)</span>
<span class="gi">+        assert not web3.is_address(&#39;0xd3CdA913deB6f67967B99D67aCDFa1712C293601@&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def test_web3_is_checksum_address(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        assert web3.is_checksum_address(&#39;0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed&#39;)</span>
<span class="gi">+        assert not web3.is_checksum_address(&#39;0x5aaeb6053f3e94c9b9a09f33669435e7ef1beaed&#39;)</span>
<span class="gi">+        assert not web3.is_checksum_address(&#39;0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed#&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def test_web3_to_checksum_address(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        assert web3.to_checksum_address(&#39;0xd3cda913deb6f67967b99d67acdfa1712c293601&#39;) == &#39;0xd3CdA913deB6f67967B99D67aCDFa1712C293601&#39;</span>
<span class="gi">+        with pytest.raises(InvalidAddress):</span>
<span class="gi">+            web3.to_checksum_address(&#39;0xd3cda913deb6f67967b99d67acdfa1712c293601#&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def test_web3_is_connected(self, web3: Union[Web3, AsyncWeb3]) -&gt; None:</span>
<span class="gi">+        assert web3.is_connected()</span>
<span class="gh">diff --git a/web3/_utils/normalizers.py b/web3/_utils/normalizers.py</span>
<span class="gh">index 8cae7f1d..bc7a7ce4 100644</span>
<span class="gd">--- a/web3/_utils/normalizers.py</span>
<span class="gi">+++ b/web3/_utils/normalizers.py</span>
<span class="gu">@@ -26,7 +26,16 @@ def parse_basic_type_str(old_normalizer: Callable[[BasicType, TypeStr, Any],</span>
<span class="w"> </span>    that type string does not represent a basic type (i.e. non-tuple type) or is
<span class="w"> </span>    not parsable, the normalizer does nothing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    @functools.wraps(old_normalizer)</span>
<span class="gi">+    def new_normalizer(type_str: TypeStr, data: Any) -&gt; Tuple[TypeStr, Any]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            abi_type = parse(type_str)</span>
<span class="gi">+            if isinstance(abi_type, BasicType):</span>
<span class="gi">+                return old_normalizer(abi_type, type_str, data)</span>
<span class="gi">+        except ParseError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        return type_str, data</span>
<span class="gi">+    return new_normalizer</span>


<span class="w"> </span>BASE_RETURN_NORMALIZERS = [addresses_checksummed]
<span class="gh">diff --git a/web3/_utils/transactions.py b/web3/_utils/transactions.py</span>
<span class="gh">index 50219835..f73fa32c 100644</span>
<span class="gd">--- a/web3/_utils/transactions.py</span>
<span class="gi">+++ b/web3/_utils/transactions.py</span>
<span class="gu">@@ -29,4 +29,27 @@ def fill_transaction_defaults(w3: &#39;Web3&#39;, transaction: TxParams) -&gt;TxParams:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    if w3 is None, fill as much as possible while offline
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    filled_transaction = cast(TxParams, {})</span>
<span class="gi">+</span>
<span class="gi">+    if transaction.get(&#39;type&#39;) in DYNAMIC_FEE_TXN_PARAMS:</span>
<span class="gi">+        # For dynamic fee transactions (EIP-1559)</span>
<span class="gi">+        defaults = [&#39;maxFeePerGas&#39;, &#39;maxPriorityFeePerGas&#39;, &#39;gas&#39;, &#39;value&#39;, &#39;data&#39;, &#39;chainId&#39;]</span>
<span class="gi">+    else:</span>
<span class="gi">+        # For legacy transactions</span>
<span class="gi">+        defaults = [&#39;gasPrice&#39;, &#39;gas&#39;, &#39;value&#39;, &#39;data&#39;, &#39;chainId&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    for key, default_val in TRANSACTION_DEFAULTS.items():</span>
<span class="gi">+        if key in defaults:</span>
<span class="gi">+            if key not in transaction:</span>
<span class="gi">+                if callable(default_val):</span>
<span class="gi">+                    if w3 is not None:</span>
<span class="gi">+                        filled_transaction[key] = default_val(w3, transaction)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    filled_transaction[key] = default_val</span>
<span class="gi">+</span>
<span class="gi">+    filled_transaction = merge(filled_transaction, transaction)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;gas&#39; in filled_transaction and filled_transaction[&#39;gas&#39;] is None:</span>
<span class="gi">+        filled_transaction = assoc(filled_transaction, &#39;gas&#39;, w3.eth.estimate_gas(filled_transaction))</span>
<span class="gi">+</span>
<span class="gi">+    return filled_transaction</span>
<span class="gh">diff --git a/web3/_utils/type_conversion.py b/web3/_utils/type_conversion.py</span>
<span class="gh">index ac15970d..79635b8d 100644</span>
<span class="gd">--- a/web3/_utils/type_conversion.py</span>
<span class="gi">+++ b/web3/_utils/type_conversion.py</span>
<span class="gu">@@ -8,7 +8,9 @@ def to_hex_if_bytes(val: Union[HexStr, str, bytes, bytearray]) -&gt;HexStr:</span>
<span class="w"> </span>    Note: This method does not validate against all cases and is only
<span class="w"> </span>    meant to work with bytes and hex strings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(val, (bytes, bytearray)):</span>
<span class="gi">+        return to_hex(val)</span>
<span class="gi">+    return HexStr(val)</span>


<span class="w"> </span>def to_bytes_if_hex(val: Union[HexStr, str, bytes, bytearray]) -&gt;bytes:
<span class="gu">@@ -16,4 +18,6 @@ def to_bytes_if_hex(val: Union[HexStr, str, bytes, bytearray]) -&gt;bytes:</span>
<span class="w"> </span>    Note: This method does not validate against all cases and is only
<span class="w"> </span>    meant to work with bytes and hex strings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(val, str):</span>
<span class="gi">+        return to_bytes(hexstr=val)</span>
<span class="gi">+    return to_bytes(val)</span>
<span class="gh">diff --git a/web3/_utils/utility_methods.py b/web3/_utils/utility_methods.py</span>
<span class="gh">index e3a04eb6..fa7c1d1d 100644</span>
<span class="gd">--- a/web3/_utils/utility_methods.py</span>
<span class="gi">+++ b/web3/_utils/utility_methods.py</span>
<span class="gu">@@ -13,7 +13,7 @@ def all_in_dict(values: Iterable[Any], d: Union[Dict[Any, Any], TxData,</span>
<span class="w"> </span>    :return:       True if ALL values exist in keys;
<span class="w"> </span>                   False if NOT ALL values exist in keys
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return all(value in d for value in values)</span>


<span class="w"> </span>def any_in_dict(values: Iterable[Any], d: Union[Dict[Any, Any], TxData,
<span class="gu">@@ -27,7 +27,7 @@ def any_in_dict(values: Iterable[Any], d: Union[Dict[Any, Any], TxData,</span>
<span class="w"> </span>    :return:       True if ANY value exists in keys;
<span class="w"> </span>                   False if NONE of the values exist in keys
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(value in d for value in values)</span>


<span class="w"> </span>def none_in_dict(values: Iterable[Any], d: Union[Dict[Any, Any], TxData,
<span class="gu">@@ -41,7 +41,7 @@ def none_in_dict(values: Iterable[Any], d: Union[Dict[Any, Any], TxData,</span>
<span class="w"> </span>    :return:       True if NONE of the values exist in keys;
<span class="w"> </span>                   False if ANY value exists in keys
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return not any(value in d for value in values)</span>


<span class="w"> </span>def either_set_is_a_subset(set1: Set[Any], set2: Set[Any], percentage: int=100
<span class="gu">@@ -58,4 +58,8 @@ def either_set_is_a_subset(set1: Set[Any], set2: Set[Any], percentage: int=100</span>
<span class="w"> </span>    :return:            True if one set&#39;s intersection with the other set is greater
<span class="w"> </span>                        than or equal to the given percentage of the other set.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not set1 or not set2:</span>
<span class="gi">+        return False</span>
<span class="gi">+    intersection = set1.intersection(set2)</span>
<span class="gi">+    return (len(intersection) &gt;= len(set1) * percentage / 100 or</span>
<span class="gi">+            len(intersection) &gt;= len(set2) * percentage / 100)</span>
<span class="gh">diff --git a/web3/_utils/validation.py b/web3/_utils/validation.py</span>
<span class="gh">index 9b02dbf1..9fcacc43 100644</span>
<span class="gd">--- a/web3/_utils/validation.py</span>
<span class="gi">+++ b/web3/_utils/validation.py</span>
<span class="gu">@@ -8,6 +8,22 @@ from eth_utils.toolz import compose, groupby, valfilter, valmap</span>
<span class="w"> </span>from ens.utils import is_valid_ens_name
<span class="w"> </span>from web3._utils.abi import abi_to_signature, filter_by_type, is_address_type, is_array_type, is_bool_type, is_bytes_type, is_int_type, is_recognized_type, is_string_type, is_uint_type, length_of_array_type, sub_type_of_array_type
<span class="w"> </span>from web3.exceptions import InvalidAddress
<span class="gi">+</span>
<span class="gi">+def is_address(value: Any) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Check if the given value is a valid Ethereum address.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if not isinstance(value, str):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if is_checksum_address(value):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if is_hex_address(value):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if is_binary_address(value):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if is_valid_ens_name(value):</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>
<span class="w"> </span>from web3.types import ABI, ABIFunction


<span class="gu">@@ -15,14 +31,21 @@ def validate_abi(abi: ABI) -&gt;None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Helper function for validating an ABI
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(abi, list):</span>
<span class="gi">+        raise ValueError(&quot;ABI must be a list&quot;)</span>
<span class="gi">+    for item in abi:</span>
<span class="gi">+        if not isinstance(item, dict):</span>
<span class="gi">+            raise ValueError(&quot;ABI items must be dictionaries&quot;)</span>
<span class="gi">+        if &quot;type&quot; not in item:</span>
<span class="gi">+            raise ValueError(&quot;ABI item must have a &#39;type&#39; key&quot;)</span>


<span class="w"> </span>def validate_abi_type(abi_type: TypeStr) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Helper function for validating an abi_type
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not is_recognized_type(abi_type):</span>
<span class="gi">+        raise ValueError(f&quot;Invalid ABI type: {abi_type}&quot;)</span>


<span class="w"> </span>def validate_abi_value(abi_type: TypeStr, value: Any) -&gt;None:
<span class="gu">@@ -30,11 +53,33 @@ def validate_abi_value(abi_type: TypeStr, value: Any) -&gt;None:</span>
<span class="w"> </span>    Helper function for validating a value against the expected abi_type
<span class="w"> </span>    Note: abi_type &#39;bytes&#39; must either be python3 &#39;bytes&#39; object or &#39;&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_array_type(abi_type):</span>
<span class="gi">+        sub_type = sub_type_of_array_type(abi_type)</span>
<span class="gi">+        if not is_list_like(value):</span>
<span class="gi">+            raise ValueError(f&quot;Expected list for array type: {abi_type}&quot;)</span>
<span class="gi">+        for item in value:</span>
<span class="gi">+            validate_abi_value(sub_type, item)</span>
<span class="gi">+    elif is_bool_type(abi_type):</span>
<span class="gi">+        if not is_boolean(value):</span>
<span class="gi">+            raise ValueError(f&quot;Expected boolean for type: {abi_type}&quot;)</span>
<span class="gi">+    elif is_int_type(abi_type) or is_uint_type(abi_type):</span>
<span class="gi">+        if not is_integer(value):</span>
<span class="gi">+            raise ValueError(f&quot;Expected integer for type: {abi_type}&quot;)</span>
<span class="gi">+    elif is_address_type(abi_type):</span>
<span class="gi">+        validate_address(value)</span>
<span class="gi">+    elif is_bytes_type(abi_type):</span>
<span class="gi">+        if not (is_bytes(value) or value == &#39;&#39;):</span>
<span class="gi">+            raise ValueError(f&quot;Expected bytes or empty string for type: {abi_type}&quot;)</span>
<span class="gi">+    elif is_string_type(abi_type):</span>
<span class="gi">+        if not is_string(value):</span>
<span class="gi">+            raise ValueError(f&quot;Expected string for type: {abi_type}&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported ABI type: {abi_type}&quot;)</span>


<span class="w"> </span>def validate_address(value: Any) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Helper function for validating an address
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not is_address(value):</span>
<span class="gi">+        raise InvalidAddress(f&quot;&#39;{value}&#39; is not a valid address&quot;)</span>
<span class="gh">diff --git a/web3/contract/async_contract.py b/web3/contract/async_contract.py</span>
<span class="gh">index 257ec0b8..574e70a7 100644</span>
<span class="gd">--- a/web3/contract/async_contract.py</span>
<span class="gi">+++ b/web3/contract/async_contract.py</span>
<span class="gu">@@ -86,7 +86,33 @@ class AsyncContractEvent(BaseContractEvent):</span>
<span class="w"> </span>          same time as fromBlock or toBlock
<span class="w"> </span>        :yield: Tuple of :class:`AttributeDict` instances
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if block_hash is not None and (fromBlock is not None or toBlock is not None):</span>
<span class="gi">+            raise ValueError(&quot;Cannot set both block_hash and fromBlock/toBlock&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        abi = self._get_event_abi()</span>
<span class="gi">+        argument_filters = argument_filters or {}</span>
<span class="gi">+</span>
<span class="gi">+        if fromBlock is None:</span>
<span class="gi">+            fromBlock = &quot;latest&quot;</span>
<span class="gi">+        if toBlock is None:</span>
<span class="gi">+            toBlock = &quot;latest&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Construct the filter</span>
<span class="gi">+        filter_params = {</span>
<span class="gi">+            &quot;address&quot;: self.address,</span>
<span class="gi">+            &quot;topics&quot;: self.get_event_topics(argument_filters),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if block_hash is not None:</span>
<span class="gi">+            filter_params[&quot;blockHash&quot;] = block_hash</span>
<span class="gi">+        else:</span>
<span class="gi">+            filter_params[&quot;fromBlock&quot;] = fromBlock</span>
<span class="gi">+            filter_params[&quot;toBlock&quot;] = toBlock</span>
<span class="gi">+</span>
<span class="gi">+        logs = await self.w3.eth.get_logs(filter_params)</span>
<span class="gi">+</span>
<span class="gi">+        # Convert raw log data into Python objects</span>
<span class="gi">+        return [get_event_data(self.w3.codec, abi, entry) for entry in logs]</span>

<span class="w"> </span>    @combomethod
<span class="w"> </span>    async def create_filter(self, *, argument_filters: Optional[Dict[str,
<span class="gu">@@ -96,7 +122,26 @@ class AsyncContractEvent(BaseContractEvent):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create filter object that tracks logs emitted by this contract event.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        abi = self._get_event_abi()</span>
<span class="gi">+        self._validate_filter_params(argument_filters)</span>
<span class="gi">+</span>
<span class="gi">+        _filters = dict(**argument_filters) if argument_filters else {}</span>
<span class="gi">+</span>
<span class="gi">+        data_filter_set, event_filter_params = construct_event_filter_params(</span>
<span class="gi">+            abi,</span>
<span class="gi">+            self.w3.codec,</span>
<span class="gi">+            contract_address=self.address,</span>
<span class="gi">+            argument_filters=_filters,</span>
<span class="gi">+            fromBlock=fromBlock,</span>
<span class="gi">+            toBlock=toBlock,</span>
<span class="gi">+            address=address,</span>
<span class="gi">+            topics=topics,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        filter_builder = AsyncEventFilterBuilder(self.w3, self.address, self._get_event_abi())</span>
<span class="gi">+        return await filter_builder.create_filter(</span>
<span class="gi">+            data_filter_set, event_filter_params</span>
<span class="gi">+        )</span>


<span class="w"> </span>class AsyncContractEvents(BaseContractEvents):
<span class="gu">@@ -152,7 +197,24 @@ class AsyncContractFunction(BaseContractFunction):</span>
<span class="w"> </span>        :return: ``Caller`` object that has contract public functions
<span class="w"> </span>            and variables exposed as Python methods
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        call_transaction = self._get_call_txn(transaction)</span>
<span class="gi">+</span>
<span class="gi">+        block_id = await async_parse_block_identifier(self.w3, block_identifier)</span>
<span class="gi">+</span>
<span class="gi">+        return await async_call_contract_function(</span>
<span class="gi">+            self.w3,</span>
<span class="gi">+            self.address,</span>
<span class="gi">+            self._return_data_normalizers,</span>
<span class="gi">+            self.function_identifier,</span>
<span class="gi">+            call_transaction,</span>
<span class="gi">+            block_id,</span>
<span class="gi">+            self.contract_abi,</span>
<span class="gi">+            self.abi,</span>
<span class="gi">+            state_override,</span>
<span class="gi">+            ccip_read_enabled,</span>
<span class="gi">+            *self.args,</span>
<span class="gi">+            **self.kwargs</span>
<span class="gi">+        )</span>


<span class="w"> </span>class AsyncContractFunctions(BaseContractFunctions):
<span class="gu">@@ -213,7 +275,13 @@ class AsyncContract(BaseContract):</span>
<span class="w"> </span>        :param kwargs: The contract constructor arguments as keyword arguments
<span class="w"> </span>        :return: a contract constructor object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cls.bytecode is None:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;Cannot call constructor on a contract that does not have &#39;bytecode&#39; associated &quot;</span>
<span class="gi">+                &quot;with it&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return AsyncContractConstructor(cls.w3, cls.abi, cls.bytecode, *args, **kwargs)</span>


<span class="w"> </span>class AsyncContractCaller(BaseContractCaller):
<span class="gu">@@ -260,4 +328,20 @@ class AsyncContractConstructor(BaseContractConstructor):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Build the transaction dictionary without sending
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if transaction is None:</span>
<span class="gi">+            transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+        defaults = await async_get_transaction_defaults(self.w3, transaction)</span>
<span class="gi">+</span>
<span class="gi">+        if self.address is not None:</span>
<span class="gi">+            defaults[&#39;to&#39;] = self.address</span>
<span class="gi">+</span>
<span class="gi">+        if self.w3.eth.default_account is not empty:</span>
<span class="gi">+            defaults[&#39;from&#39;] = self.w3.eth.default_account</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;data&#39; in defaults:</span>
<span class="gi">+            raise ValueError(&quot;Cannot set data in constructor transaction&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        defaults[&#39;data&#39;] = self._encode_data()</span>
<span class="gi">+</span>
<span class="gi">+        return await async_fill_transaction_defaults(self.w3, defaults)</span>
<span class="gh">diff --git a/web3/contract/base_contract.py b/web3/contract/base_contract.py</span>
<span class="gh">index 49dd148e..af3b043d 100644</span>
<span class="gd">--- a/web3/contract/base_contract.py</span>
<span class="gi">+++ b/web3/contract/base_contract.py</span>
<span class="gu">@@ -213,7 +213,18 @@ class BaseContract:</span>

<span class="w"> </span>        :param data: defaults to function selector
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if args is None:</span>
<span class="gi">+            args = tuple()</span>
<span class="gi">+        if kwargs is None:</span>
<span class="gi">+            kwargs = {}</span>
<span class="gi">+</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(cls.abi, fn_name, args, kwargs)</span>
<span class="gi">+        arguments = merge_args_and_kwargs(fn_abi, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        if data is None:</span>
<span class="gi">+            data = add_0x_prefix(function_abi_to_4byte_selector(fn_abi))</span>
<span class="gi">+</span>
<span class="gi">+        return add_0x_prefix(encode_abi(cls.w3, fn_abi, arguments, data))</span>
<span class="w"> </span>    _return_data_normalizers: Tuple[Callable[..., Any], ...] = tuple()


<span class="gh">diff --git a/web3/contract/contract.py b/web3/contract/contract.py</span>
<span class="gh">index 5e82a39a..6c7d680d 100644</span>
<span class="gd">--- a/web3/contract/contract.py</span>
<span class="gi">+++ b/web3/contract/contract.py</span>
<span class="gu">@@ -86,7 +86,34 @@ class ContractEvent(BaseContractEvent):</span>
<span class="w"> </span>          same time as fromBlock or toBlock
<span class="w"> </span>        :yield: Tuple of :class:`AttributeDict` instances
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if block_hash is not None and (fromBlock is not None or toBlock is not None):</span>
<span class="gi">+            raise ValueError(&quot;block_hash cannot be used with fromBlock or toBlock&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        abi = self._get_event_abi()</span>
<span class="gi">+        argument_filters = argument_filters or {}</span>
<span class="gi">+</span>
<span class="gi">+        if fromBlock is None:</span>
<span class="gi">+            fromBlock = &quot;latest&quot;</span>
<span class="gi">+        if toBlock is None:</span>
<span class="gi">+            toBlock = &quot;latest&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Construct the filter</span>
<span class="gi">+        filter_params = {</span>
<span class="gi">+            &quot;address&quot;: self.address,</span>
<span class="gi">+            &quot;topics&quot;: self._get_event_filter_topics(abi, argument_filters),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if block_hash is not None:</span>
<span class="gi">+            filter_params[&quot;blockHash&quot;] = block_hash</span>
<span class="gi">+        else:</span>
<span class="gi">+            filter_params[&quot;fromBlock&quot;] = fromBlock</span>
<span class="gi">+            filter_params[&quot;toBlock&quot;] = toBlock</span>
<span class="gi">+</span>
<span class="gi">+        logs = self.w3.eth.get_logs(filter_params)</span>
<span class="gi">+</span>
<span class="gi">+        # Convert raw log data into processed event data</span>
<span class="gi">+        for log in logs:</span>
<span class="gi">+            yield get_event_data(self.w3, abi, log)</span>

<span class="w"> </span>    @combomethod
<span class="w"> </span>    def create_filter(self, *, argument_filters: Optional[Dict[str, Any]]=
<span class="gu">@@ -96,7 +123,30 @@ class ContractEvent(BaseContractEvent):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Create filter object that tracks logs emitted by this contract event.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        abi = self._get_event_abi()</span>
<span class="gi">+        </span>
<span class="gi">+        argument_filters = argument_filters or {}</span>
<span class="gi">+        _filters = dict(**argument_filters)</span>
<span class="gi">+        </span>
<span class="gi">+        data_filter_set, event_filter_params = construct_event_filter_params(</span>
<span class="gi">+            abi,</span>
<span class="gi">+            contract_address=self.address,</span>
<span class="gi">+            argument_filters=_filters,</span>
<span class="gi">+            fromBlock=fromBlock,</span>
<span class="gi">+            toBlock=toBlock,</span>
<span class="gi">+            address=address,</span>
<span class="gi">+            topics=topics,</span>
<span class="gi">+        )</span>
<span class="gi">+        </span>
<span class="gi">+        log_data_extract_fn = functools.partial(get_event_data, abi)</span>
<span class="gi">+        </span>
<span class="gi">+        log_filter = self.w3.eth.filter(event_filter_params)</span>
<span class="gi">+        </span>
<span class="gi">+        log_filter.set_data_filters(data_filter_set)</span>
<span class="gi">+        log_filter.log_entry_formatter = log_data_extract_fn</span>
<span class="gi">+        log_filter.filter_params = event_filter_params</span>
<span class="gi">+        </span>
<span class="gi">+        return log_filter</span>


<span class="w"> </span>class ContractEvents(BaseContractEvents):
<span class="gu">@@ -152,7 +202,24 @@ class ContractFunction(BaseContractFunction):</span>
<span class="w"> </span>        :return: ``Caller`` object that has contract public functions
<span class="w"> </span>            and variables exposed as Python methods
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        call_transaction = self._get_call_txn(transaction)</span>
<span class="gi">+</span>
<span class="gi">+        block_id = parse_block_identifier(self.w3, block_identifier)</span>
<span class="gi">+</span>
<span class="gi">+        return call_contract_function(</span>
<span class="gi">+            self.w3,</span>
<span class="gi">+            self.address,</span>
<span class="gi">+            self._return_data_normalizers,</span>
<span class="gi">+            self.function_identifier,</span>
<span class="gi">+            call_transaction,</span>
<span class="gi">+            block_id,</span>
<span class="gi">+            self.contract_abi,</span>
<span class="gi">+            self.abi,</span>
<span class="gi">+            state_override,</span>
<span class="gi">+            ccip_read_enabled,</span>
<span class="gi">+            *self.args,</span>
<span class="gi">+            **self.kwargs</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ContractFunctions(BaseContractFunctions):
<span class="gu">@@ -212,7 +279,19 @@ class Contract(BaseContract):</span>
<span class="w"> </span>        :param kwargs: The contract constructor arguments as keyword arguments
<span class="w"> </span>        :return: a contract constructor object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cls.bytecode is None:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;Cannot call constructor on a contract that does not have &#39;bytecode&#39; associated &quot;</span>
<span class="gi">+                &quot;with it&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return ContractConstructor(</span>
<span class="gi">+            cls.w3,</span>
<span class="gi">+            cls.abi,</span>
<span class="gi">+            cls.bytecode,</span>
<span class="gi">+            *args,</span>
<span class="gi">+            **kwargs</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ContractCaller(BaseContractCaller):
<span class="gu">@@ -258,4 +337,15 @@ class ContractConstructor(BaseContractConstructor):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Build the transaction dictionary without sending
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if transaction is None:</span>
<span class="gi">+            transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+        contracts = self.w3.eth.contract(</span>
<span class="gi">+            abi=self.abi, bytecode=self.bytecode, bytecode_runtime=self.bytecode_runtime</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        built_transaction = contracts._encode_constructor_data(</span>
<span class="gi">+            transaction, self.args, self.kwargs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return fill_transaction_defaults(self.w3, built_transaction)</span>
<span class="gh">diff --git a/web3/contract/utils.py b/web3/contract/utils.py</span>
<span class="gh">index 5bb9317a..6068c62d 100644</span>
<span class="gd">--- a/web3/contract/utils.py</span>
<span class="gi">+++ b/web3/contract/utils.py</span>
<span class="gu">@@ -26,7 +26,65 @@ def call_contract_function(w3: &#39;Web3&#39;, address: ChecksumAddress,</span>
<span class="w"> </span>    Helper function for interacting with a contract function using the
<span class="w"> </span>    `eth_call` API.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if fn_abi is None:</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(contract_abi, function_identifier, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if transaction is None:</span>
<span class="gi">+        transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+    processed_transaction = prepare_transaction(</span>
<span class="gi">+        address,</span>
<span class="gi">+        w3,</span>
<span class="gi">+        fn_identifier=function_identifier,</span>
<span class="gi">+        contract_abi=contract_abi,</span>
<span class="gi">+        fn_abi=fn_abi,</span>
<span class="gi">+        transaction=transaction,</span>
<span class="gi">+        fn_args=args,</span>
<span class="gi">+        fn_kwargs=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    call_transaction = fill_transaction_defaults(w3, processed_transaction)</span>
<span class="gi">+</span>
<span class="gi">+    output_types = get_abi_output_types(fn_abi)</span>
<span class="gi">+</span>
<span class="gi">+    call_params = {</span>
<span class="gi">+        &#39;to&#39;: address,</span>
<span class="gi">+        &#39;data&#39;: call_transaction[&#39;data&#39;],</span>
<span class="gi">+    }</span>
<span class="gi">+    if &#39;gas&#39; in call_transaction:</span>
<span class="gi">+        call_params[&#39;gas&#39;] = call_transaction[&#39;gas&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    if state_override is not None:</span>
<span class="gi">+        call_params[&#39;state_override&#39;] = state_override</span>
<span class="gi">+</span>
<span class="gi">+    if ccip_read_enabled is not None:</span>
<span class="gi">+        call_params[&#39;ccip_read_enabled&#39;] = ccip_read_enabled</span>
<span class="gi">+</span>
<span class="gi">+    result = w3.eth.call(call_params, block_identifier=block_id)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        output_data = w3.codec.decode(output_types, result)</span>
<span class="gi">+    except DecodingError as e:</span>
<span class="gi">+        # Provide a more helpful error message than the one provided by</span>
<span class="gi">+        # eth-abi-utils</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Could not decode contract function call {} return data {} for &quot;</span>
<span class="gi">+            &quot;output_types {}&quot;.format(</span>
<span class="gi">+                function_identifier,</span>
<span class="gi">+                result,</span>
<span class="gi">+                output_types</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        raise BadFunctionCallOutput(msg) from e</span>
<span class="gi">+</span>
<span class="gi">+    normalized_data = map_abi_data(normalizers, output_types, output_data)</span>
<span class="gi">+</span>
<span class="gi">+    if len(normalized_data) == 1:</span>
<span class="gi">+        return normalized_data[0]</span>
<span class="gi">+    elif decode_tuples:</span>
<span class="gi">+        return named_tree(normalized_data, output_types)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return normalized_data</span>


<span class="w"> </span>def transact_with_contract_function(address: ChecksumAddress, w3: &#39;Web3&#39;,
<span class="gu">@@ -37,7 +95,28 @@ def transact_with_contract_function(address: ChecksumAddress, w3: &#39;Web3&#39;,</span>
<span class="w"> </span>    Helper function for interacting with a contract function by sending a
<span class="w"> </span>    transaction.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if transaction is None:</span>
<span class="gi">+        transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+    if fn_abi is None:</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(contract_abi, function_name, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if function_name is None:</span>
<span class="gi">+        function_name = fn_abi[&#39;name&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    processed_transaction = prepare_transaction(</span>
<span class="gi">+        address,</span>
<span class="gi">+        w3,</span>
<span class="gi">+        fn_identifier=function_name,</span>
<span class="gi">+        contract_abi=contract_abi,</span>
<span class="gi">+        transaction=transaction,</span>
<span class="gi">+        fn_abi=fn_abi,</span>
<span class="gi">+        fn_args=args,</span>
<span class="gi">+        fn_kwargs=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    txn_hash = w3.eth.send_transaction(processed_transaction)</span>
<span class="gi">+    return txn_hash</span>


<span class="w"> </span>def estimate_gas_for_function(address: ChecksumAddress, w3: &#39;Web3&#39;,
<span class="gu">@@ -51,7 +130,33 @@ def estimate_gas_for_function(address: ChecksumAddress, w3: &#39;Web3&#39;,</span>
<span class="w"> </span>    Don&#39;t call this directly, instead use :meth:`Contract.estimate_gas`
<span class="w"> </span>    on your contract instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if transaction is None:</span>
<span class="gi">+        transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+    if fn_abi is None:</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(contract_abi, fn_identifier, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if fn_identifier is None:</span>
<span class="gi">+        fn_identifier = fn_abi[&#39;name&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    processed_transaction = prepare_transaction(</span>
<span class="gi">+        address,</span>
<span class="gi">+        w3,</span>
<span class="gi">+        fn_identifier=fn_identifier,</span>
<span class="gi">+        contract_abi=contract_abi,</span>
<span class="gi">+        fn_abi=fn_abi,</span>
<span class="gi">+        transaction=transaction,</span>
<span class="gi">+        fn_args=args,</span>
<span class="gi">+        fn_kwargs=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    gas_estimate = w3.eth.estimate_gas(</span>
<span class="gi">+        processed_transaction,</span>
<span class="gi">+        block_identifier=block_identifier,</span>
<span class="gi">+        state_override=state_override</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return gas_estimate</span>


<span class="w"> </span>def build_transaction_for_function(address: ChecksumAddress, w3: &#39;Web3&#39;,
<span class="gu">@@ -63,7 +168,27 @@ def build_transaction_for_function(address: ChecksumAddress, w3: &#39;Web3&#39;,</span>
<span class="w"> </span>    Don&#39;t call this directly, instead use :meth:`Contract.build_transaction`
<span class="w"> </span>    on your contract instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if transaction is None:</span>
<span class="gi">+        transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+    if fn_abi is None:</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(contract_abi, function_name, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if function_name is None:</span>
<span class="gi">+        function_name = fn_abi[&#39;name&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    processed_transaction = prepare_transaction(</span>
<span class="gi">+        address,</span>
<span class="gi">+        w3,</span>
<span class="gi">+        fn_identifier=function_name,</span>
<span class="gi">+        contract_abi=contract_abi,</span>
<span class="gi">+        transaction=transaction,</span>
<span class="gi">+        fn_abi=fn_abi,</span>
<span class="gi">+        fn_args=args,</span>
<span class="gi">+        fn_kwargs=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return fill_transaction_defaults(w3, processed_transaction)</span>


<span class="w"> </span>async def async_call_contract_function(async_w3: &#39;AsyncWeb3&#39;, address:
<span class="gu">@@ -77,7 +202,63 @@ async def async_call_contract_function(async_w3: &#39;AsyncWeb3&#39;, address:</span>
<span class="w"> </span>    Helper function for interacting with a contract function using the
<span class="w"> </span>    `eth_call` API.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if fn_abi is None:</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(contract_abi, function_identifier, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if transaction is None:</span>
<span class="gi">+        transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+    processed_transaction = prepare_transaction(</span>
<span class="gi">+        address,</span>
<span class="gi">+        async_w3,</span>
<span class="gi">+        fn_identifier=function_identifier,</span>
<span class="gi">+        contract_abi=contract_abi,</span>
<span class="gi">+        fn_abi=fn_abi,</span>
<span class="gi">+        transaction=transaction,</span>
<span class="gi">+        fn_args=args,</span>
<span class="gi">+        fn_kwargs=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    call_transaction = await async_fill_transaction_defaults(async_w3, processed_transaction)</span>
<span class="gi">+</span>
<span class="gi">+    output_types = get_abi_output_types(fn_abi)</span>
<span class="gi">+</span>
<span class="gi">+    call_params = {</span>
<span class="gi">+        &#39;to&#39;: address,</span>
<span class="gi">+        &#39;data&#39;: call_transaction[&#39;data&#39;],</span>
<span class="gi">+    }</span>
<span class="gi">+    if &#39;gas&#39; in call_transaction:</span>
<span class="gi">+        call_params[&#39;gas&#39;] = call_transaction[&#39;gas&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    if state_override is not None:</span>
<span class="gi">+        call_params[&#39;state_override&#39;] = state_override</span>
<span class="gi">+</span>
<span class="gi">+    if ccip_read_enabled is not None:</span>
<span class="gi">+        call_params[&#39;ccip_read_enabled&#39;] = ccip_read_enabled</span>
<span class="gi">+</span>
<span class="gi">+    result = await async_w3.eth.call(call_params, block_identifier=block_id)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        output_data = async_w3.codec.decode(output_types, result)</span>
<span class="gi">+    except DecodingError as e:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Could not decode contract function call {} return data {} for &quot;</span>
<span class="gi">+            &quot;output_types {}&quot;.format(</span>
<span class="gi">+                function_identifier,</span>
<span class="gi">+                result,</span>
<span class="gi">+                output_types</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        raise BadFunctionCallOutput(msg) from e</span>
<span class="gi">+</span>
<span class="gi">+    normalized_data = map_abi_data(normalizers, output_types, output_data)</span>
<span class="gi">+</span>
<span class="gi">+    if len(normalized_data) == 1:</span>
<span class="gi">+        return normalized_data[0]</span>
<span class="gi">+    elif decode_tuples:</span>
<span class="gi">+        return named_tree(normalized_data, output_types)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return normalized_data</span>


<span class="w"> </span>async def async_transact_with_contract_function(address: ChecksumAddress,
<span class="gu">@@ -88,7 +269,28 @@ async def async_transact_with_contract_function(address: ChecksumAddress,</span>
<span class="w"> </span>    Helper function for interacting with a contract function by sending a
<span class="w"> </span>    transaction.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if transaction is None:</span>
<span class="gi">+        transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+    if fn_abi is None:</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(contract_abi, function_name, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if function_name is None:</span>
<span class="gi">+        function_name = fn_abi[&#39;name&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    processed_transaction = prepare_transaction(</span>
<span class="gi">+        address,</span>
<span class="gi">+        async_w3,</span>
<span class="gi">+        fn_identifier=function_name,</span>
<span class="gi">+        contract_abi=contract_abi,</span>
<span class="gi">+        transaction=transaction,</span>
<span class="gi">+        fn_abi=fn_abi,</span>
<span class="gi">+        fn_args=args,</span>
<span class="gi">+        fn_kwargs=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    txn_hash = await async_w3.eth.send_transaction(processed_transaction)</span>
<span class="gi">+    return txn_hash</span>


<span class="w"> </span>async def async_estimate_gas_for_function(address: ChecksumAddress,
<span class="gu">@@ -102,7 +304,33 @@ async def async_estimate_gas_for_function(address: ChecksumAddress,</span>
<span class="w"> </span>    Don&#39;t call this directly, instead use :meth:`Contract.estimate_gas`
<span class="w"> </span>    on your contract instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if transaction is None:</span>
<span class="gi">+        transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+    if fn_abi is None:</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(contract_abi, fn_identifier, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if fn_identifier is None:</span>
<span class="gi">+        fn_identifier = fn_abi[&#39;name&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    processed_transaction = prepare_transaction(</span>
<span class="gi">+        address,</span>
<span class="gi">+        async_w3,</span>
<span class="gi">+        fn_identifier=fn_identifier,</span>
<span class="gi">+        contract_abi=contract_abi,</span>
<span class="gi">+        fn_abi=fn_abi,</span>
<span class="gi">+        transaction=transaction,</span>
<span class="gi">+        fn_args=args,</span>
<span class="gi">+        fn_kwargs=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    gas_estimate = await async_w3.eth.estimate_gas(</span>
<span class="gi">+        processed_transaction,</span>
<span class="gi">+        block_identifier=block_identifier,</span>
<span class="gi">+        state_override=state_override</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return gas_estimate</span>


<span class="w"> </span>async def async_build_transaction_for_function(address: ChecksumAddress,
<span class="gu">@@ -114,4 +342,24 @@ async def async_build_transaction_for_function(address: ChecksumAddress,</span>
<span class="w"> </span>    Don&#39;t call this directly, instead use :meth:`Contract.build_transaction`
<span class="w"> </span>    on your contract instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if transaction is None:</span>
<span class="gi">+        transaction = {}</span>
<span class="gi">+</span>
<span class="gi">+    if fn_abi is None:</span>
<span class="gi">+        fn_abi = find_matching_fn_abi(contract_abi, function_name, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if function_name is None:</span>
<span class="gi">+        function_name = fn_abi[&#39;name&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    processed_transaction = prepare_transaction(</span>
<span class="gi">+        address,</span>
<span class="gi">+        async_w3,</span>
<span class="gi">+        fn_identifier=function_name,</span>
<span class="gi">+        contract_abi=contract_abi,</span>
<span class="gi">+        transaction=transaction,</span>
<span class="gi">+        fn_abi=fn_abi,</span>
<span class="gi">+        fn_args=args,</span>
<span class="gi">+        fn_kwargs=kwargs,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return await async_fill_transaction_defaults(async_w3, processed_transaction)</span>
<span class="gh">diff --git a/web3/datastructures.py b/web3/datastructures.py</span>
<span class="gh">index 0a0a115e..4cf0674b 100644</span>
<span class="gd">--- a/web3/datastructures.py</span>
<span class="gi">+++ b/web3/datastructures.py</span>
<span class="gu">@@ -35,7 +35,18 @@ class ReadableAttributeDict(Mapping[TKey, TValue]):</span>
<span class="w"> </span>        Custom pretty output for the IPython console
<span class="w"> </span>        https://ipython.readthedocs.io/en/stable/api/generated/IPython.lib.pretty.html#extending  # noqa: E501
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        class_name = self.__class__.__name__</span>
<span class="gi">+        if cycle:</span>
<span class="gi">+            builder.text(f&#39;{class_name}(...)&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            with builder.group(4, f&#39;{class_name}(&#39;, &#39;)&#39;):</span>
<span class="gi">+                for idx, (key, value) in enumerate(self.__dict__.items()):</span>
<span class="gi">+                    if idx:</span>
<span class="gi">+                        builder.text(&#39;,&#39;)</span>
<span class="gi">+                        builder.breakable()</span>
<span class="gi">+                    builder.pretty(key)</span>
<span class="gi">+                    builder.text(&#39;: &#39;)</span>
<span class="gi">+                    builder.pretty(value)</span>


<span class="w"> </span>class MutableAttributeDict(MutableMapping[TKey, TValue],
<span class="gu">@@ -83,7 +94,14 @@ def tupleize_lists_nested(d: Mapping[TKey, TValue]) -&gt;AttributeDict[TKey,</span>
<span class="w"> </span>    This method converts lists to tuples, rendering them hashable.
<span class="w"> </span>    Other unhashable types found will raise a TypeError
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _tupleize_lists(item: Any) -&gt; Any:</span>
<span class="gi">+        if isinstance(item, list):</span>
<span class="gi">+            return tuple(_tupleize_lists(i) for i in item)</span>
<span class="gi">+        elif isinstance(item, dict):</span>
<span class="gi">+            return {k: _tupleize_lists(v) for k, v in item.items()}</span>
<span class="gi">+        return item</span>
<span class="gi">+</span>
<span class="gi">+    return AttributeDict({k: _tupleize_lists(v) for k, v in d.items()})</span>


<span class="w"> </span>class NamedElementOnion(Mapping[TKey, TValue]):
<span class="gu">@@ -111,7 +129,16 @@ class NamedElementOnion(Mapping[TKey, TValue]):</span>
<span class="w"> </span>        or at the outermost layer. Note that inserting to the outermost is equivalent
<span class="w"> </span>        to calling :meth:`add` .
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if layer is None:</span>
<span class="gi">+            # Insert at the outermost layer (equivalent to add)</span>
<span class="gi">+            self.add(element, name)</span>
<span class="gi">+        elif layer == 0:</span>
<span class="gi">+            # Insert at the innermost layer</span>
<span class="gi">+            if name is None:</span>
<span class="gi">+                name = element.__name__ if hasattr(element, &#39;__name__&#39;) else str(element)</span>
<span class="gi">+            self._queue[name] = element</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Only layer=None (outermost) or layer=0 (innermost) are supported&quot;)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def middlewares(self) -&gt;Sequence[Any]:
<span class="gu">@@ -119,7 +146,7 @@ class NamedElementOnion(Mapping[TKey, TValue]):</span>
<span class="w"> </span>        Returns middlewares in the appropriate order to be imported into a new Web3
<span class="w"> </span>        instance (reversed _queue order) as a list of (middleware, name) tuples.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [(middleware, name) for name, middleware in reversed(self._queue.items())]</span>

<span class="w"> </span>    def __iter__(self) -&gt;Iterator[TKey]:
<span class="w"> </span>        elements = self._queue.values()
<span class="gh">diff --git a/web3/eth/async_eth.py b/web3/eth/async_eth.py</span>
<span class="gh">index a6135aed..a951d81d 100644</span>
<span class="gd">--- a/web3/eth/async_eth.py</span>
<span class="gi">+++ b/web3/eth/async_eth.py</span>
<span class="gu">@@ -16,6 +16,7 @@ from web3.exceptions import MethodUnavailable, OffchainLookup, TimeExhausted, To</span>
<span class="w"> </span>from web3.method import Method, default_root_munger
<span class="w"> </span>from web3.providers import PersistentConnectionProvider
<span class="w"> </span>from web3.types import ENS, BlockData, BlockIdentifier, BlockParams, CallOverride, CreateAccessListResponse, FeeHistory, FilterParams, LogReceipt, LogsSubscriptionArg, Nonce, SignedTx, SubscriptionType, SyncStatus, TxData, TxParams, TxReceipt, Wei, _Hash32
<span class="gi">+from web3._utils.fee_utils import async_fee_history_priority_fee</span>
<span class="w"> </span>from web3.utils import async_handle_offchain_lookup
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from web3 import AsyncWeb3
<span class="gu">@@ -42,13 +43,31 @@ class AsyncEth(BaseEth):</span>
<span class="w"> </span>        eth_maxPriorityFeePerGas, is_property=True)

<span class="w"> </span>    @property
<span class="gd">-    async def max_priority_fee(self) -&gt;Wei:</span>
<span class="gi">+    async def max_priority_fee(self) -&gt; Wei:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Try to use eth_maxPriorityFeePerGas but, since this is not part
<span class="w"> </span>        of the spec and is only supported by some clients, fall back to
<span class="w"> </span>        an eth_feeHistory calculation with min and max caps.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return await self._max_priority_fee()</span>
<span class="gi">+        except (ValueError, MethodUnavailable):</span>
<span class="gi">+            return await self._suggest_max_priority_fee()</span>
<span class="gi">+</span>
<span class="gi">+    async def _suggest_max_priority_fee(self) -&gt; Wei:</span>
<span class="gi">+        # Use fee history to estimate priority fee</span>
<span class="gi">+        fee_history = await self._fee_history(10, &#39;latest&#39;, [10])</span>
<span class="gi">+        latest_block = await self.get_block(&#39;latest&#39;)</span>
<span class="gi">+        base_fee = latest_block[&#39;baseFeePerGas&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate priority fee based on fee history</span>
<span class="gi">+        priority_fee = await async_fee_history_priority_fee(fee_history)</span>
<span class="gi">+</span>
<span class="gi">+        # Apply min and max caps</span>
<span class="gi">+        min_priority_fee = Wei(1_000_000_000)  # 1 gwei</span>
<span class="gi">+        max_priority_fee = Wei(2_000_000_000)  # 2 gwei</span>
<span class="gi">+        </span>
<span class="gi">+        return Wei(max(min(priority_fee, max_priority_fee), min_priority_fee))</span>
<span class="w"> </span>    _mining: Method[Callable[[], Awaitable[bool]]] = Method(RPC.eth_mining,
<span class="w"> </span>        is_property=True)
<span class="w"> </span>    _syncing: Method[Callable[[], Awaitable[Union[SyncStatus, bool]]]
<span class="gh">diff --git a/web3/eth/eth.py b/web3/eth/eth.py</span>
<span class="gh">index 3469bcec..379b5d81 100644</span>
<span class="gd">--- a/web3/eth/eth.py</span>
<span class="gi">+++ b/web3/eth/eth.py</span>
<span class="gu">@@ -38,13 +38,28 @@ class Eth(BaseEth):</span>
<span class="w"> </span>        eth_maxPriorityFeePerGas, is_property=True)

<span class="w"> </span>    @property
<span class="gd">-    def max_priority_fee(self) -&gt;Wei:</span>
<span class="gi">+    def max_priority_fee(self) -&gt; Wei:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Try to use eth_maxPriorityFeePerGas but, since this is not part
<span class="w"> </span>        of the spec and is only supported by some clients, fall back to
<span class="w"> </span>        an eth_feeHistory calculation with min and max caps.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._max_priority_fee()</span>
<span class="gi">+        except (ValueError, MethodUnavailable):</span>
<span class="gi">+            # If eth_maxPriorityFeePerGas is not available, fall back to fee history calculation</span>
<span class="gi">+            block_count = 10</span>
<span class="gi">+            latest_block = self.get_block_number()</span>
<span class="gi">+            fee_history = self._fee_history(block_count, latest_block, [10])</span>
<span class="gi">+            </span>
<span class="gi">+            priority_fees = [int(fee[0], 16) for fee in fee_history[&#39;reward&#39;]]</span>
<span class="gi">+            average_priority_fee = sum(priority_fees) // len(priority_fees)</span>
<span class="gi">+            </span>
<span class="gi">+            # Apply min and max caps (you may want to adjust these values)</span>
<span class="gi">+            min_priority_fee = Wei(1_000_000_000)  # 1 Gwei</span>
<span class="gi">+            max_priority_fee = Wei(100_000_000_000)  # 100 Gwei</span>
<span class="gi">+            </span>
<span class="gi">+            return Wei(max(min_priority_fee, min(average_priority_fee, max_priority_fee)))</span>
<span class="w"> </span>    _mining: Method[Callable[[], bool]] = Method(RPC.eth_mining,
<span class="w"> </span>        is_property=True)
<span class="w"> </span>    _syncing: Method[Callable[[], Union[SyncStatus, bool]]] = Method(RPC.
<span class="gh">diff --git a/web3/gas_strategies/rpc.py b/web3/gas_strategies/rpc.py</span>
<span class="gh">index e4bf92f5..d2b891d1 100644</span>
<span class="gd">--- a/web3/gas_strategies/rpc.py</span>
<span class="gi">+++ b/web3/gas_strategies/rpc.py</span>
<span class="gu">@@ -3,9 +3,8 @@ from web3 import Web3</span>
<span class="w"> </span>from web3.types import TxParams, Wei


<span class="gd">-def rpc_gas_price_strategy(w3: Web3, transaction_params: Optional[TxParams]</span>
<span class="gd">-    =None) -&gt;Wei:</span>
<span class="gi">+def rpc_gas_price_strategy(w3: Web3, transaction_params: Optional[TxParams] = None) -&gt; Wei:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    A simple gas price strategy deriving it&#39;s value from the eth_gasPrice JSON-RPC call.</span>
<span class="gi">+    A simple gas price strategy deriving its value from the eth_gasPrice JSON-RPC call.</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return w3.eth.gas_price</span>
<span class="gh">diff --git a/web3/gas_strategies/time_based.py b/web3/gas_strategies/time_based.py</span>
<span class="gh">index 653c12e4..3865d45a 100644</span>
<span class="gd">--- a/web3/gas_strategies/time_based.py</span>
<span class="gi">+++ b/web3/gas_strategies/time_based.py</span>
<span class="gu">@@ -22,7 +22,11 @@ def _compute_probabilities(miner_data: Iterable[MinerData], wait_blocks:</span>
<span class="w"> </span>    Computes the probabilities that a txn will be accepted at each of the gas
<span class="w"> </span>    prices accepted by the miners.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    miner_data = sorted(miner_data, key=operator.attrgetter(&#39;min_gas_price&#39;))</span>
<span class="gi">+    for idx, data in enumerate(miner_data):</span>
<span class="gi">+        num_blocks_accepting = sum(m.num_blocks for m in miner_data[idx:])</span>
<span class="gi">+        probability = float(min(num_blocks_accepting, wait_blocks)) / float(sample_size)</span>
<span class="gi">+        yield Probability(data.min_gas_price, probability)</span>


<span class="w"> </span>def _compute_gas_price(probabilities: Sequence[Probability],
<span class="gu">@@ -37,7 +41,15 @@ def _compute_gas_price(probabilities: Sequence[Probability],</span>
<span class="w"> </span>    :param desired_probability: An floating point representation of the desired
<span class="w"> </span>        probability. (e.g. ``85% -&gt; 0.85``)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for left, right in sliding_window(2, probabilities):</span>
<span class="gi">+        if desired_probability &lt;= right.prob:</span>
<span class="gi">+            return Wei(int(left.gas_price))</span>
<span class="gi">+        elif right.prob &lt; desired_probability &lt; left.prob:</span>
<span class="gi">+            prob_range = left.prob - right.prob</span>
<span class="gi">+            price_range = left.gas_price - right.gas_price</span>
<span class="gi">+            prob_delta = desired_probability - right.prob</span>
<span class="gi">+            return Wei(int(right.gas_price + (prob_delta * price_range / prob_range)))</span>
<span class="gi">+    return Wei(int(probabilities[-1].gas_price))</span>


<span class="w"> </span>@curry
<span class="gu">@@ -57,7 +69,73 @@ def construct_time_based_gas_price_strategy(max_wait_seconds: int,</span>
<span class="w"> </span>        that the transaction will be mined within ``max_wait_seconds``.  0 means 0%
<span class="w"> </span>        and 100 means 100%.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def time_based_gas_price_strategy(web3: Web3, transaction_params: TxParams) -&gt; Wei:</span>
<span class="gi">+        if probability &lt; 0 or probability &gt; 100:</span>
<span class="gi">+            raise Web3ValidationError(</span>
<span class="gi">+                &quot;The `probability` value must be a number between 0 and 100&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if sample_size &lt; 2:</span>
<span class="gi">+            raise Web3ValidationError(</span>
<span class="gi">+                &quot;The `sample_size` value must be at least 2&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        latest_block = web3.eth.get_block(&#39;latest&#39;)</span>
<span class="gi">+        latest_block_number = latest_block[&#39;number&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        max_wait_blocks = int(math.ceil(max_wait_seconds / 15))</span>
<span class="gi">+        block_num = max(1, latest_block_number - sample_size)</span>
<span class="gi">+</span>
<span class="gi">+        weighted_blocks = []</span>
<span class="gi">+        for block_number in range(block_num, latest_block_number + 1):</span>
<span class="gi">+            block = web3.eth.get_block(BlockNumber(block_number))</span>
<span class="gi">+            if weighted:</span>
<span class="gi">+                weight = (block_number - block_num + 1) / sample_size</span>
<span class="gi">+            else:</span>
<span class="gi">+                weight = 1</span>
<span class="gi">+</span>
<span class="gi">+            weighted_blocks.append((block, weight))</span>
<span class="gi">+</span>
<span class="gi">+        min_price = min(block[&#39;baseFeePerGas&#39;] for block, _ in weighted_blocks)</span>
<span class="gi">+</span>
<span class="gi">+        miner_data = groupby(</span>
<span class="gi">+            operator.attrgetter(&#39;miner&#39;),</span>
<span class="gi">+            MinerData(</span>
<span class="gi">+                block[&#39;miner&#39;],</span>
<span class="gi">+                weight,</span>
<span class="gi">+                min_price,</span>
<span class="gi">+                percentile(block[&#39;baseFeePerGas&#39;], 10)</span>
<span class="gi">+            ) for block, weight in weighted_blocks</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        miner_data = [</span>
<span class="gi">+            MinerData(</span>
<span class="gi">+                miner=miner,</span>
<span class="gi">+                num_blocks=sum(m.num_blocks for m in data),</span>
<span class="gi">+                min_gas_price=min(m.min_gas_price for m in data),</span>
<span class="gi">+                low_percentile_gas_price=min(m.low_percentile_gas_price for m in data),</span>
<span class="gi">+            )</span>
<span class="gi">+            for miner, data</span>
<span class="gi">+            in miner_data.items()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        raw_probabilities = _compute_probabilities(</span>
<span class="gi">+            miner_data,</span>
<span class="gi">+            wait_blocks=max_wait_blocks,</span>
<span class="gi">+            sample_size=sample_size,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        probabilities = tuple(sorted(</span>
<span class="gi">+            raw_probabilities,</span>
<span class="gi">+            key=operator.attrgetter(&#39;gas_price&#39;),</span>
<span class="gi">+            reverse=True,</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+        gas_price = _compute_gas_price(probabilities, probability / 100)</span>
<span class="gi">+</span>
<span class="gi">+        return gas_price</span>
<span class="gi">+</span>
<span class="gi">+    return time_based_gas_price_strategy</span>


<span class="w"> </span>fast_gas_price_strategy = construct_time_based_gas_price_strategy(
<span class="gh">diff --git a/web3/geth.py b/web3/geth.py</span>
<span class="gh">index 308930d9..08248b7a 100644</span>
<span class="gd">--- a/web3/geth.py</span>
<span class="gi">+++ b/web3/geth.py</span>
<span class="gu">@@ -138,6 +138,19 @@ class AsyncGethTxPool(Module):</span>
<span class="w"> </span>    https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-txpool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    is_async = True
<span class="gi">+    </span>
<span class="gi">+    @property</span>
<span class="gi">+    async def content(self) -&gt; TxPoolContent:</span>
<span class="gi">+        return await self._content()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def inspect(self) -&gt; TxPoolInspect:</span>
<span class="gi">+        return await self._inspect()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def status(self) -&gt; TxPoolStatus:</span>
<span class="gi">+        return await self._status()</span>
<span class="gi">+</span>
<span class="w"> </span>    _content: Method[Callable[[], Awaitable[TxPoolContent]]] = Method(RPC.
<span class="w"> </span>        txpool_content, is_property=True)
<span class="w"> </span>    _inspect: Method[Callable[[], Awaitable[TxPoolInspect]]] = Method(RPC.
<span class="gu">@@ -151,6 +164,36 @@ class AsyncGethAdmin(Module):</span>
<span class="w"> </span>    https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-admin
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    is_async = True
<span class="gi">+</span>
<span class="gi">+    async def add_peer(self, enode: EnodeURI) -&gt; bool:</span>
<span class="gi">+        return await self._add_peer(enode)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def datadir(self) -&gt; str:</span>
<span class="gi">+        return await self._datadir()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def node_info(self) -&gt; NodeInfo:</span>
<span class="gi">+        return await self._node_info()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def peers(self) -&gt; List[Peer]:</span>
<span class="gi">+        return await self._peers()</span>
<span class="gi">+</span>
<span class="gi">+    async def start_http(self, host: str = &#39;localhost&#39;, port: int = 8545,</span>
<span class="gi">+                         cors: str = &#39;&#39;, apis: str = &#39;eth,net,web3&#39;) -&gt; bool:</span>
<span class="gi">+        return await self._start_http(host, port, cors, apis)</span>
<span class="gi">+</span>
<span class="gi">+    async def stop_http(self) -&gt; bool:</span>
<span class="gi">+        return await self._stop_http()</span>
<span class="gi">+</span>
<span class="gi">+    async def start_ws(self, host: str = &#39;localhost&#39;, port: int = 8546,</span>
<span class="gi">+                       cors: str = &#39;&#39;, apis: str = &#39;eth,net,web3&#39;) -&gt; bool:</span>
<span class="gi">+        return await self._start_ws(host, port, cors, apis)</span>
<span class="gi">+</span>
<span class="gi">+    async def stop_ws(self) -&gt; bool:</span>
<span class="gi">+        return await self._stop_ws()</span>
<span class="gi">+</span>
<span class="w"> </span>    _add_peer: Method[Callable[[EnodeURI], Awaitable[bool]]] = Method(RPC.
<span class="w"> </span>        admin_addPeer, mungers=[default_root_munger])
<span class="w"> </span>    _datadir: Method[Callable[[], Awaitable[str]]] = Method(RPC.
<span class="gu">@@ -174,6 +217,39 @@ class AsyncGethPersonal(Module):</span>
<span class="w"> </span>    https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-personal
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    is_async = True
<span class="gi">+</span>
<span class="gi">+    async def ec_recover(self, message: str, signature: HexStr) -&gt; ChecksumAddress:</span>
<span class="gi">+        return await self._ec_recover(message, signature)</span>
<span class="gi">+</span>
<span class="gi">+    async def import_raw_key(self, private_key: str, passphrase: str) -&gt; ChecksumAddress:</span>
<span class="gi">+        return await self._import_raw_key(private_key, passphrase)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def list_accounts(self) -&gt; List[ChecksumAddress]:</span>
<span class="gi">+        return await self._list_accounts()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    async def list_wallets(self) -&gt; List[GethWallet]:</span>
<span class="gi">+        return await self._list_wallets()</span>
<span class="gi">+</span>
<span class="gi">+    async def send_transaction(self, transaction: TxParams, passphrase: str) -&gt; HexBytes:</span>
<span class="gi">+        return await self._send_transaction(transaction, passphrase)</span>
<span class="gi">+</span>
<span class="gi">+    async def sign(self, message: str, account: ChecksumAddress, password: Optional[str] = None) -&gt; HexStr:</span>
<span class="gi">+        return await self._sign(message, account, password)</span>
<span class="gi">+</span>
<span class="gi">+    async def sign_typed_data(self, jsonMessage: Dict[str, Any], account: ChecksumAddress, password: str) -&gt; HexStr:</span>
<span class="gi">+        return await self._sign_typed_data(jsonMessage, account, password)</span>
<span class="gi">+</span>
<span class="gi">+    async def new_account(self, password: str) -&gt; ChecksumAddress:</span>
<span class="gi">+        return await self._new_account(password)</span>
<span class="gi">+</span>
<span class="gi">+    async def lock_account(self, account: ChecksumAddress) -&gt; bool:</span>
<span class="gi">+        return await self._lock_account(account)</span>
<span class="gi">+</span>
<span class="gi">+    async def unlock_account(self, account: ChecksumAddress, passphrase: str, duration: Optional[int] = None) -&gt; bool:</span>
<span class="gi">+        return await self._unlock_account(account, passphrase, duration)</span>
<span class="gi">+</span>
<span class="w"> </span>    _ec_recover: Method[Callable[[str, HexStr], Awaitable[ChecksumAddress]]
<span class="w"> </span>        ] = Method(RPC.personal_ecRecover, mungers=[default_root_munger])
<span class="w"> </span>    _import_raw_key: Method[Callable[[str, str], Awaitable[ChecksumAddress]]
<span class="gh">diff --git a/web3/main.py b/web3/main.py</span>
<span class="gh">index f7375874..6a790045 100644</span>
<span class="gd">--- a/web3/main.py</span>
<span class="gi">+++ b/web3/main.py</span>
<span class="gu">@@ -59,14 +59,32 @@ class BaseWeb3:</span>
<span class="w"> </span>        Takes list of abi_types as inputs -- `[uint24, int8[], bool]`
<span class="w"> </span>        and list of corresponding values  -- `[20, [-1, 5, 0], True]`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(abi_types) != len(values):</span>
<span class="gi">+            raise ValueError(&quot;Length mismatch between abi_types and values&quot;)</span>
<span class="gi">+        hex_data = add_0x_prefix(&#39;&#39;.join(</span>
<span class="gi">+            remove_0x_prefix(hex_encode_abi_type(abi_type, value))</span>
<span class="gi">+            for abi_type, value in zip(abi_types, values)</span>
<span class="gi">+        ))</span>
<span class="gi">+        return eth_utils_keccak(hexstr=hex_data)</span>

<span class="w"> </span>    def attach_modules(self, modules: Optional[Dict[str, Union[Type[Module],
<span class="w"> </span>        Sequence[Any]]]]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Attach modules to the `Web3` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if modules is not None:</span>
<span class="gi">+            for module_name, module_info in modules.items():</span>
<span class="gi">+                if isinstance(module_info, Sequence):</span>
<span class="gi">+                    if len(module_info) == 2:</span>
<span class="gi">+                        module_class, module_args = module_info</span>
<span class="gi">+                        _attach_modules(self, ((module_name, module_class(*module_args)),))</span>
<span class="gi">+                    elif len(module_info) == 1:</span>
<span class="gi">+                        module_class = module_info[0]</span>
<span class="gi">+                        _attach_modules(self, ((module_name, module_class(self)),))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise ValueError(&quot;Module sequence must have 1 or 2 elements&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    _attach_modules(self, ((module_name, module_info(self)),))</span>


<span class="w"> </span>class Web3(BaseWeb3):
<span class="gu">@@ -118,7 +136,7 @@ class AsyncWeb3(BaseWeb3):</span>
<span class="w"> </span>        Establish a persistent connection via websockets to a websocket provider using
<span class="w"> </span>        a ``PersistentConnectionProvider`` instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _PersistentConnectionWeb3(provider, middlewares, modules, external_modules, ens)</span>


<span class="w"> </span>class _PersistentConnectionWeb3(AsyncWeb3):
<span class="gh">diff --git a/web3/manager.py b/web3/manager.py</span>
<span class="gh">index b3a25415..af5f5f1e 100644</span>
<span class="gd">--- a/web3/manager.py</span>
<span class="gi">+++ b/web3/manager.py</span>
<span class="gu">@@ -52,7 +52,14 @@ class RequestManager:</span>
<span class="w"> </span>        Leaving w3 unspecified will prevent the middleware from resolving names.
<span class="w"> </span>        Documentation should remain in sync with these defaults.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [</span>
<span class="gi">+            (gas_price_strategy_middleware, &#39;gas_price_strategy&#39;),</span>
<span class="gi">+            (name_to_address_middleware(w3), &#39;name_to_address&#39;),</span>
<span class="gi">+            (attrdict_middleware, &#39;attrdict&#39;),</span>
<span class="gi">+            (validation_middleware, &#39;validation&#39;),</span>
<span class="gi">+            (abi_middleware, &#39;abi&#39;),</span>
<span class="gi">+            (buffered_gas_estimate_middleware, &#39;gas_estimate&#39;),</span>
<span class="gi">+        ]</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def async_default_middlewares() -&gt;List[Tuple[AsyncMiddleware, str]]:
<span class="gu">@@ -60,7 +67,13 @@ class RequestManager:</span>
<span class="w"> </span>        List the default async middlewares for the request manager.
<span class="w"> </span>        Documentation should remain in sync with these defaults.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [</span>
<span class="gi">+            (async_gas_price_strategy_middleware, &#39;gas_price_strategy&#39;),</span>
<span class="gi">+            (async_name_to_address_middleware, &#39;name_to_address&#39;),</span>
<span class="gi">+            (async_attrdict_middleware, &#39;attrdict&#39;),</span>
<span class="gi">+            (async_validation_middleware, &#39;validation&#39;),</span>
<span class="gi">+            (async_buffered_gas_estimate_middleware, &#39;gas_estimate&#39;),</span>
<span class="gi">+        ]</span>

<span class="w"> </span>    def request_blocking(self, method: Union[RPCEndpoint, Callable[...,
<span class="w"> </span>        RPCEndpoint]], params: Any, error_formatters: Optional[Callable[...,
<span class="gu">@@ -69,7 +82,31 @@ class RequestManager:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Make a synchronous request using the provider
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        response = self._make_request(method, params)</span>
<span class="gi">+        return self._process_response(response, error_formatters, null_result_formatters)</span>
<span class="gi">+</span>
<span class="gi">+    def _make_request(self, method: Union[RPCEndpoint, Callable[..., RPCEndpoint]], params: Any) -&gt;RPCResponse:</span>
<span class="gi">+        if callable(method):</span>
<span class="gi">+            method = method(params)</span>
<span class="gi">+        middleware = self.middleware_onion.wrap(self.provider.make_request)</span>
<span class="gi">+        return middleware(method, params)</span>
<span class="gi">+</span>
<span class="gi">+    def _process_response(self, response: RPCResponse, error_formatters: Optional[Callable[..., Any]],</span>
<span class="gi">+                          null_result_formatters: Optional[Callable[..., Any]]) -&gt;Any:</span>
<span class="gi">+        if &quot;error&quot; in response:</span>
<span class="gi">+            apply_error_formatters = error_formatters or (lambda x: x)</span>
<span class="gi">+            formatted_error = apply_error_formatters(response[&quot;error&quot;])</span>
<span class="gi">+            raise ValueError(formatted_error)</span>
<span class="gi">+        elif &quot;result&quot; in response:</span>
<span class="gi">+            result = response[&quot;result&quot;]</span>
<span class="gi">+            if result is None or result == &quot;0x&quot; or result == HexBytes(&quot;0x&quot;):</span>
<span class="gi">+                if null_result_formatters:</span>
<span class="gi">+                    return null_result_formatters(result)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return None</span>
<span class="gi">+            return result</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise BadResponseFormat(&quot;The response was in an unexpected format and unable to be parsed&quot;)</span>

<span class="w"> </span>    async def coro_request(self, method: Union[RPCEndpoint, Callable[...,
<span class="w"> </span>        RPCEndpoint]], params: Any, error_formatters: Optional[Callable[...,
<span class="gu">@@ -78,7 +115,14 @@ class RequestManager:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Coroutine for making a request using the provider
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        response = await self._make_async_request(method, params)</span>
<span class="gi">+        return self._process_response(response, error_formatters, null_result_formatters)</span>
<span class="gi">+</span>
<span class="gi">+    async def _make_async_request(self, method: Union[RPCEndpoint, Callable[..., RPCEndpoint]], params: Any) -&gt;RPCResponse:</span>
<span class="gi">+        if callable(method):</span>
<span class="gi">+            method = method(params)</span>
<span class="gi">+        middleware = self.middleware_onion.wrap(self.provider.request)</span>
<span class="gi">+        return await middleware(method, params)</span>


<span class="w"> </span>class _AsyncPersistentMessageStream:
<span class="gh">diff --git a/web3/method.py b/web3/method.py</span>
<span class="gh">index 145212b3..28efed3e 100644</span>
<span class="gd">--- a/web3/method.py</span>
<span class="gi">+++ b/web3/method.py</span>
<span class="gu">@@ -78,10 +78,16 @@ class Method(Generic[TFunc]):</span>
<span class="w"> </span>        return obj.retrieve_caller_fn(self)

<span class="w"> </span>    @property
<span class="gd">-    def method_selector_fn(self) -&gt;Callable[..., Union[RPCEndpoint,</span>
<span class="gd">-        Callable[..., RPCEndpoint]]]:</span>
<span class="gi">+    def method_selector_fn(self) -&gt; Callable[..., Union[RPCEndpoint, Callable[..., RPCEndpoint]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Gets the method selector from the config.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if callable(self.json_rpc_method):</span>
<span class="gi">+            return self.json_rpc_method</span>
<span class="gi">+        elif isinstance(self.json_rpc_method, str):</span>
<span class="gi">+            return lambda *_: self.json_rpc_method</span>
<span class="gi">+        elif self.method_choice_depends_on_args:</span>
<span class="gi">+            return self.method_choice_depends_on_args</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;Unable to determine method selector&quot;)</span>


<span class="w"> </span>class DeprecatedMethod:
<span class="gh">diff --git a/web3/middleware/async_cache.py b/web3/middleware/async_cache.py</span>
<span class="gh">index f8eb024c..6f249759 100644</span>
<span class="gd">--- a/web3/middleware/async_cache.py</span>
<span class="gi">+++ b/web3/middleware/async_cache.py</span>
<span class="gu">@@ -25,4 +25,27 @@ async def async_construct_simple_cache_middleware(cache: SimpleCache=None,</span>
<span class="w"> </span>        ``response`` and returns a boolean as to whether the response should be
<span class="w"> </span>        cached.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cache is None:</span>
<span class="gi">+        cache = SimpleCache(256)</span>
<span class="gi">+</span>
<span class="gi">+    async def async_middleware(make_request: Callable[[RPCEndpoint, Any], Any], w3: &quot;AsyncWeb3&quot;) -&gt; AsyncMiddlewareCoroutine:</span>
<span class="gi">+        async def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method in rpc_whitelist:</span>
<span class="gi">+                cache_key = generate_cache_key((method, params))</span>
<span class="gi">+                cached_response = cache.get(cache_key)</span>
<span class="gi">+                if cached_response is not None:</span>
<span class="gi">+                    return cached_response</span>
<span class="gi">+</span>
<span class="gi">+                response = await make_request(method, params)</span>
<span class="gi">+</span>
<span class="gi">+                if should_cache_fn(method, params, response):</span>
<span class="gi">+                    async with async_lock():</span>
<span class="gi">+                        cache.cache(cache_key, response)</span>
<span class="gi">+</span>
<span class="gi">+                return response</span>
<span class="gi">+            else:</span>
<span class="gi">+                return await make_request(method, params)</span>
<span class="gi">+</span>
<span class="gi">+        return middleware</span>
<span class="gi">+</span>
<span class="gi">+    return async_middleware</span>
<span class="gh">diff --git a/web3/middleware/attrdict.py b/web3/middleware/attrdict.py</span>
<span class="gh">index 06cd32d9..56add109 100644</span>
<span class="gd">--- a/web3/middleware/attrdict.py</span>
<span class="gi">+++ b/web3/middleware/attrdict.py</span>
<span class="gu">@@ -15,7 +15,13 @@ def attrdict_middleware(make_request: Callable[[RPCEndpoint, Any], Any],</span>
<span class="w"> </span>    Note: Accessing `AttributeDict` properties via attribute
<span class="w"> </span>        (e.g. my_attribute_dict.property1) will not preserve typing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+        response = make_request(method, params)</span>
<span class="gi">+        if &#39;result&#39; in response and isinstance(response[&#39;result&#39;], dict):</span>
<span class="gi">+            response = assoc(response, &#39;result&#39;, AttributeDict.recursive(response[&#39;result&#39;]))</span>
<span class="gi">+        return cast(RPCResponse, response)</span>
<span class="gi">+    </span>
<span class="gi">+    return middleware</span>


<span class="w"> </span>async def async_attrdict_middleware(make_request: Callable[[RPCEndpoint,
<span class="gu">@@ -26,4 +32,10 @@ async def async_attrdict_middleware(make_request: Callable[[RPCEndpoint,</span>
<span class="w"> </span>    Note: Accessing `AttributeDict` properties via attribute
<span class="w"> </span>        (e.g. my_attribute_dict.property1) will not preserve typing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    async def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+        response = await make_request(method, params)</span>
<span class="gi">+        if &#39;result&#39; in response and isinstance(response[&#39;result&#39;], dict):</span>
<span class="gi">+            response = assoc(response, &#39;result&#39;, AttributeDict.recursive(response[&#39;result&#39;]))</span>
<span class="gi">+        return cast(RPCResponse, response)</span>
<span class="gi">+    </span>
<span class="gi">+    return middleware</span>
<span class="gh">diff --git a/web3/middleware/cache.py b/web3/middleware/cache.py</span>
<span class="gh">index 18c93307..571fc1ac 100644</span>
<span class="gd">--- a/web3/middleware/cache.py</span>
<span class="gi">+++ b/web3/middleware/cache.py</span>
<span class="gu">@@ -32,7 +32,26 @@ def construct_simple_cache_middleware(cache: SimpleCache=None,</span>
<span class="w"> </span>        ``response`` and returns a boolean as to whether the response should be
<span class="w"> </span>        cached.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cache is None:</span>
<span class="gi">+        cache = SimpleCache()</span>
<span class="gi">+    if rpc_whitelist is None:</span>
<span class="gi">+        rpc_whitelist = SIMPLE_CACHE_RPC_WHITELIST</span>
<span class="gi">+</span>
<span class="gi">+    def middleware(make_request: Callable[[RPCEndpoint, Any], RPCResponse], w3: &quot;Web3&quot;) -&gt; Callable[[RPCEndpoint, Any], RPCResponse]:</span>
<span class="gi">+        def middleware_fn(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method in rpc_whitelist:</span>
<span class="gi">+                cache_key = generate_cache_key((method, params))</span>
<span class="gi">+                if cache_key in cache:</span>
<span class="gi">+                    return cache[cache_key]</span>
<span class="gi">+</span>
<span class="gi">+                response = make_request(method, params)</span>
<span class="gi">+                if should_cache_fn(method, params, response):</span>
<span class="gi">+                    cache[cache_key] = response</span>
<span class="gi">+                return response</span>
<span class="gi">+            else:</span>
<span class="gi">+                return make_request(method, params)</span>
<span class="gi">+        return middleware_fn</span>
<span class="gi">+    return middleware</span>


<span class="w"> </span>_simple_cache_middleware = construct_simple_cache_middleware()
<span class="gu">@@ -57,7 +76,25 @@ def construct_time_based_cache_middleware(cache_class: Callable[..., Dict[</span>
<span class="w"> </span>        ``response`` and returns a boolean as to whether the response should be
<span class="w"> </span>        cached.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cache = cache_class()</span>
<span class="gi">+</span>
<span class="gi">+    def middleware(make_request: Callable[[RPCEndpoint, Any], RPCResponse], w3: &quot;Web3&quot;) -&gt; Callable[[RPCEndpoint, Any], RPCResponse]:</span>
<span class="gi">+        def middleware_fn(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method in rpc_whitelist:</span>
<span class="gi">+                cache_key = generate_cache_key((method, params))</span>
<span class="gi">+                if cache_key in cache:</span>
<span class="gi">+                    cached_response, timestamp = cache[cache_key]</span>
<span class="gi">+                    if time.time() - timestamp &lt;= cache_expire_seconds:</span>
<span class="gi">+                        return cached_response</span>
<span class="gi">+</span>
<span class="gi">+                response = make_request(method, params)</span>
<span class="gi">+                if should_cache_fn(method, params, response):</span>
<span class="gi">+                    cache[cache_key] = (response, time.time())</span>
<span class="gi">+                return response</span>
<span class="gi">+            else:</span>
<span class="gi">+                return make_request(method, params)</span>
<span class="gi">+        return middleware_fn</span>
<span class="gi">+    return middleware</span>


<span class="w"> </span>_time_based_cache_middleware = construct_time_based_cache_middleware(
<span class="gu">@@ -103,7 +140,52 @@ def construct_latest_block_based_cache_middleware(cache_class: Callable[...,</span>
<span class="w"> </span>        a new block when the last seen latest block is older than the average
<span class="w"> </span>        block time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cache = cache_class()</span>
<span class="gi">+    block_info: BlockInfoCache = {}</span>
<span class="gi">+</span>
<span class="gi">+    def middleware(make_request: Callable[[RPCEndpoint, Any], RPCResponse], w3: &quot;Web3&quot;) -&gt; Callable[[RPCEndpoint, Any], RPCResponse]:</span>
<span class="gi">+        def middleware_fn(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method in rpc_whitelist:</span>
<span class="gi">+                if &quot;latest_block&quot; not in block_info:</span>
<span class="gi">+                    _update_block_info_cache(make_request, block_info)</span>
<span class="gi">+                elif time.time() - block_info[&quot;avg_block_time_updated_at&quot;] &gt; block_info[&quot;avg_block_time&quot;]:</span>
<span class="gi">+                    _update_block_info_cache(make_request, block_info)</span>
<span class="gi">+</span>
<span class="gi">+                latest_block = block_info[&quot;latest_block&quot;]</span>
<span class="gi">+                cache_key = generate_cache_key((method, params, latest_block[&quot;hash&quot;]))</span>
<span class="gi">+                </span>
<span class="gi">+                if cache_key in cache:</span>
<span class="gi">+                    return cache[cache_key]</span>
<span class="gi">+</span>
<span class="gi">+                response = make_request(method, params)</span>
<span class="gi">+                if should_cache_fn(method, params, response):</span>
<span class="gi">+                    cache[cache_key] = response</span>
<span class="gi">+                return response</span>
<span class="gi">+            else:</span>
<span class="gi">+                return make_request(method, params)</span>
<span class="gi">+        return middleware_fn</span>
<span class="gi">+</span>
<span class="gi">+    def _update_block_info_cache(make_request: Callable[[RPCEndpoint, Any], RPCResponse], block_info: BlockInfoCache) -&gt; None:</span>
<span class="gi">+        latest_block = make_request(&quot;eth_getBlockByNumber&quot;, [&quot;latest&quot;, False])</span>
<span class="gi">+        if &quot;latest_block&quot; in block_info:</span>
<span class="gi">+            prev_block_number = block_info[&quot;latest_block&quot;][&quot;number&quot;]</span>
<span class="gi">+            blocks_diff = int(latest_block[&quot;number&quot;], 16) - int(prev_block_number, 16)</span>
<span class="gi">+            if blocks_diff &gt; 0:</span>
<span class="gi">+                block_time = (int(latest_block[&quot;timestamp&quot;], 16) - int(block_info[&quot;latest_block&quot;][&quot;timestamp&quot;], 16)) / blocks_diff</span>
<span class="gi">+                if AVG_BLOCK_TIME_KEY in block_info:</span>
<span class="gi">+                    block_info[AVG_BLOCK_TIME_KEY] = (block_info[AVG_BLOCK_TIME_KEY] * block_info.get(AVG_BLOCK_SAMPLE_SIZE_KEY, 0) + block_time) / (block_info.get(AVG_BLOCK_SAMPLE_SIZE_KEY, 0) + 1)</span>
<span class="gi">+                    block_info[AVG_BLOCK_SAMPLE_SIZE_KEY] = min(block_info.get(AVG_BLOCK_SAMPLE_SIZE_KEY, 0) + 1, average_block_time_sample_size)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    block_info[AVG_BLOCK_TIME_KEY] = block_time</span>
<span class="gi">+                    block_info[AVG_BLOCK_SAMPLE_SIZE_KEY] = 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            block_info[AVG_BLOCK_TIME_KEY] = default_average_block_time</span>
<span class="gi">+            block_info[AVG_BLOCK_SAMPLE_SIZE_KEY] = 1</span>
<span class="gi">+</span>
<span class="gi">+        block_info[&quot;latest_block&quot;] = latest_block</span>
<span class="gi">+        block_info[AVG_BLOCK_TIME_UPDATED_AT_KEY] = time.time()</span>
<span class="gi">+</span>
<span class="gi">+    return middleware</span>


<span class="w"> </span>_latest_block_based_cache_middleware = (
<span class="gh">diff --git a/web3/middleware/exception_retry_request.py b/web3/middleware/exception_retry_request.py</span>
<span class="gh">index cbaf3bd0..57c37158 100644</span>
<span class="gd">--- a/web3/middleware/exception_retry_request.py</span>
<span class="gi">+++ b/web3/middleware/exception_retry_request.py</span>
<span class="gu">@@ -36,7 +36,22 @@ def exception_retry_middleware(make_request: Callable[[RPCEndpoint, Any],</span>
<span class="w"> </span>    Creates middleware that retries failed HTTP requests. Is a default
<span class="w"> </span>    middleware for HTTPProvider.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    allow_list = allow_list or DEFAULT_ALLOWLIST</span>
<span class="gi">+</span>
<span class="gi">+    def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+        if method not in allow_list:</span>
<span class="gi">+            return make_request(method, params)</span>
<span class="gi">+</span>
<span class="gi">+        for attempt in range(retries):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return make_request(method, params)</span>
<span class="gi">+            except errors as e:</span>
<span class="gi">+                if attempt == retries - 1:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                backoff = backoff_factor * (2 ** attempt)</span>
<span class="gi">+                time.sleep(backoff)</span>
<span class="gi">+</span>
<span class="gi">+    return middleware</span>


<span class="w"> </span>async def async_exception_retry_middleware(make_request: Callable[[
<span class="gu">@@ -47,4 +62,19 @@ async def async_exception_retry_middleware(make_request: Callable[[</span>
<span class="w"> </span>    Creates middleware that retries failed HTTP requests.
<span class="w"> </span>    Is a default middleware for AsyncHTTPProvider.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    allow_list = allow_list or DEFAULT_ALLOWLIST</span>
<span class="gi">+</span>
<span class="gi">+    async def middleware(method: RPCEndpoint, params: Any) -&gt; Any:</span>
<span class="gi">+        if method not in allow_list:</span>
<span class="gi">+            return await make_request(method, params)</span>
<span class="gi">+</span>
<span class="gi">+        for attempt in range(retries):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return await make_request(method, params)</span>
<span class="gi">+            except errors as e:</span>
<span class="gi">+                if attempt == retries - 1:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                backoff = backoff_factor * (2 ** attempt)</span>
<span class="gi">+                await asyncio.sleep(backoff)</span>
<span class="gi">+</span>
<span class="gi">+    return middleware</span>
<span class="gh">diff --git a/web3/middleware/filter.py b/web3/middleware/filter.py</span>
<span class="gh">index c552b7b2..68cdf4a5 100644</span>
<span class="gd">--- a/web3/middleware/filter.py</span>
<span class="gi">+++ b/web3/middleware/filter.py</span>
<span class="gu">@@ -41,7 +41,11 @@ def segment_count(start: int, stop: int, step: int=5) -&gt;Iterable[Tuple[int,</span>
<span class="w"> </span>    &gt;&gt;&gt; next(segment_counter) #  Remainder is also returned
<span class="w"> </span>    (9, 10)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current = start</span>
<span class="gi">+    while current &lt; stop:</span>
<span class="gi">+        next_segment = min(current + step, stop)</span>
<span class="gi">+        yield (current, next_segment)</span>
<span class="gi">+        current = next_segment</span>


<span class="w"> </span>def block_ranges(start_block: BlockNumber, last_block: Optional[BlockNumber
<span class="gu">@@ -51,7 +55,12 @@ def block_ranges(start_block: BlockNumber, last_block: Optional[BlockNumber</span>
<span class="w"> </span>    Ranges do not overlap to facilitate use as ``toBlock``, ``fromBlock``
<span class="w"> </span>    json-rpc arguments, which are both inclusive.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if last_block is None:</span>
<span class="gi">+        yield (start_block, None)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for from_block, to_block in segment_count(start_block, last_block + 1, step):</span>
<span class="gi">+        yield (BlockNumber(from_block), BlockNumber(to_block - 1))</span>


<span class="w"> </span>def iter_latest_block(w3: &#39;Web3&#39;, to_block: Optional[Union[BlockNumber,
<span class="gu">@@ -72,7 +81,16 @@ def iter_latest_block(w3: &#39;Web3&#39;, to_block: Optional[Union[BlockNumber,</span>
<span class="w"> </span>    10
<span class="w"> </span>    &gt;&gt;&gt; next(new_blocks)  # latest block &gt; to block
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    last_block = None</span>
<span class="gi">+    while True:</span>
<span class="gi">+        latest_block = w3.eth.block_number</span>
<span class="gi">+        if latest_block != last_block:</span>
<span class="gi">+            if to_block is not None and latest_block &gt; to_block:</span>
<span class="gi">+                return</span>
<span class="gi">+            yield latest_block</span>
<span class="gi">+            last_block = latest_block</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield None</span>


<span class="w"> </span>def iter_latest_block_ranges(w3: &#39;Web3&#39;, from_block: BlockNumber, to_block:
<span class="gu">@@ -92,7 +110,13 @@ def iter_latest_block_ranges(w3: &#39;Web3&#39;, from_block: BlockNumber, to_block:</span>
<span class="w"> </span>    &gt;&gt;&gt; next(blocks_to_filter)  # latest block number = 50
<span class="w"> </span>    (46, 50)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for latest_block in iter_latest_block(w3, to_block):</span>
<span class="gi">+        if latest_block is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield (from_block, latest_block)</span>
<span class="gi">+        from_block = latest_block + 1</span>
<span class="gi">+        if to_block is not None and latest_block &gt;= to_block:</span>
<span class="gi">+            break</span>


<span class="w"> </span>def get_logs_multipart(w3: &#39;Web3&#39;, start_block: BlockNumber, stop_block:
<span class="gu">@@ -104,7 +128,14 @@ def get_logs_multipart(w3: &#39;Web3&#39;, start_block: BlockNumber, stop_block:</span>
<span class="w"> </span>    The getLog request is partitioned into multiple calls of the max number of blocks
<span class="w"> </span>    ``max_blocks``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for from_block, to_block in block_ranges(start_block, stop_block, max_blocks):</span>
<span class="gi">+        params = {</span>
<span class="gi">+            &#39;fromBlock&#39;: from_block,</span>
<span class="gi">+            &#39;toBlock&#39;: to_block,</span>
<span class="gi">+            &#39;address&#39;: address,</span>
<span class="gi">+            &#39;topics&#39;: topics</span>
<span class="gi">+        }</span>
<span class="gi">+        yield w3.eth.get_logs(params)</span>


<span class="w"> </span>class RequestLogs:
<span class="gu">@@ -159,7 +190,16 @@ async def async_iter_latest_block(w3: &#39;Web3&#39;, to_block: Optional[Union[</span>
<span class="w"> </span>    10
<span class="w"> </span>    &gt;&gt;&gt; next(new_blocks)  # latest block &gt; to block
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    last_block = None</span>
<span class="gi">+    while True:</span>
<span class="gi">+        latest_block = await w3.eth.block_number</span>
<span class="gi">+        if latest_block != last_block:</span>
<span class="gi">+            if to_block is not None and latest_block &gt; to_block:</span>
<span class="gi">+                return</span>
<span class="gi">+            yield latest_block</span>
<span class="gi">+            last_block = latest_block</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield None</span>


<span class="w"> </span>async def async_iter_latest_block_ranges(w3: &#39;Web3&#39;, from_block:
<span class="gu">@@ -179,7 +219,13 @@ async def async_iter_latest_block_ranges(w3: &#39;Web3&#39;, from_block:</span>
<span class="w"> </span>    &gt;&gt;&gt; next(blocks_to_filter)  # latest block number = 50
<span class="w"> </span>    (46, 50)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    async for latest_block in async_iter_latest_block(w3, to_block):</span>
<span class="gi">+        if latest_block is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield (from_block, latest_block)</span>
<span class="gi">+        from_block = latest_block + 1</span>
<span class="gi">+        if to_block is not None and latest_block &gt;= to_block:</span>
<span class="gi">+            break</span>


<span class="w"> </span>async def async_get_logs_multipart(w3: &#39;Web3&#39;, start_block: BlockNumber,
<span class="gu">@@ -191,7 +237,14 @@ async def async_get_logs_multipart(w3: &#39;Web3&#39;, start_block: BlockNumber,</span>
<span class="w"> </span>    The getLog request is partitioned into multiple calls of the max number of blocks
<span class="w"> </span>    ``max_blocks``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for from_block, to_block in block_ranges(start_block, stop_block, max_blocks):</span>
<span class="gi">+        params = {</span>
<span class="gi">+            &#39;fromBlock&#39;: from_block,</span>
<span class="gi">+            &#39;toBlock&#39;: to_block,</span>
<span class="gi">+            &#39;address&#39;: address,</span>
<span class="gi">+            &#39;topics&#39;: topics</span>
<span class="gi">+        }</span>
<span class="gi">+        yield await w3.eth.get_logs(params)</span>


<span class="w"> </span>class AsyncRequestLogs:
<span class="gh">diff --git a/web3/middleware/fixture.py b/web3/middleware/fixture.py</span>
<span class="gh">index d67010d5..99e71f29 100644</span>
<span class="gd">--- a/web3/middleware/fixture.py</span>
<span class="gi">+++ b/web3/middleware/fixture.py</span>
<span class="gu">@@ -11,7 +11,15 @@ def construct_fixture_middleware(fixtures: Dict[RPCEndpoint, Any]</span>
<span class="w"> </span>    Constructs a middleware which returns a static response for any method
<span class="w"> </span>    which is found in the provided fixtures.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def fixture_middleware(</span>
<span class="gi">+        make_request: Callable[[RPCEndpoint, Any], Any], w3: &quot;Web3&quot;</span>
<span class="gi">+    ) -&gt; Callable[[RPCEndpoint, Any], RPCResponse]:</span>
<span class="gi">+        def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method in fixtures:</span>
<span class="gi">+                return {&quot;result&quot;: fixtures[method]}</span>
<span class="gi">+            return make_request(method, params)</span>
<span class="gi">+        return middleware</span>
<span class="gi">+    return fixture_middleware</span>


<span class="w"> </span>def construct_result_generator_middleware(result_generators: Dict[
<span class="gu">@@ -22,7 +30,16 @@ def construct_result_generator_middleware(result_generators: Dict[</span>
<span class="w"> </span>    whatever response the generator function returns.  Callbacks must be
<span class="w"> </span>    functions with the signature `fn(method, params)`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def result_generator_middleware(</span>
<span class="gi">+        make_request: Callable[[RPCEndpoint, Any], Any], w3: &quot;Web3&quot;</span>
<span class="gi">+    ) -&gt; Callable[[RPCEndpoint, Any], RPCResponse]:</span>
<span class="gi">+        def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method in result_generators:</span>
<span class="gi">+                result = result_generators[method](method, params)</span>
<span class="gi">+                return {&quot;result&quot;: result}</span>
<span class="gi">+            return make_request(method, params)</span>
<span class="gi">+        return middleware</span>
<span class="gi">+    return result_generator_middleware</span>


<span class="w"> </span>def construct_error_generator_middleware(error_generators: Dict[RPCEndpoint,
<span class="gu">@@ -33,7 +50,16 @@ def construct_error_generator_middleware(error_generators: Dict[RPCEndpoint,</span>
<span class="w"> </span>    whatever error message the generator function returns.  Callbacks must be
<span class="w"> </span>    functions with the signature `fn(method, params)`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def error_generator_middleware(</span>
<span class="gi">+        make_request: Callable[[RPCEndpoint, Any], Any], w3: &quot;Web3&quot;</span>
<span class="gi">+    ) -&gt; Callable[[RPCEndpoint, Any], RPCResponse]:</span>
<span class="gi">+        def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method in error_generators:</span>
<span class="gi">+                error = error_generators[method](method, params)</span>
<span class="gi">+                return {&quot;error&quot;: error}</span>
<span class="gi">+            return make_request(method, params)</span>
<span class="gi">+        return middleware</span>
<span class="gi">+    return error_generator_middleware</span>


<span class="w"> </span>async def async_construct_result_generator_middleware(result_generators:
<span class="gu">@@ -42,7 +68,16 @@ async def async_construct_result_generator_middleware(result_generators:</span>
<span class="w"> </span>    Constructs a middleware which returns a static response for any method
<span class="w"> </span>    which is found in the provided fixtures.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    async def async_result_generator_middleware(</span>
<span class="gi">+        make_request: Callable[[RPCEndpoint, Any], Any], w3: &quot;AsyncWeb3&quot;</span>
<span class="gi">+    ) -&gt; AsyncMiddlewareCoroutine:</span>
<span class="gi">+        async def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method in result_generators:</span>
<span class="gi">+                result = result_generators[method](method, params)</span>
<span class="gi">+                return {&quot;result&quot;: result}</span>
<span class="gi">+            return await make_request(method, params)</span>
<span class="gi">+        return middleware</span>
<span class="gi">+    return async_result_generator_middleware</span>


<span class="w"> </span>async def async_construct_error_generator_middleware(error_generators: Dict
<span class="gu">@@ -53,4 +88,13 @@ async def async_construct_error_generator_middleware(error_generators: Dict</span>
<span class="w"> </span>    whatever error message the generator function returns.  Callbacks must be
<span class="w"> </span>    functions with the signature `fn(method, params)`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    async def async_error_generator_middleware(</span>
<span class="gi">+        make_request: Callable[[RPCEndpoint, Any], Any], w3: &quot;AsyncWeb3&quot;</span>
<span class="gi">+    ) -&gt; AsyncMiddlewareCoroutine:</span>
<span class="gi">+        async def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method in error_generators:</span>
<span class="gi">+                error = error_generators[method](method, params)</span>
<span class="gi">+                return {&quot;error&quot;: error}</span>
<span class="gi">+            return await make_request(method, params)</span>
<span class="gi">+        return middleware</span>
<span class="gi">+    return async_error_generator_middleware</span>
<span class="gh">diff --git a/web3/middleware/gas_price_strategy.py b/web3/middleware/gas_price_strategy.py</span>
<span class="gh">index 33d6387b..715f2b62 100644</span>
<span class="gd">--- a/web3/middleware/gas_price_strategy.py</span>
<span class="gi">+++ b/web3/middleware/gas_price_strategy.py</span>
<span class="gu">@@ -18,7 +18,32 @@ def gas_price_strategy_middleware(make_request: Callable[[RPCEndpoint, Any],</span>

<span class="w"> </span>    - Validates transaction params against legacy and dynamic fee txn values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+        if method != &#39;eth_sendTransaction&#39;:</span>
<span class="gi">+            return make_request(method, params)</span>
<span class="gi">+</span>
<span class="gi">+        transaction = params[0]</span>
<span class="gi">+        </span>
<span class="gi">+        # Validate transaction params</span>
<span class="gi">+        if any_in_dict(DYNAMIC_FEE_TXN_PARAMS, transaction) and any_in_dict([&#39;gasPrice&#39;], transaction):</span>
<span class="gi">+            raise TransactionTypeMismatch(&quot;You cannot use legacy and EIP-1559 transaction parameters at the same time&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        if none_in_dict(DYNAMIC_FEE_TXN_PARAMS, transaction) and &#39;gasPrice&#39; not in transaction:</span>
<span class="gi">+            if w3.eth.gas_price_strategy:</span>
<span class="gi">+                gas_price_strategy = w3.eth.gas_price_strategy</span>
<span class="gi">+                gas_price = gas_price_strategy(w3, transaction)</span>
<span class="gi">+                transaction = assoc(transaction, &#39;gasPrice&#39;, gas_price)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise InvalidTransaction(&quot;Gas price strategy not set and gasPrice not provided&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Convert values to hex if they are integers</span>
<span class="gi">+        for key in [&#39;gasPrice&#39;, &#39;maxFeePerGas&#39;, &#39;maxPriorityFeePerGas&#39;]:</span>
<span class="gi">+            if key in transaction:</span>
<span class="gi">+                transaction[key] = to_hex_if_integer(transaction[key])</span>
<span class="gi">+</span>
<span class="gi">+        return make_request(method, [transaction])</span>
<span class="gi">+</span>
<span class="gi">+    return middleware</span>


<span class="w"> </span>async def async_gas_price_strategy_middleware(make_request: Callable[[
<span class="gu">@@ -30,4 +55,29 @@ async def async_gas_price_strategy_middleware(make_request: Callable[[</span>

<span class="w"> </span>    - Validates transaction params against legacy and dynamic fee txn values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    async def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+        if method != &#39;eth_sendTransaction&#39;:</span>
<span class="gi">+            return await make_request(method, params)</span>
<span class="gi">+</span>
<span class="gi">+        transaction = params[0]</span>
<span class="gi">+        </span>
<span class="gi">+        # Validate transaction params</span>
<span class="gi">+        if any_in_dict(DYNAMIC_FEE_TXN_PARAMS, transaction) and any_in_dict([&#39;gasPrice&#39;], transaction):</span>
<span class="gi">+            raise TransactionTypeMismatch(&quot;You cannot use legacy and EIP-1559 transaction parameters at the same time&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        if none_in_dict(DYNAMIC_FEE_TXN_PARAMS, transaction) and &#39;gasPrice&#39; not in transaction:</span>
<span class="gi">+            if async_w3.eth.gas_price_strategy:</span>
<span class="gi">+                gas_price_strategy = async_w3.eth.gas_price_strategy</span>
<span class="gi">+                gas_price = await gas_price_strategy(async_w3, transaction)</span>
<span class="gi">+                transaction = assoc(transaction, &#39;gasPrice&#39;, gas_price)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise InvalidTransaction(&quot;Gas price strategy not set and gasPrice not provided&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Convert values to hex if they are integers</span>
<span class="gi">+        for key in [&#39;gasPrice&#39;, &#39;maxFeePerGas&#39;, &#39;maxPriorityFeePerGas&#39;]:</span>
<span class="gi">+            if key in transaction:</span>
<span class="gi">+                transaction[key] = to_hex_if_integer(transaction[key])</span>
<span class="gi">+</span>
<span class="gi">+        return await make_request(method, [transaction])</span>
<span class="gi">+</span>
<span class="gi">+    return middleware</span>
<span class="gh">diff --git a/web3/middleware/signing.py b/web3/middleware/signing.py</span>
<span class="gh">index 6cd23d57..44ea7724 100644</span>
<span class="gd">--- a/web3/middleware/signing.py</span>
<span class="gi">+++ b/web3/middleware/signing.py</span>
<span class="gu">@@ -32,7 +32,10 @@ def format_transaction(transaction: TxParams) -&gt;TxParams:</span>
<span class="w"> </span>    the underlying layers. Also has the effect of normalizing &#39;from&#39; for
<span class="w"> </span>    easier comparisons.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    formatted_transaction = apply_abi_formatters_to_dict(TRANSACTION_PARAMS_ABIS, transaction)</span>
<span class="gi">+    if &#39;from&#39; in formatted_transaction:</span>
<span class="gi">+        formatted_transaction[&#39;from&#39;] = to_checksum_address(formatted_transaction[&#39;from&#39;])</span>
<span class="gi">+    return formatted_transaction</span>


<span class="w"> </span>def construct_sign_and_send_raw_middleware(private_key_or_account: Union[
<span class="gu">@@ -47,7 +50,32 @@ def construct_sign_and_send_raw_middleware(private_key_or_account: Union[</span>
<span class="w"> </span>      - An eth_keys.PrivateKey object
<span class="w"> </span>      - A raw private key as a hex string or byte string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(private_key_or_account, (list, tuple, set)):</span>
<span class="gi">+        accounts = [to_account(pk) for pk in private_key_or_account]</span>
<span class="gi">+    else:</span>
<span class="gi">+        accounts = [to_account(private_key_or_account)]</span>
<span class="gi">+</span>
<span class="gi">+    def middleware(make_request: Callable[[RPCEndpoint, Any], Any], w3: &quot;Web3&quot;) -&gt; Callable[[RPCEndpoint, Any], RPCResponse]:</span>
<span class="gi">+        def middleware_fn(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method != &quot;eth_sendTransaction&quot;:</span>
<span class="gi">+                return make_request(method, params)</span>
<span class="gi">+            </span>
<span class="gi">+            transaction = format_transaction(params[0])</span>
<span class="gi">+            if &#39;from&#39; not in transaction:</span>
<span class="gi">+                return make_request(method, params)</span>
<span class="gi">+            </span>
<span class="gi">+            from_address = transaction[&#39;from&#39;]</span>
<span class="gi">+            account = next((acct for acct in accounts if acct.address == from_address), None)</span>
<span class="gi">+            if account is None:</span>
<span class="gi">+                return make_request(method, params)</span>
<span class="gi">+</span>
<span class="gi">+            transaction = fill_transaction_defaults(w3, transaction)</span>
<span class="gi">+            transaction = fill_nonce(w3, transaction)</span>
<span class="gi">+            signed = account.sign_transaction(transaction)</span>
<span class="gi">+            return make_request(&quot;eth_sendRawTransaction&quot;, [signed.rawTransaction])</span>
<span class="gi">+</span>
<span class="gi">+        return middleware_fn</span>
<span class="gi">+    return middleware</span>


<span class="w"> </span>async def async_construct_sign_and_send_raw_middleware(private_key_or_account:
<span class="gu">@@ -62,4 +90,29 @@ async def async_construct_sign_and_send_raw_middleware(private_key_or_account:</span>
<span class="w"> </span>      - An eth_keys.PrivateKey object
<span class="w"> </span>      - A raw private key as a hex string or byte string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(private_key_or_account, (list, tuple, set)):</span>
<span class="gi">+        accounts = [to_account(pk) for pk in private_key_or_account]</span>
<span class="gi">+    else:</span>
<span class="gi">+        accounts = [to_account(private_key_or_account)]</span>
<span class="gi">+</span>
<span class="gi">+    async def middleware(make_request: Callable[[RPCEndpoint, Any], Any], w3: &quot;AsyncWeb3&quot;) -&gt; AsyncMiddlewareCoroutine:</span>
<span class="gi">+        async def middleware_fn(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method != &quot;eth_sendTransaction&quot;:</span>
<span class="gi">+                return await make_request(method, params)</span>
<span class="gi">+            </span>
<span class="gi">+            transaction = format_transaction(params[0])</span>
<span class="gi">+            if &#39;from&#39; not in transaction:</span>
<span class="gi">+                return await make_request(method, params)</span>
<span class="gi">+            </span>
<span class="gi">+            from_address = transaction[&#39;from&#39;]</span>
<span class="gi">+            account = next((acct for acct in accounts if acct.address == from_address), None)</span>
<span class="gi">+            if account is None:</span>
<span class="gi">+                return await make_request(method, params)</span>
<span class="gi">+</span>
<span class="gi">+            transaction = await async_fill_transaction_defaults(w3, transaction)</span>
<span class="gi">+            transaction = await async_fill_nonce(w3, transaction)</span>
<span class="gi">+            signed = account.sign_transaction(transaction)</span>
<span class="gi">+            return await make_request(&quot;eth_sendRawTransaction&quot;, [signed.rawTransaction])</span>
<span class="gi">+</span>
<span class="gi">+        return middleware_fn</span>
<span class="gi">+    return middleware</span>
<span class="gh">diff --git a/web3/middleware/stalecheck.py b/web3/middleware/stalecheck.py</span>
<span class="gh">index 9fc519d1..ef9e3efb 100644</span>
<span class="gd">--- a/web3/middleware/stalecheck.py</span>
<span class="gi">+++ b/web3/middleware/stalecheck.py</span>
<span class="gu">@@ -21,7 +21,18 @@ def make_stalecheck_middleware(allowable_delay: int,</span>
<span class="w"> </span>    If the latest block in the chain is older than 5 minutes in this example, then the
<span class="w"> </span>    middleware will raise a StaleBlockchain exception.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def stalecheck_middleware(make_request: Callable[[RPCEndpoint, Any], Any], w3: &#39;Web3&#39;) -&gt; Callable[[RPCEndpoint, Any], RPCResponse]:</span>
<span class="gi">+        def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method not in skip_stalecheck_for_methods:</span>
<span class="gi">+                latest_block = w3.eth.get_block(&#39;latest&#39;)</span>
<span class="gi">+                if latest_block is None:</span>
<span class="gi">+                    raise StaleBlockchain(&quot;Latest block is None&quot;)</span>
<span class="gi">+                last_block_time = latest_block[&#39;timestamp&#39;]</span>
<span class="gi">+                if time.time() - last_block_time &gt; allowable_delay:</span>
<span class="gi">+                    raise StaleBlockchain(f&quot;The latest block is {time.time() - last_block_time} seconds old, which exceeds the allowable delay of {allowable_delay} seconds&quot;)</span>
<span class="gi">+            return make_request(method, params)</span>
<span class="gi">+        return middleware</span>
<span class="gi">+    return stalecheck_middleware</span>


<span class="w"> </span>async def async_make_stalecheck_middleware(allowable_delay: int,
<span class="gu">@@ -38,4 +49,15 @@ async def async_make_stalecheck_middleware(allowable_delay: int,</span>
<span class="w"> </span>    If the latest block in the chain is older than 5 minutes in this example, then the
<span class="w"> </span>    middleware will raise a StaleBlockchain exception.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    async def stalecheck_middleware(make_request: Callable[[RPCEndpoint, Any], Any], w3: &#39;AsyncWeb3&#39;) -&gt; AsyncMiddlewareCoroutine:</span>
<span class="gi">+        async def middleware(method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+            if method not in skip_stalecheck_for_methods:</span>
<span class="gi">+                latest_block = await w3.eth.get_block(&#39;latest&#39;)</span>
<span class="gi">+                if latest_block is None:</span>
<span class="gi">+                    raise StaleBlockchain(&quot;Latest block is None&quot;)</span>
<span class="gi">+                last_block_time = latest_block[&#39;timestamp&#39;]</span>
<span class="gi">+                if time.time() - last_block_time &gt; allowable_delay:</span>
<span class="gi">+                    raise StaleBlockchain(f&quot;The latest block is {time.time() - last_block_time} seconds old, which exceeds the allowable delay of {allowable_delay} seconds&quot;)</span>
<span class="gi">+            return await make_request(method, params)</span>
<span class="gi">+        return middleware</span>
<span class="gi">+    return stalecheck_middleware</span>
<span class="gh">diff --git a/web3/pm.py b/web3/pm.py</span>
<span class="gh">index 1a35c7d5..051ad89b 100644</span>
<span class="gd">--- a/web3/pm.py</span>
<span class="gi">+++ b/web3/pm.py</span>
<span class="gu">@@ -202,7 +202,8 @@ class PM(Module):</span>
<span class="w"> </span>        * Parameters:
<span class="w"> </span>            * ``manifest``: A dict representing a valid manifest
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        validate_manifest_against_schema(manifest)</span>
<span class="gi">+        return Package(manifest)</span>

<span class="w"> </span>    def get_package_from_uri(self, manifest_uri: URI) -&gt;Package:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -214,7 +215,11 @@ class PM(Module):</span>
<span class="w"> </span>        * Parameters:
<span class="w"> </span>            * ``uri``: Must be a valid content-addressed URI
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not is_supported_content_addressed_uri(manifest_uri):</span>
<span class="gi">+            raise ValueError(&quot;URI must be a valid content-addressed URI&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        manifest = json.loads(resolve_uri_contents(manifest_uri))</span>
<span class="gi">+        return self.get_package_from_manifest(manifest)</span>

<span class="w"> </span>    def get_local_package(self, package_name: str, ethpm_dir: Path=None
<span class="w"> </span>        ) -&gt;Package:
<span class="gu">@@ -226,7 +231,19 @@ class PM(Module):</span>
<span class="w"> </span>            * ``package_name``: Must be the name of a package installed locally.
<span class="w"> </span>            * ``ethpm_dir``: Path pointing to the target ethpm directory (optional).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if ethpm_dir is None:</span>
<span class="gi">+            ethpm_dir = Path.home() / &#39;.ethpm&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        package_dir = ethpm_dir / package_name</span>
<span class="gi">+        manifest_path = package_dir / &#39;manifest.json&#39;</span>
<span class="gi">+        </span>
<span class="gi">+        if not manifest_path.exists():</span>
<span class="gi">+            raise FileNotFoundError(f&quot;Manifest not found for package: {package_name}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        with open(manifest_path) as f:</span>
<span class="gi">+            manifest = json.load(f)</span>
<span class="gi">+        </span>
<span class="gi">+        return self.get_package_from_manifest(manifest)</span>

<span class="w"> </span>    def set_registry(self, address: Union[Address, ChecksumAddress, ENS]
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -242,7 +259,15 @@ class PM(Module):</span>
<span class="w"> </span>        * Parameters:
<span class="w"> </span>            * ``address``: Address of on-chain Registry.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(address, str) and is_ens_name(address):</span>
<span class="gi">+            if not hasattr(self.w3, &#39;ens&#39;) or not isinstance(self.w3.ens, ENS):</span>
<span class="gi">+                raise ValueError(&quot;ENS is not set up on current web3 instance&quot;)</span>
<span class="gi">+            address = self.w3.ens.address(address)</span>
<span class="gi">+        </span>
<span class="gi">+        if not is_checksum_address(address):</span>
<span class="gi">+            address = to_checksum_address(address)</span>
<span class="gi">+        </span>
<span class="gi">+        self.registry = SimpleRegistry(address, self.w3)</span>

<span class="w"> </span>    def deploy_and_set_registry(self) -&gt;ChecksumAddress:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -256,7 +281,9 @@ class PM(Module):</span>

<span class="w"> </span>           w3.ens.setup_address(ens_name, w3.pm.registry.address)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        deployed_registry = SimpleRegistry.deploy_new_instance(self.w3)</span>
<span class="gi">+        self.registry = deployed_registry</span>
<span class="gi">+        return deployed_registry.address</span>

<span class="w"> </span>    def release_package(self, package_name: str, version: str, manifest_uri:
<span class="w"> </span>        URI) -&gt;bytes:
<span class="gu">@@ -274,7 +301,16 @@ class PM(Module):</span>
<span class="w"> </span>                                supported.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.registry:</span>
<span class="gi">+            raise ValueError(&quot;Registry not set. Use set_registry() first.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        validate_package_name(package_name)</span>
<span class="gi">+        validate_package_version(version)</span>
<span class="gi">+        </span>
<span class="gi">+        if not is_supported_content_addressed_uri(manifest_uri):</span>
<span class="gi">+            raise ValueError(&quot;manifest_uri must be a valid content-addressed URI&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        return self.registry._release(package_name, version, manifest_uri)</span>

<span class="w"> </span>    @to_tuple
<span class="w"> </span>    def get_all_package_names(self) -&gt;Iterable[str]:
<span class="gu">@@ -282,27 +318,43 @@ class PM(Module):</span>
<span class="w"> </span>        Returns a tuple containing all the package names
<span class="w"> </span>        available on the current registry.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.registry:</span>
<span class="gi">+            raise ValueError(&quot;Registry not set. Use set_registry() first.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        for package_id in self.registry._get_all_package_ids():</span>
<span class="gi">+            yield self.registry._get_package_name(package_id)</span>

<span class="w"> </span>    def get_package_count(self) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the number of packages available on the current registry.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.registry:</span>
<span class="gi">+            raise ValueError(&quot;Registry not set. Use set_registry() first.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        return self.registry._num_package_ids()</span>

<span class="w"> </span>    def get_release_count(self, package_name: str) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the number of releases of the given package name
<span class="w"> </span>        available on the current registry.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.registry:</span>
<span class="gi">+            raise ValueError(&quot;Registry not set. Use set_registry() first.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        validate_package_name(package_name)</span>
<span class="gi">+        return self.registry._num_release_ids(package_name)</span>

<span class="w"> </span>    def get_release_id(self, package_name: str, version: str) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the 32 byte identifier of a release for the given package
<span class="w"> </span>        name and version, if they are available on the current registry.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.registry:</span>
<span class="gi">+            raise ValueError(&quot;Registry not set. Use set_registry() first.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        validate_package_name(package_name)</span>
<span class="gi">+        validate_package_version(version)</span>
<span class="gi">+        return self.registry._get_release_id(package_name, version)</span>

<span class="w"> </span>    @to_tuple
<span class="w"> </span>    def get_all_package_releases(self, package_name: str) -&gt;Iterable[Tuple[
<span class="gu">@@ -311,7 +363,13 @@ class PM(Module):</span>
<span class="w"> </span>        Returns a tuple of release data (version, manifest_ur) for every release of the
<span class="w"> </span>        given package name available on the current registry.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.registry:</span>
<span class="gi">+            raise ValueError(&quot;Registry not set. Use set_registry() first.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        validate_package_name(package_name)</span>
<span class="gi">+        for release_id in self.registry._get_all_release_ids(package_name):</span>
<span class="gi">+            release_data = self.registry._get_release_data(release_id)</span>
<span class="gi">+            yield (release_data.version, release_data.manifest_uri)</span>

<span class="w"> </span>    def get_release_id_data(self, release_id: bytes) -&gt;ReleaseData:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -321,7 +379,10 @@ class PM(Module):</span>
<span class="w"> </span>        * Parameters:
<span class="w"> </span>            * ``release_id``: 32 byte release identifier
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.registry:</span>
<span class="gi">+            raise ValueError(&quot;Registry not set. Use set_registry() first.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        return self.registry._get_release_data(release_id)</span>

<span class="w"> </span>    def get_release_data(self, package_name: str, version: str) -&gt;ReleaseData:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -332,7 +393,13 @@ class PM(Module):</span>
<span class="w"> </span>            * ``name``: Must be a valid package name.
<span class="w"> </span>            * ``version``: Must be a valid package version.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.registry:</span>
<span class="gi">+            raise ValueError(&quot;Registry not set. Use set_registry() first.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        validate_package_name(package_name)</span>
<span class="gi">+        validate_package_version(version)</span>
<span class="gi">+        release_id = self.get_release_id(package_name, version)</span>
<span class="gi">+        return self.get_release_id_data(release_id)</span>

<span class="w"> </span>    def get_package(self, package_name: str, version: str) -&gt;Package:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -344,4 +411,9 @@ class PM(Module):</span>
<span class="w"> </span>            * ``name``: Must be a valid package name.
<span class="w"> </span>            * ``version``: Must be a valid package version.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.registry:</span>
<span class="gi">+            raise ValueError(&quot;Registry not set. Use set_registry() first.&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        release_data = self.get_release_data(package_name, version)</span>
<span class="gi">+        manifest_uri = release_data.manifest_uri</span>
<span class="gi">+        return self.get_package_from_uri(manifest_uri)</span>
<span class="gh">diff --git a/web3/providers/base.py b/web3/providers/base.py</span>
<span class="gh">index 83113b8d..ca7b373f 100644</span>
<span class="gd">--- a/web3/providers/base.py</span>
<span class="gi">+++ b/web3/providers/base.py</span>
<span class="gu">@@ -26,7 +26,15 @@ class BaseProvider:</span>
<span class="w"> </span>        @returns a function that calls all the middleware and
<span class="w"> </span>            eventually self.make_request()
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        middlewares = tuple(outer_middlewares) + self._middlewares</span>
<span class="gi">+        cache_key = self._middlewares</span>
<span class="gi">+        if cache_key != self._request_func_cache[0]:</span>
<span class="gi">+            self._request_func_cache = (cache_key, combine_middlewares(</span>
<span class="gi">+                middlewares=middlewares,</span>
<span class="gi">+                w3=w3,</span>
<span class="gi">+                provider_request_fn=self.make_request,</span>
<span class="gi">+            ))</span>
<span class="gi">+        return self._request_func_cache[1]</span>


<span class="w"> </span>class JSONBaseProvider(BaseProvider):
<span class="gh">diff --git a/web3/providers/eth_tester/defaults.py b/web3/providers/eth_tester/defaults.py</span>
<span class="gh">index 96005e39..51beb236 100644</span>
<span class="gd">--- a/web3/providers/eth_tester/defaults.py</span>
<span class="gi">+++ b/web3/providers/eth_tester/defaults.py</span>
<span class="gu">@@ -21,12 +21,13 @@ null_if_filter_not_found = null_if_excepts(FilterNotFound)</span>
<span class="w"> </span>null_if_indexerror = null_if_excepts(IndexError)


<span class="gd">-def _generate_random_private_key() -&gt;HexStr:</span>
<span class="gi">+def _generate_random_private_key() -&gt; HexStr:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    WARNING: This is not a secure way to generate private keys and should only
<span class="w"> </span>    be used for testing purposes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    private_key = &#39;0x&#39; + &#39;&#39;.join([random.choice(&#39;0123456789abcdef&#39;) for _ in range(64)])</span>
<span class="gi">+    return HexStr(private_key)</span>


<span class="w"> </span>API_ENDPOINTS = {&#39;web3&#39;: {&#39;clientVersion&#39;: client_version, &#39;sha3&#39;: compose(
<span class="gh">diff --git a/web3/providers/ipc.py b/web3/providers/ipc.py</span>
<span class="gh">index 116d38f3..8e630b3a 100644</span>
<span class="gd">--- a/web3/providers/ipc.py</span>
<span class="gi">+++ b/web3/providers/ipc.py</span>
<span class="gu">@@ -35,6 +35,11 @@ class PersistantSocket:</span>
<span class="w"> </span>                pass
<span class="w"> </span>            self.sock = None

<span class="gi">+    def _open(self) -&gt;socket.socket:</span>
<span class="gi">+        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span>
<span class="gi">+        sock.connect(self.ipc_path)</span>
<span class="gi">+        return sock</span>
<span class="gi">+</span>

<span class="w"> </span>class IPCProvider(JSONBaseProvider):
<span class="w"> </span>    logger = logging.getLogger(&#39;web3.providers.IPCProvider&#39;)
<span class="gu">@@ -55,3 +60,44 @@ class IPCProvider(JSONBaseProvider):</span>

<span class="w"> </span>    def __str__(self) -&gt;str:
<span class="w"> </span>        return f&#39;&lt;{self.__class__.__name__} {self.ipc_path}&gt;&#39;
<span class="gi">+</span>
<span class="gi">+    def make_request(self, method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+        request = self.encode_rpc_request(method, params)</span>
<span class="gi">+        with self._lock, self._socket as sock:</span>
<span class="gi">+            try:</span>
<span class="gi">+                sock.sendall(request)</span>
<span class="gi">+                response_raw = b&quot;&quot;</span>
<span class="gi">+                with Timeout(self.timeout) as timeout:</span>
<span class="gi">+                    while True:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            response_raw += sock.recv(4096)</span>
<span class="gi">+                        except socket.timeout:</span>
<span class="gi">+                            timeout.sleep(0)</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        if response_raw and response_raw[-1] == ord(&quot;\n&quot;):</span>
<span class="gi">+                            break</span>
<span class="gi">+            except (ConnectionError, OSError) as e:</span>
<span class="gi">+                raise ConnectionError(f&quot;Could not connect to IPC socket at path: {self.ipc_path}&quot;) from e</span>
<span class="gi">+        return self.decode_rpc_response(response_raw)</span>
<span class="gi">+</span>
<span class="gi">+    def isConnected(self) -&gt; bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            with self._lock, self._socket as sock:</span>
<span class="gi">+                sock.sendall(self.encode_rpc_request(&quot;web3_clientVersion&quot;, []))</span>
<span class="gi">+                sock.recv(1)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except (ConnectionError, OSError):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+def get_default_ipc_path() -&gt; str:</span>
<span class="gi">+    if sys.platform.startswith(&#39;darwin&#39;):</span>
<span class="gi">+        return os.path.expanduser(&quot;~/Library/Ethereum/geth.ipc&quot;)</span>
<span class="gi">+    elif sys.platform.startswith(&#39;linux&#39;):</span>
<span class="gi">+        return os.path.expanduser(&quot;~/.ethereum/geth.ipc&quot;)</span>
<span class="gi">+    elif sys.platform.startswith(&#39;win&#39;):</span>
<span class="gi">+        return r&quot;\\\\.\\pipe\\geth.ipc&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;Unsupported platform &#39;{0}&#39;. Unable to determine &quot;</span>
<span class="gi">+            &quot;the default ipc path.&quot;.format(sys.platform)</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/web3/providers/persistent.py b/web3/providers/persistent.py</span>
<span class="gh">index 81b2301b..48525e76 100644</span>
<span class="gd">--- a/web3/providers/persistent.py</span>
<span class="gi">+++ b/web3/providers/persistent.py</span>
<span class="gu">@@ -41,7 +41,7 @@ class PersistentConnectionProvider(AsyncJSONBaseProvider, ABC):</span>
<span class="w"> </span>        exception and keep the listener task alive. Override this method to fine-tune
<span class="w"> </span>        error logging behavior for the implementation class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.logger.error(f&quot;Listener task exception: {e}&quot;, exc_info=True)</span>

<span class="w"> </span>    def _handle_listener_task_exceptions(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -49,4 +49,109 @@ class PersistentConnectionProvider(AsyncJSONBaseProvider, ABC):</span>
<span class="w"> </span>        messages in the main loop. If the message listener task has completed and an
<span class="w"> </span>        exception was recorded, raise the exception in the main loop.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._message_listener_task and self._message_listener_task.done():</span>
<span class="gi">+            exception = self._message_listener_task.exception()</span>
<span class="gi">+            if exception:</span>
<span class="gi">+                if self.silence_listener_task_exceptions:</span>
<span class="gi">+                    self._error_log_listener_task_exception(exception)</span>
<span class="gi">+                    # Restart the listener task</span>
<span class="gi">+                    self._start_listener_task()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise exception</span>
<span class="gi">+</span>
<span class="gi">+    def _start_listener_task(self) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Start the message listener task.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if self._message_listener_task is None or self._message_listener_task.done():</span>
<span class="gi">+            self._message_listener_task = asyncio.create_task(self._listen_for_messages())</span>
<span class="gi">+</span>
<span class="gi">+    async def _listen_for_messages(self) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Listen for messages from the WebSocket connection.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if self._ws:</span>
<span class="gi">+                    message = await self._ws.recv()</span>
<span class="gi">+                    await self._request_processor.process_response(message)</span>
<span class="gi">+            except (ConnectionClosed, ConnectionClosedOK, WebSocketException) as e:</span>
<span class="gi">+                self.logger.warning(f&quot;WebSocket connection closed: {e}&quot;)</span>
<span class="gi">+                await self._reconnect()</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                self.logger.error(f&quot;Error in message listener: {e}&quot;, exc_info=True)</span>
<span class="gi">+                if not self.silence_listener_task_exceptions:</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+    async def _reconnect(self) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Attempt to reconnect to the WebSocket.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        for attempt in range(self._max_connection_retries):</span>
<span class="gi">+            try:</span>
<span class="gi">+                await self.connect()</span>
<span class="gi">+                self.logger.info(&quot;Reconnected to WebSocket&quot;)</span>
<span class="gi">+                return</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                self.logger.warning(f&quot;Reconnection attempt {attempt + 1} failed: {e}&quot;)</span>
<span class="gi">+                await asyncio.sleep(2 ** attempt)  # Exponential backoff</span>
<span class="gi">+        raise ProviderConnectionError(&quot;Failed to reconnect after multiple attempts&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    async def connect(self) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Establish a WebSocket connection.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if not self.endpoint_uri:</span>
<span class="gi">+            raise ValueError(&quot;No endpoint URI specified&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            self._ws = await asyncio.wait_for(</span>
<span class="gi">+                WebSocketClientProtocol.__aenter__(self.endpoint_uri),</span>
<span class="gi">+                timeout=self.request_timeout</span>
<span class="gi">+            )</span>
<span class="gi">+            self._start_listener_task()</span>
<span class="gi">+            self._listen_event.set()</span>
<span class="gi">+        except (asyncio.TimeoutError, WebSocketException) as e:</span>
<span class="gi">+            raise ProviderConnectionError(f&quot;Failed to connect to {self.endpoint_uri}: {e}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    async def disconnect(self) -&gt;None:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Close the WebSocket connection.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if self._ws:</span>
<span class="gi">+            await self._ws.close()</span>
<span class="gi">+            self._ws = None</span>
<span class="gi">+        if self._message_listener_task:</span>
<span class="gi">+            self._message_listener_task.cancel()</span>
<span class="gi">+            try:</span>
<span class="gi">+                await self._message_listener_task</span>
<span class="gi">+            except asyncio.CancelledError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        self._listen_event.clear()</span>
<span class="gi">+</span>
<span class="gi">+    async def is_connected(self) -&gt;bool:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Check if the WebSocket connection is established and open.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self._ws is not None and self._ws.open</span>
<span class="gi">+</span>
<span class="gi">+    async def make_request(self, method: RPCEndpoint, params: Any) -&gt;RPCResponse:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Make an RPC request over the WebSocket connection.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if not await self.is_connected():</span>
<span class="gi">+            await self.connect()</span>
<span class="gi">+</span>
<span class="gi">+        request_id = generate_cache_key(method, params)</span>
<span class="gi">+        request = self.encode_rpc_request(method, params)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            response = await asyncio.wait_for(</span>
<span class="gi">+                self._request_processor.send_request(request_id, request),</span>
<span class="gi">+                timeout=self.request_timeout</span>
<span class="gi">+            )</span>
<span class="gi">+            return self.decode_rpc_response(response)</span>
<span class="gi">+        except asyncio.TimeoutError:</span>
<span class="gi">+            raise TimeExhausted(f&quot;Request {request_id} timed out after {self.request_timeout} seconds&quot;)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise ProviderConnectionError(f&quot;Error making request: {e}&quot;)</span>
<span class="gh">diff --git a/web3/providers/websocket/request_processor.py b/web3/providers/websocket/request_processor.py</span>
<span class="gh">index 704c0352..00262254 100644</span>
<span class="gd">--- a/web3/providers/websocket/request_processor.py</span>
<span class="gi">+++ b/web3/providers/websocket/request_processor.py</span>
<span class="gu">@@ -49,10 +49,24 @@ class RequestProcessor:</span>
<span class="w"> </span>        request is made but inner requests, say to `eth_estimateGas` if the `gas` is
<span class="w"> </span>        missing, are made before the original request is sent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cache_key in self._request_information_cache:</span>
<span class="gi">+            old_request_info = self._request_information_cache[cache_key]</span>
<span class="gi">+            new_request_id = old_request_info.request_id + 1</span>
<span class="gi">+            new_cache_key = generate_cache_key(</span>
<span class="gi">+                old_request_info.method,</span>
<span class="gi">+                old_request_info.params,</span>
<span class="gi">+                new_request_id</span>
<span class="gi">+            )</span>
<span class="gi">+            self._request_information_cache[new_cache_key] = RequestInformation(</span>
<span class="gi">+                old_request_info.method,</span>
<span class="gi">+                old_request_info.params,</span>
<span class="gi">+                new_request_id</span>
<span class="gi">+            )</span>
<span class="gi">+            del self._request_information_cache[cache_key]</span>

<span class="w"> </span>    def clear_caches(self) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Clear the request processor caches.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._request_response_cache.clear()</span>
<span class="gi">+        self._request_information_cache.clear()</span>
<span class="gh">diff --git a/web3/providers/websocket/websocket.py b/web3/providers/websocket/websocket.py</span>
<span class="gh">index 23c1a7e4..f6e88a36 100644</span>
<span class="gd">--- a/web3/providers/websocket/websocket.py</span>
<span class="gi">+++ b/web3/providers/websocket/websocket.py</span>
<span class="gu">@@ -65,3 +65,31 @@ class WebsocketProvider(JSONBaseProvider):</span>

<span class="w"> </span>    def __str__(self) -&gt;str:
<span class="w"> </span>        return f&#39;WS connection {self.endpoint_uri}&#39;
<span class="gi">+</span>
<span class="gi">+    def make_request(self, method: RPCEndpoint, params: Any) -&gt; RPCResponse:</span>
<span class="gi">+        request_data = self.encode_rpc_request(method, params)</span>
<span class="gi">+        response = self._loop.run_until_complete(self._make_request(request_data))</span>
<span class="gi">+        return self.decode_rpc_response(response)</span>
<span class="gi">+</span>
<span class="gi">+    async def _make_request(self, request_data: str) -&gt; str:</span>
<span class="gi">+        async with self.conn as ws:</span>
<span class="gi">+            await ws.send(request_data)</span>
<span class="gi">+            response = await asyncio.wait_for(ws.recv(), timeout=self.websocket_timeout)</span>
<span class="gi">+        return response</span>
<span class="gi">+</span>
<span class="gi">+    def is_connected(self) -&gt; bool:</span>
<span class="gi">+        return self._loop.run_until_complete(self._is_connected())</span>
<span class="gi">+</span>
<span class="gi">+    async def _is_connected(self) -&gt; bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            async with self.conn as ws:</span>
<span class="gi">+                return ws.open</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def disconnect(self) -&gt; None:</span>
<span class="gi">+        self._loop.run_until_complete(self._disconnect())</span>
<span class="gi">+</span>
<span class="gi">+    async def _disconnect(self) -&gt; None:</span>
<span class="gi">+        if self.conn.ws and self.conn.ws.open:</span>
<span class="gi">+            await self.conn.ws.close()</span>
<span class="gh">diff --git a/web3/testing.py b/web3/testing.py</span>
<span class="gh">index 40e4637c..5d933bc0 100644</span>
<span class="gd">--- a/web3/testing.py</span>
<span class="gi">+++ b/web3/testing.py</span>
<span class="gu">@@ -1,7 +1,137 @@</span>
<span class="gd">-from typing import Optional</span>
<span class="gi">+from typing import Optional, Any, Dict, List</span>
<span class="w"> </span>from web3._utils.rpc_abi import RPC
<span class="w"> </span>from web3.module import Module
<span class="gi">+from web3.types import Wei, BlockIdentifier</span>


<span class="w"> </span>class Testing(Module):
<span class="gd">-    pass</span>
<span class="gi">+    def timeTravel(self, timestamp: int) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Fast forward to a future timestamp.</span>
<span class="gi">+</span>
<span class="gi">+        :param timestamp: The timestamp to fast forward to.</span>
<span class="gi">+        :return: True if successful, False otherwise.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(RPC.testing_timeTravel, [timestamp])</span>
<span class="gi">+</span>
<span class="gi">+    def mine(self, num_blocks: int = 1) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Mine a specified number of blocks.</span>
<span class="gi">+</span>
<span class="gi">+        :param num_blocks: Number of blocks to mine (default: 1).</span>
<span class="gi">+        :return: True if successful, False otherwise.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(RPC.evm_mine, [num_blocks])</span>
<span class="gi">+</span>
<span class="gi">+    def snapshot(self) -&gt; str:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Take a snapshot of the current state of the blockchain.</span>
<span class="gi">+</span>
<span class="gi">+        :return: The ID of the snapshot.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(RPC.evm_snapshot, [])</span>
<span class="gi">+</span>
<span class="gi">+    def revert(self, snapshot_id: str) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Revert the blockchain to a previous snapshot.</span>
<span class="gi">+</span>
<span class="gi">+        :param snapshot_id: The ID of the snapshot to revert to.</span>
<span class="gi">+        :return: True if successful, False otherwise.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(RPC.evm_revert, [snapshot_id])</span>
<span class="gi">+</span>
<span class="gi">+    def reset_to_genesis(self) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Reset the blockchain to its genesis state.</span>
<span class="gi">+</span>
<span class="gi">+        :return: True if successful, False otherwise.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(RPC.evm_reset, [])</span>
<span class="gi">+</span>
<span class="gi">+    def set_balance(self, address: str, balance: Wei) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Set the balance of an account.</span>
<span class="gi">+</span>
<span class="gi">+        :param address: The address of the account.</span>
<span class="gi">+        :param balance: The new balance in Wei.</span>
<span class="gi">+        :return: True if successful, False otherwise.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(</span>
<span class="gi">+            RPC.testing_setBalance,</span>
<span class="gi">+            [address, hex(balance)]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def set_code(self, address: str, code: str) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Set the code of a contract.</span>
<span class="gi">+</span>
<span class="gi">+        :param address: The address of the contract.</span>
<span class="gi">+        :param code: The new code as a hexadecimal string.</span>
<span class="gi">+        :return: True if successful, False otherwise.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(</span>
<span class="gi">+            RPC.testing_setCode,</span>
<span class="gi">+            [address, code]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def set_storage_at(self, address: str, position: int, value: str) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Set a storage slot of a contract.</span>
<span class="gi">+</span>
<span class="gi">+        :param address: The address of the contract.</span>
<span class="gi">+        :param position: The storage slot position.</span>
<span class="gi">+        :param value: The value to set at the storage slot.</span>
<span class="gi">+        :return: True if successful, False otherwise.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(</span>
<span class="gi">+            RPC.testing_setStorageAt,</span>
<span class="gi">+            [address, hex(position), value]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_block_by_number(self, block_identifier: BlockIdentifier) -&gt; Dict[str, Any]:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Get block information by block number.</span>
<span class="gi">+</span>
<span class="gi">+        :param block_identifier: The block number or a predefined block identifier.</span>
<span class="gi">+        :return: A dictionary containing block information.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(</span>
<span class="gi">+            RPC.eth_getBlockByNumber,</span>
<span class="gi">+            [block_identifier, True]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_transaction_receipt(self, tx_hash: str) -&gt; Dict[str, Any]:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Get the receipt of a transaction.</span>
<span class="gi">+</span>
<span class="gi">+        :param tx_hash: The transaction hash.</span>
<span class="gi">+        :return: A dictionary containing the transaction receipt.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        return self.web3.manager.request_blocking(</span>
<span class="gi">+            RPC.eth_getTransactionReceipt,</span>
<span class="gi">+            [tx_hash]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_logs(self, from_block: BlockIdentifier, to_block: BlockIdentifier, address: Optional[str] = None, topics: Optional[List[str]] = None) -&gt; List[Dict[str, Any]]:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Get logs matching the given parameters.</span>
<span class="gi">+</span>
<span class="gi">+        :param from_block: The starting block (inclusive).</span>
<span class="gi">+        :param to_block: The ending block (inclusive).</span>
<span class="gi">+        :param address: (Optional) The address to get logs from.</span>
<span class="gi">+        :param topics: (Optional) Array of 32 Bytes DATA topics.</span>
<span class="gi">+        :return: A list of log objects.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        filter_params = {</span>
<span class="gi">+            &quot;fromBlock&quot;: from_block,</span>
<span class="gi">+            &quot;toBlock&quot;: to_block,</span>
<span class="gi">+        }</span>
<span class="gi">+        if address:</span>
<span class="gi">+            filter_params[&quot;address&quot;] = address</span>
<span class="gi">+        if topics:</span>
<span class="gi">+            filter_params[&quot;topics&quot;] = topics</span>
<span class="gi">+</span>
<span class="gi">+        return self.web3.manager.request_blocking(</span>
<span class="gi">+            RPC.eth_getLogs,</span>
<span class="gi">+            [filter_params]</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/web3/tools/pytest_ethereum/_utils.py b/web3/tools/pytest_ethereum/_utils.py</span>
<span class="gh">index 443aece3..b9ed57ee 100644</span>
<span class="gd">--- a/web3/tools/pytest_ethereum/_utils.py</span>
<span class="gi">+++ b/web3/tools/pytest_ethereum/_utils.py</span>
<span class="gu">@@ -15,7 +15,10 @@ def pluck_matching_uri(deployment_data: Dict[URI, Dict[str, str]], w3: Web3</span>
<span class="w"> </span>    Return any blockchain uri that matches w3-connected chain, if one
<span class="w"> </span>    is present in the deployment data keys.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for uri in deployment_data.keys():</span>
<span class="gi">+        if check_if_chain_matches_chain_uri(w3, uri):</span>
<span class="gi">+            return uri</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def contains_matching_uri(deployment_data: Dict[str, Dict[str, str]], w3: Web3
<span class="gu">@@ -24,7 +27,7 @@ def contains_matching_uri(deployment_data: Dict[str, Dict[str, str]], w3: Web3</span>
<span class="w"> </span>    Returns true if any blockchain uri in deployment data matches
<span class="w"> </span>    w3-connected chain.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(check_if_chain_matches_chain_uri(w3, uri) for uri in deployment_data.keys())</span>


<span class="w"> </span>def insert_deployment(package: Package, deployment_name: str,
<span class="gu">@@ -35,11 +38,32 @@ def insert_deployment(package: Package, deployment_name: str,</span>
<span class="w"> </span>    with the new deployment data. If no match, it will simply add
<span class="w"> </span>    the new chain uri and deployment data.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    old_deployments = package.manifest.get(&#39;deployments&#39;, {})</span>
<span class="gi">+    </span>
<span class="gi">+    if latest_block_uri in old_deployments:</span>
<span class="gi">+        updated_deployments = assoc_in(</span>
<span class="gi">+            old_deployments,</span>
<span class="gi">+            [latest_block_uri, deployment_name],</span>
<span class="gi">+            deployment_data</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        updated_deployments = assoc(</span>
<span class="gi">+            old_deployments,</span>
<span class="gi">+            latest_block_uri,</span>
<span class="gi">+            {deployment_name: deployment_data}</span>
<span class="gi">+        )</span>
<span class="gi">+    </span>
<span class="gi">+    return assoc(package.manifest, &#39;deployments&#39;, updated_deployments)</span>


<span class="w"> </span>def get_deployment_address(linked_type: str, package: Package) -&gt;Address:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the address of a linked_type found in a package&#39;s manifest deployments.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    deployments = package.manifest.get(&#39;deployments&#39;, {})</span>
<span class="gi">+    </span>
<span class="gi">+    for deployment_data in deployments.values():</span>
<span class="gi">+        if linked_type in deployment_data:</span>
<span class="gi">+            return Address(deployment_data[linked_type][&#39;address&#39;])</span>
<span class="gi">+    </span>
<span class="gi">+    raise LinkerError(f&quot;Unable to find deployment address for {linked_type}&quot;)</span>
<span class="gh">diff --git a/web3/tools/pytest_ethereum/exceptions.py b/web3/tools/pytest_ethereum/exceptions.py</span>
<span class="gh">index 3125e3dd..8ddb8325 100644</span>
<span class="gd">--- a/web3/tools/pytest_ethereum/exceptions.py</span>
<span class="gi">+++ b/web3/tools/pytest_ethereum/exceptions.py</span>
<span class="gu">@@ -2,18 +2,22 @@ class PytestEthereumError(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Base class for all Pytest-Ethereum errors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self, message=&quot;An error occurred in Pytest-Ethereum&quot;):</span>
<span class="gi">+        self.message = message</span>
<span class="gi">+        super().__init__(self.message)</span>


<span class="w"> </span>class DeployerError(PytestEthereumError):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Raised when the Deployer is unable to deploy a contract type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self, message=&quot;Unable to deploy contract&quot;):</span>
<span class="gi">+        super().__init__(message)</span>


<span class="w"> </span>class LinkerError(PytestEthereumError):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Raised when the Linker is unable to link two contract types.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def __init__(self, message=&quot;Unable to link contract types&quot;):</span>
<span class="gi">+        super().__init__(message)</span>
<span class="gh">diff --git a/web3/tools/pytest_ethereum/linker.py b/web3/tools/pytest_ethereum/linker.py</span>
<span class="gh">index 8a276c1e..b9874cd6 100644</span>
<span class="gd">--- a/web3/tools/pytest_ethereum/linker.py</span>
<span class="gi">+++ b/web3/tools/pytest_ethereum/linker.py</span>
<span class="gu">@@ -18,7 +18,42 @@ def deploy(contract_name: str, *args: Any, transaction: Dict[str, Any]=None</span>
<span class="w"> </span>    a deployment is found on the current w3 instance, it will return that deployment
<span class="w"> </span>    rather than creating a new instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _deploy(package: Package) -&gt; Package:</span>
<span class="gi">+        deployments = package.deployments</span>
<span class="gi">+        if contract_name in deployments:</span>
<span class="gi">+            return package</span>
<span class="gi">+</span>
<span class="gi">+        factory = package.get_contract_factory(contract_name)</span>
<span class="gi">+        if not factory:</span>
<span class="gi">+            raise LinkerError(f&quot;Contract factory for {contract_name} not found in package.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        w3 = package.w3</span>
<span class="gi">+        if transaction is None:</span>
<span class="gi">+            deploy_transaction = {}</span>
<span class="gi">+        else:</span>
<span class="gi">+            deploy_transaction = transaction.copy()</span>
<span class="gi">+        </span>
<span class="gi">+        if &quot;from&quot; not in deploy_transaction:</span>
<span class="gi">+            deploy_transaction[&quot;from&quot;] = w3.eth.accounts[0]</span>
<span class="gi">+</span>
<span class="gi">+        tx_hash = factory.constructor(*args).transact(deploy_transaction)</span>
<span class="gi">+        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)</span>
<span class="gi">+        address = tx_receipt[&quot;contractAddress&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        deployment_data = create_deployment_data(</span>
<span class="gi">+            contract_name,</span>
<span class="gi">+            to_checksum_address(address),</span>
<span class="gi">+            tx_receipt,</span>
<span class="gi">+        )</span>
<span class="gi">+        latest_block_uri = create_latest_block_uri(w3, tx_receipt)</span>
<span class="gi">+        return insert_deployment(</span>
<span class="gi">+            package,</span>
<span class="gi">+            contract_name,</span>
<span class="gi">+            deployment_data,</span>
<span class="gi">+            latest_block_uri</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return _deploy</span>


<span class="w"> </span>@curry
<span class="gu">@@ -27,7 +62,27 @@ def link(contract: ContractName, linked_type: str, package: Package) -&gt;Package:</span>
<span class="w"> </span>    Return a new package, created with a new manifest after applying the linked type
<span class="w"> </span>    reference to the contract factory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    deployment_address = get_deployment_address(package, linked_type)</span>
<span class="gi">+    if not deployment_address:</span>
<span class="gi">+        raise LinkerError(f&quot;No deployment found for contract {linked_type}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    factory = package.get_contract_factory(contract)</span>
<span class="gi">+    if not factory:</span>
<span class="gi">+        raise LinkerError(f&quot;Contract factory for {contract} not found in package.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    linked_factory = factory.link_bytecode({linked_type: deployment_address})</span>
<span class="gi">+</span>
<span class="gi">+    # Update the contract factory in the package</span>
<span class="gi">+    updated_manifest = pipe(</span>
<span class="gi">+        package.manifest,</span>
<span class="gi">+        lambda manifest: assoc_in(</span>
<span class="gi">+            manifest,</span>
<span class="gi">+            [&quot;contract_types&quot;, contract, &quot;deployment_bytecode&quot;, &quot;bytecode&quot;],</span>
<span class="gi">+            to_hex(linked_factory.bytecode)</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return Package(updated_manifest, package.w3)</span>


<span class="w"> </span>@curry
<span class="gu">@@ -36,4 +91,5 @@ def run_python(callback_fn: Callable[..., None], package: Package) -&gt;Package:</span>
<span class="w"> </span>    Return the unmodified package, after performing any user-defined
<span class="w"> </span>    callback function on the contracts in the package.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    callback_fn(package)</span>
<span class="gi">+    return package</span>
<span class="gh">diff --git a/web3/tools/pytest_ethereum/plugins.py b/web3/tools/pytest_ethereum/plugins.py</span>
<span class="gh">index 92f8e27d..bdad0ee5 100644</span>
<span class="gd">--- a/web3/tools/pytest_ethereum/plugins.py</span>
<span class="gi">+++ b/web3/tools/pytest_ethereum/plugins.py</span>
<span class="gu">@@ -8,9 +8,14 @@ from web3.tools.pytest_ethereum.deployer import Deployer</span>


<span class="w"> </span>@pytest.fixture
<span class="gd">-def deployer(w3: Web3) -&gt;Callable[[Path], Deployer]:</span>
<span class="gi">+def deployer(w3: Web3) -&gt; Callable[[Path], Deployer]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a `Deployer` instance composed from a `Package` instance
<span class="w"> </span>    generated from the manifest located at the provided `path` folder.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _deployer(path: Path) -&gt; Deployer:</span>
<span class="gi">+        manifest = json.loads(path.read_text())</span>
<span class="gi">+        package = Package(manifest, w3)</span>
<span class="gi">+        return Deployer(package)</span>
<span class="gi">+    </span>
<span class="gi">+    return _deployer</span>
<span class="gh">diff --git a/web3/utils/address.py b/web3/utils/address.py</span>
<span class="gh">index dcb5fa09..56ed2dee 100644</span>
<span class="gd">--- a/web3/utils/address.py</span>
<span class="gi">+++ b/web3/utils/address.py</span>
<span class="gu">@@ -8,7 +8,10 @@ def get_create_address(sender: HexAddress, nonce: Nonce) -&gt;ChecksumAddress:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Determine the resulting `CREATE` opcode contract address for a sender and a nonce.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sender_bytes = to_bytes(hexstr=sender)</span>
<span class="gi">+    nonce_bytes = rlp.encode(nonce)</span>
<span class="gi">+    raw_address = keccak(rlp.encode([sender_bytes, nonce_bytes]))</span>
<span class="gi">+    return to_checksum_address(raw_address[12:])</span>


<span class="w"> </span>def get_create2_address(sender: HexAddress, salt: HexStr, init_code: HexStr
<span class="gu">@@ -17,4 +20,10 @@ def get_create2_address(sender: HexAddress, salt: HexStr, init_code: HexStr</span>
<span class="w"> </span>    Determine the resulting `CREATE2` opcode contract address for a sender, salt and
<span class="w"> </span>    bytecode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    prefix = b&#39;\xff&#39;</span>
<span class="gi">+    sender_bytes = to_bytes(hexstr=sender)</span>
<span class="gi">+    salt_bytes = to_bytes(hexstr=salt)</span>
<span class="gi">+    init_code_bytes = to_bytes(hexstr=init_code)</span>
<span class="gi">+    init_code_hash = keccak(init_code_bytes)</span>
<span class="gi">+    raw_address = keccak(prefix + sender_bytes + salt_bytes + init_code_hash)</span>
<span class="gi">+    return to_checksum_address(raw_address[12:])</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>