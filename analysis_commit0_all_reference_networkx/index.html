
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference networkx - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-networkx" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference networkx
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-networkx" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test networkx
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_pylabpytest_draw_networkx_edges_multiedge_connectionstyleg1-4" class="md-nav__link">
    <span class="md-ellipsis">
      test_pylab.py::test_draw_networkx_edges_multiedge_connectionstyle[G1-4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pylabpytest_draw_networkx_edges_multiedge_connectionstyleg2-4" class="md-nav__link">
    <span class="md-ellipsis">
      test_pylab.py::test_draw_networkx_edges_multiedge_connectionstyle[G2-4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pylabpytest_draw_networkx_edge_labels_multiedge_connectionstyleg1-4" class="md-nav__link">
    <span class="md-ellipsis">
      test_pylab.py::test_draw_networkx_edge_labels_multiedge_connectionstyle[G1-4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pylabpytest_draw_networkx_edge_labels_multiedge_connectionstyleg2-4" class="md-nav__link">
    <span class="md-ellipsis">
      test_pylab.py::test_draw_networkx_edge_labels_multiedge_connectionstyle[G2-4]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-networkx"><strong>Reference (Gold)</strong>: networkx</h1>
<h2 id="pytest-summary-for-test-networkx">Pytest Summary for test <code>networkx</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">5436</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">53</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">5493</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">10986</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_pylabpytest_draw_networkx_edges_multiedge_connectionstyleg1-4">test_pylab.py::test_draw_networkx_edges_multiedge_connectionstyle[G1-4]</h3>
<details><summary> <pre>test_pylab.py::test_draw_networkx_edges_multiedge_connectionstyle[G1-4]</pre></summary><pre>
G = <networkx.classes.multigraph.MultiGraph object at 0x7f22704056a0>
expected_n_edges = 4

    @pytest.mark.parametrize(
        ("G", "expected_n_edges"),
        ([nx.DiGraph(), 2], [nx.MultiGraph(), 4], [nx.MultiDiGraph(), 4]),
    )
    def test_draw_networkx_edges_multiedge_connectionstyle(G, expected_n_edges):
        """Draws edges correctly for 3 types of graphs and checks for valid length"""
        for i, (u, v) in enumerate([(0, 1), (0, 1), (0, 1), (0, 2)]):
            G.add_edge(u, v, weight=round(i / 3, 2))
        pos = {n: (n, n) for n in G}
        # Raises on insuficient connectionstyle length
        for conn_style in [
            "arc3,rad=0.1",
            ["arc3,rad=0.1", "arc3,rad=0.1"],
            ["arc3,rad=0.1", "arc3,rad=0.1", "arc3,rad=0.2"],
        ]:
            nx.draw_networkx_edges(G, pos, connectionstyle=conn_style)
            arrows = nx.draw_networkx_edges(G, pos, connectionstyle=conn_style)
>           assert len(arrows) == expected_n_edges
E           assert 8 == 4
E            +  where 8 = len([<matplotlib.patches.FancyArrowPatch object at 0x7f22640351c0>, <matplotlib.patches.FancyArrowPatch object at 0x7f2259....patches.FancyArrowPatch object at 0x7f2259355100>, <matplotlib.patches.FancyArrowPatch object at 0x7f225afbefc0>, ...])

networkx/drawing/tests/test_pylab.py:732: AssertionError
</pre>
</details>
<h3 id="test_pylabpytest_draw_networkx_edges_multiedge_connectionstyleg2-4">test_pylab.py::test_draw_networkx_edges_multiedge_connectionstyle[G2-4]</h3>
<details><summary> <pre>test_pylab.py::test_draw_networkx_edges_multiedge_connectionstyle[G2-4]</pre></summary><pre>
G = <networkx.classes.multidigraph.MultiDiGraph object at 0x7f2270405670>
expected_n_edges = 4

    @pytest.mark.parametrize(
        ("G", "expected_n_edges"),
        ([nx.DiGraph(), 2], [nx.MultiGraph(), 4], [nx.MultiDiGraph(), 4]),
    )
    def test_draw_networkx_edges_multiedge_connectionstyle(G, expected_n_edges):
        """Draws edges correctly for 3 types of graphs and checks for valid length"""
        for i, (u, v) in enumerate([(0, 1), (0, 1), (0, 1), (0, 2)]):
            G.add_edge(u, v, weight=round(i / 3, 2))
        pos = {n: (n, n) for n in G}
        # Raises on insuficient connectionstyle length
        for conn_style in [
            "arc3,rad=0.1",
            ["arc3,rad=0.1", "arc3,rad=0.1"],
            ["arc3,rad=0.1", "arc3,rad=0.1", "arc3,rad=0.2"],
        ]:
            nx.draw_networkx_edges(G, pos, connectionstyle=conn_style)
            arrows = nx.draw_networkx_edges(G, pos, connectionstyle=conn_style)
>           assert len(arrows) == expected_n_edges
E           assert 8 == 4
E            +  where 8 = len([<matplotlib.patches.FancyArrowPatch object at 0x7f2255bab4a0>, <matplotlib.patches.FancyArrowPatch object at 0x7f2259....patches.FancyArrowPatch object at 0x7f225a3461b0>, <matplotlib.patches.FancyArrowPatch object at 0x7f2259a0e180>, ...])

networkx/drawing/tests/test_pylab.py:732: AssertionError
</pre>
</details>
<h3 id="test_pylabpytest_draw_networkx_edge_labels_multiedge_connectionstyleg1-4">test_pylab.py::test_draw_networkx_edge_labels_multiedge_connectionstyle[G1-4]</h3>
<details><summary> <pre>test_pylab.py::test_draw_networkx_edge_labels_multiedge_connectionstyle[G1-4]</pre></summary><pre>
G = <networkx.classes.multigraph.MultiGraph object at 0x7f2270405970>
expected_n_edges = 4

    @pytest.mark.parametrize(
        ("G", "expected_n_edges"),
        ([nx.DiGraph(), 2], [nx.MultiGraph(), 4], [nx.MultiDiGraph(), 4]),
    )
    def test_draw_networkx_edge_labels_multiedge_connectionstyle(G, expected_n_edges):
        """Draws labels correctly for 3 types of graphs and checks for valid length and class names"""
        for i, (u, v) in enumerate([(0, 1), (0, 1), (0, 1), (0, 2)]):
            G.add_edge(u, v, weight=round(i / 3, 2))
        pos = {n: (n, n) for n in G}
        # Raises on insuficient connectionstyle length
        arrows = nx.draw_networkx_edges(
            G, pos, connectionstyle=["arc3,rad=0.1", "arc3,rad=0.1", "arc3,rad=0.1"]
        )
        for conn_style in [
            "arc3,rad=0.1",
            ["arc3,rad=0.1", "arc3,rad=0.2"],
            ["arc3,rad=0.1", "arc3,rad=0.1", "arc3,rad=0.1"],
        ]:
            text_items = nx.draw_networkx_edge_labels(G, pos, connectionstyle=conn_style)
>           assert len(text_items) == expected_n_edges
E           assert 8 == 4
E            +  where 8 = len({(0, 1, 0): Text(0.5372660379084617, 0.4329084063193035, "{'weight': 0.0}"), (0, 1, 1): Text(0.5372660379084617, 0.432...4329084063193035, "{'weight': 0.67}"), (0, 1, 3): Text(0.5372660379084617, 0.4329084063193035, "{'weight': 0.0}"), ...})

networkx/drawing/tests/test_pylab.py:754: AssertionError
</pre>
</details>
<h3 id="test_pylabpytest_draw_networkx_edge_labels_multiedge_connectionstyleg2-4">test_pylab.py::test_draw_networkx_edge_labels_multiedge_connectionstyle[G2-4]</h3>
<details><summary> <pre>test_pylab.py::test_draw_networkx_edge_labels_multiedge_connectionstyle[G2-4]</pre></summary><pre>
G = <networkx.classes.multidigraph.MultiDiGraph object at 0x7f2270405850>
expected_n_edges = 4

    @pytest.mark.parametrize(
        ("G", "expected_n_edges"),
        ([nx.DiGraph(), 2], [nx.MultiGraph(), 4], [nx.MultiDiGraph(), 4]),
    )
    def test_draw_networkx_edge_labels_multiedge_connectionstyle(G, expected_n_edges):
        """Draws labels correctly for 3 types of graphs and checks for valid length and class names"""
        for i, (u, v) in enumerate([(0, 1), (0, 1), (0, 1), (0, 2)]):
            G.add_edge(u, v, weight=round(i / 3, 2))
        pos = {n: (n, n) for n in G}
        # Raises on insuficient connectionstyle length
        arrows = nx.draw_networkx_edges(
            G, pos, connectionstyle=["arc3,rad=0.1", "arc3,rad=0.1", "arc3,rad=0.1"]
        )
        for conn_style in [
            "arc3,rad=0.1",
            ["arc3,rad=0.1", "arc3,rad=0.2"],
            ["arc3,rad=0.1", "arc3,rad=0.1", "arc3,rad=0.1"],
        ]:
            text_items = nx.draw_networkx_edge_labels(G, pos, connectionstyle=conn_style)
>           assert len(text_items) == expected_n_edges
E           assert 8 == 4
E            +  where 8 = len({(0, 1, 0): Text(0.5372660379084617, 0.4329084063193035, "{'weight': 0.0}"), (0, 1, 1): Text(0.5372660379084617, 0.432...4329084063193035, "{'weight': 0.67}"), (0, 1, 3): Text(0.5372660379084617, 0.4329084063193035, "{'weight': 0.0}"), ...})

networkx/drawing/tests/test_pylab.py:754: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/networkx/algorithms/approximation/clique.py b/networkx/algorithms/approximation/clique.py</span>
<span class="gh">index 78320db44..564430686 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/clique.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/clique.py</span>
<span class="gu">@@ -2,12 +2,17 @@</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.approximation import ramsey
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;clique_removal&#39;, &#39;max_clique&#39;, &#39;large_clique_size&#39;,</span>
<span class="gd">-    &#39;maximum_independent_set&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;clique_removal&quot;,</span>
<span class="gi">+    &quot;max_clique&quot;,</span>
<span class="gi">+    &quot;large_clique_size&quot;,</span>
<span class="gi">+    &quot;maximum_independent_set&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def maximum_independent_set(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns an approximate maximum independent set.
<span class="gu">@@ -59,14 +64,15 @@ def maximum_independent_set(G):</span>
<span class="w"> </span>       Approximating maximum independent sets by excluding subgraphs.
<span class="w"> </span>       BIT Numerical Mathematics, 32(2), 180–196. Springer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    iset, _ = clique_removal(G)</span>
<span class="gi">+    return iset</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def max_clique(G):
<span class="gd">-    &quot;&quot;&quot;Find the Maximum Clique</span>
<span class="gi">+    r&quot;&quot;&quot;Find the Maximum Clique</span>

<span class="w"> </span>    Finds the $O(|V|/(log|V|)^2)$ apx of maximum clique/independent set
<span class="w"> </span>    in the worst case.
<span class="gu">@@ -95,13 +101,13 @@ def max_clique(G):</span>
<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="w"> </span>    A clique in an undirected graph G = (V, E) is a subset of the vertex set
<span class="gd">-    `C \\subseteq V` such that for every two vertices in C there exists an edge</span>
<span class="gi">+    `C \subseteq V` such that for every two vertices in C there exists an edge</span>
<span class="w"> </span>    connecting the two. This is equivalent to saying that the subgraph
<span class="w"> </span>    induced by C is complete (in some cases, the term clique may also refer
<span class="w"> </span>    to the subgraph).

<span class="w"> </span>    A maximum clique is a clique of the largest possible size in a given graph.
<span class="gd">-    The clique number `\\omega(G)` of a graph G is the number of</span>
<span class="gi">+    The clique number `\omega(G)` of a graph G is the number of</span>
<span class="w"> </span>    vertices in a maximum clique in G. The intersection number of
<span class="w"> </span>    G is the smallest number of cliques that together cover all edges of G.

<span class="gu">@@ -114,16 +120,20 @@ def max_clique(G):</span>
<span class="w"> </span>        BIT Numerical Mathematics, 32(2), 180–196. Springer.
<span class="w"> </span>        doi:10.1007/BF01994876
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # finding the maximum clique in a graph is equivalent to finding</span>
<span class="gi">+    # the independent set in the complementary graph</span>
<span class="gi">+    cgraph = nx.complement(G)</span>
<span class="gi">+    iset, _ = clique_removal(cgraph)</span>
<span class="gi">+    return iset</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def clique_removal(G):
<span class="gd">-    &quot;&quot;&quot;Repeatedly remove cliques from the graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Repeatedly remove cliques from the graph.</span>

<span class="gd">-    Results in a $O(|V|/(\\log |V|)^2)$ approximation of maximum clique</span>
<span class="gi">+    Results in a $O(|V|/(\log |V|)^2)$ approximation of maximum clique</span>
<span class="w"> </span>    and independent set. Returns the largest independent set found, along
<span class="w"> </span>    with found maximal cliques.

<span class="gu">@@ -154,11 +164,24 @@ def clique_removal(G):</span>
<span class="w"> </span>        Approximating maximum independent sets by excluding subgraphs.
<span class="w"> </span>        BIT Numerical Mathematics, 32(2), 180–196. Springer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    graph = G.copy()</span>
<span class="gi">+    c_i, i_i = ramsey.ramsey_R2(graph)</span>
<span class="gi">+    cliques = [c_i]</span>
<span class="gi">+    isets = [i_i]</span>
<span class="gi">+    while graph:</span>
<span class="gi">+        graph.remove_nodes_from(c_i)</span>
<span class="gi">+        c_i, i_i = ramsey.ramsey_R2(graph)</span>
<span class="gi">+        if c_i:</span>
<span class="gi">+            cliques.append(c_i)</span>
<span class="gi">+        if i_i:</span>
<span class="gi">+            isets.append(i_i)</span>
<span class="gi">+    # Determine the largest independent set as measured by cardinality.</span>
<span class="gi">+    maxiset = max(isets, key=len)</span>
<span class="gi">+    return maxiset, cliques</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def large_clique_size(G):
<span class="w"> </span>    &quot;&quot;&quot;Find the size of a large clique in a graph.
<span class="gu">@@ -217,4 +240,19 @@ def large_clique_size(G):</span>
<span class="w"> </span>        Functions for finding the exact maximum clique in a graph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    degrees = G.degree</span>
<span class="gi">+</span>
<span class="gi">+    def _clique_heuristic(G, U, size, best_size):</span>
<span class="gi">+        if not U:</span>
<span class="gi">+            return max(best_size, size)</span>
<span class="gi">+        u = max(U, key=degrees)</span>
<span class="gi">+        U.remove(u)</span>
<span class="gi">+        N_prime = {v for v in G[u] if degrees[v] &gt;= best_size}</span>
<span class="gi">+        return _clique_heuristic(G, U &amp; N_prime, size + 1, best_size)</span>
<span class="gi">+</span>
<span class="gi">+    best_size = 0</span>
<span class="gi">+    nodes = (u for u in G if degrees[u] &gt;= best_size)</span>
<span class="gi">+    for u in nodes:</span>
<span class="gi">+        neighbors = {v for v in G[u] if degrees[v] &gt;= best_size}</span>
<span class="gi">+        best_size = _clique_heuristic(G, neighbors, 1, best_size)</span>
<span class="gi">+    return best_size</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/clustering_coefficient.py b/networkx/algorithms/approximation/clustering_coefficient.py</span>
<span class="gh">index 30a71d1a9..545fc6553 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/clustering_coefficient.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/clustering_coefficient.py</span>
<span class="gu">@@ -1,13 +1,14 @@</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;average_clustering&#39;]</span>

<span class="gi">+__all__ = [&quot;average_clustering&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@py_random_state(2)
<span class="gd">-@nx._dispatchable(name=&#39;approximate_average_clustering&#39;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;approximate_average_clustering&quot;)</span>
<span class="w"> </span>def average_clustering(G, trials=1000, seed=None):
<span class="gd">-    &quot;&quot;&quot;Estimates the average clustering coefficient of G.</span>
<span class="gi">+    r&quot;&quot;&quot;Estimates the average clustering coefficient of G.</span>

<span class="w"> </span>    The local clustering of each node in `G` is the fraction of triangles
<span class="w"> </span>    that actually exist over all possible triangles in its neighborhood.
<span class="gu">@@ -57,4 +58,14 @@ def average_clustering(G, trials=1000, seed=None):</span>
<span class="w"> </span>       https://doi.org/10.5445/IR/1000001239

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    triangles = 0</span>
<span class="gi">+    nodes = list(G)</span>
<span class="gi">+    for i in [int(seed.random() * n) for i in range(trials)]:</span>
<span class="gi">+        nbrs = list(G[nodes[i]])</span>
<span class="gi">+        if len(nbrs) &lt; 2:</span>
<span class="gi">+            continue</span>
<span class="gi">+        u, v = seed.sample(nbrs, 2)</span>
<span class="gi">+        if u in G[v]:</span>
<span class="gi">+            triangles += 1</span>
<span class="gi">+    return triangles / trials</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/connectivity.py b/networkx/algorithms/approximation/connectivity.py</span>
<span class="gh">index cd88c5219..a2214ed12 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/connectivity.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/connectivity.py</span>
<span class="gu">@@ -2,12 +2,17 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import itertools
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;local_node_connectivity&#39;, &#39;node_connectivity&#39;,</span>
<span class="gd">-    &#39;all_pairs_node_connectivity&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;local_node_connectivity&quot;,</span>
<span class="gi">+    &quot;node_connectivity&quot;,</span>
<span class="gi">+    &quot;all_pairs_node_connectivity&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@nx._dispatchable(name=&#39;approximate_local_node_connectivity&#39;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;approximate_local_node_connectivity&quot;)</span>
<span class="w"> </span>def local_node_connectivity(G, source, target, cutoff=None):
<span class="w"> </span>    &quot;&quot;&quot;Compute node connectivity between source and target.

<span class="gu">@@ -75,12 +80,37 @@ def local_node_connectivity(G, source, target, cutoff=None):</span>
<span class="w"> </span>        http://eclectic.ss.uci.edu/~drwhite/working.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if target == source:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;source and target have to be different nodes.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Maximum possible node independent paths</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        possible = min(G.out_degree(source), G.in_degree(target))</span>
<span class="gi">+    else:</span>
<span class="gi">+        possible = min(G.degree(source), G.degree(target))</span>
<span class="gi">+</span>
<span class="gi">+    K = 0</span>
<span class="gi">+    if not possible:</span>
<span class="gi">+        return K</span>
<span class="gi">+</span>
<span class="gi">+    if cutoff is None:</span>
<span class="gi">+        cutoff = float(&quot;inf&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    exclude = set()</span>
<span class="gi">+    for i in range(min(possible, cutoff)):</span>
<span class="gi">+        try:</span>
<span class="gi">+            path = _bidirectional_shortest_path(G, source, target, exclude)</span>
<span class="gi">+            exclude.update(set(path))</span>
<span class="gi">+            K += 1</span>
<span class="gi">+        except nx.NetworkXNoPath:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return K</span>


<span class="gd">-@nx._dispatchable(name=&#39;approximate_node_connectivity&#39;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;approximate_node_connectivity&quot;)</span>
<span class="w"> </span>def node_connectivity(G, s=None, t=None):
<span class="gd">-    &quot;&quot;&quot;Returns an approximation for node connectivity for a graph or digraph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns an approximation for node connectivity for a graph or digraph G.</span>

<span class="w"> </span>    Node connectivity is equal to the minimum number of nodes that
<span class="w"> </span>    must be removed to disconnect G or render it trivial. By Menger&#39;s theorem,
<span class="gu">@@ -142,10 +172,49 @@ def node_connectivity(G, s=None, t=None):</span>
<span class="w"> </span>        http://eclectic.ss.uci.edu/~drwhite/working.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(name=&#39;approximate_all_pairs_node_connectivity&#39;)</span>
<span class="gi">+    if (s is not None and t is None) or (s is None and t is not None):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Both source and target must be specified.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Local node connectivity</span>
<span class="gi">+    if s is not None and t is not None:</span>
<span class="gi">+        if s not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {s} not in graph&quot;)</span>
<span class="gi">+        if t not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {t} not in graph&quot;)</span>
<span class="gi">+        return local_node_connectivity(G, s, t)</span>
<span class="gi">+</span>
<span class="gi">+    # Global node connectivity</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        connected_func = nx.is_weakly_connected</span>
<span class="gi">+        iter_func = itertools.permutations</span>
<span class="gi">+</span>
<span class="gi">+        def neighbors(v):</span>
<span class="gi">+            return itertools.chain(G.predecessors(v), G.successors(v))</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        connected_func = nx.is_connected</span>
<span class="gi">+        iter_func = itertools.combinations</span>
<span class="gi">+        neighbors = G.neighbors</span>
<span class="gi">+</span>
<span class="gi">+    if not connected_func(G):</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    # Choose a node with minimum degree</span>
<span class="gi">+    v, minimum_degree = min(G.degree(), key=itemgetter(1))</span>
<span class="gi">+    # Node connectivity is bounded by minimum degree</span>
<span class="gi">+    K = minimum_degree</span>
<span class="gi">+    # compute local node connectivity with all non-neighbors nodes</span>
<span class="gi">+    # and store the minimum</span>
<span class="gi">+    for w in set(G) - set(neighbors(v)) - {v}:</span>
<span class="gi">+        K = min(K, local_node_connectivity(G, v, w, cutoff=K))</span>
<span class="gi">+    # Same for non adjacent pairs of neighbors of v</span>
<span class="gi">+    for x, y in iter_func(neighbors(v), 2):</span>
<span class="gi">+        if y not in G[x] and x != y:</span>
<span class="gi">+            K = min(K, local_node_connectivity(G, x, y, cutoff=K))</span>
<span class="gi">+    return K</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(name=&quot;approximate_all_pairs_node_connectivity&quot;)</span>
<span class="w"> </span>def all_pairs_node_connectivity(G, nbunch=None, cutoff=None):
<span class="w"> </span>    &quot;&quot;&quot;Compute node connectivity between all pairs of nodes.

<span class="gu">@@ -203,7 +272,26 @@ def all_pairs_node_connectivity(G, nbunch=None, cutoff=None):</span>
<span class="w"> </span>        Node-Independent Paths. Santa Fe Institute Working Paper #01-07-035
<span class="w"> </span>        http://eclectic.ss.uci.edu/~drwhite/working.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nbunch is None:</span>
<span class="gi">+        nbunch = G</span>
<span class="gi">+    else:</span>
<span class="gi">+        nbunch = set(nbunch)</span>
<span class="gi">+</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        iter_func = itertools.permutations</span>
<span class="gi">+    else:</span>
<span class="gi">+        iter_func = itertools.combinations</span>
<span class="gi">+</span>
<span class="gi">+    all_pairs = {n: {} for n in nbunch}</span>
<span class="gi">+</span>
<span class="gi">+    for u, v in iter_func(nbunch, 2):</span>
<span class="gi">+        k = local_node_connectivity(G, u, v, cutoff=cutoff)</span>
<span class="gi">+        all_pairs[u][v] = k</span>
<span class="gi">+        if not directed:</span>
<span class="gi">+            all_pairs[v][u] = k</span>
<span class="gi">+</span>
<span class="gi">+    return all_pairs</span>


<span class="w"> </span>def _bidirectional_shortest_path(G, source, target, exclude):
<span class="gu">@@ -249,4 +337,76 @@ def _bidirectional_shortest_path(G, source, target, exclude):</span>
<span class="w"> </span>        http://eclectic.ss.uci.edu/~drwhite/working.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # call helper to do the real work</span>
<span class="gi">+    results = _bidirectional_pred_succ(G, source, target, exclude)</span>
<span class="gi">+    pred, succ, w = results</span>
<span class="gi">+</span>
<span class="gi">+    # build path from pred+w+succ</span>
<span class="gi">+    path = []</span>
<span class="gi">+    # from source to w</span>
<span class="gi">+    while w is not None:</span>
<span class="gi">+        path.append(w)</span>
<span class="gi">+        w = pred[w]</span>
<span class="gi">+    path.reverse()</span>
<span class="gi">+    # from w to target</span>
<span class="gi">+    w = succ[path[-1]]</span>
<span class="gi">+    while w is not None:</span>
<span class="gi">+        path.append(w)</span>
<span class="gi">+        w = succ[w]</span>
<span class="gi">+</span>
<span class="gi">+    return path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _bidirectional_pred_succ(G, source, target, exclude):</span>
<span class="gi">+    # does BFS from both source and target and meets in the middle</span>
<span class="gi">+    # excludes nodes in the container &quot;exclude&quot; from the search</span>
<span class="gi">+</span>
<span class="gi">+    # handle either directed or undirected</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        Gpred = G.predecessors</span>
<span class="gi">+        Gsucc = G.successors</span>
<span class="gi">+    else:</span>
<span class="gi">+        Gpred = G.neighbors</span>
<span class="gi">+        Gsucc = G.neighbors</span>
<span class="gi">+</span>
<span class="gi">+    # predecessor and successors in search</span>
<span class="gi">+    pred = {source: None}</span>
<span class="gi">+    succ = {target: None}</span>
<span class="gi">+</span>
<span class="gi">+    # initialize fringes, start with forward</span>
<span class="gi">+    forward_fringe = [source]</span>
<span class="gi">+    reverse_fringe = [target]</span>
<span class="gi">+</span>
<span class="gi">+    level = 0</span>
<span class="gi">+</span>
<span class="gi">+    while forward_fringe and reverse_fringe:</span>
<span class="gi">+        # Make sure that we iterate one step forward and one step backwards</span>
<span class="gi">+        # thus source and target will only trigger &quot;found path&quot; when they are</span>
<span class="gi">+        # adjacent and then they can be safely included in the container &#39;exclude&#39;</span>
<span class="gi">+        level += 1</span>
<span class="gi">+        if level % 2 != 0:</span>
<span class="gi">+            this_level = forward_fringe</span>
<span class="gi">+            forward_fringe = []</span>
<span class="gi">+            for v in this_level:</span>
<span class="gi">+                for w in Gsucc(v):</span>
<span class="gi">+                    if w in exclude:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if w not in pred:</span>
<span class="gi">+                        forward_fringe.append(w)</span>
<span class="gi">+                        pred[w] = v</span>
<span class="gi">+                    if w in succ:</span>
<span class="gi">+                        return pred, succ, w  # found path</span>
<span class="gi">+        else:</span>
<span class="gi">+            this_level = reverse_fringe</span>
<span class="gi">+            reverse_fringe = []</span>
<span class="gi">+            for v in this_level:</span>
<span class="gi">+                for w in Gpred(v):</span>
<span class="gi">+                    if w in exclude:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if w not in succ:</span>
<span class="gi">+                        succ[w] = v</span>
<span class="gi">+                        reverse_fringe.append(w)</span>
<span class="gi">+                    if w in pred:</span>
<span class="gi">+                        return pred, succ, w  # found path</span>
<span class="gi">+</span>
<span class="gi">+    raise nx.NetworkXNoPath(f&quot;No path between {source} and {target}.&quot;)</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/distance_measures.py b/networkx/algorithms/approximation/distance_measures.py</span>
<span class="gh">index 8f95ba3f3..d5847e65a 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/distance_measures.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/distance_measures.py</span>
<span class="gu">@@ -1,11 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Distance measures approximated metrics.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils.decorators import py_random_state
<span class="gd">-__all__ = [&#39;diameter&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;diameter&quot;]</span>


<span class="w"> </span>@py_random_state(1)
<span class="gd">-@nx._dispatchable(name=&#39;approximate_diameter&#39;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;approximate_diameter&quot;)</span>
<span class="w"> </span>def diameter(G, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a lower bound on the diameter of the graph G.

<span class="gu">@@ -69,7 +71,17 @@ def diameter(G, seed=None):</span>
<span class="w"> </span>       International Symposium on Experimental Algorithms. Springer, Berlin, Heidelberg, 2012.
<span class="w"> </span>       https://courses.cs.ut.ee/MTAT.03.238/2014_fall/uploads/Main/diameter.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # if G is empty</span>
<span class="gi">+    if not G:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Expected non-empty NetworkX graph!&quot;)</span>
<span class="gi">+    # if there&#39;s only a node</span>
<span class="gi">+    if G.number_of_nodes() == 1:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    # if G is directed</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        return _two_sweep_directed(G, seed)</span>
<span class="gi">+    # else if G is undirected</span>
<span class="gi">+    return _two_sweep_undirected(G, seed)</span>


<span class="w"> </span>def _two_sweep_undirected(G, seed):
<span class="gu">@@ -85,7 +97,17 @@ def _two_sweep_undirected(G, seed):</span>

<span class="w"> </span>        ``seed`` is a random.Random or numpy.random.RandomState instance
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # select a random source node</span>
<span class="gi">+    source = seed.choice(list(G))</span>
<span class="gi">+    # get the distances to the other nodes</span>
<span class="gi">+    distances = nx.shortest_path_length(G, source)</span>
<span class="gi">+    # if some nodes have not been visited, then the graph is not connected</span>
<span class="gi">+    if len(distances) != len(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph not connected.&quot;)</span>
<span class="gi">+    # take a node that is (one of) the farthest nodes from the source</span>
<span class="gi">+    *_, node = distances</span>
<span class="gi">+    # return the eccentricity of the node</span>
<span class="gi">+    return nx.eccentricity(G, node)</span>


<span class="w"> </span>def _two_sweep_directed(G, seed):
<span class="gu">@@ -107,4 +129,22 @@ def _two_sweep_directed(G, seed):</span>

<span class="w"> </span>        ``seed`` is a random.Random or numpy.random.RandomState instance
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # get a new digraph G&#39; with the edges reversed in the opposite direction</span>
<span class="gi">+    G_reversed = G.reverse()</span>
<span class="gi">+    # select a random source node</span>
<span class="gi">+    source = seed.choice(list(G))</span>
<span class="gi">+    # compute forward distances from source</span>
<span class="gi">+    forward_distances = nx.shortest_path_length(G, source)</span>
<span class="gi">+    # compute backward distances  from source</span>
<span class="gi">+    backward_distances = nx.shortest_path_length(G_reversed, source)</span>
<span class="gi">+    # if either the source can&#39;t reach every node or not every node</span>
<span class="gi">+    # can reach the source, then the graph is not strongly connected</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    if len(forward_distances) != n or len(backward_distances) != n:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;DiGraph not strongly connected.&quot;)</span>
<span class="gi">+    # take a node a_1 at the maximum distance from the source in G</span>
<span class="gi">+    *_, a_1 = forward_distances</span>
<span class="gi">+    # take a node a_2 at the maximum distance from the source in G_reversed</span>
<span class="gi">+    *_, a_2 = backward_distances</span>
<span class="gi">+    # return the max between the backward eccentricity of a_1 and the forward eccentricity of a_2</span>
<span class="gi">+    return max(nx.eccentricity(G_reversed, a_1), nx.eccentricity(G, a_2))</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/dominating_set.py b/networkx/algorithms/approximation/dominating_set.py</span>
<span class="gh">index 92411f7e6..06ab97d97 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/dominating_set.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/dominating_set.py</span>
<span class="gu">@@ -11,15 +11,18 @@ incident to an endpoint of at least one edge in *F*.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from ...utils import not_implemented_for
<span class="w"> </span>from ..matching import maximal_matching
<span class="gd">-__all__ = [&#39;min_weighted_dominating_set&#39;, &#39;min_edge_dominating_set&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;min_weighted_dominating_set&quot;, &quot;min_edge_dominating_set&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(node_attrs=&#39;weight&#39;)</span>
<span class="gi">+# TODO Why doesn&#39;t this algorithm work for directed graphs?</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def min_weighted_dominating_set(G, weight=None):
<span class="gd">-    &quot;&quot;&quot;Returns a dominating set that approximates the minimum weight node</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a dominating set that approximates the minimum weight node</span>
<span class="w"> </span>    dominating set.

<span class="w"> </span>    Parameters
<span class="gu">@@ -35,7 +38,7 @@ def min_weighted_dominating_set(G, weight=None):</span>
<span class="w"> </span>    Returns
<span class="w"> </span>    -------
<span class="w"> </span>    min_weight_dominating_set : set
<span class="gd">-        A set of nodes, the sum of whose weights is no more than `(\\log</span>
<span class="gi">+        A set of nodes, the sum of whose weights is no more than `(\log</span>
<span class="w"> </span>        w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of
<span class="w"> </span>        each node in the graph and `w(V^*)` denotes the sum of the
<span class="w"> </span>        weights of each node in the minimum weight dominating set.
<span class="gu">@@ -54,7 +57,7 @@ def min_weighted_dominating_set(G, weight=None):</span>
<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="w"> </span>    This algorithm computes an approximate minimum weighted dominating
<span class="gd">-    set for the graph `G`. The returned solution has weight `(\\log</span>
<span class="gi">+    set for the graph `G`. The returned solution has weight `(\log</span>
<span class="w"> </span>    w(V)) w(V^*)`, where `w(V)` denotes the sum of the weights of each
<span class="w"> </span>    node in the graph and `w(V^*)` denotes the sum of the weights of
<span class="w"> </span>    each node in the minimum weight dominating set for the graph.
<span class="gu">@@ -69,12 +72,49 @@ def min_weighted_dominating_set(G, weight=None):</span>
<span class="w"> </span>           Springer Science &amp; Business Media, 2001.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The unique dominating set for the null graph is the empty set.</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return set()</span>
<span class="gi">+</span>
<span class="gi">+    # This is the dominating set that will eventually be returned.</span>
<span class="gi">+    dom_set = set()</span>
<span class="gi">+</span>
<span class="gi">+    def _cost(node_and_neighborhood):</span>
<span class="gi">+        &quot;&quot;&quot;Returns the cost-effectiveness of greedily choosing the given</span>
<span class="gi">+        node.</span>
<span class="gi">+</span>
<span class="gi">+        `node_and_neighborhood` is a two-tuple comprising a node and its</span>
<span class="gi">+        closed neighborhood.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        v, neighborhood = node_and_neighborhood</span>
<span class="gi">+        return G.nodes[v].get(weight, 1) / len(neighborhood - dom_set)</span>
<span class="gi">+</span>
<span class="gi">+    # This is a set of all vertices not already covered by the</span>
<span class="gi">+    # dominating set.</span>
<span class="gi">+    vertices = set(G)</span>
<span class="gi">+    # This is a dictionary mapping each node to the closed neighborhood</span>
<span class="gi">+    # of that node.</span>
<span class="gi">+    neighborhoods = {v: {v} | set(G[v]) for v in G}</span>
<span class="gi">+</span>
<span class="gi">+    # Continue until all vertices are adjacent to some node in the</span>
<span class="gi">+    # dominating set.</span>
<span class="gi">+    while vertices:</span>
<span class="gi">+        # Find the most cost-effective node to add, along with its</span>
<span class="gi">+        # closed neighborhood.</span>
<span class="gi">+        dom_node, min_set = min(neighborhoods.items(), key=_cost)</span>
<span class="gi">+        # Add the node to the dominating set and reduce the remaining</span>
<span class="gi">+        # set of nodes to cover.</span>
<span class="gi">+        dom_set.add(dom_node)</span>
<span class="gi">+        del neighborhoods[dom_node]</span>
<span class="gi">+        vertices -= min_set</span>
<span class="gi">+</span>
<span class="gi">+    return dom_set</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def min_edge_dominating_set(G):
<span class="gd">-    &quot;&quot;&quot;Returns minimum cardinality edge dominating set.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns minimum cardinality edge dominating set.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -103,4 +143,6 @@ def min_edge_dominating_set(G):</span>
<span class="w"> </span>    problem. The result is no more than 2 * OPT in terms of size of the set.
<span class="w"> </span>    Runtime of the algorithm is $O(|E|)$.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not G:</span>
<span class="gi">+        raise ValueError(&quot;Expected non-empty NetworkX graph!&quot;)</span>
<span class="gi">+    return maximal_matching(G)</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/kcomponents.py b/networkx/algorithms/approximation/kcomponents.py</span>
<span class="gh">index 93c6193ad..b540bd5f4 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/kcomponents.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/kcomponents.py</span>
<span class="gu">@@ -4,17 +4,19 @@ import itertools</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from collections.abc import Mapping
<span class="w"> </span>from functools import cached_property
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.approximation import local_node_connectivity
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;k_components&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;k_components&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(name=&#39;approximate_k_components&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;approximate_k_components&quot;)</span>
<span class="w"> </span>def k_components(G, min_density=0.95):
<span class="gd">-    &quot;&quot;&quot;Returns the approximate k-component structure of a graph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the approximate k-component structure of a graph G.</span>

<span class="w"> </span>    A `k`-component is a maximal subgraph of a graph G that has, at least,
<span class="w"> </span>    node connectivity `k`: we need to remove at least `k` nodes to break it
<span class="gu">@@ -100,7 +102,96 @@ def k_components(G, min_density=0.95):</span>
<span class="w"> </span>            https://doi.org/10.2307/3088904

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Dictionary with connectivity level (k) as keys and a list of</span>
<span class="gi">+    # sets of nodes that form a k-component as values</span>
<span class="gi">+    k_components = defaultdict(list)</span>
<span class="gi">+    # make a few functions local for speed</span>
<span class="gi">+    node_connectivity = local_node_connectivity</span>
<span class="gi">+    k_core = nx.k_core</span>
<span class="gi">+    core_number = nx.core_number</span>
<span class="gi">+    biconnected_components = nx.biconnected_components</span>
<span class="gi">+    combinations = itertools.combinations</span>
<span class="gi">+    # Exact solution for k = {1,2}</span>
<span class="gi">+    # There is a linear time algorithm for triconnectivity, if we had an</span>
<span class="gi">+    # implementation available we could start from k = 4.</span>
<span class="gi">+    for component in nx.connected_components(G):</span>
<span class="gi">+        # isolated nodes have connectivity 0</span>
<span class="gi">+        comp = set(component)</span>
<span class="gi">+        if len(comp) &gt; 1:</span>
<span class="gi">+            k_components[1].append(comp)</span>
<span class="gi">+    for bicomponent in nx.biconnected_components(G):</span>
<span class="gi">+        # avoid considering dyads as bicomponents</span>
<span class="gi">+        bicomp = set(bicomponent)</span>
<span class="gi">+        if len(bicomp) &gt; 2:</span>
<span class="gi">+            k_components[2].append(bicomp)</span>
<span class="gi">+    # There is no k-component of k &gt; maximum core number</span>
<span class="gi">+    # \kappa(G) &lt;= \lambda(G) &lt;= \delta(G)</span>
<span class="gi">+    g_cnumber = core_number(G)</span>
<span class="gi">+    max_core = max(g_cnumber.values())</span>
<span class="gi">+    for k in range(3, max_core + 1):</span>
<span class="gi">+        C = k_core(G, k, core_number=g_cnumber)</span>
<span class="gi">+        for nodes in biconnected_components(C):</span>
<span class="gi">+            # Build a subgraph SG induced by the nodes that are part of</span>
<span class="gi">+            # each biconnected component of the k-core subgraph C.</span>
<span class="gi">+            if len(nodes) &lt; k:</span>
<span class="gi">+                continue</span>
<span class="gi">+            SG = G.subgraph(nodes)</span>
<span class="gi">+            # Build auxiliary graph</span>
<span class="gi">+            H = _AntiGraph()</span>
<span class="gi">+            H.add_nodes_from(SG.nodes())</span>
<span class="gi">+            for u, v in combinations(SG, 2):</span>
<span class="gi">+                K = node_connectivity(SG, u, v, cutoff=k)</span>
<span class="gi">+                if k &gt; K:</span>
<span class="gi">+                    H.add_edge(u, v)</span>
<span class="gi">+            for h_nodes in biconnected_components(H):</span>
<span class="gi">+                if len(h_nodes) &lt;= k:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                SH = H.subgraph(h_nodes)</span>
<span class="gi">+                for Gc in _cliques_heuristic(SG, SH, k, min_density):</span>
<span class="gi">+                    for k_nodes in biconnected_components(Gc):</span>
<span class="gi">+                        Gk = nx.k_core(SG.subgraph(k_nodes), k)</span>
<span class="gi">+                        if len(Gk) &lt;= k:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        k_components[k].append(set(Gk))</span>
<span class="gi">+    return k_components</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _cliques_heuristic(G, H, k, min_density):</span>
<span class="gi">+    h_cnumber = nx.core_number(H)</span>
<span class="gi">+    for i, c_value in enumerate(sorted(set(h_cnumber.values()), reverse=True)):</span>
<span class="gi">+        cands = {n for n, c in h_cnumber.items() if c == c_value}</span>
<span class="gi">+        # Skip checking for overlap for the highest core value</span>
<span class="gi">+        if i == 0:</span>
<span class="gi">+            overlap = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            overlap = set.intersection(</span>
<span class="gi">+                *[{x for x in H[n] if x not in cands} for n in cands]</span>
<span class="gi">+            )</span>
<span class="gi">+        if overlap and len(overlap) &lt; k:</span>
<span class="gi">+            SH = H.subgraph(cands | overlap)</span>
<span class="gi">+        else:</span>
<span class="gi">+            SH = H.subgraph(cands)</span>
<span class="gi">+        sh_cnumber = nx.core_number(SH)</span>
<span class="gi">+        SG = nx.k_core(G.subgraph(SH), k)</span>
<span class="gi">+        while not (_same(sh_cnumber) and nx.density(SH) &gt;= min_density):</span>
<span class="gi">+            # This subgraph must be writable =&gt; .copy()</span>
<span class="gi">+            SH = H.subgraph(SG).copy()</span>
<span class="gi">+            if len(SH) &lt;= k:</span>
<span class="gi">+                break</span>
<span class="gi">+            sh_cnumber = nx.core_number(SH)</span>
<span class="gi">+            sh_deg = dict(SH.degree())</span>
<span class="gi">+            min_deg = min(sh_deg.values())</span>
<span class="gi">+            SH.remove_nodes_from(n for n, d in sh_deg.items() if d == min_deg)</span>
<span class="gi">+            SG = nx.k_core(G.subgraph(SH), k)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield SG</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _same(measure, tol=0):</span>
<span class="gi">+    vals = set(measure.values())</span>
<span class="gi">+    if (max(vals) - min(vals)) &lt;= tol:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class _AntiGraph(nx.Graph):
<span class="gu">@@ -116,8 +207,13 @@ class _AntiGraph(nx.Graph):</span>
<span class="w"> </span>    an instance of this class with some of NetworkX functions. In this
<span class="w"> </span>    case we only use k-core, connected_components, and biconnected_components.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    all_edge_dict = {&#39;weight&#39;: 1}</span>
<span class="gd">-    edge_attr_dict_factory = single_edge_dict</span>
<span class="gi">+</span>
<span class="gi">+    all_edge_dict = {&quot;weight&quot;: 1}</span>
<span class="gi">+</span>
<span class="gi">+    def single_edge_dict(self):</span>
<span class="gi">+        return self.all_edge_dict</span>
<span class="gi">+</span>
<span class="gi">+    edge_attr_dict_factory = single_edge_dict  # type: ignore[assignment]</span>

<span class="w"> </span>    def __getitem__(self, n):
<span class="w"> </span>        &quot;&quot;&quot;Returns a dict of neighbors of node n in the dense graph.
<span class="gu">@@ -134,15 +230,18 @@ class _AntiGraph(nx.Graph):</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        all_edge_dict = self.all_edge_dict
<span class="gd">-        return {node: all_edge_dict for node in set(self._adj) - set(self.</span>
<span class="gd">-            _adj[n]) - {n}}</span>
<span class="gi">+        return {</span>
<span class="gi">+            node: all_edge_dict for node in set(self._adj) - set(self._adj[n]) - {n}</span>
<span class="gi">+        }</span>

<span class="w"> </span>    def neighbors(self, n):
<span class="w"> </span>        &quot;&quot;&quot;Returns an iterator over all neighbors of node n in the
<span class="w"> </span>        dense graph.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        try:</span>
<span class="gi">+            return iter(set(self._adj) - set(self._adj[n]) - {n})</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;The node {n} is not in the graph.&quot;) from err</span>

<span class="w"> </span>    class AntiAtlasView(Mapping):
<span class="w"> </span>        &quot;&quot;&quot;An adjacency inner dict for AntiGraph&quot;&quot;&quot;
<span class="gu">@@ -156,8 +255,7 @@ class _AntiGraph(nx.Graph):</span>
<span class="w"> </span>            return len(self._graph) - len(self._atlas) - 1

<span class="w"> </span>        def __iter__(self):
<span class="gd">-            return (n for n in self._graph if n not in self._atlas and n !=</span>
<span class="gd">-                self._node)</span>
<span class="gi">+            return (n for n in self._graph if n not in self._atlas and n != self._node)</span>

<span class="w"> </span>        def __getitem__(self, nbr):
<span class="w"> </span>            nbrs = set(self._graph._adj) - set(self._atlas) - {self._node}
<span class="gu">@@ -165,7 +263,6 @@ class _AntiGraph(nx.Graph):</span>
<span class="w"> </span>                return self._graph.all_edge_dict
<span class="w"> </span>            raise KeyError(nbr)

<span class="gd">-</span>
<span class="w"> </span>    class AntiAdjacencyView(AntiAtlasView):
<span class="w"> </span>        &quot;&quot;&quot;An adjacency outer dict for AntiGraph&quot;&quot;&quot;

<span class="gu">@@ -184,21 +281,35 @@ class _AntiGraph(nx.Graph):</span>
<span class="w"> </span>                raise KeyError(node)
<span class="w"> </span>            return self._graph.AntiAtlasView(self._graph, node)

<span class="gi">+    @cached_property</span>
<span class="gi">+    def adj(self):</span>
<span class="gi">+        return self.AntiAdjacencyView(self)</span>
<span class="gi">+</span>
<span class="w"> </span>    def subgraph(self, nodes):
<span class="w"> </span>        &quot;&quot;&quot;This subgraph method returns a full AntiGraph. Not a View&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        nodes = set(nodes)</span>
<span class="gi">+        G = _AntiGraph()</span>
<span class="gi">+        G.add_nodes_from(nodes)</span>
<span class="gi">+        for n in G:</span>
<span class="gi">+            Gnbrs = G.adjlist_inner_dict_factory()</span>
<span class="gi">+            G._adj[n] = Gnbrs</span>
<span class="gi">+            for nbr, d in self._adj[n].items():</span>
<span class="gi">+                if nbr in G._adj:</span>
<span class="gi">+                    Gnbrs[nbr] = d</span>
<span class="gi">+                    G._adj[nbr][n] = d</span>
<span class="gi">+        G.graph = self.graph</span>
<span class="gi">+        return G</span>

<span class="w"> </span>    class AntiDegreeView(nx.reportviews.DegreeView):
<span class="gd">-</span>
<span class="w"> </span>        def __iter__(self):
<span class="w"> </span>            all_nodes = set(self._succ)
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                nbrs = all_nodes - set(self._succ[n]) - {n}
<span class="gd">-                yield n, len(nbrs)</span>
<span class="gi">+                yield (n, len(nbrs))</span>

<span class="w"> </span>        def __getitem__(self, n):
<span class="w"> </span>            nbrs = set(self._succ) - set(self._succ[n]) - {n}
<span class="gi">+            # AntiGraph is a ThinGraph so all edges have weight 1</span>
<span class="w"> </span>            return len(nbrs) + (n in nbrs)

<span class="w"> </span>    @cached_property
<span class="gu">@@ -238,7 +349,7 @@ class _AntiGraph(nx.Graph):</span>
<span class="w"> </span>        [(0, 1), (1, 2)]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.AntiDegreeView(self)</span>

<span class="w"> </span>    def adjacency(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns an iterator of (node, adjacency set) tuples for all nodes
<span class="gu">@@ -254,4 +365,5 @@ class _AntiGraph(nx.Graph):</span>
<span class="w"> </span>           the graph.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for n in self._adj:</span>
<span class="gi">+            yield (n, set(self._adj) - set(self._adj[n]) - {n})</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/matching.py b/networkx/algorithms/approximation/matching.py</span>
<span class="gh">index d51a8fa32..3a7c8a39b 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/matching.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/matching.py</span>
<span class="gu">@@ -9,12 +9,13 @@ edges; that is, no two edges share a common vertex.</span>
<span class="w"> </span>`Wikipedia: Matching &lt;https://en.wikipedia.org/wiki/Matching_(graph_theory)&gt;`_
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;min_maximal_matching&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;min_maximal_matching&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def min_maximal_matching(G):
<span class="gd">-    &quot;&quot;&quot;Returns the minimum maximal matching of G. That is, out of all maximal</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the minimum maximal matching of G. That is, out of all maximal</span>
<span class="w"> </span>    matchings of the graph G, the smallest is returned.

<span class="w"> </span>    Parameters
<span class="gu">@@ -39,4 +40,4 @@ def min_maximal_matching(G):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] Vazirani, Vijay Approximation Algorithms (2001)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return nx.maximal_matching(G)</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/maxcut.py b/networkx/algorithms/approximation/maxcut.py</span>
<span class="gh">index 13460e11f..f4e1da87c 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/maxcut.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/maxcut.py</span>
<span class="gu">@@ -1,12 +1,13 @@</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;randomized_partitioning&#39;, &#39;one_exchange&#39;]</span>

<span class="gi">+__all__ = [&quot;randomized_partitioning&quot;, &quot;one_exchange&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@py_random_state(1)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def randomized_partitioning(G, seed=None, p=0.5, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Compute a random partitioning of the graph nodes and its cut value.

<span class="gu">@@ -53,13 +54,20 @@ def randomized_partitioning(G, seed=None, p=0.5, weight=None):</span>
<span class="w"> </span>    NetworkXNotImplemented
<span class="w"> </span>        If the graph is directed or is a multigraph.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cut = {node for node in G.nodes() if seed.random() &lt; p}</span>
<span class="gi">+    cut_size = nx.algorithms.cut_size(G, cut, weight=weight)</span>
<span class="gi">+    partition = (cut, G.nodes - cut)</span>
<span class="gi">+    return cut_size, partition</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _swap_node_partition(cut, node):</span>
<span class="gi">+    return cut - {node} if node in cut else cut.union({node})</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@py_random_state(2)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def one_exchange(G, initial_cut=None, seed=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Compute a partitioning of the graphs nodes and the corresponding cut value.

<span class="gu">@@ -107,4 +115,29 @@ def one_exchange(G, initial_cut=None, seed=None, weight=None):</span>
<span class="w"> </span>    NetworkXNotImplemented
<span class="w"> </span>        If the graph is directed or is a multigraph.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if initial_cut is None:</span>
<span class="gi">+        initial_cut = set()</span>
<span class="gi">+    cut = set(initial_cut)</span>
<span class="gi">+    current_cut_size = nx.algorithms.cut_size(G, cut, weight=weight)</span>
<span class="gi">+    while True:</span>
<span class="gi">+        nodes = list(G.nodes())</span>
<span class="gi">+        # Shuffling the nodes ensures random tie-breaks in the following call to max</span>
<span class="gi">+        seed.shuffle(nodes)</span>
<span class="gi">+        best_node_to_swap = max(</span>
<span class="gi">+            nodes,</span>
<span class="gi">+            key=lambda v: nx.algorithms.cut_size(</span>
<span class="gi">+                G, _swap_node_partition(cut, v), weight=weight</span>
<span class="gi">+            ),</span>
<span class="gi">+            default=None,</span>
<span class="gi">+        )</span>
<span class="gi">+        potential_cut = _swap_node_partition(cut, best_node_to_swap)</span>
<span class="gi">+        potential_cut_size = nx.algorithms.cut_size(G, potential_cut, weight=weight)</span>
<span class="gi">+</span>
<span class="gi">+        if potential_cut_size &gt; current_cut_size:</span>
<span class="gi">+            cut = potential_cut</span>
<span class="gi">+            current_cut_size = potential_cut_size</span>
<span class="gi">+        else:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    partition = (cut, G.nodes - cut)</span>
<span class="gi">+    return current_cut_size, partition</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/ramsey.py b/networkx/algorithms/approximation/ramsey.py</span>
<span class="gh">index 986e5c9da..5cb9fda04 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/ramsey.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/ramsey.py</span>
<span class="gu">@@ -3,15 +3,17 @@ Ramsey numbers.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gi">+</span>
<span class="w"> </span>from ...utils import arbitrary_element
<span class="gd">-__all__ = [&#39;ramsey_R2&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;ramsey_R2&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def ramsey_R2(G):
<span class="gd">-    &quot;&quot;&quot;Compute the largest clique and largest independent set in `G`.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the largest clique and largest independent set in `G`.</span>

<span class="w"> </span>    This can be used to estimate bounds for the 2-color
<span class="w"> </span>    Ramsey number `R(2;s,t)` for `G`.
<span class="gu">@@ -34,4 +36,17 @@ def ramsey_R2(G):</span>
<span class="w"> </span>    NetworkXNotImplemented
<span class="w"> </span>        If the graph is directed or is a multigraph.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not G:</span>
<span class="gi">+        return set(), set()</span>
<span class="gi">+</span>
<span class="gi">+    node = arbitrary_element(G)</span>
<span class="gi">+    nbrs = (nbr for nbr in nx.all_neighbors(G, node) if nbr != node)</span>
<span class="gi">+    nnbrs = nx.non_neighbors(G, node)</span>
<span class="gi">+    c_1, i_1 = ramsey_R2(G.subgraph(nbrs).copy())</span>
<span class="gi">+    c_2, i_2 = ramsey_R2(G.subgraph(nnbrs).copy())</span>
<span class="gi">+</span>
<span class="gi">+    c_1.add(node)</span>
<span class="gi">+    i_2.add(node)</span>
<span class="gi">+    # Choose the larger of the two cliques and the larger of the two</span>
<span class="gi">+    # independent sets, according to cardinality.</span>
<span class="gi">+    return max(c_1, c_2, key=len), max(i_1, i_2, key=len)</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/steinertree.py b/networkx/algorithms/approximation/steinertree.py</span>
<span class="gh">index 74895df5d..c6c834f42 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/steinertree.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/steinertree.py</span>
<span class="gu">@@ -1,12 +1,14 @@</span>
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, pairwise
<span class="gd">-__all__ = [&#39;metric_closure&#39;, &#39;steiner_tree&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;metric_closure&quot;, &quot;steiner_tree&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, returns_graph=True)</span>
<span class="gd">-def metric_closure(G, weight=&#39;weight&#39;):</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, returns_graph=True)</span>
<span class="gi">+def metric_closure(G, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the metric closure of a graph.

<span class="w"> </span>    The metric closure of a graph *G* is the complete graph in which each edge
<span class="gu">@@ -22,16 +24,111 @@ def metric_closure(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>        Metric closure of the graph `G`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-ALGORITHMS = {&#39;kou&#39;: _kou_steiner_tree, &#39;mehlhorn&#39;: _mehlhorn_steiner_tree}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    M = nx.Graph()</span>
<span class="gi">+</span>
<span class="gi">+    Gnodes = set(G)</span>
<span class="gi">+</span>
<span class="gi">+    # check for connected graph while processing first node</span>
<span class="gi">+    all_paths_iter = nx.all_pairs_dijkstra(G, weight=weight)</span>
<span class="gi">+    u, (distance, path) = next(all_paths_iter)</span>
<span class="gi">+    if Gnodes - set(distance):</span>
<span class="gi">+        msg = &quot;G is not a connected graph. metric_closure is not defined.&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    Gnodes.remove(u)</span>
<span class="gi">+    for v in Gnodes:</span>
<span class="gi">+        M.add_edge(u, v, distance=distance[v], path=path[v])</span>
<span class="gi">+</span>
<span class="gi">+    # first node done -- now process the rest</span>
<span class="gi">+    for u, (distance, path) in all_paths_iter:</span>
<span class="gi">+        Gnodes.remove(u)</span>
<span class="gi">+        for v in Gnodes:</span>
<span class="gi">+            M.add_edge(u, v, distance=distance[v], path=path[v])</span>
<span class="gi">+</span>
<span class="gi">+    return M</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _mehlhorn_steiner_tree(G, terminal_nodes, weight):</span>
<span class="gi">+    paths = nx.multi_source_dijkstra_path(G, terminal_nodes)</span>
<span class="gi">+</span>
<span class="gi">+    d_1 = {}</span>
<span class="gi">+    s = {}</span>
<span class="gi">+    for v in G.nodes():</span>
<span class="gi">+        s[v] = paths[v][0]</span>
<span class="gi">+        d_1[(v, s[v])] = len(paths[v]) - 1</span>
<span class="gi">+</span>
<span class="gi">+    # G1-G4 names match those from the Mehlhorn 1988 paper.</span>
<span class="gi">+    G_1_prime = nx.Graph()</span>
<span class="gi">+    for u, v, data in G.edges(data=True):</span>
<span class="gi">+        su, sv = s[u], s[v]</span>
<span class="gi">+        weight_here = d_1[(u, su)] + data.get(weight, 1) + d_1[(v, sv)]</span>
<span class="gi">+        if not G_1_prime.has_edge(su, sv):</span>
<span class="gi">+            G_1_prime.add_edge(su, sv, weight=weight_here)</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_weight = min(weight_here, G_1_prime[su][sv][&quot;weight&quot;])</span>
<span class="gi">+            G_1_prime.add_edge(su, sv, weight=new_weight)</span>
<span class="gi">+</span>
<span class="gi">+    G_2 = nx.minimum_spanning_edges(G_1_prime, data=True)</span>
<span class="gi">+</span>
<span class="gi">+    G_3 = nx.Graph()</span>
<span class="gi">+    for u, v, d in G_2:</span>
<span class="gi">+        path = nx.shortest_path(G, u, v, weight)</span>
<span class="gi">+        for n1, n2 in pairwise(path):</span>
<span class="gi">+            G_3.add_edge(n1, n2)</span>
<span class="gi">+</span>
<span class="gi">+    G_3_mst = list(nx.minimum_spanning_edges(G_3, data=False))</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        G_3_mst = (</span>
<span class="gi">+            (u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for u, v in G_3_mst</span>
<span class="gi">+        )</span>
<span class="gi">+    G_4 = G.edge_subgraph(G_3_mst).copy()</span>
<span class="gi">+    _remove_nonterminal_leaves(G_4, terminal_nodes)</span>
<span class="gi">+    return G_4.edges()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _kou_steiner_tree(G, terminal_nodes, weight):</span>
<span class="gi">+    # H is the subgraph induced by terminal_nodes in the metric closure M of G.</span>
<span class="gi">+    M = metric_closure(G, weight=weight)</span>
<span class="gi">+    H = M.subgraph(terminal_nodes)</span>
<span class="gi">+</span>
<span class="gi">+    # Use the &#39;distance&#39; attribute of each edge provided by M.</span>
<span class="gi">+    mst_edges = nx.minimum_spanning_edges(H, weight=&quot;distance&quot;, data=True)</span>
<span class="gi">+</span>
<span class="gi">+    # Create an iterator over each edge in each shortest path; repeats are okay</span>
<span class="gi">+    mst_all_edges = chain.from_iterable(pairwise(d[&quot;path&quot;]) for u, v, d in mst_edges)</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        mst_all_edges = (</span>
<span class="gi">+            (u, v, min(G[u][v], key=lambda k: G[u][v][k][weight]))</span>
<span class="gi">+            for u, v in mst_all_edges</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Find the MST again, over this new set of edges</span>
<span class="gi">+    G_S = G.edge_subgraph(mst_all_edges)</span>
<span class="gi">+    T_S = nx.minimum_spanning_edges(G_S, weight=&quot;weight&quot;, data=False)</span>
<span class="gi">+</span>
<span class="gi">+    # Leaf nodes that are not terminal might still remain; remove them here</span>
<span class="gi">+    T_H = G.edge_subgraph(T_S).copy()</span>
<span class="gi">+    _remove_nonterminal_leaves(T_H, terminal_nodes)</span>
<span class="gi">+</span>
<span class="gi">+    return T_H.edges()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _remove_nonterminal_leaves(G, terminals):</span>
<span class="gi">+    terminals_set = set(terminals)</span>
<span class="gi">+    for n in list(G.nodes):</span>
<span class="gi">+        if n not in terminals_set and G.degree(n) == 1:</span>
<span class="gi">+            G.remove_node(n)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ALGORITHMS = {</span>
<span class="gi">+    &quot;kou&quot;: _kou_steiner_tree,</span>
<span class="gi">+    &quot;mehlhorn&quot;: _mehlhorn_steiner_tree,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gd">-def steiner_tree(G, terminal_nodes, weight=&#39;weight&#39;, method=None):</span>
<span class="gd">-    &quot;&quot;&quot;Return an approximation to the minimum Steiner tree of a graph.</span>
<span class="gi">+def steiner_tree(G, terminal_nodes, weight=&quot;weight&quot;, method=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Return an approximation to the minimum Steiner tree of a graph.</span>

<span class="w"> </span>    The minimum Steiner tree of `G` w.r.t a set of `terminal_nodes` (also *S*)
<span class="w"> </span>    is a tree within `G` that spans those nodes and has minimum size (sum of
<span class="gu">@@ -48,7 +145,7 @@ def steiner_tree(G, terminal_nodes, weight=&#39;weight&#39;, method=None):</span>
<span class="w"> </span>      where the metric closure of *G* is the complete graph in which each edge is
<span class="w"> </span>      weighted by the shortest path distance between the nodes in *G*.

<span class="gd">-    * ``&quot;mehlhorn&quot;`` [3]_ (runtime $O(|E|+|V|\\log|V|)$) modifies Kou et al.&#39;s</span>
<span class="gi">+    * ``&quot;mehlhorn&quot;`` [3]_ (runtime $O(|E|+|V|\log|V|)$) modifies Kou et al.&#39;s</span>
<span class="w"> </span>      algorithm, beginning by finding the closest terminal node for each
<span class="w"> </span>      non-terminal. This data is used to create a complete graph containing only
<span class="w"> </span>      the terminal nodes, in which edge is weighted with the shortest path
<span class="gu">@@ -105,4 +202,19 @@ def steiner_tree(G, terminal_nodes, weight=&#39;weight&#39;, method=None):</span>
<span class="w"> </span>           Information Processing Letters 27 (3): 125–28.
<span class="w"> </span>           https://doi.org/10.1016/0020-0190(88)90066-X.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if method is None:</span>
<span class="gi">+        method = &quot;mehlhorn&quot;</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        algo = ALGORITHMS[method]</span>
<span class="gi">+    except KeyError as e:</span>
<span class="gi">+        raise ValueError(f&quot;{method} is not a valid choice for an algorithm.&quot;) from e</span>
<span class="gi">+</span>
<span class="gi">+    edges = algo(G, terminal_nodes, weight)</span>
<span class="gi">+    # For multigraph we should add the minimal weight edge keys</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        edges = (</span>
<span class="gi">+            (u, v, min(G[u][v], key=lambda k: G[u][v][k][weight])) for u, v in edges</span>
<span class="gi">+        )</span>
<span class="gi">+    T = G.edge_subgraph(edges)</span>
<span class="gi">+    return T</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/traveling_salesman.py b/networkx/algorithms/approximation/traveling_salesman.py</span>
<span class="gh">index c18c99cb2..2a31b7281 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/traveling_salesman.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/traveling_salesman.py</span>
<span class="gu">@@ -34,11 +34,19 @@ important in operations research and theoretical computer science.</span>
<span class="w"> </span>http://en.wikipedia.org/wiki/Travelling_salesman_problem
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import math
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.tree.mst import random_spanning_tree
<span class="w"> </span>from networkx.utils import not_implemented_for, pairwise, py_random_state
<span class="gd">-__all__ = [&#39;traveling_salesman_problem&#39;, &#39;christofides&#39;, &#39;asadpour_atsp&#39;,</span>
<span class="gd">-    &#39;greedy_tsp&#39;, &#39;simulated_annealing_tsp&#39;, &#39;threshold_accepting_tsp&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;traveling_salesman_problem&quot;,</span>
<span class="gi">+    &quot;christofides&quot;,</span>
<span class="gi">+    &quot;asadpour_atsp&quot;,</span>
<span class="gi">+    &quot;greedy_tsp&quot;,</span>
<span class="gi">+    &quot;simulated_annealing_tsp&quot;,</span>
<span class="gi">+    &quot;threshold_accepting_tsp&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def swap_two_nodes(soln, seed):
<span class="gu">@@ -71,7 +79,9 @@ def swap_two_nodes(soln, seed):</span>
<span class="w"> </span>    --------
<span class="w"> </span>        move_one_node
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    a, b = seed.sample(range(1, len(soln) - 1), k=2)</span>
<span class="gi">+    soln[a], soln[b] = soln[b], soln[a]</span>
<span class="gi">+    return soln</span>


<span class="w"> </span>def move_one_node(soln, seed):
<span class="gu">@@ -108,12 +118,14 @@ def move_one_node(soln, seed):</span>
<span class="w"> </span>    --------
<span class="w"> </span>        swap_two_nodes
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    a, b = seed.sample(range(1, len(soln) - 1), k=2)</span>
<span class="gi">+    soln.insert(b, soln.pop(a))</span>
<span class="gi">+    return soln</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def christofides(G, weight=&#39;weight&#39;, tree=None):</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def christofides(G, weight=&quot;weight&quot;, tree=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Approximate a solution of the traveling salesman problem

<span class="w"> </span>    Compute a 3/2-approximation of the traveling salesman problem
<span class="gu">@@ -145,17 +157,50 @@ def christofides(G, weight=&#39;weight&#39;, tree=None):</span>
<span class="w"> </span>       the travelling salesman problem.&quot; No. RR-388. Carnegie-Mellon Univ
<span class="w"> </span>       Pittsburgh Pa Management Sciences Research Group, 1976.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Remove selfloops if necessary</span>
<span class="gi">+    loop_nodes = nx.nodes_with_selfloops(G)</span>
<span class="gi">+    try:</span>
<span class="gi">+        node = next(loop_nodes)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        G = G.copy()</span>
<span class="gi">+        G.remove_edge(node, node)</span>
<span class="gi">+        G.remove_edges_from((n, n) for n in loop_nodes)</span>
<span class="gi">+    # Check that G is a complete graph</span>
<span class="gi">+    N = len(G) - 1</span>
<span class="gi">+    # This check ignores selfloops which is what we want here.</span>
<span class="gi">+    if any(len(nbrdict) != N for n, nbrdict in G.adj.items()):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;G must be a complete graph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if tree is None:</span>
<span class="gi">+        tree = nx.minimum_spanning_tree(G, weight=weight)</span>
<span class="gi">+    L = G.copy()</span>
<span class="gi">+    L.remove_nodes_from([v for v, degree in tree.degree if not (degree % 2)])</span>
<span class="gi">+    MG = nx.MultiGraph()</span>
<span class="gi">+    MG.add_edges_from(tree.edges)</span>
<span class="gi">+    edges = nx.min_weight_matching(L, weight=weight)</span>
<span class="gi">+    MG.add_edges_from(edges)</span>
<span class="gi">+    return _shortcutting(nx.eulerian_circuit(MG))</span>


<span class="w"> </span>def _shortcutting(circuit):
<span class="w"> </span>    &quot;&quot;&quot;Remove duplicate nodes in the path&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def traveling_salesman_problem(G, weight=&#39;weight&#39;, nodes=None, cycle=True,</span>
<span class="gd">-    method=None, **kwargs):</span>
<span class="gi">+    nodes = []</span>
<span class="gi">+    for u, v in circuit:</span>
<span class="gi">+        if v in nodes:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if not nodes:</span>
<span class="gi">+            nodes.append(u)</span>
<span class="gi">+        nodes.append(v)</span>
<span class="gi">+    nodes.append(nodes[0])</span>
<span class="gi">+    return nodes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def traveling_salesman_problem(</span>
<span class="gi">+    G, weight=&quot;weight&quot;, nodes=None, cycle=True, method=None, **kwargs</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the shortest path in `G` connecting specified nodes

<span class="w"> </span>    This function allows approximate solution to the traveling salesman
<span class="gu">@@ -263,13 +308,54 @@ def traveling_salesman_problem(G, weight=&#39;weight&#39;, nodes=None, cycle=True,</span>
<span class="w"> </span>    &gt;&gt;&gt; path in ([4, 3, 2, 1, 0, 8, 7, 6, 5], [5, 6, 7, 8, 0, 1, 2, 3, 4])
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    if method is None:</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            method = asadpour_atsp</span>
<span class="gi">+        else:</span>
<span class="gi">+            method = christofides</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = list(G.nodes)</span>
<span class="gi">+</span>
<span class="gi">+    dist = {}</span>
<span class="gi">+    path = {}</span>
<span class="gi">+    for n, (d, p) in nx.all_pairs_dijkstra(G, weight=weight):</span>
<span class="gi">+        dist[n] = d</span>
<span class="gi">+        path[n] = p</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        # If the graph is not strongly connected, raise an exception</span>
<span class="gi">+        if not nx.is_strongly_connected(G):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;G is not strongly connected&quot;)</span>
<span class="gi">+        GG = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        GG = nx.Graph()</span>
<span class="gi">+    for u in nodes:</span>
<span class="gi">+        for v in nodes:</span>
<span class="gi">+            if u == v:</span>
<span class="gi">+                continue</span>
<span class="gi">+            GG.add_edge(u, v, weight=dist[u][v])</span>
<span class="gi">+</span>
<span class="gi">+    best_GG = method(GG, weight=weight, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if not cycle:</span>
<span class="gi">+        # find and remove the biggest edge</span>
<span class="gi">+        (u, v) = max(pairwise(best_GG), key=lambda x: dist[x[0]][x[1]])</span>
<span class="gi">+        pos = best_GG.index(u) + 1</span>
<span class="gi">+        while best_GG[pos] != v:</span>
<span class="gi">+            pos = best_GG[pos:].index(u) + 1</span>
<span class="gi">+        best_GG = best_GG[pos:-1] + best_GG[:pos]</span>
<span class="gi">+</span>
<span class="gi">+    best_path = []</span>
<span class="gi">+    for u, v in pairwise(best_GG):</span>
<span class="gi">+        best_path.extend(path[u][v][:-1])</span>
<span class="gi">+    best_path.append(v)</span>
<span class="gi">+    return best_path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@py_random_state(2)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, mutates_input=True)</span>
<span class="gd">-def asadpour_atsp(G, weight=&#39;weight&#39;, seed=None, source=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, mutates_input=True)</span>
<span class="gi">+def asadpour_atsp(G, weight=&quot;weight&quot;, seed=None, source=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns an approximate solution to the traveling salesman problem.

<span class="gu">@@ -342,11 +428,86 @@ def asadpour_atsp(G, weight=&#39;weight&#39;, seed=None, source=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; tour
<span class="w"> </span>    [0, 2, 1, 0]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, mutates_input=True, returns_graph=True)</span>
<span class="gd">-def held_karp_ascent(G, weight=&#39;weight&#39;):</span>
<span class="gi">+    from math import ceil, exp</span>
<span class="gi">+    from math import log as ln</span>
<span class="gi">+</span>
<span class="gi">+    # Check that G is a complete graph</span>
<span class="gi">+    N = len(G) - 1</span>
<span class="gi">+    if N &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;G must have at least two nodes&quot;)</span>
<span class="gi">+    # This check ignores selfloops which is what we want here.</span>
<span class="gi">+    if any(len(nbrdict) - (n in nbrdict) != N for n, nbrdict in G.adj.items()):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;G is not a complete DiGraph&quot;)</span>
<span class="gi">+    # Check that the source vertex, if given, is in the graph</span>
<span class="gi">+    if source is not None and source not in G.nodes:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Given source node not in G.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    opt_hk, z_star = held_karp_ascent(G, weight)</span>
<span class="gi">+</span>
<span class="gi">+    # Test to see if the ascent method found an integer solution or a fractional</span>
<span class="gi">+    # solution. If it is integral then z_star is a nx.Graph, otherwise it is</span>
<span class="gi">+    # a dict</span>
<span class="gi">+    if not isinstance(z_star, dict):</span>
<span class="gi">+        # Here we are using the shortcutting method to go from the list of edges</span>
<span class="gi">+        # returned from eulerian_circuit to a list of nodes</span>
<span class="gi">+        return _shortcutting(nx.eulerian_circuit(z_star, source=source))</span>
<span class="gi">+</span>
<span class="gi">+    # Create the undirected support of z_star</span>
<span class="gi">+    z_support = nx.MultiGraph()</span>
<span class="gi">+    for u, v in z_star:</span>
<span class="gi">+        if (u, v) not in z_support.edges:</span>
<span class="gi">+            edge_weight = min(G[u][v][weight], G[v][u][weight])</span>
<span class="gi">+            z_support.add_edge(u, v, **{weight: edge_weight})</span>
<span class="gi">+</span>
<span class="gi">+    # Create the exponential distribution of spanning trees</span>
<span class="gi">+    gamma = spanning_tree_distribution(z_support, z_star)</span>
<span class="gi">+</span>
<span class="gi">+    # Write the lambda values to the edges of z_support</span>
<span class="gi">+    z_support = nx.Graph(z_support)</span>
<span class="gi">+    lambda_dict = {(u, v): exp(gamma[(u, v)]) for u, v in z_support.edges()}</span>
<span class="gi">+    nx.set_edge_attributes(z_support, lambda_dict, &quot;weight&quot;)</span>
<span class="gi">+    del gamma, lambda_dict</span>
<span class="gi">+</span>
<span class="gi">+    # Sample 2 * ceil( ln(n) ) spanning trees and record the minimum one</span>
<span class="gi">+    minimum_sampled_tree = None</span>
<span class="gi">+    minimum_sampled_tree_weight = math.inf</span>
<span class="gi">+    for _ in range(2 * ceil(ln(G.number_of_nodes()))):</span>
<span class="gi">+        sampled_tree = random_spanning_tree(z_support, &quot;weight&quot;, seed=seed)</span>
<span class="gi">+        sampled_tree_weight = sampled_tree.size(weight)</span>
<span class="gi">+        if sampled_tree_weight &lt; minimum_sampled_tree_weight:</span>
<span class="gi">+            minimum_sampled_tree = sampled_tree.copy()</span>
<span class="gi">+            minimum_sampled_tree_weight = sampled_tree_weight</span>
<span class="gi">+</span>
<span class="gi">+    # Orient the edges in that tree to keep the cost of the tree the same.</span>
<span class="gi">+    t_star = nx.MultiDiGraph()</span>
<span class="gi">+    for u, v, d in minimum_sampled_tree.edges(data=weight):</span>
<span class="gi">+        if d == G[u][v][weight]:</span>
<span class="gi">+            t_star.add_edge(u, v, **{weight: d})</span>
<span class="gi">+        else:</span>
<span class="gi">+            t_star.add_edge(v, u, **{weight: d})</span>
<span class="gi">+</span>
<span class="gi">+    # Find the node demands needed to neutralize the flow of t_star in G</span>
<span class="gi">+    node_demands = {n: t_star.out_degree(n) - t_star.in_degree(n) for n in t_star}</span>
<span class="gi">+    nx.set_node_attributes(G, node_demands, &quot;demand&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Find the min_cost_flow</span>
<span class="gi">+    flow_dict = nx.min_cost_flow(G, &quot;demand&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Build the flow into t_star</span>
<span class="gi">+    for source, values in flow_dict.items():</span>
<span class="gi">+        for target in values:</span>
<span class="gi">+            if (source, target) not in t_star.edges and values[target] &gt; 0:</span>
<span class="gi">+                # IF values[target] &gt; 0 we have to add that many edges</span>
<span class="gi">+                for _ in range(values[target]):</span>
<span class="gi">+                    t_star.add_edge(source, target)</span>
<span class="gi">+</span>
<span class="gi">+    # Return the shortcut eulerian circuit</span>
<span class="gi">+    circuit = nx.eulerian_circuit(t_star, source=source)</span>
<span class="gi">+    return _shortcutting(circuit)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, mutates_input=True, returns_graph=True)</span>
<span class="gi">+def held_karp_ascent(G, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Minimizes the Held-Karp relaxation of the TSP for `G`

<span class="gu">@@ -391,7 +552,273 @@ def held_karp_ascent(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>           spanning trees, Operations Research, 1970-11-01, Vol. 18 (6),
<span class="w"> </span>           pp.1138-1162
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    from scipy import optimize</span>
<span class="gi">+</span>
<span class="gi">+    def k_pi():</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Find the set of minimum 1-Arborescences for G at point pi.</span>
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        Set</span>
<span class="gi">+            The set of minimum 1-Arborescences</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Create a copy of G without vertex 1.</span>
<span class="gi">+        G_1 = G.copy()</span>
<span class="gi">+        minimum_1_arborescences = set()</span>
<span class="gi">+        minimum_1_arborescence_weight = math.inf</span>
<span class="gi">+</span>
<span class="gi">+        # node is node &#39;1&#39; in the Held and Karp paper</span>
<span class="gi">+        n = next(G.__iter__())</span>
<span class="gi">+        G_1.remove_node(n)</span>
<span class="gi">+</span>
<span class="gi">+        # Iterate over the spanning arborescences of the graph until we know</span>
<span class="gi">+        # that we have found the minimum 1-arborescences. My proposed strategy</span>
<span class="gi">+        # is to find the most extensive root to connect to from &#39;node 1&#39; and</span>
<span class="gi">+        # the least expensive one. We then iterate over arborescences until</span>
<span class="gi">+        # the cost of the basic arborescence is the cost of the minimum one</span>
<span class="gi">+        # plus the difference between the most and least expensive roots,</span>
<span class="gi">+        # that way the cost of connecting &#39;node 1&#39; will by definition not by</span>
<span class="gi">+        # minimum</span>
<span class="gi">+        min_root = {&quot;node&quot;: None, weight: math.inf}</span>
<span class="gi">+        max_root = {&quot;node&quot;: None, weight: -math.inf}</span>
<span class="gi">+        for u, v, d in G.edges(n, data=True):</span>
<span class="gi">+            if d[weight] &lt; min_root[weight]:</span>
<span class="gi">+                min_root = {&quot;node&quot;: v, weight: d[weight]}</span>
<span class="gi">+            if d[weight] &gt; max_root[weight]:</span>
<span class="gi">+                max_root = {&quot;node&quot;: v, weight: d[weight]}</span>
<span class="gi">+</span>
<span class="gi">+        min_in_edge = min(G.in_edges(n, data=True), key=lambda x: x[2][weight])</span>
<span class="gi">+        min_root[weight] = min_root[weight] + min_in_edge[2][weight]</span>
<span class="gi">+        max_root[weight] = max_root[weight] + min_in_edge[2][weight]</span>
<span class="gi">+</span>
<span class="gi">+        min_arb_weight = math.inf</span>
<span class="gi">+        for arb in nx.ArborescenceIterator(G_1):</span>
<span class="gi">+            arb_weight = arb.size(weight)</span>
<span class="gi">+            if min_arb_weight == math.inf:</span>
<span class="gi">+                min_arb_weight = arb_weight</span>
<span class="gi">+            elif arb_weight &gt; min_arb_weight + max_root[weight] - min_root[weight]:</span>
<span class="gi">+                break</span>
<span class="gi">+            # We have to pick the root node of the arborescence for the out</span>
<span class="gi">+            # edge of the first vertex as that is the only node without an</span>
<span class="gi">+            # edge directed into it.</span>
<span class="gi">+            for N, deg in arb.in_degree:</span>
<span class="gi">+                if deg == 0:</span>
<span class="gi">+                    # root found</span>
<span class="gi">+                    arb.add_edge(n, N, **{weight: G[n][N][weight]})</span>
<span class="gi">+                    arb_weight += G[n][N][weight]</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            # We can pick the minimum weight in-edge for the vertex with</span>
<span class="gi">+            # a cycle. If there are multiple edges with the same, minimum</span>
<span class="gi">+            # weight, We need to add all of them.</span>
<span class="gi">+            #</span>
<span class="gi">+            # Delete the edge (N, v) so that we cannot pick it.</span>
<span class="gi">+            edge_data = G[N][n]</span>
<span class="gi">+            G.remove_edge(N, n)</span>
<span class="gi">+            min_weight = min(G.in_edges(n, data=weight), key=lambda x: x[2])[2]</span>
<span class="gi">+            min_edges = [</span>
<span class="gi">+                (u, v, d) for u, v, d in G.in_edges(n, data=weight) if d == min_weight</span>
<span class="gi">+            ]</span>
<span class="gi">+            for u, v, d in min_edges:</span>
<span class="gi">+                new_arb = arb.copy()</span>
<span class="gi">+                new_arb.add_edge(u, v, **{weight: d})</span>
<span class="gi">+                new_arb_weight = arb_weight + d</span>
<span class="gi">+                # Check to see the weight of the arborescence, if it is a</span>
<span class="gi">+                # new minimum, clear all of the old potential minimum</span>
<span class="gi">+                # 1-arborescences and add this is the only one. If its</span>
<span class="gi">+                # weight is above the known minimum, do not add it.</span>
<span class="gi">+                if new_arb_weight &lt; minimum_1_arborescence_weight:</span>
<span class="gi">+                    minimum_1_arborescences.clear()</span>
<span class="gi">+                    minimum_1_arborescence_weight = new_arb_weight</span>
<span class="gi">+                # We have a 1-arborescence, add it to the set</span>
<span class="gi">+                if new_arb_weight == minimum_1_arborescence_weight:</span>
<span class="gi">+                    minimum_1_arborescences.add(new_arb)</span>
<span class="gi">+            G.add_edge(N, n, **edge_data)</span>
<span class="gi">+</span>
<span class="gi">+        return minimum_1_arborescences</span>
<span class="gi">+</span>
<span class="gi">+    def direction_of_ascent():</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Find the direction of ascent at point pi.</span>
<span class="gi">+</span>
<span class="gi">+        See [1]_ for more information.</span>
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        dict</span>
<span class="gi">+            A mapping from the nodes of the graph which represents the direction</span>
<span class="gi">+            of ascent.</span>
<span class="gi">+</span>
<span class="gi">+        References</span>
<span class="gi">+        ----------</span>
<span class="gi">+        .. [1] M. Held, R. M. Karp, The traveling-salesman problem and minimum</span>
<span class="gi">+           spanning trees, Operations Research, 1970-11-01, Vol. 18 (6),</span>
<span class="gi">+           pp.1138-1162</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # 1. Set d equal to the zero n-vector.</span>
<span class="gi">+        d = {}</span>
<span class="gi">+        for n in G:</span>
<span class="gi">+            d[n] = 0</span>
<span class="gi">+        del n</span>
<span class="gi">+        # 2. Find a 1-Arborescence T^k such that k is in K(pi, d).</span>
<span class="gi">+        minimum_1_arborescences = k_pi()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # Reduce K(pi) to K(pi, d)</span>
<span class="gi">+            # Find the arborescence in K(pi) which increases the lest in</span>
<span class="gi">+            # direction d</span>
<span class="gi">+            min_k_d_weight = math.inf</span>
<span class="gi">+            min_k_d = None</span>
<span class="gi">+            for arborescence in minimum_1_arborescences:</span>
<span class="gi">+                weighted_cost = 0</span>
<span class="gi">+                for n, deg in arborescence.degree:</span>
<span class="gi">+                    weighted_cost += d[n] * (deg - 2)</span>
<span class="gi">+                if weighted_cost &lt; min_k_d_weight:</span>
<span class="gi">+                    min_k_d_weight = weighted_cost</span>
<span class="gi">+                    min_k_d = arborescence</span>
<span class="gi">+</span>
<span class="gi">+            # 3. If sum of d_i * v_{i, k} is greater than zero, terminate</span>
<span class="gi">+            if min_k_d_weight &gt; 0:</span>
<span class="gi">+                return d, min_k_d</span>
<span class="gi">+            # 4. d_i = d_i + v_{i, k}</span>
<span class="gi">+            for n, deg in min_k_d.degree:</span>
<span class="gi">+                d[n] += deg - 2</span>
<span class="gi">+            # Check that we do not need to terminate because the direction</span>
<span class="gi">+            # of ascent does not exist. This is done with linear</span>
<span class="gi">+            # programming.</span>
<span class="gi">+            c = np.full(len(minimum_1_arborescences), -1, dtype=int)</span>
<span class="gi">+            a_eq = np.empty((len(G) + 1, len(minimum_1_arborescences)), dtype=int)</span>
<span class="gi">+            b_eq = np.zeros(len(G) + 1, dtype=int)</span>
<span class="gi">+            b_eq[len(G)] = 1</span>
<span class="gi">+            for arb_count, arborescence in enumerate(minimum_1_arborescences):</span>
<span class="gi">+                n_count = len(G) - 1</span>
<span class="gi">+                for n, deg in arborescence.degree:</span>
<span class="gi">+                    a_eq[n_count][arb_count] = deg - 2</span>
<span class="gi">+                    n_count -= 1</span>
<span class="gi">+                a_eq[len(G)][arb_count] = 1</span>
<span class="gi">+            program_result = optimize.linprog(</span>
<span class="gi">+                c, A_eq=a_eq, b_eq=b_eq, method=&quot;highs-ipm&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            # If the constants exist, then the direction of ascent doesn&#39;t</span>
<span class="gi">+            if program_result.success:</span>
<span class="gi">+                # There is no direction of ascent</span>
<span class="gi">+                return None, minimum_1_arborescences</span>
<span class="gi">+</span>
<span class="gi">+            # 5. GO TO 2</span>
<span class="gi">+</span>
<span class="gi">+    def find_epsilon(k, d):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Given the direction of ascent at pi, find the maximum distance we can go</span>
<span class="gi">+        in that direction.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        k_xy : set</span>
<span class="gi">+            The set of 1-arborescences which have the minimum rate of increase</span>
<span class="gi">+            in the direction of ascent</span>
<span class="gi">+</span>
<span class="gi">+        d : dict</span>
<span class="gi">+            The direction of ascent</span>
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        float</span>
<span class="gi">+            The distance we can travel in direction `d`</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        min_epsilon = math.inf</span>
<span class="gi">+        for e_u, e_v, e_w in G.edges(data=weight):</span>
<span class="gi">+            if (e_u, e_v) in k.edges:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Now, I have found a condition which MUST be true for the edges to</span>
<span class="gi">+            # be a valid substitute. The edge in the graph which is the</span>
<span class="gi">+            # substitute is the one with the same terminated end. This can be</span>
<span class="gi">+            # checked rather simply.</span>
<span class="gi">+            #</span>
<span class="gi">+            # Find the edge within k which is the substitute. Because k is a</span>
<span class="gi">+            # 1-arborescence, we know that they is only one such edges</span>
<span class="gi">+            # leading into every vertex.</span>
<span class="gi">+            if len(k.in_edges(e_v, data=weight)) &gt; 1:</span>
<span class="gi">+                raise Exception</span>
<span class="gi">+            sub_u, sub_v, sub_w = next(k.in_edges(e_v, data=weight).__iter__())</span>
<span class="gi">+            k.add_edge(e_u, e_v, **{weight: e_w})</span>
<span class="gi">+            k.remove_edge(sub_u, sub_v)</span>
<span class="gi">+            if (</span>
<span class="gi">+                max(d for n, d in k.in_degree()) &lt;= 1</span>
<span class="gi">+                and len(G) == k.number_of_edges()</span>
<span class="gi">+                and nx.is_weakly_connected(k)</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Ascent method calculation</span>
<span class="gi">+                if d[sub_u] == d[e_u] or sub_w == e_w:</span>
<span class="gi">+                    # Revert to the original graph</span>
<span class="gi">+                    k.remove_edge(e_u, e_v)</span>
<span class="gi">+                    k.add_edge(sub_u, sub_v, **{weight: sub_w})</span>
<span class="gi">+                    continue</span>
<span class="gi">+                epsilon = (sub_w - e_w) / (d[e_u] - d[sub_u])</span>
<span class="gi">+                if 0 &lt; epsilon &lt; min_epsilon:</span>
<span class="gi">+                    min_epsilon = epsilon</span>
<span class="gi">+            # Revert to the original graph</span>
<span class="gi">+            k.remove_edge(e_u, e_v)</span>
<span class="gi">+            k.add_edge(sub_u, sub_v, **{weight: sub_w})</span>
<span class="gi">+</span>
<span class="gi">+        return min_epsilon</span>
<span class="gi">+</span>
<span class="gi">+    # I have to know that the elements in pi correspond to the correct elements</span>
<span class="gi">+    # in the direction of ascent, even if the node labels are not integers.</span>
<span class="gi">+    # Thus, I will use dictionaries to made that mapping.</span>
<span class="gi">+    pi_dict = {}</span>
<span class="gi">+    for n in G:</span>
<span class="gi">+        pi_dict[n] = 0</span>
<span class="gi">+    del n</span>
<span class="gi">+    original_edge_weights = {}</span>
<span class="gi">+    for u, v, d in G.edges(data=True):</span>
<span class="gi">+        original_edge_weights[(u, v)] = d[weight]</span>
<span class="gi">+    dir_ascent, k_d = direction_of_ascent()</span>
<span class="gi">+    while dir_ascent is not None:</span>
<span class="gi">+        max_distance = find_epsilon(k_d, dir_ascent)</span>
<span class="gi">+        for n, v in dir_ascent.items():</span>
<span class="gi">+            pi_dict[n] += max_distance * v</span>
<span class="gi">+        for u, v, d in G.edges(data=True):</span>
<span class="gi">+            d[weight] = original_edge_weights[(u, v)] + pi_dict[u]</span>
<span class="gi">+        dir_ascent, k_d = direction_of_ascent()</span>
<span class="gi">+    nx._clear_cache(G)</span>
<span class="gi">+    # k_d is no longer an individual 1-arborescence but rather a set of</span>
<span class="gi">+    # minimal 1-arborescences at the maximum point of the polytope and should</span>
<span class="gi">+    # be reflected as such</span>
<span class="gi">+    k_max = k_d</span>
<span class="gi">+</span>
<span class="gi">+    # Search for a cycle within k_max. If a cycle exists, return it as the</span>
<span class="gi">+    # solution</span>
<span class="gi">+    for k in k_max:</span>
<span class="gi">+        if len([n for n in k if k.degree(n) == 2]) == G.order():</span>
<span class="gi">+            # Tour found</span>
<span class="gi">+            # TODO: this branch does not restore original_edge_weights of G!</span>
<span class="gi">+            return k.size(weight), k</span>
<span class="gi">+</span>
<span class="gi">+    # Write the original edge weights back to G and every member of k_max at</span>
<span class="gi">+    # the maximum point. Also average the number of times that edge appears in</span>
<span class="gi">+    # the set of minimal 1-arborescences.</span>
<span class="gi">+    x_star = {}</span>
<span class="gi">+    size_k_max = len(k_max)</span>
<span class="gi">+    for u, v, d in G.edges(data=True):</span>
<span class="gi">+        edge_count = 0</span>
<span class="gi">+        d[weight] = original_edge_weights[(u, v)]</span>
<span class="gi">+        for k in k_max:</span>
<span class="gi">+            if (u, v) in k.edges():</span>
<span class="gi">+                edge_count += 1</span>
<span class="gi">+                k[u][v][weight] = original_edge_weights[(u, v)]</span>
<span class="gi">+        x_star[(u, v)] = edge_count / size_k_max</span>
<span class="gi">+    # Now symmetrize the edges in x_star and scale them according to (5) in</span>
<span class="gi">+    # reference [1]</span>
<span class="gi">+    z_star = {}</span>
<span class="gi">+    scale_factor = (G.order() - 1) / G.order()</span>
<span class="gi">+    for u, v in x_star:</span>
<span class="gi">+        frequency = x_star[(u, v)] + x_star[(v, u)]</span>
<span class="gi">+        if frequency &gt; 0:</span>
<span class="gi">+            z_star[(u, v)] = scale_factor * frequency</span>
<span class="gi">+    del x_star</span>
<span class="gi">+    # Return the optimal weight and the z dict</span>
<span class="gi">+    return next(k_max.__iter__()).size(weight), z_star</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -423,11 +850,90 @@ def spanning_tree_distribution(G, z):</span>
<span class="w"> </span>        The probability distribution which approximately preserves the marginal
<span class="w"> </span>        probabilities of `z`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def greedy_tsp(G, weight=&#39;weight&#39;, source=None):</span>
<span class="gi">+    from math import exp</span>
<span class="gi">+    from math import log as ln</span>
<span class="gi">+</span>
<span class="gi">+    def q(e):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        The value of q(e) is described in the Asadpour paper is &quot;the</span>
<span class="gi">+        probability that edge e will be included in a spanning tree T that is</span>
<span class="gi">+        chosen with probability proportional to exp(gamma(T))&quot; which</span>
<span class="gi">+        basically means that it is the total probability of the edge appearing</span>
<span class="gi">+        across the whole distribution.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        e : tuple</span>
<span class="gi">+            The `(u, v)` tuple describing the edge we are interested in</span>
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        float</span>
<span class="gi">+            The probability that a spanning tree chosen according to the</span>
<span class="gi">+            current values of gamma will include edge `e`.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Create the laplacian matrices</span>
<span class="gi">+        for u, v, d in G.edges(data=True):</span>
<span class="gi">+            d[lambda_key] = exp(gamma[(u, v)])</span>
<span class="gi">+        G_Kirchhoff = nx.total_spanning_tree_weight(G, lambda_key)</span>
<span class="gi">+        G_e = nx.contracted_edge(G, e, self_loops=False)</span>
<span class="gi">+        G_e_Kirchhoff = nx.total_spanning_tree_weight(G_e, lambda_key)</span>
<span class="gi">+</span>
<span class="gi">+        # Multiply by the weight of the contracted edge since it is not included</span>
<span class="gi">+        # in the total weight of the contracted graph.</span>
<span class="gi">+        return exp(gamma[(e[0], e[1])]) * G_e_Kirchhoff / G_Kirchhoff</span>
<span class="gi">+</span>
<span class="gi">+    # initialize gamma to the zero dict</span>
<span class="gi">+    gamma = {}</span>
<span class="gi">+    for u, v, _ in G.edges:</span>
<span class="gi">+        gamma[(u, v)] = 0</span>
<span class="gi">+</span>
<span class="gi">+    # set epsilon</span>
<span class="gi">+    EPSILON = 0.2</span>
<span class="gi">+</span>
<span class="gi">+    # pick an edge attribute name that is unlikely to be in the graph</span>
<span class="gi">+    lambda_key = &quot;spanning_tree_distribution&#39;s secret attribute name for lambda&quot;</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        # We need to know that know that no values of q_e are greater than</span>
<span class="gi">+        # (1 + epsilon) * z_e, however changing one gamma value can increase the</span>
<span class="gi">+        # value of a different q_e, so we have to complete the for loop without</span>
<span class="gi">+        # changing anything for the condition to be meet</span>
<span class="gi">+        in_range_count = 0</span>
<span class="gi">+        # Search for an edge with q_e &gt; (1 + epsilon) * z_e</span>
<span class="gi">+        for u, v in gamma:</span>
<span class="gi">+            e = (u, v)</span>
<span class="gi">+            q_e = q(e)</span>
<span class="gi">+            z_e = z[e]</span>
<span class="gi">+            if q_e &gt; (1 + EPSILON) * z_e:</span>
<span class="gi">+                delta = ln(</span>
<span class="gi">+                    (q_e * (1 - (1 + EPSILON / 2) * z_e))</span>
<span class="gi">+                    / ((1 - q_e) * (1 + EPSILON / 2) * z_e)</span>
<span class="gi">+                )</span>
<span class="gi">+                gamma[e] -= delta</span>
<span class="gi">+                # Check that delta had the desired effect</span>
<span class="gi">+                new_q_e = q(e)</span>
<span class="gi">+                desired_q_e = (1 + EPSILON / 2) * z_e</span>
<span class="gi">+                if round(new_q_e, 8) != round(desired_q_e, 8):</span>
<span class="gi">+                    raise nx.NetworkXError(</span>
<span class="gi">+                        f&quot;Unable to modify probability for edge ({u}, {v})&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                in_range_count += 1</span>
<span class="gi">+        # Check if the for loop terminated without changing any gamma</span>
<span class="gi">+        if in_range_count == len(gamma):</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    # Remove the new edge attributes</span>
<span class="gi">+    for _, _, d in G.edges(data=True):</span>
<span class="gi">+        if lambda_key in d:</span>
<span class="gi">+            del d[lambda_key]</span>
<span class="gi">+</span>
<span class="gi">+    return gamma</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def greedy_tsp(G, weight=&quot;weight&quot;, source=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a low cost cycle starting at `source` and its cost.

<span class="w"> </span>    This approximates a solution to the traveling salesman problem.
<span class="gu">@@ -503,14 +1009,46 @@ def greedy_tsp(G, weight=&#39;weight&#39;, source=None):</span>

<span class="w"> </span>    Time complexity: It has a running time $O(|V|^2)$
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check that G is a complete graph</span>
<span class="gi">+    N = len(G) - 1</span>
<span class="gi">+    # This check ignores selfloops which is what we want here.</span>
<span class="gi">+    if any(len(nbrdict) - (n in nbrdict) != N for n, nbrdict in G.adj.items()):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;G must be a complete graph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if source is None:</span>
<span class="gi">+        source = nx.utils.arbitrary_element(G)</span>
<span class="gi">+</span>
<span class="gi">+    if G.number_of_nodes() == 2:</span>
<span class="gi">+        neighbor = next(G.neighbors(source))</span>
<span class="gi">+        return [source, neighbor, source]</span>
<span class="gi">+</span>
<span class="gi">+    nodeset = set(G)</span>
<span class="gi">+    nodeset.remove(source)</span>
<span class="gi">+    cycle = [source]</span>
<span class="gi">+    next_node = source</span>
<span class="gi">+    while nodeset:</span>
<span class="gi">+        nbrdict = G[next_node]</span>
<span class="gi">+        next_node = min(nodeset, key=lambda n: nbrdict[n].get(weight, 1))</span>
<span class="gi">+        cycle.append(next_node)</span>
<span class="gi">+        nodeset.remove(next_node)</span>
<span class="gi">+    cycle.append(cycle[0])</span>
<span class="gi">+    return cycle</span>


<span class="w"> </span>@py_random_state(9)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def simulated_annealing_tsp(G, init_cycle, weight=&#39;weight&#39;, source=None,</span>
<span class="gd">-    temp=100, move=&#39;1-1&#39;, max_iterations=10, N_inner=100, alpha=0.01, seed=None</span>
<span class="gd">-    ):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def simulated_annealing_tsp(</span>
<span class="gi">+    G,</span>
<span class="gi">+    init_cycle,</span>
<span class="gi">+    weight=&quot;weight&quot;,</span>
<span class="gi">+    source=None,</span>
<span class="gi">+    temp=100,</span>
<span class="gi">+    move=&quot;1-1&quot;,</span>
<span class="gi">+    max_iterations=10,</span>
<span class="gi">+    N_inner=100,</span>
<span class="gi">+    alpha=0.01,</span>
<span class="gi">+    seed=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns an approximate solution to the traveling salesman problem.

<span class="w"> </span>    This function uses simulated annealing to approximate the minimal cost
<span class="gu">@@ -663,14 +1201,84 @@ def simulated_annealing_tsp(G, init_cycle, weight=&#39;weight&#39;, source=None,</span>
<span class="w"> </span>    For more information and how the algorithm is inspired see:
<span class="w"> </span>    http://en.wikipedia.org/wiki/Simulated_annealing
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if move == &quot;1-1&quot;:</span>
<span class="gi">+        move = swap_two_nodes</span>
<span class="gi">+    elif move == &quot;1-0&quot;:</span>
<span class="gi">+        move = move_one_node</span>
<span class="gi">+    if init_cycle == &quot;greedy&quot;:</span>
<span class="gi">+        # Construct an initial solution using a greedy algorithm.</span>
<span class="gi">+        cycle = greedy_tsp(G, weight=weight, source=source)</span>
<span class="gi">+        if G.number_of_nodes() == 2:</span>
<span class="gi">+            return cycle</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        cycle = list(init_cycle)</span>
<span class="gi">+        if source is None:</span>
<span class="gi">+            source = cycle[0]</span>
<span class="gi">+        elif source != cycle[0]:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;source must be first node in init_cycle&quot;)</span>
<span class="gi">+        if cycle[0] != cycle[-1]:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;init_cycle must be a cycle. (return to start)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if len(cycle) - 1 != len(G) or len(set(G.nbunch_iter(cycle))) != len(G):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;init_cycle should be a cycle over all nodes in G.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Check that G is a complete graph</span>
<span class="gi">+        N = len(G) - 1</span>
<span class="gi">+        # This check ignores selfloops which is what we want here.</span>
<span class="gi">+        if any(len(nbrdict) - (n in nbrdict) != N for n, nbrdict in G.adj.items()):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;G must be a complete graph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if G.number_of_nodes() == 2:</span>
<span class="gi">+            neighbor = next(G.neighbors(source))</span>
<span class="gi">+            return [source, neighbor, source]</span>
<span class="gi">+</span>
<span class="gi">+    # Find the cost of initial solution</span>
<span class="gi">+    cost = sum(G[u][v].get(weight, 1) for u, v in pairwise(cycle))</span>
<span class="gi">+</span>
<span class="gi">+    count = 0</span>
<span class="gi">+    best_cycle = cycle.copy()</span>
<span class="gi">+    best_cost = cost</span>
<span class="gi">+    while count &lt;= max_iterations and temp &gt; 0:</span>
<span class="gi">+        count += 1</span>
<span class="gi">+        for i in range(N_inner):</span>
<span class="gi">+            adj_sol = move(cycle, seed)</span>
<span class="gi">+            adj_cost = sum(G[u][v].get(weight, 1) for u, v in pairwise(adj_sol))</span>
<span class="gi">+            delta = adj_cost - cost</span>
<span class="gi">+            if delta &lt;= 0:</span>
<span class="gi">+                # Set current solution the adjacent solution.</span>
<span class="gi">+                cycle = adj_sol</span>
<span class="gi">+                cost = adj_cost</span>
<span class="gi">+</span>
<span class="gi">+                if cost &lt; best_cost:</span>
<span class="gi">+                    count = 0</span>
<span class="gi">+                    best_cycle = cycle.copy()</span>
<span class="gi">+                    best_cost = cost</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Accept even a worse solution with probability p.</span>
<span class="gi">+                p = math.exp(-delta / temp)</span>
<span class="gi">+                if p &gt;= seed.random():</span>
<span class="gi">+                    cycle = adj_sol</span>
<span class="gi">+                    cost = adj_cost</span>
<span class="gi">+        temp -= temp * alpha</span>
<span class="gi">+</span>
<span class="gi">+    return best_cycle</span>


<span class="w"> </span>@py_random_state(9)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def threshold_accepting_tsp(G, init_cycle, weight=&#39;weight&#39;, source=None,</span>
<span class="gd">-    threshold=1, move=&#39;1-1&#39;, max_iterations=10, N_inner=100, alpha=0.1,</span>
<span class="gd">-    seed=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def threshold_accepting_tsp(</span>
<span class="gi">+    G,</span>
<span class="gi">+    init_cycle,</span>
<span class="gi">+    weight=&quot;weight&quot;,</span>
<span class="gi">+    source=None,</span>
<span class="gi">+    threshold=1,</span>
<span class="gi">+    move=&quot;1-1&quot;,</span>
<span class="gi">+    max_iterations=10,</span>
<span class="gi">+    N_inner=100,</span>
<span class="gi">+    alpha=0.1,</span>
<span class="gi">+    seed=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns an approximate solution to the traveling salesman problem.

<span class="w"> </span>    This function uses threshold accepting methods to approximate the minimal cost
<span class="gu">@@ -828,4 +1436,63 @@ def threshold_accepting_tsp(G, init_cycle, weight=&#39;weight&#39;, source=None,</span>
<span class="w"> </span>    simulated_annealing_tsp

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if move == &quot;1-1&quot;:</span>
<span class="gi">+        move = swap_two_nodes</span>
<span class="gi">+    elif move == &quot;1-0&quot;:</span>
<span class="gi">+        move = move_one_node</span>
<span class="gi">+    if init_cycle == &quot;greedy&quot;:</span>
<span class="gi">+        # Construct an initial solution using a greedy algorithm.</span>
<span class="gi">+        cycle = greedy_tsp(G, weight=weight, source=source)</span>
<span class="gi">+        if G.number_of_nodes() == 2:</span>
<span class="gi">+            return cycle</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        cycle = list(init_cycle)</span>
<span class="gi">+        if source is None:</span>
<span class="gi">+            source = cycle[0]</span>
<span class="gi">+        elif source != cycle[0]:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;source must be first node in init_cycle&quot;)</span>
<span class="gi">+        if cycle[0] != cycle[-1]:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;init_cycle must be a cycle. (return to start)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if len(cycle) - 1 != len(G) or len(set(G.nbunch_iter(cycle))) != len(G):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;init_cycle is not all and only nodes.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Check that G is a complete graph</span>
<span class="gi">+        N = len(G) - 1</span>
<span class="gi">+        # This check ignores selfloops which is what we want here.</span>
<span class="gi">+        if any(len(nbrdict) - (n in nbrdict) != N for n, nbrdict in G.adj.items()):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;G must be a complete graph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if G.number_of_nodes() == 2:</span>
<span class="gi">+            neighbor = list(G.neighbors(source))[0]</span>
<span class="gi">+            return [source, neighbor, source]</span>
<span class="gi">+</span>
<span class="gi">+    # Find the cost of initial solution</span>
<span class="gi">+    cost = sum(G[u][v].get(weight, 1) for u, v in pairwise(cycle))</span>
<span class="gi">+</span>
<span class="gi">+    count = 0</span>
<span class="gi">+    best_cycle = cycle.copy()</span>
<span class="gi">+    best_cost = cost</span>
<span class="gi">+    while count &lt;= max_iterations:</span>
<span class="gi">+        count += 1</span>
<span class="gi">+        accepted = False</span>
<span class="gi">+        for i in range(N_inner):</span>
<span class="gi">+            adj_sol = move(cycle, seed)</span>
<span class="gi">+            adj_cost = sum(G[u][v].get(weight, 1) for u, v in pairwise(adj_sol))</span>
<span class="gi">+            delta = adj_cost - cost</span>
<span class="gi">+            if delta &lt;= threshold:</span>
<span class="gi">+                accepted = True</span>
<span class="gi">+</span>
<span class="gi">+                # Set current solution the adjacent solution.</span>
<span class="gi">+                cycle = adj_sol</span>
<span class="gi">+                cost = adj_cost</span>
<span class="gi">+</span>
<span class="gi">+                if cost &lt; best_cost:</span>
<span class="gi">+                    count = 0</span>
<span class="gi">+                    best_cycle = cycle.copy()</span>
<span class="gi">+                    best_cost = cost</span>
<span class="gi">+        if accepted:</span>
<span class="gi">+            threshold -= threshold * alpha</span>
<span class="gi">+</span>
<span class="gi">+    return best_cycle</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/treewidth.py b/networkx/algorithms/approximation/treewidth.py</span>
<span class="gh">index 33ba4841d..31d73f636 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/treewidth.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/treewidth.py</span>
<span class="gu">@@ -28,16 +28,19 @@ There are two different functions for computing a tree decomposition:</span>
<span class="w"> </span>      https://web.archive.org/web/20210507025929/http://web.eecs.utk.edu/~cphill25/cs594_spring2015_projects/treewidth.pdf

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>import sys
<span class="w"> </span>from heapq import heapify, heappop, heappush
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;treewidth_min_degree&#39;, &#39;treewidth_min_fill_in&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;treewidth_min_degree&quot;, &quot;treewidth_min_fill_in&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def treewidth_min_degree(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns a treewidth decomposition using the Minimum Degree heuristic.
<span class="gu">@@ -56,11 +59,12 @@ def treewidth_min_degree(G):</span>
<span class="w"> </span>    Treewidth decomposition : (int, Graph) tuple
<span class="w"> </span>          2-tuple with treewidth and the corresponding decomposed tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    deg_heuristic = MinDegreeHeuristic(G)</span>
<span class="gi">+    return treewidth_decomp(G, lambda graph: deg_heuristic.best_node(graph))</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def treewidth_min_fill_in(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns a treewidth decomposition using the Minimum Fill-in heuristic.
<span class="gu">@@ -78,7 +82,7 @@ def treewidth_min_fill_in(G):</span>
<span class="w"> </span>    Treewidth decomposition : (int, Graph) tuple
<span class="w"> </span>        2-tuple with treewidth and the corresponding decomposed tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return treewidth_decomp(G, min_fill_in_heuristic)</span>


<span class="w"> </span>class MinDegreeHeuristic:
<span class="gu">@@ -92,13 +96,41 @@ class MinDegreeHeuristic:</span>

<span class="w"> </span>    def __init__(self, graph):
<span class="w"> </span>        self._graph = graph
<span class="gi">+</span>
<span class="gi">+        # nodes that have to be updated in the heap before each iteration</span>
<span class="w"> </span>        self._update_nodes = []
<span class="gd">-        self._degreeq = []</span>
<span class="gi">+</span>
<span class="gi">+        self._degreeq = []  # a heapq with 3-tuples (degree,unique_id,node)</span>
<span class="w"> </span>        self.count = itertools.count()
<span class="gi">+</span>
<span class="gi">+        # build heap with initial degrees</span>
<span class="w"> </span>        for n in graph:
<span class="w"> </span>            self._degreeq.append((len(graph[n]), next(self.count), n))
<span class="w"> </span>        heapify(self._degreeq)

<span class="gi">+    def best_node(self, graph):</span>
<span class="gi">+        # update nodes in self._update_nodes</span>
<span class="gi">+        for n in self._update_nodes:</span>
<span class="gi">+            # insert changed degrees into degreeq</span>
<span class="gi">+            heappush(self._degreeq, (len(graph[n]), next(self.count), n))</span>
<span class="gi">+</span>
<span class="gi">+        # get the next valid (minimum degree) node</span>
<span class="gi">+        while self._degreeq:</span>
<span class="gi">+            (min_degree, _, elim_node) = heappop(self._degreeq)</span>
<span class="gi">+            if elim_node not in graph or len(graph[elim_node]) != min_degree:</span>
<span class="gi">+                # outdated entry in degreeq</span>
<span class="gi">+                continue</span>
<span class="gi">+            elif min_degree == len(graph) - 1:</span>
<span class="gi">+                # fully connected: abort condition</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            # remember to update nodes in the heap before getting the next node</span>
<span class="gi">+            self._update_nodes = graph[elim_node]</span>
<span class="gi">+            return elim_node</span>
<span class="gi">+</span>
<span class="gi">+        # the heap is empty: abort</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>def min_fill_in_heuristic(graph):
<span class="w"> </span>    &quot;&quot;&quot;Implements the Minimum Degree heuristic.
<span class="gu">@@ -108,7 +140,41 @@ def min_fill_in_heuristic(graph):</span>
<span class="w"> </span>    possible. This algorithm chooses the nodes using the Minimum Fill-In
<span class="w"> </span>    heuristic. The running time of the algorithm is :math:`O(V^3)` and it uses
<span class="w"> </span>    additional constant memory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if len(graph) == 0:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    min_fill_in_node = None</span>
<span class="gi">+</span>
<span class="gi">+    min_fill_in = sys.maxsize</span>
<span class="gi">+</span>
<span class="gi">+    # sort nodes by degree</span>
<span class="gi">+    nodes_by_degree = sorted(graph, key=lambda x: len(graph[x]))</span>
<span class="gi">+    min_degree = len(graph[nodes_by_degree[0]])</span>
<span class="gi">+</span>
<span class="gi">+    # abort condition (handle complete graph)</span>
<span class="gi">+    if min_degree == len(graph) - 1:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    for node in nodes_by_degree:</span>
<span class="gi">+        num_fill_in = 0</span>
<span class="gi">+        nbrs = graph[node]</span>
<span class="gi">+        for nbr in nbrs:</span>
<span class="gi">+            # count how many nodes in nbrs current nbr is not connected to</span>
<span class="gi">+            # subtract 1 for the node itself</span>
<span class="gi">+            num_fill_in += len(nbrs - graph[nbr]) - 1</span>
<span class="gi">+            if num_fill_in &gt;= 2 * min_fill_in:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        num_fill_in /= 2  # divide by 2 because of double counting</span>
<span class="gi">+</span>
<span class="gi">+        if num_fill_in &lt; min_fill_in:  # update min-fill-in node</span>
<span class="gi">+            if num_fill_in == 0:</span>
<span class="gi">+                return node</span>
<span class="gi">+            min_fill_in = num_fill_in</span>
<span class="gi">+            min_fill_in_node = node</span>
<span class="gi">+</span>
<span class="gi">+    return min_fill_in_node</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -125,4 +191,62 @@ def treewidth_decomp(G, heuristic=min_fill_in_heuristic):</span>
<span class="w"> </span>    Treewidth decomposition : (int, Graph) tuple
<span class="w"> </span>        2-tuple with treewidth and the corresponding decomposed tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # make dict-of-sets structure</span>
<span class="gi">+    graph = {n: set(G[n]) - {n} for n in G}</span>
<span class="gi">+</span>
<span class="gi">+    # stack containing nodes and neighbors in the order from the heuristic</span>
<span class="gi">+    node_stack = []</span>
<span class="gi">+</span>
<span class="gi">+    # get first node from heuristic</span>
<span class="gi">+    elim_node = heuristic(graph)</span>
<span class="gi">+    while elim_node is not None:</span>
<span class="gi">+        # connect all neighbors with each other</span>
<span class="gi">+        nbrs = graph[elim_node]</span>
<span class="gi">+        for u, v in itertools.permutations(nbrs, 2):</span>
<span class="gi">+            if v not in graph[u]:</span>
<span class="gi">+                graph[u].add(v)</span>
<span class="gi">+</span>
<span class="gi">+        # push node and its current neighbors on stack</span>
<span class="gi">+        node_stack.append((elim_node, nbrs))</span>
<span class="gi">+</span>
<span class="gi">+        # remove node from graph</span>
<span class="gi">+        for u in graph[elim_node]:</span>
<span class="gi">+            graph[u].remove(elim_node)</span>
<span class="gi">+</span>
<span class="gi">+        del graph[elim_node]</span>
<span class="gi">+        elim_node = heuristic(graph)</span>
<span class="gi">+</span>
<span class="gi">+    # the abort condition is met; put all remaining nodes into one bag</span>
<span class="gi">+    decomp = nx.Graph()</span>
<span class="gi">+    first_bag = frozenset(graph.keys())</span>
<span class="gi">+    decomp.add_node(first_bag)</span>
<span class="gi">+</span>
<span class="gi">+    treewidth = len(first_bag) - 1</span>
<span class="gi">+</span>
<span class="gi">+    while node_stack:</span>
<span class="gi">+        # get node and its neighbors from the stack</span>
<span class="gi">+        (curr_node, nbrs) = node_stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+        # find a bag all neighbors are in</span>
<span class="gi">+        old_bag = None</span>
<span class="gi">+        for bag in decomp.nodes:</span>
<span class="gi">+            if nbrs &lt;= bag:</span>
<span class="gi">+                old_bag = bag</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if old_bag is None:</span>
<span class="gi">+            # no old_bag was found: just connect to the first_bag</span>
<span class="gi">+            old_bag = first_bag</span>
<span class="gi">+</span>
<span class="gi">+        # create new node for decomposition</span>
<span class="gi">+        nbrs.add(curr_node)</span>
<span class="gi">+        new_bag = frozenset(nbrs)</span>
<span class="gi">+</span>
<span class="gi">+        # update treewidth</span>
<span class="gi">+        treewidth = max(treewidth, len(new_bag) - 1)</span>
<span class="gi">+</span>
<span class="gi">+        # add edge to decomposition (implicitly also adds the new node)</span>
<span class="gi">+        decomp.add_edge(old_bag, new_bag)</span>
<span class="gi">+</span>
<span class="gi">+    return treewidth, decomp</span>
<span class="gh">diff --git a/networkx/algorithms/approximation/vertex_cover.py b/networkx/algorithms/approximation/vertex_cover.py</span>
<span class="gh">index 10b268303..c71399ebc 100644</span>
<span class="gd">--- a/networkx/algorithms/approximation/vertex_cover.py</span>
<span class="gi">+++ b/networkx/algorithms/approximation/vertex_cover.py</span>
<span class="gu">@@ -8,12 +8,13 @@ is incident to at least one node in the subset.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;min_weighted_vertex_cover&#39;]</span>

<span class="gi">+__all__ = [&quot;min_weighted_vertex_cover&quot;]</span>

<span class="gd">-@nx._dispatchable(node_attrs=&#39;weight&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def min_weighted_vertex_cover(G, weight=None):
<span class="gd">-    &quot;&quot;&quot;Returns an approximate minimum weighted vertex cover.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns an approximate minimum weighted vertex cover.</span>

<span class="w"> </span>    The set of nodes returned by this function is guaranteed to be a
<span class="w"> </span>    vertex cover, and the total weight of the set is guaranteed to be at
<span class="gu">@@ -22,7 +23,7 @@ def min_weighted_vertex_cover(G, weight=None):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       w(S) \\leq 2 * w(S^*),</span>
<span class="gi">+       w(S) \leq 2 * w(S^*),</span>

<span class="w"> </span>    where $S$ is the vertex cover returned by this function,
<span class="w"> </span>    $S^*$ is the vertex cover of minimum weight out of all vertex
<span class="gu">@@ -54,7 +55,7 @@ def min_weighted_vertex_cover(G, weight=None):</span>
<span class="w"> </span>    This is the local-ratio algorithm for computing an approximate
<span class="w"> </span>    vertex cover. The algorithm greedily reduces the costs over edges,
<span class="w"> </span>    iteratively building a cover. The worst-case runtime of this
<span class="gd">-    implementation is $O(m \\log n)$, where $n$ is the number</span>
<span class="gi">+    implementation is $O(m \log n)$, where $n$ is the number</span>
<span class="w"> </span>    of nodes and $m$ the number of edges in the graph.

<span class="w"> </span>    References
<span class="gu">@@ -65,4 +66,17 @@ def min_weighted_vertex_cover(G, weight=None):</span>
<span class="w"> </span>       &lt;http://www.cs.technion.ac.il/~reuven/PDF/vc_lr.pdf&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cost = dict(G.nodes(data=weight, default=1))</span>
<span class="gi">+    # While there are uncovered edges, choose an uncovered and update</span>
<span class="gi">+    # the cost of the remaining edges.</span>
<span class="gi">+    cover = set()</span>
<span class="gi">+    for u, v in G.edges():</span>
<span class="gi">+        if u in cover or v in cover:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if cost[u] &lt;= cost[v]:</span>
<span class="gi">+            cover.add(u)</span>
<span class="gi">+            cost[v] -= cost[u]</span>
<span class="gi">+        else:</span>
<span class="gi">+            cover.add(v)</span>
<span class="gi">+            cost[u] -= cost[v]</span>
<span class="gi">+    return cover</span>
<span class="gh">diff --git a/networkx/algorithms/assortativity/connectivity.py b/networkx/algorithms/assortativity/connectivity.py</span>
<span class="gh">index d4dd9ca05..c3fde0da6 100644</span>
<span class="gd">--- a/networkx/algorithms/assortativity/connectivity.py</span>
<span class="gi">+++ b/networkx/algorithms/assortativity/connectivity.py</span>
<span class="gu">@@ -1,12 +1,15 @@</span>
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;average_degree_connectivity&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;average_degree_connectivity&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def average_degree_connectivity(G, source=&#39;in+out&#39;, target=&#39;in+out&#39;, nodes=</span>
<span class="gd">-    None, weight=None):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the average degree connectivity of graph.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def average_degree_connectivity(</span>
<span class="gi">+    G, source=&quot;in+out&quot;, target=&quot;in+out&quot;, nodes=None, weight=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the average degree connectivity of graph.</span>

<span class="w"> </span>    The average degree connectivity is the average nearest neighbor degree of
<span class="w"> </span>    nodes with degree k. For weighted graphs, an analogous measure can
<span class="gu">@@ -15,7 +18,7 @@ def average_degree_connectivity(G, source=&#39;in+out&#39;, target=&#39;in+out&#39;, nodes=</span>

<span class="w"> </span>    .. math::

<span class="gd">-        k_{nn,i}^{w} = \\frac{1}{s_i} \\sum_{j \\in N(i)} w_{ij} k_j</span>
<span class="gi">+        k_{nn,i}^{w} = \frac{1}{s_i} \sum_{j \in N(i)} w_{ij} k_j</span>

<span class="w"> </span>    where `s_i` is the weighted degree of node `i`,
<span class="w"> </span>    `w_{ij}` is the weight of the edge that links `i` and `j`,
<span class="gu">@@ -70,4 +73,50 @@ def average_degree_connectivity(G, source=&#39;in+out&#39;, target=&#39;in+out&#39;, nodes=</span>
<span class="w"> </span>       &quot;The architecture of complex weighted networks&quot;.
<span class="w"> </span>       PNAS 101 (11): 3747–3752 (2004).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # First, determine the type of neighbors and the type of degree to use.</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        if source not in (&quot;in&quot;, &quot;out&quot;, &quot;in+out&quot;):</span>
<span class="gi">+            raise nx.NetworkXError(&#39;source must be one of &quot;in&quot;, &quot;out&quot;, or &quot;in+out&quot;&#39;)</span>
<span class="gi">+        if target not in (&quot;in&quot;, &quot;out&quot;, &quot;in+out&quot;):</span>
<span class="gi">+            raise nx.NetworkXError(&#39;target must be one of &quot;in&quot;, &quot;out&quot;, or &quot;in+out&quot;&#39;)</span>
<span class="gi">+        direction = {&quot;out&quot;: G.out_degree, &quot;in&quot;: G.in_degree, &quot;in+out&quot;: G.degree}</span>
<span class="gi">+        neighbor_funcs = {</span>
<span class="gi">+            &quot;out&quot;: G.successors,</span>
<span class="gi">+            &quot;in&quot;: G.predecessors,</span>
<span class="gi">+            &quot;in+out&quot;: G.neighbors,</span>
<span class="gi">+        }</span>
<span class="gi">+        source_degree = direction[source]</span>
<span class="gi">+        target_degree = direction[target]</span>
<span class="gi">+        neighbors = neighbor_funcs[source]</span>
<span class="gi">+        # `reverse` indicates whether to look at the in-edge when</span>
<span class="gi">+        # computing the weight of an edge.</span>
<span class="gi">+        reverse = source == &quot;in&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        if source != &quot;in+out&quot; or target != &quot;in+out&quot;:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;source and target arguments are only supported for directed graphs&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        source_degree = G.degree</span>
<span class="gi">+        target_degree = G.degree</span>
<span class="gi">+        neighbors = G.neighbors</span>
<span class="gi">+        reverse = False</span>
<span class="gi">+    dsum = defaultdict(int)</span>
<span class="gi">+    dnorm = defaultdict(int)</span>
<span class="gi">+    # Check if `source_nodes` is actually a single node in the graph.</span>
<span class="gi">+    source_nodes = source_degree(nodes)</span>
<span class="gi">+    if nodes in G:</span>
<span class="gi">+        source_nodes = [(nodes, source_degree(nodes))]</span>
<span class="gi">+    for n, k in source_nodes:</span>
<span class="gi">+        nbrdeg = target_degree(neighbors(n))</span>
<span class="gi">+        if weight is None:</span>
<span class="gi">+            s = sum(d for n, d in nbrdeg)</span>
<span class="gi">+        else:  # weight nbr degree by weight of (n,nbr) edge</span>
<span class="gi">+            if reverse:</span>
<span class="gi">+                s = sum(G[nbr][n].get(weight, 1) * d for nbr, d in nbrdeg)</span>
<span class="gi">+            else:</span>
<span class="gi">+                s = sum(G[n][nbr].get(weight, 1) * d for nbr, d in nbrdeg)</span>
<span class="gi">+        dnorm[k] += source_degree(n, weight=weight)</span>
<span class="gi">+        dsum[k] += s</span>
<span class="gi">+</span>
<span class="gi">+    # normalize</span>
<span class="gi">+    return {k: avg if dnorm[k] == 0 else avg / dnorm[k] for k, avg in dsum.items()}</span>
<span class="gh">diff --git a/networkx/algorithms/assortativity/correlation.py b/networkx/algorithms/assortativity/correlation.py</span>
<span class="gh">index a6d207842..170d219a5 100644</span>
<span class="gd">--- a/networkx/algorithms/assortativity/correlation.py</span>
<span class="gi">+++ b/networkx/algorithms/assortativity/correlation.py</span>
<span class="gu">@@ -1,16 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Node assortativity coefficients and correlation measures.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.algorithms.assortativity.mixing import attribute_mixing_matrix, degree_mixing_matrix</span>
<span class="gi">+from networkx.algorithms.assortativity.mixing import (</span>
<span class="gi">+    attribute_mixing_matrix,</span>
<span class="gi">+    degree_mixing_matrix,</span>
<span class="gi">+)</span>
<span class="w"> </span>from networkx.algorithms.assortativity.pairs import node_degree_xy
<span class="gd">-__all__ = [&#39;degree_pearson_correlation_coefficient&#39;,</span>
<span class="gd">-    &#39;degree_assortativity_coefficient&#39;,</span>
<span class="gd">-    &#39;attribute_assortativity_coefficient&#39;, &#39;numeric_assortativity_coefficient&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;degree_pearson_correlation_coefficient&quot;,</span>
<span class="gi">+    &quot;degree_assortativity_coefficient&quot;,</span>
<span class="gi">+    &quot;attribute_assortativity_coefficient&quot;,</span>
<span class="gi">+    &quot;numeric_assortativity_coefficient&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def degree_assortativity_coefficient(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None, nodes</span>
<span class="gd">-    =None):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def degree_assortativity_coefficient(G, x=&quot;out&quot;, y=&quot;in&quot;, weight=None, nodes=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute degree assortativity of graph.

<span class="w"> </span>    Assortativity measures the similarity of connections
<span class="gu">@@ -68,12 +74,34 @@ def degree_assortativity_coefficient(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None, nodes</span>
<span class="w"> </span>    .. [2] Foster, J.G., Foster, D.V., Grassberger, P. &amp; Paczuski, M.
<span class="w"> </span>       Edge direction and the structure of networks, PNAS 107, 10815-20 (2010).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def degree_pearson_correlation_coefficient(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None,</span>
<span class="gd">-    nodes=None):</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = G.nodes</span>
<span class="gi">+</span>
<span class="gi">+    degrees = None</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        indeg = (</span>
<span class="gi">+            {d for _, d in G.in_degree(nodes, weight=weight)}</span>
<span class="gi">+            if &quot;in&quot; in (x, y)</span>
<span class="gi">+            else set()</span>
<span class="gi">+        )</span>
<span class="gi">+        outdeg = (</span>
<span class="gi">+            {d for _, d in G.out_degree(nodes, weight=weight)}</span>
<span class="gi">+            if &quot;out&quot; in (x, y)</span>
<span class="gi">+            else set()</span>
<span class="gi">+        )</span>
<span class="gi">+        degrees = set.union(indeg, outdeg)</span>
<span class="gi">+    else:</span>
<span class="gi">+        degrees = {d for _, d in G.degree(nodes, weight=weight)}</span>
<span class="gi">+</span>
<span class="gi">+    mapping = {d: i for i, d in enumerate(degrees)}</span>
<span class="gi">+    M = degree_mixing_matrix(G, x=x, y=y, nodes=nodes, weight=weight, mapping=mapping)</span>
<span class="gi">+</span>
<span class="gi">+    return _numeric_ac(M, mapping=mapping)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def degree_pearson_correlation_coefficient(G, x=&quot;out&quot;, y=&quot;in&quot;, weight=None, nodes=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute degree assortativity of graph.

<span class="w"> </span>    Assortativity measures the similarity of connections
<span class="gu">@@ -124,10 +152,14 @@ def degree_pearson_correlation_coefficient(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None,</span>
<span class="w"> </span>    .. [2] Foster, J.G., Foster, D.V., Grassberger, P. &amp; Paczuski, M.
<span class="w"> </span>       Edge direction and the structure of networks, PNAS 107, 10815-20 (2010).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    xy = node_degree_xy(G, x=x, y=y, nodes=nodes, weight=weight)</span>
<span class="gi">+    x, y = zip(*xy)</span>
<span class="gi">+    return float(sp.stats.pearsonr(x, y)[0])</span>


<span class="gd">-@nx._dispatchable(node_attrs=&#39;attribute&#39;)</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;attribute&quot;)</span>
<span class="w"> </span>def attribute_assortativity_coefficient(G, attribute, nodes=None):
<span class="w"> </span>    &quot;&quot;&quot;Compute assortativity for node attributes.

<span class="gu">@@ -170,10 +202,11 @@ def attribute_assortativity_coefficient(G, attribute, nodes=None):</span>
<span class="w"> </span>    .. [1] M. E. J. Newman, Mixing patterns in networks,
<span class="w"> </span>       Physical Review E, 67 026126, 2003
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    M = attribute_mixing_matrix(G, attribute, nodes)</span>
<span class="gi">+    return attribute_ac(M)</span>


<span class="gd">-@nx._dispatchable(node_attrs=&#39;attribute&#39;)</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;attribute&quot;)</span>
<span class="w"> </span>def numeric_assortativity_coefficient(G, attribute, nodes=None):
<span class="w"> </span>    &quot;&quot;&quot;Compute assortativity for numerical node attributes.

<span class="gu">@@ -215,7 +248,12 @@ def numeric_assortativity_coefficient(G, attribute, nodes=None):</span>
<span class="w"> </span>    .. [1] M. E. J. Newman, Mixing patterns in networks
<span class="w"> </span>           Physical Review E, 67 026126, 2003
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = G.nodes</span>
<span class="gi">+    vals = {G.nodes[n][attribute] for n in nodes}</span>
<span class="gi">+    mapping = {d: i for i, d in enumerate(vals)}</span>
<span class="gi">+    M = attribute_mixing_matrix(G, attribute, nodes, mapping)</span>
<span class="gi">+    return _numeric_ac(M, mapping)</span>


<span class="w"> </span>def attribute_ac(M):
<span class="gu">@@ -237,4 +275,28 @@ def attribute_ac(M):</span>
<span class="w"> </span>    .. [1] M. E. J. Newman, Mixing patterns in networks,
<span class="w"> </span>       Physical Review E, 67 026126, 2003
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if M.sum() != 1.0:</span>
<span class="gi">+        M = M / M.sum()</span>
<span class="gi">+    s = (M @ M).sum()</span>
<span class="gi">+    t = M.trace()</span>
<span class="gi">+    r = (t - s) / (1 - s)</span>
<span class="gi">+    return float(r)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _numeric_ac(M, mapping):</span>
<span class="gi">+    # M is a 2D numpy array</span>
<span class="gi">+    # numeric assortativity coefficient, pearsonr</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if M.sum() != 1.0:</span>
<span class="gi">+        M = M / M.sum()</span>
<span class="gi">+    x = np.array(list(mapping.keys()))</span>
<span class="gi">+    y = x  # x and y have the same support</span>
<span class="gi">+    idx = list(mapping.values())</span>
<span class="gi">+    a = M.sum(axis=0)</span>
<span class="gi">+    b = M.sum(axis=1)</span>
<span class="gi">+    vara = (a[idx] * x**2).sum() - ((a[idx] * x).sum()) ** 2</span>
<span class="gi">+    varb = (b[idx] * y**2).sum() - ((b[idx] * y).sum()) ** 2</span>
<span class="gi">+    xy = np.outer(x, y)</span>
<span class="gi">+    ab = np.outer(a[idx], b[idx])</span>
<span class="gi">+    return float((xy * (M - ab)).sum() / np.sqrt(vara * varb))</span>
<span class="gh">diff --git a/networkx/algorithms/assortativity/mixing.py b/networkx/algorithms/assortativity/mixing.py</span>
<span class="gh">index 929c736b9..852ad82a4 100644</span>
<span class="gd">--- a/networkx/algorithms/assortativity/mixing.py</span>
<span class="gi">+++ b/networkx/algorithms/assortativity/mixing.py</span>
<span class="gu">@@ -4,11 +4,17 @@ Mixing matrices for node attributes and degree.</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.assortativity.pairs import node_attribute_xy, node_degree_xy
<span class="w"> </span>from networkx.utils import dict_to_numpy_array
<span class="gd">-__all__ = [&#39;attribute_mixing_matrix&#39;, &#39;attribute_mixing_dict&#39;,</span>
<span class="gd">-    &#39;degree_mixing_matrix&#39;, &#39;degree_mixing_dict&#39;, &#39;mixing_dict&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;attribute_mixing_matrix&quot;,</span>
<span class="gi">+    &quot;attribute_mixing_dict&quot;,</span>
<span class="gi">+    &quot;degree_mixing_matrix&quot;,</span>
<span class="gi">+    &quot;degree_mixing_dict&quot;,</span>
<span class="gi">+    &quot;mixing_dict&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@nx._dispatchable(node_attrs=&#39;attribute&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;attribute&quot;)</span>
<span class="w"> </span>def attribute_mixing_dict(G, attribute, nodes=None, normalized=False):
<span class="w"> </span>    &quot;&quot;&quot;Returns dictionary representation of mixing matrix for attribute.

<span class="gu">@@ -43,12 +49,12 @@ def attribute_mixing_dict(G, attribute, nodes=None, normalized=False):</span>
<span class="w"> </span>    d : dictionary
<span class="w"> </span>       Counts or joint probability of occurrence of attribute pairs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    xy_iter = node_attribute_xy(G, attribute, nodes)</span>
<span class="gi">+    return mixing_dict(xy_iter, normalized=normalized)</span>


<span class="gd">-@nx._dispatchable(node_attrs=&#39;attribute&#39;)</span>
<span class="gd">-def attribute_mixing_matrix(G, attribute, nodes=None, mapping=None,</span>
<span class="gd">-    normalized=True):</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;attribute&quot;)</span>
<span class="gi">+def attribute_mixing_matrix(G, attribute, nodes=None, mapping=None, normalized=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns mixing matrix for attribute.

<span class="w"> </span>    Parameters
<span class="gu">@@ -100,12 +106,15 @@ def attribute_mixing_matrix(G, attribute, nodes=None, mapping=None,</span>
<span class="w"> </span>    array([[0.  , 0.25],
<span class="w"> </span>           [0.25, 0.5 ]])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    d = attribute_mixing_dict(G, attribute, nodes)</span>
<span class="gi">+    a = dict_to_numpy_array(d, mapping=mapping)</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        a = a / a.sum()</span>
<span class="gi">+    return a</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def degree_mixing_dict(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None, nodes=None,</span>
<span class="gd">-    normalized=False):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def degree_mixing_dict(G, x=&quot;out&quot;, y=&quot;in&quot;, weight=None, nodes=None, normalized=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns dictionary representation of mixing matrix for degree.

<span class="w"> </span>    Parameters
<span class="gu">@@ -132,12 +141,14 @@ def degree_mixing_dict(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None, nodes=None,</span>
<span class="w"> </span>    d: dictionary
<span class="w"> </span>       Counts or joint probability of occurrence of degree pairs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    xy_iter = node_degree_xy(G, x=x, y=y, nodes=nodes, weight=weight)</span>
<span class="gi">+    return mixing_dict(xy_iter, normalized=normalized)</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def degree_mixing_matrix(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None, nodes=None,</span>
<span class="gd">-    normalized=True, mapping=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def degree_mixing_matrix(</span>
<span class="gi">+    G, x=&quot;out&quot;, y=&quot;in&quot;, weight=None, nodes=None, normalized=True, mapping=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns mixing matrix for attribute.

<span class="w"> </span>    Parameters
<span class="gu">@@ -199,7 +210,11 @@ def degree_mixing_matrix(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None, nodes=None,</span>
<span class="w"> </span>           [0. , 0. , 0. , 0. ],
<span class="w"> </span>           [0. , 0.5, 0. , 0. ]])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    d = degree_mixing_dict(G, x=x, y=y, nodes=nodes, weight=weight)</span>
<span class="gi">+    a = dict_to_numpy_array(d, mapping=mapping)</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        a = a / a.sum()</span>
<span class="gi">+    return a</span>


<span class="w"> </span>def mixing_dict(xy, normalized=False):
<span class="gu">@@ -221,4 +236,19 @@ def mixing_dict(xy, normalized=False):</span>
<span class="w"> </span>    d: dictionary
<span class="w"> </span>       Counts or Joint probability of occurrence of values in xy.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    d = {}</span>
<span class="gi">+    psum = 0.0</span>
<span class="gi">+    for x, y in xy:</span>
<span class="gi">+        if x not in d:</span>
<span class="gi">+            d[x] = {}</span>
<span class="gi">+        if y not in d:</span>
<span class="gi">+            d[y] = {}</span>
<span class="gi">+        v = d[x].get(y, 0)</span>
<span class="gi">+        d[x][y] = v + 1</span>
<span class="gi">+        psum += 1</span>
<span class="gi">+</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        for _, jdict in d.items():</span>
<span class="gi">+            for j in jdict:</span>
<span class="gi">+                jdict[j] /= psum</span>
<span class="gi">+    return d</span>
<span class="gh">diff --git a/networkx/algorithms/assortativity/neighbor_degree.py b/networkx/algorithms/assortativity/neighbor_degree.py</span>
<span class="gh">index 75b0f6d85..6488d041a 100644</span>
<span class="gd">--- a/networkx/algorithms/assortativity/neighbor_degree.py</span>
<span class="gi">+++ b/networkx/algorithms/assortativity/neighbor_degree.py</span>
<span class="gu">@@ -1,11 +1,11 @@</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;average_neighbor_degree&#39;]</span>

<span class="gi">+__all__ = [&quot;average_neighbor_degree&quot;]</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def average_neighbor_degree(G, source=&#39;out&#39;, target=&#39;out&#39;, nodes=None,</span>
<span class="gd">-    weight=None):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the average degree of the neighborhood of each node.</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def average_neighbor_degree(G, source=&quot;out&quot;, target=&quot;out&quot;, nodes=None, weight=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the average degree of the neighborhood of each node.</span>

<span class="w"> </span>    In an undirected graph, the neighborhood `N(i)` of node `i` contains the
<span class="w"> </span>    nodes that are connected to `i` by an edge.
<span class="gu">@@ -20,7 +20,7 @@ def average_neighbor_degree(G, source=&#39;out&#39;, target=&#39;out&#39;, nodes=None,</span>

<span class="w"> </span>    .. math::

<span class="gd">-        k_{nn,i} = \\frac{1}{|N(i)|} \\sum_{j \\in N(i)} k_j</span>
<span class="gi">+        k_{nn,i} = \frac{1}{|N(i)|} \sum_{j \in N(i)} k_j</span>

<span class="w"> </span>    where `N(i)` are the neighbors of node `i` and `k_j` is
<span class="w"> </span>    the degree of node `j` which belongs to `N(i)`. For weighted
<span class="gu">@@ -28,7 +28,7 @@ def average_neighbor_degree(G, source=&#39;out&#39;, target=&#39;out&#39;, nodes=None,</span>

<span class="w"> </span>    .. math::

<span class="gd">-        k_{nn,i}^{w} = \\frac{1}{s_i} \\sum_{j \\in N(i)} w_{ij} k_j</span>
<span class="gi">+        k_{nn,i}^{w} = \frac{1}{s_i} \sum_{j \in N(i)} w_{ij} k_j</span>

<span class="w"> </span>    where `s_i` is the weighted degree of node `i`, `w_{ij}`
<span class="w"> </span>    is the weight of the edge that links `i` and `j` and
<span class="gu">@@ -94,4 +94,67 @@ def average_neighbor_degree(G, source=&#39;out&#39;, target=&#39;out&#39;, nodes=None,</span>
<span class="w"> </span>       &quot;The architecture of complex weighted networks&quot;.
<span class="w"> </span>       PNAS 101 (11): 3747–3752 (2004).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        if source == &quot;in&quot;:</span>
<span class="gi">+            source_degree = G.in_degree</span>
<span class="gi">+        elif source == &quot;out&quot;:</span>
<span class="gi">+            source_degree = G.out_degree</span>
<span class="gi">+        elif source == &quot;in+out&quot;:</span>
<span class="gi">+            source_degree = G.degree</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;source argument {source} must be &#39;in&#39;, &#39;out&#39; or &#39;in+out&#39;&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if target == &quot;in&quot;:</span>
<span class="gi">+            target_degree = G.in_degree</span>
<span class="gi">+        elif target == &quot;out&quot;:</span>
<span class="gi">+            target_degree = G.out_degree</span>
<span class="gi">+        elif target == &quot;in+out&quot;:</span>
<span class="gi">+            target_degree = G.degree</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;target argument {target} must be &#39;in&#39;, &#39;out&#39; or &#39;in+out&#39;&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+    else:</span>
<span class="gi">+        if source != &quot;out&quot; or target != &quot;out&quot;:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;source and target arguments are only supported for directed graphs&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        source_degree = target_degree = G.degree</span>
<span class="gi">+</span>
<span class="gi">+    # precompute target degrees -- should *not* be weighted degree</span>
<span class="gi">+    t_deg = dict(target_degree())</span>
<span class="gi">+</span>
<span class="gi">+    # Set up both predecessor and successor neighbor dicts leaving empty if not needed</span>
<span class="gi">+    G_P = G_S = {n: {} for n in G}</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        # &quot;in&quot; or &quot;in+out&quot; cases: G_P contains predecessors</span>
<span class="gi">+        if &quot;in&quot; in source:</span>
<span class="gi">+            G_P = G.pred</span>
<span class="gi">+        # &quot;out&quot; or &quot;in+out&quot; cases: G_S contains successors</span>
<span class="gi">+        if &quot;out&quot; in source:</span>
<span class="gi">+            G_S = G.succ</span>
<span class="gi">+    else:</span>
<span class="gi">+        # undirected leave G_P empty but G_S is the adjacency</span>
<span class="gi">+        G_S = G.adj</span>
<span class="gi">+</span>
<span class="gi">+    # Main loop: Compute average degree of neighbors</span>
<span class="gi">+    avg = {}</span>
<span class="gi">+    for n, deg in source_degree(nodes, weight=weight):</span>
<span class="gi">+        # handle degree zero average</span>
<span class="gi">+        if deg == 0:</span>
<span class="gi">+            avg[n] = 0.0</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # we sum over both G_P and G_S, but one of the two is usually empty.</span>
<span class="gi">+        if weight is None:</span>
<span class="gi">+            avg[n] = (</span>
<span class="gi">+                sum(t_deg[nbr] for nbr in G_S[n]) + sum(t_deg[nbr] for nbr in G_P[n])</span>
<span class="gi">+            ) / deg</span>
<span class="gi">+        else:</span>
<span class="gi">+            avg[n] = (</span>
<span class="gi">+                sum(dd.get(weight, 1) * t_deg[nbr] for nbr, dd in G_S[n].items())</span>
<span class="gi">+                + sum(dd.get(weight, 1) * t_deg[nbr] for nbr, dd in G_P[n].items())</span>
<span class="gi">+            ) / deg</span>
<span class="gi">+    return avg</span>
<span class="gh">diff --git a/networkx/algorithms/assortativity/pairs.py b/networkx/algorithms/assortativity/pairs.py</span>
<span class="gh">index 65bf798ef..5a1d6f8e1 100644</span>
<span class="gd">--- a/networkx/algorithms/assortativity/pairs.py</span>
<span class="gi">+++ b/networkx/algorithms/assortativity/pairs.py</span>
<span class="gu">@@ -1,9 +1,10 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Generators of  x-y pairs of node data.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;node_attribute_xy&#39;, &#39;node_degree_xy&#39;]</span>

<span class="gi">+__all__ = [&quot;node_attribute_xy&quot;, &quot;node_degree_xy&quot;]</span>

<span class="gd">-@nx._dispatchable(node_attrs=&#39;attribute&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;attribute&quot;)</span>
<span class="w"> </span>def node_attribute_xy(G, attribute, nodes=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns iterator of node-attribute pairs for all edges in G.

<span class="gu">@@ -38,11 +39,28 @@ def node_attribute_xy(G, attribute, nodes=None):</span>
<span class="w"> </span>    representation (u, v) and (v, u), with the exception of self-loop edges
<span class="w"> </span>    which only appear once.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def node_degree_xy(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None, nodes=None):</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = set(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodes = set(nodes)</span>
<span class="gi">+    Gnodes = G.nodes</span>
<span class="gi">+    for u, nbrsdict in G.adjacency():</span>
<span class="gi">+        if u not in nodes:</span>
<span class="gi">+            continue</span>
<span class="gi">+        uattr = Gnodes[u].get(attribute, None)</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            for v, keys in nbrsdict.items():</span>
<span class="gi">+                vattr = Gnodes[v].get(attribute, None)</span>
<span class="gi">+                for _ in keys:</span>
<span class="gi">+                    yield (uattr, vattr)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for v in nbrsdict:</span>
<span class="gi">+                vattr = Gnodes[v].get(attribute, None)</span>
<span class="gi">+                yield (uattr, vattr)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def node_degree_xy(G, x=&quot;out&quot;, y=&quot;in&quot;, weight=None, nodes=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate node degree-degree pairs for edges in G.

<span class="w"> </span>    Parameters
<span class="gu">@@ -85,4 +103,16 @@ def node_degree_xy(G, x=&#39;out&#39;, y=&#39;in&#39;, weight=None, nodes=None):</span>
<span class="w"> </span>    representation (u, v) and (v, u), with the exception of self-loop edges
<span class="w"> </span>    which only appear once.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodes = set(G) if nodes is None else set(nodes)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        direction = {&quot;out&quot;: G.out_degree, &quot;in&quot;: G.in_degree}</span>
<span class="gi">+        xdeg = direction[x]</span>
<span class="gi">+        ydeg = direction[y]</span>
<span class="gi">+    else:</span>
<span class="gi">+        xdeg = ydeg = G.degree</span>
<span class="gi">+</span>
<span class="gi">+    for u, degu in xdeg(nodes, weight=weight):</span>
<span class="gi">+        # use G.edges to treat multigraphs correctly</span>
<span class="gi">+        neighbors = (nbr for _, nbr in G.edges(u) if nbr in nodes)</span>
<span class="gi">+        for _, degv in ydeg(neighbors, weight=weight):</span>
<span class="gi">+            yield degu, degv</span>
<span class="gh">diff --git a/networkx/algorithms/asteroidal.py b/networkx/algorithms/asteroidal.py</span>
<span class="gh">index 6242d3172..41e91390d 100644</span>
<span class="gd">--- a/networkx/algorithms/asteroidal.py</span>
<span class="gi">+++ b/networkx/algorithms/asteroidal.py</span>
<span class="gu">@@ -12,14 +12,15 @@ independent set and coloring.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;is_at_free&#39;, &#39;find_asteroidal_triple&#39;]</span>

<span class="gi">+__all__ = [&quot;is_at_free&quot;, &quot;find_asteroidal_triple&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def find_asteroidal_triple(G):
<span class="gd">-    &quot;&quot;&quot;Find an asteroidal triple in the given graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Find an asteroidal triple in the given graph.</span>

<span class="w"> </span>    An asteroidal triple is a triple of non-adjacent vertices such that
<span class="w"> </span>    there exists a path between any two of them which avoids the closed
<span class="gu">@@ -30,7 +31,7 @@ def find_asteroidal_triple(G):</span>
<span class="w"> </span>    the same connected component when the closed neighborhood of a given vertex
<span class="w"> </span>    is removed from the graph. The algorithm used to check is the trivial
<span class="w"> </span>    one, outlined in [1]_, which has a runtime of
<span class="gd">-    :math:`O(|V||\\overline{E} + |V||E|)`, where the second term is the</span>
<span class="gi">+    :math:`O(|V||\overline{E} + |V||E|)`, where the second term is the</span>
<span class="w"> </span>    creation of the component structure.

<span class="w"> </span>    Parameters
<span class="gu">@@ -60,11 +61,36 @@ def find_asteroidal_triple(G):</span>
<span class="w"> </span>       Journal of Discrete Algorithms 2, pages 439-452, 2004.
<span class="w"> </span>       https://www.sciencedirect.com/science/article/pii/S157086670400019X
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    V = set(G.nodes)</span>
<span class="gi">+</span>
<span class="gi">+    if len(V) &lt; 6:</span>
<span class="gi">+        # An asteroidal triple cannot exist in a graph with 5 or less vertices.</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    component_structure = create_component_structure(G)</span>
<span class="gi">+    E_complement = set(nx.complement(G).edges)</span>
<span class="gi">+</span>
<span class="gi">+    for e in E_complement:</span>
<span class="gi">+        u = e[0]</span>
<span class="gi">+        v = e[1]</span>
<span class="gi">+        u_neighborhood = set(G[u]).union([u])</span>
<span class="gi">+        v_neighborhood = set(G[v]).union([v])</span>
<span class="gi">+        union_of_neighborhoods = u_neighborhood.union(v_neighborhood)</span>
<span class="gi">+        for w in V - union_of_neighborhoods:</span>
<span class="gi">+            # Check for each pair of vertices whether they belong to the</span>
<span class="gi">+            # same connected component when the closed neighborhood of the</span>
<span class="gi">+            # third is removed.</span>
<span class="gi">+            if (</span>
<span class="gi">+                component_structure[u][v] == component_structure[u][w]</span>
<span class="gi">+                and component_structure[v][u] == component_structure[v][w]</span>
<span class="gi">+                and component_structure[w][u] == component_structure[w][v]</span>
<span class="gi">+            ):</span>
<span class="gi">+                return [u, v, w]</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_at_free(G):
<span class="w"> </span>    &quot;&quot;&quot;Check if a graph is AT-free.
<span class="gu">@@ -94,21 +120,21 @@ def is_at_free(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.is_at_free(G)
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return find_asteroidal_triple(G) is None</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def create_component_structure(G):
<span class="gd">-    &quot;&quot;&quot;Create component structure for G.</span>
<span class="gi">+    r&quot;&quot;&quot;Create component structure for G.</span>

<span class="w"> </span>    A *component structure* is an `nxn` array, denoted `c`, where `n` is
<span class="w"> </span>    the number of vertices,  where each row and column corresponds to a vertex.

<span class="w"> </span>    .. math::
<span class="gd">-        c_{uv} = \\begin{cases} 0, if v \\in N[u] \\\\</span>
<span class="gd">-            k, if v \\in component k of G \\setminus N[u] \\end{cases}</span>
<span class="gi">+        c_{uv} = \begin{cases} 0, if v \in N[u] \\</span>
<span class="gi">+            k, if v \in component k of G \setminus N[u] \end{cases}</span>

<span class="w"> </span>    Where `k` is an arbitrary label for each component. The structure is used
<span class="w"> </span>    to simplify the detection of asteroidal triples.
<span class="gu">@@ -124,4 +150,21 @@ def create_component_structure(G):</span>
<span class="w"> </span>        A dictionary of dictionaries, keyed by pairs of vertices.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    V = set(G.nodes)</span>
<span class="gi">+    component_structure = {}</span>
<span class="gi">+    for v in V:</span>
<span class="gi">+        label = 0</span>
<span class="gi">+        closed_neighborhood = set(G[v]).union({v})</span>
<span class="gi">+        row_dict = {}</span>
<span class="gi">+        for u in closed_neighborhood:</span>
<span class="gi">+            row_dict[u] = 0</span>
<span class="gi">+</span>
<span class="gi">+        G_reduced = G.subgraph(set(G.nodes) - closed_neighborhood)</span>
<span class="gi">+        for cc in nx.connected_components(G_reduced):</span>
<span class="gi">+            label += 1</span>
<span class="gi">+            for u in cc:</span>
<span class="gi">+                row_dict[u] = label</span>
<span class="gi">+</span>
<span class="gi">+        component_structure[v] = row_dict</span>
<span class="gi">+</span>
<span class="gi">+    return component_structure</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/basic.py b/networkx/algorithms/bipartite/basic.py</span>
<span class="gh">index 2db85cfba..d0a63a10f 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/basic.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/basic.py</span>
<span class="gu">@@ -6,8 +6,15 @@ Bipartite Graph Algorithms</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.components import connected_components
<span class="w"> </span>from networkx.exception import AmbiguousSolution
<span class="gd">-__all__ = [&#39;is_bipartite&#39;, &#39;is_bipartite_node_set&#39;, &#39;color&#39;, &#39;sets&#39;,</span>
<span class="gd">-    &#39;density&#39;, &#39;degrees&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;is_bipartite&quot;,</span>
<span class="gi">+    &quot;is_bipartite_node_set&quot;,</span>
<span class="gi">+    &quot;color&quot;,</span>
<span class="gi">+    &quot;sets&quot;,</span>
<span class="gi">+    &quot;density&quot;,</span>
<span class="gi">+    &quot;degrees&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -46,7 +53,34 @@ def color(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; print(G.nodes[1][&quot;bipartite&quot;])
<span class="w"> </span>    0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        import itertools</span>
<span class="gi">+</span>
<span class="gi">+        def neighbors(v):</span>
<span class="gi">+            return itertools.chain.from_iterable([G.predecessors(v), G.successors(v)])</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        neighbors = G.neighbors</span>
<span class="gi">+</span>
<span class="gi">+    color = {}</span>
<span class="gi">+    for n in G:  # handle disconnected graphs</span>
<span class="gi">+        if n in color or len(G[n]) == 0:  # skip isolates</span>
<span class="gi">+            continue</span>
<span class="gi">+        queue = [n]</span>
<span class="gi">+        color[n] = 1  # nodes seen with color (1 or 0)</span>
<span class="gi">+        while queue:</span>
<span class="gi">+            v = queue.pop()</span>
<span class="gi">+            c = 1 - color[v]  # opposite color of node v</span>
<span class="gi">+            for w in neighbors(v):</span>
<span class="gi">+                if w in color:</span>
<span class="gi">+                    if color[w] == color[v]:</span>
<span class="gi">+                        raise nx.NetworkXError(&quot;Graph is not bipartite.&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    color[w] = c</span>
<span class="gi">+                    queue.append(w)</span>
<span class="gi">+    # color isolates with 0</span>
<span class="gi">+    color.update(dict.fromkeys(nx.isolates(G), 0))</span>
<span class="gi">+    return color</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -68,7 +102,11 @@ def is_bipartite(G):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    color, is_bipartite_node_set
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        color(G)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except nx.NetworkXError:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -97,7 +135,23 @@ def is_bipartite_node_set(G, nodes):</span>
<span class="w"> </span>    For connected graphs the bipartite sets are unique.  This function handles
<span class="w"> </span>    disconnected graphs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    S = set(nodes)</span>
<span class="gi">+</span>
<span class="gi">+    if len(S) &lt; len(nodes):</span>
<span class="gi">+        # this should maybe just return False?</span>
<span class="gi">+        raise AmbiguousSolution(</span>
<span class="gi">+            &quot;The input node set contains duplicates.\n&quot;</span>
<span class="gi">+            &quot;This may lead to incorrect results when using it in bipartite algorithms.\n&quot;</span>
<span class="gi">+            &quot;Consider using set(nodes) as the input&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    for CC in (G.subgraph(c).copy() for c in connected_components(G)):</span>
<span class="gi">+        X, Y = sets(CC)</span>
<span class="gi">+        if not (</span>
<span class="gi">+            (X.issubset(S) and Y.isdisjoint(S)) or (Y.issubset(S) and X.isdisjoint(S))</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -150,10 +204,24 @@ def sets(G, top_nodes=None):</span>
<span class="w"> </span>    color

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;B&#39;)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        is_connected = nx.is_weakly_connected</span>
<span class="gi">+    else:</span>
<span class="gi">+        is_connected = nx.is_connected</span>
<span class="gi">+    if top_nodes is not None:</span>
<span class="gi">+        X = set(top_nodes)</span>
<span class="gi">+        Y = set(G) - X</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not is_connected(G):</span>
<span class="gi">+            msg = &quot;Disconnected graph: Ambiguous solution for bipartite sets.&quot;</span>
<span class="gi">+            raise nx.AmbiguousSolution(msg)</span>
<span class="gi">+        c = color(G)</span>
<span class="gi">+        X = {n for n, is_top in c.items() if is_top}</span>
<span class="gi">+        Y = {n for n, is_top in c.items() if not is_top}</span>
<span class="gi">+    return (X, Y)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;B&quot;)</span>
<span class="w"> </span>def density(B, nodes):
<span class="w"> </span>    &quot;&quot;&quot;Returns density of bipartite graph B.

<span class="gu">@@ -192,10 +260,21 @@ def density(B, nodes):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    color
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;B&#39;, edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    n = len(B)</span>
<span class="gi">+    m = nx.number_of_edges(B)</span>
<span class="gi">+    nb = len(nodes)</span>
<span class="gi">+    nt = n - nb</span>
<span class="gi">+    if m == 0:  # includes cases n==0 and n==1</span>
<span class="gi">+        d = 0.0</span>
<span class="gi">+    else:</span>
<span class="gi">+        if B.is_directed():</span>
<span class="gi">+            d = m / (2 * nb * nt)</span>
<span class="gi">+        else:</span>
<span class="gi">+            d = m / (nb * nt)</span>
<span class="gi">+    return d</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;B&quot;, edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def degrees(B, nodes, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the degrees of the two node sets in the bipartite graph B.

<span class="gu">@@ -237,4 +316,6 @@ def degrees(B, nodes, weight=None):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    color, density
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bottom = set(nodes)</span>
<span class="gi">+    top = set(B) - bottom</span>
<span class="gi">+    return (B.degree(top, weight), B.degree(bottom, weight))</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/centrality.py b/networkx/algorithms/bipartite/centrality.py</span>
<span class="gh">index cca9a8892..42d7270ee 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/centrality.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/centrality.py</span>
<span class="gu">@@ -1,11 +1,11 @@</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;degree_centrality&#39;, &#39;betweenness_centrality&#39;,</span>
<span class="gd">-    &#39;closeness_centrality&#39;]</span>

<span class="gi">+__all__ = [&quot;degree_centrality&quot;, &quot;betweenness_centrality&quot;, &quot;closeness_centrality&quot;]</span>

<span class="gd">-@nx._dispatchable(name=&#39;bipartite_degree_centrality&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(name=&quot;bipartite_degree_centrality&quot;)</span>
<span class="w"> </span>def degree_centrality(G, nodes):
<span class="gd">-    &quot;&quot;&quot;Compute the degree centrality for nodes in a bipartite network.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the degree centrality for nodes in a bipartite network.</span>

<span class="w"> </span>    The degree centrality for a node `v` is the fraction of nodes
<span class="w"> </span>    connected to it.
<span class="gu">@@ -55,9 +55,9 @@ def degree_centrality(G, nodes):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        d_{v} = \\frac{deg(v)}{m}, \\mbox{for} v \\in U ,</span>
<span class="gi">+        d_{v} = \frac{deg(v)}{m}, \mbox{for} v \in U ,</span>

<span class="gd">-        d_{v} = \\frac{deg(v)}{n}, \\mbox{for} v \\in V ,</span>
<span class="gi">+        d_{v} = \frac{deg(v)}{n}, \mbox{for} v \in V ,</span>


<span class="w"> </span>    where `deg(v)` is the degree of node `v`.
<span class="gu">@@ -69,12 +69,18 @@ def degree_centrality(G, nodes):</span>
<span class="w"> </span>        of Social Network Analysis. Sage Publications.
<span class="w"> </span>        https://dx.doi.org/10.4135/9781446294413.n28
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    top = set(nodes)</span>
<span class="gi">+    bottom = set(G) - top</span>
<span class="gi">+    s = 1.0 / len(bottom)</span>
<span class="gi">+    centrality = {n: d * s for n, d in G.degree(top)}</span>
<span class="gi">+    s = 1.0 / len(top)</span>
<span class="gi">+    centrality.update({n: d * s for n, d in G.degree(bottom)})</span>
<span class="gi">+    return centrality</span>


<span class="gd">-@nx._dispatchable(name=&#39;bipartite_betweenness_centrality&#39;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;bipartite_betweenness_centrality&quot;)</span>
<span class="w"> </span>def betweenness_centrality(G, nodes):
<span class="gd">-    &quot;&quot;&quot;Compute betweenness centrality for nodes in a bipartite network.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute betweenness centrality for nodes in a bipartite network.</span>

<span class="w"> </span>    Betweenness centrality of a node `v` is the sum of the
<span class="w"> </span>    fraction of all-pairs shortest paths that pass through `v`.
<span class="gu">@@ -89,25 +95,25 @@ def betweenness_centrality(G, nodes):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       \\frac{1}{2} [m^2 (s + 1)^2 + m (s + 1)(2t - s - 1) - t (2s - t + 3)] ,</span>
<span class="gi">+       \frac{1}{2} [m^2 (s + 1)^2 + m (s + 1)(2t - s - 1) - t (2s - t + 3)] ,</span>

<span class="w"> </span>    where

<span class="w"> </span>    .. math::

<span class="gd">-        s = (n - 1) \\div m , t = (n - 1) \\mod m ,</span>
<span class="gi">+        s = (n - 1) \div m , t = (n - 1) \mod m ,</span>

<span class="w"> </span>    and nodes in `V` are normalized by dividing by

<span class="w"> </span>    .. math::

<span class="gd">-        \\frac{1}{2} [n^2 (p + 1)^2 + n (p + 1)(2r - p - 1) - r (2p - r + 3)] ,</span>
<span class="gi">+        \frac{1}{2} [n^2 (p + 1)^2 + n (p + 1)(2r - p - 1) - r (2p - r + 3)] ,</span>

<span class="w"> </span>    where,

<span class="w"> </span>    .. math::

<span class="gd">-        p = (m - 1) \\div n , r = (m - 1) \\mod n .</span>
<span class="gi">+        p = (m - 1) \div n , r = (m - 1) \mod n .</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -152,12 +158,33 @@ def betweenness_centrality(G, nodes):</span>
<span class="w"> </span>        of Social Network Analysis. Sage Publications.
<span class="w"> </span>        https://dx.doi.org/10.4135/9781446294413.n28
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(name=&#39;bipartite_closeness_centrality&#39;)</span>
<span class="gi">+    top = set(nodes)</span>
<span class="gi">+    bottom = set(G) - top</span>
<span class="gi">+    n = len(top)</span>
<span class="gi">+    m = len(bottom)</span>
<span class="gi">+    s, t = divmod(n - 1, m)</span>
<span class="gi">+    bet_max_top = (</span>
<span class="gi">+        ((m**2) * ((s + 1) ** 2))</span>
<span class="gi">+        + (m * (s + 1) * (2 * t - s - 1))</span>
<span class="gi">+        - (t * ((2 * s) - t + 3))</span>
<span class="gi">+    ) / 2.0</span>
<span class="gi">+    p, r = divmod(m - 1, n)</span>
<span class="gi">+    bet_max_bot = (</span>
<span class="gi">+        ((n**2) * ((p + 1) ** 2))</span>
<span class="gi">+        + (n * (p + 1) * (2 * r - p - 1))</span>
<span class="gi">+        - (r * ((2 * p) - r + 3))</span>
<span class="gi">+    ) / 2.0</span>
<span class="gi">+    betweenness = nx.betweenness_centrality(G, normalized=False, weight=None)</span>
<span class="gi">+    for node in top:</span>
<span class="gi">+        betweenness[node] /= bet_max_top</span>
<span class="gi">+    for node in bottom:</span>
<span class="gi">+        betweenness[node] /= bet_max_bot</span>
<span class="gi">+    return betweenness</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(name=&quot;bipartite_closeness_centrality&quot;)</span>
<span class="w"> </span>def closeness_centrality(G, nodes, normalized=True):
<span class="gd">-    &quot;&quot;&quot;Compute the closeness centrality for nodes in a bipartite network.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the closeness centrality for nodes in a bipartite network.</span>

<span class="w"> </span>    The closeness of a node is the distance to all other nodes in the
<span class="w"> </span>    graph or in the case that the graph is not connected to all other nodes
<span class="gu">@@ -211,9 +238,9 @@ def closeness_centrality(G, nodes, normalized=True):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        c_{v} = \\frac{m + 2(n - 1)}{d}, \\mbox{for} v \\in U,</span>
<span class="gi">+        c_{v} = \frac{m + 2(n - 1)}{d}, \mbox{for} v \in U,</span>

<span class="gd">-        c_{v} = \\frac{n + 2(m - 1)}{d}, \\mbox{for} v \\in V,</span>
<span class="gi">+        c_{v} = \frac{n + 2(m - 1)}{d}, \mbox{for} v \in V,</span>

<span class="w"> </span>    where `d` is the sum of the distances from `v` to all
<span class="w"> </span>    other nodes.
<span class="gu">@@ -234,4 +261,30 @@ def closeness_centrality(G, nodes, normalized=True):</span>
<span class="w"> </span>        of Social Network Analysis. Sage Publications.
<span class="w"> </span>        https://dx.doi.org/10.4135/9781446294413.n28
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    closeness = {}</span>
<span class="gi">+    path_length = nx.single_source_shortest_path_length</span>
<span class="gi">+    top = set(nodes)</span>
<span class="gi">+    bottom = set(G) - top</span>
<span class="gi">+    n = len(top)</span>
<span class="gi">+    m = len(bottom)</span>
<span class="gi">+    for node in top:</span>
<span class="gi">+        sp = dict(path_length(G, node))</span>
<span class="gi">+        totsp = sum(sp.values())</span>
<span class="gi">+        if totsp &gt; 0.0 and len(G) &gt; 1:</span>
<span class="gi">+            closeness[node] = (m + 2 * (n - 1)) / totsp</span>
<span class="gi">+            if normalized:</span>
<span class="gi">+                s = (len(sp) - 1) / (len(G) - 1)</span>
<span class="gi">+                closeness[node] *= s</span>
<span class="gi">+        else:</span>
<span class="gi">+            closeness[node] = 0.0</span>
<span class="gi">+    for node in bottom:</span>
<span class="gi">+        sp = dict(path_length(G, node))</span>
<span class="gi">+        totsp = sum(sp.values())</span>
<span class="gi">+        if totsp &gt; 0.0 and len(G) &gt; 1:</span>
<span class="gi">+            closeness[node] = (n + 2 * (m - 1)) / totsp</span>
<span class="gi">+            if normalized:</span>
<span class="gi">+                s = (len(sp) - 1) / (len(G) - 1)</span>
<span class="gi">+                closeness[node] *= s</span>
<span class="gi">+        else:</span>
<span class="gi">+            closeness[node] = 0.0</span>
<span class="gi">+    return closeness</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/cluster.py b/networkx/algorithms/bipartite/cluster.py</span>
<span class="gh">index 56e5d1c32..d96115277 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/cluster.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/cluster.py</span>
<span class="gu">@@ -1,23 +1,44 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing clustering of pairs

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;clustering&#39;, &#39;average_clustering&#39;, &#39;latapy_clustering&#39;,</span>
<span class="gd">-    &#39;robins_alexander_clustering&#39;]</span>
<span class="gd">-modes = {&#39;dot&#39;: cc_dot, &#39;min&#39;: cc_min, &#39;max&#39;: cc_max}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;clustering&quot;,</span>
<span class="gi">+    &quot;average_clustering&quot;,</span>
<span class="gi">+    &quot;latapy_clustering&quot;,</span>
<span class="gi">+    &quot;robins_alexander_clustering&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def cc_dot(nu, nv):</span>
<span class="gi">+    return len(nu &amp; nv) / len(nu | nv)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def cc_max(nu, nv):</span>
<span class="gi">+    return len(nu &amp; nv) / max(len(nu), len(nv))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def cc_min(nu, nv):</span>
<span class="gi">+    return len(nu &amp; nv) / min(len(nu), len(nv))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+modes = {&quot;dot&quot;: cc_dot, &quot;min&quot;: cc_min, &quot;max&quot;: cc_max}</span>


<span class="w"> </span>@nx._dispatchable
<span class="gd">-def latapy_clustering(G, nodes=None, mode=&#39;dot&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Compute a bipartite clustering coefficient for nodes.</span>
<span class="gi">+def latapy_clustering(G, nodes=None, mode=&quot;dot&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute a bipartite clustering coefficient for nodes.</span>

<span class="w"> </span>    The bipartite clustering coefficient is a measure of local density
<span class="w"> </span>    of connections defined as [1]_:

<span class="w"> </span>    .. math::

<span class="gd">-       c_u = \\frac{\\sum_{v \\in N(N(u))} c_{uv} }{|N(N(u))|}</span>
<span class="gi">+       c_u = \frac{\sum_{v \in N(N(u))} c_{uv} }{|N(N(u))|}</span>

<span class="w"> </span>    where `N(N(u))` are the second order neighbors of `u` in `G` excluding `u`,
<span class="w"> </span>    and `c_{uv}` is the pairwise clustering coefficient between nodes
<span class="gu">@@ -29,19 +50,19 @@ def latapy_clustering(G, nodes=None, mode=&#39;dot&#39;):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       c_{uv}=\\frac{|N(u)\\cap N(v)|}{|N(u) \\cup N(v)|}</span>
<span class="gi">+       c_{uv}=\frac{|N(u)\cap N(v)|}{|N(u) \cup N(v)|}</span>

<span class="w"> </span>    `min`:

<span class="w"> </span>    .. math::

<span class="gd">-       c_{uv}=\\frac{|N(u)\\cap N(v)|}{min(|N(u)|,|N(v)|)}</span>
<span class="gi">+       c_{uv}=\frac{|N(u)\cap N(v)|}{min(|N(u)|,|N(v)|)}</span>

<span class="w"> </span>    `max`:

<span class="w"> </span>    .. math::

<span class="gd">-       c_{uv}=\\frac{|N(u)\\cap N(v)|}{max(|N(u)|,|N(v)|)}</span>
<span class="gi">+       c_{uv}=\frac{|N(u)\cap N(v)|}{max(|N(u)|,|N(v)|)}</span>


<span class="w"> </span>    Parameters
<span class="gu">@@ -86,21 +107,42 @@ def latapy_clustering(G, nodes=None, mode=&#39;dot&#39;):</span>
<span class="w"> </span>       Basic notions for the analysis of large two-mode networks.
<span class="w"> </span>       Social Networks 30(1), 31--48.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.algorithms.bipartite.is_bipartite(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph is not bipartite&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        cc_func = modes[mode]</span>
<span class="gi">+    except KeyError as err:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;Mode for bipartite clustering must be: dot, min or max&quot;</span>
<span class="gi">+        ) from err</span>
<span class="gi">+</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = G</span>
<span class="gi">+    ccs = {}</span>
<span class="gi">+    for v in nodes:</span>
<span class="gi">+        cc = 0.0</span>
<span class="gi">+        nbrs2 = {u for nbr in G[v] for u in G[nbr]} - {v}</span>
<span class="gi">+        for u in nbrs2:</span>
<span class="gi">+            cc += cc_func(set(G[u]), set(G[v]))</span>
<span class="gi">+        if cc &gt; 0.0:  # len(nbrs2)&gt;0</span>
<span class="gi">+            cc /= len(nbrs2)</span>
<span class="gi">+        ccs[v] = cc</span>
<span class="gi">+    return ccs</span>


<span class="w"> </span>clustering = latapy_clustering


<span class="gd">-@nx._dispatchable(name=&#39;bipartite_average_clustering&#39;)</span>
<span class="gd">-def average_clustering(G, nodes=None, mode=&#39;dot&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the average bipartite clustering coefficient.</span>
<span class="gi">+@nx._dispatchable(name=&quot;bipartite_average_clustering&quot;)</span>
<span class="gi">+def average_clustering(G, nodes=None, mode=&quot;dot&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the average bipartite clustering coefficient.</span>

<span class="w"> </span>    A clustering coefficient for the whole graph is the average,

<span class="w"> </span>    .. math::

<span class="gd">-       C = \\frac{1}{n}\\sum_{v \\in G} c_v,</span>
<span class="gi">+       C = \frac{1}{n}\sum_{v \in G} c_v,</span>

<span class="w"> </span>    where `n` is the number of nodes in `G`.

<span class="gu">@@ -108,7 +150,7 @@ def average_clustering(G, nodes=None, mode=&#39;dot&#39;):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       C_X = \\frac{1}{|X|}\\sum_{v \\in X} c_v,</span>
<span class="gi">+       C_X = \frac{1}{|X|}\sum_{v \in X} c_v,</span>

<span class="w"> </span>    where `X` is a bipartite set of `G`.

<span class="gu">@@ -163,12 +205,15 @@ def average_clustering(G, nodes=None, mode=&#39;dot&#39;):</span>
<span class="w"> </span>        Basic notions for the analysis of large two-mode networks.
<span class="w"> </span>        Social Networks 30(1), 31--48.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = G</span>
<span class="gi">+    ccs = latapy_clustering(G, nodes=nodes, mode=mode)</span>
<span class="gi">+    return sum(ccs[v] for v in nodes) / len(nodes)</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def robins_alexander_clustering(G):
<span class="gd">-    &quot;&quot;&quot;Compute the bipartite clustering of G.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the bipartite clustering of G.</span>

<span class="w"> </span>    Robins and Alexander [1]_ defined bipartite clustering coefficient as
<span class="w"> </span>    four times the number of four cycles `C_4` divided by the number of
<span class="gu">@@ -176,7 +221,7 @@ def robins_alexander_clustering(G):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       CC_4 = \\frac{4 * C_4}{L_3}</span>
<span class="gi">+       CC_4 = \frac{4 * C_4}{L_3}</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -207,4 +252,29 @@ def robins_alexander_clustering(G):</span>
<span class="w"> </span>           Computational &amp; Mathematical Organization Theory 10(1), 69–94.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.order() &lt; 4 or G.size() &lt; 3:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    L_3 = _threepaths(G)</span>
<span class="gi">+    if L_3 == 0:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    C_4 = _four_cycles(G)</span>
<span class="gi">+    return (4.0 * C_4) / L_3</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _four_cycles(G):</span>
<span class="gi">+    cycles = 0</span>
<span class="gi">+    for v in G:</span>
<span class="gi">+        for u, w in itertools.combinations(G[v], 2):</span>
<span class="gi">+            cycles += len((set(G[u]) &amp; set(G[w])) - {v})</span>
<span class="gi">+    return cycles / 4</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _threepaths(G):</span>
<span class="gi">+    paths = 0</span>
<span class="gi">+    for v in G:</span>
<span class="gi">+        for u in G[v]:</span>
<span class="gi">+            for w in set(G[u]) - {v}:</span>
<span class="gi">+                paths += len(set(G[w]) - {v, u})</span>
<span class="gi">+    # Divide by two because we count each three path twice</span>
<span class="gi">+    # one for each possible starting point</span>
<span class="gi">+    return paths / 2</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/covering.py b/networkx/algorithms/bipartite/covering.py</span>
<span class="gh">index 39dbf9ba6..720c63ac4 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/covering.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/covering.py</span>
<span class="gu">@@ -1,14 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot; Functions related to graph covers.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.bipartite.matching import hopcroft_karp_matching
<span class="w"> </span>from networkx.algorithms.covering import min_edge_cover as _min_edge_cover
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;min_edge_cover&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;min_edge_cover&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(name=&#39;bipartite_min_edge_cover&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;bipartite_min_edge_cover&quot;)</span>
<span class="w"> </span>def min_edge_cover(G, matching_algorithm=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a set of edges which constitutes
<span class="w"> </span>    the minimum edge cover of the graph.
<span class="gu">@@ -48,4 +50,8 @@ def min_edge_cover(G, matching_algorithm=None):</span>
<span class="w"> </span>    is bounded by the worst-case running time of the function
<span class="w"> </span>    ``matching_algorithm``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.order() == 0:  # Special case for the empty graph</span>
<span class="gi">+        return set()</span>
<span class="gi">+    if matching_algorithm is None:</span>
<span class="gi">+        matching_algorithm = hopcroft_karp_matching</span>
<span class="gi">+    return _min_edge_cover(G, matching_algorithm=matching_algorithm)</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/edgelist.py b/networkx/algorithms/bipartite/edgelist.py</span>
<span class="gh">index 252a14b18..70631ea0e 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/edgelist.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/edgelist.py</span>
<span class="gu">@@ -22,15 +22,14 @@ Arbitrary data::</span>

<span class="w"> </span>For each edge (u, v) the node u is assigned to part 0 and the node v to part 1.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;generate_edgelist&#39;, &#39;write_edgelist&#39;, &#39;parse_edgelist&#39;,</span>
<span class="gd">-    &#39;read_edgelist&#39;]</span>
<span class="gi">+__all__ = [&quot;generate_edgelist&quot;, &quot;write_edgelist&quot;, &quot;parse_edgelist&quot;, &quot;read_edgelist&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, open_file


<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gd">-def write_edgelist(G, path, comments=&#39;#&#39;, delimiter=&#39; &#39;, data=True,</span>
<span class="gd">-    encoding=&#39;utf-8&#39;):</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="gi">+def write_edgelist(G, path, comments=&quot;#&quot;, delimiter=&quot; &quot;, data=True, encoding=&quot;utf-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write a bipartite graph as a list of edges.

<span class="w"> </span>    Parameters
<span class="gu">@@ -74,11 +73,13 @@ def write_edgelist(G, path, comments=&#39;#&#39;, delimiter=&#39; &#39;, data=True,</span>
<span class="w"> </span>    write_edgelist
<span class="w"> </span>    generate_edgelist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for line in generate_edgelist(G, delimiter, data):</span>
<span class="gi">+        line += &quot;\n&quot;</span>
<span class="gi">+        path.write(line.encode(encoding))</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-def generate_edgelist(G, delimiter=&#39; &#39;, data=True):</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+def generate_edgelist(G, delimiter=&quot; &quot;, data=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a single line of the bipartite graph G in edge list format.

<span class="w"> </span>    Parameters
<span class="gu">@@ -126,13 +127,29 @@ def generate_edgelist(G, delimiter=&#39; &#39;, data=True):</span>
<span class="w"> </span>    2 1 3
<span class="w"> </span>    2 3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(name=&#39;bipartite_parse_edgelist&#39;, graphs=None,</span>
<span class="gd">-    returns_graph=True)</span>
<span class="gd">-def parse_edgelist(lines, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="gd">-    nodetype=None, data=True):</span>
<span class="gi">+    try:</span>
<span class="gi">+        part0 = [n for n, d in G.nodes.items() if d[&quot;bipartite&quot;] == 0]</span>
<span class="gi">+    except BaseException as err:</span>
<span class="gi">+        raise AttributeError(&quot;Missing node attribute `bipartite`&quot;) from err</span>
<span class="gi">+    if data is True or data is False:</span>
<span class="gi">+        for n in part0:</span>
<span class="gi">+            for edge in G.edges(n, data=data):</span>
<span class="gi">+                yield delimiter.join(map(str, edge))</span>
<span class="gi">+    else:</span>
<span class="gi">+        for n in part0:</span>
<span class="gi">+            for u, v, d in G.edges(n, data=True):</span>
<span class="gi">+                edge = [u, v]</span>
<span class="gi">+                try:</span>
<span class="gi">+                    edge.extend(d[k] for k in data)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass  # missing data for this edge, should warn?</span>
<span class="gi">+                yield delimiter.join(map(str, edge))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(name=&quot;bipartite_parse_edgelist&quot;, graphs=None, returns_graph=True)</span>
<span class="gi">+def parse_edgelist(</span>
<span class="gi">+    lines, comments=&quot;#&quot;, delimiter=None, create_using=None, nodetype=None, data=True</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse lines of an edge list representation of a bipartite graph.

<span class="w"> </span>    Parameters
<span class="gu">@@ -192,14 +209,76 @@ def parse_edgelist(lines, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="w"> </span>    See Also
<span class="w"> </span>    --------
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gd">-@nx._dispatchable(name=&#39;bipartite_read_edgelist&#39;, graphs=None,</span>
<span class="gd">-    returns_graph=True)</span>
<span class="gd">-def read_edgelist(path, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="gd">-    nodetype=None, data=True, edgetype=None, encoding=&#39;utf-8&#39;):</span>
<span class="gi">+    from ast import literal_eval</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        p = line.find(comments)</span>
<span class="gi">+        if p &gt;= 0:</span>
<span class="gi">+            line = line[:p]</span>
<span class="gi">+        if not len(line):</span>
<span class="gi">+            continue</span>
<span class="gi">+        # split line, should have 2 or more</span>
<span class="gi">+        s = line.strip().split(delimiter)</span>
<span class="gi">+        if len(s) &lt; 2:</span>
<span class="gi">+            continue</span>
<span class="gi">+        u = s.pop(0)</span>
<span class="gi">+        v = s.pop(0)</span>
<span class="gi">+        d = s</span>
<span class="gi">+        if nodetype is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                u = nodetype(u)</span>
<span class="gi">+                v = nodetype(v)</span>
<span class="gi">+            except BaseException as err:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Failed to convert nodes {u},{v} to type {nodetype}.&quot;</span>
<span class="gi">+                ) from err</span>
<span class="gi">+</span>
<span class="gi">+        if len(d) == 0 or data is False:</span>
<span class="gi">+            # no data or data type specified</span>
<span class="gi">+            edgedata = {}</span>
<span class="gi">+        elif data is True:</span>
<span class="gi">+            # no edge types specified</span>
<span class="gi">+            try:  # try to evaluate as dictionary</span>
<span class="gi">+                edgedata = dict(literal_eval(&quot; &quot;.join(d)))</span>
<span class="gi">+            except BaseException as err:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Failed to convert edge data ({d}) to dictionary.&quot;</span>
<span class="gi">+                ) from err</span>
<span class="gi">+        else:</span>
<span class="gi">+            # convert edge data to dictionary with specified keys and type</span>
<span class="gi">+            if len(d) != len(data):</span>
<span class="gi">+                raise IndexError(</span>
<span class="gi">+                    f&quot;Edge data {d} and data_keys {data} are not the same length&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            edgedata = {}</span>
<span class="gi">+            for (edge_key, edge_type), edge_value in zip(data, d):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    edge_value = edge_type(edge_value)</span>
<span class="gi">+                except BaseException as err:</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        f&quot;Failed to convert {edge_key} data &quot;</span>
<span class="gi">+                        f&quot;{edge_value} to type {edge_type}.&quot;</span>
<span class="gi">+                    ) from err</span>
<span class="gi">+                edgedata.update({edge_key: edge_value})</span>
<span class="gi">+        G.add_node(u, bipartite=0)</span>
<span class="gi">+        G.add_node(v, bipartite=1)</span>
<span class="gi">+        G.add_edge(u, v, **edgedata)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;bipartite_read_edgelist&quot;, graphs=None, returns_graph=True)</span>
<span class="gi">+def read_edgelist(</span>
<span class="gi">+    path,</span>
<span class="gi">+    comments=&quot;#&quot;,</span>
<span class="gi">+    delimiter=None,</span>
<span class="gi">+    create_using=None,</span>
<span class="gi">+    nodetype=None,</span>
<span class="gi">+    data=True,</span>
<span class="gi">+    edgetype=None,</span>
<span class="gi">+    encoding=&quot;utf-8&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a bipartite graph from a list of edges.

<span class="w"> </span>    Parameters
<span class="gu">@@ -269,4 +348,12 @@ def read_edgelist(path, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="w"> </span>    Since nodes must be hashable, the function nodetype must return hashable
<span class="w"> </span>    types (e.g. int, float, str, frozenset - or tuples of those, etc.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = (line.decode(encoding) for line in path)</span>
<span class="gi">+    return parse_edgelist(</span>
<span class="gi">+        lines,</span>
<span class="gi">+        comments=comments,</span>
<span class="gi">+        delimiter=delimiter,</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+        nodetype=nodetype,</span>
<span class="gi">+        data=data,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/extendability.py b/networkx/algorithms/bipartite/extendability.py</span>
<span class="gh">index 84e5c3c5c..0764997ad 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/extendability.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/extendability.py</span>
<span class="gu">@@ -1,12 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot; Provides a function for computing the extendability of a graph which is
<span class="w"> </span>undirected, simple, connected and bipartite and contains at least one perfect matching.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;maximal_extendability&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;maximal_extendability&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def maximal_extendability(G):
<span class="w"> </span>    &quot;&quot;&quot;Computes the extendability of a graph.
<span class="gu">@@ -63,4 +66,41 @@ def maximal_extendability(G):</span>
<span class="w"> </span>          https://doi.org/10.1016/0012-365X(80)90037-0

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph G is not connected&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.bipartite.is_bipartite(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph G is not bipartite&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    U, V = nx.bipartite.sets(G)</span>
<span class="gi">+</span>
<span class="gi">+    maximum_matching = nx.bipartite.hopcroft_karp_matching(G)</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_perfect_matching(G, maximum_matching):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph G does not contain a perfect matching&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # list of edges in perfect matching, directed from V to U</span>
<span class="gi">+    pm = [(node, maximum_matching[node]) for node in V &amp; maximum_matching.keys()]</span>
<span class="gi">+</span>
<span class="gi">+    # Direct all the edges of G, from V to U if in matching, else from U to V</span>
<span class="gi">+    directed_edges = [</span>
<span class="gi">+        (x, y) if (x in V and (x, y) in pm) or (x in U and (y, x) not in pm) else (y, x)</span>
<span class="gi">+        for x, y in G.edges</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # Construct the residual graph of G</span>
<span class="gi">+    residual_G = nx.DiGraph()</span>
<span class="gi">+    residual_G.add_nodes_from(G)</span>
<span class="gi">+    residual_G.add_edges_from(directed_edges)</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_strongly_connected(residual_G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;The residual graph of G is not strongly connected&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # For node-pairs between V &amp; U, keep min of max number of node-disjoint paths</span>
<span class="gi">+    # Variable $k$ stands for the extendability of graph G</span>
<span class="gi">+    k = float(&quot;inf&quot;)</span>
<span class="gi">+    for u in U:</span>
<span class="gi">+        for v in V:</span>
<span class="gi">+            num_paths = sum(1 for _ in nx.node_disjoint_paths(residual_G, u, v))</span>
<span class="gi">+            k = k if k &lt; num_paths else num_paths</span>
<span class="gi">+    return k</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/generators.py b/networkx/algorithms/bipartite/generators.py</span>
<span class="gh">index f5d313d58..de6f07972 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/generators.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/generators.py</span>
<span class="gu">@@ -4,12 +4,20 @@ Generators and functions for bipartite graphs.</span>
<span class="w"> </span>import math
<span class="w"> </span>import numbers
<span class="w"> </span>from functools import reduce
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import nodes_or_number, py_random_state
<span class="gd">-__all__ = [&#39;configuration_model&#39;, &#39;havel_hakimi_graph&#39;,</span>
<span class="gd">-    &#39;reverse_havel_hakimi_graph&#39;, &#39;alternating_havel_hakimi_graph&#39;,</span>
<span class="gd">-    &#39;preferential_attachment_graph&#39;, &#39;random_graph&#39;, &#39;gnmk_random_graph&#39;,</span>
<span class="gd">-    &#39;complete_bipartite_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;configuration_model&quot;,</span>
<span class="gi">+    &quot;havel_hakimi_graph&quot;,</span>
<span class="gi">+    &quot;reverse_havel_hakimi_graph&quot;,</span>
<span class="gi">+    &quot;alternating_havel_hakimi_graph&quot;,</span>
<span class="gi">+    &quot;preferential_attachment_graph&quot;,</span>
<span class="gi">+    &quot;random_graph&quot;,</span>
<span class="gi">+    &quot;gnmk_random_graph&quot;,</span>
<span class="gi">+    &quot;complete_bipartite_graph&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -41,12 +49,25 @@ def complete_bipartite_graph(n1, n2, create_using=None):</span>
<span class="w"> </span>    This function is not imported in the main namespace.
<span class="w"> </span>    To use it use nx.bipartite.complete_bipartite_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    n1, top = n1</span>
<span class="gi">+    n2, bottom = n2</span>
<span class="gi">+    if isinstance(n1, numbers.Integral) and isinstance(n2, numbers.Integral):</span>
<span class="gi">+        bottom = [n1 + i for i in bottom]</span>
<span class="gi">+    G.add_nodes_from(top, bipartite=0)</span>
<span class="gi">+    G.add_nodes_from(bottom, bipartite=1)</span>
<span class="gi">+    if len(G) != len(top) + len(bottom):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Inputs n1 and n2 must contain distinct nodes&quot;)</span>
<span class="gi">+    G.add_edges_from((u, v) for u in top for v in bottom)</span>
<span class="gi">+    G.graph[&quot;name&quot;] = f&quot;complete_bipartite_graph({n1}, {n2})&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gd">-@nx._dispatchable(name=&#39;bipartite_configuration_model&#39;, graphs=None,</span>
<span class="gd">-    returns_graph=True)</span>
<span class="gi">+@nx._dispatchable(name=&quot;bipartite_configuration_model&quot;, graphs=None, returns_graph=True)</span>
<span class="w"> </span>def configuration_model(aseq, bseq, create_using=None, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a random bipartite graph from two given degree sequences.

<span class="gu">@@ -80,11 +101,44 @@ def configuration_model(aseq, bseq, create_using=None, seed=None):</span>
<span class="w"> </span>    This function is not imported in the main namespace.
<span class="w"> </span>    To use it use nx.bipartite.configuration_model
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # length and sum of each sequence</span>
<span class="gi">+    lena = len(aseq)</span>
<span class="gi">+    lenb = len(bseq)</span>
<span class="gi">+    suma = sum(aseq)</span>
<span class="gi">+    sumb = sum(bseq)</span>
<span class="gi">+</span>
<span class="gi">+    if not suma == sumb:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;invalid degree sequences, sum(aseq)!=sum(bseq),{suma},{sumb}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    G = _add_nodes_with_bipartite_label(G, lena, lenb)</span>
<span class="gi">+</span>
<span class="gi">+    if len(aseq) == 0 or max(aseq) == 0:</span>
<span class="gi">+        return G  # done if no edges</span>
<span class="gi">+</span>
<span class="gi">+    # build lists of degree-repeated vertex numbers</span>
<span class="gi">+    stubs = [[v] * aseq[v] for v in range(lena)]</span>
<span class="gi">+    astubs = [x for subseq in stubs for x in subseq]</span>
<span class="gi">+</span>
<span class="gi">+    stubs = [[v] * bseq[v - lena] for v in range(lena, lena + lenb)]</span>
<span class="gi">+    bstubs = [x for subseq in stubs for x in subseq]</span>
<span class="gi">+</span>
<span class="gi">+    # shuffle lists</span>
<span class="gi">+    seed.shuffle(astubs)</span>
<span class="gi">+    seed.shuffle(bstubs)</span>
<span class="gi">+</span>
<span class="gi">+    G.add_edges_from([astubs[i], bstubs[i]] for i in range(suma))</span>
<span class="gi">+</span>
<span class="gi">+    G.name = &quot;bipartite_configuration_model&quot;</span>
<span class="gi">+    return G</span>


<span class="gd">-@nx._dispatchable(name=&#39;bipartite_havel_hakimi_graph&#39;, graphs=None,</span>
<span class="gd">-    returns_graph=True)</span>
<span class="gi">+@nx._dispatchable(name=&quot;bipartite_havel_hakimi_graph&quot;, graphs=None, returns_graph=True)</span>
<span class="w"> </span>def havel_hakimi_graph(aseq, bseq, create_using=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a bipartite graph from two given degree sequences using a
<span class="w"> </span>    Havel-Hakimi style construction.
<span class="gu">@@ -117,7 +171,46 @@ def havel_hakimi_graph(aseq, bseq, create_using=None):</span>
<span class="w"> </span>    This function is not imported in the main namespace.
<span class="w"> </span>    To use it use nx.bipartite.havel_hakimi_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # length of the each sequence</span>
<span class="gi">+    naseq = len(aseq)</span>
<span class="gi">+    nbseq = len(bseq)</span>
<span class="gi">+</span>
<span class="gi">+    suma = sum(aseq)</span>
<span class="gi">+    sumb = sum(bseq)</span>
<span class="gi">+</span>
<span class="gi">+    if not suma == sumb:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;invalid degree sequences, sum(aseq)!=sum(bseq),{suma},{sumb}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    G = _add_nodes_with_bipartite_label(G, naseq, nbseq)</span>
<span class="gi">+</span>
<span class="gi">+    if len(aseq) == 0 or max(aseq) == 0:</span>
<span class="gi">+        return G  # done if no edges</span>
<span class="gi">+</span>
<span class="gi">+    # build list of degree-repeated vertex numbers</span>
<span class="gi">+    astubs = [[aseq[v], v] for v in range(naseq)]</span>
<span class="gi">+    bstubs = [[bseq[v - naseq], v] for v in range(naseq, naseq + nbseq)]</span>
<span class="gi">+    astubs.sort()</span>
<span class="gi">+    while astubs:</span>
<span class="gi">+        (degree, u) = astubs.pop()  # take of largest degree node in the a set</span>
<span class="gi">+        if degree == 0:</span>
<span class="gi">+            break  # done, all are zero</span>
<span class="gi">+        # connect the source to largest degree nodes in the b set</span>
<span class="gi">+        bstubs.sort()</span>
<span class="gi">+        for target in bstubs[-degree:]:</span>
<span class="gi">+            v = target[1]</span>
<span class="gi">+            G.add_edge(u, v)</span>
<span class="gi">+            target[0] -= 1  # note this updates bstubs too.</span>
<span class="gi">+            if target[0] == 0:</span>
<span class="gi">+                bstubs.remove(target)</span>
<span class="gi">+</span>
<span class="gi">+    G.name = &quot;bipartite_havel_hakimi_graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -153,7 +246,45 @@ def reverse_havel_hakimi_graph(aseq, bseq, create_using=None):</span>
<span class="w"> </span>    This function is not imported in the main namespace.
<span class="w"> </span>    To use it use nx.bipartite.reverse_havel_hakimi_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # length of the each sequence</span>
<span class="gi">+    lena = len(aseq)</span>
<span class="gi">+    lenb = len(bseq)</span>
<span class="gi">+    suma = sum(aseq)</span>
<span class="gi">+    sumb = sum(bseq)</span>
<span class="gi">+</span>
<span class="gi">+    if not suma == sumb:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;invalid degree sequences, sum(aseq)!=sum(bseq),{suma},{sumb}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    G = _add_nodes_with_bipartite_label(G, lena, lenb)</span>
<span class="gi">+</span>
<span class="gi">+    if len(aseq) == 0 or max(aseq) == 0:</span>
<span class="gi">+        return G  # done if no edges</span>
<span class="gi">+</span>
<span class="gi">+    # build list of degree-repeated vertex numbers</span>
<span class="gi">+    astubs = [[aseq[v], v] for v in range(lena)]</span>
<span class="gi">+    bstubs = [[bseq[v - lena], v] for v in range(lena, lena + lenb)]</span>
<span class="gi">+    astubs.sort()</span>
<span class="gi">+    bstubs.sort()</span>
<span class="gi">+    while astubs:</span>
<span class="gi">+        (degree, u) = astubs.pop()  # take of largest degree node in the a set</span>
<span class="gi">+        if degree == 0:</span>
<span class="gi">+            break  # done, all are zero</span>
<span class="gi">+        # connect the source to the smallest degree nodes in the b set</span>
<span class="gi">+        for target in bstubs[0:degree]:</span>
<span class="gi">+            v = target[1]</span>
<span class="gi">+            G.add_edge(u, v)</span>
<span class="gi">+            target[0] -= 1  # note this updates bstubs too.</span>
<span class="gi">+            if target[0] == 0:</span>
<span class="gi">+                bstubs.remove(target)</span>
<span class="gi">+</span>
<span class="gi">+    G.name = &quot;bipartite_reverse_havel_hakimi_graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -190,7 +321,48 @@ def alternating_havel_hakimi_graph(aseq, bseq, create_using=None):</span>
<span class="w"> </span>    This function is not imported in the main namespace.
<span class="w"> </span>    To use it use nx.bipartite.alternating_havel_hakimi_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # length of the each sequence</span>
<span class="gi">+    naseq = len(aseq)</span>
<span class="gi">+    nbseq = len(bseq)</span>
<span class="gi">+    suma = sum(aseq)</span>
<span class="gi">+    sumb = sum(bseq)</span>
<span class="gi">+</span>
<span class="gi">+    if not suma == sumb:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;invalid degree sequences, sum(aseq)!=sum(bseq),{suma},{sumb}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    G = _add_nodes_with_bipartite_label(G, naseq, nbseq)</span>
<span class="gi">+</span>
<span class="gi">+    if len(aseq) == 0 or max(aseq) == 0:</span>
<span class="gi">+        return G  # done if no edges</span>
<span class="gi">+    # build list of degree-repeated vertex numbers</span>
<span class="gi">+    astubs = [[aseq[v], v] for v in range(naseq)]</span>
<span class="gi">+    bstubs = [[bseq[v - naseq], v] for v in range(naseq, naseq + nbseq)]</span>
<span class="gi">+    while astubs:</span>
<span class="gi">+        astubs.sort()</span>
<span class="gi">+        (degree, u) = astubs.pop()  # take of largest degree node in the a set</span>
<span class="gi">+        if degree == 0:</span>
<span class="gi">+            break  # done, all are zero</span>
<span class="gi">+        bstubs.sort()</span>
<span class="gi">+        small = bstubs[0 : degree // 2]  # add these low degree targets</span>
<span class="gi">+        large = bstubs[(-degree + degree // 2) :]  # now high degree targets</span>
<span class="gi">+        stubs = [x for z in zip(large, small) for x in z]  # combine, sorry</span>
<span class="gi">+        if len(stubs) &lt; len(small) + len(large):  # check for zip truncation</span>
<span class="gi">+            stubs.append(large.pop())</span>
<span class="gi">+        for target in stubs:</span>
<span class="gi">+            v = target[1]</span>
<span class="gi">+            G.add_edge(u, v)</span>
<span class="gi">+            target[0] -= 1  # note this updates bstubs too.</span>
<span class="gi">+            if target[0] == 0:</span>
<span class="gi">+                bstubs.remove(target)</span>
<span class="gi">+</span>
<span class="gi">+    G.name = &quot;bipartite_alternating_havel_hakimi_graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -234,7 +406,35 @@ def preferential_attachment_graph(aseq, p, create_using=None, seed=None):</span>
<span class="w"> </span>    This function is not imported in the main namespace.
<span class="w"> </span>    To use it use nx.bipartite.preferential_attachment_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if p &gt; 1:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;probability {p} &gt; 1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    naseq = len(aseq)</span>
<span class="gi">+    G = _add_nodes_with_bipartite_label(G, naseq, 0)</span>
<span class="gi">+    vv = [[v] * aseq[v] for v in range(naseq)]</span>
<span class="gi">+    while vv:</span>
<span class="gi">+        while vv[0]:</span>
<span class="gi">+            source = vv[0][0]</span>
<span class="gi">+            vv[0].remove(source)</span>
<span class="gi">+            if seed.random() &lt; p or len(G) == naseq:</span>
<span class="gi">+                target = len(G)</span>
<span class="gi">+                G.add_node(target, bipartite=1)</span>
<span class="gi">+                G.add_edge(source, target)</span>
<span class="gi">+            else:</span>
<span class="gi">+                bb = [[b] * G.degree(b) for b in range(naseq, len(G))]</span>
<span class="gi">+                # flatten the list of lists into a list.</span>
<span class="gi">+                bbstubs = reduce(lambda x, y: x + y, bb)</span>
<span class="gi">+                # choose preferentially a bottom node.</span>
<span class="gi">+                target = seed.choice(bbstubs)</span>
<span class="gi">+                G.add_node(target, bipartite=1)</span>
<span class="gi">+                G.add_edge(source, target)</span>
<span class="gi">+        vv.remove(vv[0])</span>
<span class="gi">+    G.name = &quot;bipartite_preferential_attachment_model&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -283,7 +483,45 @@ def random_graph(n, m, p, seed=None, directed=False):</span>
<span class="w"> </span>       &quot;Efficient generation of large random networks&quot;,
<span class="w"> </span>       Phys. Rev. E, 71, 036113, 2005.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    G = _add_nodes_with_bipartite_label(G, n, m)</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        G = nx.DiGraph(G)</span>
<span class="gi">+    G.name = f&quot;fast_gnp_random_graph({n},{m},{p})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if p &lt;= 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+    if p &gt;= 1:</span>
<span class="gi">+        return nx.complete_bipartite_graph(n, m)</span>
<span class="gi">+</span>
<span class="gi">+    lp = math.log(1.0 - p)</span>
<span class="gi">+</span>
<span class="gi">+    v = 0</span>
<span class="gi">+    w = -1</span>
<span class="gi">+    while v &lt; n:</span>
<span class="gi">+        lr = math.log(1.0 - seed.random())</span>
<span class="gi">+        w = w + 1 + int(lr / lp)</span>
<span class="gi">+        while w &gt;= m and v &lt; n:</span>
<span class="gi">+            w = w - m</span>
<span class="gi">+            v = v + 1</span>
<span class="gi">+        if v &lt; n:</span>
<span class="gi">+            G.add_edge(v, n + w)</span>
<span class="gi">+</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        # use the same algorithm to</span>
<span class="gi">+        # add edges from the &quot;m&quot; to &quot;n&quot; set</span>
<span class="gi">+        v = 0</span>
<span class="gi">+        w = -1</span>
<span class="gi">+        while v &lt; n:</span>
<span class="gi">+            lr = math.log(1.0 - seed.random())</span>
<span class="gi">+            w = w + 1 + int(lr / lp)</span>
<span class="gi">+            while w &gt;= m and v &lt; n:</span>
<span class="gi">+                w = w - m</span>
<span class="gi">+                v = v + 1</span>
<span class="gi">+            if v &lt; n:</span>
<span class="gi">+                G.add_edge(n + w, v)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -331,4 +569,35 @@ def gnmk_random_graph(n, m, k, seed=None, directed=False):</span>
<span class="w"> </span>    This function is not imported in the main namespace.
<span class="w"> </span>    To use it use nx.bipartite.gnmk_random_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    G = _add_nodes_with_bipartite_label(G, n, m)</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        G = nx.DiGraph(G)</span>
<span class="gi">+    G.name = f&quot;bipartite_gnm_random_graph({n},{m},{k})&quot;</span>
<span class="gi">+    if n == 1 or m == 1:</span>
<span class="gi">+        return G</span>
<span class="gi">+    max_edges = n * m  # max_edges for bipartite networks</span>
<span class="gi">+    if k &gt;= max_edges:  # Maybe we should raise an exception here</span>
<span class="gi">+        return nx.complete_bipartite_graph(n, m, create_using=G)</span>
<span class="gi">+</span>
<span class="gi">+    top = [n for n, d in G.nodes(data=True) if d[&quot;bipartite&quot;] == 0]</span>
<span class="gi">+    bottom = list(set(G) - set(top))</span>
<span class="gi">+    edge_count = 0</span>
<span class="gi">+    while edge_count &lt; k:</span>
<span class="gi">+        # generate random edge,u,v</span>
<span class="gi">+        u = seed.choice(top)</span>
<span class="gi">+        v = seed.choice(bottom)</span>
<span class="gi">+        if v in G[u]:</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            G.add_edge(u, v)</span>
<span class="gi">+            edge_count += 1</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _add_nodes_with_bipartite_label(G, lena, lenb):</span>
<span class="gi">+    G.add_nodes_from(range(lena + lenb))</span>
<span class="gi">+    b = dict(zip(range(lena), [0] * lena))</span>
<span class="gi">+    b.update(dict(zip(range(lena, lena + lenb), [1] * lenb)))</span>
<span class="gi">+    nx.set_node_attributes(G, b, &quot;bipartite&quot;)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/matching.py b/networkx/algorithms/bipartite/matching.py</span>
<span class="gh">index 931b37b2f..48149ab9e 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/matching.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/matching.py</span>
<span class="gu">@@ -1,3 +1,13 @@</span>
<span class="gi">+# This module uses material from the Wikipedia article Hopcroft--Karp algorithm</span>
<span class="gi">+# &lt;https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm&gt;, accessed on</span>
<span class="gi">+# January 3, 2015, which is released under the Creative Commons</span>
<span class="gi">+# Attribution-Share-Alike License 3.0</span>
<span class="gi">+# &lt;http://creativecommons.org/licenses/by-sa/3.0/&gt;. That article includes</span>
<span class="gi">+# pseudocode, which has been translated into the corresponding Python code.</span>
<span class="gi">+#</span>
<span class="gi">+# Portions of this module use code from David Eppstein&#39;s Python Algorithms and</span>
<span class="gi">+# Data Structures (PADS) library, which is dedicated to the public domain (for</span>
<span class="gi">+# proof, see &lt;http://www.ics.uci.edu/~eppstein/PADS/ABOUT-PADS.txt&gt;).</span>
<span class="w"> </span>&quot;&quot;&quot;Provides functions for computing maximum cardinality matchings and minimum
<span class="w"> </span>weight full matchings in a bipartite graph.

<span class="gu">@@ -28,12 +38,20 @@ edges included in the matching is minimal.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import collections
<span class="w"> </span>import itertools
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.bipartite import sets as bipartite_sets
<span class="w"> </span>from networkx.algorithms.bipartite.matrix import biadjacency_matrix
<span class="gd">-__all__ = [&#39;maximum_matching&#39;, &#39;hopcroft_karp_matching&#39;,</span>
<span class="gd">-    &#39;eppstein_matching&#39;, &#39;to_vertex_cover&#39;, &#39;minimum_weight_full_matching&#39;]</span>
<span class="gd">-INFINITY = float(&#39;inf&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;maximum_matching&quot;,</span>
<span class="gi">+    &quot;hopcroft_karp_matching&quot;,</span>
<span class="gi">+    &quot;eppstein_matching&quot;,</span>
<span class="gi">+    &quot;to_vertex_cover&quot;,</span>
<span class="gi">+    &quot;minimum_weight_full_matching&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+INFINITY = float(&quot;inf&quot;)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -98,7 +116,69 @@ def hopcroft_karp_matching(G, top_nodes=None):</span>
<span class="w"> </span>       2.4 (1973), pp. 225--231. &lt;https://doi.org/10.1137/0202019&gt;.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # First we define some auxiliary search functions.</span>
<span class="gi">+    #</span>
<span class="gi">+    # If you are a human reading these auxiliary search functions, the &quot;global&quot;</span>
<span class="gi">+    # variables `leftmatches`, `rightmatches`, `distances`, etc. are defined</span>
<span class="gi">+    # below the functions, so that they are initialized close to the initial</span>
<span class="gi">+    # invocation of the search functions.</span>
<span class="gi">+    def breadth_first_search():</span>
<span class="gi">+        for v in left:</span>
<span class="gi">+            if leftmatches[v] is None:</span>
<span class="gi">+                distances[v] = 0</span>
<span class="gi">+                queue.append(v)</span>
<span class="gi">+            else:</span>
<span class="gi">+                distances[v] = INFINITY</span>
<span class="gi">+        distances[None] = INFINITY</span>
<span class="gi">+        while queue:</span>
<span class="gi">+            v = queue.popleft()</span>
<span class="gi">+            if distances[v] &lt; distances[None]:</span>
<span class="gi">+                for u in G[v]:</span>
<span class="gi">+                    if distances[rightmatches[u]] is INFINITY:</span>
<span class="gi">+                        distances[rightmatches[u]] = distances[v] + 1</span>
<span class="gi">+                        queue.append(rightmatches[u])</span>
<span class="gi">+        return distances[None] is not INFINITY</span>
<span class="gi">+</span>
<span class="gi">+    def depth_first_search(v):</span>
<span class="gi">+        if v is not None:</span>
<span class="gi">+            for u in G[v]:</span>
<span class="gi">+                if distances[rightmatches[u]] == distances[v] + 1:</span>
<span class="gi">+                    if depth_first_search(rightmatches[u]):</span>
<span class="gi">+                        rightmatches[u] = v</span>
<span class="gi">+                        leftmatches[v] = u</span>
<span class="gi">+                        return True</span>
<span class="gi">+            distances[v] = INFINITY</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize the &quot;global&quot; variables that maintain state during the search.</span>
<span class="gi">+    left, right = bipartite_sets(G, top_nodes)</span>
<span class="gi">+    leftmatches = {v: None for v in left}</span>
<span class="gi">+    rightmatches = {v: None for v in right}</span>
<span class="gi">+    distances = {}</span>
<span class="gi">+    queue = collections.deque()</span>
<span class="gi">+</span>
<span class="gi">+    # Implementation note: this counter is incremented as pairs are matched but</span>
<span class="gi">+    # it is currently not used elsewhere in the computation.</span>
<span class="gi">+    num_matched_pairs = 0</span>
<span class="gi">+    while breadth_first_search():</span>
<span class="gi">+        for v in left:</span>
<span class="gi">+            if leftmatches[v] is None:</span>
<span class="gi">+                if depth_first_search(v):</span>
<span class="gi">+                    num_matched_pairs += 1</span>
<span class="gi">+</span>
<span class="gi">+    # Strip the entries matched to `None`.</span>
<span class="gi">+    leftmatches = {k: v for k, v in leftmatches.items() if v is not None}</span>
<span class="gi">+    rightmatches = {k: v for k, v in rightmatches.items() if v is not None}</span>
<span class="gi">+</span>
<span class="gi">+    # At this point, the left matches and the right matches are inverses of one</span>
<span class="gi">+    # another. In other words,</span>
<span class="gi">+    #</span>
<span class="gi">+    #     leftmatches == {v, k for k, v in rightmatches.items()}</span>
<span class="gi">+    #</span>
<span class="gi">+    # Finally, we combine both the left matches and right matches.</span>
<span class="gi">+    return dict(itertools.chain(leftmatches.items(), rightmatches.items()))</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -149,11 +229,98 @@ def eppstein_matching(G, top_nodes=None):</span>
<span class="w"> </span>    hopcroft_karp_matching

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _is_connected_by_alternating_path(G, v, matched_edges, unmatched_edges,</span>
<span class="gd">-    targets):</span>
<span class="gi">+    # Due to its original implementation, a directed graph is needed</span>
<span class="gi">+    # so that the two sets of bipartite nodes can be distinguished</span>
<span class="gi">+    left, right = bipartite_sets(G, top_nodes)</span>
<span class="gi">+    G = nx.DiGraph(G.edges(left))</span>
<span class="gi">+    # initialize greedy matching (redundant, but faster than full search)</span>
<span class="gi">+    matching = {}</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        for v in G[u]:</span>
<span class="gi">+            if v not in matching:</span>
<span class="gi">+                matching[v] = u</span>
<span class="gi">+                break</span>
<span class="gi">+    while True:</span>
<span class="gi">+        # structure residual graph into layers</span>
<span class="gi">+        # pred[u] gives the neighbor in the previous layer for u in U</span>
<span class="gi">+        # preds[v] gives a list of neighbors in the previous layer for v in V</span>
<span class="gi">+        # unmatched gives a list of unmatched vertices in final layer of V,</span>
<span class="gi">+        # and is also used as a flag value for pred[u] when u is in the first</span>
<span class="gi">+        # layer</span>
<span class="gi">+        preds = {}</span>
<span class="gi">+        unmatched = []</span>
<span class="gi">+        pred = {u: unmatched for u in G}</span>
<span class="gi">+        for v in matching:</span>
<span class="gi">+            del pred[matching[v]]</span>
<span class="gi">+        layer = list(pred)</span>
<span class="gi">+</span>
<span class="gi">+        # repeatedly extend layering structure by another pair of layers</span>
<span class="gi">+        while layer and not unmatched:</span>
<span class="gi">+            newLayer = {}</span>
<span class="gi">+            for u in layer:</span>
<span class="gi">+                for v in G[u]:</span>
<span class="gi">+                    if v not in preds:</span>
<span class="gi">+                        newLayer.setdefault(v, []).append(u)</span>
<span class="gi">+            layer = []</span>
<span class="gi">+            for v in newLayer:</span>
<span class="gi">+                preds[v] = newLayer[v]</span>
<span class="gi">+                if v in matching:</span>
<span class="gi">+                    layer.append(matching[v])</span>
<span class="gi">+                    pred[matching[v]] = v</span>
<span class="gi">+                else:</span>
<span class="gi">+                    unmatched.append(v)</span>
<span class="gi">+</span>
<span class="gi">+        # did we finish layering without finding any alternating paths?</span>
<span class="gi">+        if not unmatched:</span>
<span class="gi">+            # TODO - The lines between --- were unused and were thus commented</span>
<span class="gi">+            # out. This whole commented chunk should be reviewed to determine</span>
<span class="gi">+            # whether it should be built upon or completely removed.</span>
<span class="gi">+            # ---</span>
<span class="gi">+            # unlayered = {}</span>
<span class="gi">+            # for u in G:</span>
<span class="gi">+            #     # TODO Why is extra inner loop necessary?</span>
<span class="gi">+            #     for v in G[u]:</span>
<span class="gi">+            #         if v not in preds:</span>
<span class="gi">+            #             unlayered[v] = None</span>
<span class="gi">+            # ---</span>
<span class="gi">+            # TODO Originally, this function returned a three-tuple:</span>
<span class="gi">+            #</span>
<span class="gi">+            #     return (matching, list(pred), list(unlayered))</span>
<span class="gi">+            #</span>
<span class="gi">+            # For some reason, the documentation for this function</span>
<span class="gi">+            # indicated that the second and third elements of the returned</span>
<span class="gi">+            # three-tuple would be the vertices in the left and right vertex</span>
<span class="gi">+            # sets, respectively, that are also in the maximum independent set.</span>
<span class="gi">+            # However, what I think the author meant was that the second</span>
<span class="gi">+            # element is the list of vertices that were unmatched and the third</span>
<span class="gi">+            # element was the list of vertices that were matched. Since that</span>
<span class="gi">+            # seems to be the case, they don&#39;t really need to be returned,</span>
<span class="gi">+            # since that information can be inferred from the matching</span>
<span class="gi">+            # dictionary.</span>
<span class="gi">+</span>
<span class="gi">+            # All the matched nodes must be a key in the dictionary</span>
<span class="gi">+            for key in matching.copy():</span>
<span class="gi">+                matching[matching[key]] = key</span>
<span class="gi">+            return matching</span>
<span class="gi">+</span>
<span class="gi">+        # recursively search backward through layers to find alternating paths</span>
<span class="gi">+        # recursion returns true if found path, false otherwise</span>
<span class="gi">+        def recurse(v):</span>
<span class="gi">+            if v in preds:</span>
<span class="gi">+                L = preds.pop(v)</span>
<span class="gi">+                for u in L:</span>
<span class="gi">+                    if u in pred:</span>
<span class="gi">+                        pu = pred.pop(u)</span>
<span class="gi">+                        if pu is unmatched or recurse(pu):</span>
<span class="gi">+                            matching[v] = u</span>
<span class="gi">+                            return True</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        for v in unmatched:</span>
<span class="gi">+            recurse(v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_connected_by_alternating_path(G, v, matched_edges, unmatched_edges, targets):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns True if and only if the vertex `v` is connected to one of
<span class="w"> </span>    the target vertices by an alternating path in `G`.

<span class="gu">@@ -175,7 +342,44 @@ def _is_connected_by_alternating_path(G, v, matched_edges, unmatched_edges,</span>
<span class="w"> </span>    `targets` is a set of vertices.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _alternating_dfs(u, along_matched=True):</span>
<span class="gi">+        &quot;&quot;&quot;Returns True if and only if `u` is connected to one of the</span>
<span class="gi">+        targets by an alternating path.</span>
<span class="gi">+</span>
<span class="gi">+        `u` is a vertex in the graph `G`.</span>
<span class="gi">+</span>
<span class="gi">+        If `along_matched` is True, this step of the depth-first search</span>
<span class="gi">+        will continue only through edges in the given matching. Otherwise, it</span>
<span class="gi">+        will continue only through edges *not* in the given matching.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        visited = set()</span>
<span class="gi">+        # Follow matched edges when depth is even,</span>
<span class="gi">+        # and follow unmatched edges when depth is odd.</span>
<span class="gi">+        initial_depth = 0 if along_matched else 1</span>
<span class="gi">+        stack = [(u, iter(G[u]), initial_depth)]</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            parent, children, depth = stack[-1]</span>
<span class="gi">+            valid_edges = matched_edges if depth % 2 else unmatched_edges</span>
<span class="gi">+            try:</span>
<span class="gi">+                child = next(children)</span>
<span class="gi">+                if child not in visited:</span>
<span class="gi">+                    if (parent, child) in valid_edges or (child, parent) in valid_edges:</span>
<span class="gi">+                        if child in targets:</span>
<span class="gi">+                            return True</span>
<span class="gi">+                        visited.add(child)</span>
<span class="gi">+                        stack.append((child, iter(G[child]), depth + 1))</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Check for alternating paths starting with edges in the matching, then</span>
<span class="gi">+    # check for alternating paths starting with edges not in the</span>
<span class="gi">+    # matching.</span>
<span class="gi">+    return _alternating_dfs(v, along_matched=True) or _alternating_dfs(</span>
<span class="gi">+        v, along_matched=False</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _connected_by_alternating_paths(G, matching, targets):
<span class="gu">@@ -196,7 +400,24 @@ def _connected_by_alternating_paths(G, matching, targets):</span>
<span class="w"> </span>    `targets` is a set of vertices.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get the set of matched edges and the set of unmatched edges. Only include</span>
<span class="gi">+    # one version of each undirected edge (for example, include edge (1, 2) but</span>
<span class="gi">+    # not edge (2, 1)). Using frozensets as an intermediary step we do not</span>
<span class="gi">+    # require nodes to be orderable.</span>
<span class="gi">+    edge_sets = {frozenset((u, v)) for u, v in matching.items()}</span>
<span class="gi">+    matched_edges = {tuple(edge) for edge in edge_sets}</span>
<span class="gi">+    unmatched_edges = {</span>
<span class="gi">+        (u, v) for (u, v) in G.edges() if frozenset((u, v)) not in edge_sets</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        v</span>
<span class="gi">+        for v in G</span>
<span class="gi">+        if v in targets</span>
<span class="gi">+        or _is_connected_by_alternating_path(</span>
<span class="gi">+            G, v, matched_edges, unmatched_edges, targets</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -260,30 +481,44 @@ def to_vertex_cover(G, matching, top_nodes=None):</span>
<span class="w"> </span>    for further details on how bipartite graphs are handled in NetworkX.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    # This is a Python implementation of the algorithm described at</span>
<span class="gi">+    # &lt;https://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29#Proof&gt;.</span>
<span class="gi">+    L, R = bipartite_sets(G, top_nodes)</span>
<span class="gi">+    # Let U be the set of unmatched vertices in the left vertex set.</span>
<span class="gi">+    unmatched_vertices = set(G) - set(matching)</span>
<span class="gi">+    U = unmatched_vertices &amp; L</span>
<span class="gi">+    # Let Z be the set of vertices that are either in U or are connected to U</span>
<span class="gi">+    # by alternating paths.</span>
<span class="gi">+    Z = _connected_by_alternating_paths(G, matching, U)</span>
<span class="gi">+    # At this point, every edge either has a right endpoint in Z or a left</span>
<span class="gi">+    # endpoint not in Z. This gives us the vertex cover.</span>
<span class="gi">+    return (L - Z) | (R &amp; Z)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: Returns the maximum cardinality matching in the given bipartite graph.</span>
<span class="gi">+#:</span>
<span class="gi">+#: This function is simply an alias for :func:`hopcroft_karp_matching`.</span>
<span class="w"> </span>maximum_matching = hopcroft_karp_matching


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def minimum_weight_full_matching(G, top_nodes=None, weight=&#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Returns a minimum weight full matching of the bipartite graph `G`.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def minimum_weight_full_matching(G, top_nodes=None, weight=&quot;weight&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a minimum weight full matching of the bipartite graph `G`.</span>

<span class="w"> </span>    Let :math:`G = ((U, V), E)` be a weighted bipartite graph with real weights
<span class="gd">-    :math:`w : E \\to \\mathbb{R}`. This function then produces a matching</span>
<span class="gd">-    :math:`M \\subseteq E` with cardinality</span>
<span class="gi">+    :math:`w : E \to \mathbb{R}`. This function then produces a matching</span>
<span class="gi">+    :math:`M \subseteq E` with cardinality</span>

<span class="w"> </span>    .. math::
<span class="gd">-       \\lvert M \\rvert = \\min(\\lvert U \\rvert, \\lvert V \\rvert),</span>
<span class="gi">+       \lvert M \rvert = \min(\lvert U \rvert, \lvert V \rvert),</span>

<span class="w"> </span>    which minimizes the sum of the weights of the edges included in the
<span class="gd">-    matching, :math:`\\sum_{e \\in M} w(e)`, or raises an error if no such</span>
<span class="gi">+    matching, :math:`\sum_{e \in M} w(e)`, or raises an error if no such</span>
<span class="w"> </span>    matching exists.

<span class="gd">-    When :math:`\\lvert U \\rvert = \\lvert V \\rvert`, this is commonly</span>
<span class="gi">+    When :math:`\lvert U \rvert = \lvert V \rvert`, this is commonly</span>
<span class="w"> </span>    referred to as a perfect matching; here, since we allow
<span class="gd">-    :math:`\\lvert U \\rvert` and :math:`\\lvert V \\rvert` to differ, we</span>
<span class="gi">+    :math:`\lvert U \rvert` and :math:`\lvert V \rvert` to differ, we</span>
<span class="w"> </span>    follow Karp [1]_ and refer to the matching as *full*.

<span class="w"> </span>    Parameters
<span class="gu">@@ -332,4 +567,23 @@ def minimum_weight_full_matching(G, top_nodes=None, weight=&#39;weight&#39;):</span>
<span class="w"> </span>       Networks, 10(2):143–152, 1980.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    left, right = nx.bipartite.sets(G, top_nodes)</span>
<span class="gi">+    U = list(left)</span>
<span class="gi">+    V = list(right)</span>
<span class="gi">+    # We explicitly create the biadjacency matrix having infinities</span>
<span class="gi">+    # where edges are missing (as opposed to zeros, which is what one would</span>
<span class="gi">+    # get by using toarray on the sparse matrix).</span>
<span class="gi">+    weights_sparse = biadjacency_matrix(</span>
<span class="gi">+        G, row_order=U, column_order=V, weight=weight, format=&quot;coo&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    weights = np.full(weights_sparse.shape, np.inf)</span>
<span class="gi">+    weights[weights_sparse.row, weights_sparse.col] = weights_sparse.data</span>
<span class="gi">+    left_matches = sp.optimize.linear_sum_assignment(weights)</span>
<span class="gi">+    d = {U[u]: V[v] for u, v in zip(*left_matches)}</span>
<span class="gi">+    # d will contain the matching from edges in left to right; we need to</span>
<span class="gi">+    # add the ones from right to left as well.</span>
<span class="gi">+    d.update({v: u for u, v in d.items()})</span>
<span class="gi">+    return d</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/matrix.py b/networkx/algorithms/bipartite/matrix.py</span>
<span class="gh">index dc5ad9920..462ef8a13 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/matrix.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/matrix.py</span>
<span class="gu">@@ -4,20 +4,23 @@ Biadjacency matrices</span>
<span class="w"> </span>====================
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import itertools
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.convert_matrix import _generate_weighted_edges
<span class="gd">-__all__ = [&#39;biadjacency_matrix&#39;, &#39;from_biadjacency_matrix&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;biadjacency_matrix&quot;, &quot;from_biadjacency_matrix&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def biadjacency_matrix(G, row_order, column_order=None, dtype=None, weight=</span>
<span class="gd">-    &#39;weight&#39;, format=&#39;csr&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the biadjacency matrix of the bipartite graph G.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def biadjacency_matrix(</span>
<span class="gi">+    G, row_order, column_order=None, dtype=None, weight=&quot;weight&quot;, format=&quot;csr&quot;</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the biadjacency matrix of the bipartite graph G.</span>

<span class="w"> </span>    Let `G = (U, V, E)` be a bipartite graph with node sets
<span class="w"> </span>    `U = u_{1},...,u_{r}` and `V = v_{1},...,v_{s}`. The biadjacency
<span class="w"> </span>    matrix [1]_ is the `r` x `s` matrix `B` in which `b_{i,j} = 1`
<span class="gd">-    if, and only if, `(u_i, v_j) \\in E`. If the parameter `weight` is</span>
<span class="gi">+    if, and only if, `(u_i, v_j) \in E`. If the parameter `weight` is</span>
<span class="w"> </span>    not `None` and matches the name of an edge attribute, its value is
<span class="w"> </span>    used instead of 1.

<span class="gu">@@ -72,12 +75,44 @@ def biadjacency_matrix(G, row_order, column_order=None, dtype=None, weight=</span>
<span class="w"> </span>    .. [2] Scipy Dev. References, &quot;Sparse Matrices&quot;,
<span class="w"> </span>       https://docs.scipy.org/doc/scipy/reference/sparse.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    nlen = len(row_order)</span>
<span class="gi">+    if nlen == 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;row_order is empty list&quot;)</span>
<span class="gi">+    if len(row_order) != len(set(row_order)):</span>
<span class="gi">+        msg = &quot;Ambiguous ordering: `row_order` contained duplicates.&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    if column_order is None:</span>
<span class="gi">+        column_order = list(set(G) - set(row_order))</span>
<span class="gi">+    mlen = len(column_order)</span>
<span class="gi">+    if len(column_order) != len(set(column_order)):</span>
<span class="gi">+        msg = &quot;Ambiguous ordering: `column_order` contained duplicates.&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    row_index = dict(zip(row_order, itertools.count()))</span>
<span class="gi">+    col_index = dict(zip(column_order, itertools.count()))</span>
<span class="gi">+</span>
<span class="gi">+    if G.number_of_edges() == 0:</span>
<span class="gi">+        row, col, data = [], [], []</span>
<span class="gi">+    else:</span>
<span class="gi">+        row, col, data = zip(</span>
<span class="gi">+            *(</span>
<span class="gi">+                (row_index[u], col_index[v], d.get(weight, 1))</span>
<span class="gi">+                for u, v, d in G.edges(row_order, data=True)</span>
<span class="gi">+                if u in row_index and v in col_index</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    A = sp.sparse.coo_array((data, (row, col)), shape=(nlen, mlen), dtype=dtype)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return A.asformat(format)</span>
<span class="gi">+    except ValueError as err:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Unknown sparse array format: {format}&quot;) from err</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def from_biadjacency_matrix(A, create_using=None, edge_attribute=&#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Creates a new bipartite graph from a biadjacency matrix given as a</span>
<span class="gi">+def from_biadjacency_matrix(A, create_using=None, edge_attribute=&quot;weight&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Creates a new bipartite graph from a biadjacency matrix given as a</span>
<span class="w"> </span>    SciPy sparse array.

<span class="w"> </span>    Parameters
<span class="gu">@@ -112,4 +147,21 @@ def from_biadjacency_matrix(A, create_using=None, edge_attribute=&#39;weight&#39;):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    [1] https://en.wikipedia.org/wiki/Adjacency_matrix#Adjacency_matrix_of_a_bipartite_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    n, m = A.shape</span>
<span class="gi">+    # Make sure we get even the isolated nodes of the graph.</span>
<span class="gi">+    G.add_nodes_from(range(n), bipartite=0)</span>
<span class="gi">+    G.add_nodes_from(range(n, n + m), bipartite=1)</span>
<span class="gi">+    # Create an iterable over (u, v, w) triples and for each triple, add an</span>
<span class="gi">+    # edge from u to v with weight w.</span>
<span class="gi">+    triples = ((u, n + v, d) for (u, v, d) in _generate_weighted_edges(A))</span>
<span class="gi">+    # If the entries in the adjacency matrix are integers and the graph is a</span>
<span class="gi">+    # multigraph, then create parallel edges, each with weight 1, for each</span>
<span class="gi">+    # entry in the adjacency matrix. Otherwise, create one edge for each</span>
<span class="gi">+    # positive entry in the adjacency matrix and set the weight of that edge to</span>
<span class="gi">+    # be the entry in the matrix.</span>
<span class="gi">+    if A.dtype.kind in (&quot;i&quot;, &quot;u&quot;) and G.is_multigraph():</span>
<span class="gi">+        chain = itertools.chain.from_iterable</span>
<span class="gi">+        triples = chain(((u, v, 1) for d in range(w)) for (u, v, w) in triples)</span>
<span class="gi">+    G.add_weighted_edges_from(triples, weight=edge_attribute)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/projection.py b/networkx/algorithms/bipartite/projection.py</span>
<span class="gh">index d45be2a76..1eb71fa52 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/projection.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/projection.py</span>
<span class="gu">@@ -2,15 +2,21 @@</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXAlgorithmError
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;projected_graph&#39;, &#39;weighted_projected_graph&#39;,</span>
<span class="gd">-    &#39;collaboration_weighted_projected_graph&#39;,</span>
<span class="gd">-    &#39;overlap_weighted_projected_graph&#39;, &#39;generic_weighted_projected_graph&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;projected_graph&quot;,</span>
<span class="gi">+    &quot;weighted_projected_graph&quot;,</span>
<span class="gi">+    &quot;collaboration_weighted_projected_graph&quot;,</span>
<span class="gi">+    &quot;overlap_weighted_projected_graph&quot;,</span>
<span class="gi">+    &quot;generic_weighted_projected_graph&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@nx._dispatchable(graphs=&#39;B&#39;, preserve_node_attrs=True,</span>
<span class="gd">-    preserve_graph_attrs=True, returns_graph=True)</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs=&quot;B&quot;, preserve_node_attrs=True, preserve_graph_attrs=True, returns_graph=True</span>
<span class="gi">+)</span>
<span class="w"> </span>def projected_graph(B, nodes, multigraph=False):
<span class="gd">-    &quot;&quot;&quot;Returns the projection of B onto one of its node sets.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the projection of B onto one of its node sets.</span>

<span class="w"> </span>    Returns the graph G that is the projection of the bipartite graph B
<span class="w"> </span>    onto the specified nodes. They retain their attributes and are connected
<span class="gu">@@ -80,13 +86,42 @@ def projected_graph(B, nodes, multigraph=False):</span>
<span class="w"> </span>    overlap_weighted_projected_graph,
<span class="w"> </span>    generic_weighted_projected_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;B&#39;, returns_graph=True)</span>
<span class="gi">+    if B.is_multigraph():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;not defined for multigraphs&quot;)</span>
<span class="gi">+    if B.is_directed():</span>
<span class="gi">+        directed = True</span>
<span class="gi">+        if multigraph:</span>
<span class="gi">+            G = nx.MultiDiGraph()</span>
<span class="gi">+        else:</span>
<span class="gi">+            G = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        directed = False</span>
<span class="gi">+        if multigraph:</span>
<span class="gi">+            G = nx.MultiGraph()</span>
<span class="gi">+        else:</span>
<span class="gi">+            G = nx.Graph()</span>
<span class="gi">+    G.graph.update(B.graph)</span>
<span class="gi">+    G.add_nodes_from((n, B.nodes[n]) for n in nodes)</span>
<span class="gi">+    for u in nodes:</span>
<span class="gi">+        nbrs2 = {v for nbr in B[u] for v in B[nbr] if v != u}</span>
<span class="gi">+        if multigraph:</span>
<span class="gi">+            for n in nbrs2:</span>
<span class="gi">+                if directed:</span>
<span class="gi">+                    links = set(B[u]) &amp; set(B.pred[n])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    links = set(B[u]) &amp; set(B[n])</span>
<span class="gi">+                for l in links:</span>
<span class="gi">+                    if not G.has_edge(u, n, l):</span>
<span class="gi">+                        G.add_edge(u, n, key=l)</span>
<span class="gi">+        else:</span>
<span class="gi">+            G.add_edges_from((u, n) for n in nbrs2)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;B&quot;, returns_graph=True)</span>
<span class="w"> </span>def weighted_projected_graph(B, nodes, ratio=False):
<span class="gd">-    &quot;&quot;&quot;Returns a weighted projection of B onto one of its node sets.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a weighted projection of B onto one of its node sets.</span>

<span class="w"> </span>    The weighted projected graph is the projection of the bipartite
<span class="w"> </span>    network B onto the specified nodes with weights representing the
<span class="gu">@@ -154,13 +189,40 @@ def weighted_projected_graph(B, nodes, ratio=False):</span>
<span class="w"> </span>        Networks&quot;. In Carrington, P. and Scott, J. (eds) The Sage Handbook
<span class="w"> </span>        of Social Network Analysis. Sage Publications.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;B&#39;, returns_graph=True)</span>
<span class="gi">+    if B.is_directed():</span>
<span class="gi">+        pred = B.pred</span>
<span class="gi">+        G = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        pred = B.adj</span>
<span class="gi">+        G = nx.Graph()</span>
<span class="gi">+    G.graph.update(B.graph)</span>
<span class="gi">+    G.add_nodes_from((n, B.nodes[n]) for n in nodes)</span>
<span class="gi">+    n_top = len(B) - len(nodes)</span>
<span class="gi">+</span>
<span class="gi">+    if n_top &lt; 1:</span>
<span class="gi">+        raise NetworkXAlgorithmError(</span>
<span class="gi">+            f&quot;the size of the nodes to project onto ({len(nodes)}) is &gt;= the graph size ({len(B)}).\n&quot;</span>
<span class="gi">+            &quot;They are either not a valid bipartite partition or contain duplicates&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    for u in nodes:</span>
<span class="gi">+        unbrs = set(B[u])</span>
<span class="gi">+        nbrs2 = {n for nbr in unbrs for n in B[nbr]} - {u}</span>
<span class="gi">+        for v in nbrs2:</span>
<span class="gi">+            vnbrs = set(pred[v])</span>
<span class="gi">+            common = unbrs &amp; vnbrs</span>
<span class="gi">+            if not ratio:</span>
<span class="gi">+                weight = len(common)</span>
<span class="gi">+            else:</span>
<span class="gi">+                weight = len(common) / n_top</span>
<span class="gi">+            G.add_edge(u, v, weight=weight)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;B&quot;, returns_graph=True)</span>
<span class="w"> </span>def collaboration_weighted_projected_graph(B, nodes):
<span class="gd">-    &quot;&quot;&quot;Newman&#39;s weighted projection of B onto one of its node sets.</span>
<span class="gi">+    r&quot;&quot;&quot;Newman&#39;s weighted projection of B onto one of its node sets.</span>

<span class="w"> </span>    The collaboration weighted projection is the projection of the
<span class="w"> </span>    bipartite network B onto the specified nodes with weights assigned
<span class="gu">@@ -168,12 +230,12 @@ def collaboration_weighted_projected_graph(B, nodes):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        w_{u, v} = \\sum_k \\frac{\\delta_{u}^{k} \\delta_{v}^{k}}{d_k - 1}</span>
<span class="gi">+        w_{u, v} = \sum_k \frac{\delta_{u}^{k} \delta_{v}^{k}}{d_k - 1}</span>

<span class="w"> </span>    where `u` and `v` are nodes from the bottom bipartite node set,
<span class="w"> </span>    and `k` is a node of the top node set.
<span class="w"> </span>    The value `d_k` is the degree of node `k` in the bipartite
<span class="gd">-    network and `\\delta_{u}^{k}` is 1 if node `u` is</span>
<span class="gi">+    network and `\delta_{u}^{k}` is 1 if node `u` is</span>
<span class="w"> </span>    linked to node `k` in the original bipartite graph or 0 otherwise.

<span class="w"> </span>    The nodes retain their attributes and are connected in the resulting
<span class="gu">@@ -232,13 +294,29 @@ def collaboration_weighted_projected_graph(B, nodes):</span>
<span class="w"> </span>        Shortest paths, weighted networks, and centrality,
<span class="w"> </span>        M. E. J. Newman, Phys. Rev. E 64, 016132 (2001).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;B&#39;, returns_graph=True)</span>
<span class="gi">+    if B.is_directed():</span>
<span class="gi">+        pred = B.pred</span>
<span class="gi">+        G = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        pred = B.adj</span>
<span class="gi">+        G = nx.Graph()</span>
<span class="gi">+    G.graph.update(B.graph)</span>
<span class="gi">+    G.add_nodes_from((n, B.nodes[n]) for n in nodes)</span>
<span class="gi">+    for u in nodes:</span>
<span class="gi">+        unbrs = set(B[u])</span>
<span class="gi">+        nbrs2 = {n for nbr in unbrs for n in B[nbr] if n != u}</span>
<span class="gi">+        for v in nbrs2:</span>
<span class="gi">+            vnbrs = set(pred[v])</span>
<span class="gi">+            common_degree = (len(B[n]) for n in unbrs &amp; vnbrs)</span>
<span class="gi">+            weight = sum(1.0 / (deg - 1) for deg in common_degree if deg &gt; 1)</span>
<span class="gi">+            G.add_edge(u, v, weight=weight)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;B&quot;, returns_graph=True)</span>
<span class="w"> </span>def overlap_weighted_projected_graph(B, nodes, jaccard=True):
<span class="gd">-    &quot;&quot;&quot;Overlap weighted projection of B onto one of its node sets.</span>
<span class="gi">+    r&quot;&quot;&quot;Overlap weighted projection of B onto one of its node sets.</span>

<span class="w"> </span>    The overlap weighted projection is the projection of the bipartite
<span class="w"> </span>    network B onto the specified nodes with weights representing
<span class="gu">@@ -247,7 +325,7 @@ def overlap_weighted_projected_graph(B, nodes, jaccard=True):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        w_{v, u} = \\frac{|N(u) \\cap N(v)|}{|N(u) \\cup N(v)|}</span>
<span class="gi">+        w_{v, u} = \frac{|N(u) \cap N(v)|}{|N(u) \cup N(v)|}</span>

<span class="w"> </span>    or if the parameter &#39;jaccard&#39; is False, the fraction of common
<span class="w"> </span>    neighbors by minimum of both nodes degree in the original
<span class="gu">@@ -255,7 +333,7 @@ def overlap_weighted_projected_graph(B, nodes, jaccard=True):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        w_{v, u} = \\frac{|N(u) \\cap N(v)|}{min(|N(u)|, |N(v)|)}</span>
<span class="gi">+        w_{v, u} = \frac{|N(u) \cap N(v)|}{min(|N(u)|, |N(v)|)}</span>

<span class="w"> </span>    The nodes retain their attributes and are connected in the resulting
<span class="w"> </span>    graph if have an edge to a common node in the original bipartite graph.
<span class="gu">@@ -314,13 +392,31 @@ def overlap_weighted_projected_graph(B, nodes, jaccard=True):</span>
<span class="w"> </span>        of Social Network Analysis. Sage Publications.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;B&#39;, preserve_all_attrs=True, returns_graph=True)</span>
<span class="gi">+    if B.is_directed():</span>
<span class="gi">+        pred = B.pred</span>
<span class="gi">+        G = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        pred = B.adj</span>
<span class="gi">+        G = nx.Graph()</span>
<span class="gi">+    G.graph.update(B.graph)</span>
<span class="gi">+    G.add_nodes_from((n, B.nodes[n]) for n in nodes)</span>
<span class="gi">+    for u in nodes:</span>
<span class="gi">+        unbrs = set(B[u])</span>
<span class="gi">+        nbrs2 = {n for nbr in unbrs for n in B[nbr]} - {u}</span>
<span class="gi">+        for v in nbrs2:</span>
<span class="gi">+            vnbrs = set(pred[v])</span>
<span class="gi">+            if jaccard:</span>
<span class="gi">+                wt = len(unbrs &amp; vnbrs) / len(unbrs | vnbrs)</span>
<span class="gi">+            else:</span>
<span class="gi">+                wt = len(unbrs &amp; vnbrs) / min(len(unbrs), len(vnbrs))</span>
<span class="gi">+            G.add_edge(u, v, weight=wt)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;B&quot;, preserve_all_attrs=True, returns_graph=True)</span>
<span class="w"> </span>def generic_weighted_projected_graph(B, nodes, weight_function=None):
<span class="gd">-    &quot;&quot;&quot;Weighted projection of B with a user-specified weight function.</span>
<span class="gi">+    r&quot;&quot;&quot;Weighted projection of B with a user-specified weight function.</span>

<span class="w"> </span>    The bipartite network B is projected on to the specified nodes
<span class="w"> </span>    with weights computed by a user-specified function.  This function
<span class="gu">@@ -403,4 +499,23 @@ def generic_weighted_projected_graph(B, nodes, weight_function=None):</span>
<span class="w"> </span>    projected_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if B.is_directed():</span>
<span class="gi">+        pred = B.pred</span>
<span class="gi">+        G = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        pred = B.adj</span>
<span class="gi">+        G = nx.Graph()</span>
<span class="gi">+    if weight_function is None:</span>
<span class="gi">+</span>
<span class="gi">+        def weight_function(G, u, v):</span>
<span class="gi">+            # Notice that we use set(pred[v]) for handling the directed case.</span>
<span class="gi">+            return len(set(G[u]) &amp; set(pred[v]))</span>
<span class="gi">+</span>
<span class="gi">+    G.graph.update(B.graph)</span>
<span class="gi">+    G.add_nodes_from((n, B.nodes[n]) for n in nodes)</span>
<span class="gi">+    for u in nodes:</span>
<span class="gi">+        nbrs2 = {n for nbr in set(B[u]) for n in B[nbr]} - {u}</span>
<span class="gi">+        for v in nbrs2:</span>
<span class="gi">+            weight = weight_function(B, u, v)</span>
<span class="gi">+            G.add_edge(u, v, weight=weight)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/redundancy.py b/networkx/algorithms/bipartite/redundancy.py</span>
<span class="gh">index 6d8f53973..7a44d2128 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/redundancy.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/redundancy.py</span>
<span class="gu">@@ -1,13 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Node redundancy for bipartite graphs.&quot;&quot;&quot;
<span class="w"> </span>from itertools import combinations
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx import NetworkXError
<span class="gd">-__all__ = [&#39;node_redundancy&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;node_redundancy&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def node_redundancy(G, nodes=None):
<span class="gd">-    &quot;&quot;&quot;Computes the node redundancy coefficients for the nodes in the bipartite</span>
<span class="gi">+    r&quot;&quot;&quot;Computes the node redundancy coefficients for the nodes in the bipartite</span>
<span class="w"> </span>    graph `G`.

<span class="w"> </span>    The redundancy coefficient of a node `v` is the fraction of pairs of
<span class="gu">@@ -20,9 +22,9 @@ def node_redundancy(G, nodes=None):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        rc(v) = \\frac{|\\{\\{u, w\\} \\subseteq N(v),</span>
<span class="gd">-        \\: \\exists v&#39; \\neq  v,\\: (v&#39;,u) \\in E\\:</span>
<span class="gd">-        \\mathrm{and}\\: (v&#39;,w) \\in E\\}|}{ \\frac{|N(v)|(|N(v)|-1)}{2}},</span>
<span class="gi">+        rc(v) = \frac{|\{\{u, w\} \subseteq N(v),</span>
<span class="gi">+        \: \exists v&#39; \neq  v,\: (v&#39;,u) \in E\:</span>
<span class="gi">+        \mathrm{and}\: (v&#39;,w) \in E\}|}{ \frac{|N(v)|(|N(v)|-1)}{2}},</span>

<span class="w"> </span>    where `N(v)` is the set of neighbors of `v` in `G`.

<span class="gu">@@ -80,7 +82,15 @@ def node_redundancy(G, nodes=None):</span>
<span class="w"> </span>       Social Networks 30(1), 31--48.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = G</span>
<span class="gi">+    if any(len(G[v]) &lt; 2 for v in nodes):</span>
<span class="gi">+        raise NetworkXError(</span>
<span class="gi">+            &quot;Cannot compute redundancy coefficient for a node&quot;</span>
<span class="gi">+            &quot; that has fewer than two neighbors.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    # TODO This can be trivially parallelized.</span>
<span class="gi">+    return {v: _node_redundancy(G, v) for v in nodes}</span>


<span class="w"> </span>def _node_redundancy(G, v):
<span class="gu">@@ -94,4 +104,8 @@ def _node_redundancy(G, v):</span>
<span class="w"> </span>    `v` must have at least two neighbors in `G`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(G[v])</span>
<span class="gi">+    overlap = sum(</span>
<span class="gi">+        1 for (u, w) in combinations(G[v], 2) if (set(G[u]) &amp; set(G[w])) - {v}</span>
<span class="gi">+    )</span>
<span class="gi">+    return (2 * overlap) / (n * (n - 1))</span>
<span class="gh">diff --git a/networkx/algorithms/bipartite/spectral.py b/networkx/algorithms/bipartite/spectral.py</span>
<span class="gh">index fe6188e5c..61a56dd2c 100644</span>
<span class="gd">--- a/networkx/algorithms/bipartite/spectral.py</span>
<span class="gi">+++ b/networkx/algorithms/bipartite/spectral.py</span>
<span class="gu">@@ -2,11 +2,12 @@</span>
<span class="w"> </span>Spectral bipartivity measure.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;spectral_bipartivity&#39;]</span>

<span class="gi">+__all__ = [&quot;spectral_bipartivity&quot;]</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def spectral_bipartivity(G, nodes=None, weight=&#39;weight&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def spectral_bipartivity(G, nodes=None, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the spectral bipartivity.

<span class="w"> </span>    Parameters
<span class="gu">@@ -47,4 +48,21 @@ def spectral_bipartivity(G, nodes=None, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    .. [1] E. Estrada and J. A. Rodríguez-Velázquez, &quot;Spectral measures of
<span class="w"> </span>       bipartivity in complex networks&quot;, PhysRev E 72, 046105 (2005)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    nodelist = list(G)  # ordering of nodes in matrix</span>
<span class="gi">+    A = nx.to_numpy_array(G, nodelist, weight=weight)</span>
<span class="gi">+    expA = sp.linalg.expm(A)</span>
<span class="gi">+    expmA = sp.linalg.expm(-A)</span>
<span class="gi">+    coshA = 0.5 * (expA + expmA)</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        # return single number for entire graph</span>
<span class="gi">+        return float(coshA.diagonal().sum() / expA.diagonal().sum())</span>
<span class="gi">+    else:</span>
<span class="gi">+        # contribution for individual nodes</span>
<span class="gi">+        index = dict(zip(nodelist, range(len(nodelist))))</span>
<span class="gi">+        sb = {}</span>
<span class="gi">+        for n in nodes:</span>
<span class="gi">+            i = index[n]</span>
<span class="gi">+            sb[n] = coshA.item(i, i) / expA.item(i, i)</span>
<span class="gi">+        return sb</span>
<span class="gh">diff --git a/networkx/algorithms/boundary.py b/networkx/algorithms/boundary.py</span>
<span class="gh">index 86e7511a1..fef9ba223 100644</span>
<span class="gd">--- a/networkx/algorithms/boundary.py</span>
<span class="gi">+++ b/networkx/algorithms/boundary.py</span>
<span class="gu">@@ -9,13 +9,14 @@ nodes in *S* that are outside *S*.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;edge_boundary&#39;, &#39;node_boundary&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;edge_boundary&quot;, &quot;node_boundary&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs={&#39;data&#39;: &#39;default&#39;}, preserve_edge_attrs=&#39;data&#39;)</span>
<span class="gd">-def edge_boundary(G, nbunch1, nbunch2=None, data=False, keys=False, default</span>
<span class="gd">-    =None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;data&quot;: &quot;default&quot;}, preserve_edge_attrs=&quot;data&quot;)</span>
<span class="gi">+def edge_boundary(G, nbunch1, nbunch2=None, data=False, keys=False, default=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the edge boundary of `nbunch1`.

<span class="w"> </span>    The *edge boundary* of a set *S* with respect to a set *T* is the
<span class="gu">@@ -81,7 +82,28 @@ def edge_boundary(G, nbunch1, nbunch2=None, data=False, keys=False, default</span>
<span class="w"> </span>    the interest of speed and generality, that is not required here.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nset1 = {n for n in nbunch1 if n in G}</span>
<span class="gi">+    # Here we create an iterator over edges incident to nodes in the set</span>
<span class="gi">+    # `nset1`. The `Graph.edges()` method does not provide a guarantee</span>
<span class="gi">+    # on the orientation of the edges, so our algorithm below must</span>
<span class="gi">+    # handle the case in which exactly one orientation, either (u, v) or</span>
<span class="gi">+    # (v, u), appears in this iterable.</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        edges = G.edges(nset1, data=data, keys=keys, default=default)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = G.edges(nset1, data=data, default=default)</span>
<span class="gi">+    # If `nbunch2` is not provided, then it is assumed to be the set</span>
<span class="gi">+    # complement of `nbunch1`. For the sake of efficiency, this is</span>
<span class="gi">+    # implemented by using the `not in` operator, instead of by creating</span>
<span class="gi">+    # an additional set and using the `in` operator.</span>
<span class="gi">+    if nbunch2 is None:</span>
<span class="gi">+        return (e for e in edges if (e[0] in nset1) ^ (e[1] in nset1))</span>
<span class="gi">+    nset2 = set(nbunch2)</span>
<span class="gi">+    return (</span>
<span class="gi">+        e</span>
<span class="gi">+        for e in edges</span>
<span class="gi">+        if (e[0] in nset1 and e[1] in nset2) or (e[1] in nset1 and e[0] in nset2)</span>
<span class="gi">+    )</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -136,4 +158,10 @@ def node_boundary(G, nbunch1, nbunch2=None):</span>
<span class="w"> </span>    the interest of speed and generality, that is not required here.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nset1 = {n for n in nbunch1 if n in G}</span>
<span class="gi">+    bdy = set(chain.from_iterable(G[v] for v in nset1)) - nset1</span>
<span class="gi">+    # If `nbunch2` is not specified, it is assumed to be the set</span>
<span class="gi">+    # complement of `nbunch1`.</span>
<span class="gi">+    if nbunch2 is not None:</span>
<span class="gi">+        bdy &amp;= set(nbunch2)</span>
<span class="gi">+    return bdy</span>
<span class="gh">diff --git a/networkx/algorithms/bridges.py b/networkx/algorithms/bridges.py</span>
<span class="gh">index fc5a86017..e076a256c 100644</span>
<span class="gd">--- a/networkx/algorithms/bridges.py</span>
<span class="gi">+++ b/networkx/algorithms/bridges.py</span>
<span class="gu">@@ -1,11 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Bridge-finding algorithms.&quot;&quot;&quot;
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;bridges&#39;, &#39;has_bridges&#39;, &#39;local_bridges&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;bridges&quot;, &quot;has_bridges&quot;, &quot;local_bridges&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def bridges(G, root=None):
<span class="w"> </span>    &quot;&quot;&quot;Generate all bridges in a graph.
<span class="gu">@@ -64,10 +66,21 @@ def bridges(G, root=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29#Bridge-Finding_with_Chain_Decompositions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    multigraph = G.is_multigraph()</span>
<span class="gi">+    H = nx.Graph(G) if multigraph else G</span>
<span class="gi">+    chains = nx.chain_decomposition(H, root=root)</span>
<span class="gi">+    chain_edges = set(chain.from_iterable(chains))</span>
<span class="gi">+    H_copy = H.copy()</span>
<span class="gi">+    if root is not None:</span>
<span class="gi">+        H = H.subgraph(nx.node_connected_component(H, root)).copy()</span>
<span class="gi">+    for u, v in H.edges():</span>
<span class="gi">+        if (u, v) not in chain_edges and (v, u) not in chain_edges:</span>
<span class="gi">+            if multigraph and len(G[u][v]) &gt; 1:</span>
<span class="gi">+                continue</span>
<span class="gi">+            yield u, v</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def has_bridges(G, root=None):
<span class="w"> </span>    &quot;&quot;&quot;Decide whether a graph has any bridges.
<span class="gu">@@ -119,12 +132,17 @@ def has_bridges(G, root=None):</span>
<span class="w"> </span>    graph and $m$ is the number of edges.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        next(bridges(G, root=root))</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        return True</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def local_bridges(G, with_span=True, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Iterate over local bridges of `G` optionally computing the span

<span class="gu">@@ -165,4 +183,23 @@ def local_bridges(G, with_span=True, weight=None):</span>
<span class="w"> </span>       &gt;&gt;&gt; (0, 8, 8) in set(nx.local_bridges(G))
<span class="w"> </span>       True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if with_span is not True:</span>
<span class="gi">+        for u, v in G.edges:</span>
<span class="gi">+            if not (set(G[u]) &amp; set(G[v])):</span>
<span class="gi">+                yield u, v</span>
<span class="gi">+    else:</span>
<span class="gi">+        wt = nx.weighted._weight_function(G, weight)</span>
<span class="gi">+        for u, v in G.edges:</span>
<span class="gi">+            if not (set(G[u]) &amp; set(G[v])):</span>
<span class="gi">+                enodes = {u, v}</span>
<span class="gi">+</span>
<span class="gi">+                def hide_edge(n, nbr, d):</span>
<span class="gi">+                    if n not in enodes or nbr not in enodes:</span>
<span class="gi">+                        return wt(n, nbr, d)</span>
<span class="gi">+                    return None</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    span = nx.shortest_path_length(G, u, v, weight=hide_edge)</span>
<span class="gi">+                    yield u, v, span</span>
<span class="gi">+                except nx.NetworkXNoPath:</span>
<span class="gi">+                    yield u, v, float(&quot;inf&quot;)</span>
<span class="gh">diff --git a/networkx/algorithms/broadcasting.py b/networkx/algorithms/broadcasting.py</span>
<span class="gh">index f3f193aec..9b362a0e1 100644</span>
<span class="gd">--- a/networkx/algorithms/broadcasting.py</span>
<span class="gi">+++ b/networkx/algorithms/broadcasting.py</span>
<span class="gu">@@ -11,14 +11,30 @@ following constraints:</span>
<span class="w"> </span>- A node can only participate in one call per unit of time.
<span class="w"> </span>- Each call only involves two adjacent nodes: a sender and a receiver.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx import NetworkXError
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;tree_broadcast_center&#39;, &#39;tree_broadcast_time&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;tree_broadcast_center&quot;,</span>
<span class="gi">+    &quot;tree_broadcast_time&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_max_broadcast_value(G, U, v, values):</span>
<span class="gi">+    adj = sorted(set(G.neighbors(v)) &amp; U, key=values.get, reverse=True)</span>
<span class="gi">+    return max(values[u] + i for i, u in enumerate(adj, start=1))</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+def _get_broadcast_centers(G, v, values, target):</span>
<span class="gi">+    adj = sorted(G.neighbors(v), key=values.get, reverse=True)</span>
<span class="gi">+    j = next(i for i, u in enumerate(adj, start=1) if values[u] + i == target)</span>
<span class="gi">+    return set([v] + adj[:j])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def tree_broadcast_center(G):
<span class="w"> </span>    &quot;&quot;&quot;Return the Broadcast Center of the tree `G`.
<span class="gu">@@ -48,11 +64,50 @@ def tree_broadcast_center(G):</span>
<span class="w"> </span>    .. [1] Slater, P.J., Cockayne, E.J., Hedetniemi, S.T,
<span class="w"> </span>       Information dissemination in trees. SIAM J.Comput. 10(4), 692–701 (1981)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    # Assert that the graph G is a tree</span>
<span class="gi">+    if not nx.is_tree(G):</span>
<span class="gi">+        NetworkXError(&quot;Input graph is not a tree&quot;)</span>
<span class="gi">+    # step 0</span>
<span class="gi">+    if G.number_of_nodes() == 2:</span>
<span class="gi">+        return 1, set(G.nodes())</span>
<span class="gi">+    if G.number_of_nodes() == 1:</span>
<span class="gi">+        return 0, set(G.nodes())</span>
<span class="gi">+</span>
<span class="gi">+    # step 1</span>
<span class="gi">+    U = {node for node, deg in G.degree if deg == 1}</span>
<span class="gi">+    values = {n: 0 for n in U}</span>
<span class="gi">+    T = G.copy()</span>
<span class="gi">+    T.remove_nodes_from(U)</span>
<span class="gi">+</span>
<span class="gi">+    # step 2</span>
<span class="gi">+    W = {node for node, deg in T.degree if deg == 1}</span>
<span class="gi">+    values.update((w, G.degree[w] - 1) for w in W)</span>
<span class="gi">+</span>
<span class="gi">+    # step 3</span>
<span class="gi">+    while T.number_of_nodes() &gt;= 2:</span>
<span class="gi">+        # step 4</span>
<span class="gi">+        w = min(W, key=lambda n: values[n])</span>
<span class="gi">+        v = next(T.neighbors(w))</span>
<span class="gi">+</span>
<span class="gi">+        # step 5</span>
<span class="gi">+        U.add(w)</span>
<span class="gi">+        W.remove(w)</span>
<span class="gi">+        T.remove_node(w)</span>
<span class="gi">+</span>
<span class="gi">+        # step 6</span>
<span class="gi">+        if T.degree(v) == 1:</span>
<span class="gi">+            # update t(v)</span>
<span class="gi">+            values.update({v: _get_max_broadcast_value(G, U, v, values)})</span>
<span class="gi">+            W.add(v)</span>
<span class="gi">+</span>
<span class="gi">+    # step 7</span>
<span class="gi">+    v = nx.utils.arbitrary_element(T)</span>
<span class="gi">+    b_T = _get_max_broadcast_value(G, U, v, values)</span>
<span class="gi">+    return b_T, _get_broadcast_centers(G, v, values, b_T)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def tree_broadcast_time(G, node=None):
<span class="w"> </span>    &quot;&quot;&quot;Return the Broadcast Time of the tree `G`.
<span class="gu">@@ -89,4 +144,12 @@ def tree_broadcast_time(G, node=None):</span>
<span class="w"> </span>        In Computing and Combinatorics. COCOON 2019
<span class="w"> </span>        (Ed. D. Z. Du and C. Tian.) Springer, pp. 240-253, 2019.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    b_T, b_C = tree_broadcast_center(G)</span>
<span class="gi">+    if node is not None:</span>
<span class="gi">+        return b_T + min(nx.shortest_path_length(G, node, u) for u in b_C)</span>
<span class="gi">+    dist_from_center = dict.fromkeys(G, len(G))</span>
<span class="gi">+    for u in b_C:</span>
<span class="gi">+        for v, dist in nx.shortest_path_length(G, u).items():</span>
<span class="gi">+            if dist &lt; dist_from_center[v]:</span>
<span class="gi">+                dist_from_center[v] = dist</span>
<span class="gi">+    return b_T + max(dist_from_center.values())</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/betweenness.py b/networkx/algorithms/centrality/betweenness.py</span>
<span class="gh">index c1df7c3ee..4f44fb19b 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/betweenness.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/betweenness.py</span>
<span class="gu">@@ -2,31 +2,34 @@</span>
<span class="w"> </span>from collections import deque
<span class="w"> </span>from heapq import heappop, heappush
<span class="w"> </span>from itertools import count
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.shortest_paths.weighted import _weight_function
<span class="w"> </span>from networkx.utils import py_random_state
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;betweenness_centrality&#39;, &#39;edge_betweenness_centrality&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;betweenness_centrality&quot;, &quot;edge_betweenness_centrality&quot;]</span>


<span class="w"> </span>@py_random_state(5)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def betweenness_centrality(G, k=None, normalized=True, weight=None,</span>
<span class="gd">-    endpoints=False, seed=None):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the shortest-path betweenness centrality for nodes.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def betweenness_centrality(</span>
<span class="gi">+    G, k=None, normalized=True, weight=None, endpoints=False, seed=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the shortest-path betweenness centrality for nodes.</span>

<span class="w"> </span>    Betweenness centrality of a node $v$ is the sum of the
<span class="w"> </span>    fraction of all-pairs shortest paths that pass through $v$

<span class="w"> </span>    .. math::

<span class="gd">-       c_B(v) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}</span>
<span class="gi">+       c_B(v) =\sum_{s,t \in V} \frac{\sigma(s, t|v)}{\sigma(s, t)}</span>

<span class="gd">-    where $V$ is the set of nodes, $\\sigma(s, t)$ is the number of</span>
<span class="gd">-    shortest $(s, t)$-paths,  and $\\sigma(s, t|v)$ is the number of</span>
<span class="gi">+    where $V$ is the set of nodes, $\sigma(s, t)$ is the number of</span>
<span class="gi">+    shortest $(s, t)$-paths,  and $\sigma(s, t|v)$ is the number of</span>
<span class="w"> </span>    those paths  passing through some  node $v$ other than $s, t$.
<span class="gd">-    If $s = t$, $\\sigma(s, t) = 1$, and if $v \\in {s, t}$,</span>
<span class="gd">-    $\\sigma(s, t|v) = 0$ [2]_.</span>
<span class="gi">+    If $s = t$, $\sigma(s, t) = 1$, and if $v \in {s, t}$,</span>
<span class="gi">+    $\sigma(s, t|v) = 0$ [2]_.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -122,24 +125,48 @@ def betweenness_centrality(G, k=None, normalized=True, weight=None,</span>
<span class="w"> </span>       Sociometry 40: 35–41, 1977
<span class="w"> </span>       https://doi.org/10.2307/3033543
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    betweenness = dict.fromkeys(G, 0.0)  # b[v]=0 for v in G</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        nodes = G</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodes = seed.sample(list(G.nodes()), k)</span>
<span class="gi">+    for s in nodes:</span>
<span class="gi">+        # single source shortest paths</span>
<span class="gi">+        if weight is None:  # use BFS</span>
<span class="gi">+            S, P, sigma, _ = _single_source_shortest_path_basic(G, s)</span>
<span class="gi">+        else:  # use Dijkstra&#39;s algorithm</span>
<span class="gi">+            S, P, sigma, _ = _single_source_dijkstra_path_basic(G, s, weight)</span>
<span class="gi">+        # accumulation</span>
<span class="gi">+        if endpoints:</span>
<span class="gi">+            betweenness, _ = _accumulate_endpoints(betweenness, S, P, sigma, s)</span>
<span class="gi">+        else:</span>
<span class="gi">+            betweenness, _ = _accumulate_basic(betweenness, S, P, sigma, s)</span>
<span class="gi">+    # rescaling</span>
<span class="gi">+    betweenness = _rescale(</span>
<span class="gi">+        betweenness,</span>
<span class="gi">+        len(G),</span>
<span class="gi">+        normalized=normalized,</span>
<span class="gi">+        directed=G.is_directed(),</span>
<span class="gi">+        k=k,</span>
<span class="gi">+        endpoints=endpoints,</span>
<span class="gi">+    )</span>
<span class="gi">+    return betweenness</span>


<span class="w"> </span>@py_random_state(4)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def edge_betweenness_centrality(G, k=None, normalized=True, weight=None,</span>
<span class="gd">-    seed=None):</span>
<span class="gd">-    &quot;&quot;&quot;Compute betweenness centrality for edges.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def edge_betweenness_centrality(G, k=None, normalized=True, weight=None, seed=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute betweenness centrality for edges.</span>

<span class="w"> </span>    Betweenness centrality of an edge $e$ is the sum of the
<span class="w"> </span>    fraction of all-pairs shortest paths that pass through $e$

<span class="w"> </span>    .. math::

<span class="gd">-       c_B(e) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|e)}{\\sigma(s, t)}</span>
<span class="gi">+       c_B(e) =\sum_{s,t \in V} \frac{\sigma(s, t|e)}{\sigma(s, t)}</span>

<span class="gd">-    where $V$ is the set of nodes, $\\sigma(s, t)$ is the number of</span>
<span class="gd">-    shortest $(s, t)$-paths, and $\\sigma(s, t|e)$ is the number of</span>
<span class="gi">+    where $V$ is the set of nodes, $\sigma(s, t)$ is the number of</span>
<span class="gi">+    shortest $(s, t)$-paths, and $\sigma(s, t|e)$ is the number of</span>
<span class="w"> </span>    those paths passing through edge $e$ [2]_.

<span class="w"> </span>    Parameters
<span class="gu">@@ -196,12 +223,185 @@ def edge_betweenness_centrality(G, k=None, normalized=True, weight=None,</span>
<span class="w"> </span>       Social Networks 30(2):136-145, 2008.
<span class="w"> </span>       https://doi.org/10.1016/j.socnet.2007.11.001
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;graph&#39;)</span>
<span class="gi">+    betweenness = dict.fromkeys(G, 0.0)  # b[v]=0 for v in G</span>
<span class="gi">+    # b[e]=0 for e in G.edges()</span>
<span class="gi">+    betweenness.update(dict.fromkeys(G.edges(), 0.0))</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        nodes = G</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodes = seed.sample(list(G.nodes()), k)</span>
<span class="gi">+    for s in nodes:</span>
<span class="gi">+        # single source shortest paths</span>
<span class="gi">+        if weight is None:  # use BFS</span>
<span class="gi">+            S, P, sigma, _ = _single_source_shortest_path_basic(G, s)</span>
<span class="gi">+        else:  # use Dijkstra&#39;s algorithm</span>
<span class="gi">+            S, P, sigma, _ = _single_source_dijkstra_path_basic(G, s, weight)</span>
<span class="gi">+        # accumulation</span>
<span class="gi">+        betweenness = _accumulate_edges(betweenness, S, P, sigma, s)</span>
<span class="gi">+    # rescaling</span>
<span class="gi">+    for n in G:  # remove nodes to only return edges</span>
<span class="gi">+        del betweenness[n]</span>
<span class="gi">+    betweenness = _rescale_e(</span>
<span class="gi">+        betweenness, len(G), normalized=normalized, directed=G.is_directed()</span>
<span class="gi">+    )</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        betweenness = _add_edge_keys(G, betweenness, weight=weight)</span>
<span class="gi">+    return betweenness</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# helpers for betweenness centrality</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _single_source_shortest_path_basic(G, s):</span>
<span class="gi">+    S = []</span>
<span class="gi">+    P = {}</span>
<span class="gi">+    for v in G:</span>
<span class="gi">+        P[v] = []</span>
<span class="gi">+    sigma = dict.fromkeys(G, 0.0)  # sigma[v]=0 for v in G</span>
<span class="gi">+    D = {}</span>
<span class="gi">+    sigma[s] = 1.0</span>
<span class="gi">+    D[s] = 0</span>
<span class="gi">+    Q = deque([s])</span>
<span class="gi">+    while Q:  # use BFS to find shortest paths</span>
<span class="gi">+        v = Q.popleft()</span>
<span class="gi">+        S.append(v)</span>
<span class="gi">+        Dv = D[v]</span>
<span class="gi">+        sigmav = sigma[v]</span>
<span class="gi">+        for w in G[v]:</span>
<span class="gi">+            if w not in D:</span>
<span class="gi">+                Q.append(w)</span>
<span class="gi">+                D[w] = Dv + 1</span>
<span class="gi">+            if D[w] == Dv + 1:  # this is a shortest path, count paths</span>
<span class="gi">+                sigma[w] += sigmav</span>
<span class="gi">+                P[w].append(v)  # predecessors</span>
<span class="gi">+    return S, P, sigma, D</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _single_source_dijkstra_path_basic(G, s, weight):</span>
<span class="gi">+    weight = _weight_function(G, weight)</span>
<span class="gi">+    # modified from Eppstein</span>
<span class="gi">+    S = []</span>
<span class="gi">+    P = {}</span>
<span class="gi">+    for v in G:</span>
<span class="gi">+        P[v] = []</span>
<span class="gi">+    sigma = dict.fromkeys(G, 0.0)  # sigma[v]=0 for v in G</span>
<span class="gi">+    D = {}</span>
<span class="gi">+    sigma[s] = 1.0</span>
<span class="gi">+    push = heappush</span>
<span class="gi">+    pop = heappop</span>
<span class="gi">+    seen = {s: 0}</span>
<span class="gi">+    c = count()</span>
<span class="gi">+    Q = []  # use Q as heap with (distance,node id) tuples</span>
<span class="gi">+    push(Q, (0, next(c), s, s))</span>
<span class="gi">+    while Q:</span>
<span class="gi">+        (dist, _, pred, v) = pop(Q)</span>
<span class="gi">+        if v in D:</span>
<span class="gi">+            continue  # already searched this node.</span>
<span class="gi">+        sigma[v] += sigma[pred]  # count paths</span>
<span class="gi">+        S.append(v)</span>
<span class="gi">+        D[v] = dist</span>
<span class="gi">+        for w, edgedata in G[v].items():</span>
<span class="gi">+            vw_dist = dist + weight(v, w, edgedata)</span>
<span class="gi">+            if w not in D and (w not in seen or vw_dist &lt; seen[w]):</span>
<span class="gi">+                seen[w] = vw_dist</span>
<span class="gi">+                push(Q, (vw_dist, next(c), v, w))</span>
<span class="gi">+                sigma[w] = 0.0</span>
<span class="gi">+                P[w] = [v]</span>
<span class="gi">+            elif vw_dist == seen[w]:  # handle equal paths</span>
<span class="gi">+                sigma[w] += sigma[v]</span>
<span class="gi">+                P[w].append(v)</span>
<span class="gi">+    return S, P, sigma, D</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _accumulate_basic(betweenness, S, P, sigma, s):</span>
<span class="gi">+    delta = dict.fromkeys(S, 0)</span>
<span class="gi">+    while S:</span>
<span class="gi">+        w = S.pop()</span>
<span class="gi">+        coeff = (1 + delta[w]) / sigma[w]</span>
<span class="gi">+        for v in P[w]:</span>
<span class="gi">+            delta[v] += sigma[v] * coeff</span>
<span class="gi">+        if w != s:</span>
<span class="gi">+            betweenness[w] += delta[w]</span>
<span class="gi">+    return betweenness, delta</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _accumulate_endpoints(betweenness, S, P, sigma, s):</span>
<span class="gi">+    betweenness[s] += len(S) - 1</span>
<span class="gi">+    delta = dict.fromkeys(S, 0)</span>
<span class="gi">+    while S:</span>
<span class="gi">+        w = S.pop()</span>
<span class="gi">+        coeff = (1 + delta[w]) / sigma[w]</span>
<span class="gi">+        for v in P[w]:</span>
<span class="gi">+            delta[v] += sigma[v] * coeff</span>
<span class="gi">+        if w != s:</span>
<span class="gi">+            betweenness[w] += delta[w] + 1</span>
<span class="gi">+    return betweenness, delta</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _accumulate_edges(betweenness, S, P, sigma, s):</span>
<span class="gi">+    delta = dict.fromkeys(S, 0)</span>
<span class="gi">+    while S:</span>
<span class="gi">+        w = S.pop()</span>
<span class="gi">+        coeff = (1 + delta[w]) / sigma[w]</span>
<span class="gi">+        for v in P[w]:</span>
<span class="gi">+            c = sigma[v] * coeff</span>
<span class="gi">+            if (v, w) not in betweenness:</span>
<span class="gi">+                betweenness[(w, v)] += c</span>
<span class="gi">+            else:</span>
<span class="gi">+                betweenness[(v, w)] += c</span>
<span class="gi">+            delta[v] += c</span>
<span class="gi">+        if w != s:</span>
<span class="gi">+            betweenness[w] += delta[w]</span>
<span class="gi">+    return betweenness</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _rescale(betweenness, n, normalized, directed=False, k=None, endpoints=False):</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        if endpoints:</span>
<span class="gi">+            if n &lt; 2:</span>
<span class="gi">+                scale = None  # no normalization</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Scale factor should include endpoint nodes</span>
<span class="gi">+                scale = 1 / (n * (n - 1))</span>
<span class="gi">+        elif n &lt;= 2:</span>
<span class="gi">+            scale = None  # no normalization b=0 for all nodes</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale = 1 / ((n - 1) * (n - 2))</span>
<span class="gi">+    else:  # rescale by 2 for undirected graphs</span>
<span class="gi">+        if not directed:</span>
<span class="gi">+            scale = 0.5</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale = None</span>
<span class="gi">+    if scale is not None:</span>
<span class="gi">+        if k is not None:</span>
<span class="gi">+            scale = scale * n / k</span>
<span class="gi">+        for v in betweenness:</span>
<span class="gi">+            betweenness[v] *= scale</span>
<span class="gi">+    return betweenness</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _rescale_e(betweenness, n, normalized, directed=False, k=None):</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        if n &lt;= 1:</span>
<span class="gi">+            scale = None  # no normalization b=0 for all nodes</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale = 1 / (n * (n - 1))</span>
<span class="gi">+    else:  # rescale by 2 for undirected graphs</span>
<span class="gi">+        if not directed:</span>
<span class="gi">+            scale = 0.5</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale = None</span>
<span class="gi">+    if scale is not None:</span>
<span class="gi">+        if k is not None:</span>
<span class="gi">+            scale = scale * n / k</span>
<span class="gi">+        for v in betweenness:</span>
<span class="gi">+            betweenness[v] *= scale</span>
<span class="gi">+    return betweenness</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;graph&quot;)</span>
<span class="w"> </span>def _add_edge_keys(G, betweenness, weight=None):
<span class="gd">-    &quot;&quot;&quot;Adds the corrected betweenness centrality (BC) values for multigraphs.</span>
<span class="gi">+    r&quot;&quot;&quot;Adds the corrected betweenness centrality (BC) values for multigraphs.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -221,4 +421,15 @@ def _add_edge_keys(G, betweenness, weight=None):</span>

<span class="w"> </span>    The BC value is divided among edges of equal weight.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _weight = _weight_function(G, weight)</span>
<span class="gi">+</span>
<span class="gi">+    edge_bc = dict.fromkeys(G.edges, 0.0)</span>
<span class="gi">+    for u, v in betweenness:</span>
<span class="gi">+        d = G[u][v]</span>
<span class="gi">+        wt = _weight(u, v, d)</span>
<span class="gi">+        keys = [k for k in d if _weight(u, v, {k: d[k]}) == wt]</span>
<span class="gi">+        bc = betweenness[(u, v)] / len(keys)</span>
<span class="gi">+        for k in keys:</span>
<span class="gi">+            edge_bc[(u, v, k)] = bc</span>
<span class="gi">+</span>
<span class="gi">+    return edge_bc</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/betweenness_subset.py b/networkx/algorithms/centrality/betweenness_subset.py</span>
<span class="gh">index 8dd1c6b3e..7f9967e96 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/betweenness_subset.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/betweenness_subset.py</span>
<span class="gu">@@ -1,27 +1,35 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Betweenness centrality measures for subsets of nodes.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.algorithms.centrality.betweenness import _add_edge_keys</span>
<span class="gd">-from networkx.algorithms.centrality.betweenness import _single_source_dijkstra_path_basic as dijkstra</span>
<span class="gd">-from networkx.algorithms.centrality.betweenness import _single_source_shortest_path_basic as shortest_path</span>
<span class="gd">-__all__ = [&#39;betweenness_centrality_subset&#39;,</span>
<span class="gd">-    &#39;edge_betweenness_centrality_subset&#39;]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def betweenness_centrality_subset(G, sources, targets, normalized=False,</span>
<span class="gd">-    weight=None):</span>
<span class="gd">-    &quot;&quot;&quot;Compute betweenness centrality for a subset of nodes.</span>
<span class="gi">+from networkx.algorithms.centrality.betweenness import (</span>
<span class="gi">+    _add_edge_keys,</span>
<span class="gi">+)</span>
<span class="gi">+from networkx.algorithms.centrality.betweenness import (</span>
<span class="gi">+    _single_source_dijkstra_path_basic as dijkstra,</span>
<span class="gi">+)</span>
<span class="gi">+from networkx.algorithms.centrality.betweenness import (</span>
<span class="gi">+    _single_source_shortest_path_basic as shortest_path,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;betweenness_centrality_subset&quot;,</span>
<span class="gi">+    &quot;edge_betweenness_centrality_subset&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def betweenness_centrality_subset(G, sources, targets, normalized=False, weight=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute betweenness centrality for a subset of nodes.</span>

<span class="w"> </span>    .. math::

<span class="gd">-       c_B(v) =\\sum_{s\\in S, t \\in T} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}</span>
<span class="gi">+       c_B(v) =\sum_{s\in S, t \in T} \frac{\sigma(s, t|v)}{\sigma(s, t)}</span>

<span class="w"> </span>    where $S$ is the set of sources, $T$ is the set of targets,
<span class="gd">-    $\\sigma(s, t)$ is the number of shortest $(s, t)$-paths,</span>
<span class="gd">-    and $\\sigma(s, t|v)$ is the number of those paths</span>
<span class="gi">+    $\sigma(s, t)$ is the number of shortest $(s, t)$-paths,</span>
<span class="gi">+    and $\sigma(s, t|v)$ is the number of those paths</span>
<span class="w"> </span>    passing through some  node $v$ other than $s, t$.
<span class="gd">-    If $s = t$, $\\sigma(s, t) = 1$,</span>
<span class="gd">-    and if $v \\in {s, t}$, $\\sigma(s, t|v) = 0$ [2]_.</span>
<span class="gi">+    If $s = t$, $\sigma(s, t) = 1$,</span>
<span class="gi">+    and if $v \in {s, t}$, $\sigma(s, t|v) = 0$ [2]_.</span>


<span class="w"> </span>    Parameters
<span class="gu">@@ -94,21 +102,31 @@ def betweenness_centrality_subset(G, sources, targets, normalized=False,</span>
<span class="w"> </span>       Social Networks 30(2):136-145, 2008.
<span class="w"> </span>       https://doi.org/10.1016/j.socnet.2007.11.001
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def edge_betweenness_centrality_subset(G, sources, targets, normalized=</span>
<span class="gd">-    False, weight=None):</span>
<span class="gd">-    &quot;&quot;&quot;Compute betweenness centrality for edges for a subset of nodes.</span>
<span class="gi">+    b = dict.fromkeys(G, 0.0)  # b[v]=0 for v in G</span>
<span class="gi">+    for s in sources:</span>
<span class="gi">+        # single source shortest paths</span>
<span class="gi">+        if weight is None:  # use BFS</span>
<span class="gi">+            S, P, sigma, _ = shortest_path(G, s)</span>
<span class="gi">+        else:  # use Dijkstra&#39;s algorithm</span>
<span class="gi">+            S, P, sigma, _ = dijkstra(G, s, weight)</span>
<span class="gi">+        b = _accumulate_subset(b, S, P, sigma, s, targets)</span>
<span class="gi">+    b = _rescale(b, len(G), normalized=normalized, directed=G.is_directed())</span>
<span class="gi">+    return b</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def edge_betweenness_centrality_subset(</span>
<span class="gi">+    G, sources, targets, normalized=False, weight=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute betweenness centrality for edges for a subset of nodes.</span>

<span class="w"> </span>    .. math::

<span class="gd">-       c_B(v) =\\sum_{s\\in S,t \\in T} \\frac{\\sigma(s, t|e)}{\\sigma(s, t)}</span>
<span class="gi">+       c_B(v) =\sum_{s\in S,t \in T} \frac{\sigma(s, t|e)}{\sigma(s, t)}</span>

<span class="w"> </span>    where $S$ is the set of sources, $T$ is the set of targets,
<span class="gd">-    $\\sigma(s, t)$ is the number of shortest $(s, t)$-paths,</span>
<span class="gd">-    and $\\sigma(s, t|e)$ is the number of those paths</span>
<span class="gi">+    $\sigma(s, t)$ is the number of shortest $(s, t)$-paths,</span>
<span class="gi">+    and $\sigma(s, t|e)$ is the number of those paths</span>
<span class="w"> </span>    passing through edge $e$ [2]_.

<span class="w"> </span>    Parameters
<span class="gu">@@ -166,19 +184,91 @@ def edge_betweenness_centrality_subset(G, sources, targets, normalized=</span>
<span class="w"> </span>       Social Networks 30(2):136-145, 2008.
<span class="w"> </span>       https://doi.org/10.1016/j.socnet.2007.11.001
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    b = dict.fromkeys(G, 0.0)  # b[v]=0 for v in G</span>
<span class="gi">+    b.update(dict.fromkeys(G.edges(), 0.0))  # b[e] for e in G.edges()</span>
<span class="gi">+    for s in sources:</span>
<span class="gi">+        # single source shortest paths</span>
<span class="gi">+        if weight is None:  # use BFS</span>
<span class="gi">+            S, P, sigma, _ = shortest_path(G, s)</span>
<span class="gi">+        else:  # use Dijkstra&#39;s algorithm</span>
<span class="gi">+            S, P, sigma, _ = dijkstra(G, s, weight)</span>
<span class="gi">+        b = _accumulate_edges_subset(b, S, P, sigma, s, targets)</span>
<span class="gi">+    for n in G:  # remove nodes to only return edges</span>
<span class="gi">+        del b[n]</span>
<span class="gi">+    b = _rescale_e(b, len(G), normalized=normalized, directed=G.is_directed())</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        b = _add_edge_keys(G, b, weight=weight)</span>
<span class="gi">+    return b</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _accumulate_subset(betweenness, S, P, sigma, s, targets):</span>
<span class="gi">+    delta = dict.fromkeys(S, 0.0)</span>
<span class="gi">+    target_set = set(targets) - {s}</span>
<span class="gi">+    while S:</span>
<span class="gi">+        w = S.pop()</span>
<span class="gi">+        if w in target_set:</span>
<span class="gi">+            coeff = (delta[w] + 1.0) / sigma[w]</span>
<span class="gi">+        else:</span>
<span class="gi">+            coeff = delta[w] / sigma[w]</span>
<span class="gi">+        for v in P[w]:</span>
<span class="gi">+            delta[v] += sigma[v] * coeff</span>
<span class="gi">+        if w != s:</span>
<span class="gi">+            betweenness[w] += delta[w]</span>
<span class="gi">+    return betweenness</span>


<span class="w"> </span>def _accumulate_edges_subset(betweenness, S, P, sigma, s, targets):
<span class="w"> </span>    &quot;&quot;&quot;edge_betweenness_centrality_subset helper.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    delta = dict.fromkeys(S, 0)</span>
<span class="gi">+    target_set = set(targets)</span>
<span class="gi">+    while S:</span>
<span class="gi">+        w = S.pop()</span>
<span class="gi">+        for v in P[w]:</span>
<span class="gi">+            if w in target_set:</span>
<span class="gi">+                c = (sigma[v] / sigma[w]) * (1.0 + delta[w])</span>
<span class="gi">+            else:</span>
<span class="gi">+                c = delta[w] / len(P[w])</span>
<span class="gi">+            if (v, w) not in betweenness:</span>
<span class="gi">+                betweenness[(w, v)] += c</span>
<span class="gi">+            else:</span>
<span class="gi">+                betweenness[(v, w)] += c</span>
<span class="gi">+            delta[v] += c</span>
<span class="gi">+        if w != s:</span>
<span class="gi">+            betweenness[w] += delta[w]</span>
<span class="gi">+    return betweenness</span>


<span class="w"> </span>def _rescale(betweenness, n, normalized, directed=False):
<span class="w"> </span>    &quot;&quot;&quot;betweenness_centrality_subset helper.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        if n &lt;= 2:</span>
<span class="gi">+            scale = None  # no normalization b=0 for all nodes</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale = 1.0 / ((n - 1) * (n - 2))</span>
<span class="gi">+    else:  # rescale by 2 for undirected graphs</span>
<span class="gi">+        if not directed:</span>
<span class="gi">+            scale = 0.5</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale = None</span>
<span class="gi">+    if scale is not None:</span>
<span class="gi">+        for v in betweenness:</span>
<span class="gi">+            betweenness[v] *= scale</span>
<span class="gi">+    return betweenness</span>


<span class="w"> </span>def _rescale_e(betweenness, n, normalized, directed=False):
<span class="w"> </span>    &quot;&quot;&quot;edge_betweenness_centrality_subset helper.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        if n &lt;= 1:</span>
<span class="gi">+            scale = None  # no normalization b=0 for all nodes</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale = 1.0 / (n * (n - 1))</span>
<span class="gi">+    else:  # rescale by 2 for undirected graphs</span>
<span class="gi">+        if not directed:</span>
<span class="gi">+            scale = 0.5</span>
<span class="gi">+        else:</span>
<span class="gi">+            scale = None</span>
<span class="gi">+    if scale is not None:</span>
<span class="gi">+        for v in betweenness:</span>
<span class="gi">+            betweenness[v] *= scale</span>
<span class="gi">+    return betweenness</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/closeness.py b/networkx/algorithms/centrality/closeness.py</span>
<span class="gh">index fa551c90c..1c1722d4e 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/closeness.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/closeness.py</span>
<span class="gu">@@ -2,22 +2,24 @@</span>
<span class="w"> </span>Closeness centrality measures.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import functools
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;closeness_centrality&#39;, &#39;incremental_closeness_centrality&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;closeness_centrality&quot;, &quot;incremental_closeness_centrality&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;distance&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;distance&quot;)</span>
<span class="w"> </span>def closeness_centrality(G, u=None, distance=None, wf_improved=True):
<span class="gd">-    &quot;&quot;&quot;Compute closeness centrality for nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute closeness centrality for nodes.</span>

<span class="w"> </span>    Closeness centrality [1]_ of a node `u` is the reciprocal of the
<span class="w"> </span>    average shortest path distance to `u` over all `n-1` reachable nodes.

<span class="w"> </span>    .. math::

<span class="gd">-        C(u) = \\frac{n - 1}{\\sum_{v=1}^{n-1} d(v, u)},</span>
<span class="gi">+        C(u) = \frac{n - 1}{\sum_{v=1}^{n-1} d(v, u)},</span>

<span class="w"> </span>    where `d(v, u)` is the shortest-path distance between `v` and `u`,
<span class="w"> </span>    and `n-1` is the number of nodes reachable from `u`. Notice that the
<span class="gu">@@ -36,7 +38,7 @@ def closeness_centrality(G, u=None, distance=None, wf_improved=True):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        C_{WF}(u) = \\frac{n-1}{N-1} \\frac{n - 1}{\\sum_{v=1}^{n-1} d(v, u)},</span>
<span class="gi">+        C_{WF}(u) = \frac{n-1}{N-1} \frac{n - 1}{\sum_{v=1}^{n-1} d(v, u)},</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -101,14 +103,45 @@ def closeness_centrality(G, u=None, distance=None, wf_improved=True):</span>
<span class="w"> </span>       Social Network Analysis: Methods and Applications, 1994,
<span class="w"> </span>       Cambridge University Press.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        G = G.reverse()  # create a reversed graph view</span>
<span class="gi">+</span>
<span class="gi">+    if distance is not None:</span>
<span class="gi">+        # use Dijkstra&#39;s algorithm with specified attribute as edge weight</span>
<span class="gi">+        path_length = functools.partial(</span>
<span class="gi">+            nx.single_source_dijkstra_path_length, weight=distance</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        path_length = nx.single_source_shortest_path_length</span>
<span class="gi">+</span>
<span class="gi">+    if u is None:</span>
<span class="gi">+        nodes = G.nodes</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodes = [u]</span>
<span class="gi">+    closeness_dict = {}</span>
<span class="gi">+    for n in nodes:</span>
<span class="gi">+        sp = path_length(G, n)</span>
<span class="gi">+        totsp = sum(sp.values())</span>
<span class="gi">+        len_G = len(G)</span>
<span class="gi">+        _closeness_centrality = 0.0</span>
<span class="gi">+        if totsp &gt; 0.0 and len_G &gt; 1:</span>
<span class="gi">+            _closeness_centrality = (len(sp) - 1.0) / totsp</span>
<span class="gi">+            # normalize to number of nodes-1 in connected part</span>
<span class="gi">+            if wf_improved:</span>
<span class="gi">+                s = (len(sp) - 1.0) / (len_G - 1)</span>
<span class="gi">+                _closeness_centrality *= s</span>
<span class="gi">+        closeness_dict[n] = _closeness_centrality</span>
<span class="gi">+    if u is not None:</span>
<span class="gi">+        return closeness_dict[u]</span>
<span class="gi">+    return closeness_dict</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(mutates_input=True)
<span class="gd">-def incremental_closeness_centrality(G, edge, prev_cc=None, insertion=True,</span>
<span class="gd">-    wf_improved=True):</span>
<span class="gd">-    &quot;&quot;&quot;Incremental closeness centrality for nodes.</span>
<span class="gi">+def incremental_closeness_centrality(</span>
<span class="gi">+    G, edge, prev_cc=None, insertion=True, wf_improved=True</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Incremental closeness centrality for nodes.</span>

<span class="w"> </span>    Compute closeness centrality for nodes using level-based work filtering
<span class="w"> </span>    as described in Incremental Algorithms for Closeness Centrality by Sariyuce et al.
<span class="gu">@@ -120,8 +153,8 @@ def incremental_closeness_centrality(G, edge, prev_cc=None, insertion=True,</span>
<span class="w"> </span>    From &quot;Incremental Algorithms for Closeness Centrality&quot;:

<span class="w"> </span>    Theorem 1: Let :math:`G = (V, E)` be a graph and u and v be two vertices in V
<span class="gd">-    such that there is no edge (u, v) in E. Let :math:`G&#39; = (V, E \\cup uv)`</span>
<span class="gd">-    Then :math:`cc[s] = cc&#39;[s]` if and only if :math:`\\left|dG(s, u) - dG(s, v)\\right| \\leq 1`.</span>
<span class="gi">+    such that there is no edge (u, v) in E. Let :math:`G&#39; = (V, E \cup uv)`</span>
<span class="gi">+    Then :math:`cc[s] = cc&#39;[s]` if and only if :math:`\left|dG(s, u) - dG(s, v)\right| \leq 1`.</span>

<span class="w"> </span>    Where :math:`dG(u, v)` denotes the length of the shortest path between
<span class="w"> </span>    two vertices u, v in a graph G, cc[s] is the closeness centrality for a
<span class="gu">@@ -134,7 +167,7 @@ def incremental_closeness_centrality(G, edge, prev_cc=None, insertion=True,</span>
<span class="w"> </span>    other nodes to u and to v before the node is added. When removing an edge,
<span class="w"> </span>    we compute the shortest path lengths after the edge is removed. Then we
<span class="w"> </span>    apply Theorem 1 to use previously computed closeness centrality for nodes
<span class="gd">-    where :math:`\\left|dG(s, u) - dG(s, v)\\right| \\leq 1`. This works only for</span>
<span class="gi">+    where :math:`\left|dG(s, u) - dG(s, v)\right| \leq 1`. This works only for</span>
<span class="w"> </span>    undirected, unweighted graphs; the distance argument is not supported.

<span class="w"> </span>    Closeness centrality [1]_ of a node `u` is the reciprocal of the
<span class="gu">@@ -145,7 +178,7 @@ def incremental_closeness_centrality(G, edge, prev_cc=None, insertion=True,</span>

<span class="w"> </span>    .. math::

<span class="gd">-        C(u) = \\frac{n - 1}{\\sum_{v=1}^{n-1} d(v, u)},</span>
<span class="gi">+        C(u) = \frac{n - 1}{\sum_{v=1}^{n-1} d(v, u)},</span>

<span class="w"> </span>    where `d(v, u)` is the shortest-path distance between `v` and `u`,
<span class="w"> </span>    and `n` is the number of nodes in the graph.
<span class="gu">@@ -198,4 +231,51 @@ def incremental_closeness_centrality(G, edge, prev_cc=None, insertion=True,</span>
<span class="w"> </span>       Algorithms for Closeness Centrality. 2013 IEEE International Conference on Big Data
<span class="w"> </span>       http://sariyuce.com/papers/bigdata13.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if prev_cc is not None and set(prev_cc.keys()) != set(G.nodes()):</span>
<span class="gi">+        raise NetworkXError(&quot;prev_cc and G do not have the same nodes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Unpack edge</span>
<span class="gi">+    (u, v) = edge</span>
<span class="gi">+    path_length = nx.single_source_shortest_path_length</span>
<span class="gi">+</span>
<span class="gi">+    if insertion:</span>
<span class="gi">+        # For edge insertion, we want shortest paths before the edge is inserted</span>
<span class="gi">+        du = path_length(G, u)</span>
<span class="gi">+        dv = path_length(G, v)</span>
<span class="gi">+</span>
<span class="gi">+        G.add_edge(u, v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        G.remove_edge(u, v)</span>
<span class="gi">+</span>
<span class="gi">+        # For edge removal, we want shortest paths after the edge is removed</span>
<span class="gi">+        du = path_length(G, u)</span>
<span class="gi">+        dv = path_length(G, v)</span>
<span class="gi">+</span>
<span class="gi">+    if prev_cc is None:</span>
<span class="gi">+        return nx.closeness_centrality(G)</span>
<span class="gi">+</span>
<span class="gi">+    nodes = G.nodes()</span>
<span class="gi">+    closeness_dict = {}</span>
<span class="gi">+    for n in nodes:</span>
<span class="gi">+        if n in du and n in dv and abs(du[n] - dv[n]) &lt;= 1:</span>
<span class="gi">+            closeness_dict[n] = prev_cc[n]</span>
<span class="gi">+        else:</span>
<span class="gi">+            sp = path_length(G, n)</span>
<span class="gi">+            totsp = sum(sp.values())</span>
<span class="gi">+            len_G = len(G)</span>
<span class="gi">+            _closeness_centrality = 0.0</span>
<span class="gi">+            if totsp &gt; 0.0 and len_G &gt; 1:</span>
<span class="gi">+                _closeness_centrality = (len(sp) - 1.0) / totsp</span>
<span class="gi">+                # normalize to number of nodes-1 in connected part</span>
<span class="gi">+                if wf_improved:</span>
<span class="gi">+                    s = (len(sp) - 1.0) / (len_G - 1)</span>
<span class="gi">+                    _closeness_centrality *= s</span>
<span class="gi">+            closeness_dict[n] = _closeness_centrality</span>
<span class="gi">+</span>
<span class="gi">+    # Leave the graph as we found it</span>
<span class="gi">+    if insertion:</span>
<span class="gi">+        G.remove_edge(u, v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        G.add_edge(u, v)</span>
<span class="gi">+</span>
<span class="gi">+    return closeness_dict</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/current_flow_betweenness.py b/networkx/algorithms/centrality/current_flow_betweenness.py</span>
<span class="gh">index 017afd931..b79a4c801 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/current_flow_betweenness.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/current_flow_betweenness.py</span>
<span class="gu">@@ -1,19 +1,38 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Current-flow betweenness centrality measures.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.algorithms.centrality.flow_matrix import CGInverseLaplacian, FullInverseLaplacian, SuperLUInverseLaplacian, flow_matrix_row</span>
<span class="gd">-from networkx.utils import not_implemented_for, py_random_state, reverse_cuthill_mckee_ordering</span>
<span class="gd">-__all__ = [&#39;current_flow_betweenness_centrality&#39;,</span>
<span class="gd">-    &#39;approximate_current_flow_betweenness_centrality&#39;,</span>
<span class="gd">-    &#39;edge_current_flow_betweenness_centrality&#39;]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+from networkx.algorithms.centrality.flow_matrix import (</span>
<span class="gi">+    CGInverseLaplacian,</span>
<span class="gi">+    FullInverseLaplacian,</span>
<span class="gi">+    SuperLUInverseLaplacian,</span>
<span class="gi">+    flow_matrix_row,</span>
<span class="gi">+)</span>
<span class="gi">+from networkx.utils import (</span>
<span class="gi">+    not_implemented_for,</span>
<span class="gi">+    py_random_state,</span>
<span class="gi">+    reverse_cuthill_mckee_ordering,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;current_flow_betweenness_centrality&quot;,</span>
<span class="gi">+    &quot;approximate_current_flow_betweenness_centrality&quot;,</span>
<span class="gi">+    &quot;edge_current_flow_betweenness_centrality&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@py_random_state(7)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def approximate_current_flow_betweenness_centrality(G, normalized=True,</span>
<span class="gd">-    weight=None, dtype=float, solver=&#39;full&#39;, epsilon=0.5, kmax=10000, seed=None</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the approximate current-flow betweenness centrality for nodes.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def approximate_current_flow_betweenness_centrality(</span>
<span class="gi">+    G,</span>
<span class="gi">+    normalized=True,</span>
<span class="gi">+    weight=None,</span>
<span class="gi">+    dtype=float,</span>
<span class="gi">+    solver=&quot;full&quot;,</span>
<span class="gi">+    epsilon=0.5,</span>
<span class="gi">+    kmax=10000,</span>
<span class="gi">+    seed=None,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the approximate current-flow betweenness centrality for nodes.</span>

<span class="w"> </span>    Approximates the current-flow betweenness centrality within absolute
<span class="w"> </span>    error of epsilon with high probability [1]_.
<span class="gu">@@ -64,7 +83,7 @@ def approximate_current_flow_betweenness_centrality(G, normalized=True,</span>

<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="gd">-    The running time is $O((1/\\epsilon^2)m{\\sqrt k} \\log n)$</span>
<span class="gi">+    The running time is $O((1/\epsilon^2)m{\sqrt k} \log n)$</span>
<span class="w"> </span>    and the space required is $O(m)$ for $n$ nodes and $m$ edges.

<span class="w"> </span>    If the edges have a &#39;weight&#39; attribute they will be used as
<span class="gu">@@ -78,14 +97,58 @@ def approximate_current_flow_betweenness_centrality(G, normalized=True,</span>
<span class="w"> </span>       LNCS 3404, pp. 533-544. Springer-Verlag, 2005.
<span class="w"> </span>       https://doi.org/10.1007/978-3-540-31856-9_44
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def current_flow_betweenness_centrality(G, normalized=True, weight=None,</span>
<span class="gd">-    dtype=float, solver=&#39;full&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Compute current-flow betweenness centrality for nodes.</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph not connected.&quot;)</span>
<span class="gi">+    solvername = {</span>
<span class="gi">+        &quot;full&quot;: FullInverseLaplacian,</span>
<span class="gi">+        &quot;lu&quot;: SuperLUInverseLaplacian,</span>
<span class="gi">+        &quot;cg&quot;: CGInverseLaplacian,</span>
<span class="gi">+    }</span>
<span class="gi">+    n = G.number_of_nodes()</span>
<span class="gi">+    ordering = list(reverse_cuthill_mckee_ordering(G))</span>
<span class="gi">+    # make a copy with integer labels according to rcm ordering</span>
<span class="gi">+    # this could be done without a copy if we really wanted to</span>
<span class="gi">+    H = nx.relabel_nodes(G, dict(zip(ordering, range(n))))</span>
<span class="gi">+    L = nx.laplacian_matrix(H, nodelist=range(n), weight=weight).asformat(&quot;csc&quot;)</span>
<span class="gi">+    L = L.astype(dtype)</span>
<span class="gi">+    C = solvername[solver](L, dtype=dtype)  # initialize solver</span>
<span class="gi">+    betweenness = dict.fromkeys(H, 0.0)</span>
<span class="gi">+    nb = (n - 1.0) * (n - 2.0)  # normalization factor</span>
<span class="gi">+    cstar = n * (n - 1) / nb</span>
<span class="gi">+    l = 1  # parameter in approximation, adjustable</span>
<span class="gi">+    k = l * int(np.ceil((cstar / epsilon) ** 2 * np.log(n)))</span>
<span class="gi">+    if k &gt; kmax:</span>
<span class="gi">+        msg = f&quot;Number random pairs k&gt;kmax ({k}&gt;{kmax}) &quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg, &quot;Increase kmax or epsilon&quot;)</span>
<span class="gi">+    cstar2k = cstar / (2 * k)</span>
<span class="gi">+    for _ in range(k):</span>
<span class="gi">+        s, t = pair = seed.sample(range(n), 2)</span>
<span class="gi">+        b = np.zeros(n, dtype=dtype)</span>
<span class="gi">+        b[s] = 1</span>
<span class="gi">+        b[t] = -1</span>
<span class="gi">+        p = C.solve(b)</span>
<span class="gi">+        for v in H:</span>
<span class="gi">+            if v in pair:</span>
<span class="gi">+                continue</span>
<span class="gi">+            for nbr in H[v]:</span>
<span class="gi">+                w = H[v][nbr].get(weight, 1.0)</span>
<span class="gi">+                betweenness[v] += float(w * np.abs(p[v] - p[nbr]) * cstar2k)</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        factor = 1.0</span>
<span class="gi">+    else:</span>
<span class="gi">+        factor = nb / 2.0</span>
<span class="gi">+    # remap to original node names and &quot;unnormalize&quot; if required</span>
<span class="gi">+    return {ordering[k]: v * factor for k, v in betweenness.items()}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def current_flow_betweenness_centrality(</span>
<span class="gi">+    G, normalized=True, weight=None, dtype=float, solver=&quot;full&quot;</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute current-flow betweenness centrality for nodes.</span>

<span class="w"> </span>    Current-flow betweenness centrality uses an electrical current
<span class="w"> </span>    model for information spreading in contrast to betweenness
<span class="gu">@@ -132,10 +195,10 @@ def current_flow_betweenness_centrality(G, normalized=True, weight=None,</span>

<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="gd">-    Current-flow betweenness can be computed in  $O(I(n-1)+mn \\log n)$</span>
<span class="gi">+    Current-flow betweenness can be computed in  $O(I(n-1)+mn \log n)$</span>
<span class="w"> </span>    time [1]_, where $I(n-1)$ is the time needed to compute the
<span class="w"> </span>    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using
<span class="gd">-    sparse methods you can achieve $O(nm{\\sqrt k})$ where $k$ is the</span>
<span class="gi">+    sparse methods you can achieve $O(nm{\sqrt k})$ where $k$ is the</span>
<span class="w"> </span>    Laplacian matrix condition number.

<span class="w"> </span>    The space required is $O(nw)$ where $w$ is the width of the sparse
<span class="gu">@@ -155,14 +218,32 @@ def current_flow_betweenness_centrality(G, normalized=True, weight=None,</span>
<span class="w"> </span>    .. [2] A measure of betweenness centrality based on random walks,
<span class="w"> </span>       M. E. J. Newman, Social Networks 27, 39-54 (2005).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def edge_current_flow_betweenness_centrality(G, normalized=True, weight=</span>
<span class="gd">-    None, dtype=float, solver=&#39;full&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Compute current-flow betweenness centrality for edges.</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph not connected.&quot;)</span>
<span class="gi">+    N = G.number_of_nodes()</span>
<span class="gi">+    ordering = list(reverse_cuthill_mckee_ordering(G))</span>
<span class="gi">+    # make a copy with integer labels according to rcm ordering</span>
<span class="gi">+    # this could be done without a copy if we really wanted to</span>
<span class="gi">+    H = nx.relabel_nodes(G, dict(zip(ordering, range(N))))</span>
<span class="gi">+    betweenness = dict.fromkeys(H, 0.0)  # b[n]=0 for n in H</span>
<span class="gi">+    for row, (s, t) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):</span>
<span class="gi">+        pos = dict(zip(row.argsort()[::-1], range(N)))</span>
<span class="gi">+        for i in range(N):</span>
<span class="gi">+            betweenness[s] += (i - pos[i]) * row.item(i)</span>
<span class="gi">+            betweenness[t] += (N - i - 1 - pos[i]) * row.item(i)</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        nb = (N - 1.0) * (N - 2.0)  # normalization factor</span>
<span class="gi">+    else:</span>
<span class="gi">+        nb = 2.0</span>
<span class="gi">+    return {ordering[n]: (b - n) * 2.0 / nb for n, b in betweenness.items()}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def edge_current_flow_betweenness_centrality(</span>
<span class="gi">+    G, normalized=True, weight=None, dtype=float, solver=&quot;full&quot;</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute current-flow betweenness centrality for edges.</span>

<span class="w"> </span>    Current-flow betweenness centrality uses an electrical current
<span class="w"> </span>    model for information spreading in contrast to betweenness
<span class="gu">@@ -215,10 +296,10 @@ def edge_current_flow_betweenness_centrality(G, normalized=True, weight=</span>

<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="gd">-    Current-flow betweenness can be computed in $O(I(n-1)+mn \\log n)$</span>
<span class="gi">+    Current-flow betweenness can be computed in $O(I(n-1)+mn \log n)$</span>
<span class="w"> </span>    time [1]_, where $I(n-1)$ is the time needed to compute the
<span class="w"> </span>    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using
<span class="gd">-    sparse methods you can achieve $O(nm{\\sqrt k})$ where $k$ is the</span>
<span class="gi">+    sparse methods you can achieve $O(nm{\sqrt k})$ where $k$ is the</span>
<span class="w"> </span>    Laplacian matrix condition number.

<span class="w"> </span>    The space required is $O(nw)$ where $w$ is the width of the sparse
<span class="gu">@@ -238,4 +319,23 @@ def edge_current_flow_betweenness_centrality(G, normalized=True, weight=</span>
<span class="w"> </span>    .. [2] A measure of betweenness centrality based on random walks,
<span class="w"> </span>       M. E. J. Newman, Social Networks 27, 39-54 (2005).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph not connected.&quot;)</span>
<span class="gi">+    N = G.number_of_nodes()</span>
<span class="gi">+    ordering = list(reverse_cuthill_mckee_ordering(G))</span>
<span class="gi">+    # make a copy with integer labels according to rcm ordering</span>
<span class="gi">+    # this could be done without a copy if we really wanted to</span>
<span class="gi">+    H = nx.relabel_nodes(G, dict(zip(ordering, range(N))))</span>
<span class="gi">+    edges = (tuple(sorted((u, v))) for u, v in H.edges())</span>
<span class="gi">+    betweenness = dict.fromkeys(edges, 0.0)</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        nb = (N - 1.0) * (N - 2.0)  # normalization factor</span>
<span class="gi">+    else:</span>
<span class="gi">+        nb = 2.0</span>
<span class="gi">+    for row, (e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):</span>
<span class="gi">+        pos = dict(zip(row.argsort()[::-1], range(1, N + 1)))</span>
<span class="gi">+        for i in range(N):</span>
<span class="gi">+            betweenness[e] += (i + 1 - pos[i]) * row.item(i)</span>
<span class="gi">+            betweenness[e] += (N - i - pos[i]) * row.item(i)</span>
<span class="gi">+        betweenness[e] /= nb</span>
<span class="gi">+    return {(ordering[s], ordering[t]): b for (s, t), b in betweenness.items()}</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/current_flow_betweenness_subset.py b/networkx/algorithms/centrality/current_flow_betweenness_subset.py</span>
<span class="gh">index d52c70fb8..c6790b218 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/current_flow_betweenness_subset.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/current_flow_betweenness_subset.py</span>
<span class="gu">@@ -2,15 +2,19 @@</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.centrality.flow_matrix import flow_matrix_row
<span class="w"> </span>from networkx.utils import not_implemented_for, reverse_cuthill_mckee_ordering
<span class="gd">-__all__ = [&#39;current_flow_betweenness_centrality_subset&#39;,</span>
<span class="gd">-    &#39;edge_current_flow_betweenness_centrality_subset&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;current_flow_betweenness_centrality_subset&quot;,</span>
<span class="gi">+    &quot;edge_current_flow_betweenness_centrality_subset&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def current_flow_betweenness_centrality_subset(G, sources, targets,</span>
<span class="gd">-    normalized=True, weight=None, dtype=float, solver=&#39;lu&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Compute current-flow betweenness centrality for subsets of nodes.</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def current_flow_betweenness_centrality_subset(</span>
<span class="gi">+    G, sources, targets, normalized=True, weight=None, dtype=float, solver=&quot;lu&quot;</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute current-flow betweenness centrality for subsets of nodes.</span>

<span class="w"> </span>    Current-flow betweenness centrality uses an electrical current
<span class="w"> </span>    model for information spreading in contrast to betweenness
<span class="gu">@@ -63,10 +67,10 @@ def current_flow_betweenness_centrality_subset(G, sources, targets,</span>

<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="gd">-    Current-flow betweenness can be computed in $O(I(n-1)+mn \\log n)$</span>
<span class="gi">+    Current-flow betweenness can be computed in $O(I(n-1)+mn \log n)$</span>
<span class="w"> </span>    time [1]_, where $I(n-1)$ is the time needed to compute the
<span class="w"> </span>    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using
<span class="gd">-    sparse methods you can achieve $O(nm{\\sqrt k})$ where $k$ is the</span>
<span class="gi">+    sparse methods you can achieve $O(nm{\sqrt k})$ where $k$ is the</span>
<span class="w"> </span>    Laplacian matrix condition number.

<span class="w"> </span>    The space required is $O(nw)$ where $w$ is the width of the sparse
<span class="gu">@@ -86,14 +90,41 @@ def current_flow_betweenness_centrality_subset(G, sources, targets,</span>
<span class="w"> </span>    .. [2] A measure of betweenness centrality based on random walks,
<span class="w"> </span>       M. E. J. Newman, Social Networks 27, 39-54 (2005).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def edge_current_flow_betweenness_centrality_subset(G, sources, targets,</span>
<span class="gd">-    normalized=True, weight=None, dtype=float, solver=&#39;lu&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Compute current-flow betweenness centrality for edges using subsets</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    from networkx.utils import reverse_cuthill_mckee_ordering</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph not connected.&quot;)</span>
<span class="gi">+    N = G.number_of_nodes()</span>
<span class="gi">+    ordering = list(reverse_cuthill_mckee_ordering(G))</span>
<span class="gi">+    # make a copy with integer labels according to rcm ordering</span>
<span class="gi">+    # this could be done without a copy if we really wanted to</span>
<span class="gi">+    mapping = dict(zip(ordering, range(N)))</span>
<span class="gi">+    H = nx.relabel_nodes(G, mapping)</span>
<span class="gi">+    betweenness = dict.fromkeys(H, 0.0)  # b[n]=0 for n in H</span>
<span class="gi">+    for row, (s, t) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):</span>
<span class="gi">+        for ss in sources:</span>
<span class="gi">+            i = mapping[ss]</span>
<span class="gi">+            for tt in targets:</span>
<span class="gi">+                j = mapping[tt]</span>
<span class="gi">+                betweenness[s] += 0.5 * abs(row.item(i) - row.item(j))</span>
<span class="gi">+                betweenness[t] += 0.5 * abs(row.item(i) - row.item(j))</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        nb = (N - 1.0) * (N - 2.0)  # normalization factor</span>
<span class="gi">+    else:</span>
<span class="gi">+        nb = 2.0</span>
<span class="gi">+    for node in H:</span>
<span class="gi">+        betweenness[node] = betweenness[node] / nb + 1.0 / (2 - N)</span>
<span class="gi">+    return {ordering[node]: value for node, value in betweenness.items()}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def edge_current_flow_betweenness_centrality_subset(</span>
<span class="gi">+    G, sources, targets, normalized=True, weight=None, dtype=float, solver=&quot;lu&quot;</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute current-flow betweenness centrality for edges using subsets</span>
<span class="w"> </span>    of nodes.

<span class="w"> </span>    Current-flow betweenness centrality uses an electrical current
<span class="gu">@@ -146,10 +177,10 @@ def edge_current_flow_betweenness_centrality_subset(G, sources, targets,</span>

<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="gd">-    Current-flow betweenness can be computed in $O(I(n-1)+mn \\log n)$</span>
<span class="gi">+    Current-flow betweenness can be computed in $O(I(n-1)+mn \log n)$</span>
<span class="w"> </span>    time [1]_, where $I(n-1)$ is the time needed to compute the
<span class="w"> </span>    inverse Laplacian.  For a full matrix this is $O(n^3)$ but using
<span class="gd">-    sparse methods you can achieve $O(nm{\\sqrt k})$ where $k$ is the</span>
<span class="gi">+    sparse methods you can achieve $O(nm{\sqrt k})$ where $k$ is the</span>
<span class="w"> </span>    Laplacian matrix condition number.

<span class="w"> </span>    The space required is $O(nw)$ where $w$ is the width of the sparse
<span class="gu">@@ -169,4 +200,27 @@ def edge_current_flow_betweenness_centrality_subset(G, sources, targets,</span>
<span class="w"> </span>    .. [2] A measure of betweenness centrality based on random walks,
<span class="w"> </span>       M. E. J. Newman, Social Networks 27, 39-54 (2005).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph not connected.&quot;)</span>
<span class="gi">+    N = G.number_of_nodes()</span>
<span class="gi">+    ordering = list(reverse_cuthill_mckee_ordering(G))</span>
<span class="gi">+    # make a copy with integer labels according to rcm ordering</span>
<span class="gi">+    # this could be done without a copy if we really wanted to</span>
<span class="gi">+    mapping = dict(zip(ordering, range(N)))</span>
<span class="gi">+    H = nx.relabel_nodes(G, mapping)</span>
<span class="gi">+    edges = (tuple(sorted((u, v))) for u, v in H.edges())</span>
<span class="gi">+    betweenness = dict.fromkeys(edges, 0.0)</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        nb = (N - 1.0) * (N - 2.0)  # normalization factor</span>
<span class="gi">+    else:</span>
<span class="gi">+        nb = 2.0</span>
<span class="gi">+    for row, (e) in flow_matrix_row(H, weight=weight, dtype=dtype, solver=solver):</span>
<span class="gi">+        for ss in sources:</span>
<span class="gi">+            i = mapping[ss]</span>
<span class="gi">+            for tt in targets:</span>
<span class="gi">+                j = mapping[tt]</span>
<span class="gi">+                betweenness[e] += 0.5 * abs(row.item(i) - row.item(j))</span>
<span class="gi">+        betweenness[e] /= nb</span>
<span class="gi">+    return {(ordering[s], ordering[t]): value for (s, t), value in betweenness.items()}</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/current_flow_closeness.py b/networkx/algorithms/centrality/current_flow_closeness.py</span>
<span class="gh">index f6d4156d9..92c892f74 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/current_flow_closeness.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/current_flow_closeness.py</span>
<span class="gu">@@ -1,14 +1,18 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Current-flow closeness centrality measures.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.algorithms.centrality.flow_matrix import CGInverseLaplacian, FullInverseLaplacian, SuperLUInverseLaplacian</span>
<span class="gi">+from networkx.algorithms.centrality.flow_matrix import (</span>
<span class="gi">+    CGInverseLaplacian,</span>
<span class="gi">+    FullInverseLaplacian,</span>
<span class="gi">+    SuperLUInverseLaplacian,</span>
<span class="gi">+)</span>
<span class="w"> </span>from networkx.utils import not_implemented_for, reverse_cuthill_mckee_ordering
<span class="gd">-__all__ = [&#39;current_flow_closeness_centrality&#39;, &#39;information_centrality&#39;]</span>

<span class="gi">+__all__ = [&quot;current_flow_closeness_centrality&quot;, &quot;information_centrality&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def current_flow_closeness_centrality(G, weight=None, dtype=float, solver=&#39;lu&#39;</span>
<span class="gd">-    ):</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def current_flow_closeness_centrality(G, weight=None, dtype=float, solver=&quot;lu&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute current-flow closeness centrality for nodes.

<span class="w"> </span>    Current-flow closeness centrality is variant of closeness
<span class="gu">@@ -63,7 +67,29 @@ def current_flow_closeness_centrality(G, weight=None, dtype=float, solver=&#39;lu&#39;</span>
<span class="w"> </span>       Social Networks 11(1):1-37, 1989.
<span class="w"> </span>       https://doi.org/10.1016/0378-8733(89)90016-6
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph not connected.&quot;)</span>
<span class="gi">+    solvername = {</span>
<span class="gi">+        &quot;full&quot;: FullInverseLaplacian,</span>
<span class="gi">+        &quot;lu&quot;: SuperLUInverseLaplacian,</span>
<span class="gi">+        &quot;cg&quot;: CGInverseLaplacian,</span>
<span class="gi">+    }</span>
<span class="gi">+    N = G.number_of_nodes()</span>
<span class="gi">+    ordering = list(reverse_cuthill_mckee_ordering(G))</span>
<span class="gi">+    # make a copy with integer labels according to rcm ordering</span>
<span class="gi">+    # this could be done without a copy if we really wanted to</span>
<span class="gi">+    H = nx.relabel_nodes(G, dict(zip(ordering, range(N))))</span>
<span class="gi">+    betweenness = dict.fromkeys(H, 0.0)  # b[n]=0 for n in H</span>
<span class="gi">+    N = H.number_of_nodes()</span>
<span class="gi">+    L = nx.laplacian_matrix(H, nodelist=range(N), weight=weight).asformat(&quot;csc&quot;)</span>
<span class="gi">+    L = L.astype(dtype)</span>
<span class="gi">+    C2 = solvername[solver](L, width=1, dtype=dtype)  # initialize solver</span>
<span class="gi">+    for v in H:</span>
<span class="gi">+        col = C2.get_row(v)</span>
<span class="gi">+        for w in H:</span>
<span class="gi">+            betweenness[v] += col.item(v) - 2 * col.item(w)</span>
<span class="gi">+            betweenness[w] += col.item(v)</span>
<span class="gi">+    return {ordering[node]: 1 / value for node, value in betweenness.items()}</span>


<span class="w"> </span>information_centrality = current_flow_closeness_centrality
<span class="gh">diff --git a/networkx/algorithms/centrality/degree_alg.py b/networkx/algorithms/centrality/degree_alg.py</span>
<span class="gh">index 9bb653827..ea53f41ea 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/degree_alg.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/degree_alg.py</span>
<span class="gu">@@ -1,8 +1,8 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Degree centrality measures.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;degree_centrality&#39;, &#39;in_degree_centrality&#39;, &#39;out_degree_centrality&#39;</span>
<span class="gd">-    ]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;degree_centrality&quot;, &quot;in_degree_centrality&quot;, &quot;out_degree_centrality&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -41,10 +41,15 @@ def degree_centrality(G):</span>
<span class="w"> </span>    be higher than n-1 and values of degree centrality greater than 1
<span class="w"> </span>    are possible.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) &lt;= 1:</span>
<span class="gi">+        return {n: 1 for n in G}</span>
<span class="gi">+</span>
<span class="gi">+    s = 1.0 / (len(G) - 1.0)</span>
<span class="gi">+    centrality = {n: d * s for n, d in G.degree()}</span>
<span class="gi">+    return centrality</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def in_degree_centrality(G):
<span class="w"> </span>    &quot;&quot;&quot;Compute the in-degree centrality for nodes.
<span class="gu">@@ -86,10 +91,15 @@ def in_degree_centrality(G):</span>
<span class="w"> </span>    be higher than n-1 and values of degree centrality greater than 1
<span class="w"> </span>    are possible.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) &lt;= 1:</span>
<span class="gi">+        return {n: 1 for n in G}</span>

<span class="gi">+    s = 1.0 / (len(G) - 1.0)</span>
<span class="gi">+    centrality = {n: d * s for n, d in G.in_degree()}</span>
<span class="gi">+    return centrality</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def out_degree_centrality(G):
<span class="w"> </span>    &quot;&quot;&quot;Compute the out-degree centrality for nodes.
<span class="gu">@@ -131,4 +141,9 @@ def out_degree_centrality(G):</span>
<span class="w"> </span>    be higher than n-1 and values of degree centrality greater than 1
<span class="w"> </span>    are possible.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) &lt;= 1:</span>
<span class="gi">+        return {n: 1 for n in G}</span>
<span class="gi">+</span>
<span class="gi">+    s = 1.0 / (len(G) - 1.0)</span>
<span class="gi">+    centrality = {n: d * s for n, d in G.out_degree()}</span>
<span class="gi">+    return centrality</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/dispersion.py b/networkx/algorithms/centrality/dispersion.py</span>
<span class="gh">index 941a49e83..a3fa68583 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/dispersion.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/dispersion.py</span>
<span class="gu">@@ -1,11 +1,13 @@</span>
<span class="w"> </span>from itertools import combinations
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;dispersion&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;dispersion&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def dispersion(G, u=None, v=None, normalized=True, alpha=1.0, b=0.0, c=0.0):
<span class="gd">-    &quot;&quot;&quot;Calculate dispersion between `u` and `v` in `G`.</span>
<span class="gi">+    r&quot;&quot;&quot;Calculate dispersion between `u` and `v` in `G`.</span>

<span class="w"> </span>    A link between two actors (`u` and `v`) has a high dispersion when their
<span class="w"> </span>    mutual ties (`s` and `t`) are not well connected with each other.
<span class="gu">@@ -51,4 +53,55 @@ def dispersion(G, u=None, v=None, normalized=True, alpha=1.0, b=0.0, c=0.0):</span>
<span class="w"> </span>        https://arxiv.org/pdf/1310.6753v1.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _dispersion(G_u, u, v):</span>
<span class="gi">+        &quot;&quot;&quot;dispersion for all nodes &#39;v&#39; in a ego network G_u of node &#39;u&#39;&quot;&quot;&quot;</span>
<span class="gi">+        u_nbrs = set(G_u[u])</span>
<span class="gi">+        ST = {n for n in G_u[v] if n in u_nbrs}</span>
<span class="gi">+        set_uv = {u, v}</span>
<span class="gi">+        # all possible ties of connections that u and b share</span>
<span class="gi">+        possib = combinations(ST, 2)</span>
<span class="gi">+        total = 0</span>
<span class="gi">+        for s, t in possib:</span>
<span class="gi">+            # neighbors of s that are in G_u, not including u and v</span>
<span class="gi">+            nbrs_s = u_nbrs.intersection(G_u[s]) - set_uv</span>
<span class="gi">+            # s and t are not directly connected</span>
<span class="gi">+            if t not in nbrs_s:</span>
<span class="gi">+                # s and t do not share a connection</span>
<span class="gi">+                if nbrs_s.isdisjoint(G_u[t]):</span>
<span class="gi">+                    # tick for disp(u, v)</span>
<span class="gi">+                    total += 1</span>
<span class="gi">+        # neighbors that u and v share</span>
<span class="gi">+        embeddedness = len(ST)</span>
<span class="gi">+</span>
<span class="gi">+        dispersion_val = total</span>
<span class="gi">+        if normalized:</span>
<span class="gi">+            dispersion_val = (total + b) ** alpha</span>
<span class="gi">+            if embeddedness + c != 0:</span>
<span class="gi">+                dispersion_val /= embeddedness + c</span>
<span class="gi">+</span>
<span class="gi">+        return dispersion_val</span>
<span class="gi">+</span>
<span class="gi">+    if u is None:</span>
<span class="gi">+        # v and u are not specified</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            results = {n: {} for n in G}</span>
<span class="gi">+            for u in G:</span>
<span class="gi">+                for v in G[u]:</span>
<span class="gi">+                    results[u][v] = _dispersion(G, u, v)</span>
<span class="gi">+        # u is not specified, but v is</span>
<span class="gi">+        else:</span>
<span class="gi">+            results = dict.fromkeys(G[v], {})</span>
<span class="gi">+            for u in G[v]:</span>
<span class="gi">+                results[u] = _dispersion(G, v, u)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # u is specified with no target v</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            results = dict.fromkeys(G[u], {})</span>
<span class="gi">+            for v in G[u]:</span>
<span class="gi">+                results[v] = _dispersion(G, u, v)</span>
<span class="gi">+        # both u and v are specified</span>
<span class="gi">+        else:</span>
<span class="gi">+            results = _dispersion(G, u, v)</span>
<span class="gi">+</span>
<span class="gi">+    return results</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/eigenvector.py b/networkx/algorithms/centrality/eigenvector.py</span>
<span class="gh">index 9d142ad9d..ed57b2aeb 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/eigenvector.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/eigenvector.py</span>
<span class="gu">@@ -1,44 +1,45 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing eigenvector centrality.&quot;&quot;&quot;
<span class="w"> </span>import math
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;eigenvector_centrality&#39;, &#39;eigenvector_centrality_numpy&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;eigenvector_centrality&quot;, &quot;eigenvector_centrality_numpy&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def eigenvector_centrality(G, max_iter=100, tol=1e-06, nstart=None, weight=None</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the eigenvector centrality for the graph G.</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def eigenvector_centrality(G, max_iter=100, tol=1.0e-6, nstart=None, weight=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the eigenvector centrality for the graph G.</span>

<span class="w"> </span>    Eigenvector centrality computes the centrality for a node by adding
<span class="w"> </span>    the centrality of its predecessors. The centrality for node $i$ is the
<span class="gd">-    $i$-th element of a left eigenvector associated with the eigenvalue $\\lambda$</span>
<span class="gi">+    $i$-th element of a left eigenvector associated with the eigenvalue $\lambda$</span>
<span class="w"> </span>    of maximum modulus that is positive. Such an eigenvector $x$ is
<span class="w"> </span>    defined up to a multiplicative constant by the equation

<span class="w"> </span>    .. math::

<span class="gd">-         \\lambda x^T = x^T A,</span>
<span class="gi">+         \lambda x^T = x^T A,</span>

<span class="w"> </span>    where $A$ is the adjacency matrix of the graph G. By definition of
<span class="w"> </span>    row-column product, the equation above is equivalent to

<span class="w"> </span>    .. math::

<span class="gd">-        \\lambda x_i = \\sum_{j\\to i}x_j.</span>
<span class="gi">+        \lambda x_i = \sum_{j\to i}x_j.</span>

<span class="w"> </span>    That is, adding the eigenvector centralities of the predecessors of
<span class="w"> </span>    $i$ one obtains the eigenvector centrality of $i$ multiplied by
<span class="gd">-    $\\lambda$. In the case of undirected graphs, $x$ also solves the familiar</span>
<span class="gd">-    right-eigenvector equation $Ax = \\lambda x$.</span>
<span class="gi">+    $\lambda$. In the case of undirected graphs, $x$ also solves the familiar</span>
<span class="gi">+    right-eigenvector equation $Ax = \lambda x$.</span>

<span class="w"> </span>    By virtue of the Perron–Frobenius theorem [1]_, if G is strongly
<span class="w"> </span>    connected there is a unique eigenvector $x$, and all its entries
<span class="w"> </span>    are strictly positive.

<span class="w"> </span>    If G is not strongly connected there might be several left
<span class="gd">-    eigenvectors associated with $\\lambda$, and some of their elements</span>
<span class="gi">+    eigenvectors associated with $\lambda$, and some of their elements</span>
<span class="w"> </span>    might be zero.

<span class="w"> </span>    Parameters
<span class="gu">@@ -157,41 +158,73 @@ def eigenvector_centrality(G, max_iter=100, tol=1e-06, nstart=None, weight=None</span>
<span class="w"> </span>    .. [7] Power iteration:: https://en.wikipedia.org/wiki/Power_iteration

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(</span>
<span class="gi">+            &quot;cannot compute centrality for the null graph&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    # If no initial vector is provided, start with the all-ones vector.</span>
<span class="gi">+    if nstart is None:</span>
<span class="gi">+        nstart = {v: 1 for v in G}</span>
<span class="gi">+    if all(v == 0 for v in nstart.values()):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;initial vector cannot have all zero values&quot;)</span>
<span class="gi">+    # Normalize the initial vector so that each entry is in [0, 1]. This is</span>
<span class="gi">+    # guaranteed to never have a divide-by-zero error by the previous line.</span>
<span class="gi">+    nstart_sum = sum(nstart.values())</span>
<span class="gi">+    x = {k: v / nstart_sum for k, v in nstart.items()}</span>
<span class="gi">+    nnodes = G.number_of_nodes()</span>
<span class="gi">+    # make up to max_iter iterations</span>
<span class="gi">+    for _ in range(max_iter):</span>
<span class="gi">+        xlast = x</span>
<span class="gi">+        x = xlast.copy()  # Start with xlast times I to iterate with (A+I)</span>
<span class="gi">+        # do the multiplication y^T = x^T A (left eigenvector)</span>
<span class="gi">+        for n in x:</span>
<span class="gi">+            for nbr in G[n]:</span>
<span class="gi">+                w = G[n][nbr].get(weight, 1) if weight else 1</span>
<span class="gi">+                x[nbr] += xlast[n] * w</span>
<span class="gi">+        # Normalize the vector. The normalization denominator `norm`</span>
<span class="gi">+        # should never be zero by the Perron--Frobenius</span>
<span class="gi">+        # theorem. However, in case it is due to numerical error, we</span>
<span class="gi">+        # assume the norm to be one instead.</span>
<span class="gi">+        norm = math.hypot(*x.values()) or 1</span>
<span class="gi">+        x = {k: v / norm for k, v in x.items()}</span>
<span class="gi">+        # Check for convergence (in the L_1 norm).</span>
<span class="gi">+        if sum(abs(x[n] - xlast[n]) for n in x) &lt; nnodes * tol:</span>
<span class="gi">+            return x</span>
<span class="gi">+    raise nx.PowerIterationFailedConvergence(max_iter)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def eigenvector_centrality_numpy(G, weight=None, max_iter=50, tol=0):
<span class="gd">-    &quot;&quot;&quot;Compute the eigenvector centrality for the graph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the eigenvector centrality for the graph G.</span>

<span class="w"> </span>    Eigenvector centrality computes the centrality for a node by adding
<span class="w"> </span>    the centrality of its predecessors. The centrality for node $i$ is the
<span class="gd">-    $i$-th element of a left eigenvector associated with the eigenvalue $\\lambda$</span>
<span class="gi">+    $i$-th element of a left eigenvector associated with the eigenvalue $\lambda$</span>
<span class="w"> </span>    of maximum modulus that is positive. Such an eigenvector $x$ is
<span class="w"> </span>    defined up to a multiplicative constant by the equation

<span class="w"> </span>    .. math::

<span class="gd">-         \\lambda x^T = x^T A,</span>
<span class="gi">+         \lambda x^T = x^T A,</span>

<span class="w"> </span>    where $A$ is the adjacency matrix of the graph G. By definition of
<span class="w"> </span>    row-column product, the equation above is equivalent to

<span class="w"> </span>    .. math::

<span class="gd">-        \\lambda x_i = \\sum_{j\\to i}x_j.</span>
<span class="gi">+        \lambda x_i = \sum_{j\to i}x_j.</span>

<span class="w"> </span>    That is, adding the eigenvector centralities of the predecessors of
<span class="w"> </span>    $i$ one obtains the eigenvector centrality of $i$ multiplied by
<span class="gd">-    $\\lambda$. In the case of undirected graphs, $x$ also solves the familiar</span>
<span class="gd">-    right-eigenvector equation $Ax = \\lambda x$.</span>
<span class="gi">+    $\lambda$. In the case of undirected graphs, $x$ also solves the familiar</span>
<span class="gi">+    right-eigenvector equation $Ax = \lambda x$.</span>

<span class="w"> </span>    By virtue of the Perron–Frobenius theorem [1]_, if G is strongly
<span class="w"> </span>    connected there is a unique eigenvector $x$, and all its entries
<span class="w"> </span>    are strictly positive.

<span class="w"> </span>    If G is not strongly connected there might be several left
<span class="gd">-    eigenvectors associated with $\\lambda$, and some of their elements</span>
<span class="gi">+    eigenvectors associated with $\lambda$, and some of their elements</span>
<span class="w"> </span>    might be zero.

<span class="w"> </span>    Parameters
<span class="gu">@@ -292,4 +325,17 @@ def eigenvector_centrality_numpy(G, weight=None, max_iter=50, tol=0):</span>
<span class="w"> </span>    .. [7] Arnoldi iteration:: https://en.wikipedia.org/wiki/Arnoldi_iteration

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(</span>
<span class="gi">+            &quot;cannot compute centrality for the null graph&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    M = nx.to_scipy_sparse_array(G, nodelist=list(G), weight=weight, dtype=float)</span>
<span class="gi">+    _, eigenvector = sp.sparse.linalg.eigs(</span>
<span class="gi">+        M.T, k=1, which=&quot;LR&quot;, maxiter=max_iter, tol=tol</span>
<span class="gi">+    )</span>
<span class="gi">+    largest = eigenvector.flatten().real</span>
<span class="gi">+    norm = np.sign(largest.sum()) * sp.linalg.norm(largest)</span>
<span class="gi">+    return dict(zip(G, (largest / norm).tolist()))</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/flow_matrix.py b/networkx/algorithms/centrality/flow_matrix.py</span>
<span class="gh">index 406d0bc08..3874f6b2f 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/flow_matrix.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/flow_matrix.py</span>
<span class="gu">@@ -1,12 +1,44 @@</span>
<span class="gi">+# Helpers for current-flow betweenness and current-flow closeness</span>
<span class="gi">+# Lazy computations for inverse Laplacian and flow-matrix rows.</span>
<span class="w"> </span>import networkx as nx


<span class="gd">-class InverseLaplacian:</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def flow_matrix_row(G, weight=None, dtype=float, solver=&quot;lu&quot;):</span>
<span class="gi">+    # Generate a row of the current-flow matrix</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    solvername = {</span>
<span class="gi">+        &quot;full&quot;: FullInverseLaplacian,</span>
<span class="gi">+        &quot;lu&quot;: SuperLUInverseLaplacian,</span>
<span class="gi">+        &quot;cg&quot;: CGInverseLaplacian,</span>
<span class="gi">+    }</span>
<span class="gi">+    n = G.number_of_nodes()</span>
<span class="gi">+    L = nx.laplacian_matrix(G, nodelist=range(n), weight=weight).asformat(&quot;csc&quot;)</span>
<span class="gi">+    L = L.astype(dtype)</span>
<span class="gi">+    C = solvername[solver](L, dtype=dtype)  # initialize solver</span>
<span class="gi">+    w = C.w  # w is the Laplacian matrix width</span>
<span class="gi">+    # row-by-row flow matrix</span>
<span class="gi">+    for u, v in sorted(sorted((u, v)) for u, v in G.edges()):</span>
<span class="gi">+        B = np.zeros(w, dtype=dtype)</span>
<span class="gi">+        c = G[u][v].get(weight, 1.0)</span>
<span class="gi">+        B[u % w] = c</span>
<span class="gi">+        B[v % w] = -c</span>
<span class="gi">+        # get only the rows needed in the inverse laplacian</span>
<span class="gi">+        # and multiply to get the flow matrix row</span>
<span class="gi">+        row = B @ C.get_rows(u, v)</span>
<span class="gi">+        yield row, (u, v)</span>
<span class="gi">+</span>

<span class="gi">+# Class to compute the inverse laplacian only for specified rows</span>
<span class="gi">+# Allows computation of the current-flow matrix without storing entire</span>
<span class="gi">+# inverse laplacian matrix</span>
<span class="gi">+class InverseLaplacian:</span>
<span class="w"> </span>    def __init__(self, L, width=None, dtype=None):
<span class="w"> </span>        global np
<span class="w"> </span>        import numpy as np
<span class="gd">-        n, n = L.shape</span>
<span class="gi">+</span>
<span class="gi">+        (n, n) = L.shape</span>
<span class="w"> </span>        self.dtype = dtype
<span class="w"> </span>        self.n = n
<span class="w"> </span>        if width is None:
<span class="gu">@@ -17,14 +49,82 @@ class InverseLaplacian:</span>
<span class="w"> </span>        self.L1 = L[1:, 1:]
<span class="w"> </span>        self.init_solver(L)

<span class="gi">+    def init_solver(self, L):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def solve(self, r):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Implement solver&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def solve_inverse(self, r):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Implement solver&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def get_rows(self, r1, r2):</span>
<span class="gi">+        for r in range(r1, r2 + 1):</span>
<span class="gi">+            self.C[r % self.w, 1:] = self.solve_inverse(r)</span>
<span class="gi">+        return self.C</span>
<span class="gi">+</span>
<span class="gi">+    def get_row(self, r):</span>
<span class="gi">+        self.C[r % self.w, 1:] = self.solve_inverse(r)</span>
<span class="gi">+        return self.C[r % self.w]</span>
<span class="gi">+</span>
<span class="gi">+    def width(self, L):</span>
<span class="gi">+        m = 0</span>
<span class="gi">+        for i, row in enumerate(L):</span>
<span class="gi">+            w = 0</span>
<span class="gi">+            x, y = np.nonzero(row)</span>
<span class="gi">+            if len(y) &gt; 0:</span>
<span class="gi">+                v = y - i</span>
<span class="gi">+                w = v.max() - v.min() + 1</span>
<span class="gi">+                m = max(w, m)</span>
<span class="gi">+        return m</span>
<span class="gi">+</span>

<span class="w"> </span>class FullInverseLaplacian(InverseLaplacian):
<span class="gd">-    pass</span>
<span class="gi">+    def init_solver(self, L):</span>
<span class="gi">+        self.IL = np.zeros(L.shape, dtype=self.dtype)</span>
<span class="gi">+        self.IL[1:, 1:] = np.linalg.inv(self.L1.todense())</span>
<span class="gi">+</span>
<span class="gi">+    def solve(self, rhs):</span>
<span class="gi">+        s = np.zeros(rhs.shape, dtype=self.dtype)</span>
<span class="gi">+        s = self.IL @ rhs</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def solve_inverse(self, r):</span>
<span class="gi">+        return self.IL[r, 1:]</span>


<span class="w"> </span>class SuperLUInverseLaplacian(InverseLaplacian):
<span class="gd">-    pass</span>
<span class="gi">+    def init_solver(self, L):</span>
<span class="gi">+        import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+        self.lusolve = sp.sparse.linalg.factorized(self.L1.tocsc())</span>
<span class="gi">+</span>
<span class="gi">+    def solve_inverse(self, r):</span>
<span class="gi">+        rhs = np.zeros(self.n, dtype=self.dtype)</span>
<span class="gi">+        rhs[r] = 1</span>
<span class="gi">+        return self.lusolve(rhs[1:])</span>
<span class="gi">+</span>
<span class="gi">+    def solve(self, rhs):</span>
<span class="gi">+        s = np.zeros(rhs.shape, dtype=self.dtype)</span>
<span class="gi">+        s[1:] = self.lusolve(rhs[1:])</span>
<span class="gi">+        return s</span>


<span class="w"> </span>class CGInverseLaplacian(InverseLaplacian):
<span class="gd">-    pass</span>
<span class="gi">+    def init_solver(self, L):</span>
<span class="gi">+        global sp</span>
<span class="gi">+        import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+        ilu = sp.sparse.linalg.spilu(self.L1.tocsc())</span>
<span class="gi">+        n = self.n - 1</span>
<span class="gi">+        self.M = sp.sparse.linalg.LinearOperator(shape=(n, n), matvec=ilu.solve)</span>
<span class="gi">+</span>
<span class="gi">+    def solve(self, rhs):</span>
<span class="gi">+        s = np.zeros(rhs.shape, dtype=self.dtype)</span>
<span class="gi">+        s[1:] = sp.sparse.linalg.cg(self.L1, rhs[1:], M=self.M, atol=0)[0]</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def solve_inverse(self, r):</span>
<span class="gi">+        rhs = np.zeros(self.n, self.dtype)</span>
<span class="gi">+        rhs[r] = 1</span>
<span class="gi">+        return sp.sparse.linalg.cg(self.L1, rhs[1:], M=self.M, atol=0)[0]</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/group.py b/networkx/algorithms/centrality/group.py</span>
<span class="gh">index 34928993a..66fd309ff 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/group.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/group.py</span>
<span class="gu">@@ -1,27 +1,37 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Group centrality measures.&quot;&quot;&quot;
<span class="w"> </span>from copy import deepcopy
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.algorithms.centrality.betweenness import _accumulate_endpoints, _single_source_dijkstra_path_basic, _single_source_shortest_path_basic</span>
<span class="gi">+from networkx.algorithms.centrality.betweenness import (</span>
<span class="gi">+    _accumulate_endpoints,</span>
<span class="gi">+    _single_source_dijkstra_path_basic,</span>
<span class="gi">+    _single_source_shortest_path_basic,</span>
<span class="gi">+)</span>
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;group_betweenness_centrality&#39;, &#39;group_closeness_centrality&#39;,</span>
<span class="gd">-    &#39;group_degree_centrality&#39;, &#39;group_in_degree_centrality&#39;,</span>
<span class="gd">-    &#39;group_out_degree_centrality&#39;, &#39;prominent_group&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;group_betweenness_centrality&quot;,</span>
<span class="gi">+    &quot;group_closeness_centrality&quot;,</span>
<span class="gi">+    &quot;group_degree_centrality&quot;,</span>
<span class="gi">+    &quot;group_in_degree_centrality&quot;,</span>
<span class="gi">+    &quot;group_out_degree_centrality&quot;,</span>
<span class="gi">+    &quot;prominent_group&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def group_betweenness_centrality(G, C, normalized=True, weight=None,</span>
<span class="gd">-    endpoints=False):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the group betweenness centrality for a group of nodes.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def group_betweenness_centrality(G, C, normalized=True, weight=None, endpoints=False):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the group betweenness centrality for a group of nodes.</span>

<span class="w"> </span>    Group betweenness centrality of a group of nodes $C$ is the sum of the
<span class="w"> </span>    fraction of all-pairs shortest paths that pass through any vertex in $C$

<span class="w"> </span>    .. math::

<span class="gd">-       c_B(v) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}</span>
<span class="gi">+       c_B(v) =\sum_{s,t \in V} \frac{\sigma(s, t|v)}{\sigma(s, t)}</span>

<span class="gd">-    where $V$ is the set of nodes, $\\sigma(s, t)$ is the number of</span>
<span class="gd">-    shortest $(s, t)$-paths, and $\\sigma(s, t|C)$ is the number of</span>
<span class="gi">+    where $V$ is the set of nodes, $\sigma(s, t)$ is the number of</span>
<span class="gi">+    shortest $(s, t)$-paths, and $\sigma(s, t|C)$ is the number of</span>
<span class="w"> </span>    those paths passing through some node in group $C$. Note that
<span class="w"> </span>    $(s, t)$ are not members of the group ($V-C$ is the set of nodes
<span class="w"> </span>    in $V$ that are not in $C$).
<span class="gu">@@ -103,13 +113,134 @@ def group_betweenness_centrality(G, C, normalized=True, weight=None,</span>
<span class="w"> </span>       https://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def prominent_group(G, k, weight=None, C=None, endpoints=False, normalized=</span>
<span class="gd">-    True, greedy=False):</span>
<span class="gd">-    &quot;&quot;&quot;Find the prominent group of size $k$ in graph $G$. The prominence of the</span>
<span class="gi">+    GBC = []  # initialize betweenness</span>
<span class="gi">+    list_of_groups = True</span>
<span class="gi">+    #  check weather C contains one or many groups</span>
<span class="gi">+    if any(el in G for el in C):</span>
<span class="gi">+        C = [C]</span>
<span class="gi">+        list_of_groups = False</span>
<span class="gi">+    set_v = {node for group in C for node in group}</span>
<span class="gi">+    if set_v - G.nodes:  # element(s) of C not in G</span>
<span class="gi">+        raise nx.NodeNotFound(f&quot;The node(s) {set_v - G.nodes} are in C but not in G.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # pre-processing</span>
<span class="gi">+    PB, sigma, D = _group_preprocessing(G, set_v, weight)</span>
<span class="gi">+</span>
<span class="gi">+    # the algorithm for each group</span>
<span class="gi">+    for group in C:</span>
<span class="gi">+        group = set(group)  # set of nodes in group</span>
<span class="gi">+        # initialize the matrices of the sigma and the PB</span>
<span class="gi">+        GBC_group = 0</span>
<span class="gi">+        sigma_m = deepcopy(sigma)</span>
<span class="gi">+        PB_m = deepcopy(PB)</span>
<span class="gi">+        sigma_m_v = deepcopy(sigma_m)</span>
<span class="gi">+        PB_m_v = deepcopy(PB_m)</span>
<span class="gi">+        for v in group:</span>
<span class="gi">+            GBC_group += PB_m[v][v]</span>
<span class="gi">+            for x in group:</span>
<span class="gi">+                for y in group:</span>
<span class="gi">+                    dxvy = 0</span>
<span class="gi">+                    dxyv = 0</span>
<span class="gi">+                    dvxy = 0</span>
<span class="gi">+                    if not (</span>
<span class="gi">+                        sigma_m[x][y] == 0 or sigma_m[x][v] == 0 or sigma_m[v][y] == 0</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        if D[x][v] == D[x][y] + D[y][v]:</span>
<span class="gi">+                            dxyv = sigma_m[x][y] * sigma_m[y][v] / sigma_m[x][v]</span>
<span class="gi">+                        if D[x][y] == D[x][v] + D[v][y]:</span>
<span class="gi">+                            dxvy = sigma_m[x][v] * sigma_m[v][y] / sigma_m[x][y]</span>
<span class="gi">+                        if D[v][y] == D[v][x] + D[x][y]:</span>
<span class="gi">+                            dvxy = sigma_m[v][x] * sigma[x][y] / sigma[v][y]</span>
<span class="gi">+                    sigma_m_v[x][y] = sigma_m[x][y] * (1 - dxvy)</span>
<span class="gi">+                    PB_m_v[x][y] = PB_m[x][y] - PB_m[x][y] * dxvy</span>
<span class="gi">+                    if y != v:</span>
<span class="gi">+                        PB_m_v[x][y] -= PB_m[x][v] * dxyv</span>
<span class="gi">+                    if x != v:</span>
<span class="gi">+                        PB_m_v[x][y] -= PB_m[v][y] * dvxy</span>
<span class="gi">+            sigma_m, sigma_m_v = sigma_m_v, sigma_m</span>
<span class="gi">+            PB_m, PB_m_v = PB_m_v, PB_m</span>
<span class="gi">+</span>
<span class="gi">+        # endpoints</span>
<span class="gi">+        v, c = len(G), len(group)</span>
<span class="gi">+        if not endpoints:</span>
<span class="gi">+            scale = 0</span>
<span class="gi">+            # if the graph is connected then subtract the endpoints from</span>
<span class="gi">+            # the count for all the nodes in the graph. else count how many</span>
<span class="gi">+            # nodes are connected to the group&#39;s nodes and subtract that.</span>
<span class="gi">+            if nx.is_directed(G):</span>
<span class="gi">+                if nx.is_strongly_connected(G):</span>
<span class="gi">+                    scale = c * (2 * v - c - 1)</span>
<span class="gi">+            elif nx.is_connected(G):</span>
<span class="gi">+                scale = c * (2 * v - c - 1)</span>
<span class="gi">+            if scale == 0:</span>
<span class="gi">+                for group_node1 in group:</span>
<span class="gi">+                    for node in D[group_node1]:</span>
<span class="gi">+                        if node != group_node1:</span>
<span class="gi">+                            if node in group:</span>
<span class="gi">+                                scale += 1</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                scale += 2</span>
<span class="gi">+            GBC_group -= scale</span>
<span class="gi">+</span>
<span class="gi">+        # normalized</span>
<span class="gi">+        if normalized:</span>
<span class="gi">+            scale = 1 / ((v - c) * (v - c - 1))</span>
<span class="gi">+            GBC_group *= scale</span>
<span class="gi">+</span>
<span class="gi">+        # If undirected than count only the undirected edges</span>
<span class="gi">+        elif not G.is_directed():</span>
<span class="gi">+            GBC_group /= 2</span>
<span class="gi">+</span>
<span class="gi">+        GBC.append(GBC_group)</span>
<span class="gi">+    if list_of_groups:</span>
<span class="gi">+        return GBC</span>
<span class="gi">+    return GBC[0]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _group_preprocessing(G, set_v, weight):</span>
<span class="gi">+    sigma = {}</span>
<span class="gi">+    delta = {}</span>
<span class="gi">+    D = {}</span>
<span class="gi">+    betweenness = dict.fromkeys(G, 0)</span>
<span class="gi">+    for s in G:</span>
<span class="gi">+        if weight is None:  # use BFS</span>
<span class="gi">+            S, P, sigma[s], D[s] = _single_source_shortest_path_basic(G, s)</span>
<span class="gi">+        else:  # use Dijkstra&#39;s algorithm</span>
<span class="gi">+            S, P, sigma[s], D[s] = _single_source_dijkstra_path_basic(G, s, weight)</span>
<span class="gi">+        betweenness, delta[s] = _accumulate_endpoints(betweenness, S, P, sigma[s], s)</span>
<span class="gi">+        for i in delta[s]:  # add the paths from s to i and rescale sigma</span>
<span class="gi">+            if s != i:</span>
<span class="gi">+                delta[s][i] += 1</span>
<span class="gi">+            if weight is not None:</span>
<span class="gi">+                sigma[s][i] = sigma[s][i] / 2</span>
<span class="gi">+    # building the path betweenness matrix only for nodes that appear in the group</span>
<span class="gi">+    PB = dict.fromkeys(G)</span>
<span class="gi">+    for group_node1 in set_v:</span>
<span class="gi">+        PB[group_node1] = dict.fromkeys(G, 0.0)</span>
<span class="gi">+        for group_node2 in set_v:</span>
<span class="gi">+            if group_node2 not in D[group_node1]:</span>
<span class="gi">+                continue</span>
<span class="gi">+            for node in G:</span>
<span class="gi">+                # if node is connected to the two group nodes than continue</span>
<span class="gi">+                if group_node2 in D[node] and group_node1 in D[node]:</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        D[node][group_node2]</span>
<span class="gi">+                        == D[node][group_node1] + D[group_node1][group_node2]</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        PB[group_node1][group_node2] += (</span>
<span class="gi">+                            delta[node][group_node2]</span>
<span class="gi">+                            * sigma[node][group_node1]</span>
<span class="gi">+                            * sigma[group_node1][group_node2]</span>
<span class="gi">+                            / sigma[node][group_node2]</span>
<span class="gi">+                        )</span>
<span class="gi">+    return PB, sigma, D</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def prominent_group(</span>
<span class="gi">+    G, k, weight=None, C=None, endpoints=False, normalized=True, greedy=False</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Find the prominent group of size $k$ in graph $G$. The prominence of the</span>
<span class="w"> </span>    group is evaluated by the group betweenness centrality.

<span class="w"> </span>    Group betweenness centrality of a group of nodes $C$ is the sum of the
<span class="gu">@@ -117,10 +248,10 @@ def prominent_group(G, k, weight=None, C=None, endpoints=False, normalized=</span>

<span class="w"> </span>    .. math::

<span class="gd">-       c_B(v) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}</span>
<span class="gi">+       c_B(v) =\sum_{s,t \in V} \frac{\sigma(s, t|v)}{\sigma(s, t)}</span>

<span class="gd">-    where $V$ is the set of nodes, $\\sigma(s, t)$ is the number of</span>
<span class="gd">-    shortest $(s, t)$-paths, and $\\sigma(s, t|C)$ is the number of</span>
<span class="gi">+    where $V$ is the set of nodes, $\sigma(s, t)$ is the number of</span>
<span class="gi">+    shortest $(s, t)$-paths, and $\sigma(s, t|C)$ is the number of</span>
<span class="w"> </span>    those paths passing through some node in group $C$. Note that
<span class="w"> </span>    $(s, t)$ are not members of the group ($V-C$ is the set of nodes
<span class="w"> </span>    in $V$ that are not in $C$).
<span class="gu">@@ -208,21 +339,223 @@ def prominent_group(G, k, weight=None, C=None, endpoints=False, normalized=</span>
<span class="w"> </span>       &quot;Fast algorithm for successive computation of group betweenness centrality.&quot;
<span class="w"> </span>       https://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import pandas as pd</span>
<span class="gi">+</span>
<span class="gi">+    if C is not None:</span>
<span class="gi">+        C = set(C)</span>
<span class="gi">+        if C - G.nodes:  # element(s) of C not in G</span>
<span class="gi">+            raise nx.NodeNotFound(f&quot;The node(s) {C - G.nodes} are in C but not in G.&quot;)</span>
<span class="gi">+        nodes = list(G.nodes - C)</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodes = list(G.nodes)</span>
<span class="gi">+    DF_tree = nx.Graph()</span>
<span class="gi">+    DF_tree.__networkx_cache__ = None  # Disable caching</span>
<span class="gi">+    PB, sigma, D = _group_preprocessing(G, nodes, weight)</span>
<span class="gi">+    betweenness = pd.DataFrame.from_dict(PB)</span>
<span class="gi">+    if C is not None:</span>
<span class="gi">+        for node in C:</span>
<span class="gi">+            # remove from the betweenness all the nodes not part of the group</span>
<span class="gi">+            betweenness.drop(index=node, inplace=True)</span>
<span class="gi">+            betweenness.drop(columns=node, inplace=True)</span>
<span class="gi">+    CL = [node for _, node in sorted(zip(np.diag(betweenness), nodes), reverse=True)]</span>
<span class="gi">+    max_GBC = 0</span>
<span class="gi">+    max_group = []</span>
<span class="gi">+    DF_tree.add_node(</span>
<span class="gi">+        1,</span>
<span class="gi">+        CL=CL,</span>
<span class="gi">+        betweenness=betweenness,</span>
<span class="gi">+        GBC=0,</span>
<span class="gi">+        GM=[],</span>
<span class="gi">+        sigma=sigma,</span>
<span class="gi">+        cont=dict(zip(nodes, np.diag(betweenness))),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # the algorithm</span>
<span class="gi">+    DF_tree.nodes[1][&quot;heu&quot;] = 0</span>
<span class="gi">+    for i in range(k):</span>
<span class="gi">+        DF_tree.nodes[1][&quot;heu&quot;] += DF_tree.nodes[1][&quot;cont&quot;][DF_tree.nodes[1][&quot;CL&quot;][i]]</span>
<span class="gi">+    max_GBC, DF_tree, max_group = _dfbnb(</span>
<span class="gi">+        G, k, DF_tree, max_GBC, 1, D, max_group, nodes, greedy</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    v = len(G)</span>
<span class="gi">+    if not endpoints:</span>
<span class="gi">+        scale = 0</span>
<span class="gi">+        # if the graph is connected then subtract the endpoints from</span>
<span class="gi">+        # the count for all the nodes in the graph. else count how many</span>
<span class="gi">+        # nodes are connected to the group&#39;s nodes and subtract that.</span>
<span class="gi">+        if nx.is_directed(G):</span>
<span class="gi">+            if nx.is_strongly_connected(G):</span>
<span class="gi">+                scale = k * (2 * v - k - 1)</span>
<span class="gi">+        elif nx.is_connected(G):</span>
<span class="gi">+            scale = k * (2 * v - k - 1)</span>
<span class="gi">+        if scale == 0:</span>
<span class="gi">+            for group_node1 in max_group:</span>
<span class="gi">+                for node in D[group_node1]:</span>
<span class="gi">+                    if node != group_node1:</span>
<span class="gi">+                        if node in max_group:</span>
<span class="gi">+                            scale += 1</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            scale += 2</span>
<span class="gi">+        max_GBC -= scale</span>
<span class="gi">+</span>
<span class="gi">+    # normalized</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        scale = 1 / ((v - k) * (v - k - 1))</span>
<span class="gi">+        max_GBC *= scale</span>
<span class="gi">+</span>
<span class="gi">+    # If undirected then count only the undirected edges</span>
<span class="gi">+    elif not G.is_directed():</span>
<span class="gi">+        max_GBC /= 2</span>
<span class="gi">+    max_GBC = float(&quot;%.2f&quot; % max_GBC)</span>
<span class="gi">+    return max_GBC, max_group</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _dfbnb(G, k, DF_tree, max_GBC, root, D, max_group, nodes, greedy):</span>
<span class="gi">+    # stopping condition - if we found a group of size k and with higher GBC then prune</span>
<span class="gi">+    if len(DF_tree.nodes[root][&quot;GM&quot;]) == k and DF_tree.nodes[root][&quot;GBC&quot;] &gt; max_GBC:</span>
<span class="gi">+        return DF_tree.nodes[root][&quot;GBC&quot;], DF_tree, DF_tree.nodes[root][&quot;GM&quot;]</span>
<span class="gi">+    # stopping condition - if the size of group members equal to k or there are less than</span>
<span class="gi">+    # k - |GM| in the candidate list or the heuristic function plus the GBC is below the</span>
<span class="gi">+    # maximal GBC found then prune</span>
<span class="gi">+    if (</span>
<span class="gi">+        len(DF_tree.nodes[root][&quot;GM&quot;]) == k</span>
<span class="gi">+        or len(DF_tree.nodes[root][&quot;CL&quot;]) &lt;= k - len(DF_tree.nodes[root][&quot;GM&quot;])</span>
<span class="gi">+        or DF_tree.nodes[root][&quot;GBC&quot;] + DF_tree.nodes[root][&quot;heu&quot;] &lt;= max_GBC</span>
<span class="gi">+    ):</span>
<span class="gi">+        return max_GBC, DF_tree, max_group</span>
<span class="gi">+</span>
<span class="gi">+    # finding the heuristic of both children</span>
<span class="gi">+    node_p, node_m, DF_tree = _heuristic(k, root, DF_tree, D, nodes, greedy)</span>
<span class="gi">+</span>
<span class="gi">+    # finding the child with the bigger heuristic + GBC and expand</span>
<span class="gi">+    # that node first if greedy then only expand the plus node</span>
<span class="gi">+    if greedy:</span>
<span class="gi">+        max_GBC, DF_tree, max_group = _dfbnb(</span>
<span class="gi">+            G, k, DF_tree, max_GBC, node_p, D, max_group, nodes, greedy</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    elif (</span>
<span class="gi">+        DF_tree.nodes[node_p][&quot;GBC&quot;] + DF_tree.nodes[node_p][&quot;heu&quot;]</span>
<span class="gi">+        &gt; DF_tree.nodes[node_m][&quot;GBC&quot;] + DF_tree.nodes[node_m][&quot;heu&quot;]</span>
<span class="gi">+    ):</span>
<span class="gi">+        max_GBC, DF_tree, max_group = _dfbnb(</span>
<span class="gi">+            G, k, DF_tree, max_GBC, node_p, D, max_group, nodes, greedy</span>
<span class="gi">+        )</span>
<span class="gi">+        max_GBC, DF_tree, max_group = _dfbnb(</span>
<span class="gi">+            G, k, DF_tree, max_GBC, node_m, D, max_group, nodes, greedy</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        max_GBC, DF_tree, max_group = _dfbnb(</span>
<span class="gi">+            G, k, DF_tree, max_GBC, node_m, D, max_group, nodes, greedy</span>
<span class="gi">+        )</span>
<span class="gi">+        max_GBC, DF_tree, max_group = _dfbnb(</span>
<span class="gi">+            G, k, DF_tree, max_GBC, node_p, D, max_group, nodes, greedy</span>
<span class="gi">+        )</span>
<span class="gi">+    return max_GBC, DF_tree, max_group</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _heuristic(k, root, DF_tree, D, nodes, greedy):</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    # This helper function add two nodes to DF_tree - one left son and the</span>
<span class="gi">+    # other right son, finds their heuristic, CL, GBC, and GM</span>
<span class="gi">+    node_p = DF_tree.number_of_nodes() + 1</span>
<span class="gi">+    node_m = DF_tree.number_of_nodes() + 2</span>
<span class="gi">+    added_node = DF_tree.nodes[root][&quot;CL&quot;][0]</span>
<span class="gi">+</span>
<span class="gi">+    # adding the plus node</span>
<span class="gi">+    DF_tree.add_nodes_from([(node_p, deepcopy(DF_tree.nodes[root]))])</span>
<span class="gi">+    DF_tree.nodes[node_p][&quot;GM&quot;].append(added_node)</span>
<span class="gi">+    DF_tree.nodes[node_p][&quot;GBC&quot;] += DF_tree.nodes[node_p][&quot;cont&quot;][added_node]</span>
<span class="gi">+    root_node = DF_tree.nodes[root]</span>
<span class="gi">+    for x in nodes:</span>
<span class="gi">+        for y in nodes:</span>
<span class="gi">+            dxvy = 0</span>
<span class="gi">+            dxyv = 0</span>
<span class="gi">+            dvxy = 0</span>
<span class="gi">+            if not (</span>
<span class="gi">+                root_node[&quot;sigma&quot;][x][y] == 0</span>
<span class="gi">+                or root_node[&quot;sigma&quot;][x][added_node] == 0</span>
<span class="gi">+                or root_node[&quot;sigma&quot;][added_node][y] == 0</span>
<span class="gi">+            ):</span>
<span class="gi">+                if D[x][added_node] == D[x][y] + D[y][added_node]:</span>
<span class="gi">+                    dxyv = (</span>
<span class="gi">+                        root_node[&quot;sigma&quot;][x][y]</span>
<span class="gi">+                        * root_node[&quot;sigma&quot;][y][added_node]</span>
<span class="gi">+                        / root_node[&quot;sigma&quot;][x][added_node]</span>
<span class="gi">+                    )</span>
<span class="gi">+                if D[x][y] == D[x][added_node] + D[added_node][y]:</span>
<span class="gi">+                    dxvy = (</span>
<span class="gi">+                        root_node[&quot;sigma&quot;][x][added_node]</span>
<span class="gi">+                        * root_node[&quot;sigma&quot;][added_node][y]</span>
<span class="gi">+                        / root_node[&quot;sigma&quot;][x][y]</span>
<span class="gi">+                    )</span>
<span class="gi">+                if D[added_node][y] == D[added_node][x] + D[x][y]:</span>
<span class="gi">+                    dvxy = (</span>
<span class="gi">+                        root_node[&quot;sigma&quot;][added_node][x]</span>
<span class="gi">+                        * root_node[&quot;sigma&quot;][x][y]</span>
<span class="gi">+                        / root_node[&quot;sigma&quot;][added_node][y]</span>
<span class="gi">+                    )</span>
<span class="gi">+            DF_tree.nodes[node_p][&quot;sigma&quot;][x][y] = root_node[&quot;sigma&quot;][x][y] * (1 - dxvy)</span>
<span class="gi">+            DF_tree.nodes[node_p][&quot;betweenness&quot;].loc[y, x] = (</span>
<span class="gi">+                root_node[&quot;betweenness&quot;][x][y] - root_node[&quot;betweenness&quot;][x][y] * dxvy</span>
<span class="gi">+            )</span>
<span class="gi">+            if y != added_node:</span>
<span class="gi">+                DF_tree.nodes[node_p][&quot;betweenness&quot;].loc[y, x] -= (</span>
<span class="gi">+                    root_node[&quot;betweenness&quot;][x][added_node] * dxyv</span>
<span class="gi">+                )</span>
<span class="gi">+            if x != added_node:</span>
<span class="gi">+                DF_tree.nodes[node_p][&quot;betweenness&quot;].loc[y, x] -= (</span>
<span class="gi">+                    root_node[&quot;betweenness&quot;][added_node][y] * dvxy</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    DF_tree.nodes[node_p][&quot;CL&quot;] = [</span>
<span class="gi">+        node</span>
<span class="gi">+        for _, node in sorted(</span>
<span class="gi">+            zip(np.diag(DF_tree.nodes[node_p][&quot;betweenness&quot;]), nodes), reverse=True</span>
<span class="gi">+        )</span>
<span class="gi">+        if node not in DF_tree.nodes[node_p][&quot;GM&quot;]</span>
<span class="gi">+    ]</span>
<span class="gi">+    DF_tree.nodes[node_p][&quot;cont&quot;] = dict(</span>
<span class="gi">+        zip(nodes, np.diag(DF_tree.nodes[node_p][&quot;betweenness&quot;]))</span>
<span class="gi">+    )</span>
<span class="gi">+    DF_tree.nodes[node_p][&quot;heu&quot;] = 0</span>
<span class="gi">+    for i in range(k - len(DF_tree.nodes[node_p][&quot;GM&quot;])):</span>
<span class="gi">+        DF_tree.nodes[node_p][&quot;heu&quot;] += DF_tree.nodes[node_p][&quot;cont&quot;][</span>
<span class="gi">+            DF_tree.nodes[node_p][&quot;CL&quot;][i]</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    # adding the minus node - don&#39;t insert the first node in the CL to GM</span>
<span class="gi">+    # Insert minus node only if isn&#39;t greedy type algorithm</span>
<span class="gi">+    if not greedy:</span>
<span class="gi">+        DF_tree.add_nodes_from([(node_m, deepcopy(DF_tree.nodes[root]))])</span>
<span class="gi">+        DF_tree.nodes[node_m][&quot;CL&quot;].pop(0)</span>
<span class="gi">+        DF_tree.nodes[node_m][&quot;cont&quot;].pop(added_node)</span>
<span class="gi">+        DF_tree.nodes[node_m][&quot;heu&quot;] = 0</span>
<span class="gi">+        for i in range(k - len(DF_tree.nodes[node_m][&quot;GM&quot;])):</span>
<span class="gi">+            DF_tree.nodes[node_m][&quot;heu&quot;] += DF_tree.nodes[node_m][&quot;cont&quot;][</span>
<span class="gi">+                DF_tree.nodes[node_m][&quot;CL&quot;][i]</span>
<span class="gi">+            ]</span>
<span class="gi">+    else:</span>
<span class="gi">+        node_m = None</span>
<span class="gi">+</span>
<span class="gi">+    return node_p, node_m, DF_tree</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def group_closeness_centrality(G, S, weight=None):
<span class="gd">-    &quot;&quot;&quot;Compute the group closeness centrality for a group of nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the group closeness centrality for a group of nodes.</span>

<span class="w"> </span>    Group closeness centrality of a group of nodes $S$ is a measure
<span class="w"> </span>    of how close the group is to the other nodes in the graph.

<span class="w"> </span>    .. math::

<span class="gd">-       c_{close}(S) = \\frac{|V-S|}{\\sum_{v \\in V-S} d_{S, v}}</span>
<span class="gi">+       c_{close}(S) = \frac{|V-S|}{\sum_{v \in V-S} d_{S, v}}</span>

<span class="gd">-       d_{S, v} = min_{u \\in S} (d_{u, v})</span>
<span class="gi">+       d_{S, v} = min_{u \in S} (d_{u, v})</span>

<span class="w"> </span>    where $V$ is the set of nodes, $d_{S, v}$ is the distance of
<span class="w"> </span>    the group $S$ from $v$ defined as above. ($V-S$ is the set of nodes
<span class="gu">@@ -288,7 +621,24 @@ def group_closeness_centrality(G, S, weight=None):</span>
<span class="w"> </span>       WWWConference Proceedings, 2014. 689-694.
<span class="w"> </span>       https://doi.org/10.1145/2567948.2579356
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        G = G.reverse()  # reverse view</span>
<span class="gi">+    closeness = 0  # initialize to 0</span>
<span class="gi">+    V = set(G)  # set of nodes in G</span>
<span class="gi">+    S = set(S)  # set of nodes in group S</span>
<span class="gi">+    V_S = V - S  # set of nodes in V but not S</span>
<span class="gi">+    shortest_path_lengths = nx.multi_source_dijkstra_path_length(G, S, weight=weight)</span>
<span class="gi">+    # accumulation</span>
<span class="gi">+    for v in V_S:</span>
<span class="gi">+        try:</span>
<span class="gi">+            closeness += shortest_path_lengths[v]</span>
<span class="gi">+        except KeyError:  # no path exists</span>
<span class="gi">+            closeness += 0</span>
<span class="gi">+    try:</span>
<span class="gi">+        closeness = len(V_S) / closeness</span>
<span class="gi">+    except ZeroDivisionError:  # 1 / 0 assumed as 0</span>
<span class="gi">+        closeness = 0</span>
<span class="gi">+    return closeness</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -337,10 +687,12 @@ def group_degree_centrality(G, S):</span>
<span class="w"> </span>       Journal of Mathematical Sociology. 23(3): 181-201. 1999.
<span class="w"> </span>       http://www.analytictech.com/borgatti/group_centrality.htm
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    centrality = len(set().union(*[set(G.neighbors(i)) for i in S]) - set(S))</span>
<span class="gi">+    centrality /= len(G.nodes()) - len(S)</span>
<span class="gi">+    return centrality</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def group_in_degree_centrality(G, S):
<span class="w"> </span>    &quot;&quot;&quot;Compute the group in-degree centrality for a group of nodes.
<span class="gu">@@ -384,10 +736,10 @@ def group_in_degree_centrality(G, S):</span>
<span class="w"> </span>    `G.neighbors(i)` gives nodes with an outward edge from i, in a DiGraph,
<span class="w"> </span>    so for group in-degree centrality, the reverse graph is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return group_degree_centrality(G.reverse(), S)</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def group_out_degree_centrality(G, S):
<span class="w"> </span>    &quot;&quot;&quot;Compute the group out-degree centrality for a group of nodes.
<span class="gu">@@ -431,4 +783,4 @@ def group_out_degree_centrality(G, S):</span>
<span class="w"> </span>    `G.neighbors(i)` gives nodes with an outward edge from i, in a DiGraph,
<span class="w"> </span>    so for group out-degree centrality, the graph itself is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return group_degree_centrality(G, S)</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/harmonic.py b/networkx/algorithms/centrality/harmonic.py</span>
<span class="gh">index 8d1daac3f..9cd9f7f08 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/harmonic.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/harmonic.py</span>
<span class="gu">@@ -1,19 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing the harmonic centrality of a graph.&quot;&quot;&quot;
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;harmonic_centrality&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;harmonic_centrality&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;distance&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;distance&quot;)</span>
<span class="w"> </span>def harmonic_centrality(G, nbunch=None, distance=None, sources=None):
<span class="gd">-    &quot;&quot;&quot;Compute harmonic centrality for nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute harmonic centrality for nodes.</span>

<span class="w"> </span>    Harmonic centrality [1]_ of a node `u` is the sum of the reciprocal
<span class="w"> </span>    of the shortest path distances from all other nodes to `u`

<span class="w"> </span>    .. math::

<span class="gd">-        C(u) = \\sum_{v \\neq u} \\frac{1}{d(v, u)}</span>
<span class="gi">+        C(u) = \sum_{v \neq u} \frac{1}{d(v, u)}</span>

<span class="w"> </span>    where `d(v, u)` is the shortest-path distance between `v` and `u`.

<span class="gu">@@ -61,4 +63,18 @@ def harmonic_centrality(G, nbunch=None, distance=None, sources=None):</span>
<span class="w"> </span>    .. [1] Boldi, Paolo, and Sebastiano Vigna. &quot;Axioms for centrality.&quot;
<span class="w"> </span>           Internet Mathematics 10.3-4 (2014): 222-262.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    nbunch = set(G.nbunch_iter(nbunch)) if nbunch is not None else set(G.nodes)</span>
<span class="gi">+    sources = set(G.nbunch_iter(sources)) if sources is not None else G.nodes</span>
<span class="gi">+</span>
<span class="gi">+    spl = partial(nx.shortest_path_length, G, weight=distance)</span>
<span class="gi">+    centrality = {u: 0 for u in nbunch}</span>
<span class="gi">+    for v in sources:</span>
<span class="gi">+        dist = spl(v)</span>
<span class="gi">+        for u in nbunch.intersection(dist):</span>
<span class="gi">+            d = dist[u]</span>
<span class="gi">+            if d == 0:  # handle u == v and edges with 0 weight</span>
<span class="gi">+                continue</span>
<span class="gi">+            centrality[u] += 1 / d</span>
<span class="gi">+</span>
<span class="gi">+    return centrality</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/katz.py b/networkx/algorithms/centrality/katz.py</span>
<span class="gh">index a5ccdf8a7..d85ffd2dc 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/katz.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/katz.py</span>
<span class="gu">@@ -1,15 +1,25 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Katz centrality.&quot;&quot;&quot;
<span class="w"> </span>import math
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;katz_centrality&#39;, &#39;katz_centrality_numpy&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;katz_centrality&quot;, &quot;katz_centrality_numpy&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def katz_centrality(G, alpha=0.1, beta=1.0, max_iter=1000, tol=1e-06,</span>
<span class="gd">-    nstart=None, normalized=True, weight=None):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the Katz centrality for the nodes of the graph G.</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def katz_centrality(</span>
<span class="gi">+    G,</span>
<span class="gi">+    alpha=0.1,</span>
<span class="gi">+    beta=1.0,</span>
<span class="gi">+    max_iter=1000,</span>
<span class="gi">+    tol=1.0e-6,</span>
<span class="gi">+    nstart=None,</span>
<span class="gi">+    normalized=True,</span>
<span class="gi">+    weight=None,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the Katz centrality for the nodes of the graph G.</span>

<span class="w"> </span>    Katz centrality computes the centrality for a node based on the centrality
<span class="w"> </span>    of its neighbors. It is a generalization of the eigenvector centrality. The
<span class="gu">@@ -17,15 +27,15 @@ def katz_centrality(G, alpha=0.1, beta=1.0, max_iter=1000, tol=1e-06,</span>

<span class="w"> </span>    .. math::

<span class="gd">-        x_i = \\alpha \\sum_{j} A_{ij} x_j + \\beta,</span>
<span class="gi">+        x_i = \alpha \sum_{j} A_{ij} x_j + \beta,</span>

<span class="gd">-    where $A$ is the adjacency matrix of graph G with eigenvalues $\\lambda$.</span>
<span class="gi">+    where $A$ is the adjacency matrix of graph G with eigenvalues $\lambda$.</span>

<span class="gd">-    The parameter $\\beta$ controls the initial centrality and</span>
<span class="gi">+    The parameter $\beta$ controls the initial centrality and</span>

<span class="w"> </span>    .. math::

<span class="gd">-        \\alpha &lt; \\frac{1}{\\lambda_{\\max}}.</span>
<span class="gi">+        \alpha &lt; \frac{1}{\lambda_{\max}}.</span>

<span class="w"> </span>    Katz centrality computes the relative influence of a node within a
<span class="w"> </span>    network by measuring the number of the immediate neighbors (first
<span class="gu">@@ -33,8 +43,8 @@ def katz_centrality(G, alpha=0.1, beta=1.0, max_iter=1000, tol=1e-06,</span>
<span class="w"> </span>    to the node under consideration through these immediate neighbors.

<span class="w"> </span>    Extra weight can be provided to immediate neighbors through the
<span class="gd">-    parameter $\\beta$.  Connections made with distant neighbors</span>
<span class="gd">-    are, however, penalized by an attenuation factor $\\alpha$ which</span>
<span class="gi">+    parameter $\beta$.  Connections made with distant neighbors</span>
<span class="gi">+    are, however, penalized by an attenuation factor $\alpha$ which</span>
<span class="w"> </span>    should be strictly less than the inverse largest eigenvalue of the
<span class="w"> </span>    adjacency matrix in order for the Katz centrality to be computed
<span class="w"> </span>    correctly. More information is provided in [1]_.
<span class="gu">@@ -113,12 +123,12 @@ def katz_centrality(G, alpha=0.1, beta=1.0, max_iter=1000, tol=1e-06,</span>
<span class="w"> </span>    corresponding to the largest eigenvalue of the adjacency matrix of ``G``.
<span class="w"> </span>    The parameter ``alpha`` should be strictly less than the inverse of largest
<span class="w"> </span>    eigenvalue of the adjacency matrix for the algorithm to converge.
<span class="gd">-    You can use ``max(nx.adjacency_spectrum(G))`` to get $\\lambda_{\\max}$ the largest</span>
<span class="gi">+    You can use ``max(nx.adjacency_spectrum(G))`` to get $\lambda_{\max}$ the largest</span>
<span class="w"> </span>    eigenvalue of the adjacency matrix.
<span class="w"> </span>    The iteration will stop after ``max_iter`` iterations or an error tolerance of
<span class="w"> </span>    ``number_of_nodes(G) * tol`` has been reached.

<span class="gd">-    For strongly connected graphs, as $\\alpha \\to 1/\\lambda_{\\max}$, and $\\beta &gt; 0$,</span>
<span class="gi">+    For strongly connected graphs, as $\alpha \to 1/\lambda_{\max}$, and $\beta &gt; 0$,</span>
<span class="w"> </span>    Katz centrality approaches the results for eigenvector centrality.

<span class="w"> </span>    For directed graphs this finds &quot;left&quot; eigenvectors which corresponds
<span class="gu">@@ -135,14 +145,58 @@ def katz_centrality(G, alpha=0.1, beta=1.0, max_iter=1000, tol=1e-06,</span>
<span class="w"> </span>       Psychometrika 18(1):39–43, 1953
<span class="w"> </span>       https://link.springer.com/content/pdf/10.1007/BF02289026.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def katz_centrality_numpy(G, alpha=0.1, beta=1.0, normalized=True, weight=None</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the Katz centrality for the graph G.</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    nnodes = G.number_of_nodes()</span>
<span class="gi">+</span>
<span class="gi">+    if nstart is None:</span>
<span class="gi">+        # choose starting vector with entries of 0</span>
<span class="gi">+        x = {n: 0 for n in G}</span>
<span class="gi">+    else:</span>
<span class="gi">+        x = nstart</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        b = dict.fromkeys(G, float(beta))</span>
<span class="gi">+    except (TypeError, ValueError, AttributeError) as err:</span>
<span class="gi">+        b = beta</span>
<span class="gi">+        if set(beta) != set(G):</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;beta dictionary must have a value for every node&quot;</span>
<span class="gi">+            ) from err</span>
<span class="gi">+</span>
<span class="gi">+    # make up to max_iter iterations</span>
<span class="gi">+    for _ in range(max_iter):</span>
<span class="gi">+        xlast = x</span>
<span class="gi">+        x = dict.fromkeys(xlast, 0)</span>
<span class="gi">+        # do the multiplication y^T = Alpha * x^T A + Beta</span>
<span class="gi">+        for n in x:</span>
<span class="gi">+            for nbr in G[n]:</span>
<span class="gi">+                x[nbr] += xlast[n] * G[n][nbr].get(weight, 1)</span>
<span class="gi">+        for n in x:</span>
<span class="gi">+            x[n] = alpha * x[n] + b[n]</span>
<span class="gi">+</span>
<span class="gi">+        # check convergence</span>
<span class="gi">+        error = sum(abs(x[n] - xlast[n]) for n in x)</span>
<span class="gi">+        if error &lt; nnodes * tol:</span>
<span class="gi">+            if normalized:</span>
<span class="gi">+                # normalize vector</span>
<span class="gi">+                try:</span>
<span class="gi">+                    s = 1.0 / math.hypot(*x.values())</span>
<span class="gi">+                except ZeroDivisionError:</span>
<span class="gi">+                    s = 1.0</span>
<span class="gi">+            else:</span>
<span class="gi">+                s = 1</span>
<span class="gi">+            for n in x:</span>
<span class="gi">+                x[n] *= s</span>
<span class="gi">+            return x</span>
<span class="gi">+    raise nx.PowerIterationFailedConvergence(max_iter)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def katz_centrality_numpy(G, alpha=0.1, beta=1.0, normalized=True, weight=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the Katz centrality for the graph G.</span>

<span class="w"> </span>    Katz centrality computes the centrality for a node based on the centrality
<span class="w"> </span>    of its neighbors. It is a generalization of the eigenvector centrality. The
<span class="gu">@@ -150,15 +204,15 @@ def katz_centrality_numpy(G, alpha=0.1, beta=1.0, normalized=True, weight=None</span>

<span class="w"> </span>    .. math::

<span class="gd">-        x_i = \\alpha \\sum_{j} A_{ij} x_j + \\beta,</span>
<span class="gi">+        x_i = \alpha \sum_{j} A_{ij} x_j + \beta,</span>

<span class="gd">-    where $A$ is the adjacency matrix of graph G with eigenvalues $\\lambda$.</span>
<span class="gi">+    where $A$ is the adjacency matrix of graph G with eigenvalues $\lambda$.</span>

<span class="gd">-    The parameter $\\beta$ controls the initial centrality and</span>
<span class="gi">+    The parameter $\beta$ controls the initial centrality and</span>

<span class="w"> </span>    .. math::

<span class="gd">-        \\alpha &lt; \\frac{1}{\\lambda_{\\max}}.</span>
<span class="gi">+        \alpha &lt; \frac{1}{\lambda_{\max}}.</span>

<span class="w"> </span>    Katz centrality computes the relative influence of a node within a
<span class="w"> </span>    network by measuring the number of the immediate neighbors (first
<span class="gu">@@ -166,8 +220,8 @@ def katz_centrality_numpy(G, alpha=0.1, beta=1.0, normalized=True, weight=None</span>
<span class="w"> </span>    to the node under consideration through these immediate neighbors.

<span class="w"> </span>    Extra weight can be provided to immediate neighbors through the
<span class="gd">-    parameter $\\beta$.  Connections made with distant neighbors</span>
<span class="gd">-    are, however, penalized by an attenuation factor $\\alpha$ which</span>
<span class="gi">+    parameter $\beta$.  Connections made with distant neighbors</span>
<span class="gi">+    are, however, penalized by an attenuation factor $\alpha$ which</span>
<span class="w"> </span>    should be strictly less than the inverse largest eigenvalue of the
<span class="w"> </span>    adjacency matrix in order for the Katz centrality to be computed
<span class="w"> </span>    correctly. More information is provided in [1]_.
<span class="gu">@@ -231,10 +285,10 @@ def katz_centrality_numpy(G, alpha=0.1, beta=1.0, normalized=True, weight=None</span>
<span class="w"> </span>    This algorithm uses a direct linear solver to solve the above equation.
<span class="w"> </span>    The parameter ``alpha`` should be strictly less than the inverse of largest
<span class="w"> </span>    eigenvalue of the adjacency matrix for there to be a solution.
<span class="gd">-    You can use ``max(nx.adjacency_spectrum(G))`` to get $\\lambda_{\\max}$ the largest</span>
<span class="gi">+    You can use ``max(nx.adjacency_spectrum(G))`` to get $\lambda_{\max}$ the largest</span>
<span class="w"> </span>    eigenvalue of the adjacency matrix.

<span class="gd">-    For strongly connected graphs, as $\\alpha \\to 1/\\lambda_{\\max}$, and $\\beta &gt; 0$,</span>
<span class="gi">+    For strongly connected graphs, as $\alpha \to 1/\lambda_{\max}$, and $\beta &gt; 0$,</span>
<span class="w"> </span>    Katz centrality approaches the results for eigenvector centrality.

<span class="w"> </span>    For directed graphs this finds &quot;left&quot; eigenvectors which corresponds
<span class="gu">@@ -251,4 +305,26 @@ def katz_centrality_numpy(G, alpha=0.1, beta=1.0, normalized=True, weight=None</span>
<span class="w"> </span>       Psychometrika 18(1):39–43, 1953
<span class="w"> </span>       https://link.springer.com/content/pdf/10.1007/BF02289026.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+    try:</span>
<span class="gi">+        nodelist = beta.keys()</span>
<span class="gi">+        if set(nodelist) != set(G):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;beta dictionary must have a value for every node&quot;)</span>
<span class="gi">+        b = np.array(list(beta.values()), dtype=float)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+        try:</span>
<span class="gi">+            b = np.ones((len(nodelist), 1)) * beta</span>
<span class="gi">+        except (TypeError, ValueError, AttributeError) as err:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;beta must be a number&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    A = nx.adjacency_matrix(G, nodelist=nodelist, weight=weight).todense().T</span>
<span class="gi">+    n = A.shape[0]</span>
<span class="gi">+    centrality = np.linalg.solve(np.eye(n, n) - (alpha * A), b).squeeze()</span>
<span class="gi">+</span>
<span class="gi">+    # Normalize: rely on truediv to cast to float, then tolist to make Python numbers</span>
<span class="gi">+    norm = np.sign(sum(centrality)) * np.linalg.norm(centrality) if normalized else 1</span>
<span class="gi">+    return dict(zip(nodelist, (centrality / norm).tolist()))</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/laplacian.py b/networkx/algorithms/centrality/laplacian.py</span>
<span class="gh">index d9d1c0192..66207ed21 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/laplacian.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/laplacian.py</span>
<span class="gu">@@ -2,13 +2,15 @@</span>
<span class="w"> </span>Laplacian centrality measures.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;laplacian_centrality&#39;]</span>

<span class="gi">+__all__ = [&quot;laplacian_centrality&quot;]</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def laplacian_centrality(G, normalized=True, nodelist=None, weight=&#39;weight&#39;,</span>
<span class="gd">-    walk_type=None, alpha=0.95):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the Laplacian centrality for nodes in the graph `G`.</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def laplacian_centrality(</span>
<span class="gi">+    G, normalized=True, nodelist=None, weight=&quot;weight&quot;, walk_type=None, alpha=0.95</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the Laplacian centrality for nodes in the graph `G`.</span>

<span class="w"> </span>    The Laplacian Centrality of a node ``i`` is measured by the drop in the
<span class="w"> </span>    Laplacian Energy after deleting node ``i`` from the graph. The Laplacian Energy
<span class="gu">@@ -16,13 +18,13 @@ def laplacian_centrality(G, normalized=True, nodelist=None, weight=&#39;weight&#39;,</span>

<span class="w"> </span>    .. math::

<span class="gd">-        C_L(u_i,G) = \\frac{(\\Delta E)_i}{E_L (G)} = \\frac{E_L (G)-E_L (G_i)}{E_L (G)}</span>
<span class="gi">+        C_L(u_i,G) = \frac{(\Delta E)_i}{E_L (G)} = \frac{E_L (G)-E_L (G_i)}{E_L (G)}</span>

<span class="gd">-        E_L (G) = \\sum_{i=0}^n \\lambda_i^2</span>
<span class="gi">+        E_L (G) = \sum_{i=0}^n \lambda_i^2</span>

<span class="w"> </span>    Where $E_L (G)$ is the Laplacian energy of graph `G`,
<span class="w"> </span>    E_L (G_i) is the Laplacian energy of graph `G` after deleting node ``i``
<span class="gd">-    and $\\lambda_i$ are the eigenvalues of `G`&#39;s Laplacian matrix.</span>
<span class="gi">+    and $\lambda_i$ are the eigenvalues of `G`&#39;s Laplacian matrix.</span>
<span class="w"> </span>    This formula shows the normalized value. Without normalization,
<span class="w"> </span>    the numerator on the right side is returned.

<span class="gu">@@ -96,4 +98,52 @@ def laplacian_centrality(G, normalized=True, nodelist=None, weight=&#39;weight&#39;,</span>
<span class="w"> </span>    :func:`~networkx.linalg.laplacianmatrix.directed_laplacian_matrix`
<span class="w"> </span>    :func:`~networkx.linalg.laplacianmatrix.laplacian_matrix`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;null graph has no centrality defined&quot;)</span>
<span class="gi">+    if G.size(weight=weight) == 0:</span>
<span class="gi">+        if normalized:</span>
<span class="gi">+            raise ZeroDivisionError(&quot;graph with no edges has zero full energy&quot;)</span>
<span class="gi">+        return {n: 0 for n in G}</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is not None:</span>
<span class="gi">+        nodeset = set(G.nbunch_iter(nodelist))</span>
<span class="gi">+        if len(nodeset) != len(nodelist):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;nodelist has duplicate nodes or nodes not in G&quot;)</span>
<span class="gi">+        nodes = nodelist + [n for n in G if n not in nodeset]</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodelist = nodes = list(G)</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        lap_matrix = nx.directed_laplacian_matrix(G, nodes, weight, walk_type, alpha)</span>
<span class="gi">+    else:</span>
<span class="gi">+        lap_matrix = nx.laplacian_matrix(G, nodes, weight).toarray()</span>
<span class="gi">+</span>
<span class="gi">+    full_energy = np.power(sp.linalg.eigh(lap_matrix, eigvals_only=True), 2).sum()</span>
<span class="gi">+</span>
<span class="gi">+    # calculate laplacian centrality</span>
<span class="gi">+    laplace_centralities_dict = {}</span>
<span class="gi">+    for i, node in enumerate(nodelist):</span>
<span class="gi">+        # remove row and col i from lap_matrix</span>
<span class="gi">+        all_but_i = list(np.arange(lap_matrix.shape[0]))</span>
<span class="gi">+        all_but_i.remove(i)</span>
<span class="gi">+        A_2 = lap_matrix[all_but_i, :][:, all_but_i]</span>
<span class="gi">+</span>
<span class="gi">+        # Adjust diagonal for removed row</span>
<span class="gi">+        new_diag = lap_matrix.diagonal() - abs(lap_matrix[:, i])</span>
<span class="gi">+        np.fill_diagonal(A_2, new_diag[all_but_i])</span>
<span class="gi">+</span>
<span class="gi">+        if len(all_but_i) &gt; 0:  # catches degenerate case of single node</span>
<span class="gi">+            new_energy = np.power(sp.linalg.eigh(A_2, eigvals_only=True), 2).sum()</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_energy = 0.0</span>
<span class="gi">+</span>
<span class="gi">+        lapl_cent = full_energy - new_energy</span>
<span class="gi">+        if normalized:</span>
<span class="gi">+            lapl_cent = lapl_cent / full_energy</span>
<span class="gi">+</span>
<span class="gi">+        laplace_centralities_dict[node] = float(lapl_cent)</span>
<span class="gi">+</span>
<span class="gi">+    return laplace_centralities_dict</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/load.py b/networkx/algorithms/centrality/load.py</span>
<span class="gh">index 7c858b0b5..50bc6210b 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/load.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/load.py</span>
<span class="gu">@@ -1,12 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Load centrality.&quot;&quot;&quot;
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;load_centrality&#39;, &#39;edge_load_centrality&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;load_centrality&quot;, &quot;edge_load_centrality&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def newman_betweenness_centrality(G, v=None, cutoff=None, normalized=True,</span>
<span class="gd">-    weight=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def newman_betweenness_centrality(G, v=None, cutoff=None, normalized=True, weight=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute load centrality for nodes.

<span class="w"> </span>    The load centrality of a node is the fraction of all shortest
<span class="gu">@@ -55,7 +56,30 @@ def newman_betweenness_centrality(G, v=None, cutoff=None, normalized=True,</span>
<span class="w"> </span>       Physical Review Letters 87(27):1–4, 2001.
<span class="w"> </span>       https://doi.org/10.1103/PhysRevLett.87.278701
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if v is not None:  # only one node</span>
<span class="gi">+        betweenness = 0.0</span>
<span class="gi">+        for source in G:</span>
<span class="gi">+            ubetween = _node_betweenness(G, source, cutoff, False, weight)</span>
<span class="gi">+            betweenness += ubetween[v] if v in ubetween else 0</span>
<span class="gi">+        if normalized:</span>
<span class="gi">+            order = G.order()</span>
<span class="gi">+            if order &lt;= 2:</span>
<span class="gi">+                return betweenness  # no normalization b=0 for all nodes</span>
<span class="gi">+            betweenness *= 1.0 / ((order - 1) * (order - 2))</span>
<span class="gi">+    else:</span>
<span class="gi">+        betweenness = {}.fromkeys(G, 0.0)</span>
<span class="gi">+        for source in betweenness:</span>
<span class="gi">+            ubetween = _node_betweenness(G, source, cutoff, False, weight)</span>
<span class="gi">+            for vk in ubetween:</span>
<span class="gi">+                betweenness[vk] += ubetween[vk]</span>
<span class="gi">+        if normalized:</span>
<span class="gi">+            order = G.order()</span>
<span class="gi">+            if order &lt;= 2:</span>
<span class="gi">+                return betweenness  # no normalization b=0 for all nodes</span>
<span class="gi">+            scale = 1.0 / ((order - 1) * (order - 2))</span>
<span class="gi">+            for v in betweenness:</span>
<span class="gi">+                betweenness[v] *= scale</span>
<span class="gi">+    return betweenness  # all nodes</span>


<span class="w"> </span>def _node_betweenness(G, source, cutoff=False, normalized=True, weight=None):
<span class="gu">@@ -73,7 +97,40 @@ def _node_betweenness(G, source, cutoff=False, normalized=True, weight=None):</span>

<span class="w"> </span>    If weight is not None then use Dijkstra for finding shortest paths.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # get the predecessor and path length data</span>
<span class="gi">+    if weight is None:</span>
<span class="gi">+        (pred, length) = nx.predecessor(G, source, cutoff=cutoff, return_seen=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        (pred, length) = nx.dijkstra_predecessor_and_distance(G, source, cutoff, weight)</span>
<span class="gi">+</span>
<span class="gi">+    # order the nodes by path length</span>
<span class="gi">+    onodes = [(l, vert) for (vert, l) in length.items()]</span>
<span class="gi">+    onodes.sort()</span>
<span class="gi">+    onodes[:] = [vert for (l, vert) in onodes if l &gt; 0]</span>
<span class="gi">+</span>
<span class="gi">+    # initialize betweenness</span>
<span class="gi">+    between = {}.fromkeys(length, 1.0)</span>
<span class="gi">+</span>
<span class="gi">+    while onodes:</span>
<span class="gi">+        v = onodes.pop()</span>
<span class="gi">+        if v in pred:</span>
<span class="gi">+            num_paths = len(pred[v])  # Discount betweenness if more than</span>
<span class="gi">+            for x in pred[v]:  # one shortest path.</span>
<span class="gi">+                if x == source:  # stop if hit source because all remaining v</span>
<span class="gi">+                    break  # also have pred[v]==[source]</span>
<span class="gi">+                between[x] += between[v] / num_paths</span>
<span class="gi">+    #  remove source</span>
<span class="gi">+    for v in between:</span>
<span class="gi">+        between[v] -= 1</span>
<span class="gi">+    # rescale to be between 0 and 1</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        l = len(between)</span>
<span class="gi">+        if l &gt; 2:</span>
<span class="gi">+            # scale by 1/the number of possible paths</span>
<span class="gi">+            scale = 1 / ((l - 1) * (l - 2))</span>
<span class="gi">+            for v in between:</span>
<span class="gi">+                between[v] *= scale</span>
<span class="gi">+    return between</span>


<span class="w"> </span>load_centrality = newman_betweenness_centrality
<span class="gu">@@ -103,9 +160,40 @@ def edge_load_centrality(G, cutoff=False):</span>
<span class="w"> </span>    which use that edge. Where more than one path is shortest
<span class="w"> </span>    the count is divided equally among paths.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    betweenness = {}</span>
<span class="gi">+    for u, v in G.edges():</span>
<span class="gi">+        betweenness[(u, v)] = 0.0</span>
<span class="gi">+        betweenness[(v, u)] = 0.0</span>
<span class="gi">+</span>
<span class="gi">+    for source in G:</span>
<span class="gi">+        ubetween = _edge_betweenness(G, source, cutoff=cutoff)</span>
<span class="gi">+        for e, ubetweenv in ubetween.items():</span>
<span class="gi">+            betweenness[e] += ubetweenv  # cumulative total</span>
<span class="gi">+    return betweenness</span>


<span class="w"> </span>def _edge_betweenness(G, source, nodes=None, cutoff=False):
<span class="w"> </span>    &quot;&quot;&quot;Edge betweenness helper.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # get the predecessor data</span>
<span class="gi">+    (pred, length) = nx.predecessor(G, source, cutoff=cutoff, return_seen=True)</span>
<span class="gi">+    # order the nodes by path length</span>
<span class="gi">+    onodes = [n for n, d in sorted(length.items(), key=itemgetter(1))]</span>
<span class="gi">+    # initialize betweenness, doesn&#39;t account for any edge weights</span>
<span class="gi">+    between = {}</span>
<span class="gi">+    for u, v in G.edges(nodes):</span>
<span class="gi">+        between[(u, v)] = 1.0</span>
<span class="gi">+        between[(v, u)] = 1.0</span>
<span class="gi">+</span>
<span class="gi">+    while onodes:  # work through all paths</span>
<span class="gi">+        v = onodes.pop()</span>
<span class="gi">+        if v in pred:</span>
<span class="gi">+            # Discount betweenness if more than one shortest path.</span>
<span class="gi">+            num_paths = len(pred[v])</span>
<span class="gi">+            for w in pred[v]:</span>
<span class="gi">+                if w in pred:</span>
<span class="gi">+                    # Discount betweenness, mult path</span>
<span class="gi">+                    num_paths = len(pred[w])</span>
<span class="gi">+                    for x in pred[w]:</span>
<span class="gi">+                        between[(w, x)] += between[(v, w)] / num_paths</span>
<span class="gi">+                        between[(x, w)] += between[(w, v)] / num_paths</span>
<span class="gi">+    return between</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/percolation.py b/networkx/algorithms/centrality/percolation.py</span>
<span class="gh">index 7e690b6ae..0d4c87132 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/percolation.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/percolation.py</span>
<span class="gu">@@ -1,14 +1,19 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Percolation centrality measures.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.algorithms.centrality.betweenness import _single_source_dijkstra_path_basic as dijkstra</span>
<span class="gd">-from networkx.algorithms.centrality.betweenness import _single_source_shortest_path_basic as shortest_path</span>
<span class="gd">-__all__ = [&#39;percolation_centrality&#39;]</span>
<span class="gi">+from networkx.algorithms.centrality.betweenness import (</span>
<span class="gi">+    _single_source_dijkstra_path_basic as dijkstra,</span>
<span class="gi">+)</span>
<span class="gi">+from networkx.algorithms.centrality.betweenness import (</span>
<span class="gi">+    _single_source_shortest_path_basic as shortest_path,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;percolation_centrality&quot;]</span>


<span class="gd">-@nx._dispatchable(node_attrs=&#39;attribute&#39;, edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def percolation_centrality(G, attribute=&#39;percolation&#39;, states=None, weight=None</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the percolation centrality for nodes.</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;attribute&quot;, edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def percolation_centrality(G, attribute=&quot;percolation&quot;, states=None, weight=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the percolation centrality for nodes.</span>

<span class="w"> </span>    Percolation centrality of a node $v$, at a given time, is defined
<span class="w"> </span>    as the proportion of ‘percolated paths’ that go through that node.
<span class="gu">@@ -78,4 +83,46 @@ def percolation_centrality(G, attribute=&#39;percolation&#39;, states=None, weight=None</span>
<span class="w"> </span>       Journal of Mathematical Sociology 25(2):163-177, 2001.
<span class="w"> </span>       https://doi.org/10.1080/0022250X.2001.9990249
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    percolation = dict.fromkeys(G, 0.0)  # b[v]=0 for v in G</span>
<span class="gi">+</span>
<span class="gi">+    nodes = G</span>
<span class="gi">+</span>
<span class="gi">+    if states is None:</span>
<span class="gi">+        states = nx.get_node_attributes(nodes, attribute, default=1)</span>
<span class="gi">+</span>
<span class="gi">+    # sum of all percolation states</span>
<span class="gi">+    p_sigma_x_t = 0.0</span>
<span class="gi">+    for v in states.values():</span>
<span class="gi">+        p_sigma_x_t += v</span>
<span class="gi">+</span>
<span class="gi">+    for s in nodes:</span>
<span class="gi">+        # single source shortest paths</span>
<span class="gi">+        if weight is None:  # use BFS</span>
<span class="gi">+            S, P, sigma, _ = shortest_path(G, s)</span>
<span class="gi">+        else:  # use Dijkstra&#39;s algorithm</span>
<span class="gi">+            S, P, sigma, _ = dijkstra(G, s, weight)</span>
<span class="gi">+        # accumulation</span>
<span class="gi">+        percolation = _accumulate_percolation(</span>
<span class="gi">+            percolation, S, P, sigma, s, states, p_sigma_x_t</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+</span>
<span class="gi">+    for v in percolation:</span>
<span class="gi">+        percolation[v] *= 1 / (n - 2)</span>
<span class="gi">+</span>
<span class="gi">+    return percolation</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _accumulate_percolation(percolation, S, P, sigma, s, states, p_sigma_x_t):</span>
<span class="gi">+    delta = dict.fromkeys(S, 0)</span>
<span class="gi">+    while S:</span>
<span class="gi">+        w = S.pop()</span>
<span class="gi">+        coeff = (1 + delta[w]) / sigma[w]</span>
<span class="gi">+        for v in P[w]:</span>
<span class="gi">+            delta[v] += sigma[v] * coeff</span>
<span class="gi">+        if w != s:</span>
<span class="gi">+            # percolation weight</span>
<span class="gi">+            pw_s_w = states[s] / (p_sigma_x_t - states[w])</span>
<span class="gi">+            percolation[w] += delta[w] * pw_s_w</span>
<span class="gi">+    return percolation</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/reaching.py b/networkx/algorithms/centrality/reaching.py</span>
<span class="gh">index 43ee40112..93cb75a96 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/reaching.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/reaching.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing reaching centrality of a node or a graph.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import pairwise
<span class="gd">-__all__ = [&#39;global_reaching_centrality&#39;, &#39;local_reaching_centrality&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;global_reaching_centrality&quot;, &quot;local_reaching_centrality&quot;]</span>


<span class="w"> </span>def _average_weight(G, path, weight=None):
<span class="gu">@@ -20,10 +22,16 @@ def _average_weight(G, path, weight=None):</span>
<span class="w"> </span>      is assumed to be the multiplicative inverse of the length of the path.
<span class="w"> </span>      Otherwise holds the name of the edge attribute used as weight.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path_length = len(path) - 1</span>
<span class="gi">+    if path_length &lt;= 0:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    if weight is None:</span>
<span class="gi">+        return 1 / path_length</span>
<span class="gi">+    total_weight = sum(G.edges[i, j][weight] for i, j in pairwise(path))</span>
<span class="gi">+    return total_weight / path_length</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def global_reaching_centrality(G, weight=None, normalized=True):
<span class="w"> </span>    &quot;&quot;&quot;Returns the global reaching centrality of a directed graph.

<span class="gu">@@ -76,10 +84,42 @@ def global_reaching_centrality(G, weight=None, normalized=True):</span>
<span class="w"> </span>           *PLoS ONE* 7.3 (2012): e33799.
<span class="w"> </span>           https://doi.org/10.1371/journal.pone.0033799
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    if nx.is_negatively_weighted(G, weight=weight):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;edge weights must be positive&quot;)</span>
<span class="gi">+    total_weight = G.size(weight=weight)</span>
<span class="gi">+    if total_weight &lt;= 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Size of G must be positive&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # If provided, weights must be interpreted as connection strength</span>
<span class="gi">+    # (so higher weights are more likely to be chosen). However, the</span>
<span class="gi">+    # shortest path algorithms in NetworkX assume the provided &quot;weight&quot;</span>
<span class="gi">+    # is actually a distance (so edges with higher weight are less</span>
<span class="gi">+    # likely to be chosen). Therefore we need to invert the weights when</span>
<span class="gi">+    # computing shortest paths.</span>
<span class="gi">+    #</span>
<span class="gi">+    # If weight is None, we leave it as-is so that the shortest path</span>
<span class="gi">+    # algorithm can use a faster, unweighted algorithm.</span>
<span class="gi">+    if weight is not None:</span>
<span class="gi">+</span>
<span class="gi">+        def as_distance(u, v, d):</span>
<span class="gi">+            return total_weight / d.get(weight, 1)</span>
<span class="gi">+</span>
<span class="gi">+        shortest_paths = nx.shortest_path(G, weight=as_distance)</span>
<span class="gi">+    else:</span>
<span class="gi">+        shortest_paths = nx.shortest_path(G)</span>
<span class="gi">+</span>
<span class="gi">+    centrality = local_reaching_centrality</span>
<span class="gi">+    # TODO This can be trivially parallelized.</span>
<span class="gi">+    lrc = [</span>
<span class="gi">+        centrality(G, node, paths=paths, weight=weight, normalized=normalized)</span>
<span class="gi">+        for node, paths in shortest_paths.items()</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    max_lrc = max(lrc)</span>
<span class="gi">+    return sum(max_lrc - c for c in lrc) / (len(G) - 1)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def local_reaching_centrality(G, v, paths=None, weight=None, normalized=True):
<span class="w"> </span>    &quot;&quot;&quot;Returns the local reaching centrality of a node in a directed
<span class="w"> </span>    graph.
<span class="gu">@@ -138,4 +178,29 @@ def local_reaching_centrality(G, v, paths=None, weight=None, normalized=True):</span>
<span class="w"> </span>           *PLoS ONE* 7.3 (2012): e33799.
<span class="w"> </span>           https://doi.org/10.1371/journal.pone.0033799
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if paths is None:</span>
<span class="gi">+        if nx.is_negatively_weighted(G, weight=weight):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;edge weights must be positive&quot;)</span>
<span class="gi">+        total_weight = G.size(weight=weight)</span>
<span class="gi">+        if total_weight &lt;= 0:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Size of G must be positive&quot;)</span>
<span class="gi">+        if weight is not None:</span>
<span class="gi">+            # Interpret weights as lengths.</span>
<span class="gi">+            def as_distance(u, v, d):</span>
<span class="gi">+                return total_weight / d.get(weight, 1)</span>
<span class="gi">+</span>
<span class="gi">+            paths = nx.shortest_path(G, source=v, weight=as_distance)</span>
<span class="gi">+        else:</span>
<span class="gi">+            paths = nx.shortest_path(G, source=v)</span>
<span class="gi">+    # If the graph is unweighted, simply return the proportion of nodes</span>
<span class="gi">+    # reachable from the source node ``v``.</span>
<span class="gi">+    if weight is None and G.is_directed():</span>
<span class="gi">+        return (len(paths) - 1) / (len(G) - 1)</span>
<span class="gi">+    if normalized and weight is not None:</span>
<span class="gi">+        norm = G.size(weight=weight) / G.size()</span>
<span class="gi">+    else:</span>
<span class="gi">+        norm = 1</span>
<span class="gi">+    # TODO This can be trivially parallelized.</span>
<span class="gi">+    avgw = (_average_weight(G, path, weight=weight) for path in paths.values())</span>
<span class="gi">+    sum_avg_weight = sum(avgw) / norm</span>
<span class="gi">+    return sum_avg_weight / (len(G) - 1)</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/second_order.py b/networkx/algorithms/centrality/second_order.py</span>
<span class="gh">index 65074a214..35583cd63 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/second_order.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/second_order.py</span>
<span class="gu">@@ -29,14 +29,18 @@ WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE</span>
<span class="w"> </span>OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
<span class="w"> </span>IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;second_order_centrality&#39;]</span>
<span class="gi">+</span>
<span class="gi">+# Authors: Erwan Le Merrer (erwan.lemerrer@technicolor.com)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;second_order_centrality&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def second_order_centrality(G, weight=&#39;weight&#39;):</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def second_order_centrality(G, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute the second order centrality for nodes of G.

<span class="w"> </span>    The second order centrality of a given node is the standard deviation of
<span class="gu">@@ -95,4 +99,43 @@ def second_order_centrality(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>       &quot;Second order centrality: Distributed assessment of nodes criticity in
<span class="w"> </span>       complex networks&quot;, Elsevier Computer Communications 34(5):619-628, 2011.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        raise nx.NetworkXException(&quot;Empty graph.&quot;)</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXException(&quot;Non connected graph.&quot;)</span>
<span class="gi">+    if any(d.get(weight, 0) &lt; 0 for u, v, d in G.edges(data=True)):</span>
<span class="gi">+        raise nx.NetworkXException(&quot;Graph has negative edge weights.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # balancing G for Metropolis-Hastings random walks</span>
<span class="gi">+    G = nx.DiGraph(G)</span>
<span class="gi">+    in_deg = dict(G.in_degree(weight=weight))</span>
<span class="gi">+    d_max = max(in_deg.values())</span>
<span class="gi">+    for i, deg in in_deg.items():</span>
<span class="gi">+        if deg &lt; d_max:</span>
<span class="gi">+            G.add_edge(i, i, weight=d_max - deg)</span>
<span class="gi">+</span>
<span class="gi">+    P = nx.to_numpy_array(G)</span>
<span class="gi">+    P /= P.sum(axis=1)[:, np.newaxis]  # to transition probability matrix</span>
<span class="gi">+</span>
<span class="gi">+    def _Qj(P, j):</span>
<span class="gi">+        P = P.copy()</span>
<span class="gi">+        P[:, j] = 0</span>
<span class="gi">+        return P</span>
<span class="gi">+</span>
<span class="gi">+    M = np.empty([n, n])</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(n):</span>
<span class="gi">+        M[:, i] = np.linalg.solve(</span>
<span class="gi">+            np.identity(n) - _Qj(P, i), np.ones([n, 1])[:, 0]</span>
<span class="gi">+        )  # eq 3</span>
<span class="gi">+</span>
<span class="gi">+    return dict(</span>
<span class="gi">+        zip(</span>
<span class="gi">+            G.nodes,</span>
<span class="gi">+            (float(np.sqrt(2 * np.sum(M[:, i]) - n * (n + 1))) for i in range(n)),</span>
<span class="gi">+        )</span>
<span class="gi">+    )  # eq 6</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/subgraph_alg.py b/networkx/algorithms/centrality/subgraph_alg.py</span>
<span class="gh">index a8adc1c6f..29a284c54 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/subgraph_alg.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/subgraph_alg.py</span>
<span class="gu">@@ -3,15 +3,20 @@ Subraph centrality and communicability betweenness.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;subgraph_centrality_exp&#39;, &#39;subgraph_centrality&#39;,</span>
<span class="gd">-    &#39;communicability_betweenness_centrality&#39;, &#39;estrada_index&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;subgraph_centrality_exp&quot;,</span>
<span class="gi">+    &quot;subgraph_centrality&quot;,</span>
<span class="gi">+    &quot;communicability_betweenness_centrality&quot;,</span>
<span class="gi">+    &quot;estrada_index&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def subgraph_centrality_exp(G):
<span class="gd">-    &quot;&quot;&quot;Returns the subgraph centrality for each node of G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the subgraph centrality for each node of G.</span>

<span class="w"> </span>    Subgraph centrality  of a node `n` is the sum of weighted closed
<span class="w"> </span>    walks of all lengths starting and ending at node `n`. The weights
<span class="gu">@@ -78,14 +83,24 @@ def subgraph_centrality_exp(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; print([f&quot;{node} {sc[node]:0.2f}&quot; for node in sorted(sc)])
<span class="w"> </span>    [&#39;1 3.90&#39;, &#39;2 3.90&#39;, &#39;3 3.64&#39;, &#39;4 3.71&#39;, &#39;5 3.64&#39;, &#39;6 3.71&#39;, &#39;7 3.64&#39;, &#39;8 3.90&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # alternative implementation that calculates the matrix exponential</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    nodelist = list(G)  # ordering of nodes in matrix</span>
<span class="gi">+    A = nx.to_numpy_array(G, nodelist)</span>
<span class="gi">+    # convert to 0-1 matrix</span>
<span class="gi">+    A[A != 0.0] = 1</span>
<span class="gi">+    expA = sp.linalg.expm(A)</span>
<span class="gi">+    # convert diagonal to dictionary keyed by node</span>
<span class="gi">+    sc = dict(zip(nodelist, map(float, expA.diagonal())))</span>
<span class="gi">+    return sc</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def subgraph_centrality(G):
<span class="gd">-    &quot;&quot;&quot;Returns subgraph centrality for each node in G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns subgraph centrality for each node in G.</span>

<span class="w"> </span>    Subgraph centrality  of a node `n` is the sum of weighted closed
<span class="w"> </span>    walks of all lengths starting and ending at node `n`. The weights
<span class="gu">@@ -121,10 +136,10 @@ def subgraph_centrality(G):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       SC(u)=\\sum_{j=1}^{N}(v_{j}^{u})^2 e^{\\lambda_{j}},</span>
<span class="gi">+       SC(u)=\sum_{j=1}^{N}(v_{j}^{u})^2 e^{\lambda_{j}},</span>

<span class="w"> </span>    where `v_j` is an eigenvector of the adjacency matrix `A` of G
<span class="gd">-    corresponding to the eigenvalue `\\lambda_j`.</span>
<span class="gi">+    corresponding to the eigenvalue `\lambda_j`.</span>

<span class="w"> </span>    Examples
<span class="w"> </span>    --------
<span class="gu">@@ -157,14 +172,26 @@ def subgraph_centrality(G):</span>
<span class="w"> </span>       https://arxiv.org/abs/cond-mat/0504730

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    nodelist = list(G)  # ordering of nodes in matrix</span>
<span class="gi">+    A = nx.to_numpy_array(G, nodelist)</span>
<span class="gi">+    # convert to 0-1 matrix</span>
<span class="gi">+    A[np.nonzero(A)] = 1</span>
<span class="gi">+    w, v = np.linalg.eigh(A)</span>
<span class="gi">+    vsquare = np.array(v) ** 2</span>
<span class="gi">+    expw = np.exp(w)</span>
<span class="gi">+    xg = vsquare @ expw</span>
<span class="gi">+    # convert vector dictionary keyed by node</span>
<span class="gi">+    sc = dict(zip(nodelist, map(float, xg)))</span>
<span class="gi">+    return sc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def communicability_betweenness_centrality(G):
<span class="gd">-    &quot;&quot;&quot;Returns subgraph communicability for all pairs of nodes in G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns subgraph communicability for all pairs of nodes in G.</span>

<span class="w"> </span>    Communicability betweenness measure makes use of the number of walks
<span class="w"> </span>    connecting every pair of nodes as the basis of a betweenness centrality
<span class="gu">@@ -199,8 +226,8 @@ def communicability_betweenness_centrality(G):</span>

<span class="w"> </span>    .. math::

<span class="gd">-         \\omega_{r} = \\frac{1}{C}\\sum_{p}\\sum_{q}\\frac{G_{prq}}{G_{pq}},</span>
<span class="gd">-         p\\neq q, q\\neq r,</span>
<span class="gi">+         \omega_{r} = \frac{1}{C}\sum_{p}\sum_{q}\frac{G_{prq}}{G_{pq}},</span>
<span class="gi">+         p\neq q, q\neq r,</span>

<span class="w"> </span>    where
<span class="w"> </span>    `G_{prq}=(e^{A}_{pq} - (e^{A+E(r)})_{pq}`  is the number of walks
<span class="gu">@@ -210,7 +237,7 @@ def communicability_betweenness_centrality(G):</span>
<span class="w"> </span>    and `C=(n-1)^{2}-(n-1)` is a normalization factor equal to the
<span class="w"> </span>    number of terms in the sum.

<span class="gd">-    The resulting `\\omega_{r}` takes values between zero and one.</span>
<span class="gi">+    The resulting `\omega_{r}` takes values between zero and one.</span>
<span class="w"> </span>    The lower bound cannot be attained for a connected
<span class="w"> </span>    graph, and the upper bound is attained in the star graph.

<span class="gu">@@ -228,12 +255,44 @@ def communicability_betweenness_centrality(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; print([f&quot;{node} {cbc[node]:0.2f}&quot; for node in sorted(cbc)])
<span class="w"> </span>    [&#39;0 0.03&#39;, &#39;1 0.45&#39;, &#39;2 0.51&#39;, &#39;3 0.45&#39;, &#39;4 0.40&#39;, &#39;5 0.19&#39;, &#39;6 0.03&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    nodelist = list(G)  # ordering of nodes in matrix</span>
<span class="gi">+    n = len(nodelist)</span>
<span class="gi">+    A = nx.to_numpy_array(G, nodelist)</span>
<span class="gi">+    # convert to 0-1 matrix</span>
<span class="gi">+    A[np.nonzero(A)] = 1</span>
<span class="gi">+    expA = sp.linalg.expm(A)</span>
<span class="gi">+    mapping = dict(zip(nodelist, range(n)))</span>
<span class="gi">+    cbc = {}</span>
<span class="gi">+    for v in G:</span>
<span class="gi">+        # remove row and col of node v</span>
<span class="gi">+        i = mapping[v]</span>
<span class="gi">+        row = A[i, :].copy()</span>
<span class="gi">+        col = A[:, i].copy()</span>
<span class="gi">+        A[i, :] = 0</span>
<span class="gi">+        A[:, i] = 0</span>
<span class="gi">+        B = (expA - sp.linalg.expm(A)) / expA</span>
<span class="gi">+        # sum with row/col of node v and diag set to zero</span>
<span class="gi">+        B[i, :] = 0</span>
<span class="gi">+        B[:, i] = 0</span>
<span class="gi">+        B -= np.diag(np.diag(B))</span>
<span class="gi">+        cbc[v] = float(B.sum())</span>
<span class="gi">+        # put row and col back</span>
<span class="gi">+        A[i, :] = row</span>
<span class="gi">+        A[:, i] = col</span>
<span class="gi">+    # rescale when more than two nodes</span>
<span class="gi">+    order = len(cbc)</span>
<span class="gi">+    if order &gt; 2:</span>
<span class="gi">+        scale = 1.0 / ((order - 1.0) ** 2 - (order - 1.0))</span>
<span class="gi">+        cbc = {node: value * scale for node, value in cbc.items()}</span>
<span class="gi">+    return cbc</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def estrada_index(G):
<span class="gd">-    &quot;&quot;&quot;Returns the Estrada index of a the graph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Estrada index of a the graph G.</span>

<span class="w"> </span>    The Estrada Index is a topological index of folding or 3D &quot;compactness&quot; ([1]_).

<span class="gu">@@ -253,12 +312,12 @@ def estrada_index(G):</span>
<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="w"> </span>    Let `G=(V,E)` be a simple undirected graph with `n` nodes  and let
<span class="gd">-    `\\lambda_{1}\\leq\\lambda_{2}\\leq\\cdots\\lambda_{n}`</span>
<span class="gi">+    `\lambda_{1}\leq\lambda_{2}\leq\cdots\lambda_{n}`</span>
<span class="w"> </span>    be a non-increasing ordering of the eigenvalues of its adjacency
<span class="w"> </span>    matrix `A`. The Estrada index is ([1]_, [2]_)

<span class="w"> </span>    .. math::
<span class="gd">-        EE(G)=\\sum_{j=1}^n e^{\\lambda _j}.</span>
<span class="gi">+        EE(G)=\sum_{j=1}^n e^{\lambda _j}.</span>

<span class="w"> </span>    References
<span class="w"> </span>    ----------
<span class="gu">@@ -277,4 +336,4 @@ def estrada_index(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; print(f&quot;{ei:0.5}&quot;)
<span class="w"> </span>    20.55
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(subgraph_centrality(G).values())</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/trophic.py b/networkx/algorithms/centrality/trophic.py</span>
<span class="gh">index f983383bd..6d1ba960b 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/trophic.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/trophic.py</span>
<span class="gu">@@ -1,26 +1,26 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Trophic levels&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;trophic_levels&#39;, &#39;trophic_differences&#39;,</span>
<span class="gd">-    &#39;trophic_incoherence_parameter&#39;]</span>

<span class="gi">+__all__ = [&quot;trophic_levels&quot;, &quot;trophic_differences&quot;, &quot;trophic_incoherence_parameter&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def trophic_levels(G, weight=&#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the trophic levels of nodes.</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def trophic_levels(G, weight=&quot;weight&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the trophic levels of nodes.</span>

<span class="w"> </span>    The trophic level of a node $i$ is

<span class="w"> </span>    .. math::

<span class="gd">-        s_i = 1 + \\frac{1}{k^{in}_i} \\sum_{j} a_{ij} s_j</span>
<span class="gi">+        s_i = 1 + \frac{1}{k^{in}_i} \sum_{j} a_{ij} s_j</span>

<span class="w"> </span>    where $k^{in}_i$ is the in-degree of i

<span class="w"> </span>    .. math::

<span class="gd">-        k^{in}_i = \\sum_{j} a_{ij}</span>
<span class="gi">+        k^{in}_i = \sum_{j} a_{ij}</span>

<span class="w"> </span>    and nodes with $k^{in}_i = 0$ have $s_i = 1$ by convention.

<span class="gu">@@ -40,13 +40,51 @@ def trophic_levels(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] Stephen Levine (1980) J. theor. Biol. 83, 195-207
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def trophic_differences(G, weight=&#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the trophic differences of the edges of a directed graph.</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    # find adjacency matrix</span>
<span class="gi">+    a = nx.adjacency_matrix(G, weight=weight).T.toarray()</span>
<span class="gi">+</span>
<span class="gi">+    # drop rows/columns where in-degree is zero</span>
<span class="gi">+    rowsum = np.sum(a, axis=1)</span>
<span class="gi">+    p = a[rowsum != 0][:, rowsum != 0]</span>
<span class="gi">+    # normalise so sum of in-degree weights is 1 along each row</span>
<span class="gi">+    p = p / rowsum[rowsum != 0][:, np.newaxis]</span>
<span class="gi">+</span>
<span class="gi">+    # calculate trophic levels</span>
<span class="gi">+    nn = p.shape[0]</span>
<span class="gi">+    i = np.eye(nn)</span>
<span class="gi">+    try:</span>
<span class="gi">+        n = np.linalg.inv(i - p)</span>
<span class="gi">+    except np.linalg.LinAlgError as err:</span>
<span class="gi">+        # LinAlgError is raised when there is a non-basal node</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Trophic levels are only defined for graphs where every &quot;</span>
<span class="gi">+            + &quot;node has a path from a basal node (basal nodes are nodes &quot;</span>
<span class="gi">+            + &quot;with no incoming edges).&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise nx.NetworkXError(msg) from err</span>
<span class="gi">+    y = n.sum(axis=1) + 1</span>
<span class="gi">+</span>
<span class="gi">+    levels = {}</span>
<span class="gi">+</span>
<span class="gi">+    # all nodes with in-degree zero have trophic level == 1</span>
<span class="gi">+    zero_node_ids = (node_id for node_id, degree in G.in_degree if degree == 0)</span>
<span class="gi">+    for node_id in zero_node_ids:</span>
<span class="gi">+        levels[node_id] = 1</span>
<span class="gi">+</span>
<span class="gi">+    # all other nodes have levels as calculated</span>
<span class="gi">+    nonzero_node_ids = (node_id for node_id, degree in G.in_degree if degree != 0)</span>
<span class="gi">+    for i, node_id in enumerate(nonzero_node_ids):</span>
<span class="gi">+        levels[node_id] = y.item(i)</span>
<span class="gi">+</span>
<span class="gi">+    return levels</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def trophic_differences(G, weight=&quot;weight&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the trophic differences of the edges of a directed graph.</span>

<span class="w"> </span>    The trophic difference $x_ij$ for each edge is defined in Johnson et al.
<span class="w"> </span>    [1]_ as:
<span class="gu">@@ -71,13 +109,17 @@ def trophic_differences(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.
<span class="w"> </span>        Munoz (2014) PNAS &quot;Trophic coherence determines food-web stability&quot;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    levels = trophic_levels(G, weight=weight)</span>
<span class="gi">+    diffs = {}</span>
<span class="gi">+    for u, v in G.edges:</span>
<span class="gi">+        diffs[(u, v)] = levels[v] - levels[u]</span>
<span class="gi">+    return diffs</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def trophic_incoherence_parameter(G, weight=&#39;weight&#39;, cannibalism=False):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the trophic incoherence parameter of a graph.</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def trophic_incoherence_parameter(G, weight=&quot;weight&quot;, cannibalism=False):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the trophic incoherence parameter of a graph.</span>

<span class="w"> </span>    Trophic coherence is defined as the homogeneity of the distribution of
<span class="w"> </span>    trophic distances: the more similar, the more coherent. This is measured by
<span class="gu">@@ -102,4 +144,19 @@ def trophic_incoherence_parameter(G, weight=&#39;weight&#39;, cannibalism=False):</span>
<span class="w"> </span>    .. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.
<span class="w"> </span>        Munoz (2014) PNAS &quot;Trophic coherence determines food-web stability&quot;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if cannibalism:</span>
<span class="gi">+        diffs = trophic_differences(G, weight=weight)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # If no cannibalism, remove self-edges</span>
<span class="gi">+        self_loops = list(nx.selfloop_edges(G))</span>
<span class="gi">+        if self_loops:</span>
<span class="gi">+            # Make a copy so we do not change G&#39;s edges in memory</span>
<span class="gi">+            G_2 = G.copy()</span>
<span class="gi">+            G_2.remove_edges_from(self_loops)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Avoid copy otherwise</span>
<span class="gi">+            G_2 = G</span>
<span class="gi">+        diffs = trophic_differences(G_2, weight=weight)</span>
<span class="gi">+    return float(np.std(list(diffs.values())))</span>
<span class="gh">diff --git a/networkx/algorithms/centrality/voterank_alg.py b/networkx/algorithms/centrality/voterank_alg.py</span>
<span class="gh">index 4cd3a4034..063dfdd64 100644</span>
<span class="gd">--- a/networkx/algorithms/centrality/voterank_alg.py</span>
<span class="gi">+++ b/networkx/algorithms/centrality/voterank_alg.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Algorithm to select influential nodes in a graph using VoteRank.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;voterank&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;voterank&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -51,4 +52,43 @@ def voterank(G, number_of_nodes=None):</span>
<span class="w"> </span>        Identifying a set of influential spreaders in complex networks.
<span class="w"> </span>        Sci. Rep. 6, 27823; doi: 10.1038/srep27823.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    influential_nodes = []</span>
<span class="gi">+    vote_rank = {}</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return influential_nodes</span>
<span class="gi">+    if number_of_nodes is None or number_of_nodes &gt; len(G):</span>
<span class="gi">+        number_of_nodes = len(G)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        # For directed graphs compute average out-degree</span>
<span class="gi">+        avgDegree = sum(deg for _, deg in G.out_degree()) / len(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # For undirected graphs compute average degree</span>
<span class="gi">+        avgDegree = sum(deg for _, deg in G.degree()) / len(G)</span>
<span class="gi">+    # step 1 - initiate all nodes to (0,1) (score, voting ability)</span>
<span class="gi">+    for n in G.nodes():</span>
<span class="gi">+        vote_rank[n] = [0, 1]</span>
<span class="gi">+    # Repeat steps 1b to 4 until num_seeds are elected.</span>
<span class="gi">+    for _ in range(number_of_nodes):</span>
<span class="gi">+        # step 1b - reset rank</span>
<span class="gi">+        for n in G.nodes():</span>
<span class="gi">+            vote_rank[n][0] = 0</span>
<span class="gi">+        # step 2 - vote</span>
<span class="gi">+        for n, nbr in G.edges():</span>
<span class="gi">+            # In directed graphs nodes only vote for their in-neighbors</span>
<span class="gi">+            vote_rank[n][0] += vote_rank[nbr][1]</span>
<span class="gi">+            if not G.is_directed():</span>
<span class="gi">+                vote_rank[nbr][0] += vote_rank[n][1]</span>
<span class="gi">+        for n in influential_nodes:</span>
<span class="gi">+            vote_rank[n][0] = 0</span>
<span class="gi">+        # step 3 - select top node</span>
<span class="gi">+        n = max(G.nodes, key=lambda x: vote_rank[x][0])</span>
<span class="gi">+        if vote_rank[n][0] == 0:</span>
<span class="gi">+            return influential_nodes</span>
<span class="gi">+        influential_nodes.append(n)</span>
<span class="gi">+        # weaken the selected node</span>
<span class="gi">+        vote_rank[n] = [0, 0]</span>
<span class="gi">+        # step 4 - update voterank properties</span>
<span class="gi">+        for _, nbr in G.edges(n):</span>
<span class="gi">+            vote_rank[nbr][1] -= 1 / avgDegree</span>
<span class="gi">+            vote_rank[nbr][1] = max(vote_rank[nbr][1], 0)</span>
<span class="gi">+    return influential_nodes</span>
<span class="gh">diff --git a/networkx/algorithms/chains.py b/networkx/algorithms/chains.py</span>
<span class="gh">index 05f01ed84..ae342d9c8 100644</span>
<span class="gd">--- a/networkx/algorithms/chains.py</span>
<span class="gi">+++ b/networkx/algorithms/chains.py</span>
<span class="gu">@@ -1,11 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for finding chains in a graph.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;chain_decomposition&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;chain_decomposition&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def chain_decomposition(G, root=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the chain decomposition of a graph.
<span class="gu">@@ -61,4 +63,110 @@ def chain_decomposition(G, root=None):</span>
<span class="w"> </span>       113, 241–244. Elsevier. &lt;https://doi.org/10.1016/j.ipl.2013.01.016&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _dfs_cycle_forest(G, root=None):</span>
<span class="gi">+        &quot;&quot;&quot;Builds a directed graph composed of cycles from the given graph.</span>
<span class="gi">+</span>
<span class="gi">+        `G` is an undirected simple graph. `root` is a node in the graph</span>
<span class="gi">+        from which the depth-first search is started.</span>
<span class="gi">+</span>
<span class="gi">+        This function returns both the depth-first search cycle graph</span>
<span class="gi">+        (as a :class:`~networkx.DiGraph`) and the list of nodes in</span>
<span class="gi">+        depth-first preorder. The depth-first search cycle graph is a</span>
<span class="gi">+        directed graph whose edges are the edges of `G` oriented toward</span>
<span class="gi">+        the root if the edge is a tree edge and away from the root if</span>
<span class="gi">+        the edge is a non-tree edge. If `root` is not specified, this</span>
<span class="gi">+        performs a depth-first search on each connected component of `G`</span>
<span class="gi">+        and returns a directed forest instead.</span>
<span class="gi">+</span>
<span class="gi">+        If `root` is not in the graph, this raises :exc:`KeyError`.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Create a directed graph from the depth-first search tree with</span>
<span class="gi">+        # root node `root` in which tree edges are directed toward the</span>
<span class="gi">+        # root and nontree edges are directed away from the root. For</span>
<span class="gi">+        # each node with an incident nontree edge, this creates a</span>
<span class="gi">+        # directed cycle starting with the nontree edge and returning to</span>
<span class="gi">+        # that node.</span>
<span class="gi">+        #</span>
<span class="gi">+        # The `parent` node attribute stores the parent of each node in</span>
<span class="gi">+        # the DFS tree. The `nontree` edge attribute indicates whether</span>
<span class="gi">+        # the edge is a tree edge or a nontree edge.</span>
<span class="gi">+        #</span>
<span class="gi">+        # We also store the order of the nodes found in the depth-first</span>
<span class="gi">+        # search in the `nodes` list.</span>
<span class="gi">+        H = nx.DiGraph()</span>
<span class="gi">+        nodes = []</span>
<span class="gi">+        for u, v, d in nx.dfs_labeled_edges(G, source=root):</span>
<span class="gi">+            if d == &quot;forward&quot;:</span>
<span class="gi">+                # `dfs_labeled_edges()` yields (root, root, &#39;forward&#39;)</span>
<span class="gi">+                # if it is beginning the search on a new connected</span>
<span class="gi">+                # component.</span>
<span class="gi">+                if u == v:</span>
<span class="gi">+                    H.add_node(v, parent=None)</span>
<span class="gi">+                    nodes.append(v)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    H.add_node(v, parent=u)</span>
<span class="gi">+                    H.add_edge(v, u, nontree=False)</span>
<span class="gi">+                    nodes.append(v)</span>
<span class="gi">+            # `dfs_labeled_edges` considers nontree edges in both</span>
<span class="gi">+            # orientations, so we need to not add the edge if it its</span>
<span class="gi">+            # other orientation has been added.</span>
<span class="gi">+            elif d == &quot;nontree&quot; and v not in H[u]:</span>
<span class="gi">+                H.add_edge(v, u, nontree=True)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Do nothing on &#39;reverse&#39; edges; we only care about</span>
<span class="gi">+                # forward and nontree edges.</span>
<span class="gi">+                pass</span>
<span class="gi">+        return H, nodes</span>
<span class="gi">+</span>
<span class="gi">+    def _build_chain(G, u, v, visited):</span>
<span class="gi">+        &quot;&quot;&quot;Generate the chain starting from the given nontree edge.</span>
<span class="gi">+</span>
<span class="gi">+        `G` is a DFS cycle graph as constructed by</span>
<span class="gi">+        :func:`_dfs_cycle_graph`. The edge (`u`, `v`) is a nontree edge</span>
<span class="gi">+        that begins a chain. `visited` is a set representing the nodes</span>
<span class="gi">+        in `G` that have already been visited.</span>
<span class="gi">+</span>
<span class="gi">+        This function yields the edges in an initial segment of the</span>
<span class="gi">+        fundamental cycle of `G` starting with the nontree edge (`u`,</span>
<span class="gi">+        `v`) that includes all the edges up until the first node that</span>
<span class="gi">+        appears in `visited`. The tree edges are given by the &#39;parent&#39;</span>
<span class="gi">+        node attribute. The `visited` set is updated to add each node in</span>
<span class="gi">+        an edge yielded by this function.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        while v not in visited:</span>
<span class="gi">+            yield u, v</span>
<span class="gi">+            visited.add(v)</span>
<span class="gi">+            u, v = v, G.nodes[v][&quot;parent&quot;]</span>
<span class="gi">+        yield u, v</span>
<span class="gi">+</span>
<span class="gi">+    # Check if the root is in the graph G. If not, raise NodeNotFound</span>
<span class="gi">+    if root is not None and root not in G:</span>
<span class="gi">+        raise nx.NodeNotFound(f&quot;Root node {root} is not in graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Create a directed version of H that has the DFS edges directed</span>
<span class="gi">+    # toward the root and the nontree edges directed away from the root</span>
<span class="gi">+    # (in each connected component).</span>
<span class="gi">+    H, nodes = _dfs_cycle_forest(G, root)</span>
<span class="gi">+</span>
<span class="gi">+    # Visit the nodes again in DFS order. For each node, and for each</span>
<span class="gi">+    # nontree edge leaving that node, compute the fundamental cycle for</span>
<span class="gi">+    # that nontree edge starting with that edge. If the fundamental</span>
<span class="gi">+    # cycle overlaps with any visited nodes, just take the prefix of the</span>
<span class="gi">+    # cycle up to the point of visited nodes.</span>
<span class="gi">+    #</span>
<span class="gi">+    # We repeat this process for each connected component (implicitly,</span>
<span class="gi">+    # since `nodes` already has a list of the nodes grouped by connected</span>
<span class="gi">+    # component).</span>
<span class="gi">+    visited = set()</span>
<span class="gi">+    for u in nodes:</span>
<span class="gi">+        visited.add(u)</span>
<span class="gi">+        # For each nontree edge going out of node u...</span>
<span class="gi">+        edges = ((u, v) for u, v, d in H.out_edges(u, data=&quot;nontree&quot;) if d)</span>
<span class="gi">+        for u, v in edges:</span>
<span class="gi">+            # Create the cycle or cycle prefix starting with the</span>
<span class="gi">+            # nontree edge.</span>
<span class="gi">+            chain = list(_build_chain(H, u, v, visited))</span>
<span class="gi">+            yield chain</span>
<span class="gh">diff --git a/networkx/algorithms/chordal.py b/networkx/algorithms/chordal.py</span>
<span class="gh">index ec2d178bd..6bd3ccd2e 100644</span>
<span class="gd">--- a/networkx/algorithms/chordal.py</span>
<span class="gi">+++ b/networkx/algorithms/chordal.py</span>
<span class="gu">@@ -6,12 +6,19 @@ A graph is chordal if every cycle of length at least 4 has a chord</span>
<span class="w"> </span>https://en.wikipedia.org/wiki/Chordal_graph
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.components import connected_components
<span class="w"> </span>from networkx.utils import arbitrary_element, not_implemented_for
<span class="gd">-__all__ = [&#39;is_chordal&#39;, &#39;find_induced_nodes&#39;, &#39;chordal_graph_cliques&#39;,</span>
<span class="gd">-    &#39;chordal_graph_treewidth&#39;, &#39;NetworkXTreewidthBoundExceeded&#39;,</span>
<span class="gd">-    &#39;complete_to_chordal_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;is_chordal&quot;,</span>
<span class="gi">+    &quot;find_induced_nodes&quot;,</span>
<span class="gi">+    &quot;chordal_graph_cliques&quot;,</span>
<span class="gi">+    &quot;chordal_graph_treewidth&quot;,</span>
<span class="gi">+    &quot;NetworkXTreewidthBoundExceeded&quot;,</span>
<span class="gi">+    &quot;complete_to_chordal_graph&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class NetworkXTreewidthBoundExceeded(nx.NetworkXException):
<span class="gu">@@ -19,8 +26,8 @@ class NetworkXTreewidthBoundExceeded(nx.NetworkXException):</span>
<span class="w"> </span>    been exceeded&quot;&quot;&quot;


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_chordal(G):
<span class="w"> </span>    &quot;&quot;&quot;Checks whether G is a chordal graph.
<span class="gu">@@ -76,7 +83,9 @@ def is_chordal(G):</span>
<span class="w"> </span>       selectively reduce acyclic hypergraphs, SIAM J. Comput., 13 (1984),
<span class="w"> </span>       pp. 566–579.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G.nodes) &lt;= 3:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return len(_find_chordality_breaker(G)) == 0</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -135,7 +144,28 @@ def find_induced_nodes(G, s, t, treewidth_bound=sys.maxsize):</span>
<span class="w"> </span>       Gal Elidan, Stephen Gould; JMLR, 9(Dec):2699--2731, 2008.
<span class="w"> </span>       http://jmlr.csail.mit.edu/papers/volume9/elidan08a/elidan08a.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not is_chordal(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Input graph is not chordal.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    H = nx.Graph(G)</span>
<span class="gi">+    H.add_edge(s, t)</span>
<span class="gi">+    induced_nodes = set()</span>
<span class="gi">+    triplet = _find_chordality_breaker(H, s, treewidth_bound)</span>
<span class="gi">+    while triplet:</span>
<span class="gi">+        (u, v, w) = triplet</span>
<span class="gi">+        induced_nodes.update(triplet)</span>
<span class="gi">+        for n in triplet:</span>
<span class="gi">+            if n != s:</span>
<span class="gi">+                H.add_edge(s, n)</span>
<span class="gi">+        triplet = _find_chordality_breaker(H, s, treewidth_bound)</span>
<span class="gi">+    if induced_nodes:</span>
<span class="gi">+        # Add t and the second node in the induced path from s to t.</span>
<span class="gi">+        induced_nodes.add(t)</span>
<span class="gi">+        for u in G[s]:</span>
<span class="gi">+            if len(induced_nodes &amp; set(G[u])) == 2:</span>
<span class="gi">+                induced_nodes.add(u)</span>
<span class="gi">+                break</span>
<span class="gi">+    return induced_nodes</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -184,7 +214,31 @@ def chordal_graph_cliques(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; cliques[0]
<span class="w"> </span>    frozenset({1, 2, 3})
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for C in (G.subgraph(c).copy() for c in connected_components(G)):</span>
<span class="gi">+        if C.number_of_nodes() == 1:</span>
<span class="gi">+            if nx.number_of_selfloops(C) &gt; 0:</span>
<span class="gi">+                raise nx.NetworkXError(&quot;Input graph is not chordal.&quot;)</span>
<span class="gi">+            yield frozenset(C.nodes())</span>
<span class="gi">+        else:</span>
<span class="gi">+            unnumbered = set(C.nodes())</span>
<span class="gi">+            v = arbitrary_element(C)</span>
<span class="gi">+            unnumbered.remove(v)</span>
<span class="gi">+            numbered = {v}</span>
<span class="gi">+            clique_wanna_be = {v}</span>
<span class="gi">+            while unnumbered:</span>
<span class="gi">+                v = _max_cardinality_node(C, unnumbered, numbered)</span>
<span class="gi">+                unnumbered.remove(v)</span>
<span class="gi">+                numbered.add(v)</span>
<span class="gi">+                new_clique_wanna_be = set(C.neighbors(v)) &amp; numbered</span>
<span class="gi">+                sg = C.subgraph(clique_wanna_be)</span>
<span class="gi">+                if _is_complete_graph(sg):</span>
<span class="gi">+                    new_clique_wanna_be.add(v)</span>
<span class="gi">+                    if not new_clique_wanna_be &gt;= clique_wanna_be:</span>
<span class="gi">+                        yield frozenset(clique_wanna_be)</span>
<span class="gi">+                    clique_wanna_be = new_clique_wanna_be</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise nx.NetworkXError(&quot;Input graph is not chordal.&quot;)</span>
<span class="gi">+            yield frozenset(clique_wanna_be)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -232,24 +286,47 @@ def chordal_graph_treewidth(G):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Tree_decomposition#Treewidth
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not is_chordal(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Input graph is not chordal.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    max_clique = -1</span>
<span class="gi">+    for clique in nx.chordal_graph_cliques(G):</span>
<span class="gi">+        max_clique = max(max_clique, len(clique))</span>
<span class="gi">+    return max_clique - 1</span>


<span class="w"> </span>def _is_complete_graph(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if G is a complete graph.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nx.number_of_selfloops(G) &gt; 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Self loop found in _is_complete_graph()&quot;)</span>
<span class="gi">+    n = G.number_of_nodes()</span>
<span class="gi">+    if n &lt; 2:</span>
<span class="gi">+        return True</span>
<span class="gi">+    e = G.number_of_edges()</span>
<span class="gi">+    max_edges = (n * (n - 1)) / 2</span>
<span class="gi">+    return e == max_edges</span>


<span class="w"> </span>def _find_missing_edge(G):
<span class="w"> </span>    &quot;&quot;&quot;Given a non-complete graph G, returns a missing edge.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodes = set(G)</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        missing = nodes - set(list(G[u].keys()) + [u])</span>
<span class="gi">+        if missing:</span>
<span class="gi">+            return (u, missing.pop())</span>


<span class="w"> </span>def _max_cardinality_node(G, choices, wanna_connect):
<span class="w"> </span>    &quot;&quot;&quot;Returns a the node in choices that has more connections in G
<span class="w"> </span>    to nodes in wanna_connect.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    max_number = -1</span>
<span class="gi">+    for x in choices:</span>
<span class="gi">+        number = len([y for y in G[x] if y in wanna_connect])</span>
<span class="gi">+        if number &gt; max_number:</span>
<span class="gi">+            max_number = number</span>
<span class="gi">+            max_cardinality_node = x</span>
<span class="gi">+    return max_cardinality_node</span>


<span class="w"> </span>def _find_chordality_breaker(G, s=None, treewidth_bound=sys.maxsize):
<span class="gu">@@ -262,10 +339,36 @@ def _find_chordality_breaker(G, s=None, treewidth_bound=sys.maxsize):</span>

<span class="w"> </span>    It ignores any self loops.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;Graph has no nodes.&quot;)</span>
<span class="gi">+    unnumbered = set(G)</span>
<span class="gi">+    if s is None:</span>
<span class="gi">+        s = arbitrary_element(G)</span>
<span class="gi">+    unnumbered.remove(s)</span>
<span class="gi">+    numbered = {s}</span>
<span class="gi">+    current_treewidth = -1</span>
<span class="gi">+    while unnumbered:  # and current_treewidth &lt;= treewidth_bound:</span>
<span class="gi">+        v = _max_cardinality_node(G, unnumbered, numbered)</span>
<span class="gi">+        unnumbered.remove(v)</span>
<span class="gi">+        numbered.add(v)</span>
<span class="gi">+        clique_wanna_be = set(G[v]) &amp; numbered</span>
<span class="gi">+        sg = G.subgraph(clique_wanna_be)</span>
<span class="gi">+        if _is_complete_graph(sg):</span>
<span class="gi">+            # The graph seems to be chordal by now. We update the treewidth</span>
<span class="gi">+            current_treewidth = max(current_treewidth, len(clique_wanna_be))</span>
<span class="gi">+            if current_treewidth &gt; treewidth_bound:</span>
<span class="gi">+                raise nx.NetworkXTreewidthBoundExceeded(</span>
<span class="gi">+                    f&quot;treewidth_bound exceeded: {current_treewidth}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            # sg is not a clique,</span>
<span class="gi">+            # look for an edge that is not included in sg</span>
<span class="gi">+            (u, w) = _find_missing_edge(sg)</span>
<span class="gi">+            return (u, v, w)</span>
<span class="gi">+    return ()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def complete_to_chordal_graph(G):
<span class="w"> </span>    &quot;&quot;&quot;Return a copy of G completed to a chordal graph
<span class="gu">@@ -307,4 +410,33 @@ def complete_to_chordal_graph(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.wheel_graph(10)
<span class="w"> </span>    &gt;&gt;&gt; H, alpha = complete_to_chordal_graph(G)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    H = G.copy()</span>
<span class="gi">+    alpha = {node: 0 for node in H}</span>
<span class="gi">+    if nx.is_chordal(H):</span>
<span class="gi">+        return H, alpha</span>
<span class="gi">+    chords = set()</span>
<span class="gi">+    weight = {node: 0 for node in H.nodes()}</span>
<span class="gi">+    unnumbered_nodes = list(H.nodes())</span>
<span class="gi">+    for i in range(len(H.nodes()), 0, -1):</span>
<span class="gi">+        # get the node in unnumbered_nodes with the maximum weight</span>
<span class="gi">+        z = max(unnumbered_nodes, key=lambda node: weight[node])</span>
<span class="gi">+        unnumbered_nodes.remove(z)</span>
<span class="gi">+        alpha[z] = i</span>
<span class="gi">+        update_nodes = []</span>
<span class="gi">+        for y in unnumbered_nodes:</span>
<span class="gi">+            if G.has_edge(y, z):</span>
<span class="gi">+                update_nodes.append(y)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # y_weight will be bigger than node weights between y and z</span>
<span class="gi">+                y_weight = weight[y]</span>
<span class="gi">+                lower_nodes = [</span>
<span class="gi">+                    node for node in unnumbered_nodes if weight[node] &lt; y_weight</span>
<span class="gi">+                ]</span>
<span class="gi">+                if nx.has_path(H.subgraph(lower_nodes + [z, y]), y, z):</span>
<span class="gi">+                    update_nodes.append(y)</span>
<span class="gi">+                    chords.add((z, y))</span>
<span class="gi">+        # during calculation of paths the weights should not be updated</span>
<span class="gi">+        for node in update_nodes:</span>
<span class="gi">+            weight[node] += 1</span>
<span class="gi">+    H.add_edges_from(chords)</span>
<span class="gi">+    return H, alpha</span>
<span class="gh">diff --git a/networkx/algorithms/clique.py b/networkx/algorithms/clique.py</span>
<span class="gh">index c984ab13b..5f959dd46 100644</span>
<span class="gd">--- a/networkx/algorithms/clique.py</span>
<span class="gi">+++ b/networkx/algorithms/clique.py</span>
<span class="gu">@@ -9,14 +9,23 @@ see the Wikipedia article on the clique problem [1]_.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections import defaultdict, deque
<span class="w"> </span>from itertools import chain, combinations, islice
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;find_cliques&#39;, &#39;find_cliques_recursive&#39;,</span>
<span class="gd">-    &#39;make_max_clique_graph&#39;, &#39;make_clique_bipartite&#39;, &#39;node_clique_number&#39;,</span>
<span class="gd">-    &#39;number_of_cliques&#39;, &#39;enumerate_all_cliques&#39;, &#39;max_weight_clique&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;find_cliques&quot;,</span>
<span class="gi">+    &quot;find_cliques_recursive&quot;,</span>
<span class="gi">+    &quot;make_max_clique_graph&quot;,</span>
<span class="gi">+    &quot;make_clique_bipartite&quot;,</span>
<span class="gi">+    &quot;node_clique_number&quot;,</span>
<span class="gi">+    &quot;number_of_cliques&quot;,</span>
<span class="gi">+    &quot;enumerate_all_cliques&quot;,</span>
<span class="gi">+    &quot;max_weight_clique&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def enumerate_all_cliques(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns all cliques in an undirected graph.
<span class="gu">@@ -63,10 +72,32 @@ def enumerate_all_cliques(G):</span>
<span class="w"> </span>           &lt;https://doi.org/10.1109/SC.2005.29&gt;.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    index = {}</span>
<span class="gi">+    nbrs = {}</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        index[u] = len(index)</span>
<span class="gi">+        # Neighbors of u that appear after u in the iteration order of G.</span>
<span class="gi">+        nbrs[u] = {v for v in G[u] if v not in index}</span>
<span class="gi">+</span>
<span class="gi">+    queue = deque(([u], sorted(nbrs[u], key=index.__getitem__)) for u in G)</span>
<span class="gi">+    # Loop invariants:</span>
<span class="gi">+    # 1. len(base) is nondecreasing.</span>
<span class="gi">+    # 2. (base + cnbrs) is sorted with respect to the iteration order of G.</span>
<span class="gi">+    # 3. cnbrs is a set of common neighbors of nodes in base.</span>
<span class="gi">+    while queue:</span>
<span class="gi">+        base, cnbrs = map(list, queue.popleft())</span>
<span class="gi">+        yield base</span>
<span class="gi">+        for i, u in enumerate(cnbrs):</span>
<span class="gi">+            # Use generators to reduce memory consumption.</span>
<span class="gi">+            queue.append(</span>
<span class="gi">+                (</span>
<span class="gi">+                    chain(base, [u]),</span>
<span class="gi">+                    filter(nbrs[u].__contains__, islice(cnbrs, i + 1, None)),</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def find_cliques(G, nodes=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns all maximal cliques in an undirected graph.
<span class="gu">@@ -212,9 +243,57 @@ def find_cliques(G, nodes=None):</span>
<span class="w"> </span>       &lt;https://doi.org/10.1016/j.tcs.2008.05.010&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    adj = {u: {v for v in G[u] if v != u} for u in G}</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize Q with the given nodes and subg, cand with their nbrs</span>
<span class="gi">+    Q = nodes[:] if nodes is not None else []</span>
<span class="gi">+    cand = set(G)</span>
<span class="gi">+    for node in Q:</span>
<span class="gi">+        if node not in cand:</span>
<span class="gi">+            raise ValueError(f&quot;The given `nodes` {nodes} do not form a clique&quot;)</span>
<span class="gi">+        cand &amp;= adj[node]</span>
<span class="gi">+</span>
<span class="gi">+    if not cand:</span>
<span class="gi">+        yield Q[:]</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    subg = cand.copy()</span>
<span class="gi">+    stack = []</span>
<span class="gi">+    Q.append(None)</span>
<span class="gi">+</span>
<span class="gi">+    u = max(subg, key=lambda u: len(cand &amp; adj[u]))</span>
<span class="gi">+    ext_u = cand - adj[u]</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if ext_u:</span>
<span class="gi">+                q = ext_u.pop()</span>
<span class="gi">+                cand.remove(q)</span>
<span class="gi">+                Q[-1] = q</span>
<span class="gi">+                adj_q = adj[q]</span>
<span class="gi">+                subg_q = subg &amp; adj_q</span>
<span class="gi">+                if not subg_q:</span>
<span class="gi">+                    yield Q[:]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    cand_q = cand &amp; adj_q</span>
<span class="gi">+                    if cand_q:</span>
<span class="gi">+                        stack.append((subg, cand, ext_u))</span>
<span class="gi">+                        Q.append(None)</span>
<span class="gi">+                        subg = subg_q</span>
<span class="gi">+                        cand = cand_q</span>
<span class="gi">+                        u = max(subg, key=lambda u: len(cand &amp; adj[u]))</span>
<span class="gi">+                        ext_u = cand - adj[u]</span>
<span class="gi">+            else:</span>
<span class="gi">+                Q.pop()</span>
<span class="gi">+                subg, cand, ext_u = stack.pop()</span>
<span class="gi">+    except IndexError:</span>
<span class="gi">+        pass</span>


<span class="gi">+# TODO Should this also be not implemented for directed graphs?</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def find_cliques_recursive(G, nodes=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns all maximal cliques in a graph.
<span class="gu">@@ -297,7 +376,40 @@ def find_cliques_recursive(G, nodes=None):</span>
<span class="w"> </span>       &lt;https://doi.org/10.1016/j.tcs.2008.05.010&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return iter([])</span>
<span class="gi">+</span>
<span class="gi">+    adj = {u: {v for v in G[u] if v != u} for u in G}</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize Q with the given nodes and subg, cand with their nbrs</span>
<span class="gi">+    Q = nodes[:] if nodes is not None else []</span>
<span class="gi">+    cand_init = set(G)</span>
<span class="gi">+    for node in Q:</span>
<span class="gi">+        if node not in cand_init:</span>
<span class="gi">+            raise ValueError(f&quot;The given `nodes` {nodes} do not form a clique&quot;)</span>
<span class="gi">+        cand_init &amp;= adj[node]</span>
<span class="gi">+</span>
<span class="gi">+    if not cand_init:</span>
<span class="gi">+        return iter([Q])</span>
<span class="gi">+</span>
<span class="gi">+    subg_init = cand_init.copy()</span>
<span class="gi">+</span>
<span class="gi">+    def expand(subg, cand):</span>
<span class="gi">+        u = max(subg, key=lambda u: len(cand &amp; adj[u]))</span>
<span class="gi">+        for q in cand - adj[u]:</span>
<span class="gi">+            cand.remove(q)</span>
<span class="gi">+            Q.append(q)</span>
<span class="gi">+            adj_q = adj[q]</span>
<span class="gi">+            subg_q = subg &amp; adj_q</span>
<span class="gi">+            if not subg_q:</span>
<span class="gi">+                yield Q[:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                cand_q = cand &amp; adj_q</span>
<span class="gi">+                if cand_q:</span>
<span class="gi">+                    yield from expand(subg_q, cand_q)</span>
<span class="gi">+            Q.pop()</span>
<span class="gi">+</span>
<span class="gi">+    return expand(subg_init, cand_init)</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -335,7 +447,17 @@ def make_max_clique_graph(G, create_using=None):</span>
<span class="w"> </span>    steps.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if create_using is None:</span>
<span class="gi">+        B = G.__class__()</span>
<span class="gi">+    else:</span>
<span class="gi">+        B = nx.empty_graph(0, create_using)</span>
<span class="gi">+    cliques = list(enumerate(set(c) for c in find_cliques(G)))</span>
<span class="gi">+    # Add a numbered node for each clique.</span>
<span class="gi">+    B.add_nodes_from(i for i, c in cliques)</span>
<span class="gi">+    # Join cliques by an edge if they share a node.</span>
<span class="gi">+    clique_pairs = combinations(cliques, 2)</span>
<span class="gi">+    B.add_edges_from((i, j) for (i, c1), (j, c2) in clique_pairs if c1 &amp; c2)</span>
<span class="gi">+    return B</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -373,7 +495,18 @@ def make_clique_bipartite(G, fpos=None, create_using=None, name=None):</span>
<span class="w"> </span>        convention for bipartite graphs in NetworkX.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    B = nx.empty_graph(0, create_using)</span>
<span class="gi">+    B.clear()</span>
<span class="gi">+    # The &quot;bottom&quot; nodes in the bipartite graph are the nodes of the</span>
<span class="gi">+    # original graph, G.</span>
<span class="gi">+    B.add_nodes_from(G, bipartite=1)</span>
<span class="gi">+    for i, cl in enumerate(find_cliques(G)):</span>
<span class="gi">+        # The &quot;top&quot; nodes in the bipartite graph are the cliques. These</span>
<span class="gi">+        # nodes get negative numbers as labels.</span>
<span class="gi">+        name = -i - 1</span>
<span class="gi">+        B.add_node(name, bipartite=0)</span>
<span class="gi">+        B.add_edges_from((v, name) for v in cl)</span>
<span class="gi">+    return B</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -409,7 +542,35 @@ def node_clique_number(G, nodes=None, cliques=None, separate_nodes=False):</span>
<span class="w"> </span>        maximal cliques containing all the given `nodes`.
<span class="w"> </span>        The search for the cliques is optimized for `nodes`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cliques is None:</span>
<span class="gi">+        if nodes is not None:</span>
<span class="gi">+            # Use ego_graph to decrease size of graph</span>
<span class="gi">+            # check for single node</span>
<span class="gi">+            if nodes in G:</span>
<span class="gi">+                return max(len(c) for c in find_cliques(nx.ego_graph(G, nodes)))</span>
<span class="gi">+            # handle multiple nodes</span>
<span class="gi">+            return {</span>
<span class="gi">+                n: max(len(c) for c in find_cliques(nx.ego_graph(G, n))) for n in nodes</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        # nodes is None--find all cliques</span>
<span class="gi">+        cliques = list(find_cliques(G))</span>
<span class="gi">+</span>
<span class="gi">+    # single node requested</span>
<span class="gi">+    if nodes in G:</span>
<span class="gi">+        return max(len(c) for c in cliques if nodes in c)</span>
<span class="gi">+</span>
<span class="gi">+    # multiple nodes requested</span>
<span class="gi">+    # preprocess all nodes (faster than one at a time for even 2 nodes)</span>
<span class="gi">+    size_for_n = defaultdict(int)</span>
<span class="gi">+    for c in cliques:</span>
<span class="gi">+        size_of_c = len(c)</span>
<span class="gi">+        for n in c:</span>
<span class="gi">+            if size_for_n[n] &lt; size_of_c:</span>
<span class="gi">+                size_for_n[n] = size_of_c</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        return size_for_n</span>
<span class="gi">+    return {n: size_for_n[n] for n in nodes}</span>


<span class="w"> </span>def number_of_cliques(G, nodes=None, cliques=None):
<span class="gu">@@ -418,7 +579,21 @@ def number_of_cliques(G, nodes=None, cliques=None):</span>
<span class="w"> </span>    Returns a single or list depending on input nodes.
<span class="w"> </span>    Optional list of cliques can be input if already computed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cliques is None:</span>
<span class="gi">+        cliques = list(find_cliques(G))</span>
<span class="gi">+</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = list(G.nodes())  # none, get entire graph</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(nodes, list):  # check for a list</span>
<span class="gi">+        v = nodes</span>
<span class="gi">+        # assume it is a single value</span>
<span class="gi">+        numcliq = len([1 for c in cliques if v in c])</span>
<span class="gi">+    else:</span>
<span class="gi">+        numcliq = {}</span>
<span class="gi">+        for v in nodes:</span>
<span class="gi">+            numcliq[v] = len([1 for c in cliques if v in c])</span>
<span class="gi">+    return numcliq</span>


<span class="w"> </span>class MaxWeightClique:
<span class="gu">@@ -451,19 +626,16 @@ class MaxWeightClique:</span>
<span class="w"> </span>        self.G = G
<span class="w"> </span>        self.incumbent_nodes = []
<span class="w"> </span>        self.incumbent_weight = 0
<span class="gi">+</span>
<span class="w"> </span>        if weight is None:
<span class="gd">-            self.node_weights = {v: (1) for v in G.nodes()}</span>
<span class="gi">+            self.node_weights = {v: 1 for v in G.nodes()}</span>
<span class="w"> </span>        else:
<span class="w"> </span>            for v in G.nodes():
<span class="w"> </span>                if weight not in G.nodes[v]:
<span class="gd">-                    errmsg = (</span>
<span class="gd">-                        f&#39;Node {v!r} does not have the requested weight field.&#39;</span>
<span class="gd">-                        )</span>
<span class="gi">+                    errmsg = f&quot;Node {v!r} does not have the requested weight field.&quot;</span>
<span class="w"> </span>                    raise KeyError(errmsg)
<span class="w"> </span>                if not isinstance(G.nodes[v][weight], int):
<span class="gd">-                    errmsg = (</span>
<span class="gd">-                        f&#39;The {weight!r} field of node {v!r} is not an integer.&#39;</span>
<span class="gd">-                        )</span>
<span class="gi">+                    errmsg = f&quot;The {weight!r} field of node {v!r} is not an integer.&quot;</span>
<span class="w"> </span>                    raise ValueError(errmsg)
<span class="w"> </span>            self.node_weights = {v: G.nodes[v][weight] for v in G.nodes()}

<span class="gu">@@ -472,32 +644,63 @@ class MaxWeightClique:</span>

<span class="w"> </span>        C is assumed to be a clique.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if C_weight &gt; self.incumbent_weight:</span>
<span class="gi">+            self.incumbent_nodes = C[:]</span>
<span class="gi">+            self.incumbent_weight = C_weight</span>

<span class="w"> </span>    def greedily_find_independent_set(self, P):
<span class="w"> </span>        &quot;&quot;&quot;Greedily find an independent set of nodes from a set of
<span class="w"> </span>        nodes P.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        independent_set = []</span>
<span class="gi">+        P = P[:]</span>
<span class="gi">+        while P:</span>
<span class="gi">+            v = P[0]</span>
<span class="gi">+            independent_set.append(v)</span>
<span class="gi">+            P = [w for w in P if v != w and not self.G.has_edge(v, w)]</span>
<span class="gi">+        return independent_set</span>

<span class="w"> </span>    def find_branching_nodes(self, P, target):
<span class="w"> </span>        &quot;&quot;&quot;Find a set of nodes to branch on.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        residual_wt = {v: self.node_weights[v] for v in P}</span>
<span class="gi">+        total_wt = 0</span>
<span class="gi">+        P = P[:]</span>
<span class="gi">+        while P:</span>
<span class="gi">+            independent_set = self.greedily_find_independent_set(P)</span>
<span class="gi">+            min_wt_in_class = min(residual_wt[v] for v in independent_set)</span>
<span class="gi">+            total_wt += min_wt_in_class</span>
<span class="gi">+            if total_wt &gt; target:</span>
<span class="gi">+                break</span>
<span class="gi">+            for v in independent_set:</span>
<span class="gi">+                residual_wt[v] -= min_wt_in_class</span>
<span class="gi">+            P = [v for v in P if residual_wt[v] != 0]</span>
<span class="gi">+        return P</span>

<span class="w"> </span>    def expand(self, C, C_weight, P):
<span class="w"> </span>        &quot;&quot;&quot;Look for the best clique that contains all the nodes in C and zero or
<span class="w"> </span>        more of the nodes in P, backtracking if it can be shown that no such
<span class="w"> </span>        clique has greater weight than the incumbent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.update_incumbent_if_improved(C, C_weight)</span>
<span class="gi">+        branching_nodes = self.find_branching_nodes(P, self.incumbent_weight - C_weight)</span>
<span class="gi">+        while branching_nodes:</span>
<span class="gi">+            v = branching_nodes.pop()</span>
<span class="gi">+            P.remove(v)</span>
<span class="gi">+            new_C = C + [v]</span>
<span class="gi">+            new_C_weight = C_weight + self.node_weights[v]</span>
<span class="gi">+            new_P = [w for w in P if self.G.has_edge(v, w)]</span>
<span class="gi">+            self.expand(new_C, new_C_weight, new_P)</span>

<span class="w"> </span>    def find_max_weight_clique(self):
<span class="w"> </span>        &quot;&quot;&quot;Find a maximum weight clique.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Sort nodes in reverse order of degree for speed</span>
<span class="gi">+        nodes = sorted(self.G.nodes(), key=lambda v: self.G.degree(v), reverse=True)</span>
<span class="gi">+        nodes = [v for v in nodes if self.node_weights[v] &gt; 0]</span>
<span class="gi">+        self.expand([], 0, nodes)</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(node_attrs=&#39;weight&#39;)</span>
<span class="gd">-def max_weight_clique(G, weight=&#39;weight&#39;):</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;weight&quot;)</span>
<span class="gi">+def max_weight_clique(G, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Find a maximum weight clique in G.

<span class="w"> </span>    A *clique* in a graph is a set of nodes such that every two distinct nodes
<span class="gu">@@ -545,4 +748,7 @@ def max_weight_clique(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>           for the Maximum Weight Independent Set Problem.  Technical Report,
<span class="w"> </span>           Texas A&amp;M University (2016).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    mwc = MaxWeightClique(G, weight)</span>
<span class="gi">+    mwc.find_max_weight_clique()</span>
<span class="gi">+    return mwc.incumbent_nodes, mwc.incumbent_weight</span>
<span class="gh">diff --git a/networkx/algorithms/cluster.py b/networkx/algorithms/cluster.py</span>
<span class="gh">index 58bcbf073..6c91ad281 100644</span>
<span class="gd">--- a/networkx/algorithms/cluster.py</span>
<span class="gi">+++ b/networkx/algorithms/cluster.py</span>
<span class="gu">@@ -1,13 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Algorithms to characterize the number of triangles in a graph.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import Counter
<span class="w"> </span>from itertools import chain, combinations
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;triangles&#39;, &#39;average_clustering&#39;, &#39;clustering&#39;, &#39;transitivity&#39;,</span>
<span class="gd">-    &#39;square_clustering&#39;, &#39;generalized_degree&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;triangles&quot;,</span>
<span class="gi">+    &quot;average_clustering&quot;,</span>
<span class="gi">+    &quot;clustering&quot;,</span>
<span class="gi">+    &quot;transitivity&quot;,</span>
<span class="gi">+    &quot;square_clustering&quot;,</span>
<span class="gi">+    &quot;generalized_degree&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def triangles(G, nodes=None):
<span class="w"> </span>    &quot;&quot;&quot;Compute the number of triangles.
<span class="gu">@@ -45,10 +54,40 @@ def triangles(G, nodes=None):</span>
<span class="w"> </span>    Self loops are ignored.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes is not None:</span>
<span class="gi">+        # If `nodes` represents a single node, return only its number of triangles</span>
<span class="gi">+        if nodes in G:</span>
<span class="gi">+            return next(_triangles_and_degree_iter(G, nodes))[2] // 2</span>
<span class="gi">+</span>
<span class="gi">+        # if `nodes` is a container of nodes, then return a</span>
<span class="gi">+        # dictionary mapping node to number of triangles.</span>
<span class="gi">+        return {v: t // 2 for v, d, t, _ in _triangles_and_degree_iter(G, nodes)}</span>
<span class="gi">+</span>
<span class="gi">+    # if nodes is None, then compute triangles for the complete graph</span>
<span class="gi">+</span>
<span class="gi">+    # dict used to avoid visiting the same nodes twice</span>
<span class="gi">+    # this allows calculating/counting each triangle only once</span>
<span class="gi">+    later_nbrs = {}</span>
<span class="gi">+</span>
<span class="gi">+    # iterate over the nodes in a graph</span>
<span class="gi">+    for node, neighbors in G.adjacency():</span>
<span class="gi">+        later_nbrs[node] = {n for n in neighbors if n not in later_nbrs and n != node}</span>
<span class="gi">+</span>
<span class="gi">+    # instantiate Counter for each node to include isolated nodes</span>
<span class="gi">+    # add 1 to the count if a nodes neighbor&#39;s neighbor is also a neighbor</span>
<span class="gi">+    triangle_counts = Counter(dict.fromkeys(G, 0))</span>
<span class="gi">+    for node1, neighbors in later_nbrs.items():</span>
<span class="gi">+        for node2 in neighbors:</span>
<span class="gi">+            third_nodes = neighbors &amp; later_nbrs[node2]</span>
<span class="gi">+            m = len(third_nodes)</span>
<span class="gi">+            triangle_counts[node1] += m</span>
<span class="gi">+            triangle_counts[node2] += m</span>
<span class="gi">+            triangle_counts.update(third_nodes)</span>
<span class="gi">+</span>
<span class="gi">+    return dict(triangle_counts)</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>def _triangles_and_degree_iter(G, nodes=None):
<span class="w"> </span>    &quot;&quot;&quot;Return an iterator of (node, degree, triangles, generalized degree).

<span class="gu">@@ -57,11 +96,20 @@ def _triangles_and_degree_iter(G, nodes=None):</span>
<span class="w"> </span>    and details.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes_nbrs = G.adj.items()</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodes_nbrs = ((n, G[n]) for n in G.nbunch_iter(nodes))</span>

<span class="gi">+    for v, v_nbrs in nodes_nbrs:</span>
<span class="gi">+        vs = set(v_nbrs) - {v}</span>
<span class="gi">+        gen_degree = Counter(len(vs &amp; (set(G[w]) - {w})) for w in vs)</span>
<span class="gi">+        ntriangles = sum(k * val for k, val in gen_degree.items())</span>
<span class="gi">+        yield (v, len(vs), ntriangles, gen_degree)</span>

<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-def _weighted_triangles_and_degree_iter(G, nodes=None, weight=&#39;weight&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+def _weighted_triangles_and_degree_iter(G, nodes=None, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return an iterator of (node, degree, weighted_triangles).

<span class="w"> </span>    Used for weighted clustering.
<span class="gu">@@ -70,10 +118,38 @@ def _weighted_triangles_and_degree_iter(G, nodes=None, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    So you may want to divide by 2.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if weight is None or G.number_of_edges() == 0:</span>
<span class="gi">+        max_weight = 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        max_weight = max(d.get(weight, 1) for u, v, d in G.edges(data=True))</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes_nbrs = G.adj.items()</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodes_nbrs = ((n, G[n]) for n in G.nbunch_iter(nodes))</span>
<span class="gi">+</span>
<span class="gi">+    def wt(u, v):</span>
<span class="gi">+        return G[u][v].get(weight, 1) / max_weight</span>
<span class="gi">+</span>
<span class="gi">+    for i, nbrs in nodes_nbrs:</span>
<span class="gi">+        inbrs = set(nbrs) - {i}</span>
<span class="gi">+        weighted_triangles = 0</span>
<span class="gi">+        seen = set()</span>
<span class="gi">+        for j in inbrs:</span>
<span class="gi">+            seen.add(j)</span>
<span class="gi">+            # This avoids counting twice -- we double at the end.</span>
<span class="gi">+            jnbrs = set(G[j]) - seen</span>
<span class="gi">+            # Only compute the edge weight once, before the inner inner</span>
<span class="gi">+            # loop.</span>
<span class="gi">+            wij = wt(i, j)</span>
<span class="gi">+            weighted_triangles += np.cbrt(</span>
<span class="gi">+                [(wij * wt(j, k) * wt(k, i)) for k in inbrs &amp; jnbrs]</span>
<span class="gi">+            ).sum()</span>
<span class="gi">+        yield (i, len(inbrs), 2 * float(weighted_triangles))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>def _directed_triangles_and_degree_iter(G, nodes=None):
<span class="w"> </span>    &quot;&quot;&quot;Return an iterator of
<span class="w"> </span>    (node, total_degree, reciprocal_degree, directed_triangles).
<span class="gu">@@ -83,12 +159,32 @@ def _directed_triangles_and_degree_iter(G, nodes=None):</span>
<span class="w"> </span>    directed triangles so does not count triangles twice.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-def _directed_weighted_triangles_and_degree_iter(G, nodes=None, weight=&#39;weight&#39;</span>
<span class="gd">-    ):</span>
<span class="gi">+    nodes_nbrs = ((n, G._pred[n], G._succ[n]) for n in G.nbunch_iter(nodes))</span>
<span class="gi">+</span>
<span class="gi">+    for i, preds, succs in nodes_nbrs:</span>
<span class="gi">+        ipreds = set(preds) - {i}</span>
<span class="gi">+        isuccs = set(succs) - {i}</span>
<span class="gi">+</span>
<span class="gi">+        directed_triangles = 0</span>
<span class="gi">+        for j in chain(ipreds, isuccs):</span>
<span class="gi">+            jpreds = set(G._pred[j]) - {j}</span>
<span class="gi">+            jsuccs = set(G._succ[j]) - {j}</span>
<span class="gi">+            directed_triangles += sum(</span>
<span class="gi">+                1</span>
<span class="gi">+                for k in chain(</span>
<span class="gi">+                    (ipreds &amp; jpreds),</span>
<span class="gi">+                    (ipreds &amp; jsuccs),</span>
<span class="gi">+                    (isuccs &amp; jpreds),</span>
<span class="gi">+                    (isuccs &amp; jsuccs),</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        dtotal = len(ipreds) + len(isuccs)</span>
<span class="gi">+        dbidirectional = len(ipreds &amp; isuccs)</span>
<span class="gi">+        yield (i, dtotal, dbidirectional, directed_triangles)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+def _directed_weighted_triangles_and_degree_iter(G, nodes=None, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return an iterator of
<span class="w"> </span>    (node, total_degree, reciprocal_degree, directed_weighted_triangles).

<span class="gu">@@ -97,18 +193,69 @@ def _directed_weighted_triangles_and_degree_iter(G, nodes=None, weight=&#39;weight&#39;</span>
<span class="w"> </span>    directed triangles so does not count triangles twice.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if weight is None or G.number_of_edges() == 0:</span>
<span class="gi">+        max_weight = 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        max_weight = max(d.get(weight, 1) for u, v, d in G.edges(data=True))</span>
<span class="gi">+</span>
<span class="gi">+    nodes_nbrs = ((n, G._pred[n], G._succ[n]) for n in G.nbunch_iter(nodes))</span>
<span class="gi">+</span>
<span class="gi">+    def wt(u, v):</span>
<span class="gi">+        return G[u][v].get(weight, 1) / max_weight</span>
<span class="gi">+</span>
<span class="gi">+    for i, preds, succs in nodes_nbrs:</span>
<span class="gi">+        ipreds = set(preds) - {i}</span>
<span class="gi">+        isuccs = set(succs) - {i}</span>
<span class="gi">+</span>
<span class="gi">+        directed_triangles = 0</span>
<span class="gi">+        for j in ipreds:</span>
<span class="gi">+            jpreds = set(G._pred[j]) - {j}</span>
<span class="gi">+            jsuccs = set(G._succ[j]) - {j}</span>
<span class="gi">+            directed_triangles += np.cbrt(</span>
<span class="gi">+                [(wt(j, i) * wt(k, i) * wt(k, j)) for k in ipreds &amp; jpreds]</span>
<span class="gi">+            ).sum()</span>
<span class="gi">+            directed_triangles += np.cbrt(</span>
<span class="gi">+                [(wt(j, i) * wt(k, i) * wt(j, k)) for k in ipreds &amp; jsuccs]</span>
<span class="gi">+            ).sum()</span>
<span class="gi">+            directed_triangles += np.cbrt(</span>
<span class="gi">+                [(wt(j, i) * wt(i, k) * wt(k, j)) for k in isuccs &amp; jpreds]</span>
<span class="gi">+            ).sum()</span>
<span class="gi">+            directed_triangles += np.cbrt(</span>
<span class="gi">+                [(wt(j, i) * wt(i, k) * wt(j, k)) for k in isuccs &amp; jsuccs]</span>
<span class="gi">+            ).sum()</span>
<span class="gi">+</span>
<span class="gi">+        for j in isuccs:</span>
<span class="gi">+            jpreds = set(G._pred[j]) - {j}</span>
<span class="gi">+            jsuccs = set(G._succ[j]) - {j}</span>
<span class="gi">+            directed_triangles += np.cbrt(</span>
<span class="gi">+                [(wt(i, j) * wt(k, i) * wt(k, j)) for k in ipreds &amp; jpreds]</span>
<span class="gi">+            ).sum()</span>
<span class="gi">+            directed_triangles += np.cbrt(</span>
<span class="gi">+                [(wt(i, j) * wt(k, i) * wt(j, k)) for k in ipreds &amp; jsuccs]</span>
<span class="gi">+            ).sum()</span>
<span class="gi">+            directed_triangles += np.cbrt(</span>
<span class="gi">+                [(wt(i, j) * wt(i, k) * wt(k, j)) for k in isuccs &amp; jpreds]</span>
<span class="gi">+            ).sum()</span>
<span class="gi">+            directed_triangles += np.cbrt(</span>
<span class="gi">+                [(wt(i, j) * wt(i, k) * wt(j, k)) for k in isuccs &amp; jsuccs]</span>
<span class="gi">+            ).sum()</span>
<span class="gi">+</span>
<span class="gi">+        dtotal = len(ipreds) + len(isuccs)</span>
<span class="gi">+        dbidirectional = len(ipreds &amp; isuccs)</span>
<span class="gi">+        yield (i, dtotal, dbidirectional, float(directed_triangles))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def average_clustering(G, nodes=None, weight=None, count_zeros=True):
<span class="gd">-    &quot;&quot;&quot;Compute the average clustering coefficient for the graph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the average clustering coefficient for the graph G.</span>

<span class="w"> </span>    The clustering coefficient for the graph is the average,

<span class="w"> </span>    .. math::

<span class="gd">-       C = \\frac{1}{n}\\sum_{v \\in G} c_v,</span>
<span class="gi">+       C = \frac{1}{n}\sum_{v \in G} c_v,</span>

<span class="w"> </span>    where :math:`n` is the number of nodes in `G`.

<span class="gu">@@ -154,19 +301,22 @@ def average_clustering(G, nodes=None, weight=None, count_zeros=True):</span>
<span class="w"> </span>       nodes and leafs on clustering measures for small-world networks.
<span class="w"> </span>       https://arxiv.org/abs/0802.2512
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    c = clustering(G, nodes, weight=weight).values()</span>
<span class="gi">+    if not count_zeros:</span>
<span class="gi">+        c = [v for v in c if abs(v) &gt; 0]</span>
<span class="gi">+    return sum(c) / len(c)</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def clustering(G, nodes=None, weight=None):
<span class="gd">-    &quot;&quot;&quot;Compute the clustering coefficient for nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the clustering coefficient for nodes.</span>

<span class="w"> </span>    For unweighted graphs, the clustering of a node :math:`u`
<span class="w"> </span>    is the fraction of possible triangles through that node that exist,

<span class="w"> </span>    .. math::

<span class="gd">-      c_u = \\frac{2 T(u)}{deg(u)(deg(u)-1)},</span>
<span class="gi">+      c_u = \frac{2 T(u)}{deg(u)(deg(u)-1)},</span>

<span class="w"> </span>    where :math:`T(u)` is the number of triangles through node :math:`u` and
<span class="w"> </span>    :math:`deg(u)` is the degree of :math:`u`.
<span class="gu">@@ -177,11 +327,11 @@ def clustering(G, nodes=None, weight=None):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       c_u = \\frac{1}{deg(u)(deg(u)-1))}</span>
<span class="gd">-             \\sum_{vw} (\\hat{w}_{uv} \\hat{w}_{uw} \\hat{w}_{vw})^{1/3}.</span>
<span class="gi">+       c_u = \frac{1}{deg(u)(deg(u)-1))}</span>
<span class="gi">+             \sum_{vw} (\hat{w}_{uv} \hat{w}_{uw} \hat{w}_{vw})^{1/3}.</span>

<span class="gd">-    The edge weights :math:`\\hat{w}_{uv}` are normalized by the maximum weight</span>
<span class="gd">-    in the network :math:`\\hat{w}_{uv} = w_{uv}/\\max(w)`.</span>
<span class="gi">+    The edge weights :math:`\hat{w}_{uv}` are normalized by the maximum weight</span>
<span class="gi">+    in the network :math:`\hat{w}_{uv} = w_{uv}/\max(w)`.</span>

<span class="w"> </span>    The value of :math:`c_u` is assigned to 0 if :math:`deg(u) &lt; 2`.

<span class="gu">@@ -193,11 +343,11 @@ def clustering(G, nodes=None, weight=None):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       c_u = \\frac{T(u)}{2(deg^{tot}(u)(deg^{tot}(u)-1) - 2deg^{\\leftrightarrow}(u))},</span>
<span class="gi">+       c_u = \frac{T(u)}{2(deg^{tot}(u)(deg^{tot}(u)-1) - 2deg^{\leftrightarrow}(u))},</span>

<span class="w"> </span>    where :math:`T(u)` is the number of directed triangles through node
<span class="w"> </span>    :math:`u`, :math:`deg^{tot}(u)` is the sum of in degree and out degree of
<span class="gd">-    :math:`u` and :math:`deg^{\\leftrightarrow}(u)` is the reciprocal degree of</span>
<span class="gi">+    :math:`u` and :math:`deg^{\leftrightarrow}(u)` is the reciprocal degree of</span>
<span class="w"> </span>    :math:`u`.


<span class="gu">@@ -245,12 +395,36 @@ def clustering(G, nodes=None, weight=None):</span>
<span class="w"> </span>    .. [4] Clustering in complex directed networks by G. Fagiolo,
<span class="w"> </span>       Physical Review E, 76(2), 026107 (2007).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        if weight is not None:</span>
<span class="gi">+            td_iter = _directed_weighted_triangles_and_degree_iter(G, nodes, weight)</span>
<span class="gi">+            clusterc = {</span>
<span class="gi">+                v: 0 if t == 0 else t / ((dt * (dt - 1) - 2 * db) * 2)</span>
<span class="gi">+                for v, dt, db, t in td_iter</span>
<span class="gi">+            }</span>
<span class="gi">+        else:</span>
<span class="gi">+            td_iter = _directed_triangles_and_degree_iter(G, nodes)</span>
<span class="gi">+            clusterc = {</span>
<span class="gi">+                v: 0 if t == 0 else t / ((dt * (dt - 1) - 2 * db) * 2)</span>
<span class="gi">+                for v, dt, db, t in td_iter</span>
<span class="gi">+            }</span>
<span class="gi">+    else:</span>
<span class="gi">+        # The formula 2*T/(d*(d-1)) from docs is t/(d*(d-1)) here b/c t==2*T</span>
<span class="gi">+        if weight is not None:</span>
<span class="gi">+            td_iter = _weighted_triangles_and_degree_iter(G, nodes, weight)</span>
<span class="gi">+            clusterc = {v: 0 if t == 0 else t / (d * (d - 1)) for v, d, t in td_iter}</span>
<span class="gi">+        else:</span>
<span class="gi">+            td_iter = _triangles_and_degree_iter(G, nodes)</span>
<span class="gi">+            clusterc = {v: 0 if t == 0 else t / (d * (d - 1)) for v, d, t, _ in td_iter}</span>
<span class="gi">+    if nodes in G:</span>
<span class="gi">+        # Return the value of the sole entry in the dictionary.</span>
<span class="gi">+        return clusterc[nodes]</span>
<span class="gi">+    return clusterc</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def transitivity(G):
<span class="gd">-    &quot;&quot;&quot;Compute graph transitivity, the fraction of all possible triangles</span>
<span class="gi">+    r&quot;&quot;&quot;Compute graph transitivity, the fraction of all possible triangles</span>
<span class="w"> </span>    present in G.

<span class="w"> </span>    Possible triangles are identified by the number of &quot;triads&quot;
<span class="gu">@@ -260,7 +434,7 @@ def transitivity(G):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        T = 3\\frac{\\#triangles}{\\#triads}.</span>
<span class="gi">+        T = 3\frac{\#triangles}{\#triads}.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -281,25 +455,32 @@ def transitivity(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; print(nx.transitivity(G))
<span class="w"> </span>    1.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    triangles_contri = [</span>
<span class="gi">+        (t, d * (d - 1)) for v, d, t, _ in _triangles_and_degree_iter(G)</span>
<span class="gi">+    ]</span>
<span class="gi">+    # If the graph is empty</span>
<span class="gi">+    if len(triangles_contri) == 0:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    triangles, contri = map(sum, zip(*triangles_contri))</span>
<span class="gi">+    return 0 if triangles == 0 else triangles / contri</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def square_clustering(G, nodes=None):
<span class="gd">-    &quot;&quot;&quot;Compute the squares clustering coefficient for nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the squares clustering coefficient for nodes.</span>

<span class="w"> </span>    For each node return the fraction of possible squares that exist at
<span class="w"> </span>    the node [1]_

<span class="w"> </span>    .. math::
<span class="gd">-       C_4(v) = \\frac{ \\sum_{u=1}^{k_v}</span>
<span class="gd">-       \\sum_{w=u+1}^{k_v} q_v(u,w) }{ \\sum_{u=1}^{k_v}</span>
<span class="gd">-       \\sum_{w=u+1}^{k_v} [a_v(u,w) + q_v(u,w)]},</span>
<span class="gi">+       C_4(v) = \frac{ \sum_{u=1}^{k_v}</span>
<span class="gi">+       \sum_{w=u+1}^{k_v} q_v(u,w) }{ \sum_{u=1}^{k_v}</span>
<span class="gi">+       \sum_{w=u+1}^{k_v} [a_v(u,w) + q_v(u,w)]},</span>

<span class="w"> </span>    where :math:`q_v(u,w)` are the number of common neighbors of :math:`u` and
<span class="w"> </span>    :math:`w` other than :math:`v` (ie squares), and :math:`a_v(u,w) = (k_u -
<span class="gd">-    (1+q_v(u,w)+\\theta_{uv})) + (k_w - (1+q_v(u,w)+\\theta_{uw}))`, where</span>
<span class="gd">-    :math:`\\theta_{uw} = 1` if :math:`u` and :math:`w` are connected and 0</span>
<span class="gi">+    (1+q_v(u,w)+\theta_{uv})) + (k_w - (1+q_v(u,w)+\theta_{uw}))`, where</span>
<span class="gi">+    :math:`\theta_{uw} = 1` if :math:`u` and :math:`w` are connected and 0</span>
<span class="w"> </span>    otherwise. [2]_

<span class="w"> </span>    Parameters
<span class="gu">@@ -339,19 +520,39 @@ def square_clustering(G, nodes=None):</span>
<span class="w"> </span>        Bipartite Networks. Physica A: Statistical Mechanics and its Applications 387.27 (2008): 6869–6875.
<span class="w"> </span>        https://arxiv.org/abs/0710.0117v1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        node_iter = G</span>
<span class="gi">+    else:</span>
<span class="gi">+        node_iter = G.nbunch_iter(nodes)</span>
<span class="gi">+    clustering = {}</span>
<span class="gi">+    for v in node_iter:</span>
<span class="gi">+        clustering[v] = 0</span>
<span class="gi">+        potential = 0</span>
<span class="gi">+        for u, w in combinations(G[v], 2):</span>
<span class="gi">+            squares = len((set(G[u]) &amp; set(G[w])) - {v})</span>
<span class="gi">+            clustering[v] += squares</span>
<span class="gi">+            degm = squares + 1</span>
<span class="gi">+            if w in G[u]:</span>
<span class="gi">+                degm += 1</span>
<span class="gi">+            potential += (len(G[u]) - degm) + (len(G[w]) - degm) + squares</span>
<span class="gi">+        if potential &gt; 0:</span>
<span class="gi">+            clustering[v] /= potential</span>
<span class="gi">+    if nodes in G:</span>
<span class="gi">+        # Return the value of the sole entry in the dictionary.</span>
<span class="gi">+        return clustering[nodes]</span>
<span class="gi">+    return clustering</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def generalized_degree(G, nodes=None):
<span class="gd">-    &quot;&quot;&quot;Compute the generalized degree for nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the generalized degree for nodes.</span>

<span class="w"> </span>    For each node, the generalized degree shows how many edges of given
<span class="w"> </span>    triangle multiplicity the node is connected to. The triangle multiplicity
<span class="w"> </span>    of an edge is the number of triangles an edge participates in. The
<span class="w"> </span>    generalized degree of node :math:`i` can be written as a vector
<span class="gd">-    :math:`\\mathbf{k}_i=(k_i^{(0)}, \\dotsc, k_i^{(N-2)})` where</span>
<span class="gi">+    :math:`\mathbf{k}_i=(k_i^{(0)}, \dotsc, k_i^{(N-2)})` where</span>
<span class="w"> </span>    :math:`k_i^{(j)}` is the number of edges attached to node :math:`i` that
<span class="w"> </span>    participate in :math:`j` triangles.

<span class="gu">@@ -393,8 +594,8 @@ def generalized_degree(G, nodes=None):</span>
<span class="w"> </span>    particular triangle multiplicity are present.

<span class="w"> </span>    The number of triangles node :math:`i` is attached to can be recovered from
<span class="gd">-    the generalized degree :math:`\\mathbf{k}_i=(k_i^{(0)}, \\dotsc,</span>
<span class="gd">-    k_i^{(N-2)})` by :math:`(k_i^{(1)}+2k_i^{(2)}+\\dotsc +(N-2)k_i^{(N-2)})/2`.</span>
<span class="gi">+    the generalized degree :math:`\mathbf{k}_i=(k_i^{(0)}, \dotsc,</span>
<span class="gi">+    k_i^{(N-2)})` by :math:`(k_i^{(1)}+2k_i^{(2)}+\dotsc +(N-2)k_i^{(N-2)})/2`.</span>

<span class="w"> </span>    References
<span class="w"> </span>    ----------
<span class="gu">@@ -403,4 +604,6 @@ def generalized_degree(G, nodes=None):</span>
<span class="w"> </span>        Volume 97, Number 2 (2012).
<span class="w"> </span>        https://iopscience.iop.org/article/10.1209/0295-5075/97/28005
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes in G:</span>
<span class="gi">+        return next(_triangles_and_degree_iter(G, nodes))[3]</span>
<span class="gi">+    return {v: gd for v, d, t, gd in _triangles_and_degree_iter(G, nodes)}</span>
<span class="gh">diff --git a/networkx/algorithms/coloring/equitable_coloring.py b/networkx/algorithms/coloring/equitable_coloring.py</span>
<span class="gh">index 05af03451..e464a0744 100644</span>
<span class="gd">--- a/networkx/algorithms/coloring/equitable_coloring.py</span>
<span class="gi">+++ b/networkx/algorithms/coloring/equitable_coloring.py</span>
<span class="gu">@@ -1,31 +1,115 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Equitable coloring of graphs with bounded degree.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;equitable_color&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;equitable_color&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_coloring(G, coloring):
<span class="w"> </span>    &quot;&quot;&quot;Determine if the coloring is a valid coloring for the graph G.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Verify that the coloring is valid.</span>
<span class="gi">+    return all(coloring[s] != coloring[d] for s, d in G.edges)</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_equitable(G, coloring, num_colors=None):
<span class="w"> </span>    &quot;&quot;&quot;Determines if the coloring is valid and equitable for the graph G.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if not is_coloring(G, coloring):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Verify whether it is equitable.</span>
<span class="gi">+    color_set_size = defaultdict(int)</span>
<span class="gi">+    for color in coloring.values():</span>
<span class="gi">+        color_set_size[color] += 1</span>
<span class="gi">+</span>
<span class="gi">+    if num_colors is not None:</span>
<span class="gi">+        for color in range(num_colors):</span>
<span class="gi">+            if color not in color_set_size:</span>
<span class="gi">+                # These colors do not have any vertices attached to them.</span>
<span class="gi">+                color_set_size[color] = 0</span>
<span class="gi">+</span>
<span class="gi">+    # If there are more than 2 distinct values, the coloring cannot be equitable</span>
<span class="gi">+    all_set_sizes = set(color_set_size.values())</span>
<span class="gi">+    if len(all_set_sizes) == 0 and num_colors is None:  # Was an empty graph</span>
<span class="gi">+        return True</span>
<span class="gi">+    elif len(all_set_sizes) == 1:</span>
<span class="gi">+        return True</span>
<span class="gi">+    elif len(all_set_sizes) == 2:</span>
<span class="gi">+        a, b = list(all_set_sizes)</span>
<span class="gi">+        return abs(a - b) &lt;= 1</span>
<span class="gi">+    else:  # len(all_set_sizes) &gt; 2:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_C_from_F(F):</span>
<span class="gi">+    C = defaultdict(list)</span>
<span class="gi">+    for node, color in F.items():</span>
<span class="gi">+        C[color].append(node)</span>
<span class="gi">+</span>
<span class="gi">+    return C</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_N_from_L_C(L, C):</span>
<span class="gi">+    nodes = L.keys()</span>
<span class="gi">+    colors = C.keys()</span>
<span class="gi">+    return {</span>
<span class="gi">+        (node, color): sum(1 for v in L[node] if v in C[color])</span>
<span class="gi">+        for node in nodes</span>
<span class="gi">+        for color in colors</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_H_from_C_N(C, N):</span>
<span class="gi">+    return {</span>
<span class="gi">+        (c1, c2): sum(1 for node in C[c1] if N[(node, c2)] == 0) for c1 in C for c2 in C</span>
<span class="gi">+    }</span>


<span class="w"> </span>def change_color(u, X, Y, N, H, F, C, L):
<span class="w"> </span>    &quot;&quot;&quot;Change the color of &#39;u&#39; from X to Y and update N, H, F, C.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert F[u] == X and X != Y</span>
<span class="gi">+</span>
<span class="gi">+    # Change the class of &#39;u&#39; from X to Y</span>
<span class="gi">+    F[u] = Y</span>
<span class="gi">+</span>
<span class="gi">+    for k in C:</span>
<span class="gi">+        # &#39;u&#39; witnesses an edge from k -&gt; Y instead of from k -&gt; X now.</span>
<span class="gi">+        if N[u, k] == 0:</span>
<span class="gi">+            H[(X, k)] -= 1</span>
<span class="gi">+            H[(Y, k)] += 1</span>
<span class="gi">+</span>
<span class="gi">+    for v in L[u]:</span>
<span class="gi">+        # &#39;v&#39; has lost a neighbor in X and gained one in Y</span>
<span class="gi">+        N[(v, X)] -= 1</span>
<span class="gi">+        N[(v, Y)] += 1</span>
<span class="gi">+</span>
<span class="gi">+        if N[(v, X)] == 0:</span>
<span class="gi">+            # &#39;v&#39; witnesses F[v] -&gt; X</span>
<span class="gi">+            H[(F[v], X)] += 1</span>
<span class="gi">+</span>
<span class="gi">+        if N[(v, Y)] == 1:</span>
<span class="gi">+            # &#39;v&#39; no longer witnesses F[v] -&gt; Y</span>
<span class="gi">+            H[(F[v], Y)] -= 1</span>
<span class="gi">+</span>
<span class="gi">+    C[X].remove(u)</span>
<span class="gi">+    C[Y].append(u)</span>


<span class="w"> </span>def move_witnesses(src_color, dst_color, N, H, F, C, T_cal, L):
<span class="w"> </span>    &quot;&quot;&quot;Move witness along a path from src_color to dst_color.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    X = src_color</span>
<span class="gi">+    while X != dst_color:</span>
<span class="gi">+        Y = T_cal[X]</span>
<span class="gi">+        # Move _any_ witness from X to Y = T_cal[X]</span>
<span class="gi">+        w = next(x for x in C[X] if N[(x, Y)] == 0)</span>
<span class="gi">+        change_color(w, X, Y, N=N, H=H, F=F, C=C, L=L)</span>
<span class="gi">+        X = Y</span>


<span class="w"> </span>@nx._dispatchable(mutates_input=True)
<span class="gu">@@ -37,12 +121,269 @@ def pad_graph(G, num_colors):</span>

<span class="w"> </span>    Returns the number of nodes with each color.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    n_ = len(G)</span>
<span class="gi">+    r = num_colors - 1</span>
<span class="gi">+</span>
<span class="gi">+    # Ensure that the number of nodes in G is a multiple of (r + 1)</span>
<span class="gi">+    s = n_ // (r + 1)</span>
<span class="gi">+    if n_ != s * (r + 1):</span>
<span class="gi">+        p = (r + 1) - n_ % (r + 1)</span>
<span class="gi">+        s += 1</span>
<span class="gi">+</span>
<span class="gi">+        # Complete graph K_p between (imaginary) nodes [n_, ... , n_ + p]</span>
<span class="gi">+        K = nx.relabel_nodes(nx.complete_graph(p), {idx: idx + n_ for idx in range(p)})</span>
<span class="gi">+        G.add_edges_from(K.edges)</span>
<span class="gi">+</span>
<span class="gi">+    return s</span>


<span class="w"> </span>def procedure_P(V_minus, V_plus, N, H, F, C, L, excluded_colors=None):
<span class="w"> </span>    &quot;&quot;&quot;Procedure P as described in the paper.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if excluded_colors is None:</span>
<span class="gi">+        excluded_colors = set()</span>
<span class="gi">+</span>
<span class="gi">+    A_cal = set()</span>
<span class="gi">+    T_cal = {}</span>
<span class="gi">+    R_cal = []</span>
<span class="gi">+</span>
<span class="gi">+    # BFS to determine A_cal, i.e. colors reachable from V-</span>
<span class="gi">+    reachable = [V_minus]</span>
<span class="gi">+    marked = set(reachable)</span>
<span class="gi">+    idx = 0</span>
<span class="gi">+</span>
<span class="gi">+    while idx &lt; len(reachable):</span>
<span class="gi">+        pop = reachable[idx]</span>
<span class="gi">+        idx += 1</span>
<span class="gi">+</span>
<span class="gi">+        A_cal.add(pop)</span>
<span class="gi">+        R_cal.append(pop)</span>
<span class="gi">+</span>
<span class="gi">+        # TODO: Checking whether a color has been visited can be made faster by</span>
<span class="gi">+        # using a look-up table instead of testing for membership in a set by a</span>
<span class="gi">+        # logarithmic factor.</span>
<span class="gi">+        next_layer = []</span>
<span class="gi">+        for k in C:</span>
<span class="gi">+            if (</span>
<span class="gi">+                H[(k, pop)] &gt; 0</span>
<span class="gi">+                and k not in A_cal</span>
<span class="gi">+                and k not in excluded_colors</span>
<span class="gi">+                and k not in marked</span>
<span class="gi">+            ):</span>
<span class="gi">+                next_layer.append(k)</span>
<span class="gi">+</span>
<span class="gi">+        for dst in next_layer:</span>
<span class="gi">+            # Record that `dst` can reach `pop`</span>
<span class="gi">+            T_cal[dst] = pop</span>
<span class="gi">+</span>
<span class="gi">+        marked.update(next_layer)</span>
<span class="gi">+        reachable.extend(next_layer)</span>
<span class="gi">+</span>
<span class="gi">+    # Variables for the algorithm</span>
<span class="gi">+    b = len(C) - len(A_cal)</span>
<span class="gi">+</span>
<span class="gi">+    if V_plus in A_cal:</span>
<span class="gi">+        # Easy case: V+ is in A_cal</span>
<span class="gi">+        # Move one node from V+ to V- using T_cal to find the parents.</span>
<span class="gi">+        move_witnesses(V_plus, V_minus, N=N, H=H, F=F, C=C, T_cal=T_cal, L=L)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # If there is a solo edge, we can resolve the situation by</span>
<span class="gi">+        # moving witnesses from B to A, making G[A] equitable and then</span>
<span class="gi">+        # recursively balancing G[B - w] with a different V_minus and</span>
<span class="gi">+        # but the same V_plus.</span>
<span class="gi">+</span>
<span class="gi">+        A_0 = set()</span>
<span class="gi">+        A_cal_0 = set()</span>
<span class="gi">+        num_terminal_sets_found = 0</span>
<span class="gi">+        made_equitable = False</span>
<span class="gi">+</span>
<span class="gi">+        for W_1 in R_cal[::-1]:</span>
<span class="gi">+            for v in C[W_1]:</span>
<span class="gi">+                X = None</span>
<span class="gi">+</span>
<span class="gi">+                for U in C:</span>
<span class="gi">+                    if N[(v, U)] == 0 and U in A_cal and U != W_1:</span>
<span class="gi">+                        X = U</span>
<span class="gi">+</span>
<span class="gi">+                # v does not witness an edge in H[A_cal]</span>
<span class="gi">+                if X is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                for U in C:</span>
<span class="gi">+                    # Note: Departing from the paper here.</span>
<span class="gi">+                    if N[(v, U)] &gt;= 1 and U not in A_cal:</span>
<span class="gi">+                        X_prime = U</span>
<span class="gi">+                        w = v</span>
<span class="gi">+</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            # Finding the solo neighbor of w in X_prime</span>
<span class="gi">+                            y = next(</span>
<span class="gi">+                                node</span>
<span class="gi">+                                for node in L[w]</span>
<span class="gi">+                                if F[node] == X_prime and N[(node, W_1)] == 1</span>
<span class="gi">+                            )</span>
<span class="gi">+                        except StopIteration:</span>
<span class="gi">+                            pass</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            W = W_1</span>
<span class="gi">+</span>
<span class="gi">+                            # Move w from W to X, now X has one extra node.</span>
<span class="gi">+                            change_color(w, W, X, N=N, H=H, F=F, C=C, L=L)</span>
<span class="gi">+</span>
<span class="gi">+                            # Move witness from X to V_minus, making the coloring</span>
<span class="gi">+                            # equitable.</span>
<span class="gi">+                            move_witnesses(</span>
<span class="gi">+                                src_color=X,</span>
<span class="gi">+                                dst_color=V_minus,</span>
<span class="gi">+                                N=N,</span>
<span class="gi">+                                H=H,</span>
<span class="gi">+                                F=F,</span>
<span class="gi">+                                C=C,</span>
<span class="gi">+                                T_cal=T_cal,</span>
<span class="gi">+                                L=L,</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+                            # Move y from X_prime to W, making W the correct size.</span>
<span class="gi">+                            change_color(y, X_prime, W, N=N, H=H, F=F, C=C, L=L)</span>
<span class="gi">+</span>
<span class="gi">+                            # Then call the procedure on G[B - y]</span>
<span class="gi">+                            procedure_P(</span>
<span class="gi">+                                V_minus=X_prime,</span>
<span class="gi">+                                V_plus=V_plus,</span>
<span class="gi">+                                N=N,</span>
<span class="gi">+                                H=H,</span>
<span class="gi">+                                C=C,</span>
<span class="gi">+                                F=F,</span>
<span class="gi">+                                L=L,</span>
<span class="gi">+                                excluded_colors=excluded_colors.union(A_cal),</span>
<span class="gi">+                            )</span>
<span class="gi">+                            made_equitable = True</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+                if made_equitable:</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                # No node in W_1 was found such that</span>
<span class="gi">+                # it had a solo-neighbor.</span>
<span class="gi">+                A_cal_0.add(W_1)</span>
<span class="gi">+                A_0.update(C[W_1])</span>
<span class="gi">+                num_terminal_sets_found += 1</span>
<span class="gi">+</span>
<span class="gi">+            if num_terminal_sets_found == b:</span>
<span class="gi">+                # Otherwise, construct the maximal independent set and find</span>
<span class="gi">+                # a pair of z_1, z_2 as in Case II.</span>
<span class="gi">+</span>
<span class="gi">+                # BFS to determine B_cal&#39;: the set of colors reachable from V+</span>
<span class="gi">+                B_cal_prime = set()</span>
<span class="gi">+                T_cal_prime = {}</span>
<span class="gi">+</span>
<span class="gi">+                reachable = [V_plus]</span>
<span class="gi">+                marked = set(reachable)</span>
<span class="gi">+                idx = 0</span>
<span class="gi">+                while idx &lt; len(reachable):</span>
<span class="gi">+                    pop = reachable[idx]</span>
<span class="gi">+                    idx += 1</span>
<span class="gi">+</span>
<span class="gi">+                    B_cal_prime.add(pop)</span>
<span class="gi">+</span>
<span class="gi">+                    # No need to check for excluded_colors here because</span>
<span class="gi">+                    # they only exclude colors from A_cal</span>
<span class="gi">+                    next_layer = [</span>
<span class="gi">+                        k</span>
<span class="gi">+                        for k in C</span>
<span class="gi">+                        if H[(pop, k)] &gt; 0 and k not in B_cal_prime and k not in marked</span>
<span class="gi">+                    ]</span>
<span class="gi">+</span>
<span class="gi">+                    for dst in next_layer:</span>
<span class="gi">+                        T_cal_prime[pop] = dst</span>
<span class="gi">+</span>
<span class="gi">+                    marked.update(next_layer)</span>
<span class="gi">+                    reachable.extend(next_layer)</span>
<span class="gi">+</span>
<span class="gi">+                # Construct the independent set of G[B&#39;]</span>
<span class="gi">+                I_set = set()</span>
<span class="gi">+                I_covered = set()</span>
<span class="gi">+                W_covering = {}</span>
<span class="gi">+</span>
<span class="gi">+                B_prime = [node for k in B_cal_prime for node in C[k]]</span>
<span class="gi">+</span>
<span class="gi">+                # Add the nodes in V_plus to I first.</span>
<span class="gi">+                for z in C[V_plus] + B_prime:</span>
<span class="gi">+                    if z in I_covered or F[z] not in B_cal_prime:</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    I_set.add(z)</span>
<span class="gi">+                    I_covered.add(z)</span>
<span class="gi">+                    I_covered.update(list(L[z]))</span>
<span class="gi">+</span>
<span class="gi">+                    for w in L[z]:</span>
<span class="gi">+                        if F[w] in A_cal_0 and N[(z, F[w])] == 1:</span>
<span class="gi">+                            if w not in W_covering:</span>
<span class="gi">+                                W_covering[w] = z</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                # Found z1, z2 which have the same solo</span>
<span class="gi">+                                # neighbor in some W</span>
<span class="gi">+                                z_1 = W_covering[w]</span>
<span class="gi">+                                # z_2 = z</span>
<span class="gi">+</span>
<span class="gi">+                                Z = F[z_1]</span>
<span class="gi">+                                W = F[w]</span>
<span class="gi">+</span>
<span class="gi">+                                # shift nodes along W, V-</span>
<span class="gi">+                                move_witnesses(</span>
<span class="gi">+                                    W, V_minus, N=N, H=H, F=F, C=C, T_cal=T_cal, L=L</span>
<span class="gi">+                                )</span>
<span class="gi">+</span>
<span class="gi">+                                # shift nodes along V+ to Z</span>
<span class="gi">+                                move_witnesses(</span>
<span class="gi">+                                    V_plus,</span>
<span class="gi">+                                    Z,</span>
<span class="gi">+                                    N=N,</span>
<span class="gi">+                                    H=H,</span>
<span class="gi">+                                    F=F,</span>
<span class="gi">+                                    C=C,</span>
<span class="gi">+                                    T_cal=T_cal_prime,</span>
<span class="gi">+                                    L=L,</span>
<span class="gi">+                                )</span>
<span class="gi">+</span>
<span class="gi">+                                # change color of z_1 to W</span>
<span class="gi">+                                change_color(z_1, Z, W, N=N, H=H, F=F, C=C, L=L)</span>
<span class="gi">+</span>
<span class="gi">+                                # change color of w to some color in B_cal</span>
<span class="gi">+                                W_plus = next(</span>
<span class="gi">+                                    k for k in C if N[(w, k)] == 0 and k not in A_cal</span>
<span class="gi">+                                )</span>
<span class="gi">+                                change_color(w, W, W_plus, N=N, H=H, F=F, C=C, L=L)</span>
<span class="gi">+</span>
<span class="gi">+                                # recurse with G[B \cup W*]</span>
<span class="gi">+                                excluded_colors.update(</span>
<span class="gi">+                                    [k for k in C if k != W and k not in B_cal_prime]</span>
<span class="gi">+                                )</span>
<span class="gi">+                                procedure_P(</span>
<span class="gi">+                                    V_minus=W,</span>
<span class="gi">+                                    V_plus=W_plus,</span>
<span class="gi">+                                    N=N,</span>
<span class="gi">+                                    H=H,</span>
<span class="gi">+                                    C=C,</span>
<span class="gi">+                                    F=F,</span>
<span class="gi">+                                    L=L,</span>
<span class="gi">+                                    excluded_colors=excluded_colors,</span>
<span class="gi">+                                )</span>
<span class="gi">+</span>
<span class="gi">+                                made_equitable = True</span>
<span class="gi">+                                break</span>
<span class="gi">+</span>
<span class="gi">+                    if made_equitable:</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    assert False, (</span>
<span class="gi">+                        &quot;Must find a w which is the solo neighbor &quot;</span>
<span class="gi">+                        &quot;of two vertices in B_cal_prime.&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            if made_equitable:</span>
<span class="gi">+                break</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -86,4 +427,79 @@ def equitable_color(G, num_colors):</span>
<span class="w"> </span>        (2010). A fast algorithm for equitable coloring. Combinatorica, 30(2),
<span class="w"> </span>        217-224.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Map nodes to integers for simplicity later.</span>
<span class="gi">+    nodes_to_int = {}</span>
<span class="gi">+    int_to_nodes = {}</span>
<span class="gi">+</span>
<span class="gi">+    for idx, node in enumerate(G.nodes):</span>
<span class="gi">+        nodes_to_int[node] = idx</span>
<span class="gi">+        int_to_nodes[idx] = node</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.relabel_nodes(G, nodes_to_int, copy=True)</span>
<span class="gi">+</span>
<span class="gi">+    # Basic graph statistics and sanity check.</span>
<span class="gi">+    if len(G.nodes) &gt; 0:</span>
<span class="gi">+        r_ = max(G.degree(node) for node in G.nodes)</span>
<span class="gi">+    else:</span>
<span class="gi">+        r_ = 0</span>
<span class="gi">+</span>
<span class="gi">+    if r_ &gt;= num_colors:</span>
<span class="gi">+        raise nx.NetworkXAlgorithmError(</span>
<span class="gi">+            f&quot;Graph has maximum degree {r_}, needs &quot;</span>
<span class="gi">+            f&quot;{r_ + 1} (&gt; {num_colors}) colors for guaranteed coloring.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Ensure that the number of nodes in G is a multiple of (r + 1)</span>
<span class="gi">+    pad_graph(G, num_colors)</span>
<span class="gi">+</span>
<span class="gi">+    # Starting the algorithm.</span>
<span class="gi">+    # L = {node: list(G.neighbors(node)) for node in G.nodes}</span>
<span class="gi">+    L_ = {node: [] for node in G.nodes}</span>
<span class="gi">+</span>
<span class="gi">+    # Arbitrary equitable allocation of colors to nodes.</span>
<span class="gi">+    F = {node: idx % num_colors for idx, node in enumerate(G.nodes)}</span>
<span class="gi">+</span>
<span class="gi">+    C = make_C_from_F(F)</span>
<span class="gi">+</span>
<span class="gi">+    # The neighborhood is empty initially.</span>
<span class="gi">+    N = make_N_from_L_C(L_, C)</span>
<span class="gi">+</span>
<span class="gi">+    # Currently all nodes witness all edges.</span>
<span class="gi">+    H = make_H_from_C_N(C, N)</span>
<span class="gi">+</span>
<span class="gi">+    # Start of algorithm.</span>
<span class="gi">+    edges_seen = set()</span>
<span class="gi">+</span>
<span class="gi">+    for u in sorted(G.nodes):</span>
<span class="gi">+        for v in sorted(G.neighbors(u)):</span>
<span class="gi">+            # Do not double count edges if (v, u) has already been seen.</span>
<span class="gi">+            if (v, u) in edges_seen:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            edges_seen.add((u, v))</span>
<span class="gi">+</span>
<span class="gi">+            L_[u].append(v)</span>
<span class="gi">+            L_[v].append(u)</span>
<span class="gi">+</span>
<span class="gi">+            N[(u, F[v])] += 1</span>
<span class="gi">+            N[(v, F[u])] += 1</span>
<span class="gi">+</span>
<span class="gi">+            if F[u] != F[v]:</span>
<span class="gi">+                # Were &#39;u&#39; and &#39;v&#39; witnesses for F[u] -&gt; F[v] or F[v] -&gt; F[u]?</span>
<span class="gi">+                if N[(u, F[v])] == 1:</span>
<span class="gi">+                    H[F[u], F[v]] -= 1  # u cannot witness an edge between F[u], F[v]</span>
<span class="gi">+</span>
<span class="gi">+                if N[(v, F[u])] == 1:</span>
<span class="gi">+                    H[F[v], F[u]] -= 1  # v cannot witness an edge between F[v], F[u]</span>
<span class="gi">+</span>
<span class="gi">+        if N[(u, F[u])] != 0:</span>
<span class="gi">+            # Find the first color where &#39;u&#39; does not have any neighbors.</span>
<span class="gi">+            Y = next(k for k in C if N[(u, k)] == 0)</span>
<span class="gi">+            X = F[u]</span>
<span class="gi">+            change_color(u, X, Y, N=N, H=H, F=F, C=C, L=L_)</span>
<span class="gi">+</span>
<span class="gi">+            # Procedure P</span>
<span class="gi">+            procedure_P(V_minus=X, V_plus=Y, N=N, H=H, F=F, C=C, L=L_)</span>
<span class="gi">+</span>
<span class="gi">+    return {int_to_nodes[x]: F[x] for x in int_to_nodes}</span>
<span class="gh">diff --git a/networkx/algorithms/coloring/greedy_coloring.py b/networkx/algorithms/coloring/greedy_coloring.py</span>
<span class="gh">index 7927585ea..61bc95367 100644</span>
<span class="gd">--- a/networkx/algorithms/coloring/greedy_coloring.py</span>
<span class="gi">+++ b/networkx/algorithms/coloring/greedy_coloring.py</span>
<span class="gu">@@ -3,13 +3,21 @@ Greedy graph coloring using various strategies.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import itertools
<span class="w"> </span>from collections import defaultdict, deque
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import arbitrary_element, py_random_state
<span class="gd">-__all__ = [&#39;greedy_color&#39;, &#39;strategy_connected_sequential&#39;,</span>
<span class="gd">-    &#39;strategy_connected_sequential_bfs&#39;,</span>
<span class="gd">-    &#39;strategy_connected_sequential_dfs&#39;, &#39;strategy_independent_set&#39;,</span>
<span class="gd">-    &#39;strategy_largest_first&#39;, &#39;strategy_random_sequential&#39;,</span>
<span class="gd">-    &#39;strategy_saturation_largest_first&#39;, &#39;strategy_smallest_last&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;greedy_color&quot;,</span>
<span class="gi">+    &quot;strategy_connected_sequential&quot;,</span>
<span class="gi">+    &quot;strategy_connected_sequential_bfs&quot;,</span>
<span class="gi">+    &quot;strategy_connected_sequential_dfs&quot;,</span>
<span class="gi">+    &quot;strategy_independent_set&quot;,</span>
<span class="gi">+    &quot;strategy_largest_first&quot;,</span>
<span class="gi">+    &quot;strategy_random_sequential&quot;,</span>
<span class="gi">+    &quot;strategy_saturation_largest_first&quot;,</span>
<span class="gi">+    &quot;strategy_smallest_last&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def strategy_largest_first(G, colors):
<span class="gu">@@ -19,7 +27,7 @@ def strategy_largest_first(G, colors):</span>
<span class="w"> </span>    ``G`` is a NetworkX graph. ``colors`` is ignored.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sorted(G, key=G.degree, reverse=True)</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -32,7 +40,9 @@ def strategy_random_sequential(G, colors, seed=None):</span>
<span class="w"> </span>        Indicator of random number generation state.
<span class="w"> </span>        See :ref:`Randomness&lt;randomness&gt;`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodes = list(G)</span>
<span class="gi">+    seed.shuffle(nodes)</span>
<span class="gi">+    return nodes</span>


<span class="w"> </span>def strategy_smallest_last(G, colors):
<span class="gu">@@ -54,7 +64,42 @@ def strategy_smallest_last(G, colors):</span>
<span class="w"> </span>    maximal independent set.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    H = G.copy()</span>
<span class="gi">+    result = deque()</span>
<span class="gi">+</span>
<span class="gi">+    # Build initial degree list (i.e. the bucket queue data structure)</span>
<span class="gi">+    degrees = defaultdict(set)  # set(), for fast random-access removals</span>
<span class="gi">+    lbound = float(&quot;inf&quot;)</span>
<span class="gi">+    for node, d in H.degree():</span>
<span class="gi">+        degrees[d].add(node)</span>
<span class="gi">+        lbound = min(lbound, d)  # Lower bound on min-degree.</span>
<span class="gi">+</span>
<span class="gi">+    def find_min_degree():</span>
<span class="gi">+        # Save time by starting the iterator at `lbound`, not 0.</span>
<span class="gi">+        # The value that we find will be our new `lbound`, which we set later.</span>
<span class="gi">+        return next(d for d in itertools.count(lbound) if d in degrees)</span>
<span class="gi">+</span>
<span class="gi">+    for _ in G:</span>
<span class="gi">+        # Pop a min-degree node and add it to the list.</span>
<span class="gi">+        min_degree = find_min_degree()</span>
<span class="gi">+        u = degrees[min_degree].pop()</span>
<span class="gi">+        if not degrees[min_degree]:  # Clean up the degree list.</span>
<span class="gi">+            del degrees[min_degree]</span>
<span class="gi">+        result.appendleft(u)</span>
<span class="gi">+</span>
<span class="gi">+        # Update degrees of removed node&#39;s neighbors.</span>
<span class="gi">+        for v in H[u]:</span>
<span class="gi">+            degree = H.degree(v)</span>
<span class="gi">+            degrees[degree].remove(v)</span>
<span class="gi">+            if not degrees[degree]:  # Clean up the degree list.</span>
<span class="gi">+                del degrees[degree]</span>
<span class="gi">+            degrees[degree - 1].add(v)</span>
<span class="gi">+</span>
<span class="gi">+        # Finally, remove the node.</span>
<span class="gi">+        H.remove_node(u)</span>
<span class="gi">+        lbound = min_degree - 1  # Subtract 1 in case of tied neighbors.</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def _maximal_independent_set(G):
<span class="gu">@@ -63,7 +108,14 @@ def _maximal_independent_set(G):</span>
<span class="w"> </span>    subgraph of unchosen nodes).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = set()</span>
<span class="gi">+    remaining = set(G)</span>
<span class="gi">+    while remaining:</span>
<span class="gi">+        G = G.subgraph(remaining)</span>
<span class="gi">+        v = min(remaining, key=G.degree)</span>
<span class="gi">+        result.add(v)</span>
<span class="gi">+        remaining -= set(G[v]) | {v}</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def strategy_independent_set(G, colors):
<span class="gu">@@ -83,7 +135,11 @@ def strategy_independent_set(G, colors):</span>
<span class="w"> </span>    instead of a maximal independent set.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    remaining_nodes = set(G)</span>
<span class="gi">+    while len(remaining_nodes) &gt; 0:</span>
<span class="gi">+        nodes = _maximal_independent_set(G.subgraph(remaining_nodes))</span>
<span class="gi">+        remaining_nodes -= nodes</span>
<span class="gi">+        yield from nodes</span>


<span class="w"> </span>def strategy_connected_sequential_bfs(G, colors):
<span class="gu">@@ -96,7 +152,7 @@ def strategy_connected_sequential_bfs(G, colors):</span>
<span class="w"> </span>    ``G`` is a NetworkX graph. ``colors`` is ignored.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return strategy_connected_sequential(G, colors, &quot;bfs&quot;)</span>


<span class="w"> </span>def strategy_connected_sequential_dfs(G, colors):
<span class="gu">@@ -109,10 +165,10 @@ def strategy_connected_sequential_dfs(G, colors):</span>
<span class="w"> </span>    ``G`` is a NetworkX graph. ``colors`` is ignored.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return strategy_connected_sequential(G, colors, &quot;dfs&quot;)</span>


<span class="gd">-def strategy_connected_sequential(G, colors, traversal=&#39;bfs&#39;):</span>
<span class="gi">+def strategy_connected_sequential(G, colors, traversal=&quot;bfs&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns an iterable over nodes in ``G`` in the order given by a
<span class="w"> </span>    breadth-first or depth-first traversal.

<span class="gu">@@ -126,7 +182,22 @@ def strategy_connected_sequential(G, colors, traversal=&#39;bfs&#39;):</span>
<span class="w"> </span>    ``G`` is a NetworkX graph. ``colors`` is ignored.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if traversal == &quot;bfs&quot;:</span>
<span class="gi">+        traverse = nx.bfs_edges</span>
<span class="gi">+    elif traversal == &quot;dfs&quot;:</span>
<span class="gi">+        traverse = nx.dfs_edges</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;Please specify one of the strings &#39;bfs&#39; or&quot;</span>
<span class="gi">+            &quot; &#39;dfs&#39; for connected sequential ordering&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    for component in nx.connected_components(G):</span>
<span class="gi">+        source = arbitrary_element(component)</span>
<span class="gi">+        # Yield the source node, then all the nodes in the specified</span>
<span class="gi">+        # traversal order.</span>
<span class="gi">+        yield source</span>
<span class="gi">+        for _, end in traverse(G.subgraph(component), source):</span>
<span class="gi">+            yield end</span>


<span class="w"> </span>def strategy_saturation_largest_first(G, colors):
<span class="gu">@@ -137,21 +208,61 @@ def strategy_saturation_largest_first(G, colors):</span>
<span class="w"> </span>    ``G`` to colors, for those nodes that have already been colored.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-STRATEGIES = {&#39;largest_first&#39;: strategy_largest_first, &#39;random_sequential&#39;:</span>
<span class="gd">-    strategy_random_sequential, &#39;smallest_last&#39;: strategy_smallest_last,</span>
<span class="gd">-    &#39;independent_set&#39;: strategy_independent_set, &#39;connected_sequential_bfs&#39;:</span>
<span class="gd">-    strategy_connected_sequential_bfs, &#39;connected_sequential_dfs&#39;:</span>
<span class="gd">-    strategy_connected_sequential_dfs, &#39;connected_sequential&#39;:</span>
<span class="gd">-    strategy_connected_sequential, &#39;saturation_largest_first&#39;:</span>
<span class="gd">-    strategy_saturation_largest_first, &#39;DSATUR&#39;:</span>
<span class="gd">-    strategy_saturation_largest_first}</span>
<span class="gi">+    distinct_colors = {v: set() for v in G}</span>
<span class="gi">+</span>
<span class="gi">+    # Add the node color assignments given in colors to the</span>
<span class="gi">+    # distinct colors set for each neighbor of that node</span>
<span class="gi">+    for node, color in colors.items():</span>
<span class="gi">+        for neighbor in G[node]:</span>
<span class="gi">+            distinct_colors[neighbor].add(color)</span>
<span class="gi">+</span>
<span class="gi">+    # Check that the color assignments in colors are valid</span>
<span class="gi">+    # i.e. no neighboring nodes have the same color</span>
<span class="gi">+    if len(colors) &gt;= 2:</span>
<span class="gi">+        for node, color in colors.items():</span>
<span class="gi">+            if color in distinct_colors[node]:</span>
<span class="gi">+                raise nx.NetworkXError(&quot;Neighboring nodes must have different colors&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # If 0 nodes have been colored, simply choose the node of highest degree.</span>
<span class="gi">+    if not colors:</span>
<span class="gi">+        node = max(G, key=G.degree)</span>
<span class="gi">+        yield node</span>
<span class="gi">+        # Add the color 0 to the distinct colors set for each</span>
<span class="gi">+        # neighbor of that node.</span>
<span class="gi">+        for v in G[node]:</span>
<span class="gi">+            distinct_colors[v].add(0)</span>
<span class="gi">+</span>
<span class="gi">+    while len(G) != len(colors):</span>
<span class="gi">+        # Update the distinct color sets for the neighbors.</span>
<span class="gi">+        for node, color in colors.items():</span>
<span class="gi">+            for neighbor in G[node]:</span>
<span class="gi">+                distinct_colors[neighbor].add(color)</span>
<span class="gi">+</span>
<span class="gi">+        # Compute the maximum saturation and the set of nodes that</span>
<span class="gi">+        # achieve that saturation.</span>
<span class="gi">+        saturation = {v: len(c) for v, c in distinct_colors.items() if v not in colors}</span>
<span class="gi">+        # Yield the node with the highest saturation, and break ties by</span>
<span class="gi">+        # degree.</span>
<span class="gi">+        node = max(saturation, key=lambda v: (saturation[v], G.degree(v)))</span>
<span class="gi">+        yield node</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: Dictionary mapping name of a strategy as a string to the strategy function.</span>
<span class="gi">+STRATEGIES = {</span>
<span class="gi">+    &quot;largest_first&quot;: strategy_largest_first,</span>
<span class="gi">+    &quot;random_sequential&quot;: strategy_random_sequential,</span>
<span class="gi">+    &quot;smallest_last&quot;: strategy_smallest_last,</span>
<span class="gi">+    &quot;independent_set&quot;: strategy_independent_set,</span>
<span class="gi">+    &quot;connected_sequential_bfs&quot;: strategy_connected_sequential_bfs,</span>
<span class="gi">+    &quot;connected_sequential_dfs&quot;: strategy_connected_sequential_dfs,</span>
<span class="gi">+    &quot;connected_sequential&quot;: strategy_connected_sequential,</span>
<span class="gi">+    &quot;saturation_largest_first&quot;: strategy_saturation_largest_first,</span>
<span class="gi">+    &quot;DSATUR&quot;: strategy_saturation_largest_first,</span>
<span class="gi">+}</span>


<span class="w"> </span>@nx._dispatchable
<span class="gd">-def greedy_color(G, strategy=&#39;largest_first&#39;, interchange=False):</span>
<span class="gi">+def greedy_color(G, strategy=&quot;largest_first&quot;, interchange=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Color a graph using various strategies of greedy graph coloring.

<span class="w"> </span>    Attempts to color a graph using as few colors as possible, where no
<span class="gu">@@ -230,11 +341,42 @@ def greedy_color(G, strategy=&#39;largest_first&#39;, interchange=False):</span>
<span class="w"> </span>       ISBN 0-486-45353-7.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+    # Determine the strategy provided by the caller.</span>
<span class="gi">+    strategy = STRATEGIES.get(strategy, strategy)</span>
<span class="gi">+    if not callable(strategy):</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;strategy must be callable or a valid string. {strategy} not valid.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    # Perform some validation on the arguments before executing any</span>
<span class="gi">+    # strategy functions.</span>
<span class="gi">+    if interchange:</span>
<span class="gi">+        if strategy is strategy_independent_set:</span>
<span class="gi">+            msg = &quot;interchange cannot be used with independent_set&quot;</span>
<span class="gi">+            raise nx.NetworkXPointlessConcept(msg)</span>
<span class="gi">+        if strategy is strategy_saturation_largest_first:</span>
<span class="gi">+            msg = &quot;interchange cannot be used with&quot; &quot; saturation_largest_first&quot;</span>
<span class="gi">+            raise nx.NetworkXPointlessConcept(msg)</span>
<span class="gi">+    colors = {}</span>
<span class="gi">+    nodes = strategy(G, colors)</span>
<span class="gi">+    if interchange:</span>
<span class="gi">+        return _greedy_coloring_with_interchange(G, nodes)</span>
<span class="gi">+    for u in nodes:</span>
<span class="gi">+        # Set to keep track of colors of neighbors</span>
<span class="gi">+        nbr_colors = {colors[v] for v in G[u] if v in colors}</span>
<span class="gi">+        # Find the first unused color.</span>
<span class="gi">+        for color in itertools.count():</span>
<span class="gi">+            if color not in nbr_colors:</span>
<span class="gi">+                break</span>
<span class="gi">+        # Assign the new color to the current node.</span>
<span class="gi">+        colors[u] = color</span>
<span class="gi">+    return colors</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Tools for coloring with interchanges</span>
<span class="w"> </span>class _Node:
<span class="gd">-    __slots__ = [&#39;node_id&#39;, &#39;color&#39;, &#39;adj_list&#39;, &#39;adj_color&#39;]</span>
<span class="gi">+    __slots__ = [&quot;node_id&quot;, &quot;color&quot;, &quot;adj_list&quot;, &quot;adj_color&quot;]</span>

<span class="w"> </span>    def __init__(self, node_id, n):
<span class="w"> </span>        self.node_id = node_id
<span class="gu">@@ -244,12 +386,40 @@ class _Node:</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return (
<span class="gd">-            f&#39;Node_id: {self.node_id}, Color: {self.color}, Adj_list: ({self.adj_list}), adj_color: ({self.adj_color})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&quot;Node_id: {self.node_id}, Color: {self.color}, &quot;</span>
<span class="gi">+            f&quot;Adj_list: ({self.adj_list}), adj_color: ({self.adj_color})&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def assign_color(self, adj_entry, color):</span>
<span class="gi">+        adj_entry.col_prev = None</span>
<span class="gi">+        adj_entry.col_next = self.adj_color[color]</span>
<span class="gi">+        self.adj_color[color] = adj_entry</span>
<span class="gi">+        if adj_entry.col_next is not None:</span>
<span class="gi">+            adj_entry.col_next.col_prev = adj_entry</span>
<span class="gi">+</span>
<span class="gi">+    def clear_color(self, adj_entry, color):</span>
<span class="gi">+        if adj_entry.col_prev is None:</span>
<span class="gi">+            self.adj_color[color] = adj_entry.col_next</span>
<span class="gi">+        else:</span>
<span class="gi">+            adj_entry.col_prev.col_next = adj_entry.col_next</span>
<span class="gi">+        if adj_entry.col_next is not None:</span>
<span class="gi">+            adj_entry.col_next.col_prev = adj_entry.col_prev</span>
<span class="gi">+</span>
<span class="gi">+    def iter_neighbors(self):</span>
<span class="gi">+        adj_node = self.adj_list</span>
<span class="gi">+        while adj_node is not None:</span>
<span class="gi">+            yield adj_node</span>
<span class="gi">+            adj_node = adj_node.next</span>
<span class="gi">+</span>
<span class="gi">+    def iter_neighbors_color(self, color):</span>
<span class="gi">+        adj_color_node = self.adj_color[color]</span>
<span class="gi">+        while adj_color_node is not None:</span>
<span class="gi">+            yield adj_color_node.node_id</span>
<span class="gi">+            adj_color_node = adj_color_node.col_next</span>


<span class="w"> </span>class _AdjEntry:
<span class="gd">-    __slots__ = [&#39;node_id&#39;, &#39;next&#39;, &#39;mate&#39;, &#39;col_next&#39;, &#39;col_prev&#39;]</span>
<span class="gi">+    __slots__ = [&quot;node_id&quot;, &quot;next&quot;, &quot;mate&quot;, &quot;col_next&quot;, &quot;col_prev&quot;]</span>

<span class="w"> </span>    def __init__(self, node_id):
<span class="w"> </span>        self.node_id = node_id
<span class="gu">@@ -262,8 +432,10 @@ class _AdjEntry:</span>
<span class="w"> </span>        col_next = None if self.col_next is None else self.col_next.node_id
<span class="w"> </span>        col_prev = None if self.col_prev is None else self.col_prev.node_id
<span class="w"> </span>        return (
<span class="gd">-            f&#39;Node_id: {self.node_id}, Next: ({self.next}), Mate: ({self.mate.node_id}), col_next: ({col_next}), col_prev: ({col_prev})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&quot;Node_id: {self.node_id}, Next: ({self.next}), &quot;</span>
<span class="gi">+            f&quot;Mate: ({self.mate.node_id}), &quot;</span>
<span class="gi">+            f&quot;col_next: ({col_next}), col_prev: ({col_prev})&quot;</span>
<span class="gi">+        )</span>


<span class="w"> </span>def _greedy_coloring_with_interchange(G, nodes):
<span class="gu">@@ -295,4 +467,98 @@ def _greedy_coloring_with_interchange(G, nodes):</span>
<span class="w"> </span>       Discrete Optimization Algorithms with Pascal Programs, 415-424, 1983.
<span class="w"> </span>       ISBN 0-486-45353-7.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+</span>
<span class="gi">+    graph = {node: _Node(node, n) for node in G}</span>
<span class="gi">+</span>
<span class="gi">+    for node1, node2 in G.edges():</span>
<span class="gi">+        adj_entry1 = _AdjEntry(node2)</span>
<span class="gi">+        adj_entry2 = _AdjEntry(node1)</span>
<span class="gi">+        adj_entry1.mate = adj_entry2</span>
<span class="gi">+        adj_entry2.mate = adj_entry1</span>
<span class="gi">+        node1_head = graph[node1].adj_list</span>
<span class="gi">+        adj_entry1.next = node1_head</span>
<span class="gi">+        graph[node1].adj_list = adj_entry1</span>
<span class="gi">+        node2_head = graph[node2].adj_list</span>
<span class="gi">+        adj_entry2.next = node2_head</span>
<span class="gi">+        graph[node2].adj_list = adj_entry2</span>
<span class="gi">+</span>
<span class="gi">+    k = 0</span>
<span class="gi">+    for node in nodes:</span>
<span class="gi">+        # Find the smallest possible, unused color</span>
<span class="gi">+        neighbors = graph[node].iter_neighbors()</span>
<span class="gi">+        col_used = {graph[adj_node.node_id].color for adj_node in neighbors}</span>
<span class="gi">+        col_used.discard(-1)</span>
<span class="gi">+        k1 = next(itertools.dropwhile(lambda x: x in col_used, itertools.count()))</span>
<span class="gi">+</span>
<span class="gi">+        # k1 is now the lowest available color</span>
<span class="gi">+        if k1 &gt; k:</span>
<span class="gi">+            connected = True</span>
<span class="gi">+            visited = set()</span>
<span class="gi">+            col1 = -1</span>
<span class="gi">+            col2 = -1</span>
<span class="gi">+            while connected and col1 &lt; k:</span>
<span class="gi">+                col1 += 1</span>
<span class="gi">+                neighbor_cols = graph[node].iter_neighbors_color(col1)</span>
<span class="gi">+                col1_adj = list(neighbor_cols)</span>
<span class="gi">+</span>
<span class="gi">+                col2 = col1</span>
<span class="gi">+                while connected and col2 &lt; k:</span>
<span class="gi">+                    col2 += 1</span>
<span class="gi">+                    visited = set(col1_adj)</span>
<span class="gi">+                    frontier = list(col1_adj)</span>
<span class="gi">+                    i = 0</span>
<span class="gi">+                    while i &lt; len(frontier):</span>
<span class="gi">+                        search_node = frontier[i]</span>
<span class="gi">+                        i += 1</span>
<span class="gi">+                        col_opp = col2 if graph[search_node].color == col1 else col1</span>
<span class="gi">+                        neighbor_cols = graph[search_node].iter_neighbors_color(col_opp)</span>
<span class="gi">+</span>
<span class="gi">+                        for neighbor in neighbor_cols:</span>
<span class="gi">+                            if neighbor not in visited:</span>
<span class="gi">+                                visited.add(neighbor)</span>
<span class="gi">+                                frontier.append(neighbor)</span>
<span class="gi">+</span>
<span class="gi">+                    # Search if node is not adj to any col2 vertex</span>
<span class="gi">+                    connected = (</span>
<span class="gi">+                        len(</span>
<span class="gi">+                            visited.intersection(graph[node].iter_neighbors_color(col2))</span>
<span class="gi">+                        )</span>
<span class="gi">+                        &gt; 0</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            # If connected is false then we can swap !!!</span>
<span class="gi">+            if not connected:</span>
<span class="gi">+                # Update all the nodes in the component</span>
<span class="gi">+                for search_node in visited:</span>
<span class="gi">+                    graph[search_node].color = (</span>
<span class="gi">+                        col2 if graph[search_node].color == col1 else col1</span>
<span class="gi">+                    )</span>
<span class="gi">+                    col2_adj = graph[search_node].adj_color[col2]</span>
<span class="gi">+                    graph[search_node].adj_color[col2] = graph[search_node].adj_color[</span>
<span class="gi">+                        col1</span>
<span class="gi">+                    ]</span>
<span class="gi">+                    graph[search_node].adj_color[col1] = col2_adj</span>
<span class="gi">+</span>
<span class="gi">+                # Update all the neighboring nodes</span>
<span class="gi">+                for search_node in visited:</span>
<span class="gi">+                    col = graph[search_node].color</span>
<span class="gi">+                    col_opp = col1 if col == col2 else col2</span>
<span class="gi">+                    for adj_node in graph[search_node].iter_neighbors():</span>
<span class="gi">+                        if graph[adj_node.node_id].color != col_opp:</span>
<span class="gi">+                            # Direct reference to entry</span>
<span class="gi">+                            adj_mate = adj_node.mate</span>
<span class="gi">+                            graph[adj_node.node_id].clear_color(adj_mate, col_opp)</span>
<span class="gi">+                            graph[adj_node.node_id].assign_color(adj_mate, col)</span>
<span class="gi">+                k1 = col1</span>
<span class="gi">+</span>
<span class="gi">+        # We can color this node color k1</span>
<span class="gi">+        graph[node].color = k1</span>
<span class="gi">+        k = max(k1, k)</span>
<span class="gi">+</span>
<span class="gi">+        # Update the neighbors of this node</span>
<span class="gi">+        for adj_node in graph[node].iter_neighbors():</span>
<span class="gi">+            adj_mate = adj_node.mate</span>
<span class="gi">+            graph[adj_node.node_id].assign_color(adj_mate, k1)</span>
<span class="gi">+</span>
<span class="gi">+    return {node.node_id: node.color for node in graph.values()}</span>
<span class="gh">diff --git a/networkx/algorithms/communicability_alg.py b/networkx/algorithms/communicability_alg.py</span>
<span class="gh">index 15d50b5a3..07316dc3a 100644</span>
<span class="gd">--- a/networkx/algorithms/communicability_alg.py</span>
<span class="gi">+++ b/networkx/algorithms/communicability_alg.py</span>
<span class="gu">@@ -3,14 +3,15 @@ Communicability.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;communicability&#39;, &#39;communicability_exp&#39;]</span>

<span class="gi">+__all__ = [&quot;communicability&quot;, &quot;communicability_exp&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def communicability(G):
<span class="gd">-    &quot;&quot;&quot;Returns communicability between all pairs of nodes in G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns communicability between all pairs of nodes in G.</span>

<span class="w"> </span>    The communicability between pairs of nodes in G is the sum of
<span class="w"> </span>    walks of different lengths starting at node u and ending at node v.
<span class="gu">@@ -47,11 +48,11 @@ def communicability(G):</span>
<span class="w"> </span>    is [1]_

<span class="w"> </span>    .. math::
<span class="gd">-        C(u,v)=\\sum_{j=1}^{n}\\phi_{j}(u)\\phi_{j}(v)e^{\\lambda_{j}},</span>
<span class="gi">+        C(u,v)=\sum_{j=1}^{n}\phi_{j}(u)\phi_{j}(v)e^{\lambda_{j}},</span>

<span class="gd">-    where `\\phi_{j}(u)` is the `u\\rm{th}` element of the `j\\rm{th}` orthonormal</span>
<span class="gi">+    where `\phi_{j}(u)` is the `u\rm{th}` element of the `j\rm{th}` orthonormal</span>
<span class="w"> </span>    eigenvector of the adjacency matrix associated with the eigenvalue
<span class="gd">-    `\\lambda_{j}`.</span>
<span class="gi">+    `\lambda_{j}`.</span>

<span class="w"> </span>    References
<span class="w"> </span>    ----------
<span class="gu">@@ -65,14 +66,34 @@ def communicability(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])
<span class="w"> </span>    &gt;&gt;&gt; c = nx.communicability(G)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    nodelist = list(G)  # ordering of nodes in matrix</span>
<span class="gi">+    A = nx.to_numpy_array(G, nodelist)</span>
<span class="gi">+    # convert to 0-1 matrix</span>
<span class="gi">+    A[A != 0.0] = 1</span>
<span class="gi">+    w, vec = np.linalg.eigh(A)</span>
<span class="gi">+    expw = np.exp(w)</span>
<span class="gi">+    mapping = dict(zip(nodelist, range(len(nodelist))))</span>
<span class="gi">+    c = {}</span>
<span class="gi">+    # computing communicabilities</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        c[u] = {}</span>
<span class="gi">+        for v in G:</span>
<span class="gi">+            s = 0</span>
<span class="gi">+            p = mapping[u]</span>
<span class="gi">+            q = mapping[v]</span>
<span class="gi">+            for j in range(len(nodelist)):</span>
<span class="gi">+                s += vec[:, j][p] * vec[:, j][q] * expw[j]</span>
<span class="gi">+            c[u][v] = float(s)</span>
<span class="gi">+    return c</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def communicability_exp(G):
<span class="gd">-    &quot;&quot;&quot;Returns communicability between all pairs of nodes in G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns communicability between all pairs of nodes in G.</span>

<span class="w"> </span>    Communicability between pair of node (u,v) of node in G is the sum of
<span class="w"> </span>    walks of different lengths starting at node u and ending at node v.
<span class="gu">@@ -124,4 +145,18 @@ def communicability_exp(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])
<span class="w"> </span>    &gt;&gt;&gt; c = nx.communicability_exp(G)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    nodelist = list(G)  # ordering of nodes in matrix</span>
<span class="gi">+    A = nx.to_numpy_array(G, nodelist)</span>
<span class="gi">+    # convert to 0-1 matrix</span>
<span class="gi">+    A[A != 0.0] = 1</span>
<span class="gi">+    # communicability matrix</span>
<span class="gi">+    expA = sp.linalg.expm(A)</span>
<span class="gi">+    mapping = dict(zip(nodelist, range(len(nodelist))))</span>
<span class="gi">+    c = {}</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        c[u] = {}</span>
<span class="gi">+        for v in G:</span>
<span class="gi">+            c[u][v] = float(expA[mapping[u], mapping[v]])</span>
<span class="gi">+    return c</span>
<span class="gh">diff --git a/networkx/algorithms/community/asyn_fluid.py b/networkx/algorithms/community/asyn_fluid.py</span>
<span class="gh">index ef356e67b..fea72c1bf 100644</span>
<span class="gd">--- a/networkx/algorithms/community/asyn_fluid.py</span>
<span class="gi">+++ b/networkx/algorithms/community/asyn_fluid.py</span>
<span class="gu">@@ -1,14 +1,17 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Asynchronous Fluid Communities algorithm for community detection.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import Counter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.components import is_connected
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.utils import groups, not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;asyn_fluidc&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;asyn_fluidc&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@py_random_state(3)
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def asyn_fluidc(G, k, max_iter=100, seed=None):
<span class="gu">@@ -64,4 +67,85 @@ def asyn_fluidc(G, k, max_iter=100, seed=None):</span>
<span class="w"> </span>       Competitive and Highly Scalable Community Detection Algorithm&quot;.
<span class="w"> </span>       [https://arxiv.org/pdf/1703.09307.pdf].
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Initial checks</span>
<span class="gi">+    if not isinstance(k, int):</span>
<span class="gi">+        raise NetworkXError(&quot;k must be an integer.&quot;)</span>
<span class="gi">+    if not k &gt; 0:</span>
<span class="gi">+        raise NetworkXError(&quot;k must be greater than 0.&quot;)</span>
<span class="gi">+    if not is_connected(G):</span>
<span class="gi">+        raise NetworkXError(&quot;Fluid Communities require connected Graphs.&quot;)</span>
<span class="gi">+    if len(G) &lt; k:</span>
<span class="gi">+        raise NetworkXError(&quot;k cannot be bigger than the number of nodes.&quot;)</span>
<span class="gi">+    # Initialization</span>
<span class="gi">+    max_density = 1.0</span>
<span class="gi">+    vertices = list(G)</span>
<span class="gi">+    seed.shuffle(vertices)</span>
<span class="gi">+    communities = {n: i for i, n in enumerate(vertices[:k])}</span>
<span class="gi">+    density = {}</span>
<span class="gi">+    com_to_numvertices = {}</span>
<span class="gi">+    for vertex in communities:</span>
<span class="gi">+        com_to_numvertices[communities[vertex]] = 1</span>
<span class="gi">+        density[communities[vertex]] = max_density</span>
<span class="gi">+    # Set up control variables and start iterating</span>
<span class="gi">+    iter_count = 0</span>
<span class="gi">+    cont = True</span>
<span class="gi">+    while cont:</span>
<span class="gi">+        cont = False</span>
<span class="gi">+        iter_count += 1</span>
<span class="gi">+        # Loop over all vertices in graph in a random order</span>
<span class="gi">+        vertices = list(G)</span>
<span class="gi">+        seed.shuffle(vertices)</span>
<span class="gi">+        for vertex in vertices:</span>
<span class="gi">+            # Updating rule</span>
<span class="gi">+            com_counter = Counter()</span>
<span class="gi">+            # Take into account self vertex community</span>
<span class="gi">+            try:</span>
<span class="gi">+                com_counter.update({communities[vertex]: density[communities[vertex]]})</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            # Gather neighbor vertex communities</span>
<span class="gi">+            for v in G[vertex]:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    com_counter.update({communities[v]: density[communities[v]]})</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            # Check which is the community with highest density</span>
<span class="gi">+            new_com = -1</span>
<span class="gi">+            if len(com_counter.keys()) &gt; 0:</span>
<span class="gi">+                max_freq = max(com_counter.values())</span>
<span class="gi">+                best_communities = [</span>
<span class="gi">+                    com</span>
<span class="gi">+                    for com, freq in com_counter.items()</span>
<span class="gi">+                    if (max_freq - freq) &lt; 0.0001</span>
<span class="gi">+                ]</span>
<span class="gi">+                # If actual vertex com in best communities, it is preserved</span>
<span class="gi">+                try:</span>
<span class="gi">+                    if communities[vertex] in best_communities:</span>
<span class="gi">+                        new_com = communities[vertex]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                # If vertex community changes...</span>
<span class="gi">+                if new_com == -1:</span>
<span class="gi">+                    # Set flag of non-convergence</span>
<span class="gi">+                    cont = True</span>
<span class="gi">+                    # Randomly chose a new community from candidates</span>
<span class="gi">+                    new_com = seed.choice(best_communities)</span>
<span class="gi">+                    # Update previous community status</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        com_to_numvertices[communities[vertex]] -= 1</span>
<span class="gi">+                        density[communities[vertex]] = (</span>
<span class="gi">+                            max_density / com_to_numvertices[communities[vertex]]</span>
<span class="gi">+                        )</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                    # Update new community status</span>
<span class="gi">+                    communities[vertex] = new_com</span>
<span class="gi">+                    com_to_numvertices[communities[vertex]] += 1</span>
<span class="gi">+                    density[communities[vertex]] = (</span>
<span class="gi">+                        max_density / com_to_numvertices[communities[vertex]]</span>
<span class="gi">+                    )</span>
<span class="gi">+        # If maximum iterations reached --&gt; output actual results</span>
<span class="gi">+        if iter_count &gt; max_iter:</span>
<span class="gi">+            break</span>
<span class="gi">+    # Return results by grouping communities as list of vertices</span>
<span class="gi">+    return iter(groups(communities).values())</span>
<span class="gh">diff --git a/networkx/algorithms/community/centrality.py b/networkx/algorithms/community/centrality.py</span>
<span class="gh">index a1b112283..43281701d 100644</span>
<span class="gd">--- a/networkx/algorithms/community/centrality.py</span>
<span class="gi">+++ b/networkx/algorithms/community/centrality.py</span>
<span class="gu">@@ -1,9 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing communities based on centrality notions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;girvan_newman&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;girvan_newman&quot;]</span>


<span class="gd">-@nx._dispatchable(preserve_edge_attrs=&#39;most_valuable_edge&#39;)</span>
<span class="gi">+@nx._dispatchable(preserve_edge_attrs=&quot;most_valuable_edge&quot;)</span>
<span class="w"> </span>def girvan_newman(G, most_valuable_edge=None):
<span class="w"> </span>    &quot;&quot;&quot;Finds communities in a graph using the Girvan–Newman method.

<span class="gu">@@ -118,7 +120,32 @@ def girvan_newman(G, most_valuable_edge=None):</span>
<span class="w"> </span>    result can be depicted as a dendrogram.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # If the graph is already empty, simply return its connected</span>
<span class="gi">+    # components.</span>
<span class="gi">+    if G.number_of_edges() == 0:</span>
<span class="gi">+        yield tuple(nx.connected_components(G))</span>
<span class="gi">+        return</span>
<span class="gi">+    # If no function is provided for computing the most valuable edge,</span>
<span class="gi">+    # use the edge betweenness centrality.</span>
<span class="gi">+    if most_valuable_edge is None:</span>
<span class="gi">+</span>
<span class="gi">+        def most_valuable_edge(G):</span>
<span class="gi">+            &quot;&quot;&quot;Returns the edge with the highest betweenness centrality</span>
<span class="gi">+            in the graph `G`.</span>
<span class="gi">+</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            # We have guaranteed that the graph is non-empty, so this</span>
<span class="gi">+            # dictionary will never be empty.</span>
<span class="gi">+            betweenness = nx.edge_betweenness_centrality(G)</span>
<span class="gi">+            return max(betweenness, key=betweenness.get)</span>
<span class="gi">+</span>
<span class="gi">+    # The copy of G here must include the edge weight data.</span>
<span class="gi">+    g = G.copy().to_undirected()</span>
<span class="gi">+    # Self-loops must be removed because their removal has no effect on</span>
<span class="gi">+    # the connected components of the graph.</span>
<span class="gi">+    g.remove_edges_from(nx.selfloop_edges(g))</span>
<span class="gi">+    while g.number_of_edges() &gt; 0:</span>
<span class="gi">+        yield _without_most_central_edges(g, most_valuable_edge)</span>


<span class="w"> </span>def _without_most_central_edges(G, most_valuable_edge):
<span class="gu">@@ -134,4 +161,11 @@ def _without_most_central_edges(G, most_valuable_edge):</span>
<span class="w"> </span>    until the number of connected components in the graph increases.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    original_num_components = nx.number_connected_components(G)</span>
<span class="gi">+    num_new_components = original_num_components</span>
<span class="gi">+    while num_new_components &lt;= original_num_components:</span>
<span class="gi">+        edge = most_valuable_edge(G)</span>
<span class="gi">+        G.remove_edge(*edge)</span>
<span class="gi">+        new_components = tuple(nx.connected_components(G))</span>
<span class="gi">+        num_new_components = len(new_components)</span>
<span class="gi">+    return new_components</span>
<span class="gh">diff --git a/networkx/algorithms/community/community_utils.py b/networkx/algorithms/community/community_utils.py</span>
<span class="gh">index fc2cf463b..b57cd9881 100644</span>
<span class="gd">--- a/networkx/algorithms/community/community_utils.py</span>
<span class="gi">+++ b/networkx/algorithms/community/community_utils.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Helper functions for community-finding algorithms.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;is_partition&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;is_partition&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -19,4 +20,10 @@ def is_partition(G, communities):</span>
<span class="w"> </span>        If it is an iterator it is exhausted.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Alternate implementation:</span>
<span class="gi">+    # return all(sum(1 if v in c else 0 for c in communities) == 1 for v in G)</span>
<span class="gi">+    if not isinstance(communities, list):</span>
<span class="gi">+        communities = list(communities)</span>
<span class="gi">+    nodes = {n for c in communities for n in c if n in G}</span>
<span class="gi">+</span>
<span class="gi">+    return len(G) == len(nodes) == sum(len(c) for c in communities)</span>
<span class="gh">diff --git a/networkx/algorithms/community/divisive.py b/networkx/algorithms/community/divisive.py</span>
<span class="gh">index 7fc0c5cb3..1fc395946 100644</span>
<span class="gd">--- a/networkx/algorithms/community/divisive.py</span>
<span class="gi">+++ b/networkx/algorithms/community/divisive.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>import functools
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;edge_betweenness_partition&#39;,</span>
<span class="gd">-    &#39;edge_current_flow_betweenness_partition&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;edge_betweenness_partition&quot;,</span>
<span class="gi">+    &quot;edge_current_flow_betweenness_partition&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def edge_betweenness_partition(G, number_of_sets, *, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Partition created by iteratively removing the highest edge betweenness edge.

<span class="gu">@@ -61,10 +65,26 @@ def edge_betweenness_partition(G, number_of_sets, *, weight=None):</span>
<span class="w"> </span>       Volume 486, Issue 3-5 p. 75-174
<span class="w"> </span>       http://arxiv.org/abs/0906.0612
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    if number_of_sets &lt;= 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;number_of_sets must be &gt;0&quot;)</span>
<span class="gi">+    if number_of_sets == 1:</span>
<span class="gi">+        return [set(G)]</span>
<span class="gi">+    if number_of_sets == len(G):</span>
<span class="gi">+        return [{n} for n in G]</span>
<span class="gi">+    if number_of_sets &gt; len(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;number_of_sets must be &lt;= len(G)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    H = G.copy()</span>
<span class="gi">+    partition = list(nx.connected_components(H))</span>
<span class="gi">+    while len(partition) &lt; number_of_sets:</span>
<span class="gi">+        ranking = nx.edge_betweenness_centrality(H, weight=weight)</span>
<span class="gi">+        edge = max(ranking, key=ranking.get)</span>
<span class="gi">+        H.remove_edge(*edge)</span>
<span class="gi">+        partition = list(nx.connected_components(H))</span>
<span class="gi">+    return partition</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def edge_current_flow_betweenness_partition(G, number_of_sets, *, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Partition created by removing the highest edge current flow betweenness edge.

<span class="gu">@@ -121,4 +141,56 @@ def edge_current_flow_betweenness_partition(G, number_of_sets, *, weight=None):</span>
<span class="w"> </span>       Volume 486, Issue 3-5 p. 75-174
<span class="w"> </span>       http://arxiv.org/abs/0906.0612
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if number_of_sets &lt;= 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;number_of_sets must be &gt;0&quot;)</span>
<span class="gi">+    elif number_of_sets == 1:</span>
<span class="gi">+        return [set(G)]</span>
<span class="gi">+    elif number_of_sets == len(G):</span>
<span class="gi">+        return [{n} for n in G]</span>
<span class="gi">+    elif number_of_sets &gt; len(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;number_of_sets must be &lt;= len(G)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    rank = functools.partial(</span>
<span class="gi">+        nx.edge_current_flow_betweenness_centrality, normalized=False, weight=weight</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # current flow requires a connected network so we track the components explicitly</span>
<span class="gi">+    H = G.copy()</span>
<span class="gi">+    partition = list(nx.connected_components(H))</span>
<span class="gi">+    if len(partition) &gt; 1:</span>
<span class="gi">+        Hcc_subgraphs = [H.subgraph(cc).copy() for cc in partition]</span>
<span class="gi">+    else:</span>
<span class="gi">+        Hcc_subgraphs = [H]</span>
<span class="gi">+</span>
<span class="gi">+    ranking = {}</span>
<span class="gi">+    for Hcc in Hcc_subgraphs:</span>
<span class="gi">+        ranking.update(rank(Hcc))</span>
<span class="gi">+</span>
<span class="gi">+    while len(partition) &lt; number_of_sets:</span>
<span class="gi">+        edge = max(ranking, key=ranking.get)</span>
<span class="gi">+        for cc, Hcc in zip(partition, Hcc_subgraphs):</span>
<span class="gi">+            if edge[0] in cc:</span>
<span class="gi">+                Hcc.remove_edge(*edge)</span>
<span class="gi">+                del ranking[edge]</span>
<span class="gi">+                splitcc_list = list(nx.connected_components(Hcc))</span>
<span class="gi">+                if len(splitcc_list) &gt; 1:</span>
<span class="gi">+                    # there are 2 connected components. split off smaller one</span>
<span class="gi">+                    cc_new = min(splitcc_list, key=len)</span>
<span class="gi">+                    Hcc_new = Hcc.subgraph(cc_new).copy()</span>
<span class="gi">+                    # update edge rankings for Hcc_new</span>
<span class="gi">+                    newranks = rank(Hcc_new)</span>
<span class="gi">+                    for e, r in newranks.items():</span>
<span class="gi">+                        ranking[e if e in ranking else e[::-1]] = r</span>
<span class="gi">+                    # append new cc and Hcc to their lists.</span>
<span class="gi">+                    partition.append(cc_new)</span>
<span class="gi">+                    Hcc_subgraphs.append(Hcc_new)</span>
<span class="gi">+</span>
<span class="gi">+                    # leave existing cc and Hcc in their lists, but shrink them</span>
<span class="gi">+                    Hcc.remove_nodes_from(cc_new)</span>
<span class="gi">+                    cc.difference_update(cc_new)</span>
<span class="gi">+                # update edge rankings for Hcc whether it was split or not</span>
<span class="gi">+                newranks = rank(Hcc)</span>
<span class="gi">+                for e, r in newranks.items():</span>
<span class="gi">+                    ranking[e if e in ranking else e[::-1]] = r</span>
<span class="gi">+                break</span>
<span class="gi">+    return partition</span>
<span class="gh">diff --git a/networkx/algorithms/community/kclique.py b/networkx/algorithms/community/kclique.py</span>
<span class="gh">index d9a8035c6..c72491042 100644</span>
<span class="gd">--- a/networkx/algorithms/community/kclique.py</span>
<span class="gi">+++ b/networkx/algorithms/community/kclique.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;k_clique_communities&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;k_clique_communities&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -42,4 +44,36 @@ def k_clique_communities(G, k, cliques=None):</span>
<span class="w"> </span>       in nature and society Nature 435, 814-818, 2005,
<span class="w"> </span>       doi:10.1038/nature03607
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if k &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;k={k}, k must be greater than 1.&quot;)</span>
<span class="gi">+    if cliques is None:</span>
<span class="gi">+        cliques = nx.find_cliques(G)</span>
<span class="gi">+    cliques = [frozenset(c) for c in cliques if len(c) &gt;= k]</span>
<span class="gi">+</span>
<span class="gi">+    # First index which nodes are in which cliques</span>
<span class="gi">+    membership_dict = defaultdict(list)</span>
<span class="gi">+    for clique in cliques:</span>
<span class="gi">+        for node in clique:</span>
<span class="gi">+            membership_dict[node].append(clique)</span>
<span class="gi">+</span>
<span class="gi">+    # For each clique, see which adjacent cliques percolate</span>
<span class="gi">+    perc_graph = nx.Graph()</span>
<span class="gi">+    perc_graph.add_nodes_from(cliques)</span>
<span class="gi">+    for clique in cliques:</span>
<span class="gi">+        for adj_clique in _get_adjacent_cliques(clique, membership_dict):</span>
<span class="gi">+            if len(clique.intersection(adj_clique)) &gt;= (k - 1):</span>
<span class="gi">+                perc_graph.add_edge(clique, adj_clique)</span>
<span class="gi">+</span>
<span class="gi">+    # Connected components of clique graph with perc edges</span>
<span class="gi">+    # are the percolated cliques</span>
<span class="gi">+    for component in nx.connected_components(perc_graph):</span>
<span class="gi">+        yield (frozenset.union(*component))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_adjacent_cliques(clique, membership_dict):</span>
<span class="gi">+    adjacent_cliques = set()</span>
<span class="gi">+    for n in clique:</span>
<span class="gi">+        for adj_clique in membership_dict[n]:</span>
<span class="gi">+            if clique != adj_clique:</span>
<span class="gi">+                adjacent_cliques.add(adj_clique)</span>
<span class="gi">+    return adjacent_cliques</span>
<span class="gh">diff --git a/networkx/algorithms/community/kernighan_lin.py b/networkx/algorithms/community/kernighan_lin.py</span>
<span class="gh">index 893673e41..f6397d82b 100644</span>
<span class="gd">--- a/networkx/algorithms/community/kernighan_lin.py</span>
<span class="gi">+++ b/networkx/algorithms/community/kernighan_lin.py</span>
<span class="gu">@@ -1,9 +1,12 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing the Kernighan–Lin bipartition algorithm.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from itertools import count
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.community.community_utils import is_partition
<span class="w"> </span>from networkx.utils import BinaryHeap, not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;kernighan_lin_bisection&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;kernighan_lin_bisection&quot;]</span>


<span class="w"> </span>def _kernighan_lin_sweep(edges, side):
<span class="gu">@@ -12,14 +15,35 @@ def _kernighan_lin_sweep(edges, side):</span>
<span class="w"> </span>    time, alternating between sides to keep the bisection balanced.  We keep
<span class="w"> </span>    two min-heaps of swap costs to make optimal-next-move selection fast.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    costs0, costs1 = costs = BinaryHeap(), BinaryHeap()</span>
<span class="gi">+    for u, side_u, edges_u in zip(count(), side, edges):</span>
<span class="gi">+        cost_u = sum(w if side[v] else -w for v, w in edges_u)</span>
<span class="gi">+        costs[side_u].insert(u, cost_u if side_u else -cost_u)</span>
<span class="gi">+</span>
<span class="gi">+    def _update_costs(costs_x, x):</span>
<span class="gi">+        for y, w in edges[x]:</span>
<span class="gi">+            costs_y = costs[side[y]]</span>
<span class="gi">+            cost_y = costs_y.get(y)</span>
<span class="gi">+            if cost_y is not None:</span>
<span class="gi">+                cost_y += 2 * (-w if costs_x is costs_y else w)</span>
<span class="gi">+                costs_y.insert(y, cost_y, True)</span>
<span class="gi">+</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    totcost = 0</span>
<span class="gi">+    while costs0 and costs1:</span>
<span class="gi">+        u, cost_u = costs0.pop()</span>
<span class="gi">+        _update_costs(costs0, u)</span>
<span class="gi">+        v, cost_v = costs1.pop()</span>
<span class="gi">+        _update_costs(costs1, v)</span>
<span class="gi">+        totcost += cost_u + cost_v</span>
<span class="gi">+        i += 1</span>
<span class="gi">+        yield totcost, i, (u, v)</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@py_random_state(4)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def kernighan_lin_bisection(G, partition=None, max_iter=10, weight=&#39;weight&#39;,</span>
<span class="gd">-    seed=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def kernighan_lin_bisection(G, partition=None, max_iter=10, weight=&quot;weight&quot;, seed=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Partition a graph into two blocks using the Kernighan–Lin
<span class="w"> </span>    algorithm.

<span class="gu">@@ -69,4 +93,47 @@ def kernighan_lin_bisection(G, partition=None, max_iter=10, weight=&#39;weight&#39;,</span>
<span class="w"> </span>       Oxford University Press 2011.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    labels = list(G)</span>
<span class="gi">+    seed.shuffle(labels)</span>
<span class="gi">+    index = {v: i for i, v in enumerate(labels)}</span>
<span class="gi">+</span>
<span class="gi">+    if partition is None:</span>
<span class="gi">+        side = [0] * (n // 2) + [1] * ((n + 1) // 2)</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            A, B = partition</span>
<span class="gi">+        except (TypeError, ValueError) as err:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;partition must be two sets&quot;) from err</span>
<span class="gi">+        if not is_partition(G, (A, B)):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;partition invalid&quot;)</span>
<span class="gi">+        side = [0] * n</span>
<span class="gi">+        for a in A:</span>
<span class="gi">+            side[index[a]] = 1</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        edges = [</span>
<span class="gi">+            [</span>
<span class="gi">+                (index[u], sum(e.get(weight, 1) for e in d.values()))</span>
<span class="gi">+                for u, d in G[v].items()</span>
<span class="gi">+            ]</span>
<span class="gi">+            for v in labels</span>
<span class="gi">+        ]</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = [</span>
<span class="gi">+            [(index[u], e.get(weight, 1)) for u, e in G[v].items()] for v in labels</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(max_iter):</span>
<span class="gi">+        costs = list(_kernighan_lin_sweep(edges, side))</span>
<span class="gi">+        min_cost, min_i, _ = min(costs)</span>
<span class="gi">+        if min_cost &gt;= 0:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        for _, _, (u, v) in costs[:min_i]:</span>
<span class="gi">+            side[u] = 1</span>
<span class="gi">+            side[v] = 0</span>
<span class="gi">+</span>
<span class="gi">+    A = {u for u, s in zip(labels, side) if s == 0}</span>
<span class="gi">+    B = {u for u, s in zip(labels, side) if s == 1}</span>
<span class="gi">+    return A, B</span>
<span class="gh">diff --git a/networkx/algorithms/community/label_propagation.py b/networkx/algorithms/community/label_propagation.py</span>
<span class="gh">index 06e9bef37..869085576 100644</span>
<span class="gd">--- a/networkx/algorithms/community/label_propagation.py</span>
<span class="gi">+++ b/networkx/algorithms/community/label_propagation.py</span>
<span class="gu">@@ -2,14 +2,19 @@</span>
<span class="w"> </span>Label propagation community detection algorithms.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections import Counter, defaultdict, deque
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import groups, not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;label_propagation_communities&#39;, &#39;asyn_lpa_communities&#39;,</span>
<span class="gd">-    &#39;fast_label_propagation_communities&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;label_propagation_communities&quot;,</span>
<span class="gi">+    &quot;asyn_lpa_communities&quot;,</span>
<span class="gi">+    &quot;fast_label_propagation_communities&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@py_random_state(&#39;seed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@py_random_state(&quot;seed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def fast_label_propagation_communities(G, *, weight=None, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns communities in `G` as detected by fast label propagation.

<span class="gu">@@ -57,7 +62,43 @@ def fast_label_propagation_communities(G, *, weight=None, seed=None):</span>
<span class="w"> </span>       fast label propagation.&quot; Scientific Reports 13 (2023): 2701.
<span class="w"> </span>       https://doi.org/10.1038/s41598-023-29610-z
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Queue of nodes to be processed.</span>
<span class="gi">+    nodes_queue = deque(G)</span>
<span class="gi">+    seed.shuffle(nodes_queue)</span>
<span class="gi">+</span>
<span class="gi">+    # Set of nodes in the queue.</span>
<span class="gi">+    nodes_set = set(G)</span>
<span class="gi">+</span>
<span class="gi">+    # Assign unique label to each node.</span>
<span class="gi">+    comms = {node: i for i, node in enumerate(G)}</span>
<span class="gi">+</span>
<span class="gi">+    while nodes_queue:</span>
<span class="gi">+        # Remove next node from the queue to process.</span>
<span class="gi">+        node = nodes_queue.popleft()</span>
<span class="gi">+        nodes_set.remove(node)</span>
<span class="gi">+</span>
<span class="gi">+        # Isolated nodes retain their initial label.</span>
<span class="gi">+        if G.degree(node) &gt; 0:</span>
<span class="gi">+            # Compute frequency of labels in node&#39;s neighborhood.</span>
<span class="gi">+            label_freqs = _fast_label_count(G, comms, node, weight)</span>
<span class="gi">+            max_freq = max(label_freqs.values())</span>
<span class="gi">+</span>
<span class="gi">+            # Always sample new label from most frequent labels.</span>
<span class="gi">+            comm = seed.choice(</span>
<span class="gi">+                [comm for comm in label_freqs if label_freqs[comm] == max_freq]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if comms[node] != comm:</span>
<span class="gi">+                comms[node] = comm</span>
<span class="gi">+</span>
<span class="gi">+                # Add neighbors that have different label to the queue.</span>
<span class="gi">+                for nbr in nx.all_neighbors(G, node):</span>
<span class="gi">+                    if comms[nbr] != comm and nbr not in nodes_set:</span>
<span class="gi">+                        nodes_queue.append(nbr)</span>
<span class="gi">+                        nodes_set.add(nbr)</span>
<span class="gi">+</span>
<span class="gi">+    yield from groups(comms).values()</span>


<span class="w"> </span>def _fast_label_count(G, comms, node, weight=None):
<span class="gu">@@ -65,11 +106,38 @@ def _fast_label_count(G, comms, node, weight=None):</span>

<span class="w"> </span>    Returns a dictionary keyed by label to the frequency of that label.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if weight is None:</span>
<span class="gi">+        # Unweighted (un)directed simple graph.</span>
<span class="gi">+        if not G.is_multigraph():</span>
<span class="gi">+            label_freqs = Counter(map(comms.get, nx.all_neighbors(G, node)))</span>
<span class="gi">+</span>
<span class="gi">+        # Unweighted (un)directed multigraph.</span>
<span class="gi">+        else:</span>
<span class="gi">+            label_freqs = defaultdict(int)</span>
<span class="gi">+            for nbr in G[node]:</span>
<span class="gi">+                label_freqs[comms[nbr]] += len(G[node][nbr])</span>
<span class="gi">+</span>
<span class="gi">+            if G.is_directed():</span>
<span class="gi">+                for nbr in G.pred[node]:</span>
<span class="gi">+                    label_freqs[comms[nbr]] += len(G.pred[node][nbr])</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Weighted undirected simple/multigraph.</span>
<span class="gi">+        label_freqs = defaultdict(float)</span>
<span class="gi">+        for _, nbr, w in G.edges(node, data=weight, default=1):</span>
<span class="gi">+            label_freqs[comms[nbr]] += w</span>
<span class="gi">+</span>
<span class="gi">+        # Weighted directed simple/multigraph.</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            for nbr, _, w in G.in_edges(node, data=weight, default=1):</span>
<span class="gi">+                label_freqs[comms[nbr]] += w</span>
<span class="gi">+</span>
<span class="gi">+    return label_freqs</span>


<span class="w"> </span>@py_random_state(2)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def asyn_lpa_communities(G, weight=None, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns communities in `G` as detected by asynchronous label
<span class="w"> </span>    propagation.
<span class="gu">@@ -119,10 +187,52 @@ def asyn_lpa_communities(G, weight=None, seed=None):</span>
<span class="w"> </span>           linear time algorithm to detect community structures in large-scale
<span class="w"> </span>           networks.&quot; Physical Review E 76.3 (2007): 036106.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    labels = {n: i for i, n in enumerate(G)}</span>
<span class="gi">+    cont = True</span>
<span class="gi">+</span>
<span class="gi">+    while cont:</span>
<span class="gi">+        cont = False</span>
<span class="gi">+        nodes = list(G)</span>
<span class="gi">+        seed.shuffle(nodes)</span>
<span class="gi">+</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            if not G[node]:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Get label frequencies among adjacent nodes.</span>
<span class="gi">+            # Depending on the order they are processed in,</span>
<span class="gi">+            # some nodes will be in iteration t and others in t-1,</span>
<span class="gi">+            # making the algorithm asynchronous.</span>
<span class="gi">+            if weight is None:</span>
<span class="gi">+                # initialising a Counter from an iterator of labels is</span>
<span class="gi">+                # faster for getting unweighted label frequencies</span>
<span class="gi">+                label_freq = Counter(map(labels.get, G[node]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                # updating a defaultdict is substantially faster</span>
<span class="gi">+                # for getting weighted label frequencies</span>
<span class="gi">+                label_freq = defaultdict(float)</span>
<span class="gi">+                for _, v, wt in G.edges(node, data=weight, default=1):</span>
<span class="gi">+                    label_freq[labels[v]] += wt</span>
<span class="gi">+</span>
<span class="gi">+            # Get the labels that appear with maximum frequency.</span>
<span class="gi">+            max_freq = max(label_freq.values())</span>
<span class="gi">+            best_labels = [</span>
<span class="gi">+                label for label, freq in label_freq.items() if freq == max_freq</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+            # If the node does not have one of the maximum frequency labels,</span>
<span class="gi">+            # randomly choose one of them and update the node&#39;s label.</span>
<span class="gi">+            # Continue the iteration as long as at least one node</span>
<span class="gi">+            # doesn&#39;t have a maximum frequency label.</span>
<span class="gi">+            if labels[node] not in best_labels:</span>
<span class="gi">+                labels[node] = seed.choice(best_labels)</span>
<span class="gi">+                cont = True</span>
<span class="gi">+</span>
<span class="gi">+    yield from groups(labels).values()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def label_propagation_communities(G):
<span class="w"> </span>    &quot;&quot;&quot;Generates community sets determined by label propagation
<span class="gu">@@ -153,7 +263,19 @@ def label_propagation_communities(G):</span>
<span class="w"> </span>       Applications of Social Network Analysis (BASNA), 2010 IEEE International
<span class="w"> </span>       Workshop on (pp. 1-8). IEEE.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    coloring = _color_network(G)</span>
<span class="gi">+    # Create a unique label for each node in the graph</span>
<span class="gi">+    labeling = {v: k for k, v in enumerate(G)}</span>
<span class="gi">+    while not _labeling_complete(labeling, G):</span>
<span class="gi">+        # Update the labels of every node with the same color.</span>
<span class="gi">+        for color, nodes in coloring.items():</span>
<span class="gi">+            for n in nodes:</span>
<span class="gi">+                _update_label(n, labeling, G)</span>
<span class="gi">+</span>
<span class="gi">+    clusters = defaultdict(set)</span>
<span class="gi">+    for node, label in labeling.items():</span>
<span class="gi">+        clusters[label].add(node)</span>
<span class="gi">+    return clusters.values()</span>


<span class="w"> </span>def _color_network(G):
<span class="gu">@@ -161,7 +283,14 @@ def _color_network(G):</span>

<span class="w"> </span>    Returns a dict keyed by color to a set of nodes with that color.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    coloring = {}  # color =&gt; set(node)</span>
<span class="gi">+    colors = nx.coloring.greedy_color(G)</span>
<span class="gi">+    for node, color in colors.items():</span>
<span class="gi">+        if color in coloring:</span>
<span class="gi">+            coloring[color].add(node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            coloring[color] = {node}</span>
<span class="gi">+    return coloring</span>


<span class="w"> </span>def _labeling_complete(labeling, G):
<span class="gu">@@ -172,7 +301,9 @@ def _labeling_complete(labeling, G):</span>

<span class="w"> </span>    Nodes with no neighbors are considered complete.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return all(</span>
<span class="gi">+        labeling[v] in _most_frequent_labels(v, labeling, G) for v in G if len(G[v]) &gt; 0</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _most_frequent_labels(node, labeling, G):
<span class="gu">@@ -180,7 +311,15 @@ def _most_frequent_labels(node, labeling, G):</span>

<span class="w"> </span>    Input `labeling` should be a dict keyed by node to labels.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not G[node]:</span>
<span class="gi">+        # Nodes with no neighbors are themselves a community and are labeled</span>
<span class="gi">+        # accordingly, hence the immediate if statement.</span>
<span class="gi">+        return {labeling[node]}</span>
<span class="gi">+</span>
<span class="gi">+    # Compute the frequencies of all neighbors of node</span>
<span class="gi">+    freqs = Counter(labeling[q] for q in G[node])</span>
<span class="gi">+    max_freq = max(freqs.values())</span>
<span class="gi">+    return {label for label, freq in freqs.items() if freq == max_freq}</span>


<span class="w"> </span>def _update_label(node, labeling, G):
<span class="gu">@@ -189,4 +328,10 @@ def _update_label(node, labeling, G):</span>
<span class="w"> </span>    The algorithm is explained in: &#39;Community Detection via Semi-Synchronous
<span class="w"> </span>    Label Propagation Algorithms&#39; Cordasco and Gargano, 2011
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    high_labels = _most_frequent_labels(node, labeling, G)</span>
<span class="gi">+    if len(high_labels) == 1:</span>
<span class="gi">+        labeling[node] = high_labels.pop()</span>
<span class="gi">+    elif len(high_labels) &gt; 1:</span>
<span class="gi">+        # Prec-Max</span>
<span class="gi">+        if labeling[node] not in high_labels:</span>
<span class="gi">+            labeling[node] = max(high_labels)</span>
<span class="gh">diff --git a/networkx/algorithms/community/louvain.py b/networkx/algorithms/community/louvain.py</span>
<span class="gh">index c95008941..959c93a51 100644</span>
<span class="gd">--- a/networkx/algorithms/community/louvain.py</span>
<span class="gi">+++ b/networkx/algorithms/community/louvain.py</span>
<span class="gu">@@ -1,18 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Function for detecting communities based on Louvain Community Detection
<span class="w"> </span>Algorithm&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>from collections import defaultdict, deque
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.community import modularity
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;louvain_communities&#39;, &#39;louvain_partitions&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;louvain_communities&quot;, &quot;louvain_partitions&quot;]</span>


<span class="gd">-@py_random_state(&#39;seed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def louvain_communities(G, weight=&#39;weight&#39;, resolution=1, threshold=1e-07,</span>
<span class="gd">-    max_level=None, seed=None):</span>
<span class="gd">-    &quot;&quot;&quot;Find the best partition of a graph using the Louvain Community Detection</span>
<span class="gi">+@py_random_state(&quot;seed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def louvain_communities(</span>
<span class="gi">+    G, weight=&quot;weight&quot;, resolution=1, threshold=0.0000001, max_level=None, seed=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Find the best partition of a graph using the Louvain Community Detection</span>
<span class="w"> </span>    Algorithm.

<span class="w"> </span>    Louvain Community Detection Algorithm is a simple method to extract the community
<span class="gu">@@ -27,21 +31,21 @@ def louvain_communities(G, weight=&#39;weight&#39;, resolution=1, threshold=1e-07,</span>
<span class="w"> </span>    easily be calculated by the following formula (combining [1]_ [2]_ and some algebra):

<span class="w"> </span>    .. math::
<span class="gd">-        \\Delta Q = \\frac{k_{i,in}}{2m} - \\gamma\\frac{ \\Sigma_{tot} \\cdot k_i}{2m^2}</span>
<span class="gi">+        \Delta Q = \frac{k_{i,in}}{2m} - \gamma\frac{ \Sigma_{tot} \cdot k_i}{2m^2}</span>

<span class="w"> </span>    where $m$ is the size of the graph, $k_{i,in}$ is the sum of the weights of the links
<span class="w"> </span>    from $i$ to nodes in $C$, $k_i$ is the sum of the weights of the links incident to node $i$,
<span class="gd">-    $\\Sigma_{tot}$ is the sum of the weights of the links incident to nodes in $C$ and $\\gamma$</span>
<span class="gi">+    $\Sigma_{tot}$ is the sum of the weights of the links incident to nodes in $C$ and $\gamma$</span>
<span class="w"> </span>    is the resolution parameter.

<span class="w"> </span>    For the directed case the modularity gain can be computed using this formula according to [3]_

<span class="w"> </span>    .. math::
<span class="gd">-        \\Delta Q = \\frac{k_{i,in}}{m}</span>
<span class="gd">-        - \\gamma\\frac{k_i^{out} \\cdot\\Sigma_{tot}^{in} + k_i^{in} \\cdot \\Sigma_{tot}^{out}}{m^2}</span>
<span class="gi">+        \Delta Q = \frac{k_{i,in}}{m}</span>
<span class="gi">+        - \gamma\frac{k_i^{out} \cdot\Sigma_{tot}^{in} + k_i^{in} \cdot \Sigma_{tot}^{out}}{m^2}</span>

<span class="w"> </span>    where $k_i^{out}$, $k_i^{in}$ are the outer and inner weighted degrees of node $i$ and
<span class="gd">-    $\\Sigma_{tot}^{in}$, $\\Sigma_{tot}^{out}$ are the sum of in-going and out-going links incident</span>
<span class="gi">+    $\Sigma_{tot}^{in}$, $\Sigma_{tot}^{out}$ are the sum of in-going and out-going links incident</span>
<span class="w"> </span>    to nodes in $C$.

<span class="w"> </span>    The first phase continues until no individual move can improve the modularity.
<span class="gu">@@ -115,13 +119,21 @@ def louvain_communities(G, weight=&#39;weight&#39;, resolution=1, threshold=1e-07,</span>
<span class="w"> </span>    --------
<span class="w"> </span>    louvain_partitions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    partitions = louvain_partitions(G, weight, resolution, threshold, seed)</span>
<span class="gi">+    if max_level is not None:</span>
<span class="gi">+        if max_level &lt;= 0:</span>
<span class="gi">+            raise ValueError(&quot;max_level argument must be a positive integer or None&quot;)</span>
<span class="gi">+        partitions = itertools.islice(partitions, max_level)</span>
<span class="gi">+    final_partition = deque(partitions, maxlen=1)</span>
<span class="gi">+    return final_partition.pop()</span>

<span class="gd">-@py_random_state(&#39;seed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def louvain_partitions(G, weight=&#39;weight&#39;, resolution=1, threshold=1e-07,</span>
<span class="gd">-    seed=None):</span>
<span class="gi">+</span>
<span class="gi">+@py_random_state(&quot;seed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def louvain_partitions(</span>
<span class="gi">+    G, weight=&quot;weight&quot;, resolution=1, threshold=0.0000001, seed=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Yields partitions for each level of the Louvain Community Detection Algorithm

<span class="w"> </span>    Louvain Community Detection Algorithm is a simple method to extract the community
<span class="gu">@@ -176,7 +188,38 @@ def louvain_partitions(G, weight=&#39;weight&#39;, resolution=1, threshold=1e-07,</span>
<span class="w"> </span>    --------
<span class="w"> </span>    louvain_communities
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    partition = [{u} for u in G.nodes()]</span>
<span class="gi">+    if nx.is_empty(G):</span>
<span class="gi">+        yield partition</span>
<span class="gi">+        return</span>
<span class="gi">+    mod = modularity(G, partition, resolution=resolution, weight=weight)</span>
<span class="gi">+    is_directed = G.is_directed()</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        graph = _convert_multigraph(G, weight, is_directed)</span>
<span class="gi">+    else:</span>
<span class="gi">+        graph = G.__class__()</span>
<span class="gi">+        graph.add_nodes_from(G)</span>
<span class="gi">+        graph.add_weighted_edges_from(G.edges(data=weight, default=1))</span>
<span class="gi">+</span>
<span class="gi">+    m = graph.size(weight=&quot;weight&quot;)</span>
<span class="gi">+    partition, inner_partition, improvement = _one_level(</span>
<span class="gi">+        graph, m, partition, resolution, is_directed, seed</span>
<span class="gi">+    )</span>
<span class="gi">+    improvement = True</span>
<span class="gi">+    while improvement:</span>
<span class="gi">+        # gh-5901 protect the sets in the yielded list from further manipulation here</span>
<span class="gi">+        yield [s.copy() for s in partition]</span>
<span class="gi">+        new_mod = modularity(</span>
<span class="gi">+            graph, inner_partition, resolution=resolution, weight=&quot;weight&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        if new_mod - mod &lt;= threshold:</span>
<span class="gi">+            return</span>
<span class="gi">+        mod = new_mod</span>
<span class="gi">+        graph = _gen_graph(graph, inner_partition)</span>
<span class="gi">+        partition, inner_partition, improvement = _one_level(</span>
<span class="gi">+            graph, m, partition, resolution, is_directed, seed</span>
<span class="gi">+        )</span>


<span class="w"> </span>def _one_level(G, m, partition, resolution=1, is_directed=False, seed=None):
<span class="gu">@@ -199,7 +242,92 @@ def _one_level(G, m, partition, resolution=1, is_directed=False, seed=None):</span>
<span class="w"> </span>        See :ref:`Randomness&lt;randomness&gt;`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    node2com = {u: i for i, u in enumerate(G.nodes())}</span>
<span class="gi">+    inner_partition = [{u} for u in G.nodes()]</span>
<span class="gi">+    if is_directed:</span>
<span class="gi">+        in_degrees = dict(G.in_degree(weight=&quot;weight&quot;))</span>
<span class="gi">+        out_degrees = dict(G.out_degree(weight=&quot;weight&quot;))</span>
<span class="gi">+        Stot_in = list(in_degrees.values())</span>
<span class="gi">+        Stot_out = list(out_degrees.values())</span>
<span class="gi">+        # Calculate weights for both in and out neighbors without considering self-loops</span>
<span class="gi">+        nbrs = {}</span>
<span class="gi">+        for u in G:</span>
<span class="gi">+            nbrs[u] = defaultdict(float)</span>
<span class="gi">+            for _, n, wt in G.out_edges(u, data=&quot;weight&quot;):</span>
<span class="gi">+                if u != n:</span>
<span class="gi">+                    nbrs[u][n] += wt</span>
<span class="gi">+            for n, _, wt in G.in_edges(u, data=&quot;weight&quot;):</span>
<span class="gi">+                if u != n:</span>
<span class="gi">+                    nbrs[u][n] += wt</span>
<span class="gi">+    else:</span>
<span class="gi">+        degrees = dict(G.degree(weight=&quot;weight&quot;))</span>
<span class="gi">+        Stot = list(degrees.values())</span>
<span class="gi">+        nbrs = {u: {v: data[&quot;weight&quot;] for v, data in G[u].items() if v != u} for u in G}</span>
<span class="gi">+    rand_nodes = list(G.nodes)</span>
<span class="gi">+    seed.shuffle(rand_nodes)</span>
<span class="gi">+    nb_moves = 1</span>
<span class="gi">+    improvement = False</span>
<span class="gi">+    while nb_moves &gt; 0:</span>
<span class="gi">+        nb_moves = 0</span>
<span class="gi">+        for u in rand_nodes:</span>
<span class="gi">+            best_mod = 0</span>
<span class="gi">+            best_com = node2com[u]</span>
<span class="gi">+            weights2com = _neighbor_weights(nbrs[u], node2com)</span>
<span class="gi">+            if is_directed:</span>
<span class="gi">+                in_degree = in_degrees[u]</span>
<span class="gi">+                out_degree = out_degrees[u]</span>
<span class="gi">+                Stot_in[best_com] -= in_degree</span>
<span class="gi">+                Stot_out[best_com] -= out_degree</span>
<span class="gi">+                remove_cost = (</span>
<span class="gi">+                    -weights2com[best_com] / m</span>
<span class="gi">+                    + resolution</span>
<span class="gi">+                    * (out_degree * Stot_in[best_com] + in_degree * Stot_out[best_com])</span>
<span class="gi">+                    / m**2</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                degree = degrees[u]</span>
<span class="gi">+                Stot[best_com] -= degree</span>
<span class="gi">+                remove_cost = -weights2com[best_com] / m + resolution * (</span>
<span class="gi">+                    Stot[best_com] * degree</span>
<span class="gi">+                ) / (2 * m**2)</span>
<span class="gi">+            for nbr_com, wt in weights2com.items():</span>
<span class="gi">+                if is_directed:</span>
<span class="gi">+                    gain = (</span>
<span class="gi">+                        remove_cost</span>
<span class="gi">+                        + wt / m</span>
<span class="gi">+                        - resolution</span>
<span class="gi">+                        * (</span>
<span class="gi">+                            out_degree * Stot_in[nbr_com]</span>
<span class="gi">+                            + in_degree * Stot_out[nbr_com]</span>
<span class="gi">+                        )</span>
<span class="gi">+                        / m**2</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    gain = (</span>
<span class="gi">+                        remove_cost</span>
<span class="gi">+                        + wt / m</span>
<span class="gi">+                        - resolution * (Stot[nbr_com] * degree) / (2 * m**2)</span>
<span class="gi">+                    )</span>
<span class="gi">+                if gain &gt; best_mod:</span>
<span class="gi">+                    best_mod = gain</span>
<span class="gi">+                    best_com = nbr_com</span>
<span class="gi">+            if is_directed:</span>
<span class="gi">+                Stot_in[best_com] += in_degree</span>
<span class="gi">+                Stot_out[best_com] += out_degree</span>
<span class="gi">+            else:</span>
<span class="gi">+                Stot[best_com] += degree</span>
<span class="gi">+            if best_com != node2com[u]:</span>
<span class="gi">+                com = G.nodes[u].get(&quot;nodes&quot;, {u})</span>
<span class="gi">+                partition[node2com[u]].difference_update(com)</span>
<span class="gi">+                inner_partition[node2com[u]].remove(u)</span>
<span class="gi">+                partition[best_com].update(com)</span>
<span class="gi">+                inner_partition[best_com].add(u)</span>
<span class="gi">+                improvement = True</span>
<span class="gi">+                nb_moves += 1</span>
<span class="gi">+                node2com[u] = best_com</span>
<span class="gi">+    partition = list(filter(len, partition))</span>
<span class="gi">+    inner_partition = list(filter(len, inner_partition))</span>
<span class="gi">+    return partition, inner_partition, improvement</span>


<span class="w"> </span>def _neighbor_weights(nbrs, node2com):
<span class="gu">@@ -213,14 +341,42 @@ def _neighbor_weights(nbrs, node2com):</span>
<span class="w"> </span>           Dictionary with all graph&#39;s nodes as keys and their community index as value.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    weights = defaultdict(float)</span>
<span class="gi">+    for nbr, wt in nbrs.items():</span>
<span class="gi">+        weights[node2com[nbr]] += wt</span>
<span class="gi">+    return weights</span>


<span class="w"> </span>def _gen_graph(G, partition):
<span class="w"> </span>    &quot;&quot;&quot;Generate a new graph based on the partitions of a given graph&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    H = G.__class__()</span>
<span class="gi">+    node2com = {}</span>
<span class="gi">+    for i, part in enumerate(partition):</span>
<span class="gi">+        nodes = set()</span>
<span class="gi">+        for node in part:</span>
<span class="gi">+            node2com[node] = i</span>
<span class="gi">+            nodes.update(G.nodes[node].get(&quot;nodes&quot;, {node}))</span>
<span class="gi">+        H.add_node(i, nodes=nodes)</span>
<span class="gi">+</span>
<span class="gi">+    for node1, node2, wt in G.edges(data=True):</span>
<span class="gi">+        wt = wt[&quot;weight&quot;]</span>
<span class="gi">+        com1 = node2com[node1]</span>
<span class="gi">+        com2 = node2com[node2]</span>
<span class="gi">+        temp = H.get_edge_data(com1, com2, {&quot;weight&quot;: 0})[&quot;weight&quot;]</span>
<span class="gi">+        H.add_edge(com1, com2, weight=wt + temp)</span>
<span class="gi">+    return H</span>


<span class="w"> </span>def _convert_multigraph(G, weight, is_directed):
<span class="w"> </span>    &quot;&quot;&quot;Convert a Multigraph to normal Graph&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_directed:</span>
<span class="gi">+        H = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = nx.Graph()</span>
<span class="gi">+    H.add_nodes_from(G)</span>
<span class="gi">+    for u, v, wt in G.edges(data=weight, default=1):</span>
<span class="gi">+        if H.has_edge(u, v):</span>
<span class="gi">+            H[u][v][&quot;weight&quot;] += wt</span>
<span class="gi">+        else:</span>
<span class="gi">+            H.add_edge(u, v, weight=wt)</span>
<span class="gi">+    return H</span>
<span class="gh">diff --git a/networkx/algorithms/community/lukes.py b/networkx/algorithms/community/lukes.py</span>
<span class="gh">index 4c1395b60..08dd7cd52 100644</span>
<span class="gd">--- a/networkx/algorithms/community/lukes.py</span>
<span class="gi">+++ b/networkx/algorithms/community/lukes.py</span>
<span class="gu">@@ -1,19 +1,31 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Lukes Algorithm for exact optimal weighted tree partitioning.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from functools import lru_cache
<span class="w"> </span>from random import choice
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;lukes_partitioning&#39;]</span>
<span class="gd">-D_EDGE_W = &#39;weight&#39;</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;lukes_partitioning&quot;]</span>
<span class="gi">+</span>
<span class="gi">+D_EDGE_W = &quot;weight&quot;</span>
<span class="w"> </span>D_EDGE_VALUE = 1.0
<span class="gd">-D_NODE_W = &#39;weight&#39;</span>
<span class="gi">+D_NODE_W = &quot;weight&quot;</span>
<span class="w"> </span>D_NODE_VALUE = 1
<span class="gd">-PKEY = &#39;partitions&#39;</span>
<span class="gi">+PKEY = &quot;partitions&quot;</span>
<span class="w"> </span>CLUSTER_EVAL_CACHE_SIZE = 2048


<span class="gd">-@nx._dispatchable(node_attrs=&#39;node_weight&#39;, edge_attrs=&#39;edge_weight&#39;)</span>
<span class="gi">+def _split_n_from(n, min_size_of_first_part):</span>
<span class="gi">+    # splits j in two parts of which the first is at least</span>
<span class="gi">+    # the second argument</span>
<span class="gi">+    assert n &gt;= min_size_of_first_part</span>
<span class="gi">+    for p1 in range(min_size_of_first_part, n + 1):</span>
<span class="gi">+        yield p1, n - p1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;node_weight&quot;, edge_attrs=&quot;edge_weight&quot;)</span>
<span class="w"> </span>def lukes_partitioning(G, max_size, node_weight=None, edge_weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Optimal partitioning of a weighted tree using the Lukes algorithm.

<span class="gu">@@ -59,4 +71,157 @@ def lukes_partitioning(G, max_size, node_weight=None, edge_weight=None):</span>
<span class="w"> </span>       IBM Journal of Research and Development, 18(3), 217–224.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # First sanity check and tree preparation</span>
<span class="gi">+    if not nx.is_tree(G):</span>
<span class="gi">+        raise nx.NotATree(&quot;lukes_partitioning works only on trees&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if nx.is_directed(G):</span>
<span class="gi">+            root = [n for n, d in G.in_degree() if d == 0]</span>
<span class="gi">+            assert len(root) == 1</span>
<span class="gi">+            root = root[0]</span>
<span class="gi">+            t_G = deepcopy(G)</span>
<span class="gi">+        else:</span>
<span class="gi">+            root = choice(list(G.nodes))</span>
<span class="gi">+            # this has the desirable side effect of not inheriting attributes</span>
<span class="gi">+            t_G = nx.dfs_tree(G, root)</span>
<span class="gi">+</span>
<span class="gi">+    # Since we do not want to screw up the original graph,</span>
<span class="gi">+    # if we have a blank attribute, we make a deepcopy</span>
<span class="gi">+    if edge_weight is None or node_weight is None:</span>
<span class="gi">+        safe_G = deepcopy(G)</span>
<span class="gi">+        if edge_weight is None:</span>
<span class="gi">+            nx.set_edge_attributes(safe_G, D_EDGE_VALUE, D_EDGE_W)</span>
<span class="gi">+            edge_weight = D_EDGE_W</span>
<span class="gi">+        if node_weight is None:</span>
<span class="gi">+            nx.set_node_attributes(safe_G, D_NODE_VALUE, D_NODE_W)</span>
<span class="gi">+            node_weight = D_NODE_W</span>
<span class="gi">+    else:</span>
<span class="gi">+        safe_G = G</span>
<span class="gi">+</span>
<span class="gi">+    # Second sanity check</span>
<span class="gi">+    # The values of node_weight MUST BE int.</span>
<span class="gi">+    # I cannot see any room for duck typing without incurring serious</span>
<span class="gi">+    # danger of subtle bugs.</span>
<span class="gi">+    all_n_attr = nx.get_node_attributes(safe_G, node_weight).values()</span>
<span class="gi">+    for x in all_n_attr:</span>
<span class="gi">+        if not isinstance(x, int):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;lukes_partitioning needs integer &quot;</span>
<span class="gi">+                f&quot;values for node_weight ({node_weight})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # SUBROUTINES -----------------------</span>
<span class="gi">+    # these functions are defined here for two reasons:</span>
<span class="gi">+    # - brevity: we can leverage global &quot;safe_G&quot;</span>
<span class="gi">+    # - caching: signatures are hashable</span>
<span class="gi">+</span>
<span class="gi">+    @not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+    # this is intended to be called only on t_G</span>
<span class="gi">+    def _leaves(gr):</span>
<span class="gi">+        for x in gr.nodes:</span>
<span class="gi">+            if not nx.descendants(gr, x):</span>
<span class="gi">+                yield x</span>
<span class="gi">+</span>
<span class="gi">+    @not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+    def _a_parent_of_leaves_only(gr):</span>
<span class="gi">+        tleaves = set(_leaves(gr))</span>
<span class="gi">+        for n in set(gr.nodes) - tleaves:</span>
<span class="gi">+            if all(x in tleaves for x in nx.descendants(gr, n)):</span>
<span class="gi">+                return n</span>
<span class="gi">+</span>
<span class="gi">+    @lru_cache(CLUSTER_EVAL_CACHE_SIZE)</span>
<span class="gi">+    def _value_of_cluster(cluster):</span>
<span class="gi">+        valid_edges = [e for e in safe_G.edges if e[0] in cluster and e[1] in cluster]</span>
<span class="gi">+        return sum(safe_G.edges[e][edge_weight] for e in valid_edges)</span>
<span class="gi">+</span>
<span class="gi">+    def _value_of_partition(partition):</span>
<span class="gi">+        return sum(_value_of_cluster(frozenset(c)) for c in partition)</span>
<span class="gi">+</span>
<span class="gi">+    @lru_cache(CLUSTER_EVAL_CACHE_SIZE)</span>
<span class="gi">+    def _weight_of_cluster(cluster):</span>
<span class="gi">+        return sum(safe_G.nodes[n][node_weight] for n in cluster)</span>
<span class="gi">+</span>
<span class="gi">+    def _pivot(partition, node):</span>
<span class="gi">+        ccx = [c for c in partition if node in c]</span>
<span class="gi">+        assert len(ccx) == 1</span>
<span class="gi">+        return ccx[0]</span>
<span class="gi">+</span>
<span class="gi">+    def _concatenate_or_merge(partition_1, partition_2, x, i, ref_weight):</span>
<span class="gi">+        ccx = _pivot(partition_1, x)</span>
<span class="gi">+        cci = _pivot(partition_2, i)</span>
<span class="gi">+        merged_xi = ccx.union(cci)</span>
<span class="gi">+</span>
<span class="gi">+        # We first check if we can do the merge.</span>
<span class="gi">+        # If so, we do the actual calculations, otherwise we concatenate</span>
<span class="gi">+        if _weight_of_cluster(frozenset(merged_xi)) &lt;= ref_weight:</span>
<span class="gi">+            cp1 = list(filter(lambda x: x != ccx, partition_1))</span>
<span class="gi">+            cp2 = list(filter(lambda x: x != cci, partition_2))</span>
<span class="gi">+</span>
<span class="gi">+            option_2 = [merged_xi] + cp1 + cp2</span>
<span class="gi">+            return option_2, _value_of_partition(option_2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            option_1 = partition_1 + partition_2</span>
<span class="gi">+            return option_1, _value_of_partition(option_1)</span>
<span class="gi">+</span>
<span class="gi">+    # INITIALIZATION -----------------------</span>
<span class="gi">+    leaves = set(_leaves(t_G))</span>
<span class="gi">+    for lv in leaves:</span>
<span class="gi">+        t_G.nodes[lv][PKEY] = {}</span>
<span class="gi">+        slot = safe_G.nodes[lv][node_weight]</span>
<span class="gi">+        t_G.nodes[lv][PKEY][slot] = [{lv}]</span>
<span class="gi">+        t_G.nodes[lv][PKEY][0] = [{lv}]</span>
<span class="gi">+</span>
<span class="gi">+    for inner in [x for x in t_G.nodes if x not in leaves]:</span>
<span class="gi">+        t_G.nodes[inner][PKEY] = {}</span>
<span class="gi">+        slot = safe_G.nodes[inner][node_weight]</span>
<span class="gi">+        t_G.nodes[inner][PKEY][slot] = [{inner}]</span>
<span class="gi">+    nx._clear_cache(t_G)</span>
<span class="gi">+</span>
<span class="gi">+    # CORE ALGORITHM -----------------------</span>
<span class="gi">+    while True:</span>
<span class="gi">+        x_node = _a_parent_of_leaves_only(t_G)</span>
<span class="gi">+        weight_of_x = safe_G.nodes[x_node][node_weight]</span>
<span class="gi">+        best_value = 0</span>
<span class="gi">+        best_partition = None</span>
<span class="gi">+        bp_buffer = {}</span>
<span class="gi">+        x_descendants = nx.descendants(t_G, x_node)</span>
<span class="gi">+        for i_node in x_descendants:</span>
<span class="gi">+            for j in range(weight_of_x, max_size + 1):</span>
<span class="gi">+                for a, b in _split_n_from(j, weight_of_x):</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        a not in t_G.nodes[x_node][PKEY]</span>
<span class="gi">+                        or b not in t_G.nodes[i_node][PKEY]</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        # it&#39;s not possible to form this particular weight sum</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    part1 = t_G.nodes[x_node][PKEY][a]</span>
<span class="gi">+                    part2 = t_G.nodes[i_node][PKEY][b]</span>
<span class="gi">+                    part, value = _concatenate_or_merge(part1, part2, x_node, i_node, j)</span>
<span class="gi">+</span>
<span class="gi">+                    if j not in bp_buffer or bp_buffer[j][1] &lt; value:</span>
<span class="gi">+                        # we annotate in the buffer the best partition for j</span>
<span class="gi">+                        bp_buffer[j] = part, value</span>
<span class="gi">+</span>
<span class="gi">+                    # we also keep track of the overall best partition</span>
<span class="gi">+                    if best_value &lt;= value:</span>
<span class="gi">+                        best_value = value</span>
<span class="gi">+                        best_partition = part</span>
<span class="gi">+</span>
<span class="gi">+            # as illustrated in Lukes, once we finished a child, we can</span>
<span class="gi">+            # discharge the partitions we found into the graph</span>
<span class="gi">+            # (the key phrase is make all x == x&#39;)</span>
<span class="gi">+            # so that they are used by the subsequent children</span>
<span class="gi">+            for w, (best_part_for_vl, vl) in bp_buffer.items():</span>
<span class="gi">+                t_G.nodes[x_node][PKEY][w] = best_part_for_vl</span>
<span class="gi">+            bp_buffer.clear()</span>
<span class="gi">+</span>
<span class="gi">+        # the absolute best partition for this node</span>
<span class="gi">+        # across all weights has to be stored at 0</span>
<span class="gi">+        t_G.nodes[x_node][PKEY][0] = best_partition</span>
<span class="gi">+        t_G.remove_nodes_from(x_descendants)</span>
<span class="gi">+</span>
<span class="gi">+        if x_node == root:</span>
<span class="gi">+            # the 0-labeled partition of root</span>
<span class="gi">+            # is the optimal one for the whole tree</span>
<span class="gi">+            return t_G.nodes[root][PKEY][0]</span>
<span class="gh">diff --git a/networkx/algorithms/community/modularity_max.py b/networkx/algorithms/community/modularity_max.py</span>
<span class="gh">index 24913548c..f465e01c6 100644</span>
<span class="gd">--- a/networkx/algorithms/community/modularity_max.py</span>
<span class="gi">+++ b/networkx/algorithms/community/modularity_max.py</span>
<span class="gu">@@ -1,15 +1,20 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for detecting communities based on modularity.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.community.quality import modularity
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="w"> </span>from networkx.utils.mapped_queue import MappedQueue
<span class="gd">-__all__ = [&#39;greedy_modularity_communities&#39;,</span>
<span class="gd">-    &#39;naive_greedy_modularity_communities&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;greedy_modularity_communities&quot;,</span>
<span class="gi">+    &quot;naive_greedy_modularity_communities&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def _greedy_modularity_communities_generator(G, weight=None, resolution=1):
<span class="gd">-    &quot;&quot;&quot;Yield community partitions of G and the modularity change at each step.</span>
<span class="gi">+    r&quot;&quot;&quot;Yield community partitions of G and the modularity change at each step.</span>

<span class="w"> </span>    This function performs Clauset-Newman-Moore greedy modularity maximization [2]_
<span class="w"> </span>    At each step of the process it yields the change in modularity that will occur in
<span class="gu">@@ -20,7 +25,7 @@ def _greedy_modularity_communities_generator(G, weight=None, resolution=1):</span>
<span class="w"> </span>    modularity until one community contains all nodes (the partition has one set).

<span class="w"> </span>    This function maximizes the generalized modularity, where `resolution`
<span class="gd">-    is the resolution parameter, often expressed as $\\gamma$.</span>
<span class="gi">+    is the resolution parameter, often expressed as $\gamma$.</span>
<span class="w"> </span>    See :func:`~networkx.algorithms.community.quality.modularity`.

<span class="w"> </span>    Parameters
<span class="gu">@@ -65,13 +70,168 @@ def _greedy_modularity_communities_generator(G, weight=None, resolution=1):</span>
<span class="w"> </span>    .. [4] Newman, M. E. J.&quot;Analysis of weighted networks&quot;
<span class="w"> </span>       Physical Review E 70(5 Pt 2):056131, 2004.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def greedy_modularity_communities(G, weight=None, resolution=1, cutoff=1,</span>
<span class="gd">-    best_n=None):</span>
<span class="gd">-    &quot;&quot;&quot;Find communities in G using greedy modularity maximization.</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    N = G.number_of_nodes()</span>
<span class="gi">+</span>
<span class="gi">+    # Count edges (or the sum of edge-weights for weighted graphs)</span>
<span class="gi">+    m = G.size(weight)</span>
<span class="gi">+    q0 = 1 / m</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate degrees (notation from the papers)</span>
<span class="gi">+    # a : the fraction of (weighted) out-degree for each node</span>
<span class="gi">+    # b : the fraction of (weighted) in-degree for each node</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        a = {node: deg_out * q0 for node, deg_out in G.out_degree(weight=weight)}</span>
<span class="gi">+        b = {node: deg_in * q0 for node, deg_in in G.in_degree(weight=weight)}</span>
<span class="gi">+    else:</span>
<span class="gi">+        a = b = {node: deg * q0 * 0.5 for node, deg in G.degree(weight=weight)}</span>
<span class="gi">+</span>
<span class="gi">+    # this preliminary step collects the edge weights for each node pair</span>
<span class="gi">+    # It handles multigraph and digraph and works fine for graph.</span>
<span class="gi">+    dq_dict = defaultdict(lambda: defaultdict(float))</span>
<span class="gi">+    for u, v, wt in G.edges(data=weight, default=1):</span>
<span class="gi">+        if u == v:</span>
<span class="gi">+            continue</span>
<span class="gi">+        dq_dict[u][v] += wt</span>
<span class="gi">+        dq_dict[v][u] += wt</span>
<span class="gi">+</span>
<span class="gi">+    # now scale and subtract the expected edge-weights term</span>
<span class="gi">+    for u, nbrdict in dq_dict.items():</span>
<span class="gi">+        for v, wt in nbrdict.items():</span>
<span class="gi">+            dq_dict[u][v] = q0 * wt - resolution * (a[u] * b[v] + b[u] * a[v])</span>
<span class="gi">+</span>
<span class="gi">+    # Use -dq to get a max_heap instead of a min_heap</span>
<span class="gi">+    # dq_heap holds a heap for each node&#39;s neighbors</span>
<span class="gi">+    dq_heap = {u: MappedQueue({(u, v): -dq for v, dq in dq_dict[u].items()}) for u in G}</span>
<span class="gi">+    # H -&gt; all_dq_heap holds a heap with the best items for each node</span>
<span class="gi">+    H = MappedQueue([dq_heap[n].heap[0] for n in G if len(dq_heap[n]) &gt; 0])</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize single-node communities</span>
<span class="gi">+    communities = {n: frozenset([n]) for n in G}</span>
<span class="gi">+    yield communities.values()</span>
<span class="gi">+</span>
<span class="gi">+    # Merge the two communities that lead to the largest modularity</span>
<span class="gi">+    while len(H) &gt; 1:</span>
<span class="gi">+        # Find best merge</span>
<span class="gi">+        # Remove from heap of row maxes</span>
<span class="gi">+        # Ties will be broken by choosing the pair with lowest min community id</span>
<span class="gi">+        try:</span>
<span class="gi">+            negdq, u, v = H.pop()</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            break</span>
<span class="gi">+        dq = -negdq</span>
<span class="gi">+        yield dq</span>
<span class="gi">+        # Remove best merge from row u heap</span>
<span class="gi">+        dq_heap[u].pop()</span>
<span class="gi">+        # Push new row max onto H</span>
<span class="gi">+        if len(dq_heap[u]) &gt; 0:</span>
<span class="gi">+            H.push(dq_heap[u].heap[0])</span>
<span class="gi">+        # If this element was also at the root of row v, we need to remove the</span>
<span class="gi">+        # duplicate entry from H</span>
<span class="gi">+        if dq_heap[v].heap[0] == (v, u):</span>
<span class="gi">+            H.remove((v, u))</span>
<span class="gi">+            # Remove best merge from row v heap</span>
<span class="gi">+            dq_heap[v].remove((v, u))</span>
<span class="gi">+            # Push new row max onto H</span>
<span class="gi">+            if len(dq_heap[v]) &gt; 0:</span>
<span class="gi">+                H.push(dq_heap[v].heap[0])</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Duplicate wasn&#39;t in H, just remove from row v heap</span>
<span class="gi">+            dq_heap[v].remove((v, u))</span>
<span class="gi">+</span>
<span class="gi">+        # Perform merge</span>
<span class="gi">+        communities[v] = frozenset(communities[u] | communities[v])</span>
<span class="gi">+        del communities[u]</span>
<span class="gi">+</span>
<span class="gi">+        # Get neighbor communities connected to the merged communities</span>
<span class="gi">+        u_nbrs = set(dq_dict[u])</span>
<span class="gi">+        v_nbrs = set(dq_dict[v])</span>
<span class="gi">+        all_nbrs = (u_nbrs | v_nbrs) - {u, v}</span>
<span class="gi">+        both_nbrs = u_nbrs &amp; v_nbrs</span>
<span class="gi">+        # Update dq for merge of u into v</span>
<span class="gi">+        for w in all_nbrs:</span>
<span class="gi">+            # Calculate new dq value</span>
<span class="gi">+            if w in both_nbrs:</span>
<span class="gi">+                dq_vw = dq_dict[v][w] + dq_dict[u][w]</span>
<span class="gi">+            elif w in v_nbrs:</span>
<span class="gi">+                dq_vw = dq_dict[v][w] - resolution * (a[u] * b[w] + a[w] * b[u])</span>
<span class="gi">+            else:  # w in u_nbrs</span>
<span class="gi">+                dq_vw = dq_dict[u][w] - resolution * (a[v] * b[w] + a[w] * b[v])</span>
<span class="gi">+            # Update rows v and w</span>
<span class="gi">+            for row, col in [(v, w), (w, v)]:</span>
<span class="gi">+                dq_heap_row = dq_heap[row]</span>
<span class="gi">+                # Update dict for v,w only (u is removed below)</span>
<span class="gi">+                dq_dict[row][col] = dq_vw</span>
<span class="gi">+                # Save old max of per-row heap</span>
<span class="gi">+                if len(dq_heap_row) &gt; 0:</span>
<span class="gi">+                    d_oldmax = dq_heap_row.heap[0]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    d_oldmax = None</span>
<span class="gi">+                # Add/update heaps</span>
<span class="gi">+                d = (row, col)</span>
<span class="gi">+                d_negdq = -dq_vw</span>
<span class="gi">+                # Save old value for finding heap index</span>
<span class="gi">+                if w in v_nbrs:</span>
<span class="gi">+                    # Update existing element in per-row heap</span>
<span class="gi">+                    dq_heap_row.update(d, d, priority=d_negdq)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # We&#39;re creating a new nonzero element, add to heap</span>
<span class="gi">+                    dq_heap_row.push(d, priority=d_negdq)</span>
<span class="gi">+                # Update heap of row maxes if necessary</span>
<span class="gi">+                if d_oldmax is None:</span>
<span class="gi">+                    # No entries previously in this row, push new max</span>
<span class="gi">+                    H.push(d, priority=d_negdq)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # We&#39;ve updated an entry in this row, has the max changed?</span>
<span class="gi">+                    row_max = dq_heap_row.heap[0]</span>
<span class="gi">+                    if d_oldmax != row_max or d_oldmax.priority != row_max.priority:</span>
<span class="gi">+                        H.update(d_oldmax, row_max)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove row/col u from dq_dict matrix</span>
<span class="gi">+        for w in dq_dict[u]:</span>
<span class="gi">+            # Remove from dict</span>
<span class="gi">+            dq_old = dq_dict[w][u]</span>
<span class="gi">+            del dq_dict[w][u]</span>
<span class="gi">+            # Remove from heaps if we haven&#39;t already</span>
<span class="gi">+            if w != v:</span>
<span class="gi">+                # Remove both row and column</span>
<span class="gi">+                for row, col in [(w, u), (u, w)]:</span>
<span class="gi">+                    dq_heap_row = dq_heap[row]</span>
<span class="gi">+                    # Check if replaced dq is row max</span>
<span class="gi">+                    d_old = (row, col)</span>
<span class="gi">+                    if dq_heap_row.heap[0] == d_old:</span>
<span class="gi">+                        # Update per-row heap and heap of row maxes</span>
<span class="gi">+                        dq_heap_row.remove(d_old)</span>
<span class="gi">+                        H.remove(d_old)</span>
<span class="gi">+                        # Update row max</span>
<span class="gi">+                        if len(dq_heap_row) &gt; 0:</span>
<span class="gi">+                            H.push(dq_heap_row.heap[0])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # Only update per-row heap</span>
<span class="gi">+                        dq_heap_row.remove(d_old)</span>
<span class="gi">+</span>
<span class="gi">+        del dq_dict[u]</span>
<span class="gi">+        # Mark row u as deleted, but keep placeholder</span>
<span class="gi">+        dq_heap[u] = MappedQueue()</span>
<span class="gi">+        # Merge u into v and update a</span>
<span class="gi">+        a[v] += a[u]</span>
<span class="gi">+        a[u] = 0</span>
<span class="gi">+        if directed:</span>
<span class="gi">+            b[v] += b[u]</span>
<span class="gi">+            b[u] = 0</span>
<span class="gi">+</span>
<span class="gi">+        yield communities.values()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def greedy_modularity_communities(</span>
<span class="gi">+    G,</span>
<span class="gi">+    weight=None,</span>
<span class="gi">+    resolution=1,</span>
<span class="gi">+    cutoff=1,</span>
<span class="gi">+    best_n=None,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Find communities in G using greedy modularity maximization.</span>

<span class="w"> </span>    This function uses Clauset-Newman-Moore greedy modularity maximization [2]_
<span class="w"> </span>    to find the community partition with the largest modularity.
<span class="gu">@@ -87,7 +247,7 @@ def greedy_modularity_communities(G, weight=None, resolution=1, cutoff=1,</span>
<span class="w"> </span>    for more. To obtain exactly n communities, set both `cutoff` and `best_n` to n.

<span class="w"> </span>    This function maximizes the generalized modularity, where `resolution`
<span class="gd">-    is the resolution parameter, often expressed as $\\gamma$.</span>
<span class="gi">+    is the resolution parameter, often expressed as $\gamma$.</span>
<span class="w"> </span>    See :func:`~networkx.algorithms.community.quality.modularity`.

<span class="w"> </span>    Parameters
<span class="gu">@@ -149,14 +309,56 @@ def greedy_modularity_communities(G, weight=None, resolution=1, cutoff=1,</span>
<span class="w"> </span>    .. [4] Newman, M. E. J.&quot;Analysis of weighted networks&quot;
<span class="w"> </span>       Physical Review E 70(5 Pt 2):056131, 2004.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    if not G.size():</span>
<span class="gi">+        return [{n} for n in G]</span>
<span class="gi">+</span>
<span class="gi">+    if (cutoff &lt; 1) or (cutoff &gt; G.number_of_nodes()):</span>
<span class="gi">+        raise ValueError(f&quot;cutoff must be between 1 and {len(G)}. Got {cutoff}.&quot;)</span>
<span class="gi">+    if best_n is not None:</span>
<span class="gi">+        if (best_n &lt; 1) or (best_n &gt; G.number_of_nodes()):</span>
<span class="gi">+            raise ValueError(f&quot;best_n must be between 1 and {len(G)}. Got {best_n}.&quot;)</span>
<span class="gi">+        if best_n &lt; cutoff:</span>
<span class="gi">+            raise ValueError(f&quot;Must have best_n &gt;= cutoff. Got {best_n} &lt; {cutoff}&quot;)</span>
<span class="gi">+        if best_n == 1:</span>
<span class="gi">+            return [set(G)]</span>
<span class="gi">+    else:</span>
<span class="gi">+        best_n = G.number_of_nodes()</span>
<span class="gi">+</span>
<span class="gi">+    # retrieve generator object to construct output</span>
<span class="gi">+    community_gen = _greedy_modularity_communities_generator(</span>
<span class="gi">+        G, weight=weight, resolution=resolution</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # construct the first best community</span>
<span class="gi">+    communities = next(community_gen)</span>
<span class="gi">+</span>
<span class="gi">+    # continue merging communities until one of the breaking criteria is satisfied</span>
<span class="gi">+    while len(communities) &gt; cutoff:</span>
<span class="gi">+        try:</span>
<span class="gi">+            dq = next(community_gen)</span>
<span class="gi">+        # StopIteration occurs when communities are the connected components</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            communities = sorted(communities, key=len, reverse=True)</span>
<span class="gi">+            # if best_n requires more merging, merge big sets for highest modularity</span>
<span class="gi">+            while len(communities) &gt; best_n:</span>
<span class="gi">+                comm1, comm2, *rest = communities</span>
<span class="gi">+                communities = [comm1 ^ comm2]</span>
<span class="gi">+                communities.extend(rest)</span>
<span class="gi">+            return communities</span>
<span class="gi">+</span>
<span class="gi">+        # keep going unless max_mod is reached or best_n says to merge more</span>
<span class="gi">+        if dq &lt; 0 and len(communities) &lt;= best_n:</span>
<span class="gi">+            break</span>
<span class="gi">+        communities = next(community_gen)</span>
<span class="gi">+</span>
<span class="gi">+    return sorted(communities, key=len, reverse=True)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def naive_greedy_modularity_communities(G, resolution=1, weight=None):
<span class="gd">-    &quot;&quot;&quot;Find communities in G using greedy modularity maximization.</span>
<span class="gi">+    r&quot;&quot;&quot;Find communities in G using greedy modularity maximization.</span>

<span class="w"> </span>    This implementation is O(n^4), much slower than alternatives, but it is
<span class="w"> </span>    provided as an easy-to-understand reference implementation.
<span class="gu">@@ -166,7 +368,7 @@ def naive_greedy_modularity_communities(G, resolution=1, weight=None):</span>
<span class="w"> </span>    such pair exists.

<span class="w"> </span>    This function maximizes the generalized modularity, where `resolution`
<span class="gd">-    is the resolution parameter, often expressed as $\\gamma$.</span>
<span class="gi">+    is the resolution parameter, often expressed as $\gamma$.</span>
<span class="w"> </span>    See :func:`~networkx.algorithms.community.quality.modularity`.

<span class="w"> </span>    Parameters
<span class="gu">@@ -201,4 +403,49 @@ def naive_greedy_modularity_communities(G, resolution=1, weight=None):</span>
<span class="w"> </span>    greedy_modularity_communities
<span class="w"> </span>    modularity
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # First create one community for each node</span>
<span class="gi">+    communities = [frozenset([u]) for u in G.nodes()]</span>
<span class="gi">+    # Track merges</span>
<span class="gi">+    merges = []</span>
<span class="gi">+    # Greedily merge communities until no improvement is possible</span>
<span class="gi">+    old_modularity = None</span>
<span class="gi">+    new_modularity = modularity(G, communities, resolution=resolution, weight=weight)</span>
<span class="gi">+    while old_modularity is None or new_modularity &gt; old_modularity:</span>
<span class="gi">+        # Save modularity for comparison</span>
<span class="gi">+        old_modularity = new_modularity</span>
<span class="gi">+        # Find best pair to merge</span>
<span class="gi">+        trial_communities = list(communities)</span>
<span class="gi">+        to_merge = None</span>
<span class="gi">+        for i, u in enumerate(communities):</span>
<span class="gi">+            for j, v in enumerate(communities):</span>
<span class="gi">+                # Skip i==j and empty communities</span>
<span class="gi">+                if j &lt;= i or len(u) == 0 or len(v) == 0:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # Merge communities u and v</span>
<span class="gi">+                trial_communities[j] = u | v</span>
<span class="gi">+                trial_communities[i] = frozenset([])</span>
<span class="gi">+                trial_modularity = modularity(</span>
<span class="gi">+                    G, trial_communities, resolution=resolution, weight=weight</span>
<span class="gi">+                )</span>
<span class="gi">+                if trial_modularity &gt;= new_modularity:</span>
<span class="gi">+                    # Check if strictly better or tie</span>
<span class="gi">+                    if trial_modularity &gt; new_modularity:</span>
<span class="gi">+                        # Found new best, save modularity and group indexes</span>
<span class="gi">+                        new_modularity = trial_modularity</span>
<span class="gi">+                        to_merge = (i, j, new_modularity - old_modularity)</span>
<span class="gi">+                    elif to_merge and min(i, j) &lt; min(to_merge[0], to_merge[1]):</span>
<span class="gi">+                        # Break ties by choosing pair with lowest min id</span>
<span class="gi">+                        new_modularity = trial_modularity</span>
<span class="gi">+                        to_merge = (i, j, new_modularity - old_modularity)</span>
<span class="gi">+                # Un-merge</span>
<span class="gi">+                trial_communities[i] = u</span>
<span class="gi">+                trial_communities[j] = v</span>
<span class="gi">+        if to_merge is not None:</span>
<span class="gi">+            # If the best merge improves modularity, use it</span>
<span class="gi">+            merges.append(to_merge)</span>
<span class="gi">+            i, j, dq = to_merge</span>
<span class="gi">+            u, v = communities[i], communities[j]</span>
<span class="gi">+            communities[j] = u | v</span>
<span class="gi">+            communities[i] = frozenset([])</span>
<span class="gi">+    # Remove empty communities and sort</span>
<span class="gi">+    return sorted((c for c in communities if len(c) &gt; 0), key=len, reverse=True)</span>
<span class="gh">diff --git a/networkx/algorithms/community/quality.py b/networkx/algorithms/community/quality.py</span>
<span class="gh">index d58afd00f..f09a6d454 100644</span>
<span class="gd">--- a/networkx/algorithms/community/quality.py</span>
<span class="gi">+++ b/networkx/algorithms/community/quality.py</span>
<span class="gu">@@ -2,19 +2,22 @@</span>
<span class="w"> </span>communities).

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from itertools import combinations
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx import NetworkXError
<span class="w"> </span>from networkx.algorithms.community.community_utils import is_partition
<span class="w"> </span>from networkx.utils.decorators import argmap
<span class="gd">-__all__ = [&#39;modularity&#39;, &#39;partition_quality&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;modularity&quot;, &quot;partition_quality&quot;]</span>


<span class="w"> </span>class NotAPartition(NetworkXError):
<span class="w"> </span>    &quot;&quot;&quot;Raised if a given collection is not a partition.&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, G, collection):
<span class="gd">-        msg = f&#39;{collection} is not a valid partition of the graph {G}&#39;</span>
<span class="gi">+        msg = f&quot;{collection} is not a valid partition of the graph {G}&quot;</span>
<span class="w"> </span>        super().__init__(msg)


<span class="gu">@@ -47,7 +50,9 @@ def _require_partition(G, partition):</span>
<span class="w"> </span>        networkx.exception.NetworkXError: `partition` is not a valid partition of the nodes of G

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_partition(G, partition):</span>
<span class="gi">+        return G, partition</span>
<span class="gi">+    raise nx.NetworkXError(&quot;`partition` is not a valid partition of the nodes of G&quot;)</span>


<span class="w"> </span>require_partition = argmap(_require_partition, (0, 1))
<span class="gu">@@ -68,7 +73,7 @@ def intra_community_edges(G, partition):</span>
<span class="w"> </span>    in the same block of the partition.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(G.subgraph(block).size() for block in partition)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -91,7 +96,16 @@ def inter_community_edges(G, partition):</span>
<span class="w"> </span>    that may require the same amount of memory as that of `G`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Alternate implementation that does not require constructing a new</span>
<span class="gi">+    # graph object (but does require constructing an affiliation</span>
<span class="gi">+    # dictionary):</span>
<span class="gi">+    #</span>
<span class="gi">+    #     aff = dict(chain.from_iterable(((v, block) for v in block)</span>
<span class="gi">+    #                                    for block in partition))</span>
<span class="gi">+    #     return sum(1 for u, v in G.edges() if aff[u] != aff[v])</span>
<span class="gi">+    #</span>
<span class="gi">+    MG = nx.MultiDiGraph if G.is_directed() else nx.MultiGraph</span>
<span class="gi">+    return nx.quotient_graph(G, partition, create_using=MG).size()</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -116,34 +130,42 @@ def inter_community_non_edges(G, partition):</span>
<span class="w"> </span>    store `G`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Alternate implementation that does not require constructing two</span>
<span class="gi">+    # new graph objects (but does require constructing an affiliation</span>
<span class="gi">+    # dictionary):</span>
<span class="gi">+    #</span>
<span class="gi">+    #     aff = dict(chain.from_iterable(((v, block) for v in block)</span>
<span class="gi">+    #                                    for block in partition))</span>
<span class="gi">+    #     return sum(1 for u, v in nx.non_edges(G) if aff[u] != aff[v])</span>
<span class="gi">+    #</span>
<span class="gi">+    return inter_community_edges(nx.complement(G), partition)</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def modularity(G, communities, weight=&#39;weight&#39;, resolution=1):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the modularity of the given partition of the graph.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def modularity(G, communities, weight=&quot;weight&quot;, resolution=1):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the modularity of the given partition of the graph.</span>

<span class="w"> </span>    Modularity is defined in [1]_ as

<span class="w"> </span>    .. math::
<span class="gd">-        Q = \\frac{1}{2m} \\sum_{ij} \\left( A_{ij} - \\gamma\\frac{k_ik_j}{2m}\\right)</span>
<span class="gd">-            \\delta(c_i,c_j)</span>
<span class="gi">+        Q = \frac{1}{2m} \sum_{ij} \left( A_{ij} - \gamma\frac{k_ik_j}{2m}\right)</span>
<span class="gi">+            \delta(c_i,c_j)</span>

<span class="w"> </span>    where $m$ is the number of edges (or sum of all edge weights as in [5]_),
<span class="w"> </span>    $A$ is the adjacency matrix of `G`, $k_i$ is the (weighted) degree of $i$,
<span class="gd">-    $\\gamma$ is the resolution parameter, and $\\delta(c_i, c_j)$ is 1 if $i$ and</span>
<span class="gi">+    $\gamma$ is the resolution parameter, and $\delta(c_i, c_j)$ is 1 if $i$ and</span>
<span class="w"> </span>    $j$ are in the same community else 0.

<span class="w"> </span>    According to [2]_ (and verified by some algebra) this can be reduced to

<span class="w"> </span>    .. math::
<span class="gd">-       Q = \\sum_{c=1}^{n}</span>
<span class="gd">-       \\left[ \\frac{L_c}{m} - \\gamma\\left( \\frac{k_c}{2m} \\right) ^2 \\right]</span>
<span class="gi">+       Q = \sum_{c=1}^{n}</span>
<span class="gi">+       \left[ \frac{L_c}{m} - \gamma\left( \frac{k_c}{2m} \right) ^2 \right]</span>

<span class="w"> </span>    where the sum iterates over all communities $c$, $m$ is the number of edges,
<span class="w"> </span>    $L_c$ is the number of intra-community links for community $c$,
<span class="w"> </span>    $k_c$ is the sum of degrees of the nodes in community $c$,
<span class="gd">-    and $\\gamma$ is the resolution parameter.</span>
<span class="gi">+    and $\gamma$ is the resolution parameter.</span>

<span class="w"> </span>    The resolution parameter sets an arbitrary tradeoff between intra-group
<span class="w"> </span>    edges and inter-group edges. More complex grouping patterns can be
<span class="gu">@@ -204,7 +226,33 @@ def modularity(G, communities, weight=&#39;weight&#39;, resolution=1):</span>
<span class="w"> </span>       networks&quot; J. Stat. Mech 10008, 1-12 (2008).
<span class="w"> </span>       https://doi.org/10.1088/1742-5468/2008/10/P10008
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(communities, list):</span>
<span class="gi">+        communities = list(communities)</span>
<span class="gi">+    if not is_partition(G, communities):</span>
<span class="gi">+        raise NotAPartition(G, communities)</span>
<span class="gi">+</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        out_degree = dict(G.out_degree(weight=weight))</span>
<span class="gi">+        in_degree = dict(G.in_degree(weight=weight))</span>
<span class="gi">+        m = sum(out_degree.values())</span>
<span class="gi">+        norm = 1 / m**2</span>
<span class="gi">+    else:</span>
<span class="gi">+        out_degree = in_degree = dict(G.degree(weight=weight))</span>
<span class="gi">+        deg_sum = sum(out_degree.values())</span>
<span class="gi">+        m = deg_sum / 2</span>
<span class="gi">+        norm = 1 / deg_sum**2</span>
<span class="gi">+</span>
<span class="gi">+    def community_contribution(community):</span>
<span class="gi">+        comm = set(community)</span>
<span class="gi">+        L_c = sum(wt for u, v, wt in G.edges(comm, data=weight, default=1) if v in comm)</span>
<span class="gi">+</span>
<span class="gi">+        out_degree_sum = sum(out_degree[u] for u in comm)</span>
<span class="gi">+        in_degree_sum = sum(in_degree[u] for u in comm) if directed else out_degree_sum</span>
<span class="gi">+</span>
<span class="gi">+        return L_c / m - resolution * out_degree_sum * in_degree_sum * norm</span>
<span class="gi">+</span>
<span class="gi">+    return sum(map(community_contribution, communities))</span>


<span class="w"> </span>@require_partition
<span class="gu">@@ -253,4 +301,46 @@ def partition_quality(G, partition):</span>
<span class="w"> </span>           *Physical Reports*, Volume 486, Issue 3--5 pp. 75--174
<span class="w"> </span>           &lt;https://arxiv.org/abs/0906.0612&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    node_community = {}</span>
<span class="gi">+    for i, community in enumerate(partition):</span>
<span class="gi">+        for node in community:</span>
<span class="gi">+            node_community[node] = i</span>
<span class="gi">+</span>
<span class="gi">+    # `performance` is not defined for multigraphs</span>
<span class="gi">+    if not G.is_multigraph():</span>
<span class="gi">+        # Iterate over the communities, quadratic, to calculate `possible_inter_community_edges`</span>
<span class="gi">+        possible_inter_community_edges = sum(</span>
<span class="gi">+            len(p1) * len(p2) for p1, p2 in combinations(partition, 2)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            possible_inter_community_edges *= 2</span>
<span class="gi">+    else:</span>
<span class="gi">+        possible_inter_community_edges = 0</span>
<span class="gi">+</span>
<span class="gi">+    # Compute the number of edges in the complete graph -- `n` nodes,</span>
<span class="gi">+    # directed or undirected, depending on `G`</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    total_pairs = n * (n - 1)</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        total_pairs //= 2</span>
<span class="gi">+</span>
<span class="gi">+    intra_community_edges = 0</span>
<span class="gi">+    inter_community_non_edges = possible_inter_community_edges</span>
<span class="gi">+</span>
<span class="gi">+    # Iterate over the links to count `intra_community_edges` and `inter_community_non_edges`</span>
<span class="gi">+    for e in G.edges():</span>
<span class="gi">+        if node_community[e[0]] == node_community[e[1]]:</span>
<span class="gi">+            intra_community_edges += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            inter_community_non_edges -= 1</span>
<span class="gi">+</span>
<span class="gi">+    coverage = intra_community_edges / len(G.edges)</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        performance = -1.0</span>
<span class="gi">+    else:</span>
<span class="gi">+        performance = (intra_community_edges + inter_community_non_edges) / total_pairs</span>
<span class="gi">+</span>
<span class="gi">+    return coverage, performance</span>
<span class="gh">diff --git a/networkx/algorithms/components/attracting.py b/networkx/algorithms/components/attracting.py</span>
<span class="gh">index a77cebd2f..305c69635 100644</span>
<span class="gd">--- a/networkx/algorithms/components/attracting.py</span>
<span class="gi">+++ b/networkx/algorithms/components/attracting.py</span>
<span class="gu">@@ -1,11 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Attracting components.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;number_attracting_components&#39;, &#39;attracting_components&#39;,</span>
<span class="gd">-    &#39;is_attracting_component&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;number_attracting_components&quot;,</span>
<span class="gi">+    &quot;attracting_components&quot;,</span>
<span class="gi">+    &quot;is_attracting_component&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def attracting_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Generates the attracting components in `G`.
<span class="gu">@@ -42,10 +46,14 @@ def attracting_components(G):</span>
<span class="w"> </span>    is_attracting_component

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scc = list(nx.strongly_connected_components(G))</span>
<span class="gi">+    cG = nx.condensation(G, scc)</span>
<span class="gi">+    for n in cG:</span>
<span class="gi">+        if cG.out_degree(n) == 0:</span>
<span class="gi">+            yield scc[n]</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def number_attracting_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the number of attracting components in `G`.
<span class="gu">@@ -71,10 +79,10 @@ def number_attracting_components(G):</span>
<span class="w"> </span>    is_attracting_component

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(1 for ac in attracting_components(G))</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_attracting_component(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if `G` consists of a single attracting component.
<span class="gu">@@ -100,4 +108,7 @@ def is_attracting_component(G):</span>
<span class="w"> </span>    number_attracting_components

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ac = list(attracting_components(G))</span>
<span class="gi">+    if len(ac) == 1:</span>
<span class="gi">+        return len(ac[0]) == len(G)</span>
<span class="gi">+    return False</span>
<span class="gh">diff --git a/networkx/algorithms/components/biconnected.py b/networkx/algorithms/components/biconnected.py</span>
<span class="gh">index 011a81e1e..0d2f06975 100644</span>
<span class="gd">--- a/networkx/algorithms/components/biconnected.py</span>
<span class="gi">+++ b/networkx/algorithms/components/biconnected.py</span>
<span class="gu">@@ -1,12 +1,18 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Biconnected components and articulation points.&quot;&quot;&quot;
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;biconnected_components&#39;, &#39;biconnected_component_edges&#39;,</span>
<span class="gd">-    &#39;is_biconnected&#39;, &#39;articulation_points&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;biconnected_components&quot;,</span>
<span class="gi">+    &quot;biconnected_component_edges&quot;,</span>
<span class="gi">+    &quot;is_biconnected&quot;,</span>
<span class="gi">+    &quot;articulation_points&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_biconnected(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if the graph is biconnected, False otherwise.
<span class="gu">@@ -71,10 +77,23 @@ def is_biconnected(G):</span>
<span class="w"> </span>       Communications of the ACM 16: 372–378. doi:10.1145/362248.362272

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    bccs = biconnected_components(G)</span>
<span class="gi">+    try:</span>
<span class="gi">+        bcc = next(bccs)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        # No bicomponents (empty graph?)</span>
<span class="gi">+        return False</span>
<span class="gi">+    try:</span>
<span class="gi">+        next(bccs)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        # Only one bicomponent</span>
<span class="gi">+        return len(bcc) == len(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Multiple bicomponents</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def biconnected_component_edges(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns a generator of lists of edges, one list for each biconnected
<span class="gu">@@ -144,10 +163,10 @@ def biconnected_component_edges(G):</span>
<span class="w"> </span>           Communications of the ACM 16: 372–378. doi:10.1145/362248.362272

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yield from _biconnected_dfs(G, components=True)</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def biconnected_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns a generator of sets of nodes, one set for each biconnected
<span class="gu">@@ -236,10 +255,11 @@ def biconnected_components(G):</span>
<span class="w"> </span>           Communications of the ACM 16: 372–378. doi:10.1145/362248.362272

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for comp in _biconnected_dfs(G, components=True):</span>
<span class="gi">+        yield set(chain.from_iterable(comp))</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def articulation_points(G):
<span class="w"> </span>    &quot;&quot;&quot;Yield the articulation points, or cut vertices, of a graph.
<span class="gu">@@ -307,4 +327,67 @@ def articulation_points(G):</span>
<span class="w"> </span>           Communications of the ACM 16: 372–378. doi:10.1145/362248.362272

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for articulation in _biconnected_dfs(G, components=False):</span>
<span class="gi">+        if articulation not in seen:</span>
<span class="gi">+            seen.add(articulation)</span>
<span class="gi">+            yield articulation</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+def _biconnected_dfs(G, components=True):</span>
<span class="gi">+    # depth-first search algorithm to generate articulation points</span>
<span class="gi">+    # and biconnected components</span>
<span class="gi">+    visited = set()</span>
<span class="gi">+    for start in G:</span>
<span class="gi">+        if start in visited:</span>
<span class="gi">+            continue</span>
<span class="gi">+        discovery = {start: 0}  # time of first discovery of node during search</span>
<span class="gi">+        low = {start: 0}</span>
<span class="gi">+        root_children = 0</span>
<span class="gi">+        visited.add(start)</span>
<span class="gi">+        edge_stack = []</span>
<span class="gi">+        stack = [(start, start, iter(G[start]))]</span>
<span class="gi">+        edge_index = {}</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            grandparent, parent, children = stack[-1]</span>
<span class="gi">+            try:</span>
<span class="gi">+                child = next(children)</span>
<span class="gi">+                if grandparent == child:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if child in visited:</span>
<span class="gi">+                    if discovery[child] &lt;= discovery[parent]:  # back edge</span>
<span class="gi">+                        low[parent] = min(low[parent], discovery[child])</span>
<span class="gi">+                        if components:</span>
<span class="gi">+                            edge_index[parent, child] = len(edge_stack)</span>
<span class="gi">+                            edge_stack.append((parent, child))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    low[child] = discovery[child] = len(discovery)</span>
<span class="gi">+                    visited.add(child)</span>
<span class="gi">+                    stack.append((parent, child, iter(G[child])))</span>
<span class="gi">+                    if components:</span>
<span class="gi">+                        edge_index[parent, child] = len(edge_stack)</span>
<span class="gi">+                        edge_stack.append((parent, child))</span>
<span class="gi">+</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+                if len(stack) &gt; 1:</span>
<span class="gi">+                    if low[parent] &gt;= discovery[grandparent]:</span>
<span class="gi">+                        if components:</span>
<span class="gi">+                            ind = edge_index[grandparent, parent]</span>
<span class="gi">+                            yield edge_stack[ind:]</span>
<span class="gi">+                            del edge_stack[ind:]</span>
<span class="gi">+</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            yield grandparent</span>
<span class="gi">+                    low[grandparent] = min(low[parent], low[grandparent])</span>
<span class="gi">+                elif stack:  # length 1 so grandparent is root</span>
<span class="gi">+                    root_children += 1</span>
<span class="gi">+                    if components:</span>
<span class="gi">+                        ind = edge_index[grandparent, parent]</span>
<span class="gi">+                        yield edge_stack[ind:]</span>
<span class="gi">+                        del edge_stack[ind:]</span>
<span class="gi">+        if not components:</span>
<span class="gi">+            # root node is articulation point if it has more than 1 child</span>
<span class="gi">+            if root_children &gt; 1:</span>
<span class="gi">+                yield start</span>
<span class="gh">diff --git a/networkx/algorithms/components/connected.py b/networkx/algorithms/components/connected.py</span>
<span class="gh">index 725e6fd5a..ad3e0155a 100644</span>
<span class="gd">--- a/networkx/algorithms/components/connected.py</span>
<span class="gi">+++ b/networkx/algorithms/components/connected.py</span>
<span class="gu">@@ -1,12 +1,18 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Connected components.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gi">+</span>
<span class="w"> </span>from ...utils import arbitrary_element
<span class="gd">-__all__ = [&#39;number_connected_components&#39;, &#39;connected_components&#39;,</span>
<span class="gd">-    &#39;is_connected&#39;, &#39;node_connected_component&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;number_connected_components&quot;,</span>
<span class="gi">+    &quot;connected_components&quot;,</span>
<span class="gi">+    &quot;is_connected&quot;,</span>
<span class="gi">+    &quot;node_connected_component&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def connected_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Generate connected components.
<span class="gu">@@ -54,10 +60,15 @@ def connected_components(G):</span>
<span class="w"> </span>    For undirected graphs only.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for v in G:</span>
<span class="gi">+        if v not in seen:</span>
<span class="gi">+            c = _plain_bfs(G, v)</span>
<span class="gi">+            seen.update(c)</span>
<span class="gi">+            yield c</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def number_connected_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the number of connected components.
<span class="gu">@@ -94,10 +105,10 @@ def number_connected_components(G):</span>
<span class="w"> </span>    For undirected graphs only.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(1 for cc in connected_components(G))</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_connected(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if the graph is connected, False otherwise.
<span class="gu">@@ -136,10 +147,14 @@ def is_connected(G):</span>
<span class="w"> </span>    For undirected graphs only.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(</span>
<span class="gi">+            &quot;Connectivity is undefined for the null graph.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    return sum(1 for node in _plain_bfs(G, arbitrary_element(G))) == len(G)</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def node_connected_component(G, n):
<span class="w"> </span>    &quot;&quot;&quot;Returns the set of nodes in the component of graph containing node n.
<span class="gu">@@ -177,9 +192,23 @@ def node_connected_component(G, n):</span>
<span class="w"> </span>    For undirected graphs only.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _plain_bfs(G, n)</span>


<span class="w"> </span>def _plain_bfs(G, source):
<span class="w"> </span>    &quot;&quot;&quot;A fast BFS node generator&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    adj = G._adj</span>
<span class="gi">+    n = len(adj)</span>
<span class="gi">+    seen = {source}</span>
<span class="gi">+    nextlevel = [source]</span>
<span class="gi">+    while nextlevel:</span>
<span class="gi">+        thislevel = nextlevel</span>
<span class="gi">+        nextlevel = []</span>
<span class="gi">+        for v in thislevel:</span>
<span class="gi">+            for w in adj[v]:</span>
<span class="gi">+                if w not in seen:</span>
<span class="gi">+                    seen.add(w)</span>
<span class="gi">+                    nextlevel.append(w)</span>
<span class="gi">+            if len(seen) == n:</span>
<span class="gi">+                return seen</span>
<span class="gi">+    return seen</span>
<span class="gh">diff --git a/networkx/algorithms/components/semiconnected.py b/networkx/algorithms/components/semiconnected.py</span>
<span class="gh">index d6838ed1b..13cfa988a 100644</span>
<span class="gd">--- a/networkx/algorithms/components/semiconnected.py</span>
<span class="gi">+++ b/networkx/algorithms/components/semiconnected.py</span>
<span class="gu">@@ -1,13 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Semiconnectedness.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, pairwise
<span class="gd">-__all__ = [&#39;is_semiconnected&#39;]</span>

<span class="gi">+__all__ = [&quot;is_semiconnected&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_semiconnected(G):
<span class="gd">-    &quot;&quot;&quot;Returns True if the graph is semiconnected, False otherwise.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns True if the graph is semiconnected, False otherwise.</span>

<span class="w"> </span>    A graph is semiconnected if and only if for any pair of nodes, either one
<span class="w"> </span>    is reachable from the other, or they are mutually reachable.
<span class="gu">@@ -18,7 +19,7 @@ def is_semiconnected(G):</span>
<span class="w"> </span>    semiconnected by condensing the graph: i.e. constructing a new graph `H`
<span class="w"> </span>    with nodes being the strongly connected components of `G`, and edges
<span class="w"> </span>    (scc_1, scc_2) if there is a edge $(v_1, v_2)$ in `G` for some
<span class="gd">-    $v_1 \\in scc_1$ and $v_2 \\in scc_2$. That results in a DAG, so we compute</span>
<span class="gi">+    $v_1 \in scc_1$ and $v_2 \in scc_2$. That results in a DAG, so we compute</span>
<span class="w"> </span>    the topological sort of `H` and check if for every $n$ there is an edge
<span class="w"> </span>    $(scc_n, scc_{n+1})$.

<span class="gu">@@ -56,4 +57,14 @@ def is_semiconnected(G):</span>
<span class="w"> </span>    is_connected
<span class="w"> </span>    is_biconnected
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(</span>
<span class="gi">+            &quot;Connectivity is undefined for the null graph.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_weakly_connected(G):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    H = nx.condensation(G)</span>
<span class="gi">+</span>
<span class="gi">+    return all(H.has_edge(u, v) for u, v in pairwise(nx.topological_sort(H)))</span>
<span class="gh">diff --git a/networkx/algorithms/components/strongly_connected.py b/networkx/algorithms/components/strongly_connected.py</span>
<span class="gh">index e1dc2128a..febd1b9b5 100644</span>
<span class="gd">--- a/networkx/algorithms/components/strongly_connected.py</span>
<span class="gi">+++ b/networkx/algorithms/components/strongly_connected.py</span>
<span class="gu">@@ -1,13 +1,18 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Strongly connected components.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;number_strongly_connected_components&#39;,</span>
<span class="gd">-    &#39;strongly_connected_components&#39;, &#39;is_strongly_connected&#39;,</span>
<span class="gd">-    &#39;strongly_connected_components_recursive&#39;,</span>
<span class="gd">-    &#39;kosaraju_strongly_connected_components&#39;, &#39;condensation&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;number_strongly_connected_components&quot;,</span>
<span class="gi">+    &quot;strongly_connected_components&quot;,</span>
<span class="gi">+    &quot;is_strongly_connected&quot;,</span>
<span class="gi">+    &quot;strongly_connected_components_recursive&quot;,</span>
<span class="gi">+    &quot;kosaraju_strongly_connected_components&quot;,</span>
<span class="gi">+    &quot;condensation&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def strongly_connected_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Generate nodes in strongly connected components of graph.
<span class="gu">@@ -63,10 +68,47 @@ def strongly_connected_components(G):</span>
<span class="w"> </span>       Information Processing Letters 49(1): 9-14, (1994)..

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    preorder = {}</span>
<span class="gi">+    lowlink = {}</span>
<span class="gi">+    scc_found = set()</span>
<span class="gi">+    scc_queue = []</span>
<span class="gi">+    i = 0  # Preorder counter</span>
<span class="gi">+    neighbors = {v: iter(G[v]) for v in G}</span>
<span class="gi">+    for source in G:</span>
<span class="gi">+        if source not in scc_found:</span>
<span class="gi">+            queue = [source]</span>
<span class="gi">+            while queue:</span>
<span class="gi">+                v = queue[-1]</span>
<span class="gi">+                if v not in preorder:</span>
<span class="gi">+                    i = i + 1</span>
<span class="gi">+                    preorder[v] = i</span>
<span class="gi">+                done = True</span>
<span class="gi">+                for w in neighbors[v]:</span>
<span class="gi">+                    if w not in preorder:</span>
<span class="gi">+                        queue.append(w)</span>
<span class="gi">+                        done = False</span>
<span class="gi">+                        break</span>
<span class="gi">+                if done:</span>
<span class="gi">+                    lowlink[v] = preorder[v]</span>
<span class="gi">+                    for w in G[v]:</span>
<span class="gi">+                        if w not in scc_found:</span>
<span class="gi">+                            if preorder[w] &gt; preorder[v]:</span>
<span class="gi">+                                lowlink[v] = min([lowlink[v], lowlink[w]])</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                lowlink[v] = min([lowlink[v], preorder[w]])</span>
<span class="gi">+                    queue.pop()</span>
<span class="gi">+                    if lowlink[v] == preorder[v]:</span>
<span class="gi">+                        scc = {v}</span>
<span class="gi">+                        while scc_queue and preorder[scc_queue[-1]] &gt; preorder[v]:</span>
<span class="gi">+                            k = scc_queue.pop()</span>
<span class="gi">+                            scc.add(k)</span>
<span class="gi">+                        scc_found.update(scc)</span>
<span class="gi">+                        yield scc</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        scc_queue.append(v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def kosaraju_strongly_connected_components(G, source=None):
<span class="w"> </span>    &quot;&quot;&quot;Generate nodes in strongly connected components of graph.
<span class="gu">@@ -115,10 +157,20 @@ def kosaraju_strongly_connected_components(G, source=None):</span>
<span class="w"> </span>    Uses Kosaraju&#39;s algorithm.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    post = list(nx.dfs_postorder_nodes(G.reverse(copy=False), source=source))</span>
<span class="gi">+</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    while post:</span>
<span class="gi">+        r = post.pop()</span>
<span class="gi">+        if r in seen:</span>
<span class="gi">+            continue</span>
<span class="gi">+        c = nx.dfs_preorder_nodes(G, r)</span>
<span class="gi">+        new = {v for v in c if v not in seen}</span>
<span class="gi">+        seen.update(new)</span>
<span class="gi">+        yield new</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def strongly_connected_components_recursive(G):
<span class="w"> </span>    &quot;&quot;&quot;Generate nodes in strongly connected components of graph.
<span class="gu">@@ -186,10 +238,21 @@ def strongly_connected_components_recursive(G):</span>
<span class="w"> </span>       Information Processing Letters 49(1): 9-14, (1994)..

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>

<span class="gi">+    warnings.warn(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;\n\nstrongly_connected_components_recursive is deprecated and will be\n&quot;</span>
<span class="gi">+            &quot;removed in the future. Use strongly_connected_components instead.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+        category=DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    yield from strongly_connected_components(G)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def number_strongly_connected_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns number of strongly connected components in graph.
<span class="gu">@@ -227,10 +290,10 @@ def number_strongly_connected_components(G):</span>
<span class="w"> </span>    -----
<span class="w"> </span>    For directed graphs only.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(1 for scc in strongly_connected_components(G))</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_strongly_connected(G):
<span class="w"> </span>    &quot;&quot;&quot;Test directed graph for strong connectivity.
<span class="gu">@@ -274,10 +337,15 @@ def is_strongly_connected(G):</span>
<span class="w"> </span>    -----
<span class="w"> </span>    For directed graphs only.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(</span>
<span class="gi">+            &quot;&quot;&quot;Connectivity is undefined for the null graph.&quot;&quot;&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return len(next(strongly_connected_components(G))) == len(G)</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def condensation(G, scc=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the condensation of G.
<span class="gu">@@ -340,4 +408,23 @@ def condensation(G, scc=None):</span>
<span class="w"> </span>    the resulting graph is a directed acyclic graph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if scc is None:</span>
<span class="gi">+        scc = nx.strongly_connected_components(G)</span>
<span class="gi">+    mapping = {}</span>
<span class="gi">+    members = {}</span>
<span class="gi">+    C = nx.DiGraph()</span>
<span class="gi">+    # Add mapping dict as graph attribute</span>
<span class="gi">+    C.graph[&quot;mapping&quot;] = mapping</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return C</span>
<span class="gi">+    for i, component in enumerate(scc):</span>
<span class="gi">+        members[i] = component</span>
<span class="gi">+        mapping.update((n, i) for n in component)</span>
<span class="gi">+    number_of_components = i + 1</span>
<span class="gi">+    C.add_nodes_from(range(number_of_components))</span>
<span class="gi">+    C.add_edges_from(</span>
<span class="gi">+        (mapping[u], mapping[v]) for u, v in G.edges() if mapping[u] != mapping[v]</span>
<span class="gi">+    )</span>
<span class="gi">+    # Add a list of members (ie original nodes) to each node (ie scc) in C.</span>
<span class="gi">+    nx.set_node_attributes(C, members, &quot;members&quot;)</span>
<span class="gi">+    return C</span>
<span class="gh">diff --git a/networkx/algorithms/components/weakly_connected.py b/networkx/algorithms/components/weakly_connected.py</span>
<span class="gh">index 3926c7239..499c2ba74 100644</span>
<span class="gd">--- a/networkx/algorithms/components/weakly_connected.py</span>
<span class="gi">+++ b/networkx/algorithms/components/weakly_connected.py</span>
<span class="gu">@@ -1,11 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Weakly connected components.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;number_weakly_connected_components&#39;,</span>
<span class="gd">-    &#39;weakly_connected_components&#39;, &#39;is_weakly_connected&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;number_weakly_connected_components&quot;,</span>
<span class="gi">+    &quot;weakly_connected_components&quot;,</span>
<span class="gi">+    &quot;is_weakly_connected&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def weakly_connected_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Generate weakly connected components of G.
<span class="gu">@@ -50,10 +54,15 @@ def weakly_connected_components(G):</span>
<span class="w"> </span>    For directed graphs only.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for v in G:</span>
<span class="gi">+        if v not in seen:</span>
<span class="gi">+            c = set(_plain_bfs(G, v))</span>
<span class="gi">+            seen.update(c)</span>
<span class="gi">+            yield c</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def number_weakly_connected_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the number of weakly connected components in G.
<span class="gu">@@ -90,10 +99,10 @@ def number_weakly_connected_components(G):</span>
<span class="w"> </span>    For directed graphs only.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(1 for wcc in weakly_connected_components(G))</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_weakly_connected(G):
<span class="w"> </span>    &quot;&quot;&quot;Test directed graph for weak connectivity.
<span class="gu">@@ -143,7 +152,12 @@ def is_weakly_connected(G):</span>
<span class="w"> </span>    For directed graphs only.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(</span>
<span class="gi">+            &quot;&quot;&quot;Connectivity is undefined for the null graph.&quot;&quot;&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return len(next(weakly_connected_components(G))) == len(G)</span>


<span class="w"> </span>def _plain_bfs(G, source):
<span class="gu">@@ -154,4 +168,26 @@ def _plain_bfs(G, source):</span>
<span class="w"> </span>    For directed graphs only.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    Gsucc = G._succ</span>
<span class="gi">+    Gpred = G._pred</span>
<span class="gi">+    seen = {source}</span>
<span class="gi">+    nextlevel = [source]</span>
<span class="gi">+</span>
<span class="gi">+    yield source</span>
<span class="gi">+    while nextlevel:</span>
<span class="gi">+        thislevel = nextlevel</span>
<span class="gi">+        nextlevel = []</span>
<span class="gi">+        for v in thislevel:</span>
<span class="gi">+            for w in Gsucc[v]:</span>
<span class="gi">+                if w not in seen:</span>
<span class="gi">+                    seen.add(w)</span>
<span class="gi">+                    nextlevel.append(w)</span>
<span class="gi">+                    yield w</span>
<span class="gi">+            for w in Gpred[v]:</span>
<span class="gi">+                if w not in seen:</span>
<span class="gi">+                    seen.add(w)</span>
<span class="gi">+                    nextlevel.append(w)</span>
<span class="gi">+                    yield w</span>
<span class="gi">+            if len(seen) == n:</span>
<span class="gi">+                return</span>
<span class="gh">diff --git a/networkx/algorithms/connectivity/connectivity.py b/networkx/algorithms/connectivity/connectivity.py</span>
<span class="gh">index 3f2ded06b..8ccca88d2 100644</span>
<span class="gd">--- a/networkx/algorithms/connectivity/connectivity.py</span>
<span class="gi">+++ b/networkx/algorithms/connectivity/connectivity.py</span>
<span class="gu">@@ -1,22 +1,41 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Flow based connectivity algorithms
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.algorithms.flow import boykov_kolmogorov, build_residual_network, dinitz, edmonds_karp, shortest_augmenting_path</span>
<span class="gi">+</span>
<span class="gi">+# Define the default maximum flow function to use in all flow based</span>
<span class="gi">+# connectivity algorithms.</span>
<span class="gi">+from networkx.algorithms.flow import (</span>
<span class="gi">+    boykov_kolmogorov,</span>
<span class="gi">+    build_residual_network,</span>
<span class="gi">+    dinitz,</span>
<span class="gi">+    edmonds_karp,</span>
<span class="gi">+    shortest_augmenting_path,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>default_flow_func = edmonds_karp
<span class="gi">+</span>
<span class="w"> </span>from .utils import build_auxiliary_edge_connectivity, build_auxiliary_node_connectivity
<span class="gd">-__all__ = [&#39;average_node_connectivity&#39;, &#39;local_node_connectivity&#39;,</span>
<span class="gd">-    &#39;node_connectivity&#39;, &#39;local_edge_connectivity&#39;, &#39;edge_connectivity&#39;,</span>
<span class="gd">-    &#39;all_pairs_node_connectivity&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;average_node_connectivity&quot;,</span>
<span class="gi">+    &quot;local_node_connectivity&quot;,</span>
<span class="gi">+    &quot;node_connectivity&quot;,</span>
<span class="gi">+    &quot;local_edge_connectivity&quot;,</span>
<span class="gi">+    &quot;edge_connectivity&quot;,</span>
<span class="gi">+    &quot;all_pairs_node_connectivity&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@nx._dispatchable(graphs={&#39;G&#39;: 0, &#39;auxiliary?&#39;: 4}, preserve_graph_attrs={</span>
<span class="gd">-    &#39;auxiliary&#39;})</span>
<span class="gd">-def local_node_connectivity(G, s, t, flow_func=None, auxiliary=None,</span>
<span class="gd">-    residual=None, cutoff=None):</span>
<span class="gd">-    &quot;&quot;&quot;Computes local node connectivity for nodes s and t.</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G&quot;: 0, &quot;auxiliary?&quot;: 4}, preserve_graph_attrs={&quot;auxiliary&quot;})</span>
<span class="gi">+def local_node_connectivity(</span>
<span class="gi">+    G, s, t, flow_func=None, auxiliary=None, residual=None, cutoff=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Computes local node connectivity for nodes s and t.</span>

<span class="w"> </span>    Local node connectivity for two non adjacent nodes s and t is the
<span class="w"> </span>    minimum number of nodes that must be removed (along with their incident
<span class="gu">@@ -163,12 +182,35 @@ def local_node_connectivity(G, s, t, flow_func=None, auxiliary=None,</span>
<span class="w"> </span>        http://www.informatik.uni-augsburg.de/thi/personen/kammer/Graph_Connectivity.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+</span>
<span class="gi">+    if auxiliary is None:</span>
<span class="gi">+        H = build_auxiliary_node_connectivity(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = auxiliary</span>
<span class="gi">+</span>
<span class="gi">+    mapping = H.graph.get(&quot;mapping&quot;, None)</span>
<span class="gi">+    if mapping is None:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Invalid auxiliary digraph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    kwargs = {&quot;flow_func&quot;: flow_func, &quot;residual&quot;: residual}</span>
<span class="gi">+    if flow_func is shortest_augmenting_path:</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = cutoff</span>
<span class="gi">+        kwargs[&quot;two_phase&quot;] = True</span>
<span class="gi">+    elif flow_func is edmonds_karp:</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = cutoff</span>
<span class="gi">+    elif flow_func is dinitz:</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = cutoff</span>
<span class="gi">+    elif flow_func is boykov_kolmogorov:</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = cutoff</span>
<span class="gi">+</span>
<span class="gi">+    return nx.maximum_flow_value(H, f&quot;{mapping[s]}B&quot;, f&quot;{mapping[t]}A&quot;, **kwargs)</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def node_connectivity(G, s=None, t=None, flow_func=None):
<span class="gd">-    &quot;&quot;&quot;Returns node connectivity for a graph or digraph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns node connectivity for a graph or digraph G.</span>

<span class="w"> </span>    Node connectivity is equal to the minimum number of nodes that
<span class="w"> </span>    must be removed to disconnect G or render it trivial. If source
<span class="gu">@@ -235,8 +277,8 @@ def node_connectivity(G, s=None, t=None, flow_func=None):</span>
<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="w"> </span>    This is a flow based implementation of node connectivity. The
<span class="gd">-    algorithm works by solving $O((n-\\delta-1+\\delta(\\delta-1)/2))$</span>
<span class="gd">-    maximum flow problems on an auxiliary digraph. Where $\\delta$</span>
<span class="gi">+    algorithm works by solving $O((n-\delta-1+\delta(\delta-1)/2))$</span>
<span class="gi">+    maximum flow problems on an auxiliary digraph. Where $\delta$</span>
<span class="w"> </span>    is the minimum degree of G. For details about the auxiliary
<span class="w"> </span>    digraph and the computation of local node connectivity see
<span class="w"> </span>    :meth:`local_node_connectivity`. This implementation is based
<span class="gu">@@ -257,19 +299,66 @@ def node_connectivity(G, s=None, t=None, flow_func=None):</span>
<span class="w"> </span>        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (s is not None and t is None) or (s is None and t is not None):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Both source and target must be specified.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Local node connectivity</span>
<span class="gi">+    if s is not None and t is not None:</span>
<span class="gi">+        if s not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {s} not in graph&quot;)</span>
<span class="gi">+        if t not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {t} not in graph&quot;)</span>
<span class="gi">+        return local_node_connectivity(G, s, t, flow_func=flow_func)</span>
<span class="gi">+</span>
<span class="gi">+    # Global node connectivity</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        if not nx.is_weakly_connected(G):</span>
<span class="gi">+            return 0</span>
<span class="gi">+        iter_func = itertools.permutations</span>
<span class="gi">+        # It is necessary to consider both predecessors</span>
<span class="gi">+        # and successors for directed graphs</span>
<span class="gi">+</span>
<span class="gi">+        def neighbors(v):</span>
<span class="gi">+            return itertools.chain.from_iterable([G.predecessors(v), G.successors(v)])</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not nx.is_connected(G):</span>
<span class="gi">+            return 0</span>
<span class="gi">+        iter_func = itertools.combinations</span>
<span class="gi">+        neighbors = G.neighbors</span>
<span class="gi">+</span>
<span class="gi">+    # Reuse the auxiliary digraph and the residual network</span>
<span class="gi">+    H = build_auxiliary_node_connectivity(G)</span>
<span class="gi">+    R = build_residual_network(H, &quot;capacity&quot;)</span>
<span class="gi">+    kwargs = {&quot;flow_func&quot;: flow_func, &quot;auxiliary&quot;: H, &quot;residual&quot;: R}</span>
<span class="gi">+</span>
<span class="gi">+    # Pick a node with minimum degree</span>
<span class="gi">+    # Node connectivity is bounded by degree.</span>
<span class="gi">+    v, K = min(G.degree(), key=itemgetter(1))</span>
<span class="gi">+    # compute local node connectivity with all its non-neighbors nodes</span>
<span class="gi">+    for w in set(G) - set(neighbors(v)) - {v}:</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = K</span>
<span class="gi">+        K = min(K, local_node_connectivity(G, v, w, **kwargs))</span>
<span class="gi">+    # Also for non adjacent pairs of neighbors of v</span>
<span class="gi">+    for x, y in iter_func(neighbors(v), 2):</span>
<span class="gi">+        if y in G[x]:</span>
<span class="gi">+            continue</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = K</span>
<span class="gi">+        K = min(K, local_node_connectivity(G, x, y, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+    return K</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def average_node_connectivity(G, flow_func=None):
<span class="gd">-    &quot;&quot;&quot;Returns the average connectivity of a graph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the average connectivity of a graph G.</span>

<span class="gd">-    The average connectivity `\\bar{\\kappa}` of a graph G is the average</span>
<span class="gi">+    The average connectivity `\bar{\kappa}` of a graph G is the average</span>
<span class="w"> </span>    of local node connectivity over all pairs of nodes of G [1]_ .

<span class="w"> </span>    .. math::

<span class="gd">-        \\bar{\\kappa}(G) = \\frac{\\sum_{u,v} \\kappa_{G}(u,v)}{{n \\choose 2}}</span>
<span class="gi">+        \bar{\kappa}(G) = \frac{\sum_{u,v} \kappa_{G}(u,v)}{{n \choose 2}}</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -309,7 +398,24 @@ def average_node_connectivity(G, flow_func=None):</span>
<span class="w"> </span>            http://www.sciencedirect.com/science/article/pii/S0012365X01001807

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        iter_func = itertools.permutations</span>
<span class="gi">+    else:</span>
<span class="gi">+        iter_func = itertools.combinations</span>
<span class="gi">+</span>
<span class="gi">+    # Reuse the auxiliary digraph and the residual network</span>
<span class="gi">+    H = build_auxiliary_node_connectivity(G)</span>
<span class="gi">+    R = build_residual_network(H, &quot;capacity&quot;)</span>
<span class="gi">+    kwargs = {&quot;flow_func&quot;: flow_func, &quot;auxiliary&quot;: H, &quot;residual&quot;: R}</span>
<span class="gi">+</span>
<span class="gi">+    num, den = 0, 0</span>
<span class="gi">+    for u, v in iter_func(G, 2):</span>
<span class="gi">+        num += local_node_connectivity(G, u, v, **kwargs)</span>
<span class="gi">+        den += 1</span>
<span class="gi">+</span>
<span class="gi">+    if den == 0:  # Null Graph</span>
<span class="gi">+        return 0</span>
<span class="gi">+    return num / den</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -352,13 +458,39 @@ def all_pairs_node_connectivity(G, nbunch=None, flow_func=None):</span>
<span class="w"> </span>    :meth:`shortest_augmenting_path`

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nbunch is None:</span>
<span class="gi">+        nbunch = G</span>
<span class="gi">+    else:</span>
<span class="gi">+        nbunch = set(nbunch)</span>
<span class="gi">+</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        iter_func = itertools.permutations</span>
<span class="gi">+    else:</span>
<span class="gi">+        iter_func = itertools.combinations</span>
<span class="gi">+</span>
<span class="gi">+    all_pairs = {n: {} for n in nbunch}</span>
<span class="gi">+</span>
<span class="gi">+    # Reuse auxiliary digraph and residual network</span>
<span class="gi">+    H = build_auxiliary_node_connectivity(G)</span>
<span class="gi">+    mapping = H.graph[&quot;mapping&quot;]</span>
<span class="gi">+    R = build_residual_network(H, &quot;capacity&quot;)</span>
<span class="gi">+    kwargs = {&quot;flow_func&quot;: flow_func, &quot;auxiliary&quot;: H, &quot;residual&quot;: R}</span>

<span class="gi">+    for u, v in iter_func(nbunch, 2):</span>
<span class="gi">+        K = local_node_connectivity(G, u, v, **kwargs)</span>
<span class="gi">+        all_pairs[u][v] = K</span>
<span class="gi">+        if not directed:</span>
<span class="gi">+            all_pairs[v][u] = K</span>

<span class="gd">-@nx._dispatchable(graphs={&#39;G&#39;: 0, &#39;auxiliary?&#39;: 4})</span>
<span class="gd">-def local_edge_connectivity(G, s, t, flow_func=None, auxiliary=None,</span>
<span class="gd">-    residual=None, cutoff=None):</span>
<span class="gd">-    &quot;&quot;&quot;Returns local edge connectivity for nodes s and t in G.</span>
<span class="gi">+    return all_pairs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G&quot;: 0, &quot;auxiliary?&quot;: 4})</span>
<span class="gi">+def local_edge_connectivity(</span>
<span class="gi">+    G, s, t, flow_func=None, auxiliary=None, residual=None, cutoff=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns local edge connectivity for nodes s and t in G.</span>

<span class="w"> </span>    Local edge connectivity for two nodes s and t is the minimum number
<span class="w"> </span>    of edges that must be removed to disconnect them.
<span class="gu">@@ -494,12 +626,31 @@ def local_edge_connectivity(G, s, t, flow_func=None, auxiliary=None,</span>
<span class="w"> </span>        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+</span>
<span class="gi">+    if auxiliary is None:</span>
<span class="gi">+        H = build_auxiliary_edge_connectivity(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = auxiliary</span>
<span class="gi">+</span>
<span class="gi">+    kwargs = {&quot;flow_func&quot;: flow_func, &quot;residual&quot;: residual}</span>
<span class="gi">+    if flow_func is shortest_augmenting_path:</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = cutoff</span>
<span class="gi">+        kwargs[&quot;two_phase&quot;] = True</span>
<span class="gi">+    elif flow_func is edmonds_karp:</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = cutoff</span>
<span class="gi">+    elif flow_func is dinitz:</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = cutoff</span>
<span class="gi">+    elif flow_func is boykov_kolmogorov:</span>
<span class="gi">+        kwargs[&quot;cutoff&quot;] = cutoff</span>
<span class="gi">+</span>
<span class="gi">+    return nx.maximum_flow_value(H, s, t, **kwargs)</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def edge_connectivity(G, s=None, t=None, flow_func=None, cutoff=None):
<span class="gd">-    &quot;&quot;&quot;Returns the edge connectivity of the graph or digraph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the edge connectivity of the graph or digraph G.</span>

<span class="w"> </span>    The edge connectivity is equal to the minimum number of edges that
<span class="w"> </span>    must be removed to disconnect G or render it trivial. If source
<span class="gu">@@ -598,4 +749,68 @@ def edge_connectivity(G, s=None, t=None, flow_func=None, cutoff=None):</span>
<span class="w"> </span>        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (s is not None and t is None) or (s is None and t is not None):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Both source and target must be specified.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Local edge connectivity</span>
<span class="gi">+    if s is not None and t is not None:</span>
<span class="gi">+        if s not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {s} not in graph&quot;)</span>
<span class="gi">+        if t not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {t} not in graph&quot;)</span>
<span class="gi">+        return local_edge_connectivity(G, s, t, flow_func=flow_func, cutoff=cutoff)</span>
<span class="gi">+</span>
<span class="gi">+    # Global edge connectivity</span>
<span class="gi">+    # reuse auxiliary digraph and residual network</span>
<span class="gi">+    H = build_auxiliary_edge_connectivity(G)</span>
<span class="gi">+    R = build_residual_network(H, &quot;capacity&quot;)</span>
<span class="gi">+    kwargs = {&quot;flow_func&quot;: flow_func, &quot;auxiliary&quot;: H, &quot;residual&quot;: R}</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        # Algorithm 8 in [1]</span>
<span class="gi">+        if not nx.is_weakly_connected(G):</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        # initial value for \lambda is minimum degree</span>
<span class="gi">+        L = min(d for n, d in G.degree())</span>
<span class="gi">+        nodes = list(G)</span>
<span class="gi">+        n = len(nodes)</span>
<span class="gi">+</span>
<span class="gi">+        if cutoff is not None:</span>
<span class="gi">+            L = min(cutoff, L)</span>
<span class="gi">+</span>
<span class="gi">+        for i in range(n):</span>
<span class="gi">+            kwargs[&quot;cutoff&quot;] = L</span>
<span class="gi">+            try:</span>
<span class="gi">+                L = min(L, local_edge_connectivity(G, nodes[i], nodes[i + 1], **kwargs))</span>
<span class="gi">+            except IndexError:  # last node!</span>
<span class="gi">+                L = min(L, local_edge_connectivity(G, nodes[i], nodes[0], **kwargs))</span>
<span class="gi">+        return L</span>
<span class="gi">+    else:  # undirected</span>
<span class="gi">+        # Algorithm 6 in [1]</span>
<span class="gi">+        if not nx.is_connected(G):</span>
<span class="gi">+            return 0</span>
<span class="gi">+</span>
<span class="gi">+        # initial value for \lambda is minimum degree</span>
<span class="gi">+        L = min(d for n, d in G.degree())</span>
<span class="gi">+</span>
<span class="gi">+        if cutoff is not None:</span>
<span class="gi">+            L = min(cutoff, L)</span>
<span class="gi">+</span>
<span class="gi">+        # A dominating set is \lambda-covering</span>
<span class="gi">+        # We need a dominating set with at least two nodes</span>
<span class="gi">+        for node in G:</span>
<span class="gi">+            D = nx.dominating_set(G, start_with=node)</span>
<span class="gi">+            v = D.pop()</span>
<span class="gi">+            if D:</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            # in complete graphs the dominating sets will always be of one node</span>
<span class="gi">+            # thus we return min degree</span>
<span class="gi">+            return L</span>
<span class="gi">+</span>
<span class="gi">+        for w in D:</span>
<span class="gi">+            kwargs[&quot;cutoff&quot;] = L</span>
<span class="gi">+            L = min(L, local_edge_connectivity(G, v, w, **kwargs))</span>
<span class="gi">+</span>
<span class="gi">+        return L</span>
<span class="gh">diff --git a/networkx/algorithms/connectivity/cuts.py b/networkx/algorithms/connectivity/cuts.py</span>
<span class="gh">index bce929eda..117004406 100644</span>
<span class="gd">--- a/networkx/algorithms/connectivity/cuts.py</span>
<span class="gi">+++ b/networkx/algorithms/connectivity/cuts.py</span>
<span class="gu">@@ -2,19 +2,31 @@</span>
<span class="w"> </span>Flow based cut algorithms
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import itertools
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="gi">+# Define the default maximum flow function to use in all flow based</span>
<span class="gi">+# cut algorithms.</span>
<span class="w"> </span>from networkx.algorithms.flow import build_residual_network, edmonds_karp
<span class="gi">+</span>
<span class="w"> </span>default_flow_func = edmonds_karp
<span class="gi">+</span>
<span class="w"> </span>from .utils import build_auxiliary_edge_connectivity, build_auxiliary_node_connectivity
<span class="gd">-__all__ = [&#39;minimum_st_node_cut&#39;, &#39;minimum_node_cut&#39;, &#39;minimum_st_edge_cut&#39;,</span>
<span class="gd">-    &#39;minimum_edge_cut&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;minimum_st_node_cut&quot;,</span>
<span class="gi">+    &quot;minimum_node_cut&quot;,</span>
<span class="gi">+    &quot;minimum_st_edge_cut&quot;,</span>
<span class="gi">+    &quot;minimum_edge_cut&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@nx._dispatchable(graphs={&#39;G&#39;: 0, &#39;auxiliary?&#39;: 4}, preserve_edge_attrs={</span>
<span class="gd">-    &#39;auxiliary&#39;: {&#39;capacity&#39;: float(&#39;inf&#39;)}}, preserve_graph_attrs={</span>
<span class="gd">-    &#39;auxiliary&#39;})</span>
<span class="gd">-def minimum_st_edge_cut(G, s, t, flow_func=None, auxiliary=None, residual=None</span>
<span class="gd">-    ):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs={&quot;G&quot;: 0, &quot;auxiliary?&quot;: 4},</span>
<span class="gi">+    preserve_edge_attrs={&quot;auxiliary&quot;: {&quot;capacity&quot;: float(&quot;inf&quot;)}},</span>
<span class="gi">+    preserve_graph_attrs={&quot;auxiliary&quot;},</span>
<span class="gi">+)</span>
<span class="gi">+def minimum_st_edge_cut(G, s, t, flow_func=None, auxiliary=None, residual=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the edges of the cut-set of a minimum (s, t)-cut.

<span class="w"> </span>    This function returns the set of edges of minimum cardinality that,
<span class="gu">@@ -125,14 +137,34 @@ def minimum_st_edge_cut(G, s, t, flow_func=None, auxiliary=None, residual=None</span>
<span class="w"> </span>    5

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs={&#39;G&#39;: 0, &#39;auxiliary?&#39;: 4}, preserve_node_attrs={</span>
<span class="gd">-    &#39;auxiliary&#39;: {&#39;id&#39;: None}}, preserve_graph_attrs={&#39;auxiliary&#39;})</span>
<span class="gd">-def minimum_st_node_cut(G, s, t, flow_func=None, auxiliary=None, residual=None</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;Returns a set of nodes of minimum cardinality that disconnect source</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+</span>
<span class="gi">+    if auxiliary is None:</span>
<span class="gi">+        H = build_auxiliary_edge_connectivity(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = auxiliary</span>
<span class="gi">+</span>
<span class="gi">+    kwargs = {&quot;capacity&quot;: &quot;capacity&quot;, &quot;flow_func&quot;: flow_func, &quot;residual&quot;: residual}</span>
<span class="gi">+</span>
<span class="gi">+    cut_value, partition = nx.minimum_cut(H, s, t, **kwargs)</span>
<span class="gi">+    reachable, non_reachable = partition</span>
<span class="gi">+    # Any edge in the original graph linking the two sets in the</span>
<span class="gi">+    # partition is part of the edge cutset</span>
<span class="gi">+    cutset = set()</span>
<span class="gi">+    for u, nbrs in ((n, G[n]) for n in reachable):</span>
<span class="gi">+        cutset.update((u, v) for v in nbrs if v in non_reachable)</span>
<span class="gi">+</span>
<span class="gi">+    return cutset</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs={&quot;G&quot;: 0, &quot;auxiliary?&quot;: 4},</span>
<span class="gi">+    preserve_node_attrs={&quot;auxiliary&quot;: {&quot;id&quot;: None}},</span>
<span class="gi">+    preserve_graph_attrs={&quot;auxiliary&quot;},</span>
<span class="gi">+)</span>
<span class="gi">+def minimum_st_node_cut(G, s, t, flow_func=None, auxiliary=None, residual=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a set of nodes of minimum cardinality that disconnect source</span>
<span class="w"> </span>    from target in G.

<span class="w"> </span>    This function returns the set of nodes of minimum cardinality that,
<span class="gu">@@ -249,12 +281,29 @@ def minimum_st_node_cut(G, s, t, flow_func=None, auxiliary=None, residual=None</span>
<span class="w"> </span>        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if auxiliary is None:</span>
<span class="gi">+        H = build_auxiliary_node_connectivity(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = auxiliary</span>
<span class="gi">+</span>
<span class="gi">+    mapping = H.graph.get(&quot;mapping&quot;, None)</span>
<span class="gi">+    if mapping is None:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Invalid auxiliary digraph.&quot;)</span>
<span class="gi">+    if G.has_edge(s, t) or G.has_edge(t, s):</span>
<span class="gi">+        return {}</span>
<span class="gi">+    kwargs = {&quot;flow_func&quot;: flow_func, &quot;residual&quot;: residual, &quot;auxiliary&quot;: H}</span>
<span class="gi">+</span>
<span class="gi">+    # The edge cut in the auxiliary digraph corresponds to the node cut in the</span>
<span class="gi">+    # original graph.</span>
<span class="gi">+    edge_cut = minimum_st_edge_cut(H, f&quot;{mapping[s]}B&quot;, f&quot;{mapping[t]}A&quot;, **kwargs)</span>
<span class="gi">+    # Each node in the original graph maps to two nodes of the auxiliary graph</span>
<span class="gi">+    node_cut = {H.nodes[node][&quot;id&quot;] for edge in edge_cut for node in edge}</span>
<span class="gi">+    return node_cut - {s, t}</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def minimum_node_cut(G, s=None, t=None, flow_func=None):
<span class="gd">-    &quot;&quot;&quot;Returns a set of nodes of minimum cardinality that disconnects G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a set of nodes of minimum cardinality that disconnects G.</span>

<span class="w"> </span>    If source and target nodes are provided, this function returns the
<span class="w"> </span>    set of nodes of minimum cardinality that, if removed, would destroy
<span class="gu">@@ -346,12 +395,61 @@ def minimum_node_cut(G, s=None, t=None, flow_func=None):</span>
<span class="w"> </span>        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (s is not None and t is None) or (s is None and t is not None):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Both source and target must be specified.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Local minimum node cut.</span>
<span class="gi">+    if s is not None and t is not None:</span>
<span class="gi">+        if s not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {s} not in graph&quot;)</span>
<span class="gi">+        if t not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {t} not in graph&quot;)</span>
<span class="gi">+        return minimum_st_node_cut(G, s, t, flow_func=flow_func)</span>
<span class="gi">+</span>
<span class="gi">+    # Global minimum node cut.</span>
<span class="gi">+    # Analog to the algorithm 11 for global node connectivity in [1].</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        if not nx.is_weakly_connected(G):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Input graph is not connected&quot;)</span>
<span class="gi">+        iter_func = itertools.permutations</span>
<span class="gi">+</span>
<span class="gi">+        def neighbors(v):</span>
<span class="gi">+            return itertools.chain.from_iterable([G.predecessors(v), G.successors(v)])</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not nx.is_connected(G):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Input graph is not connected&quot;)</span>
<span class="gi">+        iter_func = itertools.combinations</span>
<span class="gi">+        neighbors = G.neighbors</span>
<span class="gi">+</span>
<span class="gi">+    # Reuse the auxiliary digraph and the residual network.</span>
<span class="gi">+    H = build_auxiliary_node_connectivity(G)</span>
<span class="gi">+    R = build_residual_network(H, &quot;capacity&quot;)</span>
<span class="gi">+    kwargs = {&quot;flow_func&quot;: flow_func, &quot;auxiliary&quot;: H, &quot;residual&quot;: R}</span>
<span class="gi">+</span>
<span class="gi">+    # Choose a node with minimum degree.</span>
<span class="gi">+    v = min(G, key=G.degree)</span>
<span class="gi">+    # Initial node cutset is all neighbors of the node with minimum degree.</span>
<span class="gi">+    min_cut = set(G[v])</span>
<span class="gi">+    # Compute st node cuts between v and all its non-neighbors nodes in G.</span>
<span class="gi">+    for w in set(G) - set(neighbors(v)) - {v}:</span>
<span class="gi">+        this_cut = minimum_st_node_cut(G, v, w, **kwargs)</span>
<span class="gi">+        if len(min_cut) &gt;= len(this_cut):</span>
<span class="gi">+            min_cut = this_cut</span>
<span class="gi">+    # Also for non adjacent pairs of neighbors of v.</span>
<span class="gi">+    for x, y in iter_func(neighbors(v), 2):</span>
<span class="gi">+        if y in G[x]:</span>
<span class="gi">+            continue</span>
<span class="gi">+        this_cut = minimum_st_node_cut(G, x, y, **kwargs)</span>
<span class="gi">+        if len(min_cut) &gt;= len(this_cut):</span>
<span class="gi">+            min_cut = this_cut</span>
<span class="gi">+</span>
<span class="gi">+    return min_cut</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def minimum_edge_cut(G, s=None, t=None, flow_func=None):
<span class="gd">-    &quot;&quot;&quot;Returns a set of edges of minimum cardinality that disconnects G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a set of edges of minimum cardinality that disconnects G.</span>

<span class="w"> </span>    If source and target nodes are provided, this function returns the
<span class="w"> </span>    set of edges of minimum cardinality that, if removed, would break
<span class="gu">@@ -445,4 +543,69 @@ def minimum_edge_cut(G, s=None, t=None, flow_func=None):</span>
<span class="w"> </span>        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (s is not None and t is None) or (s is None and t is not None):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Both source and target must be specified.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # reuse auxiliary digraph and residual network</span>
<span class="gi">+    H = build_auxiliary_edge_connectivity(G)</span>
<span class="gi">+    R = build_residual_network(H, &quot;capacity&quot;)</span>
<span class="gi">+    kwargs = {&quot;flow_func&quot;: flow_func, &quot;residual&quot;: R, &quot;auxiliary&quot;: H}</span>
<span class="gi">+</span>
<span class="gi">+    # Local minimum edge cut if s and t are not None</span>
<span class="gi">+    if s is not None and t is not None:</span>
<span class="gi">+        if s not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {s} not in graph&quot;)</span>
<span class="gi">+        if t not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {t} not in graph&quot;)</span>
<span class="gi">+        return minimum_st_edge_cut(H, s, t, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    # Global minimum edge cut</span>
<span class="gi">+    # Analog to the algorithm for global edge connectivity</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        # Based on algorithm 8 in [1]</span>
<span class="gi">+        if not nx.is_weakly_connected(G):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Input graph is not connected&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Initial cutset is all edges of a node with minimum degree</span>
<span class="gi">+        node = min(G, key=G.degree)</span>
<span class="gi">+        min_cut = set(G.edges(node))</span>
<span class="gi">+        nodes = list(G)</span>
<span class="gi">+        n = len(nodes)</span>
<span class="gi">+        for i in range(n):</span>
<span class="gi">+            try:</span>
<span class="gi">+                this_cut = minimum_st_edge_cut(H, nodes[i], nodes[i + 1], **kwargs)</span>
<span class="gi">+                if len(this_cut) &lt;= len(min_cut):</span>
<span class="gi">+                    min_cut = this_cut</span>
<span class="gi">+            except IndexError:  # Last node!</span>
<span class="gi">+                this_cut = minimum_st_edge_cut(H, nodes[i], nodes[0], **kwargs)</span>
<span class="gi">+                if len(this_cut) &lt;= len(min_cut):</span>
<span class="gi">+                    min_cut = this_cut</span>
<span class="gi">+</span>
<span class="gi">+        return min_cut</span>
<span class="gi">+</span>
<span class="gi">+    else:  # undirected</span>
<span class="gi">+        # Based on algorithm 6 in [1]</span>
<span class="gi">+        if not nx.is_connected(G):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Input graph is not connected&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Initial cutset is all edges of a node with minimum degree</span>
<span class="gi">+        node = min(G, key=G.degree)</span>
<span class="gi">+        min_cut = set(G.edges(node))</span>
<span class="gi">+        # A dominating set is \lambda-covering</span>
<span class="gi">+        # We need a dominating set with at least two nodes</span>
<span class="gi">+        for node in G:</span>
<span class="gi">+            D = nx.dominating_set(G, start_with=node)</span>
<span class="gi">+            v = D.pop()</span>
<span class="gi">+            if D:</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            # in complete graphs the dominating set will always be of one node</span>
<span class="gi">+            # thus we return min_cut, which now contains the edges of a node</span>
<span class="gi">+            # with minimum degree</span>
<span class="gi">+            return min_cut</span>
<span class="gi">+        for w in D:</span>
<span class="gi">+            this_cut = minimum_st_edge_cut(H, v, w, **kwargs)</span>
<span class="gi">+            if len(this_cut) &lt;= len(min_cut):</span>
<span class="gi">+                min_cut = this_cut</span>
<span class="gi">+</span>
<span class="gi">+        return min_cut</span>
<span class="gh">diff --git a/networkx/algorithms/connectivity/disjoint_paths.py b/networkx/algorithms/connectivity/disjoint_paths.py</span>
<span class="gh">index ebe417b6b..e4634e7dd 100644</span>
<span class="gd">--- a/networkx/algorithms/connectivity/disjoint_paths.py</span>
<span class="gi">+++ b/networkx/algorithms/connectivity/disjoint_paths.py</span>
<span class="gu">@@ -1,17 +1,31 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Flow based node and edge disjoint paths.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.algorithms.flow import edmonds_karp, preflow_push, shortest_augmenting_path</span>
<span class="gi">+</span>
<span class="gi">+# Define the default maximum flow function to use for the underlying</span>
<span class="gi">+# maximum flow computations</span>
<span class="gi">+from networkx.algorithms.flow import (</span>
<span class="gi">+    edmonds_karp,</span>
<span class="gi">+    preflow_push,</span>
<span class="gi">+    shortest_augmenting_path,</span>
<span class="gi">+)</span>
<span class="w"> </span>from networkx.exception import NetworkXNoPath
<span class="gi">+</span>
<span class="w"> </span>default_flow_func = edmonds_karp
<span class="w"> </span>from itertools import filterfalse as _filterfalse
<span class="gi">+</span>
<span class="gi">+# Functions to build auxiliary data structures.</span>
<span class="w"> </span>from .utils import build_auxiliary_edge_connectivity, build_auxiliary_node_connectivity
<span class="gd">-__all__ = [&#39;edge_disjoint_paths&#39;, &#39;node_disjoint_paths&#39;]</span>

<span class="gi">+__all__ = [&quot;edge_disjoint_paths&quot;, &quot;node_disjoint_paths&quot;]</span>

<span class="gd">-@nx._dispatchable(graphs={&#39;G&#39;: 0, &#39;auxiliary?&#39;: 5}, preserve_edge_attrs={</span>
<span class="gd">-    &#39;auxiliary&#39;: {&#39;capacity&#39;: float(&#39;inf&#39;)}})</span>
<span class="gd">-def edge_disjoint_paths(G, s, t, flow_func=None, cutoff=None, auxiliary=</span>
<span class="gd">-    None, residual=None):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs={&quot;G&quot;: 0, &quot;auxiliary?&quot;: 5},</span>
<span class="gi">+    preserve_edge_attrs={&quot;auxiliary&quot;: {&quot;capacity&quot;: float(&quot;inf&quot;)}},</span>
<span class="gi">+)</span>
<span class="gi">+def edge_disjoint_paths(</span>
<span class="gi">+    G, s, t, flow_func=None, cutoff=None, auxiliary=None, residual=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the edges disjoint paths between source and target.

<span class="w"> </span>    Edge disjoint paths are paths that do not share any edge. The
<span class="gu">@@ -138,14 +152,93 @@ def edge_disjoint_paths(G, s, t, flow_func=None, cutoff=None, auxiliary=</span>
<span class="w"> </span>    package.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs={&#39;G&#39;: 0, &#39;auxiliary?&#39;: 5}, preserve_node_attrs={</span>
<span class="gd">-    &#39;auxiliary&#39;: {&#39;id&#39;: None}}, preserve_graph_attrs={&#39;auxiliary&#39;})</span>
<span class="gd">-def node_disjoint_paths(G, s, t, flow_func=None, cutoff=None, auxiliary=</span>
<span class="gd">-    None, residual=None):</span>
<span class="gd">-    &quot;&quot;&quot;Computes node disjoint paths between source and target.</span>
<span class="gi">+    if s not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {s} not in graph&quot;)</span>
<span class="gi">+    if t not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {t} not in graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+</span>
<span class="gi">+    if auxiliary is None:</span>
<span class="gi">+        H = build_auxiliary_edge_connectivity(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = auxiliary</span>
<span class="gi">+</span>
<span class="gi">+    # Maximum possible edge disjoint paths</span>
<span class="gi">+    possible = min(H.out_degree(s), H.in_degree(t))</span>
<span class="gi">+    if not possible:</span>
<span class="gi">+        raise NetworkXNoPath</span>
<span class="gi">+</span>
<span class="gi">+    if cutoff is None:</span>
<span class="gi">+        cutoff = possible</span>
<span class="gi">+    else:</span>
<span class="gi">+        cutoff = min(cutoff, possible)</span>
<span class="gi">+</span>
<span class="gi">+    # Compute maximum flow between source and target. Flow functions in</span>
<span class="gi">+    # NetworkX return a residual network.</span>
<span class="gi">+    kwargs = {</span>
<span class="gi">+        &quot;capacity&quot;: &quot;capacity&quot;,</span>
<span class="gi">+        &quot;residual&quot;: residual,</span>
<span class="gi">+        &quot;cutoff&quot;: cutoff,</span>
<span class="gi">+        &quot;value_only&quot;: True,</span>
<span class="gi">+    }</span>
<span class="gi">+    if flow_func is preflow_push:</span>
<span class="gi">+        del kwargs[&quot;cutoff&quot;]</span>
<span class="gi">+    if flow_func is shortest_augmenting_path:</span>
<span class="gi">+        kwargs[&quot;two_phase&quot;] = True</span>
<span class="gi">+    R = flow_func(H, s, t, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if R.graph[&quot;flow_value&quot;] == 0:</span>
<span class="gi">+        raise NetworkXNoPath</span>
<span class="gi">+</span>
<span class="gi">+    # Saturated edges in the residual network form the edge disjoint paths</span>
<span class="gi">+    # between source and target</span>
<span class="gi">+    cutset = [</span>
<span class="gi">+        (u, v)</span>
<span class="gi">+        for u, v, d in R.edges(data=True)</span>
<span class="gi">+        if d[&quot;capacity&quot;] == d[&quot;flow&quot;] and d[&quot;flow&quot;] &gt; 0</span>
<span class="gi">+    ]</span>
<span class="gi">+    # This is equivalent of what flow.utils.build_flow_dict returns, but</span>
<span class="gi">+    # only for the nodes with saturated edges and without reporting 0 flows.</span>
<span class="gi">+    flow_dict = {n: {} for edge in cutset for n in edge}</span>
<span class="gi">+    for u, v in cutset:</span>
<span class="gi">+        flow_dict[u][v] = 1</span>
<span class="gi">+</span>
<span class="gi">+    # Rebuild the edge disjoint paths from the flow dictionary.</span>
<span class="gi">+    paths_found = 0</span>
<span class="gi">+    for v in list(flow_dict[s]):</span>
<span class="gi">+        if paths_found &gt;= cutoff:</span>
<span class="gi">+            # preflow_push does not support cutoff: we have to</span>
<span class="gi">+            # keep track of the paths founds and stop at cutoff.</span>
<span class="gi">+            break</span>
<span class="gi">+        path = [s]</span>
<span class="gi">+        if v == t:</span>
<span class="gi">+            path.append(v)</span>
<span class="gi">+            yield path</span>
<span class="gi">+            continue</span>
<span class="gi">+        u = v</span>
<span class="gi">+        while u != t:</span>
<span class="gi">+            path.append(u)</span>
<span class="gi">+            try:</span>
<span class="gi">+                u, _ = flow_dict[u].popitem()</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            path.append(t)</span>
<span class="gi">+            yield path</span>
<span class="gi">+            paths_found += 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs={&quot;G&quot;: 0, &quot;auxiliary?&quot;: 5},</span>
<span class="gi">+    preserve_node_attrs={&quot;auxiliary&quot;: {&quot;id&quot;: None}},</span>
<span class="gi">+    preserve_graph_attrs={&quot;auxiliary&quot;},</span>
<span class="gi">+)</span>
<span class="gi">+def node_disjoint_paths(</span>
<span class="gi">+    G, s, t, flow_func=None, cutoff=None, auxiliary=None, residual=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Computes node disjoint paths between source and target.</span>

<span class="w"> </span>    Node disjoint paths are paths that only share their first and last
<span class="w"> </span>    nodes. The number of node independent paths between two nodes is
<span class="gu">@@ -264,9 +357,51 @@ def node_disjoint_paths(G, s, t, flow_func=None, cutoff=None, auxiliary=</span>
<span class="w"> </span>    :meth:`shortest_augmenting_path`

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if s not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {s} not in graph&quot;)</span>
<span class="gi">+    if t not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {t} not in graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if auxiliary is None:</span>
<span class="gi">+        H = build_auxiliary_node_connectivity(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = auxiliary</span>
<span class="gi">+</span>
<span class="gi">+    mapping = H.graph.get(&quot;mapping&quot;, None)</span>
<span class="gi">+    if mapping is None:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Invalid auxiliary digraph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Maximum possible edge disjoint paths</span>
<span class="gi">+    possible = min(H.out_degree(f&quot;{mapping[s]}B&quot;), H.in_degree(f&quot;{mapping[t]}A&quot;))</span>
<span class="gi">+    if not possible:</span>
<span class="gi">+        raise NetworkXNoPath</span>
<span class="gi">+</span>
<span class="gi">+    if cutoff is None:</span>
<span class="gi">+        cutoff = possible</span>
<span class="gi">+    else:</span>
<span class="gi">+        cutoff = min(cutoff, possible)</span>
<span class="gi">+</span>
<span class="gi">+    kwargs = {</span>
<span class="gi">+        &quot;flow_func&quot;: flow_func,</span>
<span class="gi">+        &quot;residual&quot;: residual,</span>
<span class="gi">+        &quot;auxiliary&quot;: H,</span>
<span class="gi">+        &quot;cutoff&quot;: cutoff,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # The edge disjoint paths in the auxiliary digraph correspond to the node</span>
<span class="gi">+    # disjoint paths in the original graph.</span>
<span class="gi">+    paths_edges = edge_disjoint_paths(H, f&quot;{mapping[s]}B&quot;, f&quot;{mapping[t]}A&quot;, **kwargs)</span>
<span class="gi">+    for path in paths_edges:</span>
<span class="gi">+        # Each node in the original graph maps to two nodes in auxiliary graph</span>
<span class="gi">+        yield list(_unique_everseen(H.nodes[node][&quot;id&quot;] for node in path))</span>


<span class="w"> </span>def _unique_everseen(iterable):
<span class="gd">-    &quot;&quot;&quot;List unique elements, preserving order. Remember all elements ever seen.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    # Adapted from https://docs.python.org/3/library/itertools.html examples</span>
<span class="gi">+    &quot;List unique elements, preserving order. Remember all elements ever seen.&quot;</span>
<span class="gi">+    # unique_everseen(&#39;AAAABBBCCDAABBB&#39;) --&gt; A B C D</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    seen_add = seen.add</span>
<span class="gi">+    for element in _filterfalse(seen.__contains__, iterable):</span>
<span class="gi">+        seen_add(element)</span>
<span class="gi">+        yield element</span>
<span class="gh">diff --git a/networkx/algorithms/connectivity/edge_augmentation.py b/networkx/algorithms/connectivity/edge_augmentation.py</span>
<span class="gh">index bffa31877..d095ed519 100644</span>
<span class="gd">--- a/networkx/algorithms/connectivity/edge_augmentation.py</span>
<span class="gi">+++ b/networkx/algorithms/connectivity/edge_augmentation.py</span>
<span class="gu">@@ -15,14 +15,15 @@ See Also</span>
<span class="w"> </span>import itertools as it
<span class="w"> </span>import math
<span class="w"> </span>from collections import defaultdict, namedtuple
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;k_edge_augmentation&#39;, &#39;is_k_edge_connected&#39;,</span>
<span class="gd">-    &#39;is_locally_k_edge_connected&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;k_edge_augmentation&quot;, &quot;is_k_edge_connected&quot;, &quot;is_locally_k_edge_connected&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_k_edge_connected(G, k):
<span class="w"> </span>    &quot;&quot;&quot;Tests to see if a graph is k-edge-connected.
<span class="gu">@@ -55,11 +56,25 @@ def is_k_edge_connected(G, k):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.is_k_edge_connected(G, k=2)
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    if k &lt; 1:</span>
<span class="gi">+        raise ValueError(f&quot;k must be positive, not {k}&quot;)</span>
<span class="gi">+    # First try to quickly determine if G is not k-edge-connected</span>
<span class="gi">+    if G.number_of_nodes() &lt; k + 1:</span>
<span class="gi">+        return False</span>
<span class="gi">+    elif any(d &lt; k for n, d in G.degree()):</span>
<span class="gi">+        return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Otherwise perform the full check</span>
<span class="gi">+        if k == 1:</span>
<span class="gi">+            return nx.is_connected(G)</span>
<span class="gi">+        elif k == 2:</span>
<span class="gi">+            return nx.is_connected(G) and not nx.has_bridges(G)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return nx.edge_connectivity(G, cutoff=k) &gt;= k</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_locally_k_edge_connected(G, s, t, k):
<span class="w"> </span>    &quot;&quot;&quot;Tests to see if an edge in a graph is locally k-edge-connected.
<span class="gu">@@ -101,11 +116,23 @@ def is_locally_k_edge_connected(G, s, t, k):</span>
<span class="w"> </span>    &gt;&gt;&gt; is_locally_k_edge_connected(G, 1, 5, k=2)
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    if k &lt; 1:</span>
<span class="gi">+        raise ValueError(f&quot;k must be positive, not {k}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # First try to quickly determine s, t is not k-locally-edge-connected in G</span>
<span class="gi">+    if G.degree(s) &lt; k or G.degree(t) &lt; k:</span>
<span class="gi">+        return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Otherwise perform the full check</span>
<span class="gi">+        if k == 1:</span>
<span class="gi">+            return nx.has_path(G, s, t)</span>
<span class="gi">+        else:</span>
<span class="gi">+            localk = nx.connectivity.local_edge_connectivity(G, s, t, cutoff=k)</span>
<span class="gi">+            return localk &gt;= k</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def k_edge_augmentation(G, k, avail=None, weight=None, partial=False):
<span class="w"> </span>    &quot;&quot;&quot;Finds set of edges to k-edge-connect G.
<span class="gu">@@ -217,7 +244,44 @@ def k_edge_augmentation(G, k, avail=None, weight=None, partial=False):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(nx.k_edge_augmentation(G, k=2, avail=avail, partial=True))
<span class="w"> </span>    [(1, 5)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if k &lt;= 0:</span>
<span class="gi">+            raise ValueError(f&quot;k must be a positive integer, not {k}&quot;)</span>
<span class="gi">+        elif G.number_of_nodes() &lt; k + 1:</span>
<span class="gi">+            msg = f&quot;impossible to {k} connect in graph with less than {k + 1} nodes&quot;</span>
<span class="gi">+            raise nx.NetworkXUnfeasible(msg)</span>
<span class="gi">+        elif avail is not None and len(avail) == 0:</span>
<span class="gi">+            if not nx.is_k_edge_connected(G, k):</span>
<span class="gi">+                raise nx.NetworkXUnfeasible(&quot;no available edges&quot;)</span>
<span class="gi">+            aug_edges = []</span>
<span class="gi">+        elif k == 1:</span>
<span class="gi">+            aug_edges = one_edge_augmentation(</span>
<span class="gi">+                G, avail=avail, weight=weight, partial=partial</span>
<span class="gi">+            )</span>
<span class="gi">+        elif k == 2:</span>
<span class="gi">+            aug_edges = bridge_augmentation(G, avail=avail, weight=weight)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # raise NotImplementedError(f&#39;not implemented for k&gt;2. k={k}&#39;)</span>
<span class="gi">+            aug_edges = greedy_k_edge_augmentation(</span>
<span class="gi">+                G, k=k, avail=avail, weight=weight, seed=0</span>
<span class="gi">+            )</span>
<span class="gi">+        # Do eager evaluation so we can catch any exceptions</span>
<span class="gi">+        # Before executing partial code.</span>
<span class="gi">+        yield from list(aug_edges)</span>
<span class="gi">+    except nx.NetworkXUnfeasible:</span>
<span class="gi">+        if partial:</span>
<span class="gi">+            # Return all available edges</span>
<span class="gi">+            if avail is None:</span>
<span class="gi">+                aug_edges = complement_edges(G)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # If we can&#39;t k-edge-connect the entire graph, try to</span>
<span class="gi">+                # k-edge-connect as much as possible</span>
<span class="gi">+                aug_edges = partial_k_edge_augmentation(</span>
<span class="gi">+                    G, k=k, avail=avail, weight=weight</span>
<span class="gi">+                )</span>
<span class="gi">+            yield from aug_edges</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -273,11 +337,56 @@ def partial_k_edge_augmentation(G, k, avail, weight=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(partial_k_edge_augmentation(G, k=2, avail=avail))
<span class="w"> </span>    [(1, 5), (1, 8)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    def _edges_between_disjoint(H, only1, only2):</span>
<span class="gi">+        &quot;&quot;&quot;finds edges between disjoint nodes&quot;&quot;&quot;</span>
<span class="gi">+        only1_adj = {u: set(H.adj[u]) for u in only1}</span>
<span class="gi">+        for u, neighbs in only1_adj.items():</span>
<span class="gi">+            # Find the neighbors of u in only1 that are also in only2</span>
<span class="gi">+            neighbs12 = neighbs.intersection(only2)</span>
<span class="gi">+            for v in neighbs12:</span>
<span class="gi">+                yield (u, v)</span>
<span class="gi">+</span>
<span class="gi">+    avail_uv, avail_w = _unpack_available_edges(avail, weight=weight, G=G)</span>
<span class="gi">+</span>
<span class="gi">+    # Find which parts of the graph can be k-edge-connected</span>
<span class="gi">+    H = G.copy()</span>
<span class="gi">+    H.add_edges_from(</span>
<span class="gi">+        (</span>
<span class="gi">+            (u, v, {&quot;weight&quot;: w, &quot;generator&quot;: (u, v)})</span>
<span class="gi">+            for (u, v), w in zip(avail, avail_w)</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    k_edge_subgraphs = list(nx.k_edge_subgraphs(H, k=k))</span>
<span class="gi">+</span>
<span class="gi">+    # Generate edges to k-edge-connect internal subgraphs</span>
<span class="gi">+    for nodes in k_edge_subgraphs:</span>
<span class="gi">+        if len(nodes) &gt; 1:</span>
<span class="gi">+            # Get the k-edge-connected subgraph</span>
<span class="gi">+            C = H.subgraph(nodes).copy()</span>
<span class="gi">+            # Find the internal edges that were available</span>
<span class="gi">+            sub_avail = {</span>
<span class="gi">+                d[&quot;generator&quot;]: d[&quot;weight&quot;]</span>
<span class="gi">+                for (u, v, d) in C.edges(data=True)</span>
<span class="gi">+                if &quot;generator&quot; in d</span>
<span class="gi">+            }</span>
<span class="gi">+            # Remove potential augmenting edges</span>
<span class="gi">+            C.remove_edges_from(sub_avail.keys())</span>
<span class="gi">+            # Find a subset of these edges that makes the component</span>
<span class="gi">+            # k-edge-connected and ignore the rest</span>
<span class="gi">+            yield from nx.k_edge_augmentation(C, k=k, avail=sub_avail)</span>
<span class="gi">+</span>
<span class="gi">+    # Generate all edges between CCs that could not be k-edge-connected</span>
<span class="gi">+    for cc1, cc2 in it.combinations(k_edge_subgraphs, 2):</span>
<span class="gi">+        for u, v in _edges_between_disjoint(H, cc1, cc2):</span>
<span class="gi">+            d = H.get_edge_data(u, v)</span>
<span class="gi">+            edge = d.get(&quot;generator&quot;, None)</span>
<span class="gi">+            if edge is not None:</span>
<span class="gi">+                yield edge</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def one_edge_augmentation(G, avail=None, weight=None, partial=False):
<span class="w"> </span>    &quot;&quot;&quot;Finds minimum weight set of edges to connect G.
<span class="gu">@@ -323,11 +432,16 @@ def one_edge_augmentation(G, avail=None, weight=None, partial=False):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    :func:`k_edge_augmentation`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if avail is None:</span>
<span class="gi">+        return unconstrained_one_edge_augmentation(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return weighted_one_edge_augmentation(</span>
<span class="gi">+            G, avail=avail, weight=weight, partial=partial</span>
<span class="gi">+        )</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def bridge_augmentation(G, avail=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Finds the a set of edges that bridge connects G.
<span class="gu">@@ -370,20 +484,49 @@ def bridge_augmentation(G, avail=None, weight=None):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    :func:`k_edge_augmentation`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.number_of_nodes() &lt; 3:</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(&quot;impossible to bridge connect less than 3 nodes&quot;)</span>
<span class="gi">+    if avail is None:</span>
<span class="gi">+        return unconstrained_bridge_augmentation(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return weighted_bridge_augmentation(G, avail, weight=weight)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# --- Algorithms and Helpers ---</span>


<span class="w"> </span>def _ordered(u, v):
<span class="w"> </span>    &quot;&quot;&quot;Returns the nodes in an undirected edge in lower-triangular order&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (u, v) if u &lt; v else (v, u)</span>


<span class="w"> </span>def _unpack_available_edges(avail, weight=None, G=None):
<span class="w"> </span>    &quot;&quot;&quot;Helper to separate avail into edges and corresponding weights&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if weight is None:</span>
<span class="gi">+        weight = &quot;weight&quot;</span>
<span class="gi">+    if isinstance(avail, dict):</span>
<span class="gi">+        avail_uv = list(avail.keys())</span>
<span class="gi">+        avail_w = list(avail.values())</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def _try_getitem(d):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return d[weight]</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                return d</span>

<span class="gi">+        avail_uv = [tup[0:2] for tup in avail]</span>
<span class="gi">+        avail_w = [1 if len(tup) == 2 else _try_getitem(tup[-1]) for tup in avail]</span>

<span class="gd">-MetaEdge = namedtuple(&#39;MetaEdge&#39;, (&#39;meta_uv&#39;, &#39;uv&#39;, &#39;w&#39;))</span>
<span class="gi">+    if G is not None:</span>
<span class="gi">+        # Edges already in the graph are filtered</span>
<span class="gi">+        flags = [not G.has_edge(u, v) for u, v in avail_uv]</span>
<span class="gi">+        avail_uv = list(it.compress(avail_uv, flags))</span>
<span class="gi">+        avail_w = list(it.compress(avail_w, flags))</span>
<span class="gi">+    return avail_uv, avail_w</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+MetaEdge = namedtuple(&quot;MetaEdge&quot;, (&quot;meta_uv&quot;, &quot;uv&quot;, &quot;w&quot;))</span>


<span class="w"> </span>def _lightest_meta_edges(mapping, avail_uv, avail_w):
<span class="gu">@@ -419,7 +562,20 @@ def _lightest_meta_edges(mapping, avail_uv, avail_w):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(_lightest_meta_edges(mapping, avail_uv, avail_w))
<span class="w"> </span>    [MetaEdge(meta_uv=(0, 1), uv=(5, 2), w=15), MetaEdge(meta_uv=(0, 2), uv=(6, 1), w=50)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    grouped_wuv = defaultdict(list)</span>
<span class="gi">+    for w, (u, v) in zip(avail_w, avail_uv):</span>
<span class="gi">+        # Order the meta-edge so it can be used as a dict key</span>
<span class="gi">+        meta_uv = _ordered(mapping[u], mapping[v])</span>
<span class="gi">+        # Group each available edge using the meta-edge as a key</span>
<span class="gi">+        grouped_wuv[meta_uv].append((w, u, v))</span>
<span class="gi">+</span>
<span class="gi">+    # Now that all available edges are grouped, choose one per group</span>
<span class="gi">+    for (mu, mv), choices_wuv in grouped_wuv.items():</span>
<span class="gi">+        # Ignore available edges within the same meta-node</span>
<span class="gi">+        if mu != mv:</span>
<span class="gi">+            # Choose the lightest available edge belonging to each meta-edge</span>
<span class="gi">+            w, u, v = min(choices_wuv)</span>
<span class="gi">+            yield MetaEdge((mu, mv), (u, v), w)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -451,7 +607,18 @@ def unconstrained_one_edge_augmentation(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(unconstrained_one_edge_augmentation(G))
<span class="w"> </span>    [(1, 4), (4, 6), (6, 7), (7, 8)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ccs1 = list(nx.connected_components(G))</span>
<span class="gi">+    C = collapse(G, ccs1)</span>
<span class="gi">+    # When we are not constrained, we can just make a meta graph tree.</span>
<span class="gi">+    meta_nodes = list(C.nodes())</span>
<span class="gi">+    # build a path in the metagraph</span>
<span class="gi">+    meta_aug = list(zip(meta_nodes, meta_nodes[1:]))</span>
<span class="gi">+    # map that path to the original graph</span>
<span class="gi">+    inverse = defaultdict(list)</span>
<span class="gi">+    for k, v in C.graph[&quot;mapping&quot;].items():</span>
<span class="gi">+        inverse[v].append(k)</span>
<span class="gi">+    for mu, mv in meta_aug:</span>
<span class="gi">+        yield (inverse[mu][0], inverse[mv][0])</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -500,7 +667,27 @@ def weighted_one_edge_augmentation(G, avail, weight=None, partial=False):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(weighted_one_edge_augmentation(G, avail))
<span class="w"> </span>    [(1, 5), (4, 7), (6, 1), (8, 2)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    avail_uv, avail_w = _unpack_available_edges(avail, weight=weight, G=G)</span>
<span class="gi">+    # Collapse CCs in the original graph into nodes in a metagraph</span>
<span class="gi">+    # Then find an MST of the metagraph instead of the original graph</span>
<span class="gi">+    C = collapse(G, nx.connected_components(G))</span>
<span class="gi">+    mapping = C.graph[&quot;mapping&quot;]</span>
<span class="gi">+    # Assign each available edge to an edge in the metagraph</span>
<span class="gi">+    candidate_mapping = _lightest_meta_edges(mapping, avail_uv, avail_w)</span>
<span class="gi">+    # nx.set_edge_attributes(C, name=&#39;weight&#39;, values=0)</span>
<span class="gi">+    C.add_edges_from(</span>
<span class="gi">+        (mu, mv, {&quot;weight&quot;: w, &quot;generator&quot;: uv})</span>
<span class="gi">+        for (mu, mv), uv, w in candidate_mapping</span>
<span class="gi">+    )</span>
<span class="gi">+    # Find MST of the meta graph</span>
<span class="gi">+    meta_mst = nx.minimum_spanning_tree(C)</span>
<span class="gi">+    if not partial and not nx.is_connected(meta_mst):</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(&quot;Not possible to connect G with available edges&quot;)</span>
<span class="gi">+    # Yield the edge that generated the meta-edge</span>
<span class="gi">+    for mu, mv, d in meta_mst.edges(data=True):</span>
<span class="gi">+        if &quot;generator&quot; in d:</span>
<span class="gi">+            edge = d[&quot;generator&quot;]</span>
<span class="gi">+            yield edge</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -580,7 +767,82 @@ def unconstrained_bridge_augmentation(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(unconstrained_bridge_augmentation(G))
<span class="w"> </span>    [(1, 4), (4, 0)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # -----</span>
<span class="gi">+    # Mapping of terms from (Eswaran and Tarjan):</span>
<span class="gi">+    #     G = G_0 - the input graph</span>
<span class="gi">+    #     C = G_0&#39; - the bridge condensation of G. (This is a forest of trees)</span>
<span class="gi">+    #     A1 = A_1 - the edges to connect the forest into a tree</span>
<span class="gi">+    #         leaf = pendant - a node with degree of 1</span>
<span class="gi">+</span>
<span class="gi">+    #     alpha(v) = maps the node v in G to its meta-node in C</span>
<span class="gi">+    #     beta(x) = maps the meta-node x in C to any node in the bridge</span>
<span class="gi">+    #         component of G corresponding to x.</span>
<span class="gi">+</span>
<span class="gi">+    # find the 2-edge-connected components of G</span>
<span class="gi">+    bridge_ccs = list(nx.connectivity.bridge_components(G))</span>
<span class="gi">+    # condense G into an forest C</span>
<span class="gi">+    C = collapse(G, bridge_ccs)</span>
<span class="gi">+</span>
<span class="gi">+    # Choose pairs of distinct leaf nodes in each tree. If this is not</span>
<span class="gi">+    # possible then make a pair using the single isolated node in the tree.</span>
<span class="gi">+    vset1 = [</span>
<span class="gi">+        tuple(cc) * 2  # case1: an isolated node</span>
<span class="gi">+        if len(cc) == 1</span>
<span class="gi">+        else sorted(cc, key=C.degree)[0:2]  # case2: pair of leaf nodes</span>
<span class="gi">+        for cc in nx.connected_components(C)</span>
<span class="gi">+    ]</span>
<span class="gi">+    if len(vset1) &gt; 1:</span>
<span class="gi">+        # Use this set to construct edges that connect C into a tree.</span>
<span class="gi">+        nodes1 = [vs[0] for vs in vset1]</span>
<span class="gi">+        nodes2 = [vs[1] for vs in vset1]</span>
<span class="gi">+        A1 = list(zip(nodes1[1:], nodes2))</span>
<span class="gi">+    else:</span>
<span class="gi">+        A1 = []</span>
<span class="gi">+    # Connect each tree in the forest to construct an arborescence</span>
<span class="gi">+    T = C.copy()</span>
<span class="gi">+    T.add_edges_from(A1)</span>
<span class="gi">+</span>
<span class="gi">+    # If there are only two leaf nodes, we simply connect them.</span>
<span class="gi">+    leafs = [n for n, d in T.degree() if d == 1]</span>
<span class="gi">+    if len(leafs) == 1:</span>
<span class="gi">+        A2 = []</span>
<span class="gi">+    if len(leafs) == 2:</span>
<span class="gi">+        A2 = [tuple(leafs)]</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Choose an arbitrary non-leaf root</span>
<span class="gi">+        try:</span>
<span class="gi">+            root = next(n for n, d in T.degree() if d &gt; 1)</span>
<span class="gi">+        except StopIteration:  # no nodes found with degree &gt; 1</span>
<span class="gi">+            return</span>
<span class="gi">+        # order the leaves of C by (induced directed) preorder</span>
<span class="gi">+        v2 = [n for n in nx.dfs_preorder_nodes(T, root) if T.degree(n) == 1]</span>
<span class="gi">+        # connecting first half of the leafs in pre-order to the second</span>
<span class="gi">+        # half will bridge connect the tree with the fewest edges.</span>
<span class="gi">+        half = math.ceil(len(v2) / 2)</span>
<span class="gi">+        A2 = list(zip(v2[:half], v2[-half:]))</span>
<span class="gi">+</span>
<span class="gi">+    # collect the edges used to augment the original forest</span>
<span class="gi">+    aug_tree_edges = A1 + A2</span>
<span class="gi">+</span>
<span class="gi">+    # Construct the mapping (beta) from meta-nodes to regular nodes</span>
<span class="gi">+    inverse = defaultdict(list)</span>
<span class="gi">+    for k, v in C.graph[&quot;mapping&quot;].items():</span>
<span class="gi">+        inverse[v].append(k)</span>
<span class="gi">+    # sort so we choose minimum degree nodes first</span>
<span class="gi">+    inverse = {</span>
<span class="gi">+        mu: sorted(mapped, key=lambda u: (G.degree(u), u))</span>
<span class="gi">+        for mu, mapped in inverse.items()</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # For each meta-edge, map back to an arbitrary pair in the original graph</span>
<span class="gi">+    G2 = G.copy()</span>
<span class="gi">+    for mu, mv in aug_tree_edges:</span>
<span class="gi">+        # Find the first available edge that doesn&#39;t exist and return it</span>
<span class="gi">+        for u, v in it.product(inverse[mu], inverse[mv]):</span>
<span class="gi">+            if not G2.has_edge(u, v):</span>
<span class="gi">+                G2.add_edge(u, v)</span>
<span class="gi">+                yield u, v</span>
<span class="gi">+                break</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -648,7 +910,110 @@ def weighted_bridge_augmentation(G, avail, weight=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(weighted_bridge_augmentation(G, avail=avail))
<span class="w"> </span>    [(1, 5), (2, 5), (4, 5)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if weight is None:</span>
<span class="gi">+        weight = &quot;weight&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # If input G is not connected the approximation factor increases to 3</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        H = G.copy()</span>
<span class="gi">+        connectors = list(one_edge_augmentation(H, avail=avail, weight=weight))</span>
<span class="gi">+        H.add_edges_from(connectors)</span>
<span class="gi">+</span>
<span class="gi">+        yield from connectors</span>
<span class="gi">+    else:</span>
<span class="gi">+        connectors = []</span>
<span class="gi">+        H = G</span>
<span class="gi">+</span>
<span class="gi">+    if len(avail) == 0:</span>
<span class="gi">+        if nx.has_bridges(H):</span>
<span class="gi">+            raise nx.NetworkXUnfeasible(&quot;no augmentation possible&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    avail_uv, avail_w = _unpack_available_edges(avail, weight=weight, G=H)</span>
<span class="gi">+</span>
<span class="gi">+    # Collapse input into a metagraph. Meta nodes are bridge-ccs</span>
<span class="gi">+    bridge_ccs = nx.connectivity.bridge_components(H)</span>
<span class="gi">+    C = collapse(H, bridge_ccs)</span>
<span class="gi">+</span>
<span class="gi">+    # Use the meta graph to shrink avail to a small feasible subset</span>
<span class="gi">+    mapping = C.graph[&quot;mapping&quot;]</span>
<span class="gi">+    # Choose the minimum weight feasible edge in each group</span>
<span class="gi">+    meta_to_wuv = {</span>
<span class="gi">+        (mu, mv): (w, uv)</span>
<span class="gi">+        for (mu, mv), uv, w in _lightest_meta_edges(mapping, avail_uv, avail_w)</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # Mapping of terms from (Khuller and Thurimella):</span>
<span class="gi">+    #     C         : G_0 = (V, E^0)</span>
<span class="gi">+    #        This is the metagraph where each node is a 2-edge-cc in G.</span>
<span class="gi">+    #        The edges in C represent bridges in the original graph.</span>
<span class="gi">+    #     (mu, mv)  : E - E^0  # they group both avail and given edges in E</span>
<span class="gi">+    #     T         : \Gamma</span>
<span class="gi">+    #     D         : G^D = (V, E_D)</span>
<span class="gi">+</span>
<span class="gi">+    #     The paper uses ancestor because children point to parents, which is</span>
<span class="gi">+    #     contrary to networkx standards.  So, we actually need to run</span>
<span class="gi">+    #     nx.least_common_ancestor on the reversed Tree.</span>
<span class="gi">+</span>
<span class="gi">+    # Pick an arbitrary leaf from C as the root</span>
<span class="gi">+    try:</span>
<span class="gi">+        root = next(n for n, d in C.degree() if d == 1)</span>
<span class="gi">+    except StopIteration:  # no nodes found with degree == 1</span>
<span class="gi">+        return</span>
<span class="gi">+    # Root C into a tree TR by directing all edges away from the root</span>
<span class="gi">+    # Note in their paper T directs edges towards the root</span>
<span class="gi">+    TR = nx.dfs_tree(C, root)</span>
<span class="gi">+</span>
<span class="gi">+    # Add to D the directed edges of T and set their weight to zero</span>
<span class="gi">+    # This indicates that it costs nothing to use edges that were given.</span>
<span class="gi">+    D = nx.reverse(TR).copy()</span>
<span class="gi">+</span>
<span class="gi">+    nx.set_edge_attributes(D, name=&quot;weight&quot;, values=0)</span>
<span class="gi">+</span>
<span class="gi">+    # The LCA of mu and mv in T is the shared ancestor of mu and mv that is</span>
<span class="gi">+    # located farthest from the root.</span>
<span class="gi">+    lca_gen = nx.tree_all_pairs_lowest_common_ancestor(</span>
<span class="gi">+        TR, root=root, pairs=meta_to_wuv.keys()</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    for (mu, mv), lca in lca_gen:</span>
<span class="gi">+        w, uv = meta_to_wuv[(mu, mv)]</span>
<span class="gi">+        if lca == mu:</span>
<span class="gi">+            # If u is an ancestor of v in TR, then add edge u-&gt;v to D</span>
<span class="gi">+            D.add_edge(lca, mv, weight=w, generator=uv)</span>
<span class="gi">+        elif lca == mv:</span>
<span class="gi">+            # If v is an ancestor of u in TR, then add edge v-&gt;u to D</span>
<span class="gi">+            D.add_edge(lca, mu, weight=w, generator=uv)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If neither u nor v is a ancestor of the other in TR</span>
<span class="gi">+            # let t = lca(TR, u, v) and add edges t-&gt;u and t-&gt;v</span>
<span class="gi">+            # Track the original edge that GENERATED these edges.</span>
<span class="gi">+            D.add_edge(lca, mu, weight=w, generator=uv)</span>
<span class="gi">+            D.add_edge(lca, mv, weight=w, generator=uv)</span>
<span class="gi">+</span>
<span class="gi">+    # Then compute a minimum rooted branching</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Note the original edges must be directed towards to root for the</span>
<span class="gi">+        # branching to give us a bridge-augmentation.</span>
<span class="gi">+        A = _minimum_rooted_branching(D, root)</span>
<span class="gi">+    except nx.NetworkXException as err:</span>
<span class="gi">+        # If there is no branching then augmentation is not possible</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(&quot;no 2-edge-augmentation possible&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    # For each edge e, in the branching that did not belong to the directed</span>
<span class="gi">+    # tree T, add the corresponding edge that **GENERATED** it (this is not</span>
<span class="gi">+    # necessarily e itself!)</span>
<span class="gi">+</span>
<span class="gi">+    # ensure the third case does not generate edges twice</span>
<span class="gi">+    bridge_connectors = set()</span>
<span class="gi">+    for mu, mv in A.edges():</span>
<span class="gi">+        data = D.get_edge_data(mu, mv)</span>
<span class="gi">+        if &quot;generator&quot; in data:</span>
<span class="gi">+            # Add the avail edge that generated the branching edge.</span>
<span class="gi">+            edge = data[&quot;generator&quot;]</span>
<span class="gi">+            bridge_connectors.add(edge)</span>
<span class="gi">+</span>
<span class="gi">+    yield from bridge_connectors</span>


<span class="w"> </span>def _minimum_rooted_branching(D, root):
<span class="gu">@@ -667,7 +1032,12 @@ def _minimum_rooted_branching(D, root):</span>
<span class="w"> </span>    [1] Khuller, Samir (2002) Advanced Algorithms Lecture 24 Notes.
<span class="w"> </span>    https://web.archive.org/web/20121030033722/https://www.cs.umd.edu/class/spring2011/cmsc651/lec07.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rooted = D.copy()</span>
<span class="gi">+    # root the graph by removing all predecessors to `root`.</span>
<span class="gi">+    rooted.remove_edges_from([(u, root) for u in D.predecessors(root)])</span>
<span class="gi">+    # Then compute the branching / arborescence.</span>
<span class="gi">+    A = nx.minimum_spanning_arborescence(rooted)</span>
<span class="gi">+    return A</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -712,7 +1082,34 @@ def collapse(G, grouped_nodes):</span>
<span class="w"> </span>    &gt;&gt;&gt; assert {5, 6, 7} in member_values
<span class="w"> </span>    &gt;&gt;&gt; assert {&quot;A&quot;} in member_values
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mapping = {}</span>
<span class="gi">+    members = {}</span>
<span class="gi">+    C = G.__class__()</span>
<span class="gi">+    i = 0  # required if G is empty</span>
<span class="gi">+    remaining = set(G.nodes())</span>
<span class="gi">+    for i, group in enumerate(grouped_nodes):</span>
<span class="gi">+        group = set(group)</span>
<span class="gi">+        assert remaining.issuperset(</span>
<span class="gi">+            group</span>
<span class="gi">+        ), &quot;grouped nodes must exist in G and be disjoint&quot;</span>
<span class="gi">+        remaining.difference_update(group)</span>
<span class="gi">+        members[i] = group</span>
<span class="gi">+        mapping.update((n, i) for n in group)</span>
<span class="gi">+    # remaining nodes are in their own group</span>
<span class="gi">+    for i, node in enumerate(remaining, start=i + 1):</span>
<span class="gi">+        group = {node}</span>
<span class="gi">+        members[i] = group</span>
<span class="gi">+        mapping.update((n, i) for n in group)</span>
<span class="gi">+    number_of_groups = i + 1</span>
<span class="gi">+    C.add_nodes_from(range(number_of_groups))</span>
<span class="gi">+    C.add_edges_from(</span>
<span class="gi">+        (mapping[u], mapping[v]) for u, v in G.edges() if mapping[u] != mapping[v]</span>
<span class="gi">+    )</span>
<span class="gi">+    # Add a list of members (ie original nodes) to each node (ie scc) in C.</span>
<span class="gi">+    nx.set_node_attributes(C, name=&quot;members&quot;, values=members)</span>
<span class="gi">+    # Add mapping dict as graph attribute</span>
<span class="gi">+    C.graph[&quot;mapping&quot;] = mapping</span>
<span class="gi">+    return C</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -740,16 +1137,26 @@ def complement_edges(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(complement_edges(G))
<span class="w"> </span>    []
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G_adj = G._adj  # Store as a variable to eliminate attribute lookup</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        for u, v in it.combinations(G.nodes(), 2):</span>
<span class="gi">+            if v not in G_adj[u]:</span>
<span class="gi">+                yield (u, v)</span>
<span class="gi">+            if u not in G_adj[v]:</span>
<span class="gi">+                yield (v, u)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u, v in it.combinations(G.nodes(), 2):</span>
<span class="gi">+            if v not in G_adj[u]:</span>
<span class="gi">+                yield (u, v)</span>


<span class="w"> </span>def _compat_shuffle(rng, input):
<span class="w"> </span>    &quot;&quot;&quot;wrapper around rng.shuffle for python 2 compatibility reasons&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    rng.shuffle(input)</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@py_random_state(4)
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def greedy_k_edge_augmentation(G, k, avail=None, weight=None, seed=None):
<span class="gu">@@ -808,4 +1215,55 @@ def greedy_k_edge_augmentation(G, k, avail=None, weight=None, seed=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(greedy_k_edge_augmentation(G, k=4, avail=avail, seed=3))
<span class="w"> </span>    [(1, 3), (1, 5), (1, 6), (2, 4), (2, 6), (3, 7), (4, 7), (5, 7)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Result set</span>
<span class="gi">+    aug_edges = []</span>
<span class="gi">+</span>
<span class="gi">+    done = is_k_edge_connected(G, k)</span>
<span class="gi">+    if done:</span>
<span class="gi">+        return</span>
<span class="gi">+    if avail is None:</span>
<span class="gi">+        # all edges are available</span>
<span class="gi">+        avail_uv = list(complement_edges(G))</span>
<span class="gi">+        avail_w = [1] * len(avail_uv)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Get the unique set of unweighted edges</span>
<span class="gi">+        avail_uv, avail_w = _unpack_available_edges(avail, weight=weight, G=G)</span>
<span class="gi">+</span>
<span class="gi">+    # Greedy: order lightest edges. Use degree sum to tie-break</span>
<span class="gi">+    tiebreaker = [sum(map(G.degree, uv)) for uv in avail_uv]</span>
<span class="gi">+    avail_wduv = sorted(zip(avail_w, tiebreaker, avail_uv))</span>
<span class="gi">+    avail_uv = [uv for w, d, uv in avail_wduv]</span>
<span class="gi">+</span>
<span class="gi">+    # Incrementally add edges in until we are k-connected</span>
<span class="gi">+    H = G.copy()</span>
<span class="gi">+    for u, v in avail_uv:</span>
<span class="gi">+        done = False</span>
<span class="gi">+        if not is_locally_k_edge_connected(H, u, v, k=k):</span>
<span class="gi">+            # Only add edges in parts that are not yet locally k-edge-connected</span>
<span class="gi">+            aug_edges.append((u, v))</span>
<span class="gi">+            H.add_edge(u, v)</span>
<span class="gi">+            # Did adding this edge help?</span>
<span class="gi">+            if H.degree(u) &gt;= k and H.degree(v) &gt;= k:</span>
<span class="gi">+                done = is_k_edge_connected(H, k)</span>
<span class="gi">+        if done:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    # Check for feasibility</span>
<span class="gi">+    if not done:</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(&quot;not able to k-edge-connect with available edges&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Randomized attempt to reduce the size of the solution</span>
<span class="gi">+    _compat_shuffle(seed, aug_edges)</span>
<span class="gi">+    for u, v in list(aug_edges):</span>
<span class="gi">+        # Don&#39;t remove if we know it would break connectivity</span>
<span class="gi">+        if H.degree(u) &lt;= k or H.degree(v) &lt;= k:</span>
<span class="gi">+            continue</span>
<span class="gi">+        H.remove_edge(u, v)</span>
<span class="gi">+        aug_edges.remove((u, v))</span>
<span class="gi">+        if not is_k_edge_connected(H, k=k):</span>
<span class="gi">+            # If removing this edge breaks feasibility, undo</span>
<span class="gi">+            H.add_edge(u, v)</span>
<span class="gi">+            aug_edges.append((u, v))</span>
<span class="gi">+</span>
<span class="gi">+    # Generate results</span>
<span class="gi">+    yield from aug_edges</span>
<span class="gh">diff --git a/networkx/algorithms/connectivity/edge_kcomponents.py b/networkx/algorithms/connectivity/edge_kcomponents.py</span>
<span class="gh">index 35329f643..e071f4d3d 100644</span>
<span class="gd">--- a/networkx/algorithms/connectivity/edge_kcomponents.py</span>
<span class="gi">+++ b/networkx/algorithms/connectivity/edge_kcomponents.py</span>
<span class="gu">@@ -10,13 +10,19 @@ least k.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import itertools as it
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import arbitrary_element, not_implemented_for
<span class="gd">-__all__ = [&#39;k_edge_components&#39;, &#39;k_edge_subgraphs&#39;, &#39;bridge_components&#39;,</span>
<span class="gd">-    &#39;EdgeComponentAuxGraph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;k_edge_components&quot;,</span>
<span class="gi">+    &quot;k_edge_subgraphs&quot;,</span>
<span class="gi">+    &quot;bridge_components&quot;,</span>
<span class="gi">+    &quot;EdgeComponentAuxGraph&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def k_edge_components(G, k):
<span class="w"> </span>    &quot;&quot;&quot;Generates nodes in each maximal k-edge-connected component in G.
<span class="gu">@@ -80,10 +86,27 @@ def k_edge_components(G, k):</span>
<span class="w"> </span>        k-edge-connected components.
<span class="w"> </span>        http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    # Compute k-edge-ccs using the most efficient algorithms available.</span>
<span class="gi">+    if k &lt; 1:</span>
<span class="gi">+        raise ValueError(&quot;k cannot be less than 1&quot;)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        if k == 1:</span>
<span class="gi">+            return nx.strongly_connected_components(G)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # TODO: investigate https://arxiv.org/abs/1412.6466 for k=2</span>
<span class="gi">+            aux_graph = EdgeComponentAuxGraph.construct(G)</span>
<span class="gi">+            return aux_graph.k_edge_components(k)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if k == 1:</span>
<span class="gi">+            return nx.connected_components(G)</span>
<span class="gi">+        elif k == 2:</span>
<span class="gi">+            return bridge_components(G)</span>
<span class="gi">+        else:</span>
<span class="gi">+            aux_graph = EdgeComponentAuxGraph.construct(G)</span>
<span class="gi">+            return aux_graph.k_edge_components(k)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def k_edge_subgraphs(G, k):
<span class="w"> </span>    &quot;&quot;&quot;Generates nodes in each maximal k-edge-connected subgraph in G.
<span class="gu">@@ -144,7 +167,22 @@ def k_edge_subgraphs(G, k):</span>
<span class="w"> </span>        Technology 2012 480-–491.
<span class="w"> </span>        https://openproceedings.org/2012/conf/edbt/ZhouLYLCL12.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if k &lt; 1:</span>
<span class="gi">+        raise ValueError(&quot;k cannot be less than 1&quot;)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        if k &lt;= 1:</span>
<span class="gi">+            # For directed graphs ,</span>
<span class="gi">+            # When k == 1, k-edge-ccs and k-edge-subgraphs are the same</span>
<span class="gi">+            return k_edge_components(G, k)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _k_edge_subgraphs_nodes(G, k)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if k &lt;= 2:</span>
<span class="gi">+            # For undirected graphs,</span>
<span class="gi">+            # when k &lt;= 2, k-edge-ccs and k-edge-subgraphs are the same</span>
<span class="gi">+            return k_edge_components(G, k)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _k_edge_subgraphs_nodes(G, k)</span>


<span class="w"> </span>def _k_edge_subgraphs_nodes(G, k):
<span class="gu">@@ -152,11 +190,12 @@ def _k_edge_subgraphs_nodes(G, k):</span>

<span class="w"> </span>    This allows k_edge_subgraphs to return a generator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for C in general_k_edge_subgraphs(G, k):</span>
<span class="gi">+        yield set(C.nodes())</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def bridge_components(G):
<span class="w"> </span>    &quot;&quot;&quot;Finds all bridge-connected components G.
<span class="gu">@@ -194,11 +233,13 @@ def bridge_components(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(map(sorted, bridge_components(G)))
<span class="w"> </span>    [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    H = G.copy()</span>
<span class="gi">+    H.remove_edges_from(nx.bridges(G))</span>
<span class="gi">+    yield from nx.connected_components(H)</span>


<span class="w"> </span>class EdgeComponentAuxGraph:
<span class="gd">-    &quot;&quot;&quot;A simple algorithm to find all k-edge-connected components in a graph.</span>
<span class="gi">+    r&quot;&quot;&quot;A simple algorithm to find all k-edge-connected components in a graph.</span>

<span class="w"> </span>    Constructing the auxiliary graph (which may take some time) allows for the
<span class="w"> </span>    k-edge-ccs to be found in linear time for arbitrary k.
<span class="gu">@@ -207,7 +248,7 @@ class EdgeComponentAuxGraph:</span>
<span class="w"> </span>    -----
<span class="w"> </span>    This implementation is based on [1]_. The idea is to construct an auxiliary
<span class="w"> </span>    graph from which the k-edge-ccs can be extracted in linear time. The
<span class="gd">-    auxiliary graph is constructed in $O(|V|\\cdot F)$ operations, where F is the</span>
<span class="gi">+    auxiliary graph is constructed in $O(|V|\cdot F)$ operations, where F is the</span>
<span class="w"> </span>    complexity of max flow. Querying the components takes an additional $O(|V|)$
<span class="w"> </span>    operations. This algorithm can be slow for large graphs, but it handles an
<span class="w"> </span>    arbitrary k and works for both directed and undirected inputs.
<span class="gu">@@ -269,6 +310,7 @@ class EdgeComponentAuxGraph:</span>
<span class="w"> </span>    [[1, 4], [2], [3]]
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    # @not_implemented_for(&#39;multigraph&#39;)  # TODO: fix decor for classmethods</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def construct(EdgeComponentAuxGraph, G):
<span class="w"> </span>        &quot;&quot;&quot;Builds an auxiliary graph encoding edge-connectivity between nodes.
<span class="gu">@@ -290,7 +332,52 @@ class EdgeComponentAuxGraph:</span>
<span class="w"> </span>        ----------
<span class="w"> </span>        G : NetworkX graph
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # workaround for classmethod decorator</span>
<span class="gi">+        not_implemented_for(&quot;multigraph&quot;)(lambda G: G)(G)</span>
<span class="gi">+</span>
<span class="gi">+        def _recursive_build(H, A, source, avail):</span>
<span class="gi">+            # Terminate once the flow has been compute to every node.</span>
<span class="gi">+            if {source} == avail:</span>
<span class="gi">+                return</span>
<span class="gi">+            # pick an arbitrary node as the sink</span>
<span class="gi">+            sink = arbitrary_element(avail - {source})</span>
<span class="gi">+            # find the minimum cut and its weight</span>
<span class="gi">+            value, (S, T) = nx.minimum_cut(H, source, sink)</span>
<span class="gi">+            if H.is_directed():</span>
<span class="gi">+                # check if the reverse direction has a smaller cut</span>
<span class="gi">+                value_, (T_, S_) = nx.minimum_cut(H, sink, source)</span>
<span class="gi">+                if value_ &lt; value:</span>
<span class="gi">+                    value, S, T = value_, S_, T_</span>
<span class="gi">+            # add edge with weight of cut to the aux graph</span>
<span class="gi">+            A.add_edge(source, sink, weight=value)</span>
<span class="gi">+            # recursively call until all but one node is used</span>
<span class="gi">+            _recursive_build(H, A, source, avail.intersection(S))</span>
<span class="gi">+            _recursive_build(H, A, sink, avail.intersection(T))</span>
<span class="gi">+</span>
<span class="gi">+        # Copy input to ensure all edges have unit capacity</span>
<span class="gi">+        H = G.__class__()</span>
<span class="gi">+        H.add_nodes_from(G.nodes())</span>
<span class="gi">+        H.add_edges_from(G.edges(), capacity=1)</span>
<span class="gi">+</span>
<span class="gi">+        # A is the auxiliary graph to be constructed</span>
<span class="gi">+        # It is a weighted undirected tree</span>
<span class="gi">+        A = nx.Graph()</span>
<span class="gi">+</span>
<span class="gi">+        # Pick an arbitrary node as the source</span>
<span class="gi">+        if H.number_of_nodes() &gt; 0:</span>
<span class="gi">+            source = arbitrary_element(H.nodes())</span>
<span class="gi">+            # Initialize a set of elements that can be chosen as the sink</span>
<span class="gi">+            avail = set(H.nodes())</span>
<span class="gi">+</span>
<span class="gi">+            # This constructs A</span>
<span class="gi">+            _recursive_build(H, A, source, avail)</span>
<span class="gi">+</span>
<span class="gi">+        # This class is a container the holds the auxiliary graph A and</span>
<span class="gi">+        # provides access the k_edge_components function.</span>
<span class="gi">+        self = EdgeComponentAuxGraph()</span>
<span class="gi">+        self.A = A</span>
<span class="gi">+        self.H = H</span>
<span class="gi">+        return self</span>

<span class="w"> </span>    def k_edge_components(self, k):
<span class="w"> </span>        &quot;&quot;&quot;Queries the auxiliary graph for k-edge-connected components.
<span class="gu">@@ -311,7 +398,19 @@ class EdgeComponentAuxGraph:</span>
<span class="w"> </span>        k from the auxiliary graph.  The resulting connected components are the
<span class="w"> </span>        k-edge-ccs in the original graph.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if k &lt; 1:</span>
<span class="gi">+            raise ValueError(&quot;k cannot be less than 1&quot;)</span>
<span class="gi">+        A = self.A</span>
<span class="gi">+        # &quot;traverse the auxiliary graph A and delete all edges with weights less</span>
<span class="gi">+        # than k&quot;</span>
<span class="gi">+        aux_weights = nx.get_edge_attributes(A, &quot;weight&quot;)</span>
<span class="gi">+        # Create a relevant graph with the auxiliary edges with weights &gt;= k</span>
<span class="gi">+        R = nx.Graph()</span>
<span class="gi">+        R.add_nodes_from(A.nodes())</span>
<span class="gi">+        R.add_edges_from(e for e, w in aux_weights.items() if w &gt;= k)</span>
<span class="gi">+</span>
<span class="gi">+        # Return the nodes that are k-edge-connected in the original graph</span>
<span class="gi">+        yield from nx.connected_components(R)</span>

<span class="w"> </span>    def k_edge_subgraphs(self, k):
<span class="w"> </span>        &quot;&quot;&quot;Queries the auxiliary graph for k-edge-connected subgraphs.
<span class="gu">@@ -334,12 +433,49 @@ class EdgeComponentAuxGraph:</span>
<span class="w"> </span>        But for multiple values of k, it can be faster to build AuxGraph and
<span class="w"> </span>        then use this method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if k &lt; 1:</span>
<span class="gi">+            raise ValueError(&quot;k cannot be less than 1&quot;)</span>
<span class="gi">+        H = self.H</span>
<span class="gi">+        A = self.A</span>
<span class="gi">+        # &quot;traverse the auxiliary graph A and delete all edges with weights less</span>
<span class="gi">+        # than k&quot;</span>
<span class="gi">+        aux_weights = nx.get_edge_attributes(A, &quot;weight&quot;)</span>
<span class="gi">+        # Create a relevant graph with the auxiliary edges with weights &gt;= k</span>
<span class="gi">+        R = nx.Graph()</span>
<span class="gi">+        R.add_nodes_from(A.nodes())</span>
<span class="gi">+        R.add_edges_from(e for e, w in aux_weights.items() if w &gt;= k)</span>
<span class="gi">+</span>
<span class="gi">+        # Return the components whose subgraphs are k-edge-connected</span>
<span class="gi">+        for cc in nx.connected_components(R):</span>
<span class="gi">+            if len(cc) &lt; k:</span>
<span class="gi">+                # Early return optimization</span>
<span class="gi">+                for node in cc:</span>
<span class="gi">+                    yield {node}</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Call subgraph solution to refine the results</span>
<span class="gi">+                C = H.subgraph(cc)</span>
<span class="gi">+                yield from k_edge_subgraphs(C, k)</span>


<span class="w"> </span>def _low_degree_nodes(G, k, nbunch=None):
<span class="w"> </span>    &quot;&quot;&quot;Helper for finding nodes with degree less than k.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Nodes with degree less than k cannot be k-edge-connected.</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        # Consider both in and out degree in the directed case</span>
<span class="gi">+        seen = set()</span>
<span class="gi">+        for node, degree in G.out_degree(nbunch):</span>
<span class="gi">+            if degree &lt; k:</span>
<span class="gi">+                seen.add(node)</span>
<span class="gi">+                yield node</span>
<span class="gi">+        for node, degree in G.in_degree(nbunch):</span>
<span class="gi">+            if node not in seen and degree &lt; k:</span>
<span class="gi">+                seen.add(node)</span>
<span class="gi">+                yield node</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Only the degree matters in the undirected case</span>
<span class="gi">+        for node, degree in G.degree(nbunch):</span>
<span class="gi">+            if degree &lt; k:</span>
<span class="gi">+                yield node</span>


<span class="w"> </span>def _high_degree_components(G, k):
<span class="gu">@@ -348,7 +484,23 @@ def _high_degree_components(G, k):</span>
<span class="w"> </span>    Removes and generates each node with degree less than k.  Then generates
<span class="w"> </span>    remaining components where all nodes have degree at least k.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Iteratively remove parts of the graph that are not k-edge-connected</span>
<span class="gi">+    H = G.copy()</span>
<span class="gi">+    singletons = set(_low_degree_nodes(H, k))</span>
<span class="gi">+    while singletons:</span>
<span class="gi">+        # Only search neighbors of removed nodes</span>
<span class="gi">+        nbunch = set(it.chain.from_iterable(map(H.neighbors, singletons)))</span>
<span class="gi">+        nbunch.difference_update(singletons)</span>
<span class="gi">+        H.remove_nodes_from(singletons)</span>
<span class="gi">+        for node in singletons:</span>
<span class="gi">+            yield {node}</span>
<span class="gi">+        singletons = set(_low_degree_nodes(H, k, nbunch))</span>
<span class="gi">+</span>
<span class="gi">+    # Note: remaining connected components may not be k-edge-connected</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        yield from nx.strongly_connected_components(H)</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield from nx.connected_components(H)</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -405,4 +557,35 @@ def general_k_edge_subgraphs(G, k):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(len(k_sg) for k_sg in k_edge_subgraphs(G, k=3))
<span class="w"> </span>    [1, 1, 1, 4, 4]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if k &lt; 1:</span>
<span class="gi">+        raise ValueError(&quot;k cannot be less than 1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Node pruning optimization (incorporates early return)</span>
<span class="gi">+    # find_ccs is either connected_components/strongly_connected_components</span>
<span class="gi">+    find_ccs = partial(_high_degree_components, k=k)</span>
<span class="gi">+</span>
<span class="gi">+    # Quick return optimization</span>
<span class="gi">+    if G.number_of_nodes() &lt; k:</span>
<span class="gi">+        for node in G.nodes():</span>
<span class="gi">+            yield G.subgraph([node]).copy()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # Intermediate results</span>
<span class="gi">+    R0 = {G.subgraph(cc).copy() for cc in find_ccs(G)}</span>
<span class="gi">+    # Subdivide CCs in the intermediate results until they are k-conn</span>
<span class="gi">+    while R0:</span>
<span class="gi">+        G1 = R0.pop()</span>
<span class="gi">+        if G1.number_of_nodes() == 1:</span>
<span class="gi">+            yield G1</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Find a global minimum cut</span>
<span class="gi">+            cut_edges = nx.minimum_edge_cut(G1)</span>
<span class="gi">+            cut_value = len(cut_edges)</span>
<span class="gi">+            if cut_value &lt; k:</span>
<span class="gi">+                # G1 is not k-edge-connected, so subdivide it</span>
<span class="gi">+                G1.remove_edges_from(cut_edges)</span>
<span class="gi">+                for cc in find_ccs(G1):</span>
<span class="gi">+                    R0.add(G1.subgraph(cc).copy())</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Otherwise we found a k-edge-connected subgraph</span>
<span class="gi">+                yield G1</span>
<span class="gh">diff --git a/networkx/algorithms/connectivity/kcomponents.py b/networkx/algorithms/connectivity/kcomponents.py</span>
<span class="gh">index b08258abf..50d5c8f41 100644</span>
<span class="gd">--- a/networkx/algorithms/connectivity/kcomponents.py</span>
<span class="gi">+++ b/networkx/algorithms/connectivity/kcomponents.py</span>
<span class="gu">@@ -4,17 +4,22 @@ Moody and White algorithm for k-components</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from itertools import combinations
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="gi">+# Define the default maximum flow function.</span>
<span class="w"> </span>from networkx.algorithms.flow import edmonds_karp
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gi">+</span>
<span class="w"> </span>default_flow_func = edmonds_karp
<span class="gd">-__all__ = [&#39;k_components&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;k_components&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def k_components(G, flow_func=None):
<span class="gd">-    &quot;&quot;&quot;Returns the k-component structure of a graph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the k-component structure of a graph G.</span>

<span class="w"> </span>    A `k`-component is a maximal subgraph of a graph G that has, at least,
<span class="w"> </span>    node connectivity `k`: we need to remove at least `k` nodes to break it
<span class="gu">@@ -98,7 +103,56 @@ def k_components(G, flow_func=None):</span>
<span class="w"> </span>            https://arxiv.org/pdf/1503.04476v1

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Dictionary with connectivity level (k) as keys and a list of</span>
<span class="gi">+    # sets of nodes that form a k-component as values. Note that</span>
<span class="gi">+    # k-components can overlap (but only k - 1 nodes).</span>
<span class="gi">+    k_components = defaultdict(list)</span>
<span class="gi">+    # Define default flow function</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+    # Bicomponents as a base to check for higher order k-components</span>
<span class="gi">+    for component in nx.connected_components(G):</span>
<span class="gi">+        # isolated nodes have connectivity 0</span>
<span class="gi">+        comp = set(component)</span>
<span class="gi">+        if len(comp) &gt; 1:</span>
<span class="gi">+            k_components[1].append(comp)</span>
<span class="gi">+    bicomponents = [G.subgraph(c) for c in nx.biconnected_components(G)]</span>
<span class="gi">+    for bicomponent in bicomponents:</span>
<span class="gi">+        bicomp = set(bicomponent)</span>
<span class="gi">+        # avoid considering dyads as bicomponents</span>
<span class="gi">+        if len(bicomp) &gt; 2:</span>
<span class="gi">+            k_components[2].append(bicomp)</span>
<span class="gi">+    for B in bicomponents:</span>
<span class="gi">+        if len(B) &lt;= 2:</span>
<span class="gi">+            continue</span>
<span class="gi">+        k = nx.node_connectivity(B, flow_func=flow_func)</span>
<span class="gi">+        if k &gt; 2:</span>
<span class="gi">+            k_components[k].append(set(B))</span>
<span class="gi">+        # Perform cuts in a DFS like order.</span>
<span class="gi">+        cuts = list(nx.all_node_cuts(B, k=k, flow_func=flow_func))</span>
<span class="gi">+        stack = [(k, _generate_partition(B, cuts, k))]</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            (parent_k, partition) = stack[-1]</span>
<span class="gi">+            try:</span>
<span class="gi">+                nodes = next(partition)</span>
<span class="gi">+                C = B.subgraph(nodes)</span>
<span class="gi">+                this_k = nx.node_connectivity(C, flow_func=flow_func)</span>
<span class="gi">+                if this_k &gt; parent_k and this_k &gt; 2:</span>
<span class="gi">+                    k_components[this_k].append(set(C))</span>
<span class="gi">+                cuts = list(nx.all_node_cuts(C, k=this_k, flow_func=flow_func))</span>
<span class="gi">+                if cuts:</span>
<span class="gi">+                    stack.append((this_k, _generate_partition(C, cuts, this_k)))</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+    # This is necessary because k-components may only be reported at their</span>
<span class="gi">+    # maximum k level. But we want to return a dictionary in which keys are</span>
<span class="gi">+    # connectivity levels and values list of sets of components, without</span>
<span class="gi">+    # skipping any connectivity level. Also, it&#39;s possible that subsets of</span>
<span class="gi">+    # an already detected k-component appear at a level k. Checking for this</span>
<span class="gi">+    # in the while loop above penalizes the common case. Thus we also have to</span>
<span class="gi">+    # _consolidate all connectivity levels in _reconstruct_k_components.</span>
<span class="gi">+    return _reconstruct_k_components(k_components)</span>


<span class="w"> </span>def _consolidate(sets, k):
<span class="gu">@@ -113,4 +167,56 @@ def _consolidate(sets, k):</span>
<span class="w"> </span>    is no licence for the code.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    nodes = dict(enumerate(sets))</span>
<span class="gi">+    G.add_nodes_from(nodes)</span>
<span class="gi">+    G.add_edges_from(</span>
<span class="gi">+        (u, v) for u, v in combinations(nodes, 2) if len(nodes[u] &amp; nodes[v]) &gt;= k</span>
<span class="gi">+    )</span>
<span class="gi">+    for component in nx.connected_components(G):</span>
<span class="gi">+        yield set.union(*[nodes[n] for n in component])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _generate_partition(G, cuts, k):</span>
<span class="gi">+    def has_nbrs_in_partition(G, node, partition):</span>
<span class="gi">+        return any(n in partition for n in G[node])</span>
<span class="gi">+</span>
<span class="gi">+    components = []</span>
<span class="gi">+    nodes = {n for n, d in G.degree() if d &gt; k} - {n for cut in cuts for n in cut}</span>
<span class="gi">+    H = G.subgraph(nodes)</span>
<span class="gi">+    for cc in nx.connected_components(H):</span>
<span class="gi">+        component = set(cc)</span>
<span class="gi">+        for cut in cuts:</span>
<span class="gi">+            for node in cut:</span>
<span class="gi">+                if has_nbrs_in_partition(G, node, cc):</span>
<span class="gi">+                    component.add(node)</span>
<span class="gi">+        if len(component) &lt; G.order():</span>
<span class="gi">+            components.append(component)</span>
<span class="gi">+    yield from _consolidate(components, k + 1)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _reconstruct_k_components(k_comps):</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    max_k = max(k_comps)</span>
<span class="gi">+    for k in reversed(range(1, max_k + 1)):</span>
<span class="gi">+        if k == max_k:</span>
<span class="gi">+            result[k] = list(_consolidate(k_comps[k], k))</span>
<span class="gi">+        elif k not in k_comps:</span>
<span class="gi">+            result[k] = list(_consolidate(result[k + 1], k))</span>
<span class="gi">+        else:</span>
<span class="gi">+            nodes_at_k = set.union(*k_comps[k])</span>
<span class="gi">+            to_add = [c for c in result[k + 1] if any(n not in nodes_at_k for n in c)]</span>
<span class="gi">+            if to_add:</span>
<span class="gi">+                result[k] = list(_consolidate(k_comps[k] + to_add, k))</span>
<span class="gi">+            else:</span>
<span class="gi">+                result[k] = list(_consolidate(k_comps[k], k))</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def build_k_number_dict(kcomps):</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for k, comps in sorted(kcomps.items(), key=itemgetter(0)):</span>
<span class="gi">+        for comp in comps:</span>
<span class="gi">+            for node in comp:</span>
<span class="gi">+                result[node] = k</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/networkx/algorithms/connectivity/kcutsets.py b/networkx/algorithms/connectivity/kcutsets.py</span>
<span class="gh">index 3163b3093..53f8d3b8f 100644</span>
<span class="gd">--- a/networkx/algorithms/connectivity/kcutsets.py</span>
<span class="gi">+++ b/networkx/algorithms/connectivity/kcutsets.py</span>
<span class="gu">@@ -5,16 +5,25 @@ import copy</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from itertools import combinations
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.algorithms.flow import build_residual_network, edmonds_karp, shortest_augmenting_path</span>
<span class="gi">+from networkx.algorithms.flow import (</span>
<span class="gi">+    build_residual_network,</span>
<span class="gi">+    edmonds_karp,</span>
<span class="gi">+    shortest_augmenting_path,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from .utils import build_auxiliary_node_connectivity
<span class="gi">+</span>
<span class="w"> </span>default_flow_func = edmonds_karp
<span class="gd">-__all__ = [&#39;all_node_cuts&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;all_node_cuts&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def all_node_cuts(G, k=None, flow_func=None):
<span class="gd">-    &quot;&quot;&quot;Returns all minimum k cutsets of an undirected graph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns all minimum k cutsets of an undirected graph G.</span>

<span class="w"> </span>    This implementation is based on Kanevsky&#39;s algorithm [1]_ for finding all
<span class="w"> </span>    minimum-size node cut-sets of an undirected graph G; ie the set (or sets)
<span class="gu">@@ -79,9 +88,147 @@ def all_node_cuts(G, k=None, flow_func=None):</span>
<span class="w"> </span>            http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Input graph is disconnected.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Address some corner cases first.</span>
<span class="gi">+    # For complete Graphs</span>
<span class="gi">+</span>
<span class="gi">+    if nx.density(G) == 1:</span>
<span class="gi">+        yield from ()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize data structures.</span>
<span class="gi">+    # Keep track of the cuts already computed so we do not repeat them.</span>
<span class="gi">+    seen = []</span>
<span class="gi">+    # Even-Tarjan reduction is what we call auxiliary digraph</span>
<span class="gi">+    # for node connectivity.</span>
<span class="gi">+    H = build_auxiliary_node_connectivity(G)</span>
<span class="gi">+    H_nodes = H.nodes  # for speed</span>
<span class="gi">+    mapping = H.graph[&quot;mapping&quot;]</span>
<span class="gi">+    # Keep a copy of original predecessors, H will be modified later.</span>
<span class="gi">+    # Shallow copy is enough.</span>
<span class="gi">+    original_H_pred = copy.copy(H._pred)</span>
<span class="gi">+    R = build_residual_network(H, &quot;capacity&quot;)</span>
<span class="gi">+    kwargs = {&quot;capacity&quot;: &quot;capacity&quot;, &quot;residual&quot;: R}</span>
<span class="gi">+    # Define default flow function</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+    if flow_func is shortest_augmenting_path:</span>
<span class="gi">+        kwargs[&quot;two_phase&quot;] = True</span>
<span class="gi">+    # Begin the actual algorithm</span>
<span class="gi">+    # step 1: Find node connectivity k of G</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        k = nx.node_connectivity(G, flow_func=flow_func)</span>
<span class="gi">+    # step 2:</span>
<span class="gi">+    # Find k nodes with top degree, call it X:</span>
<span class="gi">+    X = {n for n, d in sorted(G.degree(), key=itemgetter(1), reverse=True)[:k]}</span>
<span class="gi">+    # Check if X is a k-node-cutset</span>
<span class="gi">+    if _is_separating_set(G, X):</span>
<span class="gi">+        seen.append(X)</span>
<span class="gi">+        yield X</span>
<span class="gi">+</span>
<span class="gi">+    for x in X:</span>
<span class="gi">+        # step 3: Compute local connectivity flow of x with all other</span>
<span class="gi">+        # non adjacent nodes in G</span>
<span class="gi">+        non_adjacent = set(G) - {x} - set(G[x])</span>
<span class="gi">+        for v in non_adjacent:</span>
<span class="gi">+            # step 4: compute maximum flow in an Even-Tarjan reduction H of G</span>
<span class="gi">+            # and step 5: build the associated residual network R</span>
<span class="gi">+            R = flow_func(H, f&quot;{mapping[x]}B&quot;, f&quot;{mapping[v]}A&quot;, **kwargs)</span>
<span class="gi">+            flow_value = R.graph[&quot;flow_value&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            if flow_value == k:</span>
<span class="gi">+                # Find the nodes incident to the flow.</span>
<span class="gi">+                E1 = flowed_edges = [</span>
<span class="gi">+                    (u, w) for (u, w, d) in R.edges(data=True) if d[&quot;flow&quot;] != 0</span>
<span class="gi">+                ]</span>
<span class="gi">+                VE1 = incident_nodes = {n for edge in E1 for n in edge}</span>
<span class="gi">+                # Remove saturated edges form the residual network.</span>
<span class="gi">+                # Note that reversed edges are introduced with capacity 0</span>
<span class="gi">+                # in the residual graph and they need to be removed too.</span>
<span class="gi">+                saturated_edges = [</span>
<span class="gi">+                    (u, w, d)</span>
<span class="gi">+                    for (u, w, d) in R.edges(data=True)</span>
<span class="gi">+                    if d[&quot;capacity&quot;] == d[&quot;flow&quot;] or d[&quot;capacity&quot;] == 0</span>
<span class="gi">+                ]</span>
<span class="gi">+                R.remove_edges_from(saturated_edges)</span>
<span class="gi">+                R_closure = nx.transitive_closure(R)</span>
<span class="gi">+                # step 6: shrink the strongly connected components of</span>
<span class="gi">+                # residual flow network R and call it L.</span>
<span class="gi">+                L = nx.condensation(R)</span>
<span class="gi">+                cmap = L.graph[&quot;mapping&quot;]</span>
<span class="gi">+                inv_cmap = defaultdict(list)</span>
<span class="gi">+                for n, scc in cmap.items():</span>
<span class="gi">+                    inv_cmap[scc].append(n)</span>
<span class="gi">+                # Find the incident nodes in the condensed graph.</span>
<span class="gi">+                VE1 = {cmap[n] for n in VE1}</span>
<span class="gi">+                # step 7: Compute all antichains of L;</span>
<span class="gi">+                # they map to closed sets in H.</span>
<span class="gi">+                # Any edge in H that links a closed set is part of a cutset.</span>
<span class="gi">+                for antichain in nx.antichains(L):</span>
<span class="gi">+                    # Only antichains that are subsets of incident nodes counts.</span>
<span class="gi">+                    # Lemma 8 in reference.</span>
<span class="gi">+                    if not set(antichain).issubset(VE1):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    # Nodes in an antichain of the condensation graph of</span>
<span class="gi">+                    # the residual network map to a closed set of nodes that</span>
<span class="gi">+                    # define a node partition of the auxiliary digraph H</span>
<span class="gi">+                    # through taking all of antichain&#39;s predecessors in the</span>
<span class="gi">+                    # transitive closure.</span>
<span class="gi">+                    S = set()</span>
<span class="gi">+                    for scc in antichain:</span>
<span class="gi">+                        S.update(inv_cmap[scc])</span>
<span class="gi">+                    S_ancestors = set()</span>
<span class="gi">+                    for n in S:</span>
<span class="gi">+                        S_ancestors.update(R_closure._pred[n])</span>
<span class="gi">+                    S.update(S_ancestors)</span>
<span class="gi">+                    if f&quot;{mapping[x]}B&quot; not in S or f&quot;{mapping[v]}A&quot; in S:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    # Find the cutset that links the node partition (S,~S) in H</span>
<span class="gi">+                    cutset = set()</span>
<span class="gi">+                    for u in S:</span>
<span class="gi">+                        cutset.update((u, w) for w in original_H_pred[u] if w not in S)</span>
<span class="gi">+                    # The edges in H that form the cutset are internal edges</span>
<span class="gi">+                    # (ie edges that represent a node of the original graph G)</span>
<span class="gi">+                    if any(H_nodes[u][&quot;id&quot;] != H_nodes[w][&quot;id&quot;] for u, w in cutset):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    node_cut = {H_nodes[u][&quot;id&quot;] for u, _ in cutset}</span>
<span class="gi">+</span>
<span class="gi">+                    if len(node_cut) == k:</span>
<span class="gi">+                        # The cut is invalid if it includes internal edges of</span>
<span class="gi">+                        # end nodes. The other half of Lemma 8 in ref.</span>
<span class="gi">+                        if x in node_cut or v in node_cut:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        if node_cut not in seen:</span>
<span class="gi">+                            yield node_cut</span>
<span class="gi">+                            seen.append(node_cut)</span>
<span class="gi">+</span>
<span class="gi">+                # Add an edge (x, v) to make sure that we do not</span>
<span class="gi">+                # find this cutset again. This is equivalent</span>
<span class="gi">+                # of adding the edge in the input graph</span>
<span class="gi">+                # G.add_edge(x, v) and then regenerate H and R:</span>
<span class="gi">+                # Add edges to the auxiliary digraph.</span>
<span class="gi">+                # See build_residual_network for convention we used</span>
<span class="gi">+                # in residual graphs.</span>
<span class="gi">+                H.add_edge(f&quot;{mapping[x]}B&quot;, f&quot;{mapping[v]}A&quot;, capacity=1)</span>
<span class="gi">+                H.add_edge(f&quot;{mapping[v]}B&quot;, f&quot;{mapping[x]}A&quot;, capacity=1)</span>
<span class="gi">+                # Add edges to the residual network.</span>
<span class="gi">+                R.add_edge(f&quot;{mapping[x]}B&quot;, f&quot;{mapping[v]}A&quot;, capacity=1)</span>
<span class="gi">+                R.add_edge(f&quot;{mapping[v]}A&quot;, f&quot;{mapping[x]}B&quot;, capacity=0)</span>
<span class="gi">+                R.add_edge(f&quot;{mapping[v]}B&quot;, f&quot;{mapping[x]}A&quot;, capacity=1)</span>
<span class="gi">+                R.add_edge(f&quot;{mapping[x]}A&quot;, f&quot;{mapping[v]}B&quot;, capacity=0)</span>
<span class="gi">+</span>
<span class="gi">+                # Add again the saturated edges to reuse the residual network</span>
<span class="gi">+                R.add_edges_from(saturated_edges)</span>


<span class="w"> </span>def _is_separating_set(G, cut):
<span class="w"> </span>    &quot;&quot;&quot;Assumes that the input graph is connected&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(cut) == len(G) - 1:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    H = nx.restricted_view(G, cut, [])</span>
<span class="gi">+    if nx.is_connected(H):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>
<span class="gh">diff --git a/networkx/algorithms/connectivity/stoerwagner.py b/networkx/algorithms/connectivity/stoerwagner.py</span>
<span class="gh">index 2e4999cd0..f6814b003 100644</span>
<span class="gd">--- a/networkx/algorithms/connectivity/stoerwagner.py</span>
<span class="gi">+++ b/networkx/algorithms/connectivity/stoerwagner.py</span>
<span class="gu">@@ -2,16 +2,19 @@</span>
<span class="w"> </span>Stoer-Wagner minimum cut algorithm.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from itertools import islice
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from ...utils import BinaryHeap, arbitrary_element, not_implemented_for
<span class="gd">-__all__ = [&#39;stoer_wagner&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;stoer_wagner&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def stoer_wagner(G, weight=&#39;weight&#39;, heap=BinaryHeap):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the weighted minimum edge cut using the Stoer-Wagner algorithm.</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def stoer_wagner(G, weight=&quot;weight&quot;, heap=BinaryHeap):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the weighted minimum edge cut using the Stoer-Wagner algorithm.</span>

<span class="w"> </span>    Determine the minimum edge cut of a connected graph using the
<span class="w"> </span>    Stoer-Wagner algorithm. In weighted cases, all weights must be
<span class="gu">@@ -22,9 +25,9 @@ def stoer_wagner(G, weight=&#39;weight&#39;, heap=BinaryHeap):</span>
<span class="w"> </span>    ============== =============================================
<span class="w"> </span>    Type of heap   Running time
<span class="w"> </span>    ============== =============================================
<span class="gd">-    Binary heap    $O(n (m + n) \\log n)$</span>
<span class="gd">-    Fibonacci heap $O(nm + n^2 \\log n)$</span>
<span class="gd">-    Pairing heap   $O(2^{2 \\sqrt{\\log \\log n}} nm + n^2 \\log n)$</span>
<span class="gi">+    Binary heap    $O(n (m + n) \log n)$</span>
<span class="gi">+    Fibonacci heap $O(nm + n^2 \log n)$</span>
<span class="gi">+    Pairing heap   $O(2^{2 \sqrt{\log \log n}} nm + n^2 \log n)$</span>
<span class="w"> </span>    ============== =============================================

<span class="w"> </span>    Parameters
<span class="gu">@@ -81,4 +84,68 @@ def stoer_wagner(G, weight=&#39;weight&#39;, heap=BinaryHeap):</span>
<span class="w"> </span>    &gt;&gt;&gt; cut_value
<span class="w"> </span>    4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    if n &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph has less than two nodes.&quot;)</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph is not connected.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Make a copy of the graph for internal use.</span>
<span class="gi">+    G = nx.Graph(</span>
<span class="gi">+        (u, v, {&quot;weight&quot;: e.get(weight, 1)}) for u, v, e in G.edges(data=True) if u != v</span>
<span class="gi">+    )</span>
<span class="gi">+    G.__networkx_cache__ = None  # Disable caching</span>
<span class="gi">+</span>
<span class="gi">+    for u, v, e in G.edges(data=True):</span>
<span class="gi">+        if e[&quot;weight&quot;] &lt; 0:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;graph has a negative-weighted edge.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    cut_value = float(&quot;inf&quot;)</span>
<span class="gi">+    nodes = set(G)</span>
<span class="gi">+    contractions = []  # contracted node pairs</span>
<span class="gi">+</span>
<span class="gi">+    # Repeatedly pick a pair of nodes to contract until only one node is left.</span>
<span class="gi">+    for i in range(n - 1):</span>
<span class="gi">+        # Pick an arbitrary node u and create a set A = {u}.</span>
<span class="gi">+        u = arbitrary_element(G)</span>
<span class="gi">+        A = {u}</span>
<span class="gi">+        # Repeatedly pick the node &quot;most tightly connected&quot; to A and add it to</span>
<span class="gi">+        # A. The tightness of connectivity of a node not in A is defined by the</span>
<span class="gi">+        # of edges connecting it to nodes in A.</span>
<span class="gi">+        h = heap()  # min-heap emulating a max-heap</span>
<span class="gi">+        for v, e in G[u].items():</span>
<span class="gi">+            h.insert(v, -e[&quot;weight&quot;])</span>
<span class="gi">+        # Repeat until all but one node has been added to A.</span>
<span class="gi">+        for j in range(n - i - 2):</span>
<span class="gi">+            u = h.pop()[0]</span>
<span class="gi">+            A.add(u)</span>
<span class="gi">+            for v, e in G[u].items():</span>
<span class="gi">+                if v not in A:</span>
<span class="gi">+                    h.insert(v, h.get(v, 0) - e[&quot;weight&quot;])</span>
<span class="gi">+        # A and the remaining node v define a &quot;cut of the phase&quot;. There is a</span>
<span class="gi">+        # minimum cut of the original graph that is also a cut of the phase.</span>
<span class="gi">+        # Due to contractions in earlier phases, v may in fact represent</span>
<span class="gi">+        # multiple nodes in the original graph.</span>
<span class="gi">+        v, w = h.min()</span>
<span class="gi">+        w = -w</span>
<span class="gi">+        if w &lt; cut_value:</span>
<span class="gi">+            cut_value = w</span>
<span class="gi">+            best_phase = i</span>
<span class="gi">+        # Contract v and the last node added to A.</span>
<span class="gi">+        contractions.append((u, v))</span>
<span class="gi">+        for w, e in G[v].items():</span>
<span class="gi">+            if w != u:</span>
<span class="gi">+                if w not in G[u]:</span>
<span class="gi">+                    G.add_edge(u, w, weight=e[&quot;weight&quot;])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    G[u][w][&quot;weight&quot;] += e[&quot;weight&quot;]</span>
<span class="gi">+        G.remove_node(v)</span>
<span class="gi">+</span>
<span class="gi">+    # Recover the optimal partitioning from the contractions.</span>
<span class="gi">+    G = nx.Graph(islice(contractions, best_phase))</span>
<span class="gi">+    v = contractions[best_phase][1]</span>
<span class="gi">+    G.add_node(v)</span>
<span class="gi">+    reachable = set(nx.single_source_shortest_path_length(G, v))</span>
<span class="gi">+    partition = (list(reachable), list(nodes - reachable))</span>
<span class="gi">+</span>
<span class="gi">+    return cut_value, partition</span>
<span class="gh">diff --git a/networkx/algorithms/connectivity/utils.py b/networkx/algorithms/connectivity/utils.py</span>
<span class="gh">index 1c3f15d8f..a4d822ae5 100644</span>
<span class="gd">--- a/networkx/algorithms/connectivity/utils.py</span>
<span class="gi">+++ b/networkx/algorithms/connectivity/utils.py</span>
<span class="gu">@@ -2,13 +2,13 @@</span>
<span class="w"> </span>Utilities for connectivity package
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;build_auxiliary_node_connectivity&#39;,</span>
<span class="gd">-    &#39;build_auxiliary_edge_connectivity&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;build_auxiliary_node_connectivity&quot;, &quot;build_auxiliary_edge_connectivity&quot;]</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def build_auxiliary_node_connectivity(G):
<span class="gd">-    &quot;&quot;&quot;Creates a directed graph D from an undirected graph G to compute flow</span>
<span class="gi">+    r&quot;&quot;&quot;Creates a directed graph D from an undirected graph G to compute flow</span>
<span class="w"> </span>    based node connectivity.

<span class="w"> </span>    For an undirected graph G having `n` nodes and `m` edges we derive a
<span class="gu">@@ -36,7 +36,27 @@ def build_auxiliary_node_connectivity(G):</span>
<span class="w"> </span>        https://doi.org/10.1007/978-3-540-31955-9_7

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+</span>
<span class="gi">+    mapping = {}</span>
<span class="gi">+    H = nx.DiGraph()</span>
<span class="gi">+</span>
<span class="gi">+    for i, node in enumerate(G):</span>
<span class="gi">+        mapping[node] = i</span>
<span class="gi">+        H.add_node(f&quot;{i}A&quot;, id=node)</span>
<span class="gi">+        H.add_node(f&quot;{i}B&quot;, id=node)</span>
<span class="gi">+        H.add_edge(f&quot;{i}A&quot;, f&quot;{i}B&quot;, capacity=1)</span>
<span class="gi">+</span>
<span class="gi">+    edges = []</span>
<span class="gi">+    for source, target in G.edges():</span>
<span class="gi">+        edges.append((f&quot;{mapping[source]}B&quot;, f&quot;{mapping[target]}A&quot;))</span>
<span class="gi">+        if not directed:</span>
<span class="gi">+            edges.append((f&quot;{mapping[target]}B&quot;, f&quot;{mapping[source]}A&quot;))</span>
<span class="gi">+    H.add_edges_from(edges, capacity=1)</span>
<span class="gi">+</span>
<span class="gi">+    # Store mapping as graph attribute</span>
<span class="gi">+    H.graph[&quot;mapping&quot;] = mapping</span>
<span class="gi">+    return H</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -54,4 +74,14 @@ def build_auxiliary_edge_connectivity(G):</span>
<span class="w"> </span>        chapter, look for the reference of the book).
<span class="w"> </span>        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        H = nx.DiGraph()</span>
<span class="gi">+        H.add_nodes_from(G.nodes())</span>
<span class="gi">+        H.add_edges_from(G.edges(), capacity=1)</span>
<span class="gi">+        return H</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = nx.DiGraph()</span>
<span class="gi">+        H.add_nodes_from(G.nodes())</span>
<span class="gi">+        for source, target in G.edges():</span>
<span class="gi">+            H.add_edges_from([(source, target), (target, source)], capacity=1)</span>
<span class="gi">+        return H</span>
<span class="gh">diff --git a/networkx/algorithms/core.py b/networkx/algorithms/core.py</span>
<span class="gh">index 2c68fec5b..511e6d9d0 100644</span>
<span class="gd">--- a/networkx/algorithms/core.py</span>
<span class="gi">+++ b/networkx/algorithms/core.py</span>
<span class="gu">@@ -21,18 +21,27 @@ D-cores: Measuring Collaboration of Directed Graphs Based on Degeneracy</span>
<span class="w"> </span>Christos Giatsidis, Dimitrios M. Thilikos, Michalis Vazirgiannis, ICDM 2011.
<span class="w"> </span>http://www.graphdegeneracy.org/dcores_ICDM_2011.pdf

<span class="gd">-Multi-scale structure and topological anomaly detection via a new network statistic: The onion decomposition</span>
<span class="gi">+Multi-scale structure and topological anomaly detection via a new network \</span>
<span class="gi">+statistic: The onion decomposition</span>
<span class="w"> </span>L. Hébert-Dufresne, J. A. Grochow, and A. Allard
<span class="w"> </span>Scientific Reports 6, 31708 (2016)
<span class="w"> </span>http://doi.org/10.1038/srep31708

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;core_number&#39;, &#39;k_core&#39;, &#39;k_shell&#39;, &#39;k_crust&#39;, &#39;k_corona&#39;,</span>
<span class="gd">-    &#39;k_truss&#39;, &#39;onion_layers&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;core_number&quot;,</span>
<span class="gi">+    &quot;k_core&quot;,</span>
<span class="gi">+    &quot;k_shell&quot;,</span>
<span class="gi">+    &quot;k_crust&quot;,</span>
<span class="gi">+    &quot;k_corona&quot;,</span>
<span class="gi">+    &quot;k_truss&quot;,</span>
<span class="gi">+    &quot;onion_layers&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@nx.utils.not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def core_number(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the core number for each node.
<span class="gu">@@ -79,7 +88,37 @@ def core_number(G):</span>
<span class="w"> </span>       Vladimir Batagelj and Matjaz Zaversnik, 2003.
<span class="w"> </span>       https://arxiv.org/abs/cs.DS/0310049
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nx.number_of_selfloops(G) &gt; 0:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Input graph has self loops which is not permitted; &quot;</span>
<span class="gi">+            &quot;Consider using G.remove_edges_from(nx.selfloop_edges(G)).&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise nx.NetworkXNotImplemented(msg)</span>
<span class="gi">+    degrees = dict(G.degree())</span>
<span class="gi">+    # Sort nodes by degree.</span>
<span class="gi">+    nodes = sorted(degrees, key=degrees.get)</span>
<span class="gi">+    bin_boundaries = [0]</span>
<span class="gi">+    curr_degree = 0</span>
<span class="gi">+    for i, v in enumerate(nodes):</span>
<span class="gi">+        if degrees[v] &gt; curr_degree:</span>
<span class="gi">+            bin_boundaries.extend([i] * (degrees[v] - curr_degree))</span>
<span class="gi">+            curr_degree = degrees[v]</span>
<span class="gi">+    node_pos = {v: pos for pos, v in enumerate(nodes)}</span>
<span class="gi">+    # The initial guess for the core number of a node is its degree.</span>
<span class="gi">+    core = degrees</span>
<span class="gi">+    nbrs = {v: list(nx.all_neighbors(G, v)) for v in G}</span>
<span class="gi">+    for v in nodes:</span>
<span class="gi">+        for u in nbrs[v]:</span>
<span class="gi">+            if core[u] &gt; core[v]:</span>
<span class="gi">+                nbrs[u].remove(v)</span>
<span class="gi">+                pos = node_pos[u]</span>
<span class="gi">+                bin_start = bin_boundaries[core[u]]</span>
<span class="gi">+                node_pos[u] = bin_start</span>
<span class="gi">+                node_pos[nodes[bin_start]] = pos</span>
<span class="gi">+                nodes[bin_start], nodes[pos] = nodes[pos], nodes[bin_start]</span>
<span class="gi">+                bin_boundaries[core[u]] += 1</span>
<span class="gi">+                core[u] -= 1</span>
<span class="gi">+    return core</span>


<span class="w"> </span>def _core_subgraph(G, k_filter, k=None, core=None):
<span class="gu">@@ -101,7 +140,12 @@ def _core_subgraph(G, k_filter, k=None, core=None):</span>
<span class="w"> </span>      If not specified, the core numbers will be computed from `G`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if core is None:</span>
<span class="gi">+        core = core_number(G)</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        k = max(core.values())</span>
<span class="gi">+    nodes = (v for v in core if k_filter(v, k, core))</span>
<span class="gi">+    return G.subgraph(nodes).copy()</span>


<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gu">@@ -160,7 +204,24 @@ def k_core(G, k=None, core_number=None):</span>
<span class="w"> </span>       Vladimir Batagelj and Matjaz Zaversnik,  2003.
<span class="w"> </span>       https://arxiv.org/abs/cs.DS/0310049
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;\n\n`k_core` will not accept `MultiGraph` objects in version 3.5.\n&quot;</span>
<span class="gi">+                &quot;Convert it to an undirected graph instead, using::\n\n&quot;</span>
<span class="gi">+                &quot;\tG = nx.Graph(G)\n&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            category=DeprecationWarning,</span>
<span class="gi">+            stacklevel=5,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def k_filter(v, k, c):</span>
<span class="gi">+        return c[v] &gt;= k</span>
<span class="gi">+</span>
<span class="gi">+    return _core_subgraph(G, k_filter, k, core_number)</span>


<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gu">@@ -225,7 +286,24 @@ def k_shell(G, k=None, core_number=None):</span>
<span class="w"> </span>       and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154
<span class="w"> </span>       http://www.pnas.org/content/104/27/11150.full
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;\n\n`k_shell` will not accept `MultiGraph` objects in version 3.5.\n&quot;</span>
<span class="gi">+                &quot;Convert it to an undirected graph instead, using::\n\n&quot;</span>
<span class="gi">+                &quot;\tG = nx.Graph(G)\n&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            category=DeprecationWarning,</span>
<span class="gi">+            stacklevel=5,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def k_filter(v, k, c):</span>
<span class="gi">+        return c[v] == k</span>
<span class="gi">+</span>
<span class="gi">+    return _core_subgraph(G, k_filter, k, core_number)</span>


<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gu">@@ -287,7 +365,28 @@ def k_crust(G, k=None, core_number=None):</span>
<span class="w"> </span>       and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154
<span class="w"> </span>       http://www.pnas.org/content/104/27/11150.full
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;\n\n`k_crust` will not accept `MultiGraph` objects in version 3.5.\n&quot;</span>
<span class="gi">+                &quot;Convert it to an undirected graph instead, using::\n\n&quot;</span>
<span class="gi">+                &quot;\tG = nx.Graph(G)\n&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            category=DeprecationWarning,</span>
<span class="gi">+            stacklevel=5,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Default for k is one less than in _core_subgraph, so just inline.</span>
<span class="gi">+    #    Filter is c[v] &lt;= k</span>
<span class="gi">+    if core_number is None:</span>
<span class="gi">+        core_number = nx.core_number(G)</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        k = max(core_number.values()) - 1</span>
<span class="gi">+    nodes = (v for v in core_number if core_number[v] &lt;= k)</span>
<span class="gi">+    return G.subgraph(nodes).copy()</span>


<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gu">@@ -347,11 +446,28 @@ def k_corona(G, k, core_number=None):</span>
<span class="w"> </span>       Phys. Rev. E 73, 056101 (2006)
<span class="w"> </span>       http://link.aps.org/doi/10.1103/PhysRevE.73.056101
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;\n\n`k_corona` will not accept `MultiGraph` objects in version 3.5.\n&quot;</span>
<span class="gi">+                &quot;Convert it to an undirected graph instead, using::\n\n&quot;</span>
<span class="gi">+                &quot;\tG = nx.Graph(G)\n&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            category=DeprecationWarning,</span>
<span class="gi">+            stacklevel=5,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def func(v, k, c):</span>
<span class="gi">+        return c[v] == k and k == sum(1 for w in G[v] if c[w] &gt;= k)</span>

<span class="gd">-@nx.utils.not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx.utils.not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    return _core_subgraph(G, func, k, core_number)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="w"> </span>def k_truss(G, k):
<span class="w"> </span>    &quot;&quot;&quot;Returns the k-truss of `G`.
<span class="gu">@@ -404,11 +520,36 @@ def k_truss(G, k):</span>
<span class="w"> </span>    .. [2] Trusses: Cohesive Subgraphs for Social Network Analysis. Jonathan
<span class="w"> </span>       Cohen, 2005.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx.utils.not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx.utils.not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    if nx.number_of_selfloops(G) &gt; 0:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Input graph has self loops which is not permitted; &quot;</span>
<span class="gi">+            &quot;Consider using G.remove_edges_from(nx.selfloop_edges(G)).&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise nx.NetworkXNotImplemented(msg)</span>
<span class="gi">+</span>
<span class="gi">+    H = G.copy()</span>
<span class="gi">+</span>
<span class="gi">+    n_dropped = 1</span>
<span class="gi">+    while n_dropped &gt; 0:</span>
<span class="gi">+        n_dropped = 0</span>
<span class="gi">+        to_drop = []</span>
<span class="gi">+        seen = set()</span>
<span class="gi">+        for u in H:</span>
<span class="gi">+            nbrs_u = set(H[u])</span>
<span class="gi">+            seen.add(u)</span>
<span class="gi">+            new_nbrs = [v for v in nbrs_u if v not in seen]</span>
<span class="gi">+            for v in new_nbrs:</span>
<span class="gi">+                if len(nbrs_u &amp; set(H[v])) &lt; (k - 2):</span>
<span class="gi">+                    to_drop.append((u, v))</span>
<span class="gi">+        H.remove_edges_from(to_drop)</span>
<span class="gi">+        n_dropped = len(to_drop)</span>
<span class="gi">+        H.remove_nodes_from(list(nx.isolates(H)))</span>
<span class="gi">+</span>
<span class="gi">+    return H</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def onion_layers(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the layer of each vertex in an onion decomposition of the graph.
<span class="gu">@@ -458,4 +599,50 @@ def onion_layers(G):</span>
<span class="w"> </span>       Physical Review X 9, 011023 (2019)
<span class="w"> </span>       http://doi.org/10.1103/PhysRevX.9.011023
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nx.number_of_selfloops(G) &gt; 0:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Input graph contains self loops which is not permitted; &quot;</span>
<span class="gi">+            &quot;Consider using G.remove_edges_from(nx.selfloop_edges(G)).&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise nx.NetworkXNotImplemented(msg)</span>
<span class="gi">+    # Dictionaries to register the k-core/onion decompositions.</span>
<span class="gi">+    od_layers = {}</span>
<span class="gi">+    # Adjacency list</span>
<span class="gi">+    neighbors = {v: list(nx.all_neighbors(G, v)) for v in G}</span>
<span class="gi">+    # Effective degree of nodes.</span>
<span class="gi">+    degrees = dict(G.degree())</span>
<span class="gi">+    # Performs the onion decomposition.</span>
<span class="gi">+    current_core = 1</span>
<span class="gi">+    current_layer = 1</span>
<span class="gi">+    # Sets vertices of degree 0 to layer 1, if any.</span>
<span class="gi">+    isolated_nodes = list(nx.isolates(G))</span>
<span class="gi">+    if len(isolated_nodes) &gt; 0:</span>
<span class="gi">+        for v in isolated_nodes:</span>
<span class="gi">+            od_layers[v] = current_layer</span>
<span class="gi">+            degrees.pop(v)</span>
<span class="gi">+        current_layer = 2</span>
<span class="gi">+    # Finds the layer for the remaining nodes.</span>
<span class="gi">+    while len(degrees) &gt; 0:</span>
<span class="gi">+        # Sets the order for looking at nodes.</span>
<span class="gi">+        nodes = sorted(degrees, key=degrees.get)</span>
<span class="gi">+        # Sets properly the current core.</span>
<span class="gi">+        min_degree = degrees[nodes[0]]</span>
<span class="gi">+        if min_degree &gt; current_core:</span>
<span class="gi">+            current_core = min_degree</span>
<span class="gi">+        # Identifies vertices in the current layer.</span>
<span class="gi">+        this_layer = []</span>
<span class="gi">+        for n in nodes:</span>
<span class="gi">+            if degrees[n] &gt; current_core:</span>
<span class="gi">+                break</span>
<span class="gi">+            this_layer.append(n)</span>
<span class="gi">+        # Identifies the core/layer of the vertices in the current layer.</span>
<span class="gi">+        for v in this_layer:</span>
<span class="gi">+            od_layers[v] = current_layer</span>
<span class="gi">+            for n in neighbors[v]:</span>
<span class="gi">+                neighbors[n].remove(v)</span>
<span class="gi">+                degrees[n] = degrees[n] - 1</span>
<span class="gi">+            degrees.pop(v)</span>
<span class="gi">+        # Updates the layer count.</span>
<span class="gi">+        current_layer = current_layer + 1</span>
<span class="gi">+    # Returns the dictionaries containing the onion layer of each vertices.</span>
<span class="gi">+    return od_layers</span>
<span class="gh">diff --git a/networkx/algorithms/covering.py b/networkx/algorithms/covering.py</span>
<span class="gh">index 5ff7e7842..bed482bc4 100644</span>
<span class="gd">--- a/networkx/algorithms/covering.py</span>
<span class="gi">+++ b/networkx/algorithms/covering.py</span>
<span class="gu">@@ -1,13 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot; Functions related to graph covers.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import arbitrary_element, not_implemented_for
<span class="gd">-__all__ = [&#39;min_edge_cover&#39;, &#39;is_edge_cover&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;min_edge_cover&quot;, &quot;is_edge_cover&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def min_edge_cover(G, matching_algorithm=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the min cardinality edge cover of the graph as a set of edges.
<span class="gu">@@ -68,10 +71,41 @@ def min_edge_cover(G, matching_algorithm=None):</span>
<span class="w"> </span>    simply this function with a default matching algorithm of
<span class="w"> </span>    :func:`~networkx.algorithms.bipartite.matching.hopcraft_karp_matching`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return set()</span>
<span class="gi">+    if nx.number_of_isolates(G) &gt; 0:</span>
<span class="gi">+        # ``min_cover`` does not exist as there is an isolated node</span>
<span class="gi">+        raise nx.NetworkXException(</span>
<span class="gi">+            &quot;Graph has a node with no edge incident on it, so no edge cover exists.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if matching_algorithm is None:</span>
<span class="gi">+        matching_algorithm = partial(nx.max_weight_matching, maxcardinality=True)</span>
<span class="gi">+    maximum_matching = matching_algorithm(G)</span>
<span class="gi">+    # ``min_cover`` is superset of ``maximum_matching``</span>
<span class="gi">+    try:</span>
<span class="gi">+        # bipartite matching algs return dict so convert if needed</span>
<span class="gi">+        min_cover = set(maximum_matching.items())</span>
<span class="gi">+        bipartite_cover = True</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        min_cover = maximum_matching</span>
<span class="gi">+        bipartite_cover = False</span>
<span class="gi">+    # iterate for uncovered nodes</span>
<span class="gi">+    uncovered_nodes = set(G) - {v for u, v in min_cover} - {u for u, v in min_cover}</span>
<span class="gi">+    for v in uncovered_nodes:</span>
<span class="gi">+        # Since `v` is uncovered, each edge incident to `v` will join it</span>
<span class="gi">+        # with a covered node (otherwise, if there were an edge joining</span>
<span class="gi">+        # uncovered nodes `u` and `v`, the maximum matching algorithm</span>
<span class="gi">+        # would have found it), so we can choose an arbitrary edge</span>
<span class="gi">+        # incident to `v`. (This applies only in a simple graph, not a</span>
<span class="gi">+        # multigraph.)</span>
<span class="gi">+        u = arbitrary_element(G[v])</span>
<span class="gi">+        min_cover.add((u, v))</span>
<span class="gi">+        if bipartite_cover:</span>
<span class="gi">+            min_cover.add((v, u))</span>
<span class="gi">+    return min_cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_edge_cover(G, cover):
<span class="w"> </span>    &quot;&quot;&quot;Decides whether a set of edges is a valid edge cover of the graph.
<span class="gu">@@ -105,4 +139,4 @@ def is_edge_cover(G, cover):</span>
<span class="w"> </span>    An edge cover of a graph is a set of edges such that every node of
<span class="w"> </span>    the graph is incident to at least one edge of the set.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return set(G) &lt;= set(chain.from_iterable(cover))</span>
<span class="gh">diff --git a/networkx/algorithms/cuts.py b/networkx/algorithms/cuts.py</span>
<span class="gh">index 4b07b7798..d7d54e7bb 100644</span>
<span class="gd">--- a/networkx/algorithms/cuts.py</span>
<span class="gi">+++ b/networkx/algorithms/cuts.py</span>
<span class="gu">@@ -1,14 +1,27 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for finding and evaluating cuts in a graph.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;boundary_expansion&#39;, &#39;conductance&#39;, &#39;cut_size&#39;,</span>
<span class="gd">-    &#39;edge_expansion&#39;, &#39;mixing_expansion&#39;, &#39;node_expansion&#39;,</span>
<span class="gd">-    &#39;normalized_cut_size&#39;, &#39;volume&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;boundary_expansion&quot;,</span>
<span class="gi">+    &quot;conductance&quot;,</span>
<span class="gi">+    &quot;cut_size&quot;,</span>
<span class="gi">+    &quot;edge_expansion&quot;,</span>
<span class="gi">+    &quot;mixing_expansion&quot;,</span>
<span class="gi">+    &quot;node_expansion&quot;,</span>
<span class="gi">+    &quot;normalized_cut_size&quot;,</span>
<span class="gi">+    &quot;volume&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO STILL NEED TO UPDATE ALL THE DOCUMENTATION!</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def cut_size(G, S, T=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the size of the cut between two sets of nodes.

<span class="gu">@@ -65,10 +78,13 @@ def cut_size(G, S, T=None, weight=None):</span>
<span class="w"> </span>    multiplicity.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = nx.edge_boundary(G, S, T, data=weight, default=1)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        edges = chain(edges, nx.edge_boundary(G, T, S, data=weight, default=1))</span>
<span class="gi">+    return sum(weight for u, v, weight in edges)</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def volume(G, S, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the volume of a set of nodes.

<span class="gu">@@ -107,10 +123,11 @@ def volume(G, S, weight=None):</span>
<span class="w"> </span>           &lt;https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    degree = G.out_degree if G.is_directed() else G.degree</span>
<span class="gi">+    return sum(d for v, d in degree(S, weight=weight))</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def normalized_cut_size(G, S, T=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the normalized size of the cut between two sets of nodes.

<span class="gu">@@ -155,10 +172,15 @@ def normalized_cut_size(G, S, T=None, weight=None):</span>
<span class="w"> </span>           &lt;https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if T is None:</span>
<span class="gi">+        T = set(G) - set(S)</span>
<span class="gi">+    num_cut_edges = cut_size(G, S, T=T, weight=weight)</span>
<span class="gi">+    volume_S = volume(G, S, weight=weight)</span>
<span class="gi">+    volume_T = volume(G, T, weight=weight)</span>
<span class="gi">+    return num_cut_edges * ((1 / volume_S) + (1 / volume_T))</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def conductance(G, S, T=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the conductance of two sets of nodes.

<span class="gu">@@ -198,10 +220,15 @@ def conductance(G, S, T=None, weight=None):</span>
<span class="w"> </span>           &lt;https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if T is None:</span>
<span class="gi">+        T = set(G) - set(S)</span>
<span class="gi">+    num_cut_edges = cut_size(G, S, T, weight=weight)</span>
<span class="gi">+    volume_S = volume(G, S, weight=weight)</span>
<span class="gi">+    volume_T = volume(G, T, weight=weight)</span>
<span class="gi">+    return num_cut_edges / min(volume_S, volume_T)</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def edge_expansion(G, S, T=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the edge expansion between two node sets.

<span class="gu">@@ -242,10 +269,13 @@ def edge_expansion(G, S, T=None, weight=None):</span>
<span class="w"> </span>           &lt;http://www.math.ucsd.edu/~fan/research/revised.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if T is None:</span>
<span class="gi">+        T = set(G) - set(S)</span>
<span class="gi">+    num_cut_edges = cut_size(G, S, T=T, weight=weight)</span>
<span class="gi">+    return num_cut_edges / min(len(S), len(T))</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def mixing_expansion(G, S, T=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the mixing expansion between two node sets.

<span class="gu">@@ -286,9 +316,13 @@ def mixing_expansion(G, S, T=None, weight=None):</span>
<span class="w"> </span>           &lt;https://doi.org/10.1561/0400000010&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    num_cut_edges = cut_size(G, S, T=T, weight=weight)</span>
<span class="gi">+    num_total_edges = G.number_of_edges()</span>
<span class="gi">+    return num_cut_edges / (2 * num_total_edges)</span>


<span class="gi">+# TODO What is the generalization to two arguments, S and T? Does the</span>
<span class="gi">+# denominator become `min(len(S), len(T))`?</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def node_expansion(G, S):
<span class="w"> </span>    &quot;&quot;&quot;Returns the node expansion of the set `S`.
<span class="gu">@@ -323,9 +357,12 @@ def node_expansion(G, S):</span>
<span class="w"> </span>           &lt;https://doi.org/10.1561/0400000010&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    neighborhood = set(chain.from_iterable(G.neighbors(v) for v in S))</span>
<span class="gi">+    return len(neighborhood) / len(S)</span>


<span class="gi">+# TODO What is the generalization to two arguments, S and T? Does the</span>
<span class="gi">+# denominator become `min(len(S), len(T))`?</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def boundary_expansion(G, S):
<span class="w"> </span>    &quot;&quot;&quot;Returns the boundary expansion of the set `S`.
<span class="gu">@@ -360,4 +397,4 @@ def boundary_expansion(G, S):</span>
<span class="w"> </span>           &lt;https://doi.org/10.1561/0400000010&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(nx.node_boundary(G, S)) / len(S)</span>
<span class="gh">diff --git a/networkx/algorithms/cycles.py b/networkx/algorithms/cycles.py</span>
<span class="gh">index a61f1b90a..14660ed52 100644</span>
<span class="gd">--- a/networkx/algorithms/cycles.py</span>
<span class="gi">+++ b/networkx/algorithms/cycles.py</span>
<span class="gu">@@ -3,17 +3,27 @@</span>
<span class="w"> </span>Cycle finding algorithms
<span class="w"> </span>========================
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import Counter, defaultdict
<span class="w"> </span>from itertools import combinations, product
<span class="w"> </span>from math import inf
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, pairwise
<span class="gd">-__all__ = [&#39;cycle_basis&#39;, &#39;simple_cycles&#39;, &#39;recursive_simple_cycles&#39;,</span>
<span class="gd">-    &#39;find_cycle&#39;, &#39;minimum_cycle_basis&#39;, &#39;chordless_cycles&#39;, &#39;girth&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;cycle_basis&quot;,</span>
<span class="gi">+    &quot;simple_cycles&quot;,</span>
<span class="gi">+    &quot;recursive_simple_cycles&quot;,</span>
<span class="gi">+    &quot;find_cycle&quot;,</span>
<span class="gi">+    &quot;minimum_cycle_basis&quot;,</span>
<span class="gi">+    &quot;chordless_cycles&quot;,</span>
<span class="gi">+    &quot;girth&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def cycle_basis(G, root=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a list of cycles which form a basis for cycles of G.
<span class="gu">@@ -58,7 +68,38 @@ def cycle_basis(G, root=None):</span>
<span class="w"> </span>    simple_cycles
<span class="w"> </span>    minimum_cycle_basis
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gnodes = dict.fromkeys(G)  # set-like object that maintains node order</span>
<span class="gi">+    cycles = []</span>
<span class="gi">+    while gnodes:  # loop over connected components</span>
<span class="gi">+        if root is None:</span>
<span class="gi">+            root = gnodes.popitem()[0]</span>
<span class="gi">+        stack = [root]</span>
<span class="gi">+        pred = {root: root}</span>
<span class="gi">+        used = {root: set()}</span>
<span class="gi">+        while stack:  # walk the spanning tree finding cycles</span>
<span class="gi">+            z = stack.pop()  # use last-in so cycles easier to find</span>
<span class="gi">+            zused = used[z]</span>
<span class="gi">+            for nbr in G[z]:</span>
<span class="gi">+                if nbr not in used:  # new node</span>
<span class="gi">+                    pred[nbr] = z</span>
<span class="gi">+                    stack.append(nbr)</span>
<span class="gi">+                    used[nbr] = {z}</span>
<span class="gi">+                elif nbr == z:  # self loops</span>
<span class="gi">+                    cycles.append([z])</span>
<span class="gi">+                elif nbr not in zused:  # found a cycle</span>
<span class="gi">+                    pn = used[nbr]</span>
<span class="gi">+                    cycle = [nbr, z]</span>
<span class="gi">+                    p = pred[z]</span>
<span class="gi">+                    while p not in pn:</span>
<span class="gi">+                        cycle.append(p)</span>
<span class="gi">+                        p = pred[p]</span>
<span class="gi">+                    cycle.append(p)</span>
<span class="gi">+                    cycles.append(cycle)</span>
<span class="gi">+                    used[nbr].add(z)</span>
<span class="gi">+        for node in pred:</span>
<span class="gi">+            gnodes.pop(node, None)</span>
<span class="gi">+        root = None</span>
<span class="gi">+    return cycles</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -154,7 +195,47 @@ def simple_cycles(G, length_bound=None):</span>
<span class="w"> </span>    cycle_basis
<span class="w"> </span>    chordless_cycles
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if length_bound is not None:</span>
<span class="gi">+        if length_bound == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        elif length_bound &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;length bound must be non-negative&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    yield from ([v] for v, Gv in G.adj.items() if v in Gv)</span>
<span class="gi">+</span>
<span class="gi">+    if length_bound is not None and length_bound == 1:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph() and not directed:</span>
<span class="gi">+        visited = set()</span>
<span class="gi">+        for u, Gu in G.adj.items():</span>
<span class="gi">+            multiplicity = ((v, len(Guv)) for v, Guv in Gu.items() if v in visited)</span>
<span class="gi">+            yield from ([u, v] for v, m in multiplicity if m &gt; 1)</span>
<span class="gi">+            visited.add(u)</span>
<span class="gi">+</span>
<span class="gi">+    # explicitly filter out loops; implicitly filter out parallel edges</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        G = nx.DiGraph((u, v) for u, Gu in G.adj.items() for v in Gu if v != u)</span>
<span class="gi">+    else:</span>
<span class="gi">+        G = nx.Graph((u, v) for u, Gu in G.adj.items() for v in Gu if v != u)</span>
<span class="gi">+</span>
<span class="gi">+    # this case is not strictly necessary but improves performance</span>
<span class="gi">+    if length_bound is not None and length_bound == 2:</span>
<span class="gi">+        if directed:</span>
<span class="gi">+            visited = set()</span>
<span class="gi">+            for u, Gu in G.adj.items():</span>
<span class="gi">+                yield from (</span>
<span class="gi">+                    [v, u] for v in visited.intersection(Gu) if G.has_edge(v, u)</span>
<span class="gi">+                )</span>
<span class="gi">+                visited.add(u)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        yield from _directed_cycle_search(G, length_bound)</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield from _undirected_cycle_search(G, length_bound)</span>


<span class="w"> </span>def _directed_cycle_search(G, length_bound):
<span class="gu">@@ -191,7 +272,20 @@ def _directed_cycle_search(G, length_bound):</span>
<span class="w"> </span>    list of nodes
<span class="w"> </span>       Each cycle is represented by a list of nodes along the cycle.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    scc = nx.strongly_connected_components</span>
<span class="gi">+    components = [c for c in scc(G) if len(c) &gt;= 2]</span>
<span class="gi">+    while components:</span>
<span class="gi">+        c = components.pop()</span>
<span class="gi">+        Gc = G.subgraph(c)</span>
<span class="gi">+        v = next(iter(c))</span>
<span class="gi">+        if length_bound is None:</span>
<span class="gi">+            yield from _johnson_cycle_search(Gc, [v])</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield from _bounded_cycle_search(Gc, [v], length_bound)</span>
<span class="gi">+        # delete v after searching G, to make sure we can find v</span>
<span class="gi">+        G.remove_node(v)</span>
<span class="gi">+        components.extend(c for c in scc(Gc) if len(c) &gt;= 2)</span>


<span class="w"> </span>def _undirected_cycle_search(G, length_bound):
<span class="gu">@@ -228,7 +322,20 @@ def _undirected_cycle_search(G, length_bound):</span>
<span class="w"> </span>    list of nodes
<span class="w"> </span>       Each cycle is represented by a list of nodes along the cycle.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    bcc = nx.biconnected_components</span>
<span class="gi">+    components = [c for c in bcc(G) if len(c) &gt;= 3]</span>
<span class="gi">+    while components:</span>
<span class="gi">+        c = components.pop()</span>
<span class="gi">+        Gc = G.subgraph(c)</span>
<span class="gi">+        uv = list(next(iter(Gc.edges)))</span>
<span class="gi">+        G.remove_edge(*uv)</span>
<span class="gi">+        # delete (u, v) before searching G, to avoid fake 3-cycles [u, v, u]</span>
<span class="gi">+        if length_bound is None:</span>
<span class="gi">+            yield from _johnson_cycle_search(Gc, uv)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield from _bounded_cycle_search(Gc, uv, length_bound)</span>
<span class="gi">+        components.extend(c for c in bcc(Gc) if len(c) &gt;= 3)</span>


<span class="w"> </span>class _NeighborhoodCache(dict):
<span class="gu">@@ -270,7 +377,41 @@ def _johnson_cycle_search(G, path):</span>
<span class="w"> </span>       https://doi.org/10.1137/0204007

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    G = _NeighborhoodCache(G)</span>
<span class="gi">+    blocked = set(path)</span>
<span class="gi">+    B = defaultdict(set)  # graph portions that yield no elementary circuit</span>
<span class="gi">+    start = path[0]</span>
<span class="gi">+    stack = [iter(G[path[-1]])]</span>
<span class="gi">+    closed = [False]</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        nbrs = stack[-1]</span>
<span class="gi">+        for w in nbrs:</span>
<span class="gi">+            if w == start:</span>
<span class="gi">+                yield path[:]</span>
<span class="gi">+                closed[-1] = True</span>
<span class="gi">+            elif w not in blocked:</span>
<span class="gi">+                path.append(w)</span>
<span class="gi">+                closed.append(False)</span>
<span class="gi">+                stack.append(iter(G[w]))</span>
<span class="gi">+                blocked.add(w)</span>
<span class="gi">+                break</span>
<span class="gi">+        else:  # no more nbrs</span>
<span class="gi">+            stack.pop()</span>
<span class="gi">+            v = path.pop()</span>
<span class="gi">+            if closed.pop():</span>
<span class="gi">+                if closed:</span>
<span class="gi">+                    closed[-1] = True</span>
<span class="gi">+                unblock_stack = {v}</span>
<span class="gi">+                while unblock_stack:</span>
<span class="gi">+                    u = unblock_stack.pop()</span>
<span class="gi">+                    if u in blocked:</span>
<span class="gi">+                        blocked.remove(u)</span>
<span class="gi">+                        unblock_stack.update(B[u])</span>
<span class="gi">+                        B[u].clear()</span>
<span class="gi">+            else:</span>
<span class="gi">+                for w in G[v]:</span>
<span class="gi">+                    B[w].add(v)</span>


<span class="w"> </span>def _bounded_cycle_search(G, path, length_bound):
<span class="gu">@@ -298,7 +439,40 @@ def _bounded_cycle_search(G, path, length_bound):</span>
<span class="w"> </span>       A. Gupta and T. Suzumura https://arxiv.org/abs/2105.10094

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = _NeighborhoodCache(G)</span>
<span class="gi">+    lock = {v: 0 for v in path}</span>
<span class="gi">+    B = defaultdict(set)</span>
<span class="gi">+    start = path[0]</span>
<span class="gi">+    stack = [iter(G[path[-1]])]</span>
<span class="gi">+    blen = [length_bound]</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        nbrs = stack[-1]</span>
<span class="gi">+        for w in nbrs:</span>
<span class="gi">+            if w == start:</span>
<span class="gi">+                yield path[:]</span>
<span class="gi">+                blen[-1] = 1</span>
<span class="gi">+            elif len(path) &lt; lock.get(w, length_bound):</span>
<span class="gi">+                path.append(w)</span>
<span class="gi">+                blen.append(length_bound)</span>
<span class="gi">+                lock[w] = len(path)</span>
<span class="gi">+                stack.append(iter(G[w]))</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            stack.pop()</span>
<span class="gi">+            v = path.pop()</span>
<span class="gi">+            bl = blen.pop()</span>
<span class="gi">+            if blen:</span>
<span class="gi">+                blen[-1] = min(blen[-1], bl)</span>
<span class="gi">+            if bl &lt; length_bound:</span>
<span class="gi">+                relax_stack = [(bl, v)]</span>
<span class="gi">+                while relax_stack:</span>
<span class="gi">+                    bl, u = relax_stack.pop()</span>
<span class="gi">+                    if lock.get(u, length_bound) &lt; length_bound - bl + 1:</span>
<span class="gi">+                        lock[u] = length_bound - bl + 1</span>
<span class="gi">+                        relax_stack.extend((bl + 1, w) for w in B[u].difference(path))</span>
<span class="gi">+            else:</span>
<span class="gi">+                for w in G[v]:</span>
<span class="gi">+                    B[w].add(v)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -391,7 +565,125 @@ def chordless_cycles(G, length_bound=None):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    simple_cycles
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if length_bound is not None:</span>
<span class="gi">+        if length_bound == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        elif length_bound &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;length bound must be non-negative&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    multigraph = G.is_multigraph()</span>
<span class="gi">+</span>
<span class="gi">+    if multigraph:</span>
<span class="gi">+        yield from ([v] for v, Gv in G.adj.items() if len(Gv.get(v, ())) == 1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield from ([v] for v, Gv in G.adj.items() if v in Gv)</span>
<span class="gi">+</span>
<span class="gi">+    if length_bound is not None and length_bound == 1:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # Nodes with loops cannot belong to longer cycles.  Let&#39;s delete them here.</span>
<span class="gi">+    # also, we implicitly reduce the multiplicity of edges down to 1 in the case</span>
<span class="gi">+    # of multiedges.</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        F = nx.DiGraph((u, v) for u, Gu in G.adj.items() if u not in Gu for v in Gu)</span>
<span class="gi">+        B = F.to_undirected(as_view=False)</span>
<span class="gi">+    else:</span>
<span class="gi">+        F = nx.Graph((u, v) for u, Gu in G.adj.items() if u not in Gu for v in Gu)</span>
<span class="gi">+        B = None</span>
<span class="gi">+</span>
<span class="gi">+    # If we&#39;re given a multigraph, we have a few cases to consider with parallel</span>
<span class="gi">+    # edges.</span>
<span class="gi">+    #</span>
<span class="gi">+    # 1. If we have 2 or more edges in parallel between the nodes (u, v), we</span>
<span class="gi">+    #    must not construct longer cycles along (u, v).</span>
<span class="gi">+    # 2. If G is not directed, then a pair of parallel edges between (u, v) is a</span>
<span class="gi">+    #    chordless cycle unless there exists a third (or more) parallel edge.</span>
<span class="gi">+    # 3. If G is directed, then parallel edges do not form cycles, but do</span>
<span class="gi">+    #    preclude back-edges from forming cycles (handled in the next section),</span>
<span class="gi">+    #    Thus, if an edge (u, v) is duplicated and the reverse (v, u) is also</span>
<span class="gi">+    #    present, then we remove both from F.</span>
<span class="gi">+    #</span>
<span class="gi">+    # In directed graphs, we need to consider both directions that edges can</span>
<span class="gi">+    # take, so iterate over all edges (u, v) and possibly (v, u).  In undirected</span>
<span class="gi">+    # graphs, we need to be a little careful to only consider every edge once,</span>
<span class="gi">+    # so we use a &quot;visited&quot; set to emulate node-order comparisons.</span>
<span class="gi">+</span>
<span class="gi">+    if multigraph:</span>
<span class="gi">+        if not directed:</span>
<span class="gi">+            B = F.copy()</span>
<span class="gi">+            visited = set()</span>
<span class="gi">+        for u, Gu in G.adj.items():</span>
<span class="gi">+            if directed:</span>
<span class="gi">+                multiplicity = ((v, len(Guv)) for v, Guv in Gu.items())</span>
<span class="gi">+                for v, m in multiplicity:</span>
<span class="gi">+                    if m &gt; 1:</span>
<span class="gi">+                        F.remove_edges_from(((u, v), (v, u)))</span>
<span class="gi">+            else:</span>
<span class="gi">+                multiplicity = ((v, len(Guv)) for v, Guv in Gu.items() if v in visited)</span>
<span class="gi">+                for v, m in multiplicity:</span>
<span class="gi">+                    if m == 2:</span>
<span class="gi">+                        yield [u, v]</span>
<span class="gi">+                    if m &gt; 1:</span>
<span class="gi">+                        F.remove_edge(u, v)</span>
<span class="gi">+                visited.add(u)</span>
<span class="gi">+</span>
<span class="gi">+    # If we&#39;re given a directed graphs, we need to think about digons.  If we</span>
<span class="gi">+    # have two edges (u, v) and (v, u), then that&#39;s a two-cycle.  If either edge</span>
<span class="gi">+    # was duplicated above, then we removed both from F.  So, any digons we find</span>
<span class="gi">+    # here are chordless.  After finding digons, we remove their edges from F</span>
<span class="gi">+    # to avoid traversing them in the search for chordless cycles.</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        for u, Fu in F.adj.items():</span>
<span class="gi">+            digons = [[u, v] for v in Fu if F.has_edge(v, u)]</span>
<span class="gi">+            yield from digons</span>
<span class="gi">+            F.remove_edges_from(digons)</span>
<span class="gi">+            F.remove_edges_from(e[::-1] for e in digons)</span>
<span class="gi">+</span>
<span class="gi">+    if length_bound is not None and length_bound == 2:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # Now, we prepare to search for cycles.  We have removed all cycles of</span>
<span class="gi">+    # lengths 1 and 2, so F is a simple graph or simple digraph.  We repeatedly</span>
<span class="gi">+    # separate digraphs into their strongly connected components, and undirected</span>
<span class="gi">+    # graphs into their biconnected components.  For each component, we pick a</span>
<span class="gi">+    # node v, search for chordless cycles based at each &quot;stem&quot; (u, v, w), and</span>
<span class="gi">+    # then remove v from that component before separating the graph again.</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        separate = nx.strongly_connected_components</span>
<span class="gi">+</span>
<span class="gi">+        # Directed stems look like (u -&gt; v -&gt; w), so we use the product of</span>
<span class="gi">+        # predecessors of v with successors of v.</span>
<span class="gi">+        def stems(C, v):</span>
<span class="gi">+            for u, w in product(C.pred[v], C.succ[v]):</span>
<span class="gi">+                if not G.has_edge(u, w):  # omit stems with acyclic chords</span>
<span class="gi">+                    yield [u, v, w], F.has_edge(w, u)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        separate = nx.biconnected_components</span>
<span class="gi">+</span>
<span class="gi">+        # Undirected stems look like (u ~ v ~ w), but we must not also search</span>
<span class="gi">+        # (w ~ v ~ u), so we use combinations of v&#39;s neighbors of length 2.</span>
<span class="gi">+        def stems(C, v):</span>
<span class="gi">+            yield from (([u, v, w], F.has_edge(w, u)) for u, w in combinations(C[v], 2))</span>
<span class="gi">+</span>
<span class="gi">+    components = [c for c in separate(F) if len(c) &gt; 2]</span>
<span class="gi">+    while components:</span>
<span class="gi">+        c = components.pop()</span>
<span class="gi">+        v = next(iter(c))</span>
<span class="gi">+        Fc = F.subgraph(c)</span>
<span class="gi">+        Fcc = Bcc = None</span>
<span class="gi">+        for S, is_triangle in stems(Fc, v):</span>
<span class="gi">+            if is_triangle:</span>
<span class="gi">+                yield S</span>
<span class="gi">+            else:</span>
<span class="gi">+                if Fcc is None:</span>
<span class="gi">+                    Fcc = _NeighborhoodCache(Fc)</span>
<span class="gi">+                    Bcc = Fcc if B is None else _NeighborhoodCache(B.subgraph(c))</span>
<span class="gi">+                yield from _chordless_cycle_search(Fcc, Bcc, S, length_bound)</span>
<span class="gi">+</span>
<span class="gi">+        components.extend(c for c in separate(F.subgraph(c - {v})) if len(c) &gt; 2)</span>


<span class="w"> </span>def _chordless_cycle_search(F, B, path, length_bound):
<span class="gu">@@ -441,10 +733,37 @@ def _chordless_cycle_search(F, B, path, length_bound):</span>
<span class="w"> </span>       https://arxiv.org/abs/1309.1051

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    blocked = defaultdict(int)</span>
<span class="gi">+    target = path[0]</span>
<span class="gi">+    blocked[path[1]] = 1</span>
<span class="gi">+    for w in path[1:]:</span>
<span class="gi">+        for v in B[w]:</span>
<span class="gi">+            blocked[v] += 1</span>
<span class="gi">+</span>
<span class="gi">+    stack = [iter(F[path[2]])]</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        nbrs = stack[-1]</span>
<span class="gi">+        for w in nbrs:</span>
<span class="gi">+            if blocked[w] == 1 and (length_bound is None or len(path) &lt; length_bound):</span>
<span class="gi">+                Fw = F[w]</span>
<span class="gi">+                if target in Fw:</span>
<span class="gi">+                    yield path + [w]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    Bw = B[w]</span>
<span class="gi">+                    if target in Bw:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    for v in Bw:</span>
<span class="gi">+                        blocked[v] += 1</span>
<span class="gi">+                    path.append(w)</span>
<span class="gi">+                    stack.append(iter(Fw))</span>
<span class="gi">+                    break</span>
<span class="gi">+        else:</span>
<span class="gi">+            stack.pop()</span>
<span class="gi">+            for v in B[path.pop()]:</span>
<span class="gi">+                blocked[v] -= 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable(mutates_input=True)
<span class="w"> </span>def recursive_simple_cycles(G):
<span class="w"> </span>    &quot;&quot;&quot;Find simple cycles (elementary circuits) of a directed graph.
<span class="gu">@@ -492,7 +811,67 @@ def recursive_simple_cycles(G):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    simple_cycles, cycle_basis
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Jon Olav Vik, 2010-08-09</span>
<span class="gi">+    def _unblock(thisnode):</span>
<span class="gi">+        &quot;&quot;&quot;Recursively unblock and remove nodes from B[thisnode].&quot;&quot;&quot;</span>
<span class="gi">+        if blocked[thisnode]:</span>
<span class="gi">+            blocked[thisnode] = False</span>
<span class="gi">+            while B[thisnode]:</span>
<span class="gi">+                _unblock(B[thisnode].pop())</span>
<span class="gi">+</span>
<span class="gi">+    def circuit(thisnode, startnode, component):</span>
<span class="gi">+        closed = False  # set to True if elementary path is closed</span>
<span class="gi">+        path.append(thisnode)</span>
<span class="gi">+        blocked[thisnode] = True</span>
<span class="gi">+        for nextnode in component[thisnode]:  # direct successors of thisnode</span>
<span class="gi">+            if nextnode == startnode:</span>
<span class="gi">+                result.append(path[:])</span>
<span class="gi">+                closed = True</span>
<span class="gi">+            elif not blocked[nextnode]:</span>
<span class="gi">+                if circuit(nextnode, startnode, component):</span>
<span class="gi">+                    closed = True</span>
<span class="gi">+        if closed:</span>
<span class="gi">+            _unblock(thisnode)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for nextnode in component[thisnode]:</span>
<span class="gi">+                if thisnode not in B[nextnode]:  # TODO: use set for speedup?</span>
<span class="gi">+                    B[nextnode].append(thisnode)</span>
<span class="gi">+        path.pop()  # remove thisnode from path</span>
<span class="gi">+        return closed</span>
<span class="gi">+</span>
<span class="gi">+    path = []  # stack of nodes in current path</span>
<span class="gi">+    blocked = defaultdict(bool)  # vertex: blocked from search?</span>
<span class="gi">+    B = defaultdict(list)  # graph portions that yield no elementary circuit</span>
<span class="gi">+    result = []  # list to accumulate the circuits found</span>
<span class="gi">+</span>
<span class="gi">+    # Johnson&#39;s algorithm exclude self cycle edges like (v, v)</span>
<span class="gi">+    # To be backward compatible, we record those cycles in advance</span>
<span class="gi">+    # and then remove from subG</span>
<span class="gi">+    for v in G:</span>
<span class="gi">+        if G.has_edge(v, v):</span>
<span class="gi">+            result.append([v])</span>
<span class="gi">+            G.remove_edge(v, v)</span>
<span class="gi">+</span>
<span class="gi">+    # Johnson&#39;s algorithm requires some ordering of the nodes.</span>
<span class="gi">+    # They might not be sortable so we assign an arbitrary ordering.</span>
<span class="gi">+    ordering = dict(zip(G, range(len(G))))</span>
<span class="gi">+    for s in ordering:</span>
<span class="gi">+        # Build the subgraph induced by s and following nodes in the ordering</span>
<span class="gi">+        subgraph = G.subgraph(node for node in G if ordering[node] &gt;= ordering[s])</span>
<span class="gi">+        # Find the strongly connected component in the subgraph</span>
<span class="gi">+        # that contains the least node according to the ordering</span>
<span class="gi">+        strongcomp = nx.strongly_connected_components(subgraph)</span>
<span class="gi">+        mincomp = min(strongcomp, key=lambda ns: min(ordering[n] for n in ns))</span>
<span class="gi">+        component = G.subgraph(mincomp)</span>
<span class="gi">+        if len(component) &gt; 1:</span>
<span class="gi">+            # smallest node in the component according to the ordering</span>
<span class="gi">+            startnode = min(component, key=ordering.__getitem__)</span>
<span class="gi">+            for node in component:</span>
<span class="gi">+                blocked[node] = False</span>
<span class="gi">+                B[node][:] = []</span>
<span class="gi">+            dummy = circuit(startnode, startnode, component)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -563,12 +942,101 @@ def find_cycle(G, source=None, orientation=None):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    simple_cycles
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    if not G.is_directed() or orientation in (None, &quot;original&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        def tailhead(edge):</span>
<span class="gi">+            return edge[:2]</span>
<span class="gi">+</span>
<span class="gi">+    elif orientation == &quot;reverse&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        def tailhead(edge):</span>
<span class="gi">+            return edge[1], edge[0]</span>
<span class="gi">+</span>
<span class="gi">+    elif orientation == &quot;ignore&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        def tailhead(edge):</span>
<span class="gi">+            if edge[-1] == &quot;reverse&quot;:</span>
<span class="gi">+                return edge[1], edge[0]</span>
<span class="gi">+            return edge[:2]</span>
<span class="gi">+</span>
<span class="gi">+    explored = set()</span>
<span class="gi">+    cycle = []</span>
<span class="gi">+    final_node = None</span>
<span class="gi">+    for start_node in G.nbunch_iter(source):</span>
<span class="gi">+        if start_node in explored:</span>
<span class="gi">+            # No loop is possible.</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        edges = []</span>
<span class="gi">+        # All nodes seen in this iteration of edge_dfs</span>
<span class="gi">+        seen = {start_node}</span>
<span class="gi">+        # Nodes in active path.</span>
<span class="gi">+        active_nodes = {start_node}</span>
<span class="gi">+        previous_head = None</span>
<span class="gi">+</span>
<span class="gi">+        for edge in nx.edge_dfs(G, start_node, orientation):</span>
<span class="gi">+            # Determine if this edge is a continuation of the active path.</span>
<span class="gi">+            tail, head = tailhead(edge)</span>
<span class="gi">+            if head in explored:</span>
<span class="gi">+                # Then we&#39;ve already explored it. No loop is possible.</span>
<span class="gi">+                continue</span>
<span class="gi">+            if previous_head is not None and tail != previous_head:</span>
<span class="gi">+                # This edge results from backtracking.</span>
<span class="gi">+                # Pop until we get a node whose head equals the current tail.</span>
<span class="gi">+                # So for example, we might have:</span>
<span class="gi">+                #  (0, 1), (1, 2), (2, 3), (1, 4)</span>
<span class="gi">+                # which must become:</span>
<span class="gi">+                #  (0, 1), (1, 4)</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        popped_edge = edges.pop()</span>
<span class="gi">+                    except IndexError:</span>
<span class="gi">+                        edges = []</span>
<span class="gi">+                        active_nodes = {tail}</span>
<span class="gi">+                        break</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        popped_head = tailhead(popped_edge)[1]</span>
<span class="gi">+                        active_nodes.remove(popped_head)</span>
<span class="gi">+</span>
<span class="gi">+                    if edges:</span>
<span class="gi">+                        last_head = tailhead(edges[-1])[1]</span>
<span class="gi">+                        if tail == last_head:</span>
<span class="gi">+                            break</span>
<span class="gi">+            edges.append(edge)</span>
<span class="gi">+</span>
<span class="gi">+            if head in active_nodes:</span>
<span class="gi">+                # We have a loop!</span>
<span class="gi">+                cycle.extend(edges)</span>
<span class="gi">+                final_node = head</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                seen.add(head)</span>
<span class="gi">+                active_nodes.add(head)</span>
<span class="gi">+                previous_head = head</span>
<span class="gi">+</span>
<span class="gi">+        if cycle:</span>
<span class="gi">+            break</span>
<span class="gi">+        else:</span>
<span class="gi">+            explored.update(seen)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        assert len(cycle) == 0</span>
<span class="gi">+        raise nx.exception.NetworkXNoCycle(&quot;No cycle found.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # We now have a list of edges which ends on a cycle.</span>
<span class="gi">+    # So we need to remove from the beginning edges that are not relevant.</span>
<span class="gi">+</span>
<span class="gi">+    for i, edge in enumerate(cycle):</span>
<span class="gi">+        tail, head = tailhead(edge)</span>
<span class="gi">+        if tail == final_node:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return cycle[i:]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def minimum_cycle_basis(G, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a minimum weight cycle basis for G

<span class="gu">@@ -606,7 +1074,41 @@ def minimum_cycle_basis(G, weight=None):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    simple_cycles, cycle_basis
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # We first split the graph in connected subgraphs</span>
<span class="gi">+    return sum(</span>
<span class="gi">+        (_min_cycle_basis(G.subgraph(c), weight) for c in nx.connected_components(G)),</span>
<span class="gi">+        [],</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _min_cycle_basis(G, weight):</span>
<span class="gi">+    cb = []</span>
<span class="gi">+    # We  extract the edges not in a spanning tree. We do not really need a</span>
<span class="gi">+    # *minimum* spanning tree. That is why we call the next function with</span>
<span class="gi">+    # weight=None. Depending on implementation, it may be faster as well</span>
<span class="gi">+    tree_edges = list(nx.minimum_spanning_edges(G, weight=None, data=False))</span>
<span class="gi">+    chords = G.edges - tree_edges - {(v, u) for u, v in tree_edges}</span>
<span class="gi">+</span>
<span class="gi">+    # We maintain a set of vectors orthogonal to sofar found cycles</span>
<span class="gi">+    set_orth = [{edge} for edge in chords]</span>
<span class="gi">+    while set_orth:</span>
<span class="gi">+        base = set_orth.pop()</span>
<span class="gi">+        # kth cycle is &quot;parallel&quot; to kth vector in set_orth</span>
<span class="gi">+        cycle_edges = _min_cycle(G, base, weight)</span>
<span class="gi">+        cb.append([v for u, v in cycle_edges])</span>
<span class="gi">+</span>
<span class="gi">+        # now update set_orth so that k+1,k+2... th elements are</span>
<span class="gi">+        # orthogonal to the newly found cycle, as per [p. 336, 1]</span>
<span class="gi">+        set_orth = [</span>
<span class="gi">+            (</span>
<span class="gi">+                {e for e in orth if e not in base if e[::-1] not in base}</span>
<span class="gi">+                | {e for e in base if e not in orth if e[::-1] not in orth}</span>
<span class="gi">+            )</span>
<span class="gi">+            if sum((e in orth or e[::-1] in orth) for e in cycle_edges) % 2</span>
<span class="gi">+            else orth</span>
<span class="gi">+            for orth in set_orth</span>
<span class="gi">+        ]</span>
<span class="gi">+    return cb</span>


<span class="w"> </span>def _min_cycle(G, orth, weight):
<span class="gu">@@ -615,11 +1117,55 @@ def _min_cycle(G, orth, weight):</span>
<span class="w"> </span>    orthogonal to the vector orth as per [p. 338, 1]
<span class="w"> </span>    Use (u, 1) to indicate the lifted copy of u (denoted u&#39; in paper).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    Gi = nx.Graph()</span>
<span class="gi">+</span>
<span class="gi">+    # Add 2 copies of each edge in G to Gi.</span>
<span class="gi">+    # If edge is in orth, add cross edge; otherwise in-plane edge</span>
<span class="gi">+    for u, v, wt in G.edges(data=weight, default=1):</span>
<span class="gi">+        if (u, v) in orth or (v, u) in orth:</span>
<span class="gi">+            Gi.add_edges_from([(u, (v, 1)), ((u, 1), v)], Gi_weight=wt)</span>
<span class="gi">+        else:</span>
<span class="gi">+            Gi.add_edges_from([(u, v), ((u, 1), (v, 1))], Gi_weight=wt)</span>
<span class="gi">+</span>
<span class="gi">+    # find the shortest length in Gi between n and (n, 1) for each n</span>
<span class="gi">+    # Note: Use &quot;Gi_weight&quot; for name of weight attribute</span>
<span class="gi">+    spl = nx.shortest_path_length</span>
<span class="gi">+    lift = {n: spl(Gi, source=n, target=(n, 1), weight=&quot;Gi_weight&quot;) for n in G}</span>
<span class="gi">+</span>
<span class="gi">+    # Now compute that short path in Gi, which translates to a cycle in G</span>
<span class="gi">+    start = min(lift, key=lift.get)</span>
<span class="gi">+    end = (start, 1)</span>
<span class="gi">+    min_path_i = nx.shortest_path(Gi, source=start, target=end, weight=&quot;Gi_weight&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Now we obtain the actual path, re-map nodes in Gi to those in G</span>
<span class="gi">+    min_path = [n if n in G else n[0] for n in min_path_i]</span>
<span class="gi">+</span>
<span class="gi">+    # Now remove the edges that occur two times</span>
<span class="gi">+    # two passes: flag which edges get kept, then build it</span>
<span class="gi">+    edgelist = list(pairwise(min_path))</span>
<span class="gi">+    edgeset = set()</span>
<span class="gi">+    for e in edgelist:</span>
<span class="gi">+        if e in edgeset:</span>
<span class="gi">+            edgeset.remove(e)</span>
<span class="gi">+        elif e[::-1] in edgeset:</span>
<span class="gi">+            edgeset.remove(e[::-1])</span>
<span class="gi">+        else:</span>
<span class="gi">+            edgeset.add(e)</span>
<span class="gi">+</span>
<span class="gi">+    min_edgelist = []</span>
<span class="gi">+    for e in edgelist:</span>
<span class="gi">+        if e in edgeset:</span>
<span class="gi">+            min_edgelist.append(e)</span>
<span class="gi">+            edgeset.remove(e)</span>
<span class="gi">+        elif e[::-1] in edgeset:</span>
<span class="gi">+            min_edgelist.append(e[::-1])</span>
<span class="gi">+            edgeset.remove(e[::-1])</span>
<span class="gi">+</span>
<span class="gi">+    return min_edgelist</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def girth(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the girth of the graph.
<span class="gu">@@ -660,4 +1206,26 @@ def girth(G):</span>
<span class="w"> </span>    .. [1] `Wikipedia: Girth &lt;https://en.wikipedia.org/wiki/Girth_(graph_theory)&gt;`_

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    girth = depth_limit = inf</span>
<span class="gi">+    tree_edge = nx.algorithms.traversal.breadth_first_search.TREE_EDGE</span>
<span class="gi">+    level_edge = nx.algorithms.traversal.breadth_first_search.LEVEL_EDGE</span>
<span class="gi">+    for n in G:</span>
<span class="gi">+        # run a BFS from source n, keeping track of distances; since we want</span>
<span class="gi">+        # the shortest cycle, no need to explore beyond the current minimum length</span>
<span class="gi">+        depth = {n: 0}</span>
<span class="gi">+        for u, v, label in nx.bfs_labeled_edges(G, n):</span>
<span class="gi">+            du = depth[u]</span>
<span class="gi">+            if du &gt; depth_limit:</span>
<span class="gi">+                break</span>
<span class="gi">+            if label is tree_edge:</span>
<span class="gi">+                depth[v] = du + 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                # if (u, v) is a level edge, the length is du + du + 1 (odd)</span>
<span class="gi">+                # otherwise, it&#39;s a forward edge; length is du + (du + 1) + 1 (even)</span>
<span class="gi">+                delta = label is level_edge</span>
<span class="gi">+                length = du + du + 2 - delta</span>
<span class="gi">+                if length &lt; girth:</span>
<span class="gi">+                    girth = length</span>
<span class="gi">+                    depth_limit = du - delta</span>
<span class="gi">+</span>
<span class="gi">+    return girth</span>
<span class="gh">diff --git a/networkx/algorithms/d_separation.py b/networkx/algorithms/d_separation.py</span>
<span class="gh">index 6c1bed40a..a688eca40 100644</span>
<span class="gd">--- a/networkx/algorithms/d_separation.py</span>
<span class="gi">+++ b/networkx/algorithms/d_separation.py</span>
<span class="gu">@@ -212,15 +212,23 @@ References</span>
<span class="w"> </span>.. [6] https://en.wikipedia.org/wiki/Berkson%27s_paradox

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import deque
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import UnionFind, not_implemented_for
<span class="gd">-__all__ = [&#39;is_d_separator&#39;, &#39;is_minimal_d_separator&#39;,</span>
<span class="gd">-    &#39;find_minimal_d_separator&#39;, &#39;d_separated&#39;, &#39;minimal_d_separator&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;is_d_separator&quot;,</span>
<span class="gi">+    &quot;is_minimal_d_separator&quot;,</span>
<span class="gi">+    &quot;find_minimal_d_separator&quot;,</span>
<span class="gi">+    &quot;d_separated&quot;,</span>
<span class="gi">+    &quot;minimal_d_separator&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_d_separator(G, x, y, z):
<span class="w"> </span>    &quot;&quot;&quot;Return whether node sets `x` and `y` are d-separated by `z`.
<span class="gu">@@ -267,10 +275,68 @@ def is_d_separator(G, x, y, z):</span>

<span class="w"> </span>    https://en.wikipedia.org/wiki/Bayesian_network#d-separation
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        x = {x} if x in G else x</span>
<span class="gi">+        y = {y} if y in G else y</span>
<span class="gi">+        z = {z} if z in G else z</span>
<span class="gi">+</span>
<span class="gi">+        intersection = x &amp; y or x &amp; z or y &amp; z</span>
<span class="gi">+        if intersection:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;The sets are not disjoint, with intersection {intersection}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        set_v = x | y | z</span>
<span class="gi">+        if set_v - G.nodes:</span>
<span class="gi">+            raise nx.NodeNotFound(f&quot;The node(s) {set_v - G.nodes} are not found in G&quot;)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        raise nx.NodeNotFound(&quot;One of x, y, or z is not a node or a set of nodes in G&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_directed_acyclic_graph(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph should be directed acyclic&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # contains -&gt; and &lt;-&gt; edges from starting node T</span>
<span class="gi">+    forward_deque = deque([])</span>
<span class="gi">+    forward_visited = set()</span>
<span class="gi">+</span>
<span class="gi">+    # contains &lt;- and - edges from starting node T</span>
<span class="gi">+    backward_deque = deque(x)</span>
<span class="gi">+    backward_visited = set()</span>
<span class="gi">+</span>
<span class="gi">+    ancestors_or_z = set().union(*[nx.ancestors(G, node) for node in x]) | z | x</span>
<span class="gi">+</span>
<span class="gi">+    while forward_deque or backward_deque:</span>
<span class="gi">+        if backward_deque:</span>
<span class="gi">+            node = backward_deque.popleft()</span>
<span class="gi">+            backward_visited.add(node)</span>
<span class="gi">+            if node in y:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if node in z:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # add &lt;- edges to backward deque</span>
<span class="gi">+            backward_deque.extend(G.pred[node].keys() - backward_visited)</span>
<span class="gi">+            # add -&gt; edges to forward deque</span>
<span class="gi">+            forward_deque.extend(G.succ[node].keys() - forward_visited)</span>
<span class="gi">+</span>
<span class="gi">+        if forward_deque:</span>
<span class="gi">+            node = forward_deque.popleft()</span>
<span class="gi">+            forward_visited.add(node)</span>
<span class="gi">+            if node in y:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            # Consider if -&gt; node &lt;- is opened due to ancestor of node in z</span>
<span class="gi">+            if node in ancestors_or_z:</span>
<span class="gi">+                # add &lt;- edges to backward deque</span>
<span class="gi">+                backward_deque.extend(G.pred[node].keys() - backward_visited)</span>
<span class="gi">+            if node not in z:</span>
<span class="gi">+                # add -&gt; edges to forward deque</span>
<span class="gi">+                forward_deque.extend(G.succ[node].keys() - forward_visited)</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def find_minimal_d_separator(G, x, y, *, included=None, restricted=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a minimal d-separating set between `x` and `y` if possible
<span class="gu">@@ -327,10 +393,57 @@ def find_minimal_d_separator(G, x, y, *, included=None, restricted=None):</span>
<span class="w"> </span>        minimal d-separators in linear time and applications.&quot; In
<span class="w"> </span>        Uncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.is_directed_acyclic_graph(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph should be directed acyclic&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        x = {x} if x in G else x</span>
<span class="gi">+        y = {y} if y in G else y</span>
<span class="gi">+</span>
<span class="gi">+        if included is None:</span>
<span class="gi">+            included = set()</span>
<span class="gi">+        elif included in G:</span>
<span class="gi">+            included = {included}</span>
<span class="gi">+</span>
<span class="gi">+        if restricted is None:</span>
<span class="gi">+            restricted = set(G)</span>
<span class="gi">+        elif restricted in G:</span>
<span class="gi">+            restricted = {restricted}</span>
<span class="gi">+</span>
<span class="gi">+        set_y = x | y | included | restricted</span>
<span class="gi">+        if set_y - G.nodes:</span>
<span class="gi">+            raise nx.NodeNotFound(f&quot;The node(s) {set_y - G.nodes} are not found in G&quot;)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        raise nx.NodeNotFound(</span>
<span class="gi">+            &quot;One of x, y, included or restricted is not a node or set of nodes in G&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if not included &lt;= restricted:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;Included nodes {included} must be in restricted nodes {restricted}&quot;</span>
<span class="gi">+        )</span>

<span class="gi">+    intersection = x &amp; y or x &amp; included or y &amp; included</span>
<span class="gi">+    if intersection:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;The sets x, y, included are not disjoint. Overlap: {intersection}&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    nodeset = x | y | included</span>
<span class="gi">+    ancestors_x_y_included = nodeset.union(*[nx.ancestors(G, node) for node in nodeset])</span>
<span class="gi">+</span>
<span class="gi">+    z_init = restricted &amp; (ancestors_x_y_included - (x | y))</span>
<span class="gi">+</span>
<span class="gi">+    x_closure = _reachable(G, x, ancestors_x_y_included, z_init)</span>
<span class="gi">+    if x_closure &amp; y:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    z_updated = z_init &amp; (x_closure | included)</span>
<span class="gi">+    y_closure = _reachable(G, y, ancestors_x_y_included, z_updated)</span>
<span class="gi">+    return z_updated &amp; (y_closure | included)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_minimal_d_separator(G, x, y, z, *, included=None, restricted=None):
<span class="w"> </span>    &quot;&quot;&quot;Determine if `z` is a minimal d-separator for `x` and `y`.
<span class="gu">@@ -414,10 +527,67 @@ def is_minimal_d_separator(G, x, y, z, *, included=None, restricted=None):</span>

<span class="w"> </span>    For full details, see [1]_.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    if not nx.is_directed_acyclic_graph(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph should be directed acyclic&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        x = {x} if x in G else x</span>
<span class="gi">+        y = {y} if y in G else y</span>
<span class="gi">+        z = {z} if z in G else z</span>
<span class="gi">+</span>
<span class="gi">+        if included is None:</span>
<span class="gi">+            included = set()</span>
<span class="gi">+        elif included in G:</span>
<span class="gi">+            included = {included}</span>
<span class="gi">+</span>
<span class="gi">+        if restricted is None:</span>
<span class="gi">+            restricted = set(G)</span>
<span class="gi">+        elif restricted in G:</span>
<span class="gi">+            restricted = {restricted}</span>
<span class="gi">+</span>
<span class="gi">+        set_y = x | y | included | restricted</span>
<span class="gi">+        if set_y - G.nodes:</span>
<span class="gi">+            raise nx.NodeNotFound(f&quot;The node(s) {set_y - G.nodes} are not found in G&quot;)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        raise nx.NodeNotFound(</span>
<span class="gi">+            &quot;One of x, y, z, included or restricted is not a node or set of nodes in G&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if not included &lt;= z:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;Included nodes {included} must be in proposed separating set z {x}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if not z &lt;= restricted:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;Separating set {z} must be contained in restricted set {restricted}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    intersection = x.intersection(y) or x.intersection(z) or y.intersection(z)</span>
<span class="gi">+    if intersection:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;The sets are not disjoint, with intersection {intersection}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    nodeset = x | y | included</span>
<span class="gi">+    ancestors_x_y_included = nodeset.union(*[nx.ancestors(G, n) for n in nodeset])</span>
<span class="gi">+</span>
<span class="gi">+    # criterion (a) -- check that z is actually a separator</span>
<span class="gi">+    x_closure = _reachable(G, x, ancestors_x_y_included, z)</span>
<span class="gi">+    if x_closure &amp; y:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # criterion (b) -- basic constraint; included and restricted already checked above</span>
<span class="gi">+    if not (z &lt;= ancestors_x_y_included):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # criterion (c) -- check that z is minimal</span>
<span class="gi">+    y_closure = _reachable(G, y, ancestors_x_y_included, z)</span>
<span class="gi">+    if not ((z - included) &lt;= (x_closure &amp; y_closure)):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>def _reachable(G, x, a, z):
<span class="w"> </span>    &quot;&quot;&quot;Modified Bayes-Ball algorithm for finding d-connected nodes.

<span class="gu">@@ -455,9 +625,61 @@ def _reachable(G, x, a, z):</span>
<span class="w"> </span>       Fourteenth Conference on Uncertainty in Artificial Intelligence
<span class="w"> </span>       (UAI), (pp. 480–487). 1998.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gi">+    def _pass(e, v, f, n):</span>
<span class="gi">+        &quot;&quot;&quot;Whether a ball entering node `v` along edge `e` passes to `n` along `f`.</span>
<span class="gi">+</span>
<span class="gi">+        Boolean function defined on page 6 of [1]_.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        e : bool</span>
<span class="gi">+            Directed edge by which the ball got to node `v`; `True` iff directed into `v`.</span>
<span class="gi">+        v : node</span>
<span class="gi">+            Node where the ball is.</span>
<span class="gi">+        f : bool</span>
<span class="gi">+            Directed edge connecting nodes `v` and `n`; `True` iff directed `n`.</span>
<span class="gi">+        n : node</span>
<span class="gi">+            Checking whether the ball passes to this node.</span>
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        b : bool</span>
<span class="gi">+            Whether the ball passes or not.</span>
<span class="gi">+</span>
<span class="gi">+        References</span>
<span class="gi">+        ----------</span>
<span class="gi">+        .. [1] van der Zander, Benito, and Maciej Liśkiewicz. &quot;Finding</span>
<span class="gi">+           minimal d-separators in linear time and applications.&quot; In</span>
<span class="gi">+           Uncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        is_element_of_A = n in a</span>
<span class="gi">+        # almost_definite_status = True  # always true for DAGs; not so for RCGs</span>
<span class="gi">+        collider_if_in_Z = v not in z or (e and not f)</span>
<span class="gi">+        return is_element_of_A and collider_if_in_Z  # and almost_definite_status</span>
<span class="gi">+</span>
<span class="gi">+    queue = deque([])</span>
<span class="gi">+    for node in x:</span>
<span class="gi">+        if bool(G.pred[node]):</span>
<span class="gi">+            queue.append((True, node))</span>
<span class="gi">+        if bool(G.succ[node]):</span>
<span class="gi">+            queue.append((False, node))</span>
<span class="gi">+    processed = queue.copy()</span>
<span class="gi">+</span>
<span class="gi">+    while any(queue):</span>
<span class="gi">+        e, v = queue.popleft()</span>
<span class="gi">+        preds = ((False, n) for n in G.pred[v])</span>
<span class="gi">+        succs = ((True, n) for n in G.succ[v])</span>
<span class="gi">+        f_n_pairs = chain(preds, succs)</span>
<span class="gi">+        for f, n in f_n_pairs:</span>
<span class="gi">+            if (f, n) not in processed and _pass(e, v, f, n):</span>
<span class="gi">+                queue.append((f, n))</span>
<span class="gi">+                processed.append((f, n))</span>
<span class="gi">+</span>
<span class="gi">+    return {w for (_, w) in processed}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Deprecated functions:</span>
<span class="w"> </span>def d_separated(G, x, y, z):
<span class="w"> </span>    &quot;&quot;&quot;Return whether nodes sets ``x`` and ``y`` are d-separated by ``z``.

<span class="gu">@@ -467,7 +689,15 @@ def d_separated(G, x, y, z):</span>
<span class="w"> </span>        Please use `is_d_separator(G, x, y, z)`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;d_separated is deprecated and will be removed in NetworkX v3.5.&quot;</span>
<span class="gi">+        &quot;Please use `is_d_separator(G, x, y, z)`.&quot;,</span>
<span class="gi">+        category=DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    return nx.is_d_separator(G, x, y, z)</span>


<span class="w"> </span>def minimal_d_separator(G, u, v):
<span class="gu">@@ -479,4 +709,14 @@ def minimal_d_separator(G, u, v):</span>
<span class="w"> </span>        Please use `find_minimal_d_separator(G, x, y)`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;This function is deprecated and will be removed in NetworkX v3.5.&quot;</span>
<span class="gi">+            &quot;Please use `is_d_separator(G, x, y)`.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+        category=DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    return nx.find_minimal_d_separator(G, u, v)</span>
<span class="gh">diff --git a/networkx/algorithms/dag.py b/networkx/algorithms/dag.py</span>
<span class="gh">index 35579494e..a70e2c5ef 100644</span>
<span class="gd">--- a/networkx/algorithms/dag.py</span>
<span class="gi">+++ b/networkx/algorithms/dag.py</span>
<span class="gu">@@ -4,19 +4,35 @@ Note that most of these functions are only guaranteed to work for DAGs.</span>
<span class="w"> </span>In general, these functions do not check for acyclic-ness, so it is up
<span class="w"> </span>to the user to check for that.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import heapq
<span class="w"> </span>from collections import deque
<span class="w"> </span>from functools import partial
<span class="w"> </span>from itertools import chain, combinations, product, starmap
<span class="w"> </span>from math import gcd
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import arbitrary_element, not_implemented_for, pairwise
<span class="gd">-__all__ = [&#39;descendants&#39;, &#39;ancestors&#39;, &#39;topological_sort&#39;,</span>
<span class="gd">-    &#39;lexicographical_topological_sort&#39;, &#39;all_topological_sorts&#39;,</span>
<span class="gd">-    &#39;topological_generations&#39;, &#39;is_directed_acyclic_graph&#39;, &#39;is_aperiodic&#39;,</span>
<span class="gd">-    &#39;transitive_closure&#39;, &#39;transitive_closure_dag&#39;, &#39;transitive_reduction&#39;,</span>
<span class="gd">-    &#39;antichains&#39;, &#39;dag_longest_path&#39;, &#39;dag_longest_path_length&#39;,</span>
<span class="gd">-    &#39;dag_to_branching&#39;, &#39;compute_v_structures&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;descendants&quot;,</span>
<span class="gi">+    &quot;ancestors&quot;,</span>
<span class="gi">+    &quot;topological_sort&quot;,</span>
<span class="gi">+    &quot;lexicographical_topological_sort&quot;,</span>
<span class="gi">+    &quot;all_topological_sorts&quot;,</span>
<span class="gi">+    &quot;topological_generations&quot;,</span>
<span class="gi">+    &quot;is_directed_acyclic_graph&quot;,</span>
<span class="gi">+    &quot;is_aperiodic&quot;,</span>
<span class="gi">+    &quot;transitive_closure&quot;,</span>
<span class="gi">+    &quot;transitive_closure_dag&quot;,</span>
<span class="gi">+    &quot;transitive_reduction&quot;,</span>
<span class="gi">+    &quot;antichains&quot;,</span>
<span class="gi">+    &quot;dag_longest_path&quot;,</span>
<span class="gi">+    &quot;dag_longest_path_length&quot;,</span>
<span class="gi">+    &quot;dag_to_branching&quot;,</span>
<span class="gi">+    &quot;compute_v_structures&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>chaini = chain.from_iterable


<span class="gu">@@ -54,7 +70,7 @@ def descendants(G, source):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    ancestors
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return {child for parent, child in nx.bfs_edges(G, source)}</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -91,13 +107,19 @@ def ancestors(G, source):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    descendants
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return {child for parent, child in nx.bfs_edges(G, source, reverse=True)}</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def has_cycle(G):
<span class="w"> </span>    &quot;&quot;&quot;Decides whether the directed graph has a cycle.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Feed the entire iterator into a zero-length deque.</span>
<span class="gi">+        deque(topological_sort(G), maxlen=0)</span>
<span class="gi">+    except nx.NetworkXUnfeasible:</span>
<span class="gi">+        return True</span>
<span class="gi">+    else:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -138,7 +160,7 @@ def is_directed_acyclic_graph(G):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    topological_sort
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.is_directed() and not has_cycle(G)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -190,7 +212,33 @@ def topological_generations(G):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    topological_sort
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Topological sort not defined on undirected graphs.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    multigraph = G.is_multigraph()</span>
<span class="gi">+    indegree_map = {v: d for v, d in G.in_degree() if d &gt; 0}</span>
<span class="gi">+    zero_indegree = [v for v, d in G.in_degree() if d == 0]</span>
<span class="gi">+</span>
<span class="gi">+    while zero_indegree:</span>
<span class="gi">+        this_generation = zero_indegree</span>
<span class="gi">+        zero_indegree = []</span>
<span class="gi">+        for node in this_generation:</span>
<span class="gi">+            if node not in G:</span>
<span class="gi">+                raise RuntimeError(&quot;Graph changed during iteration&quot;)</span>
<span class="gi">+            for child in G.neighbors(node):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    indegree_map[child] -= len(G[node][child]) if multigraph else 1</span>
<span class="gi">+                except KeyError as err:</span>
<span class="gi">+                    raise RuntimeError(&quot;Graph changed during iteration&quot;) from err</span>
<span class="gi">+                if indegree_map[child] == 0:</span>
<span class="gi">+                    zero_indegree.append(child)</span>
<span class="gi">+                    del indegree_map[child]</span>
<span class="gi">+        yield this_generation</span>
<span class="gi">+</span>
<span class="gi">+    if indegree_map:</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(</span>
<span class="gi">+            &quot;Graph contains a cycle or graph changed during iteration&quot;</span>
<span class="gi">+        )</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -258,7 +306,8 @@ def topological_sort(G):</span>
<span class="w"> </span>    .. [1] Manber, U. (1989).
<span class="w"> </span>       *Introduction to Algorithms - A Creative Approach.* Addison-Wesley.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for generation in nx.topological_generations(G):</span>
<span class="gi">+        yield from generation</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -358,10 +407,52 @@ def lexicographical_topological_sort(G, key=None):</span>
<span class="w"> </span>    .. [1] Manber, U. (1989).
<span class="w"> </span>       *Introduction to Algorithms - A Creative Approach.* Addison-Wesley.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        msg = &quot;Topological sort not defined on undirected graphs.&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    if key is None:</span>
<span class="gi">+</span>
<span class="gi">+        def key(node):</span>
<span class="gi">+            return node</span>
<span class="gi">+</span>
<span class="gi">+    nodeid_map = {n: i for i, n in enumerate(G)}</span>

<span class="gi">+    def create_tuple(node):</span>
<span class="gi">+        return key(node), nodeid_map[node], node</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    indegree_map = {v: d for v, d in G.in_degree() if d &gt; 0}</span>
<span class="gi">+    # These nodes have zero indegree and ready to be returned.</span>
<span class="gi">+    zero_indegree = [create_tuple(v) for v, d in G.in_degree() if d == 0]</span>
<span class="gi">+    heapq.heapify(zero_indegree)</span>
<span class="gi">+</span>
<span class="gi">+    while zero_indegree:</span>
<span class="gi">+        _, _, node = heapq.heappop(zero_indegree)</span>
<span class="gi">+</span>
<span class="gi">+        if node not in G:</span>
<span class="gi">+            raise RuntimeError(&quot;Graph changed during iteration&quot;)</span>
<span class="gi">+        for _, child in G.edges(node):</span>
<span class="gi">+            try:</span>
<span class="gi">+                indegree_map[child] -= 1</span>
<span class="gi">+            except KeyError as err:</span>
<span class="gi">+                raise RuntimeError(&quot;Graph changed during iteration&quot;) from err</span>
<span class="gi">+            if indegree_map[child] == 0:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    heapq.heappush(zero_indegree, create_tuple(child))</span>
<span class="gi">+                except TypeError as err:</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        f&quot;{err}\nConsider using `key=` parameter to resolve ambiguities in the sort order.&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                del indegree_map[child]</span>
<span class="gi">+</span>
<span class="gi">+        yield node</span>
<span class="gi">+</span>
<span class="gi">+    if indegree_map:</span>
<span class="gi">+        msg = &quot;Graph contains a cycle or graph changed during iteration&quot;</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def all_topological_sorts(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns a generator of _all_ topological sorts of the directed graph G.
<span class="gu">@@ -408,7 +499,77 @@ def all_topological_sorts(G):</span>
<span class="w"> </span>       https://doi.org/10.1016/0020-0190(74)90001-5.
<span class="w"> </span>       Elsevier (North-Holland), Amsterdam
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Topological sort not defined on undirected graphs.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # the names of count and D are chosen to match the global variables in [1]</span>
<span class="gi">+    # number of edges originating in a vertex v</span>
<span class="gi">+    count = dict(G.in_degree())</span>
<span class="gi">+    # vertices with indegree 0</span>
<span class="gi">+    D = deque([v for v, d in G.in_degree() if d == 0])</span>
<span class="gi">+    # stack of first value chosen at a position k in the topological sort</span>
<span class="gi">+    bases = []</span>
<span class="gi">+    current_sort = []</span>
<span class="gi">+</span>
<span class="gi">+    # do-while construct</span>
<span class="gi">+    while True:</span>
<span class="gi">+        assert all(count[v] == 0 for v in D)</span>
<span class="gi">+</span>
<span class="gi">+        if len(current_sort) == len(G):</span>
<span class="gi">+            yield list(current_sort)</span>
<span class="gi">+</span>
<span class="gi">+            # clean-up stack</span>
<span class="gi">+            while len(current_sort) &gt; 0:</span>
<span class="gi">+                assert len(bases) == len(current_sort)</span>
<span class="gi">+                q = current_sort.pop()</span>
<span class="gi">+</span>
<span class="gi">+                # &quot;restores&quot; all edges (q, x)</span>
<span class="gi">+                # NOTE: it is important to iterate over edges instead</span>
<span class="gi">+                # of successors, so count is updated correctly in multigraphs</span>
<span class="gi">+                for _, j in G.out_edges(q):</span>
<span class="gi">+                    count[j] += 1</span>
<span class="gi">+                    assert count[j] &gt;= 0</span>
<span class="gi">+                # remove entries from D</span>
<span class="gi">+                while len(D) &gt; 0 and count[D[-1]] &gt; 0:</span>
<span class="gi">+                    D.pop()</span>
<span class="gi">+</span>
<span class="gi">+                # corresponds to a circular shift of the values in D</span>
<span class="gi">+                # if the first value chosen (the base) is in the first</span>
<span class="gi">+                # position of D again, we are done and need to consider the</span>
<span class="gi">+                # previous condition</span>
<span class="gi">+                D.appendleft(q)</span>
<span class="gi">+                if D[-1] == bases[-1]:</span>
<span class="gi">+                    # all possible values have been chosen at current position</span>
<span class="gi">+                    # remove corresponding marker</span>
<span class="gi">+                    bases.pop()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # there are still elements that have not been fixed</span>
<span class="gi">+                    # at the current position in the topological sort</span>
<span class="gi">+                    # stop removing elements, escape inner loop</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            if len(D) == 0:</span>
<span class="gi">+                raise nx.NetworkXUnfeasible(&quot;Graph contains a cycle.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            # choose next node</span>
<span class="gi">+            q = D.pop()</span>
<span class="gi">+            # &quot;erase&quot; all edges (q, x)</span>
<span class="gi">+            # NOTE: it is important to iterate over edges instead</span>
<span class="gi">+            # of successors, so count is updated correctly in multigraphs</span>
<span class="gi">+            for _, j in G.out_edges(q):</span>
<span class="gi">+                count[j] -= 1</span>
<span class="gi">+                assert count[j] &gt;= 0</span>
<span class="gi">+                if count[j] == 0:</span>
<span class="gi">+                    D.append(j)</span>
<span class="gi">+            current_sort.append(q)</span>
<span class="gi">+</span>
<span class="gi">+            # base for current position might _not_ be fixed yet</span>
<span class="gi">+            if len(bases) &lt; len(current_sort):</span>
<span class="gi">+                bases.append(q)</span>
<span class="gi">+</span>
<span class="gi">+        if len(bases) == 0:</span>
<span class="gi">+            break</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -478,7 +639,30 @@ def is_aperiodic(G):</span>
<span class="w"> </span>       in Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:
<span class="w"> </span>       A Multidisciplinary Approach, CRC Press.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;is_aperiodic not defined for undirected graphs&quot;)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;Graph has no nodes.&quot;)</span>
<span class="gi">+    s = arbitrary_element(G)</span>
<span class="gi">+    levels = {s: 0}</span>
<span class="gi">+    this_level = [s]</span>
<span class="gi">+    g = 0</span>
<span class="gi">+    lev = 1</span>
<span class="gi">+    while this_level:</span>
<span class="gi">+        next_level = []</span>
<span class="gi">+        for u in this_level:</span>
<span class="gi">+            for v in G[u]:</span>
<span class="gi">+                if v in levels:  # Non-Tree Edge</span>
<span class="gi">+                    g = gcd(g, levels[u] - levels[v] + 1)</span>
<span class="gi">+                else:  # Tree Edge</span>
<span class="gi">+                    next_level.append(v)</span>
<span class="gi">+                    levels[v] = lev</span>
<span class="gi">+        this_level = next_level</span>
<span class="gi">+        lev += 1</span>
<span class="gi">+    if len(levels) == len(G):  # All nodes in tree</span>
<span class="gi">+        return g == 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        return g == 1 and nx.is_aperiodic(G.subgraph(set(G) - set(levels)))</span>


<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gu">@@ -555,10 +739,25 @@ def transitive_closure(G, reflexive=False):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] https://www.ics.uci.edu/~eppstein/PADS/PartialOrder.py
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    TC = G.copy()</span>
<span class="gi">+</span>
<span class="gi">+    if reflexive not in {None, True, False}:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Incorrect value for the parameter `reflexive`&quot;)</span>

<span class="gi">+    for v in G:</span>
<span class="gi">+        if reflexive is None:</span>
<span class="gi">+            TC.add_edges_from((v, u) for u in nx.descendants(G, v) if u not in TC[v])</span>
<span class="gi">+        elif reflexive is True:</span>
<span class="gi">+            TC.add_edges_from(</span>
<span class="gi">+                (v, u) for u in nx.descendants(G, v) | {v} if u not in TC[v]</span>
<span class="gi">+            )</span>
<span class="gi">+        elif reflexive is False:</span>
<span class="gi">+            TC.add_edges_from((v, e[1]) for e in nx.edge_bfs(G, v) if e[1] not in TC[v])</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    return TC</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="w"> </span>def transitive_closure_dag(G, topo_order=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the transitive closure of a directed acyclic graph.
<span class="gu">@@ -602,10 +801,20 @@ def transitive_closure_dag(G, topo_order=None):</span>
<span class="w"> </span>    This algorithm is probably simple enough to be well-known but I didn&#39;t find
<span class="w"> </span>    a mention in the literature.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if topo_order is None:</span>
<span class="gi">+        topo_order = list(topological_sort(G))</span>
<span class="gi">+</span>
<span class="gi">+    TC = G.copy()</span>
<span class="gi">+</span>
<span class="gi">+    # idea: traverse vertices following a reverse topological order, connecting</span>
<span class="gi">+    # each vertex to its descendants at distance 2 as we go</span>
<span class="gi">+    for v in reversed(topo_order):</span>
<span class="gi">+        TC.add_edges_from((v, u) for u in nx.descendants_at_distance(TC, v, 2))</span>

<span class="gi">+    return TC</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def transitive_reduction(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns transitive reduction of a directed graph
<span class="gu">@@ -656,10 +865,29 @@ def transitive_reduction(G):</span>
<span class="w"> </span>    https://en.wikipedia.org/wiki/Transitive_reduction

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    if not is_directed_acyclic_graph(G):</span>
<span class="gi">+        msg = &quot;Directed Acyclic Graph required for transitive_reduction&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    TR = nx.DiGraph()</span>
<span class="gi">+    TR.add_nodes_from(G.nodes())</span>
<span class="gi">+    descendants = {}</span>
<span class="gi">+    # count before removing set stored in descendants</span>
<span class="gi">+    check_count = dict(G.in_degree)</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        u_nbrs = set(G[u])</span>
<span class="gi">+        for v in G[u]:</span>
<span class="gi">+            if v in u_nbrs:</span>
<span class="gi">+                if v not in descendants:</span>
<span class="gi">+                    descendants[v] = {y for x, y in nx.dfs_edges(G, v)}</span>
<span class="gi">+                u_nbrs -= descendants[v]</span>
<span class="gi">+            check_count[v] -= 1</span>
<span class="gi">+            if check_count[v] == 0:</span>
<span class="gi">+                del descendants[v]</span>
<span class="gi">+        TR.add_edges_from((u, v) for v in u_nbrs)</span>
<span class="gi">+    return TR</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def antichains(G, topo_order=None):
<span class="w"> </span>    &quot;&quot;&quot;Generates antichains from a directed acyclic graph (DAG).
<span class="gu">@@ -707,12 +935,28 @@ def antichains(G, topo_order=None):</span>
<span class="w"> </span>    .. [1] Free Lattices, by R. Freese, J. Jezek and J. B. Nation,
<span class="w"> </span>       AMS, Vol 42, 1995, p. 226.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs={&#39;weight&#39;: &#39;default_weight&#39;})</span>
<span class="gd">-def dag_longest_path(G, weight=&#39;weight&#39;, default_weight=1, topo_order=None):</span>
<span class="gi">+    if topo_order is None:</span>
<span class="gi">+        topo_order = list(nx.topological_sort(G))</span>
<span class="gi">+</span>
<span class="gi">+    TC = nx.transitive_closure_dag(G, topo_order)</span>
<span class="gi">+    antichains_stacks = [([], list(reversed(topo_order)))]</span>
<span class="gi">+</span>
<span class="gi">+    while antichains_stacks:</span>
<span class="gi">+        (antichain, stack) = antichains_stacks.pop()</span>
<span class="gi">+        # Invariant:</span>
<span class="gi">+        #  - the elements of antichain are independent</span>
<span class="gi">+        #  - the elements of stack are independent from those of antichain</span>
<span class="gi">+        yield antichain</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            x = stack.pop()</span>
<span class="gi">+            new_antichain = antichain + [x]</span>
<span class="gi">+            new_stack = [t for t in stack if not ((t in TC[x]) or (x in TC[t]))]</span>
<span class="gi">+            antichains_stacks.append((new_antichain, new_stack))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;weight&quot;: &quot;default_weight&quot;})</span>
<span class="gi">+def dag_longest_path(G, weight=&quot;weight&quot;, default_weight=1, topo_order=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the longest path in a directed acyclic graph (DAG).

<span class="w"> </span>    If `G` has edges with `weight` attribute the edge data are used as
<span class="gu">@@ -768,12 +1012,47 @@ def dag_longest_path(G, weight=&#39;weight&#39;, default_weight=1, topo_order=None):</span>
<span class="w"> </span>    dag_longest_path_length

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs={&#39;weight&#39;: &#39;default_weight&#39;})</span>
<span class="gd">-def dag_longest_path_length(G, weight=&#39;weight&#39;, default_weight=1):</span>
<span class="gi">+    if not G:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    if topo_order is None:</span>
<span class="gi">+        topo_order = nx.topological_sort(G)</span>
<span class="gi">+</span>
<span class="gi">+    dist = {}  # stores {v : (length, u)}</span>
<span class="gi">+    for v in topo_order:</span>
<span class="gi">+        us = [</span>
<span class="gi">+            (</span>
<span class="gi">+                dist[u][0]</span>
<span class="gi">+                + (</span>
<span class="gi">+                    max(data.values(), key=lambda x: x.get(weight, default_weight))</span>
<span class="gi">+                    if G.is_multigraph()</span>
<span class="gi">+                    else data</span>
<span class="gi">+                ).get(weight, default_weight),</span>
<span class="gi">+                u,</span>
<span class="gi">+            )</span>
<span class="gi">+            for u, data in G.pred[v].items()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # Use the best predecessor if there is one and its distance is</span>
<span class="gi">+        # non-negative, otherwise terminate.</span>
<span class="gi">+        maxu = max(us, key=lambda x: x[0]) if us else (0, v)</span>
<span class="gi">+        dist[v] = maxu if maxu[0] &gt;= 0 else (0, v)</span>
<span class="gi">+</span>
<span class="gi">+    u = None</span>
<span class="gi">+    v = max(dist, key=lambda x: dist[x][0])</span>
<span class="gi">+    path = []</span>
<span class="gi">+    while u != v:</span>
<span class="gi">+        path.append(v)</span>
<span class="gi">+        u = v</span>
<span class="gi">+        v = dist[v][1]</span>
<span class="gi">+</span>
<span class="gi">+    path.reverse()</span>
<span class="gi">+    return path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;weight&quot;: &quot;default_weight&quot;})</span>
<span class="gi">+def dag_longest_path_length(G, weight=&quot;weight&quot;, default_weight=1):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the longest path length in a DAG

<span class="w"> </span>    Parameters
<span class="gu">@@ -811,7 +1090,17 @@ def dag_longest_path_length(G, weight=&#39;weight&#39;, default_weight=1):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    dag_longest_path
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = nx.dag_longest_path(G, weight, default_weight)</span>
<span class="gi">+    path_length = 0</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        for u, v in pairwise(path):</span>
<span class="gi">+            i = max(G[u][v], key=lambda x: G[u][v][x].get(weight, default_weight))</span>
<span class="gi">+            path_length += G[u][v][i].get(weight, default_weight)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u, v in pairwise(path):</span>
<span class="gi">+            path_length += G[u][v].get(weight, default_weight)</span>
<span class="gi">+</span>
<span class="gi">+    return path_length</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -826,11 +1115,15 @@ def root_to_leaf_paths(G):</span>
<span class="w"> </span>    any leaf. A path is a list of nodes.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    roots = (v for v, d in G.in_degree() if d == 0)</span>
<span class="gi">+    leaves = (v for v, d in G.out_degree() if d == 0)</span>
<span class="gi">+    all_paths = partial(nx.all_simple_paths, G)</span>
<span class="gi">+    # TODO In Python 3, this would be better as `yield from ...`.</span>
<span class="gi">+    return chaini(starmap(all_paths, product(roots, leaves)))</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def dag_to_branching(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns a branching representing all (overlapping) paths from
<span class="gu">@@ -917,10 +1210,18 @@ def dag_to_branching(G):</span>
<span class="w"> </span>    that function.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    if has_cycle(G):</span>
<span class="gi">+        msg = &quot;dag_to_branching is only defined for acyclic graphs&quot;</span>
<span class="gi">+        raise nx.HasACycle(msg)</span>
<span class="gi">+    paths = root_to_leaf_paths(G)</span>
<span class="gi">+    B = nx.prefix_tree(paths)</span>
<span class="gi">+    # Remove the synthetic `root`(0) and `NIL`(-1) nodes from the tree</span>
<span class="gi">+    B.remove_node(0)</span>
<span class="gi">+    B.remove_node(-1)</span>
<span class="gi">+    return B</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def compute_v_structures(G):
<span class="w"> </span>    &quot;&quot;&quot;Iterate through the graph to compute all v-structures.
<span class="gu">@@ -951,4 +1252,8 @@ def compute_v_structures(G):</span>
<span class="w"> </span>    -----
<span class="w"> </span>    `Wikipedia: Collider in causal graphs &lt;https://en.wikipedia.org/wiki/Collider_(statistics)&gt;`_
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for collider, preds in G.pred.items():</span>
<span class="gi">+        for common_parents in combinations(preds, r=2):</span>
<span class="gi">+            # ensure that the colliders are the same</span>
<span class="gi">+            common_parents = sorted(common_parents)</span>
<span class="gi">+            yield (common_parents[0], collider, common_parents[1])</span>
<span class="gh">diff --git a/networkx/algorithms/distance_measures.py b/networkx/algorithms/distance_measures.py</span>
<span class="gh">index 83efb364d..20c1086d6 100644</span>
<span class="gd">--- a/networkx/algorithms/distance_measures.py</span>
<span class="gi">+++ b/networkx/algorithms/distance_measures.py</span>
<span class="gu">@@ -1,12 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Graph diameter, radius, eccentricity and other properties.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;eccentricity&#39;, &#39;diameter&#39;, &#39;radius&#39;, &#39;periphery&#39;, &#39;center&#39;,</span>
<span class="gd">-    &#39;barycenter&#39;, &#39;resistance_distance&#39;, &#39;kemeny_constant&#39;,</span>
<span class="gd">-    &#39;effective_graph_resistance&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;eccentricity&quot;,</span>
<span class="gi">+    &quot;diameter&quot;,</span>
<span class="gi">+    &quot;radius&quot;,</span>
<span class="gi">+    &quot;periphery&quot;,</span>
<span class="gi">+    &quot;center&quot;,</span>
<span class="gi">+    &quot;barycenter&quot;,</span>
<span class="gi">+    &quot;resistance_distance&quot;,</span>
<span class="gi">+    &quot;kemeny_constant&quot;,</span>
<span class="gi">+    &quot;effective_graph_resistance&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-def _extrema_bounding(G, compute=&#39;diameter&#39;, weight=None):</span>
<span class="gi">+def _extrema_bounding(G, compute=&quot;diameter&quot;, weight=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute requested extreme distance metric of undirected graph G

<span class="w"> </span>    Computation is based on smart lower and upper bounds, and in practice
<span class="gu">@@ -78,10 +88,156 @@ def _extrema_bounding(G, compute=&#39;diameter&#39;, weight=None):</span>
<span class="w"> </span>       Theoretical Computer Science, 2015
<span class="w"> </span>       https://www.sciencedirect.com/science/article/pii/S0304397515001644
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    # init variables</span>
<span class="gi">+    degrees = dict(G.degree())  # start with the highest degree node</span>
<span class="gi">+    minlowernode = max(degrees, key=degrees.get)</span>
<span class="gi">+    N = len(degrees)  # number of nodes</span>
<span class="gi">+    # alternate between smallest lower and largest upper bound</span>
<span class="gi">+    high = False</span>
<span class="gi">+    # status variables</span>
<span class="gi">+    ecc_lower = dict.fromkeys(G, 0)</span>
<span class="gi">+    ecc_upper = dict.fromkeys(G, N)</span>
<span class="gi">+    candidates = set(G)</span>
<span class="gi">+</span>
<span class="gi">+    # (re)set bound extremes</span>
<span class="gi">+    minlower = N</span>
<span class="gi">+    maxlower = 0</span>
<span class="gi">+    minupper = N</span>
<span class="gi">+    maxupper = 0</span>
<span class="gi">+</span>
<span class="gi">+    # repeat the following until there are no more candidates</span>
<span class="gi">+    while candidates:</span>
<span class="gi">+        if high:</span>
<span class="gi">+            current = maxuppernode  # select node with largest upper bound</span>
<span class="gi">+        else:</span>
<span class="gi">+            current = minlowernode  # select node with smallest lower bound</span>
<span class="gi">+        high = not high</span>
<span class="gi">+</span>
<span class="gi">+        # get distances from/to current node and derive eccentricity</span>
<span class="gi">+        dist = nx.shortest_path_length(G, source=current, weight=weight)</span>
<span class="gi">+</span>
<span class="gi">+        if len(dist) != N:</span>
<span class="gi">+            msg = &quot;Cannot compute metric because graph is not connected.&quot;</span>
<span class="gi">+            raise nx.NetworkXError(msg)</span>
<span class="gi">+        current_ecc = max(dist.values())</span>
<span class="gi">+</span>
<span class="gi">+        # print status update</span>
<span class="gi">+        #        print (&quot;ecc of &quot; + str(current) + &quot; (&quot; + str(ecc_lower[current]) + &quot;/&quot;</span>
<span class="gi">+        #        + str(ecc_upper[current]) + &quot;, deg: &quot; + str(dist[current]) + &quot;) is &quot;</span>
<span class="gi">+        #        + str(current_ecc))</span>
<span class="gi">+        #        print(ecc_upper)</span>
<span class="gi">+</span>
<span class="gi">+        # (re)set bound extremes</span>
<span class="gi">+        maxuppernode = None</span>
<span class="gi">+        minlowernode = None</span>
<span class="gi">+</span>
<span class="gi">+        # update node bounds</span>
<span class="gi">+        for i in candidates:</span>
<span class="gi">+            # update eccentricity bounds</span>
<span class="gi">+            d = dist[i]</span>
<span class="gi">+            ecc_lower[i] = low = max(ecc_lower[i], max(d, (current_ecc - d)))</span>
<span class="gi">+            ecc_upper[i] = upp = min(ecc_upper[i], current_ecc + d)</span>
<span class="gi">+</span>
<span class="gi">+            # update min/max values of lower and upper bounds</span>
<span class="gi">+            minlower = min(ecc_lower[i], minlower)</span>
<span class="gi">+            maxlower = max(ecc_lower[i], maxlower)</span>
<span class="gi">+            minupper = min(ecc_upper[i], minupper)</span>
<span class="gi">+            maxupper = max(ecc_upper[i], maxupper)</span>
<span class="gi">+</span>
<span class="gi">+        # update candidate set</span>
<span class="gi">+        if compute == &quot;diameter&quot;:</span>
<span class="gi">+            ruled_out = {</span>
<span class="gi">+                i</span>
<span class="gi">+                for i in candidates</span>
<span class="gi">+                if ecc_upper[i] &lt;= maxlower and 2 * ecc_lower[i] &gt;= maxupper</span>
<span class="gi">+            }</span>
<span class="gi">+        elif compute == &quot;radius&quot;:</span>
<span class="gi">+            ruled_out = {</span>
<span class="gi">+                i</span>
<span class="gi">+                for i in candidates</span>
<span class="gi">+                if ecc_lower[i] &gt;= minupper and ecc_upper[i] + 1 &lt;= 2 * minlower</span>
<span class="gi">+            }</span>
<span class="gi">+        elif compute == &quot;periphery&quot;:</span>
<span class="gi">+            ruled_out = {</span>
<span class="gi">+                i</span>
<span class="gi">+                for i in candidates</span>
<span class="gi">+                if ecc_upper[i] &lt; maxlower</span>
<span class="gi">+                and (maxlower == maxupper or ecc_lower[i] &gt; maxupper)</span>
<span class="gi">+            }</span>
<span class="gi">+        elif compute == &quot;center&quot;:</span>
<span class="gi">+            ruled_out = {</span>
<span class="gi">+                i</span>
<span class="gi">+                for i in candidates</span>
<span class="gi">+                if ecc_lower[i] &gt; minupper</span>
<span class="gi">+                and (minlower == minupper or ecc_upper[i] + 1 &lt; 2 * minlower)</span>
<span class="gi">+            }</span>
<span class="gi">+        elif compute == &quot;eccentricities&quot;:</span>
<span class="gi">+            ruled_out = set()</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = &quot;compute must be one of &#39;diameter&#39;, &#39;radius&#39;, &#39;periphery&#39;, &#39;center&#39;, &#39;eccentricities&#39;&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        ruled_out.update(i for i in candidates if ecc_lower[i] == ecc_upper[i])</span>
<span class="gi">+        candidates -= ruled_out</span>
<span class="gi">+</span>
<span class="gi">+        #        for i in ruled_out:</span>
<span class="gi">+        #            print(&quot;removing %g: ecc_u: %g maxl: %g ecc_l: %g maxu: %g&quot;%</span>
<span class="gi">+        #                    (i,ecc_upper[i],maxlower,ecc_lower[i],maxupper))</span>
<span class="gi">+        #        print(&quot;node %g: ecc_u: %g maxl: %g ecc_l: %g maxu: %g&quot;%</span>
<span class="gi">+        #                    (4,ecc_upper[4],maxlower,ecc_lower[4],maxupper))</span>
<span class="gi">+        #        print(&quot;NODE 4: %g&quot;%(ecc_upper[4] &lt;= maxlower))</span>
<span class="gi">+        #        print(&quot;NODE 4: %g&quot;%(2 * ecc_lower[4] &gt;= maxupper))</span>
<span class="gi">+        #        print(&quot;NODE 4: %g&quot;%(ecc_upper[4] &lt;= maxlower</span>
<span class="gi">+        #                            and 2 * ecc_lower[4] &gt;= maxupper))</span>
<span class="gi">+</span>
<span class="gi">+        # updating maxuppernode and minlowernode for selection in next round</span>
<span class="gi">+        for i in candidates:</span>
<span class="gi">+            if (</span>
<span class="gi">+                minlowernode is None</span>
<span class="gi">+                or (</span>
<span class="gi">+                    ecc_lower[i] == ecc_lower[minlowernode]</span>
<span class="gi">+                    and degrees[i] &gt; degrees[minlowernode]</span>
<span class="gi">+                )</span>
<span class="gi">+                or (ecc_lower[i] &lt; ecc_lower[minlowernode])</span>
<span class="gi">+            ):</span>
<span class="gi">+                minlowernode = i</span>
<span class="gi">+</span>
<span class="gi">+            if (</span>
<span class="gi">+                maxuppernode is None</span>
<span class="gi">+                or (</span>
<span class="gi">+                    ecc_upper[i] == ecc_upper[maxuppernode]</span>
<span class="gi">+                    and degrees[i] &gt; degrees[maxuppernode]</span>
<span class="gi">+                )</span>
<span class="gi">+                or (ecc_upper[i] &gt; ecc_upper[maxuppernode])</span>
<span class="gi">+            ):</span>
<span class="gi">+                maxuppernode = i</span>
<span class="gi">+</span>
<span class="gi">+        # print status update</span>
<span class="gi">+    #        print (&quot; min=&quot; + str(minlower) + &quot;/&quot; + str(minupper) +</span>
<span class="gi">+    #        &quot; max=&quot; + str(maxlower) + &quot;/&quot; + str(maxupper) +</span>
<span class="gi">+    #        &quot; candidates: &quot; + str(len(candidates)))</span>
<span class="gi">+    #        print(&quot;cand:&quot;,candidates)</span>
<span class="gi">+    #        print(&quot;ecc_l&quot;,ecc_lower)</span>
<span class="gi">+    #        print(&quot;ecc_u&quot;,ecc_upper)</span>
<span class="gi">+    #        wait = input(&quot;press Enter to continue&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # return the correct value of the requested metric</span>
<span class="gi">+    if compute == &quot;diameter&quot;:</span>
<span class="gi">+        return maxlower</span>
<span class="gi">+    if compute == &quot;radius&quot;:</span>
<span class="gi">+        return minupper</span>
<span class="gi">+    if compute == &quot;periphery&quot;:</span>
<span class="gi">+        p = [v for v in G if ecc_lower[v] == maxlower]</span>
<span class="gi">+        return p</span>
<span class="gi">+    if compute == &quot;center&quot;:</span>
<span class="gi">+        c = [v for v in G if ecc_upper[v] == minupper]</span>
<span class="gi">+        return c</span>
<span class="gi">+    if compute == &quot;eccentricities&quot;:</span>
<span class="gi">+        return ecc_lower</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def eccentricity(G, v=None, sp=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the eccentricity of nodes in G.

<span class="gu">@@ -134,10 +290,43 @@ def eccentricity(G, v=None, sp=None, weight=None):</span>
<span class="w"> </span>    {1: 2, 5: 3}

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    #    if v is None:                # none, use entire graph</span>
<span class="gi">+    #        nodes=G.nodes()</span>
<span class="gi">+    #    elif v in G:               # is v a single node</span>
<span class="gi">+    #        nodes=[v]</span>
<span class="gi">+    #    else:                      # assume v is a container of nodes</span>
<span class="gi">+    #        nodes=v</span>
<span class="gi">+    order = G.order()</span>
<span class="gi">+    e = {}</span>
<span class="gi">+    for n in G.nbunch_iter(v):</span>
<span class="gi">+        if sp is None:</span>
<span class="gi">+            length = nx.shortest_path_length(G, source=n, weight=weight)</span>
<span class="gi">+</span>
<span class="gi">+            L = len(length)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                length = sp[n]</span>
<span class="gi">+                L = len(length)</span>
<span class="gi">+            except TypeError as err:</span>
<span class="gi">+                raise nx.NetworkXError(&#39;Format of &quot;sp&quot; is invalid.&#39;) from err</span>
<span class="gi">+        if L != order:</span>
<span class="gi">+            if G.is_directed():</span>
<span class="gi">+                msg = (</span>
<span class="gi">+                    &quot;Found infinite path length because the digraph is not&quot;</span>
<span class="gi">+                    &quot; strongly connected&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = &quot;Found infinite path length because the graph is not&quot; &quot; connected&quot;</span>
<span class="gi">+            raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        e[n] = max(length.values())</span>
<span class="gi">+</span>
<span class="gi">+    if v in G:</span>
<span class="gi">+        return e[v]  # return single value</span>
<span class="gi">+    return e</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def diameter(G, e=None, usebounds=False, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the diameter of the graph G.

<span class="gu">@@ -186,10 +375,14 @@ def diameter(G, e=None, usebounds=False, weight=None):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    eccentricity
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if usebounds is True and e is None and not G.is_directed():</span>
<span class="gi">+        return _extrema_bounding(G, compute=&quot;diameter&quot;, weight=weight)</span>
<span class="gi">+    if e is None:</span>
<span class="gi">+        e = eccentricity(G, weight=weight)</span>
<span class="gi">+    return max(e.values())</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def periphery(G, e=None, usebounds=False, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the periphery of the graph G.

<span class="gu">@@ -239,10 +432,16 @@ def periphery(G, e=None, usebounds=False, weight=None):</span>
<span class="w"> </span>    barycenter
<span class="w"> </span>    center
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if usebounds is True and e is None and not G.is_directed():</span>
<span class="gi">+        return _extrema_bounding(G, compute=&quot;periphery&quot;, weight=weight)</span>
<span class="gi">+    if e is None:</span>
<span class="gi">+        e = eccentricity(G, weight=weight)</span>
<span class="gi">+    diameter = max(e.values())</span>
<span class="gi">+    p = [v for v in e if e[v] == diameter]</span>
<span class="gi">+    return p</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def radius(G, e=None, usebounds=False, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the radius of the graph G.

<span class="gu">@@ -288,10 +487,14 @@ def radius(G, e=None, usebounds=False, weight=None):</span>
<span class="w"> </span>    2

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if usebounds is True and e is None and not G.is_directed():</span>
<span class="gi">+        return _extrema_bounding(G, compute=&quot;radius&quot;, weight=weight)</span>
<span class="gi">+    if e is None:</span>
<span class="gi">+        e = eccentricity(G, weight=weight)</span>
<span class="gi">+    return min(e.values())</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def center(G, e=None, usebounds=False, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the center of the graph G.

<span class="gu">@@ -341,12 +544,18 @@ def center(G, e=None, usebounds=False, weight=None):</span>
<span class="w"> </span>    barycenter
<span class="w"> </span>    periphery
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if usebounds is True and e is None and not G.is_directed():</span>
<span class="gi">+        return _extrema_bounding(G, compute=&quot;center&quot;, weight=weight)</span>
<span class="gi">+    if e is None:</span>
<span class="gi">+        e = eccentricity(G, weight=weight)</span>
<span class="gi">+    radius = min(e.values())</span>
<span class="gi">+    p = [v for v in e if e[v] == radius]</span>
<span class="gi">+    return p</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, mutates_input={&#39;attr&#39;: 2})</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, mutates_input={&quot;attr&quot;: 2})</span>
<span class="w"> </span>def barycenter(G, weight=None, attr=None, sp=None):
<span class="gd">-    &quot;&quot;&quot;Calculate barycenter of a connected graph, optionally with edge weights.</span>
<span class="gi">+    r&quot;&quot;&quot;Calculate barycenter of a connected graph, optionally with edge weights.</span>

<span class="w"> </span>    The :dfn:`barycenter` a
<span class="w"> </span>    :func:`connected &lt;networkx.algorithms.components.is_connected&gt;` graph
<span class="gu">@@ -355,7 +564,7 @@ def barycenter(G, weight=None, attr=None, sp=None):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        \\sum_{u \\in V(G)} d_G(u, v),</span>
<span class="gi">+        \sum_{u \in V(G)} d_G(u, v),</span>

<span class="w"> </span>    where :math:`d_G` is the (possibly weighted) :func:`path length
<span class="w"> </span>    &lt;networkx.algorithms.shortest_paths.generic.shortest_path_length&gt;`.
<span class="gu">@@ -399,13 +608,35 @@ def barycenter(G, weight=None, attr=None, sp=None):</span>
<span class="w"> </span>    center
<span class="w"> </span>    periphery
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def resistance_distance(G, nodeA=None, nodeB=None, weight=None,</span>
<span class="gd">-    invert_weight=True):</span>
<span class="gi">+    if sp is None:</span>
<span class="gi">+        sp = nx.shortest_path_length(G, weight=weight)</span>
<span class="gi">+    else:</span>
<span class="gi">+        sp = sp.items()</span>
<span class="gi">+        if weight is not None:</span>
<span class="gi">+            raise ValueError(&quot;Cannot use both sp, weight arguments together&quot;)</span>
<span class="gi">+    smallest, barycenter_vertices, n = float(&quot;inf&quot;), [], len(G)</span>
<span class="gi">+    for v, dists in sp:</span>
<span class="gi">+        if len(dists) &lt; n:</span>
<span class="gi">+            raise nx.NetworkXNoPath(</span>
<span class="gi">+                f&quot;Input graph {G} is disconnected, so every induced subgraph &quot;</span>
<span class="gi">+                &quot;has infinite barycentricity.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        barycentricity = sum(dists.values())</span>
<span class="gi">+        if attr is not None:</span>
<span class="gi">+            G.nodes[v][attr] = barycentricity</span>
<span class="gi">+        if barycentricity &lt; smallest:</span>
<span class="gi">+            smallest = barycentricity</span>
<span class="gi">+            barycenter_vertices = [v]</span>
<span class="gi">+        elif barycentricity == smallest:</span>
<span class="gi">+            barycenter_vertices.append(v)</span>
<span class="gi">+    if attr is not None:</span>
<span class="gi">+        nx._clear_cache(G)</span>
<span class="gi">+    return barycenter_vertices</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def resistance_distance(G, nodeA=None, nodeB=None, weight=None, invert_weight=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the resistance distance between pairs of nodes in graph G.

<span class="w"> </span>    The resistance distance between two nodes of a graph is akin to treating
<span class="gu">@@ -474,11 +705,74 @@ def resistance_distance(G, nodeA=None, nodeB=None, weight=None,</span>
<span class="w"> </span>        Resistance distance.
<span class="w"> </span>        J. of Math. Chem. 12:81-95, 1993.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph G must contain at least one node.&quot;)</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph G must be strongly connected.&quot;)</span>
<span class="gi">+    if nodeA is not None and nodeA not in G:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Node A is not in graph G.&quot;)</span>
<span class="gi">+    if nodeB is not None and nodeB not in G:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Node B is not in graph G.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G = G.copy()</span>
<span class="gi">+    node_list = list(G)</span>
<span class="gi">+</span>
<span class="gi">+    # Invert weights</span>
<span class="gi">+    if invert_weight and weight is not None:</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            for u, v, k, d in G.edges(keys=True, data=True):</span>
<span class="gi">+                d[weight] = 1 / d[weight]</span>
<span class="gi">+        else:</span>
<span class="gi">+            for u, v, d in G.edges(data=True):</span>
<span class="gi">+                d[weight] = 1 / d[weight]</span>
<span class="gi">+</span>
<span class="gi">+    # Compute resistance distance using the Pseudo-inverse of the Laplacian</span>
<span class="gi">+    # Self-loops are ignored</span>
<span class="gi">+    L = nx.laplacian_matrix(G, weight=weight).todense()</span>
<span class="gi">+    Linv = np.linalg.pinv(L, hermitian=True)</span>
<span class="gi">+</span>
<span class="gi">+    # Return relevant distances</span>
<span class="gi">+    if nodeA is not None and nodeB is not None:</span>
<span class="gi">+        i = node_list.index(nodeA)</span>
<span class="gi">+        j = node_list.index(nodeB)</span>
<span class="gi">+        return Linv.item(i, i) + Linv.item(j, j) - Linv.item(i, j) - Linv.item(j, i)</span>
<span class="gi">+</span>
<span class="gi">+    elif nodeA is not None:</span>
<span class="gi">+        i = node_list.index(nodeA)</span>
<span class="gi">+        d = {}</span>
<span class="gi">+        for n in G:</span>
<span class="gi">+            j = node_list.index(n)</span>
<span class="gi">+            d[n] = Linv.item(i, i) + Linv.item(j, j) - Linv.item(i, j) - Linv.item(j, i)</span>
<span class="gi">+        return d</span>
<span class="gi">+</span>
<span class="gi">+    elif nodeB is not None:</span>
<span class="gi">+        j = node_list.index(nodeB)</span>
<span class="gi">+        d = {}</span>
<span class="gi">+        for n in G:</span>
<span class="gi">+            i = node_list.index(n)</span>
<span class="gi">+            d[n] = Linv.item(i, i) + Linv.item(j, j) - Linv.item(i, j) - Linv.item(j, i)</span>
<span class="gi">+        return d</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        d = {}</span>
<span class="gi">+        for n in G:</span>
<span class="gi">+            i = node_list.index(n)</span>
<span class="gi">+            d[n] = {}</span>
<span class="gi">+            for n2 in G:</span>
<span class="gi">+                j = node_list.index(n2)</span>
<span class="gi">+                d[n][n2] = (</span>
<span class="gi">+                    Linv.item(i, i)</span>
<span class="gi">+                    + Linv.item(j, j)</span>
<span class="gi">+                    - Linv.item(i, j)</span>
<span class="gi">+                    - Linv.item(j, i)</span>
<span class="gi">+                )</span>
<span class="gi">+        return d</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def effective_graph_resistance(G, weight=None, invert_weight=True):
<span class="w"> </span>    &quot;&quot;&quot;Returns the Effective graph resistance of G.

<span class="gu">@@ -538,11 +832,35 @@ def effective_graph_resistance(G, weight=None, invert_weight=True):</span>
<span class="w"> </span>        Effective graph resistance.
<span class="w"> </span>        Lin. Alg. Appl. 435:2491-2506, 2011.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph G must contain at least one node.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Disconnected graphs have infinite Effective graph resistance</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        return float(&quot;inf&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Invert weights</span>
<span class="gi">+    G = G.copy()</span>
<span class="gi">+    if invert_weight and weight is not None:</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            for u, v, k, d in G.edges(keys=True, data=True):</span>
<span class="gi">+                d[weight] = 1 / d[weight]</span>
<span class="gi">+        else:</span>
<span class="gi">+            for u, v, d in G.edges(data=True):</span>
<span class="gi">+                d[weight] = 1 / d[weight]</span>
<span class="gi">+</span>
<span class="gi">+    # Get Laplacian eigenvalues</span>
<span class="gi">+    mu = np.sort(nx.laplacian_spectrum(G, weight=weight))</span>
<span class="gi">+</span>
<span class="gi">+    # Compute Effective graph resistance based on spectrum of the Laplacian</span>
<span class="gi">+    # Self-loops are ignored</span>
<span class="gi">+    return float(np.sum(1 / mu[1:]) * G.number_of_nodes())</span>


<span class="gd">-@nx.utils.not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def kemeny_constant(G, *, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the Kemeny constant of the given graph.

<span class="gu">@@ -606,4 +924,28 @@ def kemeny_constant(G, *, weight=None):</span>
<span class="w"> </span>        Paul Erdös is Eighty, vol. 2, Bolyai Society,
<span class="w"> </span>        Mathematical Studies, Keszthely, Hungary (1993), pp. 1-46
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph G must contain at least one node.&quot;)</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph G must be connected.&quot;)</span>
<span class="gi">+    if nx.is_negatively_weighted(G, weight=weight):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;The weights of graph G must be nonnegative.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Compute matrix H = D^-1/2 A D^-1/2</span>
<span class="gi">+    A = nx.adjacency_matrix(G, weight=weight)</span>
<span class="gi">+    n, m = A.shape</span>
<span class="gi">+    diags = A.sum(axis=1)</span>
<span class="gi">+    with np.errstate(divide=&quot;ignore&quot;):</span>
<span class="gi">+        diags_sqrt = 1.0 / np.sqrt(diags)</span>
<span class="gi">+    diags_sqrt[np.isinf(diags_sqrt)] = 0</span>
<span class="gi">+    DH = sp.sparse.csr_array(sp.sparse.spdiags(diags_sqrt, 0, m, n, format=&quot;csr&quot;))</span>
<span class="gi">+    H = DH @ (A @ DH)</span>
<span class="gi">+</span>
<span class="gi">+    # Compute eigenvalues of H</span>
<span class="gi">+    eig = np.sort(sp.linalg.eigvalsh(H.todense()))</span>
<span class="gi">+</span>
<span class="gi">+    # Compute the Kemeny constant</span>
<span class="gi">+    return float(np.sum(1 / (1 - eig[:-1])))</span>
<span class="gh">diff --git a/networkx/algorithms/distance_regular.py b/networkx/algorithms/distance_regular.py</span>
<span class="gh">index bc0a96922..27b4d0216 100644</span>
<span class="gd">--- a/networkx/algorithms/distance_regular.py</span>
<span class="gi">+++ b/networkx/algorithms/distance_regular.py</span>
<span class="gu">@@ -3,11 +3,18 @@</span>
<span class="w"> </span>Distance-regular graphs
<span class="w"> </span>=======================
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gi">+</span>
<span class="w"> </span>from .distance_measures import diameter
<span class="gd">-__all__ = [&#39;is_distance_regular&#39;, &#39;is_strongly_regular&#39;,</span>
<span class="gd">-    &#39;intersection_array&#39;, &#39;global_parameters&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;is_distance_regular&quot;,</span>
<span class="gi">+    &quot;is_strongly_regular&quot;,</span>
<span class="gi">+    &quot;intersection_array&quot;,</span>
<span class="gi">+    &quot;global_parameters&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -51,7 +58,11 @@ def is_distance_regular(G):</span>
<span class="w"> </span>        http://mathworld.wolfram.com/Distance-RegularGraph.html

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        intersection_array(G)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except nx.NetworkXError:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def global_parameters(b, c):
<span class="gu">@@ -95,11 +106,11 @@ def global_parameters(b, c):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    intersection_array
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return ((y, b[0] - x - y, x) for x, y in zip(b + [0], [0] + c))</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def intersection_array(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the intersection array of a distance-regular graph.
<span class="gu">@@ -136,11 +147,43 @@ def intersection_array(G):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    global_parameters
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    # test for regular graph (all degrees must be equal)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;Graph has no nodes.&quot;)</span>
<span class="gi">+    degree = iter(G.degree())</span>
<span class="gi">+    (_, k) = next(degree)</span>
<span class="gi">+    for _, knext in degree:</span>
<span class="gi">+        if knext != k:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Graph is not distance regular.&quot;)</span>
<span class="gi">+        k = knext</span>
<span class="gi">+    path_length = dict(nx.all_pairs_shortest_path_length(G))</span>
<span class="gi">+    diameter = max(max(path_length[n].values()) for n in path_length)</span>
<span class="gi">+    bint = {}  # &#39;b&#39; intersection array</span>
<span class="gi">+    cint = {}  # &#39;c&#39; intersection array</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        for v in G:</span>
<span class="gi">+            try:</span>
<span class="gi">+                i = path_length[u][v]</span>
<span class="gi">+            except KeyError as err:  # graph must be connected</span>
<span class="gi">+                raise nx.NetworkXError(&quot;Graph is not distance regular.&quot;) from err</span>
<span class="gi">+            # number of neighbors of v at a distance of i-1 from u</span>
<span class="gi">+            c = len([n for n in G[v] if path_length[n][u] == i - 1])</span>
<span class="gi">+            # number of neighbors of v at a distance of i+1 from u</span>
<span class="gi">+            b = len([n for n in G[v] if path_length[n][u] == i + 1])</span>
<span class="gi">+            # b,c are independent of u and v</span>
<span class="gi">+            if cint.get(i, c) != c or bint.get(i, b) != b:</span>
<span class="gi">+                raise nx.NetworkXError(&quot;Graph is not distance regular&quot;)</span>
<span class="gi">+            bint[i] = b</span>
<span class="gi">+            cint[i] = c</span>
<span class="gi">+    return (</span>
<span class="gi">+        [bint.get(j, 0) for j in range(diameter)],</span>
<span class="gi">+        [cint.get(j + 1, 0) for j in range(diameter)],</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO There is a definition for directed strongly regular graphs.</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_strongly_regular(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if and only if the given graph is strongly
<span class="gu">@@ -181,4 +224,15 @@ def is_strongly_regular(G):</span>
<span class="w"> </span>        True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Here is an alternate implementation based directly on the</span>
<span class="gi">+    # definition of strongly regular graphs:</span>
<span class="gi">+    #</span>
<span class="gi">+    #     return (all_equal(G.degree().values())</span>
<span class="gi">+    #             and all_equal(len(common_neighbors(G, u, v))</span>
<span class="gi">+    #                           for u, v in G.edges())</span>
<span class="gi">+    #             and all_equal(len(common_neighbors(G, u, v))</span>
<span class="gi">+    #                           for u, v in non_edges(G)))</span>
<span class="gi">+    #</span>
<span class="gi">+    # We instead use the fact that a distance-regular graph of diameter</span>
<span class="gi">+    # two is strongly regular.</span>
<span class="gi">+    return is_distance_regular(G) and diameter(G) == 2</span>
<span class="gh">diff --git a/networkx/algorithms/dominance.py b/networkx/algorithms/dominance.py</span>
<span class="gh">index d0af4785f..ab841fe21 100644</span>
<span class="gd">--- a/networkx/algorithms/dominance.py</span>
<span class="gi">+++ b/networkx/algorithms/dominance.py</span>
<span class="gu">@@ -1,13 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Dominance algorithms.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from functools import reduce
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;immediate_dominators&#39;, &#39;dominance_frontiers&#39;]</span>

<span class="gi">+__all__ = [&quot;immediate_dominators&quot;, &quot;dominance_frontiers&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def immediate_dominators(G, start):
<span class="w"> </span>    &quot;&quot;&quot;Returns the immediate dominators of all nodes of a directed graph.
<span class="gu">@@ -51,7 +54,34 @@ def immediate_dominators(G, start):</span>
<span class="w"> </span>           A simple, fast dominance algorithm.
<span class="w"> </span>           Software Practice &amp; Experience, 4:110, 2001.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if start not in G:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;start is not in G&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    idom = {start: start}</span>
<span class="gi">+</span>
<span class="gi">+    order = list(nx.dfs_postorder_nodes(G, start))</span>
<span class="gi">+    dfn = {u: i for i, u in enumerate(order)}</span>
<span class="gi">+    order.pop()</span>
<span class="gi">+    order.reverse()</span>
<span class="gi">+</span>
<span class="gi">+    def intersect(u, v):</span>
<span class="gi">+        while u != v:</span>
<span class="gi">+            while dfn[u] &lt; dfn[v]:</span>
<span class="gi">+                u = idom[u]</span>
<span class="gi">+            while dfn[u] &gt; dfn[v]:</span>
<span class="gi">+                v = idom[v]</span>
<span class="gi">+        return u</span>
<span class="gi">+</span>
<span class="gi">+    changed = True</span>
<span class="gi">+    while changed:</span>
<span class="gi">+        changed = False</span>
<span class="gi">+        for u in order:</span>
<span class="gi">+            new_idom = reduce(intersect, (v for v in G.pred[u] if v in idom))</span>
<span class="gi">+            if u not in idom or idom[u] != new_idom:</span>
<span class="gi">+                idom[u] = new_idom</span>
<span class="gi">+                changed = True</span>
<span class="gi">+</span>
<span class="gi">+    return idom</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -92,4 +122,14 @@ def dominance_frontiers(G, start):</span>
<span class="w"> </span>           A simple, fast dominance algorithm.
<span class="w"> </span>           Software Practice &amp; Experience, 4:110, 2001.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    idom = nx.immediate_dominators(G, start)</span>
<span class="gi">+</span>
<span class="gi">+    df = {u: set() for u in idom}</span>
<span class="gi">+    for u in idom:</span>
<span class="gi">+        if len(G.pred[u]) &gt;= 2:</span>
<span class="gi">+            for v in G.pred[u]:</span>
<span class="gi">+                if v in idom:</span>
<span class="gi">+                    while v != idom[u]:</span>
<span class="gi">+                        df[v].add(u)</span>
<span class="gi">+                        v = idom[v]</span>
<span class="gi">+    return df</span>
<span class="gh">diff --git a/networkx/algorithms/dominating.py b/networkx/algorithms/dominating.py</span>
<span class="gh">index bb1ca38c9..8e9a458f8 100644</span>
<span class="gd">--- a/networkx/algorithms/dominating.py</span>
<span class="gi">+++ b/networkx/algorithms/dominating.py</span>
<span class="gu">@@ -1,13 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing dominating sets in a graph.&quot;&quot;&quot;
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import arbitrary_element
<span class="gd">-__all__ = [&#39;dominating_set&#39;, &#39;is_dominating_set&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;dominating_set&quot;, &quot;is_dominating_set&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def dominating_set(G, start_with=None):
<span class="gd">-    &quot;&quot;&quot;Finds a dominating set for the graph G.</span>
<span class="gi">+    r&quot;&quot;&quot;Finds a dominating set for the graph G.</span>

<span class="w"> </span>    A *dominating set* for a graph with node set *V* is a subset *D* of
<span class="w"> </span>    *V* such that every node not in *D* is adjacent to at least one
<span class="gu">@@ -42,7 +44,25 @@ def dominating_set(G, start_with=None):</span>
<span class="w"> </span>        http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    all_nodes = set(G)</span>
<span class="gi">+    if start_with is None:</span>
<span class="gi">+        start_with = arbitrary_element(all_nodes)</span>
<span class="gi">+    if start_with not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {start_with} is not in G&quot;)</span>
<span class="gi">+    dominating_set = {start_with}</span>
<span class="gi">+    dominated_nodes = set(G[start_with])</span>
<span class="gi">+    remaining_nodes = all_nodes - dominated_nodes - dominating_set</span>
<span class="gi">+    while remaining_nodes:</span>
<span class="gi">+        # Choose an arbitrary node and determine its undominated neighbors.</span>
<span class="gi">+        v = remaining_nodes.pop()</span>
<span class="gi">+        undominated_nbrs = set(G[v]) - dominating_set</span>
<span class="gi">+        # Add the node to the dominating set and the neighbors to the</span>
<span class="gi">+        # dominated set. Finally, remove all of those nodes from the set</span>
<span class="gi">+        # of remaining nodes.</span>
<span class="gi">+        dominating_set.add(v)</span>
<span class="gi">+        dominated_nodes |= undominated_nbrs</span>
<span class="gi">+        remaining_nodes -= undominated_nbrs</span>
<span class="gi">+    return dominating_set</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -69,4 +89,6 @@ def is_dominating_set(G, nbunch):</span>
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Dominating_set

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    testset = {n for n in nbunch if n in G}</span>
<span class="gi">+    nbrs = set(chain.from_iterable(G[n] for n in testset))</span>
<span class="gi">+    return len(set(G) - testset - nbrs) == 0</span>
<span class="gh">diff --git a/networkx/algorithms/efficiency_measures.py b/networkx/algorithms/efficiency_measures.py</span>
<span class="gh">index 48ec5ddf3..2c99b0114 100644</span>
<span class="gd">--- a/networkx/algorithms/efficiency_measures.py</span>
<span class="gi">+++ b/networkx/algorithms/efficiency_measures.py</span>
<span class="gu">@@ -1,11 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Provides functions for computing the efficiency of nodes and graphs.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXNoPath
<span class="gi">+</span>
<span class="w"> </span>from ..utils import not_implemented_for
<span class="gd">-__all__ = [&#39;efficiency&#39;, &#39;local_efficiency&#39;, &#39;global_efficiency&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;efficiency&quot;, &quot;local_efficiency&quot;, &quot;global_efficiency&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def efficiency(G, u, v):
<span class="w"> </span>    &quot;&quot;&quot;Returns the efficiency of a pair of nodes in a graph.
<span class="gu">@@ -49,10 +52,14 @@ def efficiency(G, u, v):</span>
<span class="w"> </span>           &lt;https://doi.org/10.1103/PhysRevLett.87.198701&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        eff = 1 / nx.shortest_path_length(G, u, v)</span>
<span class="gi">+    except NetworkXNoPath:</span>
<span class="gi">+        eff = 0</span>
<span class="gi">+    return eff</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def global_efficiency(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the average global efficiency of the graph.
<span class="gu">@@ -94,10 +101,26 @@ def global_efficiency(G):</span>
<span class="w"> </span>           &lt;https://doi.org/10.1103/PhysRevLett.87.198701&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    denom = n * (n - 1)</span>
<span class="gi">+    if denom != 0:</span>
<span class="gi">+        lengths = nx.all_pairs_shortest_path_length(G)</span>
<span class="gi">+        g_eff = 0</span>
<span class="gi">+        for source, targets in lengths:</span>
<span class="gi">+            for target, distance in targets.items():</span>
<span class="gi">+                if distance &gt; 0:</span>
<span class="gi">+                    g_eff += 1 / distance</span>
<span class="gi">+        g_eff /= denom</span>
<span class="gi">+        # g_eff = sum(1 / d for s, tgts in lengths</span>
<span class="gi">+        #                   for t, d in tgts.items() if d &gt; 0) / denom</span>
<span class="gi">+    else:</span>
<span class="gi">+        g_eff = 0</span>
<span class="gi">+    # TODO This can be made more efficient by computing all pairs shortest</span>
<span class="gi">+    # path lengths in parallel.</span>
<span class="gi">+    return g_eff</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def local_efficiency(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the average local efficiency of the graph.
<span class="gu">@@ -140,4 +163,6 @@ def local_efficiency(G):</span>
<span class="w"> </span>           &lt;https://doi.org/10.1103/PhysRevLett.87.198701&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO This summation can be trivially parallelized.</span>
<span class="gi">+    efficiency_list = (global_efficiency(G.subgraph(G[v])) for v in G)</span>
<span class="gi">+    return sum(efficiency_list) / len(G)</span>
<span class="gh">diff --git a/networkx/algorithms/euler.py b/networkx/algorithms/euler.py</span>
<span class="gh">index 032874645..2e0e57358 100644</span>
<span class="gd">--- a/networkx/algorithms/euler.py</span>
<span class="gi">+++ b/networkx/algorithms/euler.py</span>
<span class="gu">@@ -2,10 +2,19 @@</span>
<span class="w"> </span>Eulerian circuits and graphs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from itertools import combinations
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from ..utils import arbitrary_element, not_implemented_for
<span class="gd">-__all__ = [&#39;is_eulerian&#39;, &#39;eulerian_circuit&#39;, &#39;eulerize&#39;, &#39;is_semieulerian&#39;,</span>
<span class="gd">-    &#39;has_eulerian_path&#39;, &#39;eulerian_path&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;is_eulerian&quot;,</span>
<span class="gi">+    &quot;eulerian_circuit&quot;,</span>
<span class="gi">+    &quot;eulerize&quot;,</span>
<span class="gi">+    &quot;is_semieulerian&quot;,</span>
<span class="gi">+    &quot;has_eulerian_path&quot;,</span>
<span class="gi">+    &quot;eulerian_path&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -49,7 +58,15 @@ def is_eulerian(G):</span>


<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        # Every node must have equal in degree and out degree and the</span>
<span class="gi">+        # graph must be strongly connected</span>
<span class="gi">+        return all(</span>
<span class="gi">+            G.in_degree(n) == G.out_degree(n) for n in G</span>
<span class="gi">+        ) and nx.is_strongly_connected(G)</span>
<span class="gi">+    # An undirected Eulerian graph has no vertices of odd degree and</span>
<span class="gi">+    # must be connected.</span>
<span class="gi">+    return all(d % 2 == 0 for v, d in G.degree()) and nx.is_connected(G)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -63,7 +80,7 @@ def is_semieulerian(G):</span>
<span class="w"> </span>    has_eulerian_path
<span class="w"> </span>    is_eulerian
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return has_eulerian_path(G) and not is_eulerian(G)</span>


<span class="w"> </span>def _find_path_start(G):
<span class="gu">@@ -71,7 +88,70 @@ def _find_path_start(G):</span>

<span class="w"> </span>    If no path exists, return None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not has_eulerian_path(G):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if is_eulerian(G):</span>
<span class="gi">+        return arbitrary_element(G)</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        v1, v2 = (v for v in G if G.in_degree(v) != G.out_degree(v))</span>
<span class="gi">+        # Determines which is the &#39;start&#39; node (as opposed to the &#39;end&#39;)</span>
<span class="gi">+        if G.out_degree(v1) &gt; G.in_degree(v1):</span>
<span class="gi">+            return v1</span>
<span class="gi">+        else:</span>
<span class="gi">+            return v2</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        # In an undirected graph randomly choose one of the possibilities</span>
<span class="gi">+        start = [v for v in G if G.degree(v) % 2 != 0][0]</span>
<span class="gi">+        return start</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _simplegraph_eulerian_circuit(G, source):</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        degree = G.out_degree</span>
<span class="gi">+        edges = G.out_edges</span>
<span class="gi">+    else:</span>
<span class="gi">+        degree = G.degree</span>
<span class="gi">+        edges = G.edges</span>
<span class="gi">+    vertex_stack = [source]</span>
<span class="gi">+    last_vertex = None</span>
<span class="gi">+    while vertex_stack:</span>
<span class="gi">+        current_vertex = vertex_stack[-1]</span>
<span class="gi">+        if degree(current_vertex) == 0:</span>
<span class="gi">+            if last_vertex is not None:</span>
<span class="gi">+                yield (last_vertex, current_vertex)</span>
<span class="gi">+            last_vertex = current_vertex</span>
<span class="gi">+            vertex_stack.pop()</span>
<span class="gi">+        else:</span>
<span class="gi">+            _, next_vertex = arbitrary_element(edges(current_vertex))</span>
<span class="gi">+            vertex_stack.append(next_vertex)</span>
<span class="gi">+            G.remove_edge(current_vertex, next_vertex)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _multigraph_eulerian_circuit(G, source):</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        degree = G.out_degree</span>
<span class="gi">+        edges = G.out_edges</span>
<span class="gi">+    else:</span>
<span class="gi">+        degree = G.degree</span>
<span class="gi">+        edges = G.edges</span>
<span class="gi">+    vertex_stack = [(source, None)]</span>
<span class="gi">+    last_vertex = None</span>
<span class="gi">+    last_key = None</span>
<span class="gi">+    while vertex_stack:</span>
<span class="gi">+        current_vertex, current_key = vertex_stack[-1]</span>
<span class="gi">+        if degree(current_vertex) == 0:</span>
<span class="gi">+            if last_vertex is not None:</span>
<span class="gi">+                yield (last_vertex, current_vertex, last_key)</span>
<span class="gi">+            last_vertex, last_key = current_vertex, current_key</span>
<span class="gi">+            vertex_stack.pop()</span>
<span class="gi">+        else:</span>
<span class="gi">+            triple = arbitrary_element(edges(current_vertex, keys=True))</span>
<span class="gi">+            _, next_vertex, next_key = triple</span>
<span class="gi">+            vertex_stack.append((next_vertex, next_key))</span>
<span class="gi">+            G.remove_edge(current_vertex, next_vertex, next_key)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -137,7 +217,22 @@ def eulerian_circuit(G, source=None, keys=False):</span>
<span class="w"> </span>        [0, 2, 1]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not is_eulerian(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;G is not Eulerian.&quot;)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        G = G.reverse()</span>
<span class="gi">+    else:</span>
<span class="gi">+        G = G.copy()</span>
<span class="gi">+    if source is None:</span>
<span class="gi">+        source = arbitrary_element(G)</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        for u, v, k in _multigraph_eulerian_circuit(G, source):</span>
<span class="gi">+            if keys:</span>
<span class="gi">+                yield u, v, k</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield u, v</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield from _simplegraph_eulerian_circuit(G, source)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -203,7 +298,36 @@ def has_eulerian_path(G, source=None):</span>
<span class="w"> </span>    is_eulerian
<span class="w"> </span>    eulerian_path
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nx.is_eulerian(G):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        ins = G.in_degree</span>
<span class="gi">+        outs = G.out_degree</span>
<span class="gi">+        # Since we know it is not eulerian, outs - ins must be 1 for source</span>
<span class="gi">+        if source is not None and outs[source] - ins[source] != 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        unbalanced_ins = 0</span>
<span class="gi">+        unbalanced_outs = 0</span>
<span class="gi">+        for v in G:</span>
<span class="gi">+            if ins[v] - outs[v] == 1:</span>
<span class="gi">+                unbalanced_ins += 1</span>
<span class="gi">+            elif outs[v] - ins[v] == 1:</span>
<span class="gi">+                unbalanced_outs += 1</span>
<span class="gi">+            elif ins[v] != outs[v]:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            unbalanced_ins &lt;= 1 and unbalanced_outs &lt;= 1 and nx.is_weakly_connected(G)</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        # We know it is not eulerian, so degree of source must be odd.</span>
<span class="gi">+        if source is not None and G.degree[source] % 2 != 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Sum is 2 since we know it is not eulerian (which implies sum is 0)</span>
<span class="gi">+        return sum(d % 2 == 1 for v, d in G.degree()) == 2 and nx.is_connected(G)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -228,10 +352,40 @@ def eulerian_path(G, source=None, keys=False):</span>
<span class="w"> </span>    Warning: If `source` provided is not the start node of an Euler path
<span class="w"> </span>    will raise error even if an Euler Path exists.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    if not has_eulerian_path(G, source):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph has no Eulerian paths.&quot;)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        G = G.reverse()</span>
<span class="gi">+        if source is None or nx.is_eulerian(G) is False:</span>
<span class="gi">+            source = _find_path_start(G)</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            for u, v, k in _multigraph_eulerian_circuit(G, source):</span>
<span class="gi">+                if keys:</span>
<span class="gi">+                    yield u, v, k</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield u, v</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield from _simplegraph_eulerian_circuit(G, source)</span>
<span class="gi">+    else:</span>
<span class="gi">+        G = G.copy()</span>
<span class="gi">+        if source is None:</span>
<span class="gi">+            source = _find_path_start(G)</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            if keys:</span>
<span class="gi">+                yield from reversed(</span>
<span class="gi">+                    [(v, u, k) for u, v, k in _multigraph_eulerian_circuit(G, source)]</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield from reversed(</span>
<span class="gi">+                    [(v, u) for u, v, k in _multigraph_eulerian_circuit(G, source)]</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield from reversed(</span>
<span class="gi">+                [(v, u) for u, v in _simplegraph_eulerian_circuit(G, source)]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def eulerize(G):
<span class="w"> </span>    &quot;&quot;&quot;Transforms a graph into an Eulerian graph.
<span class="gu">@@ -274,4 +428,42 @@ def eulerize(G):</span>
<span class="w"> </span>        True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.order() == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;Cannot Eulerize null graph&quot;)</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;G is not connected&quot;)</span>
<span class="gi">+    odd_degree_nodes = [n for n, d in G.degree() if d % 2 == 1]</span>
<span class="gi">+    G = nx.MultiGraph(G)</span>
<span class="gi">+    if len(odd_degree_nodes) == 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    # get all shortest paths between vertices of odd degree</span>
<span class="gi">+    odd_deg_pairs_paths = [</span>
<span class="gi">+        (m, {n: nx.shortest_path(G, source=m, target=n)})</span>
<span class="gi">+        for m, n in combinations(odd_degree_nodes, 2)</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # use the number of vertices in a graph + 1 as an upper bound on</span>
<span class="gi">+    # the maximum length of a path in G</span>
<span class="gi">+    upper_bound_on_max_path_length = len(G) + 1</span>
<span class="gi">+</span>
<span class="gi">+    # use &quot;len(G) + 1 - len(P)&quot;,</span>
<span class="gi">+    # where P is a shortest path between vertices n and m,</span>
<span class="gi">+    # as edge-weights in a new graph</span>
<span class="gi">+    # store the paths in the graph for easy indexing later</span>
<span class="gi">+    Gp = nx.Graph()</span>
<span class="gi">+    for n, Ps in odd_deg_pairs_paths:</span>
<span class="gi">+        for m, P in Ps.items():</span>
<span class="gi">+            if n != m:</span>
<span class="gi">+                Gp.add_edge(</span>
<span class="gi">+                    m, n, weight=upper_bound_on_max_path_length - len(P), path=P</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    # find the minimum weight matching of edges in the weighted graph</span>
<span class="gi">+    best_matching = nx.Graph(list(nx.max_weight_matching(Gp)))</span>
<span class="gi">+</span>
<span class="gi">+    # duplicate each edge along each path in the set of paths in Gp</span>
<span class="gi">+    for m, n in best_matching.edges():</span>
<span class="gi">+        path = Gp[m][n][&quot;path&quot;]</span>
<span class="gi">+        G.add_edges_from(nx.utils.pairwise(path))</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/algorithms/flow/boykovkolmogorov.py b/networkx/algorithms/flow/boykovkolmogorov.py</span>
<span class="gh">index 749df42e4..87290a928 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/boykovkolmogorov.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/boykovkolmogorov.py</span>
<span class="gu">@@ -3,15 +3,18 @@ Boykov-Kolmogorov algorithm for maximum flow problems.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections import deque
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.flow.utils import build_residual_network
<span class="gd">-__all__ = [&#39;boykov_kolmogorov&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;boykov_kolmogorov&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)}, returns_graph=True)</span>
<span class="gd">-def boykov_kolmogorov(G, s, t, capacity=&#39;capacity&#39;, residual=None,</span>
<span class="gd">-    value_only=False, cutoff=None):</span>
<span class="gd">-    &quot;&quot;&quot;Find a maximum single-commodity flow using Boykov-Kolmogorov algorithm.</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)}, returns_graph=True)</span>
<span class="gi">+def boykov_kolmogorov(</span>
<span class="gi">+    G, s, t, capacity=&quot;capacity&quot;, residual=None, value_only=False, cutoff=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Find a maximum single-commodity flow using Boykov-Kolmogorov algorithm.</span>

<span class="w"> </span>    This function returns the residual network resulting after computing
<span class="w"> </span>    the maximum flow. See below for details about the conventions
<span class="gu">@@ -151,4 +154,216 @@ def boykov_kolmogorov(G, s, t, capacity=&#39;capacity&#39;, residual=None,</span>
<span class="w"> </span>           https://web.archive.org/web/20170809091249/https://pub.ist.ac.at/~vnk/papers/thesis.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = boykov_kolmogorov_impl(G, s, t, capacity, residual, cutoff)</span>
<span class="gi">+    R.graph[&quot;algorithm&quot;] = &quot;boykov_kolmogorov&quot;</span>
<span class="gi">+    nx._clear_cache(R)</span>
<span class="gi">+    return R</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def boykov_kolmogorov_impl(G, s, t, capacity, residual, cutoff):</span>
<span class="gi">+    if s not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(s)} not in graph&quot;)</span>
<span class="gi">+    if t not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(t)} not in graph&quot;)</span>
<span class="gi">+    if s == t:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;source and sink are the same node&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if residual is None:</span>
<span class="gi">+        R = build_residual_network(G, capacity)</span>
<span class="gi">+    else:</span>
<span class="gi">+        R = residual</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize/reset the residual network.</span>
<span class="gi">+    # This is way too slow</span>
<span class="gi">+    # nx.set_edge_attributes(R, 0, &#39;flow&#39;)</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        for e in R[u].values():</span>
<span class="gi">+            e[&quot;flow&quot;] = 0</span>
<span class="gi">+</span>
<span class="gi">+    # Use an arbitrary high value as infinite. It is computed</span>
<span class="gi">+    # when building the residual network.</span>
<span class="gi">+    INF = R.graph[&quot;inf&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    if cutoff is None:</span>
<span class="gi">+        cutoff = INF</span>
<span class="gi">+</span>
<span class="gi">+    R_succ = R.succ</span>
<span class="gi">+    R_pred = R.pred</span>
<span class="gi">+</span>
<span class="gi">+    def grow():</span>
<span class="gi">+        &quot;&quot;&quot;Bidirectional breadth-first search for the growth stage.</span>
<span class="gi">+</span>
<span class="gi">+        Returns a connecting edge, that is and edge that connects</span>
<span class="gi">+        a node from the source search tree with a node from the</span>
<span class="gi">+        target search tree.</span>
<span class="gi">+        The first node in the connecting edge is always from the</span>
<span class="gi">+        source tree and the last node from the target tree.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        while active:</span>
<span class="gi">+            u = active[0]</span>
<span class="gi">+            if u in source_tree:</span>
<span class="gi">+                this_tree = source_tree</span>
<span class="gi">+                other_tree = target_tree</span>
<span class="gi">+                neighbors = R_succ</span>
<span class="gi">+            else:</span>
<span class="gi">+                this_tree = target_tree</span>
<span class="gi">+                other_tree = source_tree</span>
<span class="gi">+                neighbors = R_pred</span>
<span class="gi">+            for v, attr in neighbors[u].items():</span>
<span class="gi">+                if attr[&quot;capacity&quot;] - attr[&quot;flow&quot;] &gt; 0:</span>
<span class="gi">+                    if v not in this_tree:</span>
<span class="gi">+                        if v in other_tree:</span>
<span class="gi">+                            return (u, v) if this_tree is source_tree else (v, u)</span>
<span class="gi">+                        this_tree[v] = u</span>
<span class="gi">+                        dist[v] = dist[u] + 1</span>
<span class="gi">+                        timestamp[v] = timestamp[u]</span>
<span class="gi">+                        active.append(v)</span>
<span class="gi">+                    elif v in this_tree and _is_closer(u, v):</span>
<span class="gi">+                        this_tree[v] = u</span>
<span class="gi">+                        dist[v] = dist[u] + 1</span>
<span class="gi">+                        timestamp[v] = timestamp[u]</span>
<span class="gi">+            _ = active.popleft()</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    def augment(u, v):</span>
<span class="gi">+        &quot;&quot;&quot;Augmentation stage.</span>
<span class="gi">+</span>
<span class="gi">+        Reconstruct path and determine its residual capacity.</span>
<span class="gi">+        We start from a connecting edge, which links a node</span>
<span class="gi">+        from the source tree to a node from the target tree.</span>
<span class="gi">+        The connecting edge is the output of the grow function</span>
<span class="gi">+        and the input of this function.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        attr = R_succ[u][v]</span>
<span class="gi">+        flow = min(INF, attr[&quot;capacity&quot;] - attr[&quot;flow&quot;])</span>
<span class="gi">+        path = [u]</span>
<span class="gi">+        # Trace a path from u to s in source_tree.</span>
<span class="gi">+        w = u</span>
<span class="gi">+        while w != s:</span>
<span class="gi">+            n = w</span>
<span class="gi">+            w = source_tree[n]</span>
<span class="gi">+            attr = R_pred[n][w]</span>
<span class="gi">+            flow = min(flow, attr[&quot;capacity&quot;] - attr[&quot;flow&quot;])</span>
<span class="gi">+            path.append(w)</span>
<span class="gi">+        path.reverse()</span>
<span class="gi">+        # Trace a path from v to t in target_tree.</span>
<span class="gi">+        path.append(v)</span>
<span class="gi">+        w = v</span>
<span class="gi">+        while w != t:</span>
<span class="gi">+            n = w</span>
<span class="gi">+            w = target_tree[n]</span>
<span class="gi">+            attr = R_succ[n][w]</span>
<span class="gi">+            flow = min(flow, attr[&quot;capacity&quot;] - attr[&quot;flow&quot;])</span>
<span class="gi">+            path.append(w)</span>
<span class="gi">+        # Augment flow along the path and check for saturated edges.</span>
<span class="gi">+        it = iter(path)</span>
<span class="gi">+        u = next(it)</span>
<span class="gi">+        these_orphans = []</span>
<span class="gi">+        for v in it:</span>
<span class="gi">+            R_succ[u][v][&quot;flow&quot;] += flow</span>
<span class="gi">+            R_succ[v][u][&quot;flow&quot;] -= flow</span>
<span class="gi">+            if R_succ[u][v][&quot;flow&quot;] == R_succ[u][v][&quot;capacity&quot;]:</span>
<span class="gi">+                if v in source_tree:</span>
<span class="gi">+                    source_tree[v] = None</span>
<span class="gi">+                    these_orphans.append(v)</span>
<span class="gi">+                if u in target_tree:</span>
<span class="gi">+                    target_tree[u] = None</span>
<span class="gi">+                    these_orphans.append(u)</span>
<span class="gi">+            u = v</span>
<span class="gi">+        orphans.extend(sorted(these_orphans, key=dist.get))</span>
<span class="gi">+        return flow</span>
<span class="gi">+</span>
<span class="gi">+    def adopt():</span>
<span class="gi">+        &quot;&quot;&quot;Adoption stage.</span>
<span class="gi">+</span>
<span class="gi">+        Reconstruct search trees by adopting or discarding orphans.</span>
<span class="gi">+        During augmentation stage some edges got saturated and thus</span>
<span class="gi">+        the source and target search trees broke down to forests, with</span>
<span class="gi">+        orphans as roots of some of its trees. We have to reconstruct</span>
<span class="gi">+        the search trees rooted to source and target before we can grow</span>
<span class="gi">+        them again.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        while orphans:</span>
<span class="gi">+            u = orphans.popleft()</span>
<span class="gi">+            if u in source_tree:</span>
<span class="gi">+                tree = source_tree</span>
<span class="gi">+                neighbors = R_pred</span>
<span class="gi">+            else:</span>
<span class="gi">+                tree = target_tree</span>
<span class="gi">+                neighbors = R_succ</span>
<span class="gi">+            nbrs = ((n, attr, dist[n]) for n, attr in neighbors[u].items() if n in tree)</span>
<span class="gi">+            for v, attr, d in sorted(nbrs, key=itemgetter(2)):</span>
<span class="gi">+                if attr[&quot;capacity&quot;] - attr[&quot;flow&quot;] &gt; 0:</span>
<span class="gi">+                    if _has_valid_root(v, tree):</span>
<span class="gi">+                        tree[u] = v</span>
<span class="gi">+                        dist[u] = dist[v] + 1</span>
<span class="gi">+                        timestamp[u] = time</span>
<span class="gi">+                        break</span>
<span class="gi">+            else:</span>
<span class="gi">+                nbrs = (</span>
<span class="gi">+                    (n, attr, dist[n]) for n, attr in neighbors[u].items() if n in tree</span>
<span class="gi">+                )</span>
<span class="gi">+                for v, attr, d in sorted(nbrs, key=itemgetter(2)):</span>
<span class="gi">+                    if attr[&quot;capacity&quot;] - attr[&quot;flow&quot;] &gt; 0:</span>
<span class="gi">+                        if v not in active:</span>
<span class="gi">+                            active.append(v)</span>
<span class="gi">+                    if tree[v] == u:</span>
<span class="gi">+                        tree[v] = None</span>
<span class="gi">+                        orphans.appendleft(v)</span>
<span class="gi">+                if u in active:</span>
<span class="gi">+                    active.remove(u)</span>
<span class="gi">+                del tree[u]</span>
<span class="gi">+</span>
<span class="gi">+    def _has_valid_root(n, tree):</span>
<span class="gi">+        path = []</span>
<span class="gi">+        v = n</span>
<span class="gi">+        while v is not None:</span>
<span class="gi">+            path.append(v)</span>
<span class="gi">+            if v in (s, t):</span>
<span class="gi">+                base_dist = 0</span>
<span class="gi">+                break</span>
<span class="gi">+            elif timestamp[v] == time:</span>
<span class="gi">+                base_dist = dist[v]</span>
<span class="gi">+                break</span>
<span class="gi">+            v = tree[v]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False</span>
<span class="gi">+        length = len(path)</span>
<span class="gi">+        for i, u in enumerate(path, 1):</span>
<span class="gi">+            dist[u] = base_dist + length - i</span>
<span class="gi">+            timestamp[u] = time</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def _is_closer(u, v):</span>
<span class="gi">+        return timestamp[v] &lt;= timestamp[u] and dist[v] &gt; dist[u] + 1</span>
<span class="gi">+</span>
<span class="gi">+    source_tree = {s: None}</span>
<span class="gi">+    target_tree = {t: None}</span>
<span class="gi">+    active = deque([s, t])</span>
<span class="gi">+    orphans = deque()</span>
<span class="gi">+    flow_value = 0</span>
<span class="gi">+    # data structures for the marking heuristic</span>
<span class="gi">+    time = 1</span>
<span class="gi">+    timestamp = {s: time, t: time}</span>
<span class="gi">+    dist = {s: 0, t: 0}</span>
<span class="gi">+    while flow_value &lt; cutoff:</span>
<span class="gi">+        # Growth stage</span>
<span class="gi">+        u, v = grow()</span>
<span class="gi">+        if u is None:</span>
<span class="gi">+            break</span>
<span class="gi">+        time += 1</span>
<span class="gi">+        # Augmentation stage</span>
<span class="gi">+        flow_value += augment(u, v)</span>
<span class="gi">+        # Adoption stage</span>
<span class="gi">+        adopt()</span>
<span class="gi">+</span>
<span class="gi">+    if flow_value * 2 &gt; INF:</span>
<span class="gi">+        raise nx.NetworkXUnbounded(&quot;Infinite capacity path, flow unbounded above.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Add source and target tree in a graph attribute.</span>
<span class="gi">+    # A partition that defines a minimum cut can be directly</span>
<span class="gi">+    # computed from the search trees as explained in the docstrings.</span>
<span class="gi">+    R.graph[&quot;trees&quot;] = (source_tree, target_tree)</span>
<span class="gi">+    # Add the standard flow_value graph attribute.</span>
<span class="gi">+    R.graph[&quot;flow_value&quot;] = flow_value</span>
<span class="gi">+    return R</span>
<span class="gh">diff --git a/networkx/algorithms/flow/capacityscaling.py b/networkx/algorithms/flow/capacityscaling.py</span>
<span class="gh">index e05a60b82..bf68565c5 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/capacityscaling.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/capacityscaling.py</span>
<span class="gu">@@ -1,34 +1,161 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Capacity scaling minimum cost flow algorithm.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;capacity_scaling&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;capacity_scaling&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from math import log
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from ...utils import BinaryHeap, arbitrary_element, not_implemented_for


<span class="w"> </span>def _detect_unboundedness(R):
<span class="w"> </span>    &quot;&quot;&quot;Detect infinite-capacity negative cycles.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.DiGraph()</span>
<span class="gi">+    G.add_nodes_from(R)</span>
<span class="gi">+</span>
<span class="gi">+    # Value simulating infinity.</span>
<span class="gi">+    inf = R.graph[&quot;inf&quot;]</span>
<span class="gi">+    # True infinity.</span>
<span class="gi">+    f_inf = float(&quot;inf&quot;)</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        for v, e in R[u].items():</span>
<span class="gi">+            # Compute the minimum weight of infinite-capacity (u, v) edges.</span>
<span class="gi">+            w = f_inf</span>
<span class="gi">+            for k, e in e.items():</span>
<span class="gi">+                if e[&quot;capacity&quot;] == inf:</span>
<span class="gi">+                    w = min(w, e[&quot;weight&quot;])</span>
<span class="gi">+            if w != f_inf:</span>
<span class="gi">+                G.add_edge(u, v, weight=w)</span>

<span class="gi">+    if nx.negative_edge_cycle(G):</span>
<span class="gi">+        raise nx.NetworkXUnbounded(</span>
<span class="gi">+            &quot;Negative cost cycle of infinite capacity found. &quot;</span>
<span class="gi">+            &quot;Min cost flow may be unbounded below.&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>def _build_residual_network(G, demand, capacity, weight):
<span class="w"> </span>    &quot;&quot;&quot;Build a residual network and initialize a zero flow.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sum(G.nodes[u].get(demand, 0) for u in G) != 0:</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(&quot;Sum of the demands should be 0.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    R = nx.MultiDiGraph()</span>
<span class="gi">+    R.add_nodes_from(</span>
<span class="gi">+        (u, {&quot;excess&quot;: -G.nodes[u].get(demand, 0), &quot;potential&quot;: 0}) for u in G</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    inf = float(&quot;inf&quot;)</span>
<span class="gi">+    # Detect selfloops with infinite capacities and negative weights.</span>
<span class="gi">+    for u, v, e in nx.selfloop_edges(G, data=True):</span>
<span class="gi">+        if e.get(weight, 0) &lt; 0 and e.get(capacity, inf) == inf:</span>
<span class="gi">+            raise nx.NetworkXUnbounded(</span>
<span class="gi">+                &quot;Negative cost cycle of infinite capacity found. &quot;</span>
<span class="gi">+                &quot;Min cost flow may be unbounded below.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # Extract edges with positive capacities. Self loops excluded.</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        edge_list = [</span>
<span class="gi">+            (u, v, k, e)</span>
<span class="gi">+            for u, v, k, e in G.edges(data=True, keys=True)</span>
<span class="gi">+            if u != v and e.get(capacity, inf) &gt; 0</span>
<span class="gi">+        ]</span>
<span class="gi">+    else:</span>
<span class="gi">+        edge_list = [</span>
<span class="gi">+            (u, v, 0, e)</span>
<span class="gi">+            for u, v, e in G.edges(data=True)</span>
<span class="gi">+            if u != v and e.get(capacity, inf) &gt; 0</span>
<span class="gi">+        ]</span>
<span class="gi">+    # Simulate infinity with the larger of the sum of absolute node imbalances</span>
<span class="gi">+    # the sum of finite edge capacities or any positive value if both sums are</span>
<span class="gi">+    # zero. This allows the infinite-capacity edges to be distinguished for</span>
<span class="gi">+    # unboundedness detection and directly participate in residual capacity</span>
<span class="gi">+    # calculation.</span>
<span class="gi">+    inf = (</span>
<span class="gi">+        max(</span>
<span class="gi">+            sum(abs(R.nodes[u][&quot;excess&quot;]) for u in R),</span>
<span class="gi">+            2</span>
<span class="gi">+            * sum(</span>
<span class="gi">+                e[capacity]</span>
<span class="gi">+                for u, v, k, e in edge_list</span>
<span class="gi">+                if capacity in e and e[capacity] != inf</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+        or 1</span>
<span class="gi">+    )</span>
<span class="gi">+    for u, v, k, e in edge_list:</span>
<span class="gi">+        r = min(e.get(capacity, inf), inf)</span>
<span class="gi">+        w = e.get(weight, 0)</span>
<span class="gi">+        # Add both (u, v) and (v, u) into the residual network marked with the</span>
<span class="gi">+        # original key. (key[1] == True) indicates the (u, v) is in the</span>
<span class="gi">+        # original network.</span>
<span class="gi">+        R.add_edge(u, v, key=(k, True), capacity=r, weight=w, flow=0)</span>
<span class="gi">+        R.add_edge(v, u, key=(k, False), capacity=0, weight=-w, flow=0)</span>
<span class="gi">+</span>
<span class="gi">+    # Record the value simulating infinity.</span>
<span class="gi">+    R.graph[&quot;inf&quot;] = inf</span>
<span class="gi">+</span>
<span class="gi">+    _detect_unboundedness(R)</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>


<span class="w"> </span>def _build_flow_dict(G, R, capacity, weight):
<span class="w"> </span>    &quot;&quot;&quot;Build a flow dictionary from a residual network.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    inf = float(&quot;inf&quot;)</span>
<span class="gi">+    flow_dict = {}</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        for u in G:</span>
<span class="gi">+            flow_dict[u] = {}</span>
<span class="gi">+            for v, es in G[u].items():</span>
<span class="gi">+                flow_dict[u][v] = {</span>
<span class="gi">+                    # Always saturate negative selfloops.</span>
<span class="gi">+                    k: (</span>
<span class="gi">+                        0</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            u != v or e.get(capacity, inf) &lt;= 0 or e.get(weight, 0) &gt;= 0</span>
<span class="gi">+                        )</span>
<span class="gi">+                        else e[capacity]</span>
<span class="gi">+                    )</span>
<span class="gi">+                    for k, e in es.items()</span>
<span class="gi">+                }</span>
<span class="gi">+            for v, es in R[u].items():</span>
<span class="gi">+                if v in flow_dict[u]:</span>
<span class="gi">+                    flow_dict[u][v].update(</span>
<span class="gi">+                        (k[0], e[&quot;flow&quot;]) for k, e in es.items() if e[&quot;flow&quot;] &gt; 0</span>
<span class="gi">+                    )</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u in G:</span>
<span class="gi">+            flow_dict[u] = {</span>
<span class="gi">+                # Always saturate negative selfloops.</span>
<span class="gi">+                v: (</span>
<span class="gi">+                    0</span>
<span class="gi">+                    if (u != v or e.get(capacity, inf) &lt;= 0 or e.get(weight, 0) &gt;= 0)</span>
<span class="gi">+                    else e[capacity]</span>
<span class="gi">+                )</span>
<span class="gi">+                for v, e in G[u].items()</span>
<span class="gi">+            }</span>
<span class="gi">+            flow_dict[u].update(</span>
<span class="gi">+                (v, e[&quot;flow&quot;])</span>
<span class="gi">+                for v, es in R[u].items()</span>
<span class="gi">+                for e in es.values()</span>
<span class="gi">+                if e[&quot;flow&quot;] &gt; 0</span>
<span class="gi">+            )</span>
<span class="gi">+    return flow_dict</span>


<span class="gd">-@nx._dispatchable(node_attrs=&#39;demand&#39;, edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;),</span>
<span class="gd">-    &#39;weight&#39;: 0})</span>
<span class="gd">-def capacity_scaling(G, demand=&#39;demand&#39;, capacity=&#39;capacity&#39;, weight=</span>
<span class="gd">-    &#39;weight&#39;, heap=BinaryHeap):</span>
<span class="gd">-    &quot;&quot;&quot;Find a minimum cost flow satisfying all demands in digraph G.</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    node_attrs=&quot;demand&quot;, edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;), &quot;weight&quot;: 0}</span>
<span class="gi">+)</span>
<span class="gi">+def capacity_scaling(</span>
<span class="gi">+    G, demand=&quot;demand&quot;, capacity=&quot;capacity&quot;, weight=&quot;weight&quot;, heap=BinaryHeap</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Find a minimum cost flow satisfying all demands in digraph G.</span>

<span class="w"> </span>    This is a capacity scaling successive shortest augmenting path algorithm.

<span class="gu">@@ -155,4 +282,126 @@ def capacity_scaling(G, demand=&#39;demand&#39;, capacity=&#39;capacity&#39;, weight=</span>
<span class="w"> </span>    &gt;&gt;&gt; flowDict
<span class="w"> </span>    {&#39;p&#39;: {&#39;q&#39;: 2, &#39;a&#39;: 2}, &#39;q&#39;: {&#39;d&#39;: 1}, &#39;a&#39;: {&#39;t&#39;: 4}, &#39;d&#39;: {&#39;w&#39;: 2}, &#39;t&#39;: {&#39;q&#39;: 1, &#39;w&#39;: 1}, &#39;w&#39;: {}}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = _build_residual_network(G, demand, capacity, weight)</span>
<span class="gi">+</span>
<span class="gi">+    inf = float(&quot;inf&quot;)</span>
<span class="gi">+    # Account cost of negative selfloops.</span>
<span class="gi">+    flow_cost = sum(</span>
<span class="gi">+        0</span>
<span class="gi">+        if e.get(capacity, inf) &lt;= 0 or e.get(weight, 0) &gt;= 0</span>
<span class="gi">+        else e[capacity] * e[weight]</span>
<span class="gi">+        for u, v, e in nx.selfloop_edges(G, data=True)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Determine the maximum edge capacity.</span>
<span class="gi">+    wmax = max(chain([-inf], (e[&quot;capacity&quot;] for u, v, e in R.edges(data=True))))</span>
<span class="gi">+    if wmax == -inf:</span>
<span class="gi">+        # Residual network has no edges.</span>
<span class="gi">+        return flow_cost, _build_flow_dict(G, R, capacity, weight)</span>
<span class="gi">+</span>
<span class="gi">+    R_nodes = R.nodes</span>
<span class="gi">+    R_succ = R.succ</span>
<span class="gi">+</span>
<span class="gi">+    delta = 2 ** int(log(wmax, 2))</span>
<span class="gi">+    while delta &gt;= 1:</span>
<span class="gi">+        # Saturate Δ-residual edges with negative reduced costs to achieve</span>
<span class="gi">+        # Δ-optimality.</span>
<span class="gi">+        for u in R:</span>
<span class="gi">+            p_u = R_nodes[u][&quot;potential&quot;]</span>
<span class="gi">+            for v, es in R_succ[u].items():</span>
<span class="gi">+                for k, e in es.items():</span>
<span class="gi">+                    flow = e[&quot;capacity&quot;] - e[&quot;flow&quot;]</span>
<span class="gi">+                    if e[&quot;weight&quot;] - p_u + R_nodes[v][&quot;potential&quot;] &lt; 0:</span>
<span class="gi">+                        flow = e[&quot;capacity&quot;] - e[&quot;flow&quot;]</span>
<span class="gi">+                        if flow &gt;= delta:</span>
<span class="gi">+                            e[&quot;flow&quot;] += flow</span>
<span class="gi">+                            R_succ[v][u][(k[0], not k[1])][&quot;flow&quot;] -= flow</span>
<span class="gi">+                            R_nodes[u][&quot;excess&quot;] -= flow</span>
<span class="gi">+                            R_nodes[v][&quot;excess&quot;] += flow</span>
<span class="gi">+        # Determine the Δ-active nodes.</span>
<span class="gi">+        S = set()</span>
<span class="gi">+        T = set()</span>
<span class="gi">+        S_add = S.add</span>
<span class="gi">+        S_remove = S.remove</span>
<span class="gi">+        T_add = T.add</span>
<span class="gi">+        T_remove = T.remove</span>
<span class="gi">+        for u in R:</span>
<span class="gi">+            excess = R_nodes[u][&quot;excess&quot;]</span>
<span class="gi">+            if excess &gt;= delta:</span>
<span class="gi">+                S_add(u)</span>
<span class="gi">+            elif excess &lt;= -delta:</span>
<span class="gi">+                T_add(u)</span>
<span class="gi">+        # Repeatedly augment flow from S to T along shortest paths until</span>
<span class="gi">+        # Δ-feasibility is achieved.</span>
<span class="gi">+        while S and T:</span>
<span class="gi">+            s = arbitrary_element(S)</span>
<span class="gi">+            t = None</span>
<span class="gi">+            # Search for a shortest path in terms of reduce costs from s to</span>
<span class="gi">+            # any t in T in the Δ-residual network.</span>
<span class="gi">+            d = {}</span>
<span class="gi">+            pred = {s: None}</span>
<span class="gi">+            h = heap()</span>
<span class="gi">+            h_insert = h.insert</span>
<span class="gi">+            h_get = h.get</span>
<span class="gi">+            h_insert(s, 0)</span>
<span class="gi">+            while h:</span>
<span class="gi">+                u, d_u = h.pop()</span>
<span class="gi">+                d[u] = d_u</span>
<span class="gi">+                if u in T:</span>
<span class="gi">+                    # Path found.</span>
<span class="gi">+                    t = u</span>
<span class="gi">+                    break</span>
<span class="gi">+                p_u = R_nodes[u][&quot;potential&quot;]</span>
<span class="gi">+                for v, es in R_succ[u].items():</span>
<span class="gi">+                    if v in d:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    wmin = inf</span>
<span class="gi">+                    # Find the minimum-weighted (u, v) Δ-residual edge.</span>
<span class="gi">+                    for k, e in es.items():</span>
<span class="gi">+                        if e[&quot;capacity&quot;] - e[&quot;flow&quot;] &gt;= delta:</span>
<span class="gi">+                            w = e[&quot;weight&quot;]</span>
<span class="gi">+                            if w &lt; wmin:</span>
<span class="gi">+                                wmin = w</span>
<span class="gi">+                                kmin = k</span>
<span class="gi">+                                emin = e</span>
<span class="gi">+                    if wmin == inf:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    # Update the distance label of v.</span>
<span class="gi">+                    d_v = d_u + wmin - p_u + R_nodes[v][&quot;potential&quot;]</span>
<span class="gi">+                    if h_insert(v, d_v):</span>
<span class="gi">+                        pred[v] = (u, kmin, emin)</span>
<span class="gi">+            if t is not None:</span>
<span class="gi">+                # Augment Δ units of flow from s to t.</span>
<span class="gi">+                while u != s:</span>
<span class="gi">+                    v = u</span>
<span class="gi">+                    u, k, e = pred[v]</span>
<span class="gi">+                    e[&quot;flow&quot;] += delta</span>
<span class="gi">+                    R_succ[v][u][(k[0], not k[1])][&quot;flow&quot;] -= delta</span>
<span class="gi">+                # Account node excess and deficit.</span>
<span class="gi">+                R_nodes[s][&quot;excess&quot;] -= delta</span>
<span class="gi">+                R_nodes[t][&quot;excess&quot;] += delta</span>
<span class="gi">+                if R_nodes[s][&quot;excess&quot;] &lt; delta:</span>
<span class="gi">+                    S_remove(s)</span>
<span class="gi">+                if R_nodes[t][&quot;excess&quot;] &gt; -delta:</span>
<span class="gi">+                    T_remove(t)</span>
<span class="gi">+                # Update node potentials.</span>
<span class="gi">+                d_t = d[t]</span>
<span class="gi">+                for u, d_u in d.items():</span>
<span class="gi">+                    R_nodes[u][&quot;potential&quot;] -= d_u - d_t</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Path not found.</span>
<span class="gi">+                S_remove(s)</span>
<span class="gi">+        delta //= 2</span>
<span class="gi">+</span>
<span class="gi">+    if any(R.nodes[u][&quot;excess&quot;] != 0 for u in R):</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(&quot;No flow satisfying all demands.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate the flow cost.</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        for v, es in R_succ[u].items():</span>
<span class="gi">+            for e in es.values():</span>
<span class="gi">+                flow = e[&quot;flow&quot;]</span>
<span class="gi">+                if flow &gt; 0:</span>
<span class="gi">+                    flow_cost += flow * e[&quot;weight&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    return flow_cost, _build_flow_dict(G, R, capacity, weight)</span>
<span class="gh">diff --git a/networkx/algorithms/flow/dinitz_alg.py b/networkx/algorithms/flow/dinitz_alg.py</span>
<span class="gh">index 533a4a45a..bcc08fe48 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/dinitz_alg.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/dinitz_alg.py</span>
<span class="gu">@@ -2,15 +2,16 @@</span>
<span class="w"> </span>Dinitz&#39; algorithm for maximum flow problems.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections import deque
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.flow.utils import build_residual_network
<span class="w"> </span>from networkx.utils import pairwise
<span class="gd">-__all__ = [&#39;dinitz&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;dinitz&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)}, returns_graph=True)</span>
<span class="gd">-def dinitz(G, s, t, capacity=&#39;capacity&#39;, residual=None, value_only=False,</span>
<span class="gd">-    cutoff=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)}, returns_graph=True)</span>
<span class="gi">+def dinitz(G, s, t, capacity=&quot;capacity&quot;, residual=None, value_only=False, cutoff=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Find a maximum single-commodity flow using Dinitz&#39; algorithm.

<span class="w"> </span>    This function returns the residual network resulting after computing
<span class="gu">@@ -132,4 +133,105 @@ def dinitz(G, s, t, capacity=&#39;capacity&#39;, residual=None, value_only=False,</span>
<span class="w"> </span>           https://doi.org/10.1007/11685654_10

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = dinitz_impl(G, s, t, capacity, residual, cutoff)</span>
<span class="gi">+    R.graph[&quot;algorithm&quot;] = &quot;dinitz&quot;</span>
<span class="gi">+    nx._clear_cache(R)</span>
<span class="gi">+    return R</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def dinitz_impl(G, s, t, capacity, residual, cutoff):</span>
<span class="gi">+    if s not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(s)} not in graph&quot;)</span>
<span class="gi">+    if t not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(t)} not in graph&quot;)</span>
<span class="gi">+    if s == t:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;source and sink are the same node&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if residual is None:</span>
<span class="gi">+        R = build_residual_network(G, capacity)</span>
<span class="gi">+    else:</span>
<span class="gi">+        R = residual</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize/reset the residual network.</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        for e in R[u].values():</span>
<span class="gi">+            e[&quot;flow&quot;] = 0</span>
<span class="gi">+</span>
<span class="gi">+    # Use an arbitrary high value as infinite. It is computed</span>
<span class="gi">+    # when building the residual network.</span>
<span class="gi">+    INF = R.graph[&quot;inf&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    if cutoff is None:</span>
<span class="gi">+        cutoff = INF</span>
<span class="gi">+</span>
<span class="gi">+    R_succ = R.succ</span>
<span class="gi">+    R_pred = R.pred</span>
<span class="gi">+</span>
<span class="gi">+    def breath_first_search():</span>
<span class="gi">+        parents = {}</span>
<span class="gi">+        vertex_dist = {s: 0}</span>
<span class="gi">+        queue = deque([(s, 0)])</span>
<span class="gi">+        # Record all the potential edges of shortest augmenting paths</span>
<span class="gi">+        while queue:</span>
<span class="gi">+            if t in parents:</span>
<span class="gi">+                break</span>
<span class="gi">+            u, dist = queue.popleft()</span>
<span class="gi">+            for v, attr in R_succ[u].items():</span>
<span class="gi">+                if attr[&quot;capacity&quot;] - attr[&quot;flow&quot;] &gt; 0:</span>
<span class="gi">+                    if v in parents:</span>
<span class="gi">+                        if vertex_dist[v] == dist + 1:</span>
<span class="gi">+                            parents[v].append(u)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        parents[v] = deque([u])</span>
<span class="gi">+                        vertex_dist[v] = dist + 1</span>
<span class="gi">+                        queue.append((v, dist + 1))</span>
<span class="gi">+        return parents</span>
<span class="gi">+</span>
<span class="gi">+    def depth_first_search(parents):</span>
<span class="gi">+        # DFS to find all the shortest augmenting paths</span>
<span class="gi">+        &quot;&quot;&quot;Build a path using DFS starting from the sink&quot;&quot;&quot;</span>
<span class="gi">+        total_flow = 0</span>
<span class="gi">+        u = t</span>
<span class="gi">+        # path also functions as a stack</span>
<span class="gi">+        path = [u]</span>
<span class="gi">+        # The loop ends with no augmenting path left in the layered graph</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if len(parents[u]) &gt; 0:</span>
<span class="gi">+                v = parents[u][0]</span>
<span class="gi">+                path.append(v)</span>
<span class="gi">+            else:</span>
<span class="gi">+                path.pop()</span>
<span class="gi">+                if len(path) == 0:</span>
<span class="gi">+                    break</span>
<span class="gi">+                v = path[-1]</span>
<span class="gi">+                parents[v].popleft()</span>
<span class="gi">+            # Augment the flow along the path found</span>
<span class="gi">+            if v == s:</span>
<span class="gi">+                flow = INF</span>
<span class="gi">+                for u, v in pairwise(path):</span>
<span class="gi">+                    flow = min(flow, R_pred[u][v][&quot;capacity&quot;] - R_pred[u][v][&quot;flow&quot;])</span>
<span class="gi">+                for u, v in pairwise(reversed(path)):</span>
<span class="gi">+                    R_pred[v][u][&quot;flow&quot;] += flow</span>
<span class="gi">+                    R_pred[u][v][&quot;flow&quot;] -= flow</span>
<span class="gi">+                    # Find the proper node to continue the search</span>
<span class="gi">+                    if R_pred[v][u][&quot;capacity&quot;] - R_pred[v][u][&quot;flow&quot;] == 0:</span>
<span class="gi">+                        parents[v].popleft()</span>
<span class="gi">+                        while path[-1] != v:</span>
<span class="gi">+                            path.pop()</span>
<span class="gi">+                total_flow += flow</span>
<span class="gi">+                v = path[-1]</span>
<span class="gi">+            u = v</span>
<span class="gi">+        return total_flow</span>
<span class="gi">+</span>
<span class="gi">+    flow_value = 0</span>
<span class="gi">+    while flow_value &lt; cutoff:</span>
<span class="gi">+        parents = breath_first_search()</span>
<span class="gi">+        if t not in parents:</span>
<span class="gi">+            break</span>
<span class="gi">+        this_flow = depth_first_search(parents)</span>
<span class="gi">+        if this_flow * 2 &gt; INF:</span>
<span class="gi">+            raise nx.NetworkXUnbounded(&quot;Infinite capacity path, flow unbounded above.&quot;)</span>
<span class="gi">+        flow_value += this_flow</span>
<span class="gi">+</span>
<span class="gi">+    R.graph[&quot;flow_value&quot;] = flow_value</span>
<span class="gi">+    return R</span>
<span class="gh">diff --git a/networkx/algorithms/flow/edmondskarp.py b/networkx/algorithms/flow/edmondskarp.py</span>
<span class="gh">index d89ce70a0..500632683 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/edmondskarp.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/edmondskarp.py</span>
<span class="gu">@@ -1,24 +1,126 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Edmonds-Karp algorithm for maximum flow problems.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.flow.utils import build_residual_network
<span class="gd">-__all__ = [&#39;edmonds_karp&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;edmonds_karp&quot;]</span>


<span class="w"> </span>def edmonds_karp_core(R, s, t, cutoff):
<span class="w"> </span>    &quot;&quot;&quot;Implementation of the Edmonds-Karp algorithm.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R_nodes = R.nodes</span>
<span class="gi">+    R_pred = R.pred</span>
<span class="gi">+    R_succ = R.succ</span>
<span class="gi">+</span>
<span class="gi">+    inf = R.graph[&quot;inf&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def augment(path):</span>
<span class="gi">+        &quot;&quot;&quot;Augment flow along a path from s to t.&quot;&quot;&quot;</span>
<span class="gi">+        # Determine the path residual capacity.</span>
<span class="gi">+        flow = inf</span>
<span class="gi">+        it = iter(path)</span>
<span class="gi">+        u = next(it)</span>
<span class="gi">+        for v in it:</span>
<span class="gi">+            attr = R_succ[u][v]</span>
<span class="gi">+            flow = min(flow, attr[&quot;capacity&quot;] - attr[&quot;flow&quot;])</span>
<span class="gi">+            u = v</span>
<span class="gi">+        if flow * 2 &gt; inf:</span>
<span class="gi">+            raise nx.NetworkXUnbounded(&quot;Infinite capacity path, flow unbounded above.&quot;)</span>
<span class="gi">+        # Augment flow along the path.</span>
<span class="gi">+        it = iter(path)</span>
<span class="gi">+        u = next(it)</span>
<span class="gi">+        for v in it:</span>
<span class="gi">+            R_succ[u][v][&quot;flow&quot;] += flow</span>
<span class="gi">+            R_succ[v][u][&quot;flow&quot;] -= flow</span>
<span class="gi">+            u = v</span>
<span class="gi">+        return flow</span>
<span class="gi">+</span>
<span class="gi">+    def bidirectional_bfs():</span>
<span class="gi">+        &quot;&quot;&quot;Bidirectional breadth-first search for an augmenting path.&quot;&quot;&quot;</span>
<span class="gi">+        pred = {s: None}</span>
<span class="gi">+        q_s = [s]</span>
<span class="gi">+        succ = {t: None}</span>
<span class="gi">+        q_t = [t]</span>
<span class="gi">+        while True:</span>
<span class="gi">+            q = []</span>
<span class="gi">+            if len(q_s) &lt;= len(q_t):</span>
<span class="gi">+                for u in q_s:</span>
<span class="gi">+                    for v, attr in R_succ[u].items():</span>
<span class="gi">+                        if v not in pred and attr[&quot;flow&quot;] &lt; attr[&quot;capacity&quot;]:</span>
<span class="gi">+                            pred[v] = u</span>
<span class="gi">+                            if v in succ:</span>
<span class="gi">+                                return v, pred, succ</span>
<span class="gi">+                            q.append(v)</span>
<span class="gi">+                if not q:</span>
<span class="gi">+                    return None, None, None</span>
<span class="gi">+                q_s = q</span>
<span class="gi">+            else:</span>
<span class="gi">+                for u in q_t:</span>
<span class="gi">+                    for v, attr in R_pred[u].items():</span>
<span class="gi">+                        if v not in succ and attr[&quot;flow&quot;] &lt; attr[&quot;capacity&quot;]:</span>
<span class="gi">+                            succ[v] = u</span>
<span class="gi">+                            if v in pred:</span>
<span class="gi">+                                return v, pred, succ</span>
<span class="gi">+                            q.append(v)</span>
<span class="gi">+                if not q:</span>
<span class="gi">+                    return None, None, None</span>
<span class="gi">+                q_t = q</span>
<span class="gi">+</span>
<span class="gi">+    # Look for shortest augmenting paths using breadth-first search.</span>
<span class="gi">+    flow_value = 0</span>
<span class="gi">+    while flow_value &lt; cutoff:</span>
<span class="gi">+        v, pred, succ = bidirectional_bfs()</span>
<span class="gi">+        if pred is None:</span>
<span class="gi">+            break</span>
<span class="gi">+        path = [v]</span>
<span class="gi">+        # Trace a path from s to v.</span>
<span class="gi">+        u = v</span>
<span class="gi">+        while u != s:</span>
<span class="gi">+            u = pred[u]</span>
<span class="gi">+            path.append(u)</span>
<span class="gi">+        path.reverse()</span>
<span class="gi">+        # Trace a path from v to t.</span>
<span class="gi">+        u = v</span>
<span class="gi">+        while u != t:</span>
<span class="gi">+            u = succ[u]</span>
<span class="gi">+            path.append(u)</span>
<span class="gi">+        flow_value += augment(path)</span>
<span class="gi">+</span>
<span class="gi">+    return flow_value</span>


<span class="w"> </span>def edmonds_karp_impl(G, s, t, capacity, residual, cutoff):
<span class="w"> </span>    &quot;&quot;&quot;Implementation of the Edmonds-Karp algorithm.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)}, returns_graph=True)</span>
<span class="gd">-def edmonds_karp(G, s, t, capacity=&#39;capacity&#39;, residual=None, value_only=</span>
<span class="gd">-    False, cutoff=None):</span>
<span class="gi">+    if s not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(s)} not in graph&quot;)</span>
<span class="gi">+    if t not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(t)} not in graph&quot;)</span>
<span class="gi">+    if s == t:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;source and sink are the same node&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if residual is None:</span>
<span class="gi">+        R = build_residual_network(G, capacity)</span>
<span class="gi">+    else:</span>
<span class="gi">+        R = residual</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize/reset the residual network.</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        for e in R[u].values():</span>
<span class="gi">+            e[&quot;flow&quot;] = 0</span>
<span class="gi">+</span>
<span class="gi">+    if cutoff is None:</span>
<span class="gi">+        cutoff = float(&quot;inf&quot;)</span>
<span class="gi">+    R.graph[&quot;flow_value&quot;] = edmonds_karp_core(R, s, t, cutoff)</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)}, returns_graph=True)</span>
<span class="gi">+def edmonds_karp(</span>
<span class="gi">+    G, s, t, capacity=&quot;capacity&quot;, residual=None, value_only=False, cutoff=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Find a maximum single-commodity flow using the Edmonds-Karp algorithm.

<span class="w"> </span>    This function returns the residual network resulting after computing
<span class="gu">@@ -133,4 +235,7 @@ def edmonds_karp(G, s, t, capacity=&#39;capacity&#39;, residual=None, value_only=</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = edmonds_karp_impl(G, s, t, capacity, residual, cutoff)</span>
<span class="gi">+    R.graph[&quot;algorithm&quot;] = &quot;edmonds_karp&quot;</span>
<span class="gi">+    nx._clear_cache(R)</span>
<span class="gi">+    return R</span>
<span class="gh">diff --git a/networkx/algorithms/flow/gomory_hu.py b/networkx/algorithms/flow/gomory_hu.py</span>
<span class="gh">index 0a43fa7cb..951abaeb5 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/gomory_hu.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/gomory_hu.py</span>
<span class="gu">@@ -3,16 +3,19 @@ Gomory-Hu tree of undirected Graphs.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gi">+</span>
<span class="w"> </span>from .edmondskarp import edmonds_karp
<span class="w"> </span>from .utils import build_residual_network
<span class="gi">+</span>
<span class="w"> </span>default_flow_func = edmonds_karp
<span class="gd">-__all__ = [&#39;gomory_hu_tree&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;gomory_hu_tree&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)}, returns_graph=True)</span>
<span class="gd">-def gomory_hu_tree(G, capacity=&#39;capacity&#39;, flow_func=None):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the Gomory-Hu tree of an undirected graph G.</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)}, returns_graph=True)</span>
<span class="gi">+def gomory_hu_tree(G, capacity=&quot;capacity&quot;, flow_func=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Gomory-Hu tree of an undirected graph G.</span>

<span class="w"> </span>    A Gomory-Hu tree of an undirected graph with capacities is a
<span class="w"> </span>    weighted tree that represents the minimum s-t cuts for all s-t
<span class="gu">@@ -127,4 +130,48 @@ def gomory_hu_tree(G, capacity=&#39;capacity&#39;, flow_func=None):</span>
<span class="w"> </span>           SIAM J Comput 19(1):143-155, 1990.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:  # empty graph</span>
<span class="gi">+        msg = &quot;Empty Graph does not have a Gomory-Hu tree representation&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # Start the tree as a star graph with an arbitrary node at the center</span>
<span class="gi">+    tree = {}</span>
<span class="gi">+    labels = {}</span>
<span class="gi">+    iter_nodes = iter(G)</span>
<span class="gi">+    root = next(iter_nodes)</span>
<span class="gi">+    for n in iter_nodes:</span>
<span class="gi">+        tree[n] = root</span>
<span class="gi">+</span>
<span class="gi">+    # Reuse residual network</span>
<span class="gi">+    R = build_residual_network(G, capacity)</span>
<span class="gi">+</span>
<span class="gi">+    # For all the leaves in the star graph tree (that is n-1 nodes).</span>
<span class="gi">+    for source in tree:</span>
<span class="gi">+        # Find neighbor in the tree</span>
<span class="gi">+        target = tree[source]</span>
<span class="gi">+        # compute minimum cut</span>
<span class="gi">+        cut_value, partition = nx.minimum_cut(</span>
<span class="gi">+            G, source, target, capacity=capacity, flow_func=flow_func, residual=R</span>
<span class="gi">+        )</span>
<span class="gi">+        labels[(source, target)] = cut_value</span>
<span class="gi">+        # Update the tree</span>
<span class="gi">+        # Source will always be in partition[0] and target in partition[1]</span>
<span class="gi">+        for node in partition[0]:</span>
<span class="gi">+            if node != source and node in tree and tree[node] == target:</span>
<span class="gi">+                tree[node] = source</span>
<span class="gi">+                labels[node, source] = labels.get((node, target), cut_value)</span>
<span class="gi">+        #</span>
<span class="gi">+        if target != root and tree[target] in partition[0]:</span>
<span class="gi">+            labels[source, tree[target]] = labels[target, tree[target]]</span>
<span class="gi">+            labels[target, source] = cut_value</span>
<span class="gi">+            tree[source] = tree[target]</span>
<span class="gi">+            tree[target] = source</span>
<span class="gi">+</span>
<span class="gi">+    # Build the tree</span>
<span class="gi">+    T = nx.Graph()</span>
<span class="gi">+    T.add_nodes_from(G)</span>
<span class="gi">+    T.add_weighted_edges_from(((u, v, labels[u, v]) for u, v in tree.items()))</span>
<span class="gi">+    return T</span>
<span class="gh">diff --git a/networkx/algorithms/flow/maxflow.py b/networkx/algorithms/flow/maxflow.py</span>
<span class="gh">index 97b2c4c3e..96bca029f 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/maxflow.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/maxflow.py</span>
<span class="gu">@@ -2,19 +2,22 @@</span>
<span class="w"> </span>Maximum flow (and minimum cut) algorithms on capacitated graphs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from .boykovkolmogorov import boykov_kolmogorov
<span class="w"> </span>from .dinitz_alg import dinitz
<span class="w"> </span>from .edmondskarp import edmonds_karp
<span class="w"> </span>from .preflowpush import preflow_push
<span class="w"> </span>from .shortestaugmentingpath import shortest_augmenting_path
<span class="w"> </span>from .utils import build_flow_dict
<span class="gi">+</span>
<span class="gi">+# Define the default flow function for computing maximum flow.</span>
<span class="w"> </span>default_flow_func = preflow_push
<span class="gd">-__all__ = [&#39;maximum_flow&#39;, &#39;maximum_flow_value&#39;, &#39;minimum_cut&#39;,</span>
<span class="gd">-    &#39;minimum_cut_value&#39;]</span>

<span class="gi">+__all__ = [&quot;maximum_flow&quot;, &quot;maximum_flow_value&quot;, &quot;minimum_cut&quot;, &quot;minimum_cut_value&quot;]</span>

<span class="gd">-@nx._dispatchable(graphs=&#39;flowG&#39;, edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)})</span>
<span class="gd">-def maximum_flow(flowG, _s, _t, capacity=&#39;capacity&#39;, flow_func=None, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;flowG&quot;, edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)})</span>
<span class="gi">+def maximum_flow(flowG, _s, _t, capacity=&quot;capacity&quot;, flow_func=None, **kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot;Find a maximum single-commodity flow.

<span class="w"> </span>    Parameters
<span class="gu">@@ -141,12 +144,25 @@ def maximum_flow(flowG, _s, _t, capacity=&#39;capacity&#39;, flow_func=None, **kwargs):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        if kwargs:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;You have to explicitly set a flow_func if&quot;</span>
<span class="gi">+                &quot; you need to pass parameters via kwargs.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+</span>
<span class="gi">+    if not callable(flow_func):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;flow_func has to be callable.&quot;)</span>

<span class="gi">+    R = flow_func(flowG, _s, _t, capacity=capacity, value_only=False, **kwargs)</span>
<span class="gi">+    flow_dict = build_flow_dict(flowG, R)</span>

<span class="gd">-@nx._dispatchable(graphs=&#39;flowG&#39;, edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)})</span>
<span class="gd">-def maximum_flow_value(flowG, _s, _t, capacity=&#39;capacity&#39;, flow_func=None,</span>
<span class="gd">-    **kwargs):</span>
<span class="gi">+    return (R.graph[&quot;flow_value&quot;], flow_dict)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;flowG&quot;, edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)})</span>
<span class="gi">+def maximum_flow_value(flowG, _s, _t, capacity=&quot;capacity&quot;, flow_func=None, **kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the value of maximum single-commodity flow.

<span class="w"> </span>    Parameters
<span class="gu">@@ -267,11 +283,24 @@ def maximum_flow_value(flowG, _s, _t, capacity=&#39;capacity&#39;, flow_func=None,</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        if kwargs:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;You have to explicitly set a flow_func if&quot;</span>
<span class="gi">+                &quot; you need to pass parameters via kwargs.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+</span>
<span class="gi">+    if not callable(flow_func):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;flow_func has to be callable.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    R = flow_func(flowG, _s, _t, capacity=capacity, value_only=True, **kwargs)</span>

<span class="gi">+    return R.graph[&quot;flow_value&quot;]</span>

<span class="gd">-@nx._dispatchable(graphs=&#39;flowG&#39;, edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)})</span>
<span class="gd">-def minimum_cut(flowG, _s, _t, capacity=&#39;capacity&#39;, flow_func=None, **kwargs):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;flowG&quot;, edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)})</span>
<span class="gi">+def minimum_cut(flowG, _s, _t, capacity=&quot;capacity&quot;, flow_func=None, **kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute the value and the node partition of a minimum (s, t)-cut.

<span class="w"> </span>    Use the max-flow min-cut theorem, i.e., the capacity of a minimum
<span class="gu">@@ -403,12 +432,39 @@ def minimum_cut(flowG, _s, _t, capacity=&#39;capacity&#39;, flow_func=None, **kwargs):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;flowG&#39;, edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)})</span>
<span class="gd">-def minimum_cut_value(flowG, _s, _t, capacity=&#39;capacity&#39;, flow_func=None,</span>
<span class="gd">-    **kwargs):</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        if kwargs:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;You have to explicitly set a flow_func if&quot;</span>
<span class="gi">+                &quot; you need to pass parameters via kwargs.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+</span>
<span class="gi">+    if not callable(flow_func):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;flow_func has to be callable.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if kwargs.get(&quot;cutoff&quot;) is not None and flow_func is preflow_push:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;cutoff should not be specified.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    R = flow_func(flowG, _s, _t, capacity=capacity, value_only=True, **kwargs)</span>
<span class="gi">+    # Remove saturated edges from the residual network</span>
<span class="gi">+    cutset = [(u, v, d) for u, v, d in R.edges(data=True) if d[&quot;flow&quot;] == d[&quot;capacity&quot;]]</span>
<span class="gi">+    R.remove_edges_from(cutset)</span>
<span class="gi">+</span>
<span class="gi">+    # Then, reachable and non reachable nodes from source in the</span>
<span class="gi">+    # residual network form the node partition that defines</span>
<span class="gi">+    # the minimum cut.</span>
<span class="gi">+    non_reachable = set(dict(nx.shortest_path_length(R, target=_t)))</span>
<span class="gi">+    partition = (set(flowG) - non_reachable, non_reachable)</span>
<span class="gi">+    # Finally add again cutset edges to the residual network to make</span>
<span class="gi">+    # sure that it is reusable.</span>
<span class="gi">+    if cutset is not None:</span>
<span class="gi">+        R.add_edges_from(cutset)</span>
<span class="gi">+    return (R.graph[&quot;flow_value&quot;], partition)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;flowG&quot;, edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)})</span>
<span class="gi">+def minimum_cut_value(flowG, _s, _t, capacity=&quot;capacity&quot;, flow_func=None, **kwargs):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute the value of a minimum (s, t)-cut.

<span class="w"> </span>    Use the max-flow min-cut theorem, i.e., the capacity of a minimum
<span class="gu">@@ -526,4 +582,20 @@ def minimum_cut_value(flowG, _s, _t, capacity=&#39;capacity&#39;, flow_func=None,</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if flow_func is None:</span>
<span class="gi">+        if kwargs:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;You have to explicitly set a flow_func if&quot;</span>
<span class="gi">+                &quot; you need to pass parameters via kwargs.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        flow_func = default_flow_func</span>
<span class="gi">+</span>
<span class="gi">+    if not callable(flow_func):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;flow_func has to be callable.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if kwargs.get(&quot;cutoff&quot;) is not None and flow_func is preflow_push:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;cutoff should not be specified.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    R = flow_func(flowG, _s, _t, capacity=capacity, value_only=True, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return R.graph[&quot;flow_value&quot;]</span>
<span class="gh">diff --git a/networkx/algorithms/flow/mincost.py b/networkx/algorithms/flow/mincost.py</span>
<span class="gh">index 99cd8ac35..2f9390d7a 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/mincost.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/mincost.py</span>
<span class="gu">@@ -1,16 +1,17 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Minimum cost flow algorithms on directed connected graphs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;min_cost_flow_cost&#39;, &#39;min_cost_flow&#39;, &#39;cost_of_flow&#39;,</span>
<span class="gd">-    &#39;max_flow_min_cost&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;min_cost_flow_cost&quot;, &quot;min_cost_flow&quot;, &quot;cost_of_flow&quot;, &quot;max_flow_min_cost&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx


<span class="gd">-@nx._dispatchable(node_attrs=&#39;demand&#39;, edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;),</span>
<span class="gd">-    &#39;weight&#39;: 0})</span>
<span class="gd">-def min_cost_flow_cost(G, demand=&#39;demand&#39;, capacity=&#39;capacity&#39;, weight=&#39;weight&#39;</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;Find the cost of a minimum cost flow satisfying all demands in digraph G.</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    node_attrs=&quot;demand&quot;, edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;), &quot;weight&quot;: 0}</span>
<span class="gi">+)</span>
<span class="gi">+def min_cost_flow_cost(G, demand=&quot;demand&quot;, capacity=&quot;capacity&quot;, weight=&quot;weight&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Find the cost of a minimum cost flow satisfying all demands in digraph G.</span>

<span class="w"> </span>    G is a digraph with edge costs and capacities and in which nodes
<span class="w"> </span>    have demand, i.e., they want to send or receive some amount of
<span class="gu">@@ -95,13 +96,14 @@ def min_cost_flow_cost(G, demand=&#39;demand&#39;, capacity=&#39;capacity&#39;, weight=&#39;weight&#39;</span>
<span class="w"> </span>    &gt;&gt;&gt; flowCost
<span class="w"> </span>    24
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return nx.network_simplex(G, demand=demand, capacity=capacity, weight=weight)[0]</span>


<span class="gd">-@nx._dispatchable(node_attrs=&#39;demand&#39;, edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;),</span>
<span class="gd">-    &#39;weight&#39;: 0})</span>
<span class="gd">-def min_cost_flow(G, demand=&#39;demand&#39;, capacity=&#39;capacity&#39;, weight=&#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Returns a minimum cost flow satisfying all demands in digraph G.</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    node_attrs=&quot;demand&quot;, edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;), &quot;weight&quot;: 0}</span>
<span class="gi">+)</span>
<span class="gi">+def min_cost_flow(G, demand=&quot;demand&quot;, capacity=&quot;capacity&quot;, weight=&quot;weight&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a minimum cost flow satisfying all demands in digraph G.</span>

<span class="w"> </span>    G is a digraph with edge costs and capacities and in which nodes
<span class="w"> </span>    have demand, i.e., they want to send or receive some amount of
<span class="gu">@@ -187,11 +189,11 @@ def min_cost_flow(G, demand=&#39;demand&#39;, capacity=&#39;capacity&#39;, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    &gt;&gt;&gt; flowDict
<span class="w"> </span>    {&#39;a&#39;: {&#39;b&#39;: 4, &#39;c&#39;: 1}, &#39;d&#39;: {}, &#39;b&#39;: {&#39;d&#39;: 4}, &#39;c&#39;: {&#39;d&#39;: 1}}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return nx.network_simplex(G, demand=demand, capacity=capacity, weight=weight)[1]</span>


<span class="gd">-@nx._dispatchable(edge_attrs={&#39;weight&#39;: 0})</span>
<span class="gd">-def cost_of_flow(G, flowDict, weight=&#39;weight&#39;):</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;weight&quot;: 0})</span>
<span class="gi">+def cost_of_flow(G, flowDict, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute the cost of the flow given by flowDict on graph G.

<span class="w"> </span>    Note that this function does not check for the validity of the
<span class="gu">@@ -247,11 +249,11 @@ def cost_of_flow(G, flowDict, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.cost_of_flow(G, flowDict)
<span class="w"> </span>    24
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum((flowDict[u][v] * d.get(weight, 0) for u, v, d in G.edges(data=True)))</span>


<span class="gd">-@nx._dispatchable(edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;), &#39;weight&#39;: 0})</span>
<span class="gd">-def max_flow_min_cost(G, s, t, capacity=&#39;capacity&#39;, weight=&#39;weight&#39;):</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;), &quot;weight&quot;: 0})</span>
<span class="gi">+def max_flow_min_cost(G, s, t, capacity=&quot;capacity&quot;, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a maximum (s, t)-flow of minimum cost.

<span class="w"> </span>    G is a digraph with edge costs and capacities. There is a source
<span class="gu">@@ -347,4 +349,8 @@ def max_flow_min_cost(G, s, t, capacity=&#39;capacity&#39;, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    maxFlow = nx.maximum_flow_value(G, s, t, capacity=capacity)</span>
<span class="gi">+    H = nx.DiGraph(G)</span>
<span class="gi">+    H.add_node(s, demand=-maxFlow)</span>
<span class="gi">+    H.add_node(t, demand=maxFlow)</span>
<span class="gi">+    return min_cost_flow(H, capacity=capacity, weight=weight)</span>
<span class="gh">diff --git a/networkx/algorithms/flow/networksimplex.py b/networkx/algorithms/flow/networksimplex.py</span>
<span class="gh">index 1a3d1ea4c..a9822d968 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/networksimplex.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/networksimplex.py</span>
<span class="gu">@@ -1,34 +1,42 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Minimum cost flow algorithms on directed connected graphs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;network_simplex&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;network_simplex&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>from itertools import chain, islice, repeat
<span class="w"> </span>from math import ceil, sqrt
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for


<span class="w"> </span>class _DataEssentialsAndFunctions:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, G, multigraph, demand=&#39;demand&#39;, capacity=&#39;capacity&#39;,</span>
<span class="gd">-        weight=&#39;weight&#39;):</span>
<span class="gd">-        self.node_list = list(G)</span>
<span class="gd">-        self.node_indices = {u: i for i, u in enumerate(self.node_list)}</span>
<span class="gd">-        self.node_demands = [G.nodes[u].get(demand, 0) for u in self.node_list]</span>
<span class="gd">-        self.edge_sources = []</span>
<span class="gd">-        self.edge_targets = []</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, G, multigraph, demand=&quot;demand&quot;, capacity=&quot;capacity&quot;, weight=&quot;weight&quot;</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Number all nodes and edges and hereafter reference them using ONLY their numbers</span>
<span class="gi">+        self.node_list = list(G)  # nodes</span>
<span class="gi">+        self.node_indices = {u: i for i, u in enumerate(self.node_list)}  # node indices</span>
<span class="gi">+        self.node_demands = [</span>
<span class="gi">+            G.nodes[u].get(demand, 0) for u in self.node_list</span>
<span class="gi">+        ]  # node demands</span>
<span class="gi">+</span>
<span class="gi">+        self.edge_sources = []  # edge sources</span>
<span class="gi">+        self.edge_targets = []  # edge targets</span>
<span class="w"> </span>        if multigraph:
<span class="gd">-            self.edge_keys = []</span>
<span class="gd">-        self.edge_indices = {}</span>
<span class="gd">-        self.edge_capacities = []</span>
<span class="gd">-        self.edge_weights = []</span>
<span class="gi">+            self.edge_keys = []  # edge keys</span>
<span class="gi">+        self.edge_indices = {}  # edge indices</span>
<span class="gi">+        self.edge_capacities = []  # edge capacities</span>
<span class="gi">+        self.edge_weights = []  # edge weights</span>
<span class="gi">+</span>
<span class="w"> </span>        if not multigraph:
<span class="w"> </span>            edges = G.edges(data=True)
<span class="w"> </span>        else:
<span class="w"> </span>            edges = G.edges(data=True, keys=True)
<span class="gd">-        inf = float(&#39;inf&#39;)</span>
<span class="gd">-        edges = (e for e in edges if e[0] != e[1] and e[-1].get(capacity,</span>
<span class="gd">-            inf) != 0)</span>
<span class="gi">+</span>
<span class="gi">+        inf = float(&quot;inf&quot;)</span>
<span class="gi">+        edges = (e for e in edges if e[0] != e[1] and e[-1].get(capacity, inf) != 0)</span>
<span class="w"> </span>        for i, e in enumerate(edges):
<span class="w"> </span>            self.edge_sources.append(self.node_indices[e[0]])
<span class="w"> </span>            self.edge_targets.append(self.node_indices[e[1]])
<span class="gu">@@ -37,28 +45,77 @@ class _DataEssentialsAndFunctions:</span>
<span class="w"> </span>            self.edge_indices[e[:-1]] = i
<span class="w"> </span>            self.edge_capacities.append(e[-1].get(capacity, inf))
<span class="w"> </span>            self.edge_weights.append(e[-1].get(weight, 0))
<span class="gd">-        self.edge_count = None</span>
<span class="gd">-        self.edge_flow = None</span>
<span class="gd">-        self.node_potentials = None</span>
<span class="gd">-        self.parent = None</span>
<span class="gd">-        self.parent_edge = None</span>
<span class="gd">-        self.subtree_size = None</span>
<span class="gd">-        self.next_node_dft = None</span>
<span class="gd">-        self.prev_node_dft = None</span>
<span class="gd">-        self.last_descendent_dft = None</span>
<span class="gd">-        self._spanning_tree_initialized = False</span>
<span class="gi">+</span>
<span class="gi">+        # spanning tree specific data to be initialized</span>
<span class="gi">+</span>
<span class="gi">+        self.edge_count = None  # number of edges</span>
<span class="gi">+        self.edge_flow = None  # edge flows</span>
<span class="gi">+        self.node_potentials = None  # node potentials</span>
<span class="gi">+        self.parent = None  # parent nodes</span>
<span class="gi">+        self.parent_edge = None  # edges to parents</span>
<span class="gi">+        self.subtree_size = None  # subtree sizes</span>
<span class="gi">+        self.next_node_dft = None  # next nodes in depth-first thread</span>
<span class="gi">+        self.prev_node_dft = None  # previous nodes in depth-first thread</span>
<span class="gi">+        self.last_descendent_dft = None  # last descendants in depth-first thread</span>
<span class="gi">+        self._spanning_tree_initialized = (</span>
<span class="gi">+            False  # False until initialize_spanning_tree() is called</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def initialize_spanning_tree(self, n, faux_inf):</span>
<span class="gi">+        self.edge_count = len(self.edge_indices)  # number of edges</span>
<span class="gi">+        self.edge_flow = list(</span>
<span class="gi">+            chain(repeat(0, self.edge_count), (abs(d) for d in self.node_demands))</span>
<span class="gi">+        )  # edge flows</span>
<span class="gi">+        self.node_potentials = [</span>
<span class="gi">+            faux_inf if d &lt;= 0 else -faux_inf for d in self.node_demands</span>
<span class="gi">+        ]  # node potentials</span>
<span class="gi">+        self.parent = list(chain(repeat(-1, n), [None]))  # parent nodes</span>
<span class="gi">+        self.parent_edge = list(</span>
<span class="gi">+            range(self.edge_count, self.edge_count + n)</span>
<span class="gi">+        )  # edges to parents</span>
<span class="gi">+        self.subtree_size = list(chain(repeat(1, n), [n + 1]))  # subtree sizes</span>
<span class="gi">+        self.next_node_dft = list(</span>
<span class="gi">+            chain(range(1, n), [-1, 0])</span>
<span class="gi">+        )  # next nodes in depth-first thread</span>
<span class="gi">+        self.prev_node_dft = list(range(-1, n))  # previous nodes in depth-first thread</span>
<span class="gi">+        self.last_descendent_dft = list(</span>
<span class="gi">+            chain(range(n), [n - 1])</span>
<span class="gi">+        )  # last descendants in depth-first thread</span>
<span class="gi">+        self._spanning_tree_initialized = True  # True only if all the assignments pass</span>

<span class="w"> </span>    def find_apex(self, p, q):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find the lowest common ancestor of nodes p and q in the spanning tree.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        size_p = self.subtree_size[p]</span>
<span class="gi">+        size_q = self.subtree_size[q]</span>
<span class="gi">+        while True:</span>
<span class="gi">+            while size_p &lt; size_q:</span>
<span class="gi">+                p = self.parent[p]</span>
<span class="gi">+                size_p = self.subtree_size[p]</span>
<span class="gi">+            while size_p &gt; size_q:</span>
<span class="gi">+                q = self.parent[q]</span>
<span class="gi">+                size_q = self.subtree_size[q]</span>
<span class="gi">+            if size_p == size_q:</span>
<span class="gi">+                if p != q:</span>
<span class="gi">+                    p = self.parent[p]</span>
<span class="gi">+                    size_p = self.subtree_size[p]</span>
<span class="gi">+                    q = self.parent[q]</span>
<span class="gi">+                    size_q = self.subtree_size[q]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return p</span>

<span class="w"> </span>    def trace_path(self, p, w):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the nodes and edges on the path from node p to its ancestor w.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        Wn = [p]</span>
<span class="gi">+        We = []</span>
<span class="gi">+        while p != w:</span>
<span class="gi">+            We.append(self.parent_edge[p])</span>
<span class="gi">+            p = self.parent[p]</span>
<span class="gi">+            Wn.append(p)</span>
<span class="gi">+        return Wn, We</span>

<span class="w"> </span>    def find_cycle(self, i, p, q):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -67,69 +124,213 @@ class _DataEssentialsAndFunctions:</span>

<span class="w"> </span>        The cycle is oriented in the direction from p to q.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        w = self.find_apex(p, q)</span>
<span class="gi">+        Wn, We = self.trace_path(p, w)</span>
<span class="gi">+        Wn.reverse()</span>
<span class="gi">+        We.reverse()</span>
<span class="gi">+        if We != [i]:</span>
<span class="gi">+            We.append(i)</span>
<span class="gi">+        WnR, WeR = self.trace_path(q, w)</span>
<span class="gi">+        del WnR[-1]</span>
<span class="gi">+        Wn += WnR</span>
<span class="gi">+        We += WeR</span>
<span class="gi">+        return Wn, We</span>

<span class="w"> </span>    def augment_flow(self, Wn, We, f):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Augment f units of flow along a cycle represented by Wn and We.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for i, p in zip(We, Wn):</span>
<span class="gi">+            if self.edge_sources[i] == p:</span>
<span class="gi">+                self.edge_flow[i] += f</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.edge_flow[i] -= f</span>

<span class="w"> </span>    def trace_subtree(self, p):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Yield the nodes in the subtree rooted at a node p.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        yield p</span>
<span class="gi">+        l = self.last_descendent_dft[p]</span>
<span class="gi">+        while p != l:</span>
<span class="gi">+            p = self.next_node_dft[p]</span>
<span class="gi">+            yield p</span>

<span class="w"> </span>    def remove_edge(self, s, t):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Remove an edge (s, t) where parent[t] == s from the spanning tree.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        size_t = self.subtree_size[t]</span>
<span class="gi">+        prev_t = self.prev_node_dft[t]</span>
<span class="gi">+        last_t = self.last_descendent_dft[t]</span>
<span class="gi">+        next_last_t = self.next_node_dft[last_t]</span>
<span class="gi">+        # Remove (s, t).</span>
<span class="gi">+        self.parent[t] = None</span>
<span class="gi">+        self.parent_edge[t] = None</span>
<span class="gi">+        # Remove the subtree rooted at t from the depth-first thread.</span>
<span class="gi">+        self.next_node_dft[prev_t] = next_last_t</span>
<span class="gi">+        self.prev_node_dft[next_last_t] = prev_t</span>
<span class="gi">+        self.next_node_dft[last_t] = t</span>
<span class="gi">+        self.prev_node_dft[t] = last_t</span>
<span class="gi">+        # Update the subtree sizes and last descendants of the (old) ancestors</span>
<span class="gi">+        # of t.</span>
<span class="gi">+        while s is not None:</span>
<span class="gi">+            self.subtree_size[s] -= size_t</span>
<span class="gi">+            if self.last_descendent_dft[s] == last_t:</span>
<span class="gi">+                self.last_descendent_dft[s] = prev_t</span>
<span class="gi">+            s = self.parent[s]</span>

<span class="w"> </span>    def make_root(self, q):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Make a node q the root of its containing subtree.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ancestors = []</span>
<span class="gi">+        while q is not None:</span>
<span class="gi">+            ancestors.append(q)</span>
<span class="gi">+            q = self.parent[q]</span>
<span class="gi">+        ancestors.reverse()</span>
<span class="gi">+        for p, q in zip(ancestors, islice(ancestors, 1, None)):</span>
<span class="gi">+            size_p = self.subtree_size[p]</span>
<span class="gi">+            last_p = self.last_descendent_dft[p]</span>
<span class="gi">+            prev_q = self.prev_node_dft[q]</span>
<span class="gi">+            last_q = self.last_descendent_dft[q]</span>
<span class="gi">+            next_last_q = self.next_node_dft[last_q]</span>
<span class="gi">+            # Make p a child of q.</span>
<span class="gi">+            self.parent[p] = q</span>
<span class="gi">+            self.parent[q] = None</span>
<span class="gi">+            self.parent_edge[p] = self.parent_edge[q]</span>
<span class="gi">+            self.parent_edge[q] = None</span>
<span class="gi">+            self.subtree_size[p] = size_p - self.subtree_size[q]</span>
<span class="gi">+            self.subtree_size[q] = size_p</span>
<span class="gi">+            # Remove the subtree rooted at q from the depth-first thread.</span>
<span class="gi">+            self.next_node_dft[prev_q] = next_last_q</span>
<span class="gi">+            self.prev_node_dft[next_last_q] = prev_q</span>
<span class="gi">+            self.next_node_dft[last_q] = q</span>
<span class="gi">+            self.prev_node_dft[q] = last_q</span>
<span class="gi">+            if last_p == last_q:</span>
<span class="gi">+                self.last_descendent_dft[p] = prev_q</span>
<span class="gi">+                last_p = prev_q</span>
<span class="gi">+            # Add the remaining parts of the subtree rooted at p as a subtree</span>
<span class="gi">+            # of q in the depth-first thread.</span>
<span class="gi">+            self.prev_node_dft[p] = last_q</span>
<span class="gi">+            self.next_node_dft[last_q] = p</span>
<span class="gi">+            self.next_node_dft[last_p] = q</span>
<span class="gi">+            self.prev_node_dft[q] = last_p</span>
<span class="gi">+            self.last_descendent_dft[q] = last_p</span>

<span class="w"> </span>    def add_edge(self, i, p, q):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Add an edge (p, q) to the spanning tree where q is the root of a subtree.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        last_p = self.last_descendent_dft[p]</span>
<span class="gi">+        next_last_p = self.next_node_dft[last_p]</span>
<span class="gi">+        size_q = self.subtree_size[q]</span>
<span class="gi">+        last_q = self.last_descendent_dft[q]</span>
<span class="gi">+        # Make q a child of p.</span>
<span class="gi">+        self.parent[q] = p</span>
<span class="gi">+        self.parent_edge[q] = i</span>
<span class="gi">+        # Insert the subtree rooted at q into the depth-first thread.</span>
<span class="gi">+        self.next_node_dft[last_p] = q</span>
<span class="gi">+        self.prev_node_dft[q] = last_p</span>
<span class="gi">+        self.prev_node_dft[next_last_p] = last_q</span>
<span class="gi">+        self.next_node_dft[last_q] = next_last_p</span>
<span class="gi">+        # Update the subtree sizes and last descendants of the (new) ancestors</span>
<span class="gi">+        # of q.</span>
<span class="gi">+        while p is not None:</span>
<span class="gi">+            self.subtree_size[p] += size_q</span>
<span class="gi">+            if self.last_descendent_dft[p] == last_p:</span>
<span class="gi">+                self.last_descendent_dft[p] = last_q</span>
<span class="gi">+            p = self.parent[p]</span>

<span class="w"> </span>    def update_potentials(self, i, p, q):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Update the potentials of the nodes in the subtree rooted at a node
<span class="w"> </span>        q connected to its parent p by an edge i.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if q == self.edge_targets[i]:</span>
<span class="gi">+            d = self.node_potentials[p] - self.edge_weights[i] - self.node_potentials[q]</span>
<span class="gi">+        else:</span>
<span class="gi">+            d = self.node_potentials[p] + self.edge_weights[i] - self.node_potentials[q]</span>
<span class="gi">+        for q in self.trace_subtree(q):</span>
<span class="gi">+            self.node_potentials[q] += d</span>

<span class="w"> </span>    def reduced_cost(self, i):
<span class="w"> </span>        &quot;&quot;&quot;Returns the reduced cost of an edge i.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        c = (</span>
<span class="gi">+            self.edge_weights[i]</span>
<span class="gi">+            - self.node_potentials[self.edge_sources[i]]</span>
<span class="gi">+            + self.node_potentials[self.edge_targets[i]]</span>
<span class="gi">+        )</span>
<span class="gi">+        return c if self.edge_flow[i] == 0 else -c</span>

<span class="w"> </span>    def find_entering_edges(self):
<span class="w"> </span>        &quot;&quot;&quot;Yield entering edges until none can be found.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.edge_count == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Entering edges are found by combining Dantzig&#39;s rule and Bland&#39;s</span>
<span class="gi">+        # rule. The edges are cyclically grouped into blocks of size B. Within</span>
<span class="gi">+        # each block, Dantzig&#39;s rule is applied to find an entering edge. The</span>
<span class="gi">+        # blocks to search is determined following Bland&#39;s rule.</span>
<span class="gi">+        B = int(ceil(sqrt(self.edge_count)))  # pivot block size</span>
<span class="gi">+        M = (self.edge_count + B - 1) // B  # number of blocks needed to cover all edges</span>
<span class="gi">+        m = 0  # number of consecutive blocks without eligible</span>
<span class="gi">+        # entering edges</span>
<span class="gi">+        f = 0  # first edge in block</span>
<span class="gi">+        while m &lt; M:</span>
<span class="gi">+            # Determine the next block of edges.</span>
<span class="gi">+            l = f + B</span>
<span class="gi">+            if l &lt;= self.edge_count:</span>
<span class="gi">+                edges = range(f, l)</span>
<span class="gi">+            else:</span>
<span class="gi">+                l -= self.edge_count</span>
<span class="gi">+                edges = chain(range(f, self.edge_count), range(l))</span>
<span class="gi">+            f = l</span>
<span class="gi">+            # Find the first edge with the lowest reduced cost.</span>
<span class="gi">+            i = min(edges, key=self.reduced_cost)</span>
<span class="gi">+            c = self.reduced_cost(i)</span>
<span class="gi">+            if c &gt;= 0:</span>
<span class="gi">+                # No entering edge found in the current block.</span>
<span class="gi">+                m += 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Entering edge found.</span>
<span class="gi">+                if self.edge_flow[i] == 0:</span>
<span class="gi">+                    p = self.edge_sources[i]</span>
<span class="gi">+                    q = self.edge_targets[i]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    p = self.edge_targets[i]</span>
<span class="gi">+                    q = self.edge_sources[i]</span>
<span class="gi">+                yield i, p, q</span>
<span class="gi">+                m = 0</span>
<span class="gi">+        # All edges have nonnegative reduced costs. The current flow is</span>
<span class="gi">+        # optimal.</span>

<span class="w"> </span>    def residual_capacity(self, i, p):
<span class="w"> </span>        &quot;&quot;&quot;Returns the residual capacity of an edge i in the direction away
<span class="w"> </span>        from its endpoint p.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.edge_capacities[i] - self.edge_flow[i]</span>
<span class="gi">+            if self.edge_sources[i] == p</span>
<span class="gi">+            else self.edge_flow[i]</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def find_leaving_edge(self, Wn, We):
<span class="w"> </span>        &quot;&quot;&quot;Returns the leaving edge in a cycle represented by Wn and We.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        j, s = min(</span>
<span class="gi">+            zip(reversed(We), reversed(Wn)),</span>
<span class="gi">+            key=lambda i_p: self.residual_capacity(*i_p),</span>
<span class="gi">+        )</span>
<span class="gi">+        t = self.edge_targets[j] if self.edge_sources[j] == s else self.edge_sources[j]</span>
<span class="gi">+        return j, s, t</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@nx._dispatchable(node_attrs=&#39;demand&#39;, edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;),</span>
<span class="gd">-    &#39;weight&#39;: 0})</span>
<span class="gd">-def network_simplex(G, demand=&#39;demand&#39;, capacity=&#39;capacity&#39;, weight=&#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Find a minimum cost flow satisfying all demands in digraph G.</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    node_attrs=&quot;demand&quot;, edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;), &quot;weight&quot;: 0}</span>
<span class="gi">+)</span>
<span class="gi">+def network_simplex(G, demand=&quot;demand&quot;, capacity=&quot;capacity&quot;, weight=&quot;weight&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Find a minimum cost flow satisfying all demands in digraph G.</span>

<span class="w"> </span>    This is a primal network simplex algorithm that uses the leaving
<span class="w"> </span>    arc rule to prevent cycling.
<span class="gu">@@ -290,4 +491,176 @@ def network_simplex(G, demand=&#39;demand&#39;, capacity=&#39;capacity&#39;, weight=&#39;weight&#39;):</span>
<span class="w"> </span>           optimization.
<span class="w"> </span>           INFOR 17(1):16--34. 1979.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+    # Problem essentials extraction and sanity check</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph has no nodes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    multigraph = G.is_multigraph()</span>
<span class="gi">+</span>
<span class="gi">+    # extracting data essential to problem</span>
<span class="gi">+    DEAF = _DataEssentialsAndFunctions(</span>
<span class="gi">+        G, multigraph, demand=demand, capacity=capacity, weight=weight</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+    # Quick Error Detection</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+</span>
<span class="gi">+    inf = float(&quot;inf&quot;)</span>
<span class="gi">+    for u, d in zip(DEAF.node_list, DEAF.node_demands):</span>
<span class="gi">+        if abs(d) == inf:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {u!r} has infinite demand&quot;)</span>
<span class="gi">+    for e, w in zip(DEAF.edge_indices, DEAF.edge_weights):</span>
<span class="gi">+        if abs(w) == inf:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;edge {e!r} has infinite weight&quot;)</span>
<span class="gi">+    if not multigraph:</span>
<span class="gi">+        edges = nx.selfloop_edges(G, data=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = nx.selfloop_edges(G, data=True, keys=True)</span>
<span class="gi">+    for e in edges:</span>
<span class="gi">+        if abs(e[-1].get(weight, 0)) == inf:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;edge {e[:-1]!r} has infinite weight&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+    # Quick Infeasibility Detection</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+</span>
<span class="gi">+    if sum(DEAF.node_demands) != 0:</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(&quot;total node demand is not zero&quot;)</span>
<span class="gi">+    for e, c in zip(DEAF.edge_indices, DEAF.edge_capacities):</span>
<span class="gi">+        if c &lt; 0:</span>
<span class="gi">+            raise nx.NetworkXUnfeasible(f&quot;edge {e!r} has negative capacity&quot;)</span>
<span class="gi">+    if not multigraph:</span>
<span class="gi">+        edges = nx.selfloop_edges(G, data=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = nx.selfloop_edges(G, data=True, keys=True)</span>
<span class="gi">+    for e in edges:</span>
<span class="gi">+        if e[-1].get(capacity, inf) &lt; 0:</span>
<span class="gi">+            raise nx.NetworkXUnfeasible(f&quot;edge {e[:-1]!r} has negative capacity&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+    # Initialization</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+</span>
<span class="gi">+    # Add a dummy node -1 and connect all existing nodes to it with infinite-</span>
<span class="gi">+    # capacity dummy edges. Node -1 will serve as the root of the</span>
<span class="gi">+    # spanning tree of the network simplex method. The new edges will used to</span>
<span class="gi">+    # trivially satisfy the node demands and create an initial strongly</span>
<span class="gi">+    # feasible spanning tree.</span>
<span class="gi">+    for i, d in enumerate(DEAF.node_demands):</span>
<span class="gi">+        # Must be greater-than here. Zero-demand nodes must have</span>
<span class="gi">+        # edges pointing towards the root to ensure strong feasibility.</span>
<span class="gi">+        if d &gt; 0:</span>
<span class="gi">+            DEAF.edge_sources.append(-1)</span>
<span class="gi">+            DEAF.edge_targets.append(i)</span>
<span class="gi">+        else:</span>
<span class="gi">+            DEAF.edge_sources.append(i)</span>
<span class="gi">+            DEAF.edge_targets.append(-1)</span>
<span class="gi">+    faux_inf = (</span>
<span class="gi">+        3</span>
<span class="gi">+        * max(</span>
<span class="gi">+            chain(</span>
<span class="gi">+                [</span>
<span class="gi">+                    sum(c for c in DEAF.edge_capacities if c &lt; inf),</span>
<span class="gi">+                    sum(abs(w) for w in DEAF.edge_weights),</span>
<span class="gi">+                ],</span>
<span class="gi">+                (abs(d) for d in DEAF.node_demands),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        or 1</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    n = len(DEAF.node_list)  # number of nodes</span>
<span class="gi">+    DEAF.edge_weights.extend(repeat(faux_inf, n))</span>
<span class="gi">+    DEAF.edge_capacities.extend(repeat(faux_inf, n))</span>
<span class="gi">+</span>
<span class="gi">+    # Construct the initial spanning tree.</span>
<span class="gi">+    DEAF.initialize_spanning_tree(n, faux_inf)</span>
<span class="gi">+</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+    # Pivot loop</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+</span>
<span class="gi">+    for i, p, q in DEAF.find_entering_edges():</span>
<span class="gi">+        Wn, We = DEAF.find_cycle(i, p, q)</span>
<span class="gi">+        j, s, t = DEAF.find_leaving_edge(Wn, We)</span>
<span class="gi">+        DEAF.augment_flow(Wn, We, DEAF.residual_capacity(j, s))</span>
<span class="gi">+        # Do nothing more if the entering edge is the same as the leaving edge.</span>
<span class="gi">+        if i != j:</span>
<span class="gi">+            if DEAF.parent[t] != s:</span>
<span class="gi">+                # Ensure that s is the parent of t.</span>
<span class="gi">+                s, t = t, s</span>
<span class="gi">+            if We.index(i) &gt; We.index(j):</span>
<span class="gi">+                # Ensure that q is in the subtree rooted at t.</span>
<span class="gi">+                p, q = q, p</span>
<span class="gi">+            DEAF.remove_edge(s, t)</span>
<span class="gi">+            DEAF.make_root(q)</span>
<span class="gi">+            DEAF.add_edge(i, p, q)</span>
<span class="gi">+            DEAF.update_potentials(i, p, q)</span>
<span class="gi">+</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+    # Infeasibility and unboundedness detection</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+</span>
<span class="gi">+    if any(DEAF.edge_flow[i] != 0 for i in range(-n, 0)):</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(&quot;no flow satisfies all node demands&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if any(DEAF.edge_flow[i] * 2 &gt;= faux_inf for i in range(DEAF.edge_count)) or any(</span>
<span class="gi">+        e[-1].get(capacity, inf) == inf and e[-1].get(weight, 0) &lt; 0</span>
<span class="gi">+        for e in nx.selfloop_edges(G, data=True)</span>
<span class="gi">+    ):</span>
<span class="gi">+        raise nx.NetworkXUnbounded(&quot;negative cycle with infinite capacity found&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+    # Flow cost calculation and flow dict construction</span>
<span class="gi">+    ###########################################################################</span>
<span class="gi">+</span>
<span class="gi">+    del DEAF.edge_flow[DEAF.edge_count :]</span>
<span class="gi">+    flow_cost = sum(w * x for w, x in zip(DEAF.edge_weights, DEAF.edge_flow))</span>
<span class="gi">+    flow_dict = {n: {} for n in DEAF.node_list}</span>
<span class="gi">+</span>
<span class="gi">+    def add_entry(e):</span>
<span class="gi">+        &quot;&quot;&quot;Add a flow dict entry.&quot;&quot;&quot;</span>
<span class="gi">+        d = flow_dict[e[0]]</span>
<span class="gi">+        for k in e[1:-2]:</span>
<span class="gi">+            try:</span>
<span class="gi">+                d = d[k]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                t = {}</span>
<span class="gi">+                d[k] = t</span>
<span class="gi">+                d = t</span>
<span class="gi">+        d[e[-2]] = e[-1]</span>
<span class="gi">+</span>
<span class="gi">+    DEAF.edge_sources = (</span>
<span class="gi">+        DEAF.node_list[s] for s in DEAF.edge_sources</span>
<span class="gi">+    )  # Use original nodes.</span>
<span class="gi">+    DEAF.edge_targets = (</span>
<span class="gi">+        DEAF.node_list[t] for t in DEAF.edge_targets</span>
<span class="gi">+    )  # Use original nodes.</span>
<span class="gi">+    if not multigraph:</span>
<span class="gi">+        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_flow):</span>
<span class="gi">+            add_entry(e)</span>
<span class="gi">+        edges = G.edges(data=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for e in zip(</span>
<span class="gi">+            DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_keys, DEAF.edge_flow</span>
<span class="gi">+        ):</span>
<span class="gi">+            add_entry(e)</span>
<span class="gi">+        edges = G.edges(data=True, keys=True)</span>
<span class="gi">+    for e in edges:</span>
<span class="gi">+        if e[0] != e[1]:</span>
<span class="gi">+            if e[-1].get(capacity, inf) == 0:</span>
<span class="gi">+                add_entry(e[:-1] + (0,))</span>
<span class="gi">+        else:</span>
<span class="gi">+            w = e[-1].get(weight, 0)</span>
<span class="gi">+            if w &gt;= 0:</span>
<span class="gi">+                add_entry(e[:-1] + (0,))</span>
<span class="gi">+            else:</span>
<span class="gi">+                c = e[-1][capacity]</span>
<span class="gi">+                flow_cost += w * c</span>
<span class="gi">+                add_entry(e[:-1] + (c,))</span>
<span class="gi">+</span>
<span class="gi">+    return flow_cost, flow_dict</span>
<span class="gh">diff --git a/networkx/algorithms/flow/preflowpush.py b/networkx/algorithms/flow/preflowpush.py</span>
<span class="gh">index 101c7948d..42cadc2e2 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/preflowpush.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/preflowpush.py</span>
<span class="gu">@@ -1,31 +1,305 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Highest-label preflow-push algorithm for maximum flow problems.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import deque
<span class="w"> </span>from itertools import islice
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from ...utils import arbitrary_element
<span class="gd">-from .utils import CurrentEdge, GlobalRelabelThreshold, Level, build_residual_network, detect_unboundedness</span>
<span class="gd">-__all__ = [&#39;preflow_push&#39;]</span>
<span class="gi">+from .utils import (</span>
<span class="gi">+    CurrentEdge,</span>
<span class="gi">+    GlobalRelabelThreshold,</span>
<span class="gi">+    Level,</span>
<span class="gi">+    build_residual_network,</span>
<span class="gi">+    detect_unboundedness,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;preflow_push&quot;]</span>


<span class="gd">-def preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq,</span>
<span class="gd">-    value_only):</span>
<span class="gi">+def preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only):</span>
<span class="w"> </span>    &quot;&quot;&quot;Implementation of the highest-label preflow-push algorithm.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if s not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(s)} not in graph&quot;)</span>
<span class="gi">+    if t not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(t)} not in graph&quot;)</span>
<span class="gi">+    if s == t:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;source and sink are the same node&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if global_relabel_freq is None:</span>
<span class="gi">+        global_relabel_freq = 0</span>
<span class="gi">+    if global_relabel_freq &lt; 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;global_relabel_freq must be nonnegative.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if residual is None:</span>
<span class="gi">+        R = build_residual_network(G, capacity)</span>
<span class="gi">+    else:</span>
<span class="gi">+        R = residual</span>
<span class="gi">+</span>
<span class="gi">+    detect_unboundedness(R, s, t)</span>
<span class="gi">+</span>
<span class="gi">+    R_nodes = R.nodes</span>
<span class="gi">+    R_pred = R.pred</span>
<span class="gi">+    R_succ = R.succ</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize/reset the residual network.</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        R_nodes[u][&quot;excess&quot;] = 0</span>
<span class="gi">+        for e in R_succ[u].values():</span>
<span class="gi">+            e[&quot;flow&quot;] = 0</span>
<span class="gi">+</span>
<span class="gi">+    def reverse_bfs(src):</span>
<span class="gi">+        &quot;&quot;&quot;Perform a reverse breadth-first search from src in the residual</span>
<span class="gi">+        network.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        heights = {src: 0}</span>
<span class="gi">+        q = deque([(src, 0)])</span>
<span class="gi">+        while q:</span>
<span class="gi">+            u, height = q.popleft()</span>
<span class="gi">+            height += 1</span>
<span class="gi">+            for v, attr in R_pred[u].items():</span>
<span class="gi">+                if v not in heights and attr[&quot;flow&quot;] &lt; attr[&quot;capacity&quot;]:</span>
<span class="gi">+                    heights[v] = height</span>
<span class="gi">+                    q.append((v, height))</span>
<span class="gi">+        return heights</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize heights of the nodes.</span>
<span class="gi">+    heights = reverse_bfs(t)</span>
<span class="gi">+</span>
<span class="gi">+    if s not in heights:</span>
<span class="gi">+        # t is not reachable from s in the residual network. The maximum flow</span>
<span class="gi">+        # must be zero.</span>
<span class="gi">+        R.graph[&quot;flow_value&quot;] = 0</span>
<span class="gi">+        return R</span>
<span class="gi">+</span>
<span class="gi">+    n = len(R)</span>
<span class="gi">+    # max_height represents the height of the highest level below level n with</span>
<span class="gi">+    # at least one active node.</span>
<span class="gi">+    max_height = max(heights[u] for u in heights if u != s)</span>
<span class="gi">+    heights[s] = n</span>
<span class="gi">+</span>
<span class="gi">+    grt = GlobalRelabelThreshold(n, R.size(), global_relabel_freq)</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize heights and &#39;current edge&#39; data structures of the nodes.</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        R_nodes[u][&quot;height&quot;] = heights[u] if u in heights else n + 1</span>
<span class="gi">+        R_nodes[u][&quot;curr_edge&quot;] = CurrentEdge(R_succ[u])</span>
<span class="gi">+</span>
<span class="gi">+    def push(u, v, flow):</span>
<span class="gi">+        &quot;&quot;&quot;Push flow units of flow from u to v.&quot;&quot;&quot;</span>
<span class="gi">+        R_succ[u][v][&quot;flow&quot;] += flow</span>
<span class="gi">+        R_succ[v][u][&quot;flow&quot;] -= flow</span>
<span class="gi">+        R_nodes[u][&quot;excess&quot;] -= flow</span>
<span class="gi">+        R_nodes[v][&quot;excess&quot;] += flow</span>
<span class="gi">+</span>
<span class="gi">+    # The maximum flow must be nonzero now. Initialize the preflow by</span>
<span class="gi">+    # saturating all edges emanating from s.</span>
<span class="gi">+    for u, attr in R_succ[s].items():</span>
<span class="gi">+        flow = attr[&quot;capacity&quot;]</span>
<span class="gi">+        if flow &gt; 0:</span>
<span class="gi">+            push(s, u, flow)</span>
<span class="gi">+</span>
<span class="gi">+    # Partition nodes into levels.</span>
<span class="gi">+    levels = [Level() for i in range(2 * n)]</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        if u != s and u != t:</span>
<span class="gi">+            level = levels[R_nodes[u][&quot;height&quot;]]</span>
<span class="gi">+            if R_nodes[u][&quot;excess&quot;] &gt; 0:</span>
<span class="gi">+                level.active.add(u)</span>
<span class="gi">+            else:</span>
<span class="gi">+                level.inactive.add(u)</span>
<span class="gi">+</span>
<span class="gi">+    def activate(v):</span>
<span class="gi">+        &quot;&quot;&quot;Move a node from the inactive set to the active set of its level.&quot;&quot;&quot;</span>
<span class="gi">+        if v != s and v != t:</span>
<span class="gi">+            level = levels[R_nodes[v][&quot;height&quot;]]</span>
<span class="gi">+            if v in level.inactive:</span>
<span class="gi">+                level.inactive.remove(v)</span>
<span class="gi">+                level.active.add(v)</span>
<span class="gi">+</span>
<span class="gi">+    def relabel(u):</span>
<span class="gi">+        &quot;&quot;&quot;Relabel a node to create an admissible edge.&quot;&quot;&quot;</span>
<span class="gi">+        grt.add_work(len(R_succ[u]))</span>
<span class="gi">+        return (</span>
<span class="gi">+            min(</span>
<span class="gi">+                R_nodes[v][&quot;height&quot;]</span>
<span class="gi">+                for v, attr in R_succ[u].items()</span>
<span class="gi">+                if attr[&quot;flow&quot;] &lt; attr[&quot;capacity&quot;]</span>
<span class="gi">+            )</span>
<span class="gi">+            + 1</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def discharge(u, is_phase1):</span>
<span class="gi">+        &quot;&quot;&quot;Discharge a node until it becomes inactive or, during phase 1 (see</span>
<span class="gi">+        below), its height reaches at least n. The node is known to have the</span>
<span class="gi">+        largest height among active nodes.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        height = R_nodes[u][&quot;height&quot;]</span>
<span class="gi">+        curr_edge = R_nodes[u][&quot;curr_edge&quot;]</span>
<span class="gi">+        # next_height represents the next height to examine after discharging</span>
<span class="gi">+        # the current node. During phase 1, it is capped to below n.</span>
<span class="gi">+        next_height = height</span>
<span class="gi">+        levels[height].active.remove(u)</span>
<span class="gi">+        while True:</span>
<span class="gi">+            v, attr = curr_edge.get()</span>
<span class="gi">+            if height == R_nodes[v][&quot;height&quot;] + 1 and attr[&quot;flow&quot;] &lt; attr[&quot;capacity&quot;]:</span>
<span class="gi">+                flow = min(R_nodes[u][&quot;excess&quot;], attr[&quot;capacity&quot;] - attr[&quot;flow&quot;])</span>
<span class="gi">+                push(u, v, flow)</span>
<span class="gi">+                activate(v)</span>
<span class="gi">+                if R_nodes[u][&quot;excess&quot;] == 0:</span>
<span class="gi">+                    # The node has become inactive.</span>
<span class="gi">+                    levels[height].inactive.add(u)</span>
<span class="gi">+                    break</span>
<span class="gi">+            try:</span>
<span class="gi">+                curr_edge.move_to_next()</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                # We have run off the end of the adjacency list, and there can</span>
<span class="gi">+                # be no more admissible edges. Relabel the node to create one.</span>
<span class="gi">+                height = relabel(u)</span>
<span class="gi">+                if is_phase1 and height &gt;= n - 1:</span>
<span class="gi">+                    # Although the node is still active, with a height at least</span>
<span class="gi">+                    # n - 1, it is now known to be on the s side of the minimum</span>
<span class="gi">+                    # s-t cut. Stop processing it until phase 2.</span>
<span class="gi">+                    levels[height].active.add(u)</span>
<span class="gi">+                    break</span>
<span class="gi">+                # The first relabel operation after global relabeling may not</span>
<span class="gi">+                # increase the height of the node since the &#39;current edge&#39; data</span>
<span class="gi">+                # structure is not rewound. Use height instead of (height - 1)</span>
<span class="gi">+                # in case other active nodes at the same level are missed.</span>
<span class="gi">+                next_height = height</span>
<span class="gi">+        R_nodes[u][&quot;height&quot;] = height</span>
<span class="gi">+        return next_height</span>
<span class="gi">+</span>
<span class="gi">+    def gap_heuristic(height):</span>
<span class="gi">+        &quot;&quot;&quot;Apply the gap heuristic.&quot;&quot;&quot;</span>
<span class="gi">+        # Move all nodes at levels (height + 1) to max_height to level n + 1.</span>
<span class="gi">+        for level in islice(levels, height + 1, max_height + 1):</span>
<span class="gi">+            for u in level.active:</span>
<span class="gi">+                R_nodes[u][&quot;height&quot;] = n + 1</span>
<span class="gi">+            for u in level.inactive:</span>
<span class="gi">+                R_nodes[u][&quot;height&quot;] = n + 1</span>
<span class="gi">+            levels[n + 1].active.update(level.active)</span>
<span class="gi">+            level.active.clear()</span>
<span class="gi">+            levels[n + 1].inactive.update(level.inactive)</span>
<span class="gi">+            level.inactive.clear()</span>
<span class="gi">+</span>
<span class="gi">+    def global_relabel(from_sink):</span>
<span class="gi">+        &quot;&quot;&quot;Apply the global relabeling heuristic.&quot;&quot;&quot;</span>
<span class="gi">+        src = t if from_sink else s</span>
<span class="gi">+        heights = reverse_bfs(src)</span>
<span class="gi">+        if not from_sink:</span>
<span class="gi">+            # s must be reachable from t. Remove t explicitly.</span>
<span class="gi">+            del heights[t]</span>
<span class="gi">+        max_height = max(heights.values())</span>
<span class="gi">+        if from_sink:</span>
<span class="gi">+            # Also mark nodes from which t is unreachable for relabeling. This</span>
<span class="gi">+            # serves the same purpose as the gap heuristic.</span>
<span class="gi">+            for u in R:</span>
<span class="gi">+                if u not in heights and R_nodes[u][&quot;height&quot;] &lt; n:</span>
<span class="gi">+                    heights[u] = n + 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Shift the computed heights because the height of s is n.</span>
<span class="gi">+            for u in heights:</span>
<span class="gi">+                heights[u] += n</span>
<span class="gi">+            max_height += n</span>
<span class="gi">+        del heights[src]</span>
<span class="gi">+        for u, new_height in heights.items():</span>
<span class="gi">+            old_height = R_nodes[u][&quot;height&quot;]</span>
<span class="gi">+            if new_height != old_height:</span>
<span class="gi">+                if u in levels[old_height].active:</span>
<span class="gi">+                    levels[old_height].active.remove(u)</span>
<span class="gi">+                    levels[new_height].active.add(u)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    levels[old_height].inactive.remove(u)</span>
<span class="gi">+                    levels[new_height].inactive.add(u)</span>
<span class="gi">+                R_nodes[u][&quot;height&quot;] = new_height</span>
<span class="gi">+        return max_height</span>
<span class="gi">+</span>
<span class="gi">+    # Phase 1: Find the maximum preflow by pushing as much flow as possible to</span>
<span class="gi">+    # t.</span>
<span class="gi">+</span>
<span class="gi">+    height = max_height</span>
<span class="gi">+    while height &gt; 0:</span>
<span class="gi">+        # Discharge active nodes in the current level.</span>
<span class="gi">+        while True:</span>
<span class="gi">+            level = levels[height]</span>
<span class="gi">+            if not level.active:</span>
<span class="gi">+                # All active nodes in the current level have been discharged.</span>
<span class="gi">+                # Move to the next lower level.</span>
<span class="gi">+                height -= 1</span>
<span class="gi">+                break</span>
<span class="gi">+            # Record the old height and level for the gap heuristic.</span>
<span class="gi">+            old_height = height</span>
<span class="gi">+            old_level = level</span>
<span class="gi">+            u = arbitrary_element(level.active)</span>
<span class="gi">+            height = discharge(u, True)</span>
<span class="gi">+            if grt.is_reached():</span>
<span class="gi">+                # Global relabeling heuristic: Recompute the exact heights of</span>
<span class="gi">+                # all nodes.</span>
<span class="gi">+                height = global_relabel(True)</span>
<span class="gi">+                max_height = height</span>
<span class="gi">+                grt.clear_work()</span>
<span class="gi">+            elif not old_level.active and not old_level.inactive:</span>
<span class="gi">+                # Gap heuristic: If the level at old_height is empty (a &#39;gap&#39;),</span>
<span class="gi">+                # a minimum cut has been identified. All nodes with heights</span>
<span class="gi">+                # above old_height can have their heights set to n + 1 and not</span>
<span class="gi">+                # be further processed before a maximum preflow is found.</span>
<span class="gi">+                gap_heuristic(old_height)</span>
<span class="gi">+                height = old_height - 1</span>
<span class="gi">+                max_height = height</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Update the height of the highest level with at least one</span>
<span class="gi">+                # active node.</span>
<span class="gi">+                max_height = max(max_height, height)</span>
<span class="gi">+</span>
<span class="gi">+    # A maximum preflow has been found. The excess at t is the maximum flow</span>
<span class="gi">+    # value.</span>
<span class="gi">+    if value_only:</span>
<span class="gi">+        R.graph[&quot;flow_value&quot;] = R_nodes[t][&quot;excess&quot;]</span>
<span class="gi">+        return R</span>
<span class="gi">+</span>
<span class="gi">+    # Phase 2: Convert the maximum preflow into a maximum flow by returning the</span>
<span class="gi">+    # excess to s.</span>
<span class="gi">+</span>
<span class="gi">+    # Relabel all nodes so that they have accurate heights.</span>
<span class="gi">+    height = global_relabel(False)</span>
<span class="gi">+    grt.clear_work()</span>
<span class="gi">+</span>
<span class="gi">+    # Continue to discharge the active nodes.</span>
<span class="gi">+    while height &gt; n:</span>
<span class="gi">+        # Discharge active nodes in the current level.</span>
<span class="gi">+        while True:</span>
<span class="gi">+            level = levels[height]</span>
<span class="gi">+            if not level.active:</span>
<span class="gi">+                # All active nodes in the current level have been discharged.</span>
<span class="gi">+                # Move to the next lower level.</span>
<span class="gi">+                height -= 1</span>
<span class="gi">+                break</span>
<span class="gi">+            u = arbitrary_element(level.active)</span>
<span class="gi">+            height = discharge(u, False)</span>
<span class="gi">+            if grt.is_reached():</span>
<span class="gi">+                # Global relabeling heuristic.</span>
<span class="gi">+                height = global_relabel(False)</span>
<span class="gi">+                grt.clear_work()</span>
<span class="gi">+</span>
<span class="gi">+    R.graph[&quot;flow_value&quot;] = R_nodes[t][&quot;excess&quot;]</span>
<span class="gi">+    return R</span>


<span class="gd">-@nx._dispatchable(edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)}, returns_graph=True)</span>
<span class="gd">-def preflow_push(G, s, t, capacity=&#39;capacity&#39;, residual=None,</span>
<span class="gd">-    global_relabel_freq=1, value_only=False):</span>
<span class="gd">-    &quot;&quot;&quot;Find a maximum single-commodity flow using the highest-label</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)}, returns_graph=True)</span>
<span class="gi">+def preflow_push(</span>
<span class="gi">+    G, s, t, capacity=&quot;capacity&quot;, residual=None, global_relabel_freq=1, value_only=False</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Find a maximum single-commodity flow using the highest-label</span>
<span class="w"> </span>    preflow-push algorithm.

<span class="w"> </span>    This function returns the residual network resulting after computing
<span class="w"> </span>    the maximum flow. See below for details about the conventions
<span class="w"> </span>    NetworkX uses for defining residual networks.

<span class="gd">-    This algorithm has a running time of $O(n^2 \\sqrt{m})$ for $n$ nodes and</span>
<span class="gi">+    This algorithm has a running time of $O(n^2 \sqrt{m})$ for $n$ nodes and</span>
<span class="w"> </span>    $m$ edges.


<span class="gu">@@ -145,4 +419,7 @@ def preflow_push(G, s, t, capacity=&#39;capacity&#39;, residual=None,</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only)</span>
<span class="gi">+    R.graph[&quot;algorithm&quot;] = &quot;preflow_push&quot;</span>
<span class="gi">+    nx._clear_cache(R)</span>
<span class="gi">+    return R</span>
<span class="gh">diff --git a/networkx/algorithms/flow/shortestaugmentingpath.py b/networkx/algorithms/flow/shortestaugmentingpath.py</span>
<span class="gh">index 2bbab9bb7..9f1193f1c 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/shortestaugmentingpath.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/shortestaugmentingpath.py</span>
<span class="gu">@@ -1,23 +1,180 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Shortest augmenting path algorithm for maximum flow problems.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import deque
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from .edmondskarp import edmonds_karp_core
<span class="w"> </span>from .utils import CurrentEdge, build_residual_network
<span class="gd">-__all__ = [&#39;shortest_augmenting_path&#39;]</span>

<span class="gi">+__all__ = [&quot;shortest_augmenting_path&quot;]</span>

<span class="gd">-def shortest_augmenting_path_impl(G, s, t, capacity, residual, two_phase,</span>
<span class="gd">-    cutoff):</span>
<span class="gi">+</span>
<span class="gi">+def shortest_augmenting_path_impl(G, s, t, capacity, residual, two_phase, cutoff):</span>
<span class="w"> </span>    &quot;&quot;&quot;Implementation of the shortest augmenting path algorithm.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if s not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(s)} not in graph&quot;)</span>
<span class="gi">+    if t not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;node {str(t)} not in graph&quot;)</span>
<span class="gi">+    if s == t:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;source and sink are the same node&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if residual is None:</span>
<span class="gi">+        R = build_residual_network(G, capacity)</span>
<span class="gi">+    else:</span>
<span class="gi">+        R = residual</span>
<span class="gi">+</span>
<span class="gi">+    R_nodes = R.nodes</span>
<span class="gi">+    R_pred = R.pred</span>
<span class="gi">+    R_succ = R.succ</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize/reset the residual network.</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        for e in R_succ[u].values():</span>
<span class="gi">+            e[&quot;flow&quot;] = 0</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize heights of the nodes.</span>
<span class="gi">+    heights = {t: 0}</span>
<span class="gi">+    q = deque([(t, 0)])</span>
<span class="gi">+    while q:</span>
<span class="gi">+        u, height = q.popleft()</span>
<span class="gi">+        height += 1</span>
<span class="gi">+        for v, attr in R_pred[u].items():</span>
<span class="gi">+            if v not in heights and attr[&quot;flow&quot;] &lt; attr[&quot;capacity&quot;]:</span>
<span class="gi">+                heights[v] = height</span>
<span class="gi">+                q.append((v, height))</span>
<span class="gi">+</span>
<span class="gi">+    if s not in heights:</span>
<span class="gi">+        # t is not reachable from s in the residual network. The maximum flow</span>
<span class="gi">+        # must be zero.</span>
<span class="gi">+        R.graph[&quot;flow_value&quot;] = 0</span>
<span class="gi">+        return R</span>
<span class="gi">+</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    m = R.size() / 2</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize heights and &#39;current edge&#39; data structures of the nodes.</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        R_nodes[u][&quot;height&quot;] = heights[u] if u in heights else n</span>
<span class="gi">+        R_nodes[u][&quot;curr_edge&quot;] = CurrentEdge(R_succ[u])</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize counts of nodes in each level.</span>
<span class="gi">+    counts = [0] * (2 * n - 1)</span>
<span class="gi">+    for u in R:</span>
<span class="gi">+        counts[R_nodes[u][&quot;height&quot;]] += 1</span>
<span class="gi">+</span>
<span class="gi">+    inf = R.graph[&quot;inf&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def augment(path):</span>
<span class="gi">+        &quot;&quot;&quot;Augment flow along a path from s to t.&quot;&quot;&quot;</span>
<span class="gi">+        # Determine the path residual capacity.</span>
<span class="gi">+        flow = inf</span>
<span class="gi">+        it = iter(path)</span>
<span class="gi">+        u = next(it)</span>
<span class="gi">+        for v in it:</span>
<span class="gi">+            attr = R_succ[u][v]</span>
<span class="gi">+            flow = min(flow, attr[&quot;capacity&quot;] - attr[&quot;flow&quot;])</span>
<span class="gi">+            u = v</span>
<span class="gi">+        if flow * 2 &gt; inf:</span>
<span class="gi">+            raise nx.NetworkXUnbounded(&quot;Infinite capacity path, flow unbounded above.&quot;)</span>
<span class="gi">+        # Augment flow along the path.</span>
<span class="gi">+        it = iter(path)</span>
<span class="gi">+        u = next(it)</span>
<span class="gi">+        for v in it:</span>
<span class="gi">+            R_succ[u][v][&quot;flow&quot;] += flow</span>
<span class="gi">+            R_succ[v][u][&quot;flow&quot;] -= flow</span>
<span class="gi">+            u = v</span>
<span class="gi">+        return flow</span>
<span class="gi">+</span>
<span class="gi">+    def relabel(u):</span>
<span class="gi">+        &quot;&quot;&quot;Relabel a node to create an admissible edge.&quot;&quot;&quot;</span>
<span class="gi">+        height = n - 1</span>
<span class="gi">+        for v, attr in R_succ[u].items():</span>
<span class="gi">+            if attr[&quot;flow&quot;] &lt; attr[&quot;capacity&quot;]:</span>
<span class="gi">+                height = min(height, R_nodes[v][&quot;height&quot;])</span>
<span class="gi">+        return height + 1</span>
<span class="gi">+</span>
<span class="gi">+    if cutoff is None:</span>
<span class="gi">+        cutoff = float(&quot;inf&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Phase 1: Look for shortest augmenting paths using depth-first search.</span>
<span class="gi">+</span>
<span class="gi">+    flow_value = 0</span>
<span class="gi">+    path = [s]</span>
<span class="gi">+    u = s</span>
<span class="gi">+    d = n if not two_phase else int(min(m**0.5, 2 * n ** (2.0 / 3)))</span>
<span class="gi">+    done = R_nodes[s][&quot;height&quot;] &gt;= d</span>
<span class="gi">+    while not done:</span>
<span class="gi">+        height = R_nodes[u][&quot;height&quot;]</span>
<span class="gi">+        curr_edge = R_nodes[u][&quot;curr_edge&quot;]</span>
<span class="gi">+        # Depth-first search for the next node on the path to t.</span>
<span class="gi">+        while True:</span>
<span class="gi">+            v, attr = curr_edge.get()</span>
<span class="gi">+            if height == R_nodes[v][&quot;height&quot;] + 1 and attr[&quot;flow&quot;] &lt; attr[&quot;capacity&quot;]:</span>
<span class="gi">+                # Advance to the next node following an admissible edge.</span>
<span class="gi">+                path.append(v)</span>
<span class="gi">+                u = v</span>
<span class="gi">+                break</span>
<span class="gi">+            try:</span>
<span class="gi">+                curr_edge.move_to_next()</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                counts[height] -= 1</span>
<span class="gi">+                if counts[height] == 0:</span>
<span class="gi">+                    # Gap heuristic: If relabeling causes a level to become</span>
<span class="gi">+                    # empty, a minimum cut has been identified. The algorithm</span>
<span class="gi">+                    # can now be terminated.</span>
<span class="gi">+                    R.graph[&quot;flow_value&quot;] = flow_value</span>
<span class="gi">+                    return R</span>
<span class="gi">+                height = relabel(u)</span>
<span class="gi">+                if u == s and height &gt;= d:</span>
<span class="gi">+                    if not two_phase:</span>
<span class="gi">+                        # t is disconnected from s in the residual network. No</span>
<span class="gi">+                        # more augmenting paths exist.</span>
<span class="gi">+                        R.graph[&quot;flow_value&quot;] = flow_value</span>
<span class="gi">+                        return R</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # t is at least d steps away from s. End of phase 1.</span>
<span class="gi">+                        done = True</span>
<span class="gi">+                        break</span>
<span class="gi">+                counts[height] += 1</span>
<span class="gi">+                R_nodes[u][&quot;height&quot;] = height</span>
<span class="gi">+                if u != s:</span>
<span class="gi">+                    # After relabeling, the last edge on the path is no longer</span>
<span class="gi">+                    # admissible. Retreat one step to look for an alternative.</span>
<span class="gi">+                    path.pop()</span>
<span class="gi">+                    u = path[-1]</span>
<span class="gi">+                    break</span>
<span class="gi">+        if u == t:</span>
<span class="gi">+            # t is reached. Augment flow along the path and reset it for a new</span>
<span class="gi">+            # depth-first search.</span>
<span class="gi">+            flow_value += augment(path)</span>
<span class="gi">+            if flow_value &gt;= cutoff:</span>
<span class="gi">+                R.graph[&quot;flow_value&quot;] = flow_value</span>
<span class="gi">+                return R</span>
<span class="gi">+            path = [s]</span>
<span class="gi">+            u = s</span>
<span class="gi">+</span>
<span class="gi">+    # Phase 2: Look for shortest augmenting paths using breadth-first search.</span>
<span class="gi">+    flow_value += edmonds_karp_core(R, s, t, cutoff - flow_value)</span>
<span class="gi">+</span>
<span class="gi">+    R.graph[&quot;flow_value&quot;] = flow_value</span>
<span class="gi">+    return R</span>


<span class="gd">-@nx._dispatchable(edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)}, returns_graph=True)</span>
<span class="gd">-def shortest_augmenting_path(G, s, t, capacity=&#39;capacity&#39;, residual=None,</span>
<span class="gd">-    value_only=False, two_phase=False, cutoff=None):</span>
<span class="gd">-    &quot;&quot;&quot;Find a maximum single-commodity flow using the shortest augmenting path</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)}, returns_graph=True)</span>
<span class="gi">+def shortest_augmenting_path(</span>
<span class="gi">+    G,</span>
<span class="gi">+    s,</span>
<span class="gi">+    t,</span>
<span class="gi">+    capacity=&quot;capacity&quot;,</span>
<span class="gi">+    residual=None,</span>
<span class="gi">+    value_only=False,</span>
<span class="gi">+    two_phase=False,</span>
<span class="gi">+    cutoff=None,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Find a maximum single-commodity flow using the shortest augmenting path</span>
<span class="w"> </span>    algorithm.

<span class="w"> </span>    This function returns the residual network resulting after computing
<span class="gu">@@ -58,7 +215,7 @@ def shortest_augmenting_path(G, s, t, capacity=&#39;capacity&#39;, residual=None,</span>
<span class="w"> </span>    two_phase : bool
<span class="w"> </span>        If True, a two-phase variant is used. The two-phase variant improves
<span class="w"> </span>        the running time on unit-capacity networks from $O(nm)$ to
<span class="gd">-        $O(\\min(n^{2/3}, m^{1/2}) m)$. Default value: False.</span>
<span class="gi">+        $O(\min(n^{2/3}, m^{1/2}) m)$. Default value: False.</span>

<span class="w"> </span>    cutoff : integer, float
<span class="w"> </span>        If specified, the algorithm will terminate when the flow value reaches
<span class="gu">@@ -137,4 +294,7 @@ def shortest_augmenting_path(G, s, t, capacity=&#39;capacity&#39;, residual=None,</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = shortest_augmenting_path_impl(G, s, t, capacity, residual, two_phase, cutoff)</span>
<span class="gi">+    R.graph[&quot;algorithm&quot;] = &quot;shortest_augmenting_path&quot;</span>
<span class="gi">+    nx._clear_cache(R)</span>
<span class="gi">+    return R</span>
<span class="gh">diff --git a/networkx/algorithms/flow/utils.py b/networkx/algorithms/flow/utils.py</span>
<span class="gh">index c33d79d27..03f1d10f7 100644</span>
<span class="gd">--- a/networkx/algorithms/flow/utils.py</span>
<span class="gi">+++ b/networkx/algorithms/flow/utils.py</span>
<span class="gu">@@ -1,27 +1,52 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Utility classes and functions for network flow algorithms.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import deque
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;CurrentEdge&#39;, &#39;Level&#39;, &#39;GlobalRelabelThreshold&#39;,</span>
<span class="gd">-    &#39;build_residual_network&#39;, &#39;detect_unboundedness&#39;, &#39;build_flow_dict&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;CurrentEdge&quot;,</span>
<span class="gi">+    &quot;Level&quot;,</span>
<span class="gi">+    &quot;GlobalRelabelThreshold&quot;,</span>
<span class="gi">+    &quot;build_residual_network&quot;,</span>
<span class="gi">+    &quot;detect_unboundedness&quot;,</span>
<span class="gi">+    &quot;build_flow_dict&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class CurrentEdge:
<span class="w"> </span>    &quot;&quot;&quot;Mechanism for iterating over out-edges incident to a node in a circular
<span class="w"> </span>    manner. StopIteration exception is raised when wraparound occurs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_edges&#39;, &#39;_it&#39;, &#39;_curr&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;_edges&quot;, &quot;_it&quot;, &quot;_curr&quot;)</span>

<span class="w"> </span>    def __init__(self, edges):
<span class="w"> </span>        self._edges = edges
<span class="w"> </span>        if self._edges:
<span class="w"> </span>            self._rewind()

<span class="gi">+    def get(self):</span>
<span class="gi">+        return self._curr</span>
<span class="gi">+</span>
<span class="gi">+    def move_to_next(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._curr = next(self._it)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            self._rewind()</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+    def _rewind(self):</span>
<span class="gi">+        self._it = iter(self._edges.items())</span>
<span class="gi">+        self._curr = next(self._it)</span>
<span class="gi">+</span>

<span class="w"> </span>class Level:
<span class="w"> </span>    &quot;&quot;&quot;Active and inactive nodes in a level.&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;active&#39;, &#39;inactive&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;active&quot;, &quot;inactive&quot;)</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.active = set()
<span class="gu">@@ -34,11 +59,20 @@ class GlobalRelabelThreshold:</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, n, m, freq):
<span class="gd">-        self._threshold = (n + m) / freq if freq else float(&#39;inf&#39;)</span>
<span class="gi">+        self._threshold = (n + m) / freq if freq else float(&quot;inf&quot;)</span>
<span class="w"> </span>        self._work = 0

<span class="gi">+    def add_work(self, work):</span>
<span class="gi">+        self._work += work</span>

<span class="gd">-@nx._dispatchable(edge_attrs={&#39;capacity&#39;: float(&#39;inf&#39;)}, returns_graph=True)</span>
<span class="gi">+    def is_reached(self):</span>
<span class="gi">+        return self._work &gt;= self._threshold</span>
<span class="gi">+</span>
<span class="gi">+    def clear_work(self):</span>
<span class="gi">+        self._work = 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;capacity&quot;: float(&quot;inf&quot;)}, returns_graph=True)</span>
<span class="w"> </span>def build_residual_network(G, capacity):
<span class="w"> </span>    &quot;&quot;&quot;Build a residual network and initialize a zero flow.

<span class="gu">@@ -64,18 +98,92 @@ def build_residual_network(G, capacity):</span>
<span class="w"> </span>    :samp:`s`-:samp:`t` cut.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;R&#39;, preserve_edge_attrs={&#39;R&#39;: {&#39;capacity&#39;: float(</span>
<span class="gd">-    &#39;inf&#39;)}}, preserve_graph_attrs=True)</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;MultiGraph and MultiDiGraph not supported (yet).&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    R = nx.DiGraph()</span>
<span class="gi">+    R.__networkx_cache__ = None  # Disable caching</span>
<span class="gi">+    R.add_nodes_from(G)</span>
<span class="gi">+</span>
<span class="gi">+    inf = float(&quot;inf&quot;)</span>
<span class="gi">+    # Extract edges with positive capacities. Self loops excluded.</span>
<span class="gi">+    edge_list = [</span>
<span class="gi">+        (u, v, attr)</span>
<span class="gi">+        for u, v, attr in G.edges(data=True)</span>
<span class="gi">+        if u != v and attr.get(capacity, inf) &gt; 0</span>
<span class="gi">+    ]</span>
<span class="gi">+    # Simulate infinity with three times the sum of the finite edge capacities</span>
<span class="gi">+    # or any positive value if the sum is zero. This allows the</span>
<span class="gi">+    # infinite-capacity edges to be distinguished for unboundedness detection</span>
<span class="gi">+    # and directly participate in residual capacity calculation. If the maximum</span>
<span class="gi">+    # flow is finite, these edges cannot appear in the minimum cut and thus</span>
<span class="gi">+    # guarantee correctness. Since the residual capacity of an</span>
<span class="gi">+    # infinite-capacity edge is always at least 2/3 of inf, while that of an</span>
<span class="gi">+    # finite-capacity edge is at most 1/3 of inf, if an operation moves more</span>
<span class="gi">+    # than 1/3 of inf units of flow to t, there must be an infinite-capacity</span>
<span class="gi">+    # s-t path in G.</span>
<span class="gi">+    inf = (</span>
<span class="gi">+        3</span>
<span class="gi">+        * sum(</span>
<span class="gi">+            attr[capacity]</span>
<span class="gi">+            for u, v, attr in edge_list</span>
<span class="gi">+            if capacity in attr and attr[capacity] != inf</span>
<span class="gi">+        )</span>
<span class="gi">+        or 1</span>
<span class="gi">+    )</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        for u, v, attr in edge_list:</span>
<span class="gi">+            r = min(attr.get(capacity, inf), inf)</span>
<span class="gi">+            if not R.has_edge(u, v):</span>
<span class="gi">+                # Both (u, v) and (v, u) must be present in the residual</span>
<span class="gi">+                # network.</span>
<span class="gi">+                R.add_edge(u, v, capacity=r)</span>
<span class="gi">+                R.add_edge(v, u, capacity=0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # The edge (u, v) was added when (v, u) was visited.</span>
<span class="gi">+                R[u][v][&quot;capacity&quot;] = r</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u, v, attr in edge_list:</span>
<span class="gi">+            # Add a pair of edges with equal residual capacities.</span>
<span class="gi">+            r = min(attr.get(capacity, inf), inf)</span>
<span class="gi">+            R.add_edge(u, v, capacity=r)</span>
<span class="gi">+            R.add_edge(v, u, capacity=r)</span>
<span class="gi">+</span>
<span class="gi">+    # Record the value simulating infinity.</span>
<span class="gi">+    R.graph[&quot;inf&quot;] = inf</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs=&quot;R&quot;,</span>
<span class="gi">+    preserve_edge_attrs={&quot;R&quot;: {&quot;capacity&quot;: float(&quot;inf&quot;)}},</span>
<span class="gi">+    preserve_graph_attrs=True,</span>
<span class="gi">+)</span>
<span class="w"> </span>def detect_unboundedness(R, s, t):
<span class="w"> </span>    &quot;&quot;&quot;Detect an infinite-capacity s-t path in R.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs={&#39;G&#39;: 0, &#39;R&#39;: 1}, preserve_edge_attrs={&#39;R&#39;: {</span>
<span class="gd">-    &#39;flow&#39;: None}})</span>
<span class="gi">+    q = deque([s])</span>
<span class="gi">+    seen = {s}</span>
<span class="gi">+    inf = R.graph[&quot;inf&quot;]</span>
<span class="gi">+    while q:</span>
<span class="gi">+        u = q.popleft()</span>
<span class="gi">+        for v, attr in R[u].items():</span>
<span class="gi">+            if attr[&quot;capacity&quot;] == inf and v not in seen:</span>
<span class="gi">+                if v == t:</span>
<span class="gi">+                    raise nx.NetworkXUnbounded(</span>
<span class="gi">+                        &quot;Infinite capacity path, flow unbounded above.&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                seen.add(v)</span>
<span class="gi">+                q.append(v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G&quot;: 0, &quot;R&quot;: 1}, preserve_edge_attrs={&quot;R&quot;: {&quot;flow&quot;: None}})</span>
<span class="w"> </span>def build_flow_dict(G, R):
<span class="w"> </span>    &quot;&quot;&quot;Build a flow dictionary from a residual network.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    flow_dict = {}</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        flow_dict[u] = {v: 0 for v in G[u]}</span>
<span class="gi">+        flow_dict[u].update(</span>
<span class="gi">+            (v, attr[&quot;flow&quot;]) for v, attr in R[u].items() if attr[&quot;flow&quot;] &gt; 0</span>
<span class="gi">+        )</span>
<span class="gi">+    return flow_dict</span>
<span class="gh">diff --git a/networkx/algorithms/graph_hashing.py b/networkx/algorithms/graph_hashing.py</span>
<span class="gh">index e2c0be264..b3761bf57 100644</span>
<span class="gd">--- a/networkx/algorithms/graph_hashing.py</span>
<span class="gi">+++ b/networkx/algorithms/graph_hashing.py</span>
<span class="gu">@@ -3,10 +3,26 @@ Functions for hashing graphs to strings.</span>
<span class="w"> </span>Isomorphic graphs should be assigned identical hashes.
<span class="w"> </span>For now, only Weisfeiler-Lehman hashing is implemented.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import Counter, defaultdict
<span class="w"> </span>from hashlib import blake2b
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;weisfeiler_lehman_graph_hash&#39;, &#39;weisfeiler_lehman_subgraph_hashes&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;weisfeiler_lehman_graph_hash&quot;, &quot;weisfeiler_lehman_subgraph_hashes&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _hash_label(label, digest_size):</span>
<span class="gi">+    return blake2b(label.encode(&quot;ascii&quot;), digest_size=digest_size).hexdigest()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _init_node_labels(G, edge_attr, node_attr):</span>
<span class="gi">+    if node_attr:</span>
<span class="gi">+        return {u: str(dd[node_attr]) for u, dd in G.nodes(data=True)}</span>
<span class="gi">+    elif edge_attr:</span>
<span class="gi">+        return {u: &quot;&quot; for u in G}</span>
<span class="gi">+    else:</span>
<span class="gi">+        return {u: str(deg) for u, deg in G.degree()}</span>


<span class="w"> </span>def _neighborhood_aggregate(G, node, node_labels, edge_attr=None):
<span class="gu">@@ -14,12 +30,17 @@ def _neighborhood_aggregate(G, node, node_labels, edge_attr=None):</span>
<span class="w"> </span>    Compute new labels for given node by aggregating
<span class="w"> </span>    the labels of each node&#39;s neighbors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    label_list = []</span>
<span class="gi">+    for nbr in G.neighbors(node):</span>
<span class="gi">+        prefix = &quot;&quot; if edge_attr is None else str(G[node][nbr][edge_attr])</span>
<span class="gi">+        label_list.append(prefix + node_labels[nbr])</span>
<span class="gi">+    return node_labels[node] + &quot;&quot;.join(sorted(label_list))</span>


<span class="gd">-@nx._dispatchable(edge_attrs={&#39;edge_attr&#39;: None}, node_attrs=&#39;node_attr&#39;)</span>
<span class="gd">-def weisfeiler_lehman_graph_hash(G, edge_attr=None, node_attr=None,</span>
<span class="gd">-    iterations=3, digest_size=16):</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;edge_attr&quot;: None}, node_attrs=&quot;node_attr&quot;)</span>
<span class="gi">+def weisfeiler_lehman_graph_hash(</span>
<span class="gi">+    G, edge_attr=None, node_attr=None, iterations=3, digest_size=16</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return Weisfeiler Lehman (WL) graph hash.

<span class="w"> </span>    The function iteratively aggregates and hashes neighborhoods of each node.
<span class="gu">@@ -112,12 +133,42 @@ def weisfeiler_lehman_graph_hash(G, edge_attr=None, node_attr=None,</span>
<span class="w"> </span>    --------
<span class="w"> </span>    weisfeiler_lehman_subgraph_hashes
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs={&#39;edge_attr&#39;: None}, node_attrs=&#39;node_attr&#39;)</span>
<span class="gd">-def weisfeiler_lehman_subgraph_hashes(G, edge_attr=None, node_attr=None,</span>
<span class="gd">-    iterations=3, digest_size=16, include_initial_labels=False):</span>
<span class="gi">+    def weisfeiler_lehman_step(G, labels, edge_attr=None):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Apply neighborhood aggregation to each node</span>
<span class="gi">+        in the graph.</span>
<span class="gi">+        Computes a dictionary with labels for each node.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        new_labels = {}</span>
<span class="gi">+        for node in G.nodes():</span>
<span class="gi">+            label = _neighborhood_aggregate(G, node, labels, edge_attr=edge_attr)</span>
<span class="gi">+            new_labels[node] = _hash_label(label, digest_size)</span>
<span class="gi">+        return new_labels</span>
<span class="gi">+</span>
<span class="gi">+    # set initial node labels</span>
<span class="gi">+    node_labels = _init_node_labels(G, edge_attr, node_attr)</span>
<span class="gi">+</span>
<span class="gi">+    subgraph_hash_counts = []</span>
<span class="gi">+    for _ in range(iterations):</span>
<span class="gi">+        node_labels = weisfeiler_lehman_step(G, node_labels, edge_attr=edge_attr)</span>
<span class="gi">+        counter = Counter(node_labels.values())</span>
<span class="gi">+        # sort the counter, extend total counts</span>
<span class="gi">+        subgraph_hash_counts.extend(sorted(counter.items(), key=lambda x: x[0]))</span>
<span class="gi">+</span>
<span class="gi">+    # hash the final counter</span>
<span class="gi">+    return _hash_label(str(tuple(subgraph_hash_counts)), digest_size)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;edge_attr&quot;: None}, node_attrs=&quot;node_attr&quot;)</span>
<span class="gi">+def weisfeiler_lehman_subgraph_hashes(</span>
<span class="gi">+    G,</span>
<span class="gi">+    edge_attr=None,</span>
<span class="gi">+    node_attr=None,</span>
<span class="gi">+    iterations=3,</span>
<span class="gi">+    digest_size=16,</span>
<span class="gi">+    include_initial_labels=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return a dictionary of subgraph hashes by node.

<span class="gu">@@ -238,4 +289,34 @@ def weisfeiler_lehman_subgraph_hashes(G, edge_attr=None, node_attr=None,</span>
<span class="w"> </span>    --------
<span class="w"> </span>    weisfeiler_lehman_graph_hash
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def weisfeiler_lehman_step(G, labels, node_subgraph_hashes, edge_attr=None):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Apply neighborhood aggregation to each node</span>
<span class="gi">+        in the graph.</span>
<span class="gi">+        Computes a dictionary with labels for each node.</span>
<span class="gi">+        Appends the new hashed label to the dictionary of subgraph hashes</span>
<span class="gi">+        originating from and indexed by each node in G</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        new_labels = {}</span>
<span class="gi">+        for node in G.nodes():</span>
<span class="gi">+            label = _neighborhood_aggregate(G, node, labels, edge_attr=edge_attr)</span>
<span class="gi">+            hashed_label = _hash_label(label, digest_size)</span>
<span class="gi">+            new_labels[node] = hashed_label</span>
<span class="gi">+            node_subgraph_hashes[node].append(hashed_label)</span>
<span class="gi">+        return new_labels</span>
<span class="gi">+</span>
<span class="gi">+    node_labels = _init_node_labels(G, edge_attr, node_attr)</span>
<span class="gi">+    if include_initial_labels:</span>
<span class="gi">+        node_subgraph_hashes = {</span>
<span class="gi">+            k: [_hash_label(v, digest_size)] for k, v in node_labels.items()</span>
<span class="gi">+        }</span>
<span class="gi">+    else:</span>
<span class="gi">+        node_subgraph_hashes = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+    for _ in range(iterations):</span>
<span class="gi">+        node_labels = weisfeiler_lehman_step(</span>
<span class="gi">+            G, node_labels, node_subgraph_hashes, edge_attr</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return dict(node_subgraph_hashes)</span>
<span class="gh">diff --git a/networkx/algorithms/graphical.py b/networkx/algorithms/graphical.py</span>
<span class="gh">index 8846af1c4..b2ce6c33a 100644</span>
<span class="gd">--- a/networkx/algorithms/graphical.py</span>
<span class="gi">+++ b/networkx/algorithms/graphical.py</span>
<span class="gu">@@ -1,14 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Test sequences for graphiness.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import heapq
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;is_graphical&#39;, &#39;is_multigraphical&#39;, &#39;is_pseudographical&#39;,</span>
<span class="gd">-    &#39;is_digraphical&#39;, &#39;is_valid_degree_sequence_erdos_gallai&#39;,</span>
<span class="gd">-    &#39;is_valid_degree_sequence_havel_hakimi&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;is_graphical&quot;,</span>
<span class="gi">+    &quot;is_multigraphical&quot;,</span>
<span class="gi">+    &quot;is_pseudographical&quot;,</span>
<span class="gi">+    &quot;is_digraphical&quot;,</span>
<span class="gi">+    &quot;is_valid_degree_sequence_erdos_gallai&quot;,</span>
<span class="gi">+    &quot;is_valid_degree_sequence_havel_hakimi&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None)
<span class="gd">-def is_graphical(sequence, method=&#39;eg&#39;):</span>
<span class="gi">+def is_graphical(sequence, method=&quot;eg&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns True if sequence is a valid degree sequence.

<span class="w"> </span>    A degree sequence is valid if some graph can realize it.
<span class="gu">@@ -56,12 +63,39 @@ def is_graphical(sequence, method=&#39;eg&#39;):</span>
<span class="w"> </span>    .. [CL1996] G. Chartrand and L. Lesniak, &quot;Graphs and Digraphs&quot;,
<span class="w"> </span>       Chapman and Hall/CRC, 1996.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if method == &quot;eg&quot;:</span>
<span class="gi">+        valid = is_valid_degree_sequence_erdos_gallai(list(sequence))</span>
<span class="gi">+    elif method == &quot;hh&quot;:</span>
<span class="gi">+        valid = is_valid_degree_sequence_havel_hakimi(list(sequence))</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = &quot;`method` must be &#39;eg&#39; or &#39;hh&#39;&quot;</span>
<span class="gi">+        raise nx.NetworkXException(msg)</span>
<span class="gi">+    return valid</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _basic_graphical_tests(deg_sequence):</span>
<span class="gi">+    # Sort and perform some simple tests on the sequence</span>
<span class="gi">+    deg_sequence = nx.utils.make_list_of_ints(deg_sequence)</span>
<span class="gi">+    p = len(deg_sequence)</span>
<span class="gi">+    num_degs = [0] * p</span>
<span class="gi">+    dmax, dmin, dsum, n = 0, p, 0, 0</span>
<span class="gi">+    for d in deg_sequence:</span>
<span class="gi">+        # Reject if degree is negative or larger than the sequence length</span>
<span class="gi">+        if d &lt; 0 or d &gt;= p:</span>
<span class="gi">+            raise nx.NetworkXUnfeasible</span>
<span class="gi">+        # Process only the non-zero integers</span>
<span class="gi">+        elif d &gt; 0:</span>
<span class="gi">+            dmax, dmin, dsum, n = max(dmax, d), min(dmin, d), dsum + d, n + 1</span>
<span class="gi">+            num_degs[d] += 1</span>
<span class="gi">+    # Reject sequence if it has odd sum or is oversaturated</span>
<span class="gi">+    if dsum % 2 or dsum &gt; n * (n - 1):</span>
<span class="gi">+        raise nx.NetworkXUnfeasible</span>
<span class="gi">+    return dmax, dmin, dsum, n, num_degs</span>


<span class="w"> </span>@nx._dispatchable(graphs=None)
<span class="w"> </span>def is_valid_degree_sequence_havel_hakimi(deg_sequence):
<span class="gd">-    &quot;&quot;&quot;Returns True if deg_sequence can be realized by a simple graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns True if deg_sequence can be realized by a simple graph.</span>

<span class="w"> </span>    The validation proceeds using the Havel-Hakimi theorem
<span class="w"> </span>    [havel1955]_, [hakimi1962]_, [CL1996]_.
<span class="gu">@@ -96,7 +130,7 @@ def is_valid_degree_sequence_havel_hakimi(deg_sequence):</span>
<span class="w"> </span>    The ZZ condition says that for the sequence d if

<span class="w"> </span>    .. math::
<span class="gd">-        |d| &gt;= \\frac{(\\max(d) + \\min(d) + 1)^2}{4*\\min(d)}</span>
<span class="gi">+        |d| &gt;= \frac{(\max(d) + \min(d) + 1)^2}{4*\min(d)}</span>

<span class="w"> </span>    then d is graphical.  This was shown in Theorem 6 in [1]_.

<span class="gu">@@ -111,12 +145,47 @@ def is_valid_degree_sequence_havel_hakimi(deg_sequence):</span>
<span class="w"> </span>    .. [CL1996] G. Chartrand and L. Lesniak, &quot;Graphs and Digraphs&quot;,
<span class="w"> </span>       Chapman and Hall/CRC, 1996.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        dmax, dmin, dsum, n, num_degs = _basic_graphical_tests(deg_sequence)</span>
<span class="gi">+    except nx.NetworkXUnfeasible:</span>
<span class="gi">+        return False</span>
<span class="gi">+    # Accept if sequence has no non-zero degrees or passes the ZZ condition</span>
<span class="gi">+    if n == 0 or 4 * dmin * n &gt;= (dmax + dmin + 1) * (dmax + dmin + 1):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    modstubs = [0] * (dmax + 1)</span>
<span class="gi">+    # Successively reduce degree sequence by removing the maximum degree</span>
<span class="gi">+    while n &gt; 0:</span>
<span class="gi">+        # Retrieve the maximum degree in the sequence</span>
<span class="gi">+        while num_degs[dmax] == 0:</span>
<span class="gi">+            dmax -= 1</span>
<span class="gi">+        # If there are not enough stubs to connect to, then the sequence is</span>
<span class="gi">+        # not graphical</span>
<span class="gi">+        if dmax &gt; n - 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Remove largest stub in list</span>
<span class="gi">+        num_degs[dmax], n = num_degs[dmax] - 1, n - 1</span>
<span class="gi">+        # Reduce the next dmax largest stubs</span>
<span class="gi">+        mslen = 0</span>
<span class="gi">+        k = dmax</span>
<span class="gi">+        for i in range(dmax):</span>
<span class="gi">+            while num_degs[k] == 0:</span>
<span class="gi">+                k -= 1</span>
<span class="gi">+            num_degs[k], n = num_degs[k] - 1, n - 1</span>
<span class="gi">+            if k &gt; 1:</span>
<span class="gi">+                modstubs[mslen] = k - 1</span>
<span class="gi">+                mslen += 1</span>
<span class="gi">+        # Add back to the list any non-zero stubs that were removed</span>
<span class="gi">+        for i in range(mslen):</span>
<span class="gi">+            stub = modstubs[i]</span>
<span class="gi">+            num_degs[stub], n = num_degs[stub] + 1, n + 1</span>
<span class="gi">+    return True</span>


<span class="w"> </span>@nx._dispatchable(graphs=None)
<span class="w"> </span>def is_valid_degree_sequence_erdos_gallai(deg_sequence):
<span class="gd">-    &quot;&quot;&quot;Returns True if deg_sequence can be realized by a simple graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns True if deg_sequence can be realized by a simple graph.</span>

<span class="w"> </span>    The validation is done using the Erdős-Gallai theorem [EG1960]_.

<span class="gu">@@ -154,8 +223,8 @@ def is_valid_degree_sequence_erdos_gallai(deg_sequence):</span>

<span class="w"> </span>     .. math::

<span class="gd">-       \\sum_{i=1}^{k} d_i \\leq k(k-1) + \\sum_{j=k+1}^{n} \\min(d_i,k)</span>
<span class="gd">-             = k(n-1) - ( k \\sum_{j=0}^{k-1} n_j - \\sum_{j=0}^{k-1} j n_j )</span>
<span class="gi">+       \sum_{i=1}^{k} d_i \leq k(k-1) + \sum_{j=k+1}^{n} \min(d_i,k)</span>
<span class="gi">+             = k(n-1) - ( k \sum_{j=0}^{k-1} n_j - \sum_{j=0}^{k-1} j n_j )</span>

<span class="w"> </span>    A strong index k is any index where d_k &gt;= k and the value n_j is the
<span class="w"> </span>    number of occurrences of j in d.  The maximal strong index is called the
<span class="gu">@@ -166,7 +235,7 @@ def is_valid_degree_sequence_erdos_gallai(deg_sequence):</span>
<span class="w"> </span>    The ZZ condition says that for the sequence d if

<span class="w"> </span>    .. math::
<span class="gd">-        |d| &gt;= \\frac{(\\max(d) + \\min(d) + 1)^2}{4*\\min(d)}</span>
<span class="gi">+        |d| &gt;= \frac{(\max(d) + \min(d) + 1)^2}{4*\min(d)}</span>

<span class="w"> </span>    then d is graphical.  This was shown in Theorem 6 in [2]_.

<span class="gu">@@ -178,7 +247,31 @@ def is_valid_degree_sequence_erdos_gallai(deg_sequence):</span>
<span class="w"> </span>       of graphic sequences&quot;, Discrete Mathematics, 105, pp. 292-303 (1992).
<span class="w"> </span>    .. [EG1960] Erdős and Gallai, Mat. Lapok 11 264, 1960.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        dmax, dmin, dsum, n, num_degs = _basic_graphical_tests(deg_sequence)</span>
<span class="gi">+    except nx.NetworkXUnfeasible:</span>
<span class="gi">+        return False</span>
<span class="gi">+    # Accept if sequence has no non-zero degrees or passes the ZZ condition</span>
<span class="gi">+    if n == 0 or 4 * dmin * n &gt;= (dmax + dmin + 1) * (dmax + dmin + 1):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Perform the EG checks using the reformulation of Zverovich and Zverovich</span>
<span class="gi">+    k, sum_deg, sum_nj, sum_jnj = 0, 0, 0, 0</span>
<span class="gi">+    for dk in range(dmax, dmin - 1, -1):</span>
<span class="gi">+        if dk &lt; k + 1:  # Check if already past Durfee index</span>
<span class="gi">+            return True</span>
<span class="gi">+        if num_degs[dk] &gt; 0:</span>
<span class="gi">+            run_size = num_degs[dk]  # Process a run of identical-valued degrees</span>
<span class="gi">+            if dk &lt; k + run_size:  # Check if end of run is past Durfee index</span>
<span class="gi">+                run_size = dk - k  # Adjust back to Durfee index</span>
<span class="gi">+            sum_deg += run_size * dk</span>
<span class="gi">+            for v in range(run_size):</span>
<span class="gi">+                sum_nj += num_degs[k + v]</span>
<span class="gi">+                sum_jnj += (k + v) * num_degs[k + v]</span>
<span class="gi">+            k += run_size</span>
<span class="gi">+            if sum_deg &gt; k * (n - 1) - k * sum_nj + sum_jnj:</span>
<span class="gi">+                return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>@nx._dispatchable(graphs=None)
<span class="gu">@@ -218,7 +311,18 @@ def is_multigraphical(sequence):</span>
<span class="w"> </span>       degrees of the vertices of a linear graph&quot;, J. SIAM, 10, pp. 496-506
<span class="w"> </span>       (1962).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        deg_sequence = nx.utils.make_list_of_ints(sequence)</span>
<span class="gi">+    except nx.NetworkXError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    dsum, dmax = 0, 0</span>
<span class="gi">+    for d in deg_sequence:</span>
<span class="gi">+        if d &lt; 0:</span>
<span class="gi">+            return False</span>
<span class="gi">+        dsum, dmax = dsum + d, max(dmax, d)</span>
<span class="gi">+    if dsum % 2 or dsum &lt; 2 * dmax:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>@nx._dispatchable(graphs=None)
<span class="gu">@@ -261,12 +365,16 @@ def is_pseudographical(sequence):</span>
<span class="w"> </span>       and their degree lists&quot;, IEEE Trans. Circuits and Systems, CAS-23(12),
<span class="w"> </span>       pp. 778-782 (1976).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        deg_sequence = nx.utils.make_list_of_ints(sequence)</span>
<span class="gi">+    except nx.NetworkXError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return sum(deg_sequence) % 2 == 0 and min(deg_sequence) &gt;= 0</span>


<span class="w"> </span>@nx._dispatchable(graphs=None)
<span class="w"> </span>def is_digraphical(in_sequence, out_sequence):
<span class="gd">-    &quot;&quot;&quot;Returns True if some directed graph can realize the in- and out-degree</span>
<span class="gi">+    r&quot;&quot;&quot;Returns True if some directed graph can realize the in- and out-degree</span>
<span class="w"> </span>    sequences.

<span class="w"> </span>    Parameters
<span class="gu">@@ -299,7 +407,7 @@ def is_digraphical(in_sequence, out_sequence):</span>
<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="w"> </span>    This algorithm is from Kleitman and Wang [1]_.
<span class="gd">-    The worst case runtime is $O(s \\times \\log n)$ where $s$ and $n$ are the</span>
<span class="gi">+    The worst case runtime is $O(s \times \log n)$ where $s$ and $n$ are the</span>
<span class="w"> </span>    sum and length of the sequences respectively.

<span class="w"> </span>    References
<span class="gu">@@ -308,4 +416,68 @@ def is_digraphical(in_sequence, out_sequence):</span>
<span class="w"> </span>       Algorithms for Constructing Graphs and Digraphs with Given Valences
<span class="w"> </span>       and Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        in_deg_sequence = nx.utils.make_list_of_ints(in_sequence)</span>
<span class="gi">+        out_deg_sequence = nx.utils.make_list_of_ints(out_sequence)</span>
<span class="gi">+    except nx.NetworkXError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    # Process the sequences and form two heaps to store degree pairs with</span>
<span class="gi">+    # either zero or non-zero out degrees</span>
<span class="gi">+    sumin, sumout, nin, nout = 0, 0, len(in_deg_sequence), len(out_deg_sequence)</span>
<span class="gi">+    maxn = max(nin, nout)</span>
<span class="gi">+    maxin = 0</span>
<span class="gi">+    if maxn == 0:</span>
<span class="gi">+        return True</span>
<span class="gi">+    stubheap, zeroheap = [], []</span>
<span class="gi">+    for n in range(maxn):</span>
<span class="gi">+        in_deg, out_deg = 0, 0</span>
<span class="gi">+        if n &lt; nout:</span>
<span class="gi">+            out_deg = out_deg_sequence[n]</span>
<span class="gi">+        if n &lt; nin:</span>
<span class="gi">+            in_deg = in_deg_sequence[n]</span>
<span class="gi">+        if in_deg &lt; 0 or out_deg &lt; 0:</span>
<span class="gi">+            return False</span>
<span class="gi">+        sumin, sumout, maxin = sumin + in_deg, sumout + out_deg, max(maxin, in_deg)</span>
<span class="gi">+        if in_deg &gt; 0:</span>
<span class="gi">+            stubheap.append((-1 * out_deg, -1 * in_deg))</span>
<span class="gi">+        elif out_deg &gt; 0:</span>
<span class="gi">+            zeroheap.append(-1 * out_deg)</span>
<span class="gi">+    if sumin != sumout:</span>
<span class="gi">+        return False</span>
<span class="gi">+    heapq.heapify(stubheap)</span>
<span class="gi">+    heapq.heapify(zeroheap)</span>
<span class="gi">+</span>
<span class="gi">+    modstubs = [(0, 0)] * (maxin + 1)</span>
<span class="gi">+    # Successively reduce degree sequence by removing the maximum out degree</span>
<span class="gi">+    while stubheap:</span>
<span class="gi">+        # Take the first value in the sequence with non-zero in degree</span>
<span class="gi">+        (freeout, freein) = heapq.heappop(stubheap)</span>
<span class="gi">+        freein *= -1</span>
<span class="gi">+        if freein &gt; len(stubheap) + len(zeroheap):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Attach out stubs to the nodes with the most in stubs</span>
<span class="gi">+        mslen = 0</span>
<span class="gi">+        for i in range(freein):</span>
<span class="gi">+            if zeroheap and (not stubheap or stubheap[0][0] &gt; zeroheap[0]):</span>
<span class="gi">+                stubout = heapq.heappop(zeroheap)</span>
<span class="gi">+                stubin = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                (stubout, stubin) = heapq.heappop(stubheap)</span>
<span class="gi">+            if stubout == 0:</span>
<span class="gi">+                return False</span>
<span class="gi">+            # Check if target is now totally connected</span>
<span class="gi">+            if stubout + 1 &lt; 0 or stubin &lt; 0:</span>
<span class="gi">+                modstubs[mslen] = (stubout + 1, stubin)</span>
<span class="gi">+                mslen += 1</span>
<span class="gi">+</span>
<span class="gi">+        # Add back the nodes to the heap that still have available stubs</span>
<span class="gi">+        for i in range(mslen):</span>
<span class="gi">+            stub = modstubs[i]</span>
<span class="gi">+            if stub[1] &lt; 0:</span>
<span class="gi">+                heapq.heappush(stubheap, stub)</span>
<span class="gi">+            else:</span>
<span class="gi">+                heapq.heappush(zeroheap, stub[0])</span>
<span class="gi">+        if freeout &lt; 0:</span>
<span class="gi">+            heapq.heappush(zeroheap, freeout)</span>
<span class="gi">+    return True</span>
<span class="gh">diff --git a/networkx/algorithms/hierarchy.py b/networkx/algorithms/hierarchy.py</span>
<span class="gh">index 41e0823a8..4bb01cb45 100644</span>
<span class="gd">--- a/networkx/algorithms/hierarchy.py</span>
<span class="gi">+++ b/networkx/algorithms/hierarchy.py</span>
<span class="gu">@@ -2,10 +2,11 @@</span>
<span class="w"> </span>Flow Hierarchy.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;flow_hierarchy&#39;]</span>

<span class="gi">+__all__ = [&quot;flow_hierarchy&quot;]</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def flow_hierarchy(G, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the flow hierarchy of a directed network.

<span class="gu">@@ -41,4 +42,7 @@ def flow_hierarchy(G, weight=None):</span>
<span class="w"> </span>       DOI: 10.1002/cplx.20368
<span class="w"> </span>       http://web.mit.edu/~cmagee/www/documents/28-DetectingEvolvingPatterns_FlowHierarchy.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;G must be a digraph in flow_hierarchy&quot;)</span>
<span class="gi">+    scc = nx.strongly_connected_components(G)</span>
<span class="gi">+    return 1 - sum(G.subgraph(c).size(weight) for c in scc) / G.size(weight)</span>
<span class="gh">diff --git a/networkx/algorithms/hybrid.py b/networkx/algorithms/hybrid.py</span>
<span class="gh">index 2498f7fea..4d0e5c36e 100644</span>
<span class="gd">--- a/networkx/algorithms/hybrid.py</span>
<span class="gi">+++ b/networkx/algorithms/hybrid.py</span>
<span class="gu">@@ -4,8 +4,10 @@ graphs.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import copy
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;kl_connected_subgraph&#39;, &#39;is_kl_connected&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;kl_connected_subgraph&quot;, &quot;is_kl_connected&quot;]</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -59,7 +61,58 @@ def kl_connected_subgraph(G, k, l, low_memory=False, same_as_graph=False):</span>
<span class="w"> </span>           2004. 89--104.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    H = copy.deepcopy(G)  # subgraph we construct by removing from G</span>
<span class="gi">+</span>
<span class="gi">+    graphOK = True</span>
<span class="gi">+    deleted_some = True  # hack to start off the while loop</span>
<span class="gi">+    while deleted_some:</span>
<span class="gi">+        deleted_some = False</span>
<span class="gi">+        # We use `for edge in list(H.edges()):` instead of</span>
<span class="gi">+        # `for edge in H.edges():` because we edit the graph `H` in</span>
<span class="gi">+        # the loop. Hence using an iterator will result in</span>
<span class="gi">+        # `RuntimeError: dictionary changed size during iteration`</span>
<span class="gi">+        for edge in list(H.edges()):</span>
<span class="gi">+            (u, v) = edge</span>
<span class="gi">+            # Get copy of graph needed for this search</span>
<span class="gi">+            if low_memory:</span>
<span class="gi">+                verts = {u, v}</span>
<span class="gi">+                for i in range(k):</span>
<span class="gi">+                    for w in verts.copy():</span>
<span class="gi">+                        verts.update(G[w])</span>
<span class="gi">+                G2 = G.subgraph(verts).copy()</span>
<span class="gi">+            else:</span>
<span class="gi">+                G2 = copy.deepcopy(G)</span>
<span class="gi">+            ###</span>
<span class="gi">+            path = [u, v]</span>
<span class="gi">+            cnt = 0</span>
<span class="gi">+            accept = 0</span>
<span class="gi">+            while path:</span>
<span class="gi">+                cnt += 1  # Found a path</span>
<span class="gi">+                if cnt &gt;= l:</span>
<span class="gi">+                    accept = 1</span>
<span class="gi">+                    break</span>
<span class="gi">+                # record edges along this graph</span>
<span class="gi">+                prev = u</span>
<span class="gi">+                for w in path:</span>
<span class="gi">+                    if prev != w:</span>
<span class="gi">+                        G2.remove_edge(prev, w)</span>
<span class="gi">+                        prev = w</span>
<span class="gi">+                #                path = shortest_path(G2, u, v, k) # ??? should &quot;Cutoff&quot; be k+1?</span>
<span class="gi">+                try:</span>
<span class="gi">+                    path = nx.shortest_path(G2, u, v)  # ??? should &quot;Cutoff&quot; be k+1?</span>
<span class="gi">+                except nx.NetworkXNoPath:</span>
<span class="gi">+                    path = False</span>
<span class="gi">+            # No Other Paths</span>
<span class="gi">+            if accept == 0:</span>
<span class="gi">+                H.remove_edge(u, v)</span>
<span class="gi">+                deleted_some = True</span>
<span class="gi">+                if graphOK:</span>
<span class="gi">+                    graphOK = False</span>
<span class="gi">+    # We looked through all edges and removed none of them.</span>
<span class="gi">+    # So, H is the maximal (k,l)-connected subgraph of G</span>
<span class="gi">+    if same_as_graph:</span>
<span class="gi">+        return (H, graphOK)</span>
<span class="gi">+    return H</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -103,4 +156,40 @@ def is_kl_connected(G, k, l, low_memory=False):</span>
<span class="w"> </span>           2004. 89--104.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    graphOK = True</span>
<span class="gi">+    for edge in G.edges():</span>
<span class="gi">+        (u, v) = edge</span>
<span class="gi">+        # Get copy of graph needed for this search</span>
<span class="gi">+        if low_memory:</span>
<span class="gi">+            verts = {u, v}</span>
<span class="gi">+            for i in range(k):</span>
<span class="gi">+                [verts.update(G.neighbors(w)) for w in verts.copy()]</span>
<span class="gi">+            G2 = G.subgraph(verts)</span>
<span class="gi">+        else:</span>
<span class="gi">+            G2 = copy.deepcopy(G)</span>
<span class="gi">+        ###</span>
<span class="gi">+        path = [u, v]</span>
<span class="gi">+        cnt = 0</span>
<span class="gi">+        accept = 0</span>
<span class="gi">+        while path:</span>
<span class="gi">+            cnt += 1  # Found a path</span>
<span class="gi">+            if cnt &gt;= l:</span>
<span class="gi">+                accept = 1</span>
<span class="gi">+                break</span>
<span class="gi">+            # record edges along this graph</span>
<span class="gi">+            prev = u</span>
<span class="gi">+            for w in path:</span>
<span class="gi">+                if w != prev:</span>
<span class="gi">+                    G2.remove_edge(prev, w)</span>
<span class="gi">+                    prev = w</span>
<span class="gi">+            #            path = shortest_path(G2, u, v, k) # ??? should &quot;Cutoff&quot; be k+1?</span>
<span class="gi">+            try:</span>
<span class="gi">+                path = nx.shortest_path(G2, u, v)  # ??? should &quot;Cutoff&quot; be k+1?</span>
<span class="gi">+            except nx.NetworkXNoPath:</span>
<span class="gi">+                path = False</span>
<span class="gi">+        # No Other Paths</span>
<span class="gi">+        if accept == 0:</span>
<span class="gi">+            graphOK = False</span>
<span class="gi">+            break</span>
<span class="gi">+    # return status</span>
<span class="gi">+    return graphOK</span>
<span class="gh">diff --git a/networkx/algorithms/isolate.py b/networkx/algorithms/isolate.py</span>
<span class="gh">index 4cdf6c772..23ac23875 100644</span>
<span class="gd">--- a/networkx/algorithms/isolate.py</span>
<span class="gi">+++ b/networkx/algorithms/isolate.py</span>
<span class="gu">@@ -2,7 +2,8 @@</span>
<span class="w"> </span>Functions for identifying isolate (degree zero) nodes.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;is_isolate&#39;, &#39;isolates&#39;, &#39;number_of_isolates&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;is_isolate&quot;, &quot;isolates&quot;, &quot;number_of_isolates&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -35,7 +36,7 @@ def is_isolate(G, n):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.is_isolate(G, 3)
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.degree(n) == 0</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -81,7 +82,7 @@ def isolates(G):</span>
<span class="w"> </span>        [3]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (n for n, d in G.degree() if d == 0)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -102,4 +103,5 @@ def number_of_isolates(G):</span>
<span class="w"> </span>        The number of degree zero nodes in the graph `G`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO This can be parallelized.</span>
<span class="gi">+    return sum(1 for v in isolates(G))</span>
<span class="gh">diff --git a/networkx/algorithms/isomorphism/ismags.py b/networkx/algorithms/isomorphism/ismags.py</span>
<span class="gh">index 483833c52..24819faf9 100644</span>
<span class="gd">--- a/networkx/algorithms/isomorphism/ismags.py</span>
<span class="gi">+++ b/networkx/algorithms/isomorphism/ismags.py</span>
<span class="gu">@@ -105,7 +105,9 @@ References</span>
<span class="w"> </span>   https://doi.org/10.1371/journal.pone.0097896
<span class="w"> </span>.. [2] https://en.wikipedia.org/wiki/Maximum_common_induced_subgraph
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;ISMAGS&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;ISMAGS&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>from collections import Counter, defaultdict
<span class="w"> </span>from functools import reduce, wraps
<span class="gu">@@ -127,7 +129,18 @@ def are_all_equal(iterable):</span>
<span class="w"> </span>        ``True`` iff all elements in `iterable` compare equal, ``False``
<span class="w"> </span>        otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        shape = iterable.shape</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        if len(shape) &gt; 1:</span>
<span class="gi">+            message = &quot;The function does not works on multidimensional arrays.&quot;</span>
<span class="gi">+            raise NotImplementedError(message) from None</span>
<span class="gi">+</span>
<span class="gi">+    iterator = iter(iterable)</span>
<span class="gi">+    first = next(iterator, None)</span>
<span class="gi">+    return all(item == first for item in iterator)</span>


<span class="w"> </span>def make_partitions(items, test):
<span class="gu">@@ -156,7 +169,16 @@ def make_partitions(items, test):</span>
<span class="w"> </span>    The function `test` is assumed to be transitive: if ``test(a, b)`` and
<span class="w"> </span>    ``test(b, c)`` return ``True``, then ``test(a, c)`` must also be ``True``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    partitions = []</span>
<span class="gi">+    for item in items:</span>
<span class="gi">+        for partition in partitions:</span>
<span class="gi">+            p_item = next(iter(partition))</span>
<span class="gi">+            if test(item, p_item):</span>
<span class="gi">+                partition.add(item)</span>
<span class="gi">+                break</span>
<span class="gi">+        else:  # No break</span>
<span class="gi">+            partitions.append({item})</span>
<span class="gi">+    return partitions</span>


<span class="w"> </span>def partition_to_color(partitions):
<span class="gu">@@ -173,7 +195,11 @@ def partition_to_color(partitions):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    colors = {}</span>
<span class="gi">+    for color, keys in enumerate(partitions):</span>
<span class="gi">+        for key in keys:</span>
<span class="gi">+            colors[key] = color</span>
<span class="gi">+    return colors</span>


<span class="w"> </span>def intersect(collection_of_sets):
<span class="gu">@@ -191,7 +217,10 @@ def intersect(collection_of_sets):</span>
<span class="w"> </span>        An intersection of all sets in `collection_of_sets`. Will have the same
<span class="w"> </span>        type as the item initially taken from `collection_of_sets`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    collection_of_sets = list(collection_of_sets)</span>
<span class="gi">+    first = collection_of_sets.pop()</span>
<span class="gi">+    out = reduce(set.intersection, collection_of_sets, set(first))</span>
<span class="gi">+    return type(first)(out)</span>


<span class="w"> </span>class ISMAGS:
<span class="gu">@@ -237,8 +266,7 @@ class ISMAGS:</span>
<span class="w"> </span>       https://doi.org/10.1371/journal.pone.0097896
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, graph, subgraph, node_match=None, edge_match=None,</span>
<span class="gd">-        cache=None):</span>
<span class="gi">+    def __init__(self, graph, subgraph, node_match=None, edge_match=None, cache=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Parameters
<span class="w"> </span>        ----------
<span class="gu">@@ -261,34 +289,156 @@ class ISMAGS:</span>
<span class="w"> </span>        cache: collections.abc.Mapping
<span class="w"> </span>            A cache used for caching graph symmetries.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        # TODO: graph and subgraph setter methods that invalidate the caches.</span>
<span class="gi">+        # TODO: allow for precomputed partitions and colors</span>
<span class="w"> </span>        self.graph = graph
<span class="w"> </span>        self.subgraph = subgraph
<span class="w"> </span>        self._symmetry_cache = cache
<span class="gi">+        # Naming conventions are taken from the original paper. For your</span>
<span class="gi">+        # sanity:</span>
<span class="gi">+        #   sg: subgraph</span>
<span class="gi">+        #   g: graph</span>
<span class="gi">+        #   e: edge(s)</span>
<span class="gi">+        #   n: node(s)</span>
<span class="gi">+        # So: sgn means &quot;subgraph nodes&quot;.</span>
<span class="w"> </span>        self._sgn_partitions_ = None
<span class="w"> </span>        self._sge_partitions_ = None
<span class="gi">+</span>
<span class="w"> </span>        self._sgn_colors_ = None
<span class="w"> </span>        self._sge_colors_ = None
<span class="gi">+</span>
<span class="w"> </span>        self._gn_partitions_ = None
<span class="w"> </span>        self._ge_partitions_ = None
<span class="gi">+</span>
<span class="w"> </span>        self._gn_colors_ = None
<span class="w"> </span>        self._ge_colors_ = None
<span class="gi">+</span>
<span class="w"> </span>        self._node_compat_ = None
<span class="w"> </span>        self._edge_compat_ = None
<span class="gi">+</span>
<span class="w"> </span>        if node_match is None:
<span class="w"> </span>            self.node_equality = self._node_match_maker(lambda n1, n2: True)
<span class="w"> </span>            self._sgn_partitions_ = [set(self.subgraph.nodes)]
<span class="w"> </span>            self._gn_partitions_ = [set(self.graph.nodes)]
<span class="gd">-            self._node_compat_ = {(0): 0}</span>
<span class="gi">+            self._node_compat_ = {0: 0}</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.node_equality = self._node_match_maker(node_match)
<span class="w"> </span>        if edge_match is None:
<span class="w"> </span>            self.edge_equality = self._edge_match_maker(lambda e1, e2: True)
<span class="w"> </span>            self._sge_partitions_ = [set(self.subgraph.edges)]
<span class="w"> </span>            self._ge_partitions_ = [set(self.graph.edges)]
<span class="gd">-            self._edge_compat_ = {(0): 0}</span>
<span class="gi">+            self._edge_compat_ = {0: 0}</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.edge_equality = self._edge_match_maker(edge_match)

<span class="gi">+    @property</span>
<span class="gi">+    def _sgn_partitions(self):</span>
<span class="gi">+        if self._sgn_partitions_ is None:</span>
<span class="gi">+</span>
<span class="gi">+            def nodematch(node1, node2):</span>
<span class="gi">+                return self.node_equality(self.subgraph, node1, self.subgraph, node2)</span>
<span class="gi">+</span>
<span class="gi">+            self._sgn_partitions_ = make_partitions(self.subgraph.nodes, nodematch)</span>
<span class="gi">+        return self._sgn_partitions_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _sge_partitions(self):</span>
<span class="gi">+        if self._sge_partitions_ is None:</span>
<span class="gi">+</span>
<span class="gi">+            def edgematch(edge1, edge2):</span>
<span class="gi">+                return self.edge_equality(self.subgraph, edge1, self.subgraph, edge2)</span>
<span class="gi">+</span>
<span class="gi">+            self._sge_partitions_ = make_partitions(self.subgraph.edges, edgematch)</span>
<span class="gi">+        return self._sge_partitions_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _gn_partitions(self):</span>
<span class="gi">+        if self._gn_partitions_ is None:</span>
<span class="gi">+</span>
<span class="gi">+            def nodematch(node1, node2):</span>
<span class="gi">+                return self.node_equality(self.graph, node1, self.graph, node2)</span>
<span class="gi">+</span>
<span class="gi">+            self._gn_partitions_ = make_partitions(self.graph.nodes, nodematch)</span>
<span class="gi">+        return self._gn_partitions_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _ge_partitions(self):</span>
<span class="gi">+        if self._ge_partitions_ is None:</span>
<span class="gi">+</span>
<span class="gi">+            def edgematch(edge1, edge2):</span>
<span class="gi">+                return self.edge_equality(self.graph, edge1, self.graph, edge2)</span>
<span class="gi">+</span>
<span class="gi">+            self._ge_partitions_ = make_partitions(self.graph.edges, edgematch)</span>
<span class="gi">+        return self._ge_partitions_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _sgn_colors(self):</span>
<span class="gi">+        if self._sgn_colors_ is None:</span>
<span class="gi">+            self._sgn_colors_ = partition_to_color(self._sgn_partitions)</span>
<span class="gi">+        return self._sgn_colors_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _sge_colors(self):</span>
<span class="gi">+        if self._sge_colors_ is None:</span>
<span class="gi">+            self._sge_colors_ = partition_to_color(self._sge_partitions)</span>
<span class="gi">+        return self._sge_colors_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _gn_colors(self):</span>
<span class="gi">+        if self._gn_colors_ is None:</span>
<span class="gi">+            self._gn_colors_ = partition_to_color(self._gn_partitions)</span>
<span class="gi">+        return self._gn_colors_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _ge_colors(self):</span>
<span class="gi">+        if self._ge_colors_ is None:</span>
<span class="gi">+            self._ge_colors_ = partition_to_color(self._ge_partitions)</span>
<span class="gi">+        return self._ge_colors_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _node_compatibility(self):</span>
<span class="gi">+        if self._node_compat_ is not None:</span>
<span class="gi">+            return self._node_compat_</span>
<span class="gi">+        self._node_compat_ = {}</span>
<span class="gi">+        for sgn_part_color, gn_part_color in itertools.product(</span>
<span class="gi">+            range(len(self._sgn_partitions)), range(len(self._gn_partitions))</span>
<span class="gi">+        ):</span>
<span class="gi">+            sgn = next(iter(self._sgn_partitions[sgn_part_color]))</span>
<span class="gi">+            gn = next(iter(self._gn_partitions[gn_part_color]))</span>
<span class="gi">+            if self.node_equality(self.subgraph, sgn, self.graph, gn):</span>
<span class="gi">+                self._node_compat_[sgn_part_color] = gn_part_color</span>
<span class="gi">+        return self._node_compat_</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _edge_compatibility(self):</span>
<span class="gi">+        if self._edge_compat_ is not None:</span>
<span class="gi">+            return self._edge_compat_</span>
<span class="gi">+        self._edge_compat_ = {}</span>
<span class="gi">+        for sge_part_color, ge_part_color in itertools.product(</span>
<span class="gi">+            range(len(self._sge_partitions)), range(len(self._ge_partitions))</span>
<span class="gi">+        ):</span>
<span class="gi">+            sge = next(iter(self._sge_partitions[sge_part_color]))</span>
<span class="gi">+            ge = next(iter(self._ge_partitions[ge_part_color]))</span>
<span class="gi">+            if self.edge_equality(self.subgraph, sge, self.graph, ge):</span>
<span class="gi">+                self._edge_compat_[sge_part_color] = ge_part_color</span>
<span class="gi">+        return self._edge_compat_</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _node_match_maker(cmp):</span>
<span class="gi">+        @wraps(cmp)</span>
<span class="gi">+        def comparer(graph1, node1, graph2, node2):</span>
<span class="gi">+            return cmp(graph1.nodes[node1], graph2.nodes[node2])</span>
<span class="gi">+</span>
<span class="gi">+        return comparer</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _edge_match_maker(cmp):</span>
<span class="gi">+        @wraps(cmp)</span>
<span class="gi">+        def comparer(graph1, edge1, graph2, edge2):</span>
<span class="gi">+            return cmp(graph1.edges[edge1], graph2.edges[edge2])</span>
<span class="gi">+</span>
<span class="gi">+        return comparer</span>
<span class="gi">+</span>
<span class="w"> </span>    def find_isomorphisms(self, symmetry=True):
<span class="w"> </span>        &quot;&quot;&quot;Find all subgraph isomorphisms between subgraph and graph

<span class="gu">@@ -305,7 +455,37 @@ class ISMAGS:</span>
<span class="w"> </span>        dict
<span class="w"> </span>            The found isomorphism mappings of {graph_node: subgraph_node}.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # The networkx VF2 algorithm is slightly funny in when it yields an</span>
<span class="gi">+        # empty dict and when not.</span>
<span class="gi">+        if not self.subgraph:</span>
<span class="gi">+            yield {}</span>
<span class="gi">+            return</span>
<span class="gi">+        elif not self.graph:</span>
<span class="gi">+            return</span>
<span class="gi">+        elif len(self.graph) &lt; len(self.subgraph):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if symmetry:</span>
<span class="gi">+            _, cosets = self.analyze_symmetry(</span>
<span class="gi">+                self.subgraph, self._sgn_partitions, self._sge_colors</span>
<span class="gi">+            )</span>
<span class="gi">+            constraints = self._make_constraints(cosets)</span>
<span class="gi">+        else:</span>
<span class="gi">+            constraints = []</span>
<span class="gi">+</span>
<span class="gi">+        candidates = self._find_nodecolor_candidates()</span>
<span class="gi">+        la_candidates = self._get_lookahead_candidates()</span>
<span class="gi">+        for sgn in self.subgraph:</span>
<span class="gi">+            extra_candidates = la_candidates[sgn]</span>
<span class="gi">+            if extra_candidates:</span>
<span class="gi">+                candidates[sgn] = candidates[sgn] | {frozenset(extra_candidates)}</span>
<span class="gi">+</span>
<span class="gi">+        if any(candidates.values()):</span>
<span class="gi">+            start_sgn = min(candidates, key=lambda n: min(candidates[n], key=len))</span>
<span class="gi">+            candidates[start_sgn] = (intersect(candidates[start_sgn]),)</span>
<span class="gi">+            yield from self._map_nodes(start_sgn, candidates, constraints)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _find_neighbor_color_count(graph, node, node_color, edge_color):
<span class="gu">@@ -313,7 +493,16 @@ class ISMAGS:</span>
<span class="w"> </span>        For `node` in `graph`, count the number of edges of a specific color
<span class="w"> </span>        it has to nodes of a specific color.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        counts = Counter()</span>
<span class="gi">+        neighbors = graph[node]</span>
<span class="gi">+        for neighbor in neighbors:</span>
<span class="gi">+            n_color = node_color[neighbor]</span>
<span class="gi">+            if (node, neighbor) in edge_color:</span>
<span class="gi">+                e_color = edge_color[node, neighbor]</span>
<span class="gi">+            else:</span>
<span class="gi">+                e_color = edge_color[neighbor, node]</span>
<span class="gi">+            counts[e_color, n_color] += 1</span>
<span class="gi">+        return counts</span>

<span class="w"> </span>    def _get_lookahead_candidates(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -321,7 +510,31 @@ class ISMAGS:</span>
<span class="w"> </span>        which the graph nodes are feasible candidates for the subgraph node, as
<span class="w"> </span>        determined by looking ahead one edge.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        g_counts = {}</span>
<span class="gi">+        for gn in self.graph:</span>
<span class="gi">+            g_counts[gn] = self._find_neighbor_color_count(</span>
<span class="gi">+                self.graph, gn, self._gn_colors, self._ge_colors</span>
<span class="gi">+            )</span>
<span class="gi">+        candidates = defaultdict(set)</span>
<span class="gi">+        for sgn in self.subgraph:</span>
<span class="gi">+            sg_count = self._find_neighbor_color_count(</span>
<span class="gi">+                self.subgraph, sgn, self._sgn_colors, self._sge_colors</span>
<span class="gi">+            )</span>
<span class="gi">+            new_sg_count = Counter()</span>
<span class="gi">+            for (sge_color, sgn_color), count in sg_count.items():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    ge_color = self._edge_compatibility[sge_color]</span>
<span class="gi">+                    gn_color = self._node_compatibility[sgn_color]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    new_sg_count[ge_color, gn_color] = count</span>
<span class="gi">+</span>
<span class="gi">+            for gn, g_count in g_counts.items():</span>
<span class="gi">+                if all(new_sg_count[x] &lt;= g_count[x] for x in new_sg_count):</span>
<span class="gi">+                    # Valid candidate</span>
<span class="gi">+                    candidates[sgn].add(gn)</span>
<span class="gi">+        return candidates</span>

<span class="w"> </span>    def largest_common_subgraph(self, symmetry=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -339,7 +552,28 @@ class ISMAGS:</span>
<span class="w"> </span>        dict
<span class="w"> </span>            The found isomorphism mappings of {graph_node: subgraph_node}.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # The networkx VF2 algorithm is slightly funny in when it yields an</span>
<span class="gi">+        # empty dict and when not.</span>
<span class="gi">+        if not self.subgraph:</span>
<span class="gi">+            yield {}</span>
<span class="gi">+            return</span>
<span class="gi">+        elif not self.graph:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if symmetry:</span>
<span class="gi">+            _, cosets = self.analyze_symmetry(</span>
<span class="gi">+                self.subgraph, self._sgn_partitions, self._sge_colors</span>
<span class="gi">+            )</span>
<span class="gi">+            constraints = self._make_constraints(cosets)</span>
<span class="gi">+        else:</span>
<span class="gi">+            constraints = []</span>
<span class="gi">+</span>
<span class="gi">+        candidates = self._find_nodecolor_candidates()</span>
<span class="gi">+</span>
<span class="gi">+        if any(candidates.values()):</span>
<span class="gi">+            yield from self._largest_common_subgraph(candidates, constraints)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>

<span class="w"> </span>    def analyze_symmetry(self, graph, node_partitions, edge_colors):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -373,7 +607,28 @@ class ISMAGS:</span>
<span class="w"> </span>            Every key-value pair describes which ``values`` can be interchanged
<span class="w"> </span>            without changing nodes less than ``key``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._symmetry_cache is not None:</span>
<span class="gi">+            key = hash(</span>
<span class="gi">+                (</span>
<span class="gi">+                    tuple(graph.nodes),</span>
<span class="gi">+                    tuple(graph.edges),</span>
<span class="gi">+                    tuple(map(tuple, node_partitions)),</span>
<span class="gi">+                    tuple(edge_colors.items()),</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            if key in self._symmetry_cache:</span>
<span class="gi">+                return self._symmetry_cache[key]</span>
<span class="gi">+        node_partitions = list(</span>
<span class="gi">+            self._refine_node_partitions(graph, node_partitions, edge_colors)</span>
<span class="gi">+        )</span>
<span class="gi">+        assert len(node_partitions) == 1</span>
<span class="gi">+        node_partitions = node_partitions[0]</span>
<span class="gi">+        permutations, cosets = self._process_ordered_pair_partitions(</span>
<span class="gi">+            graph, node_partitions, node_partitions, edge_colors</span>
<span class="gi">+        )</span>
<span class="gi">+        if self._symmetry_cache is not None:</span>
<span class="gi">+            self._symmetry_cache[key] = permutations, cosets</span>
<span class="gi">+        return permutations, cosets</span>

<span class="w"> </span>    def is_isomorphic(self, symmetry=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -384,7 +639,9 @@ class ISMAGS:</span>
<span class="w"> </span>        -------
<span class="w"> </span>        bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.subgraph) == len(self.graph) and self.subgraph_is_isomorphic(</span>
<span class="gi">+            symmetry</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def subgraph_is_isomorphic(self, symmetry=False):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -395,31 +652,53 @@ class ISMAGS:</span>
<span class="w"> </span>        -------
<span class="w"> </span>        bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # symmetry=False, since we only need to know whether there is any</span>
<span class="gi">+        # example; figuring out all symmetry elements probably costs more time</span>
<span class="gi">+        # than it gains.</span>
<span class="gi">+        isom = next(self.subgraph_isomorphisms_iter(symmetry=symmetry), None)</span>
<span class="gi">+        return isom is not None</span>

<span class="w"> </span>    def isomorphisms_iter(self, symmetry=True):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Does the same as :meth:`find_isomorphisms` if :attr:`graph` and
<span class="w"> </span>        :attr:`subgraph` have the same number of nodes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(self.graph) == len(self.subgraph):</span>
<span class="gi">+            yield from self.subgraph_isomorphisms_iter(symmetry=symmetry)</span>

<span class="w"> </span>    def subgraph_isomorphisms_iter(self, symmetry=True):
<span class="w"> </span>        &quot;&quot;&quot;Alternative name for :meth:`find_isomorphisms`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.find_isomorphisms(symmetry)</span>

<span class="w"> </span>    def _find_nodecolor_candidates(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Per node in subgraph find all nodes in graph that have the same color.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        candidates = defaultdict(set)</span>
<span class="gi">+        for sgn in self.subgraph.nodes:</span>
<span class="gi">+            sgn_color = self._sgn_colors[sgn]</span>
<span class="gi">+            if sgn_color in self._node_compatibility:</span>
<span class="gi">+                gn_color = self._node_compatibility[sgn_color]</span>
<span class="gi">+                candidates[sgn].add(frozenset(self._gn_partitions[gn_color]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                candidates[sgn].add(frozenset())</span>
<span class="gi">+        candidates = dict(candidates)</span>
<span class="gi">+        for sgn, options in candidates.items():</span>
<span class="gi">+            candidates[sgn] = frozenset(options)</span>
<span class="gi">+        return candidates</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _make_constraints(cosets):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Turn cosets into constraints.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        constraints = []</span>
<span class="gi">+        for node_i, node_ts in cosets.items():</span>
<span class="gi">+            for node_t in node_ts:</span>
<span class="gi">+                if node_i != node_t:</span>
<span class="gi">+                    # Node i must be smaller than node t.</span>
<span class="gi">+                    constraints.append((node_i, node_t))</span>
<span class="gi">+        return constraints</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _find_node_edge_color(graph, node_colors, edge_colors):
<span class="gu">@@ -428,7 +707,23 @@ class ISMAGS:</span>
<span class="w"> </span>        color of the node, and 2) the number of edges of a color to each type
<span class="w"> </span>        of node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        counts = defaultdict(lambda: defaultdict(int))</span>
<span class="gi">+        for node1, node2 in graph.edges:</span>
<span class="gi">+            if (node1, node2) in edge_colors:</span>
<span class="gi">+                # FIXME directed graphs</span>
<span class="gi">+                ecolor = edge_colors[node1, node2]</span>
<span class="gi">+            else:</span>
<span class="gi">+                ecolor = edge_colors[node2, node1]</span>
<span class="gi">+            # Count per node how many edges it has of what color to nodes of</span>
<span class="gi">+            # what color</span>
<span class="gi">+            counts[node1][ecolor, node_colors[node2]] += 1</span>
<span class="gi">+            counts[node2][ecolor, node_colors[node1]] += 1</span>
<span class="gi">+</span>
<span class="gi">+        node_edge_colors = {}</span>
<span class="gi">+        for node in graph.nodes:</span>
<span class="gi">+            node_edge_colors[node] = node_colors[node], set(counts[node].items())</span>
<span class="gi">+</span>
<span class="gi">+        return node_edge_colors</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _get_permutations_by_length(items):
<span class="gu">@@ -446,38 +741,225 @@ class ISMAGS:</span>
<span class="w"> </span>        &gt;&gt;&gt; found == answer
<span class="w"> </span>        True
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        by_len = defaultdict(list)</span>
<span class="gi">+        for item in items:</span>
<span class="gi">+            by_len[len(item)].append(item)</span>
<span class="gi">+</span>
<span class="gi">+        yield from itertools.product(</span>
<span class="gi">+            *(itertools.permutations(by_len[l]) for l in sorted(by_len))</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def _refine_node_partitions(cls, graph, node_partitions, edge_colors,</span>
<span class="gd">-        branch=False):</span>
<span class="gi">+    def _refine_node_partitions(cls, graph, node_partitions, edge_colors, branch=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Given a partition of nodes in graph, make the partitions smaller such
<span class="w"> </span>        that all nodes in a partition have 1) the same color, and 2) the same
<span class="w"> </span>        number of edges to specific other partitions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def equal_color(node1, node2):</span>
<span class="gi">+            return node_edge_colors[node1] == node_edge_colors[node2]</span>
<span class="gi">+</span>
<span class="gi">+        node_partitions = list(node_partitions)</span>
<span class="gi">+        node_colors = partition_to_color(node_partitions)</span>
<span class="gi">+        node_edge_colors = cls._find_node_edge_color(graph, node_colors, edge_colors)</span>
<span class="gi">+        if all(</span>
<span class="gi">+            are_all_equal(node_edge_colors[node] for node in partition)</span>
<span class="gi">+            for partition in node_partitions</span>
<span class="gi">+        ):</span>
<span class="gi">+            yield node_partitions</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        new_partitions = []</span>
<span class="gi">+        output = [new_partitions]</span>
<span class="gi">+        for partition in node_partitions:</span>
<span class="gi">+            if not are_all_equal(node_edge_colors[node] for node in partition):</span>
<span class="gi">+                refined = make_partitions(partition, equal_color)</span>
<span class="gi">+                if (</span>
<span class="gi">+                    branch</span>
<span class="gi">+                    and len(refined) != 1</span>
<span class="gi">+                    and len({len(r) for r in refined}) != len([len(r) for r in refined])</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # This is where it breaks. There are multiple new cells</span>
<span class="gi">+                    # in refined with the same length, and their order</span>
<span class="gi">+                    # matters.</span>
<span class="gi">+                    # So option 1) Hit it with a big hammer and simply make all</span>
<span class="gi">+                    # orderings.</span>
<span class="gi">+                    permutations = cls._get_permutations_by_length(refined)</span>
<span class="gi">+                    new_output = []</span>
<span class="gi">+                    for n_p in output:</span>
<span class="gi">+                        for permutation in permutations:</span>
<span class="gi">+                            new_output.append(n_p + list(permutation[0]))</span>
<span class="gi">+                    output = new_output</span>
<span class="gi">+                else:</span>
<span class="gi">+                    for n_p in output:</span>
<span class="gi">+                        n_p.extend(sorted(refined, key=len))</span>
<span class="gi">+            else:</span>
<span class="gi">+                for n_p in output:</span>
<span class="gi">+                    n_p.append(partition)</span>
<span class="gi">+        for n_p in output:</span>
<span class="gi">+            yield from cls._refine_node_partitions(graph, n_p, edge_colors, branch)</span>

<span class="w"> </span>    def _edges_of_same_color(self, sgn1, sgn2):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns all edges in :attr:`graph` that have the same colour as the
<span class="w"> </span>        edge between sgn1 and sgn2 in :attr:`subgraph`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (sgn1, sgn2) in self._sge_colors:</span>
<span class="gi">+            # FIXME directed graphs</span>
<span class="gi">+            sge_color = self._sge_colors[sgn1, sgn2]</span>
<span class="gi">+        else:</span>
<span class="gi">+            sge_color = self._sge_colors[sgn2, sgn1]</span>
<span class="gi">+        if sge_color in self._edge_compatibility:</span>
<span class="gi">+            ge_color = self._edge_compatibility[sge_color]</span>
<span class="gi">+            g_edges = self._ge_partitions[ge_color]</span>
<span class="gi">+        else:</span>
<span class="gi">+            g_edges = []</span>
<span class="gi">+        return g_edges</span>

<span class="gd">-    def _map_nodes(self, sgn, candidates, constraints, mapping=None,</span>
<span class="gd">-        to_be_mapped=None):</span>
<span class="gi">+    def _map_nodes(self, sgn, candidates, constraints, mapping=None, to_be_mapped=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find all subgraph isomorphisms honoring constraints.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _largest_common_subgraph(self, candidates, constraints,</span>
<span class="gd">-        to_be_mapped=None):</span>
<span class="gi">+        if mapping is None:</span>
<span class="gi">+            mapping = {}</span>
<span class="gi">+        else:</span>
<span class="gi">+            mapping = mapping.copy()</span>
<span class="gi">+        if to_be_mapped is None:</span>
<span class="gi">+            to_be_mapped = set(self.subgraph.nodes)</span>
<span class="gi">+</span>
<span class="gi">+        # Note, we modify candidates here. Doesn&#39;t seem to affect results, but</span>
<span class="gi">+        # remember this.</span>
<span class="gi">+        # candidates = candidates.copy()</span>
<span class="gi">+        sgn_candidates = intersect(candidates[sgn])</span>
<span class="gi">+        candidates[sgn] = frozenset([sgn_candidates])</span>
<span class="gi">+        for gn in sgn_candidates:</span>
<span class="gi">+            # We&#39;re going to try to map sgn to gn.</span>
<span class="gi">+            if gn in mapping.values() or sgn not in to_be_mapped:</span>
<span class="gi">+                # gn is already mapped to something</span>
<span class="gi">+                continue  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+            # REDUCTION and COMBINATION</span>
<span class="gi">+            mapping[sgn] = gn</span>
<span class="gi">+            # BASECASE</span>
<span class="gi">+            if to_be_mapped == set(mapping.keys()):</span>
<span class="gi">+                yield {v: k for k, v in mapping.items()}</span>
<span class="gi">+                continue</span>
<span class="gi">+            left_to_map = to_be_mapped - set(mapping.keys())</span>
<span class="gi">+</span>
<span class="gi">+            new_candidates = candidates.copy()</span>
<span class="gi">+            sgn_nbrs = set(self.subgraph[sgn])</span>
<span class="gi">+            not_gn_nbrs = set(self.graph.nodes) - set(self.graph[gn])</span>
<span class="gi">+            for sgn2 in left_to_map:</span>
<span class="gi">+                if sgn2 not in sgn_nbrs:</span>
<span class="gi">+                    gn2_options = not_gn_nbrs</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Get all edges to gn of the right color:</span>
<span class="gi">+                    g_edges = self._edges_of_same_color(sgn, sgn2)</span>
<span class="gi">+                    # FIXME directed graphs</span>
<span class="gi">+                    # And all nodes involved in those which are connected to gn</span>
<span class="gi">+                    gn2_options = {n for e in g_edges for n in e if gn in e}</span>
<span class="gi">+                # Node color compatibility should be taken care of by the</span>
<span class="gi">+                # initial candidate lists made by find_subgraphs</span>
<span class="gi">+</span>
<span class="gi">+                # Add gn2_options to the right collection. Since new_candidates</span>
<span class="gi">+                # is a dict of frozensets of frozensets of node indices it&#39;s</span>
<span class="gi">+                # a bit clunky. We can&#39;t do .add, and + also doesn&#39;t work. We</span>
<span class="gi">+                # could do |, but I deem union to be clearer.</span>
<span class="gi">+                new_candidates[sgn2] = new_candidates[sgn2].union(</span>
<span class="gi">+                    [frozenset(gn2_options)]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                if (sgn, sgn2) in constraints:</span>
<span class="gi">+                    gn2_options = {gn2 for gn2 in self.graph if gn2 &gt; gn}</span>
<span class="gi">+                elif (sgn2, sgn) in constraints:</span>
<span class="gi">+                    gn2_options = {gn2 for gn2 in self.graph if gn2 &lt; gn}</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue  # pragma: no cover</span>
<span class="gi">+                new_candidates[sgn2] = new_candidates[sgn2].union(</span>
<span class="gi">+                    [frozenset(gn2_options)]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # The next node is the one that is unmapped and has fewest</span>
<span class="gi">+            # candidates</span>
<span class="gi">+            next_sgn = min(left_to_map, key=lambda n: min(new_candidates[n], key=len))</span>
<span class="gi">+            yield from self._map_nodes(</span>
<span class="gi">+                next_sgn,</span>
<span class="gi">+                new_candidates,</span>
<span class="gi">+                constraints,</span>
<span class="gi">+                mapping=mapping,</span>
<span class="gi">+                to_be_mapped=to_be_mapped,</span>
<span class="gi">+            )</span>
<span class="gi">+            # Unmap sgn-gn. Strictly not necessary since it&#39;d get overwritten</span>
<span class="gi">+            # when making a new mapping for sgn.</span>
<span class="gi">+            # del mapping[sgn]</span>
<span class="gi">+</span>
<span class="gi">+    def _largest_common_subgraph(self, candidates, constraints, to_be_mapped=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find all largest common subgraphs honoring constraints.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if to_be_mapped is None:</span>
<span class="gi">+            to_be_mapped = {frozenset(self.subgraph.nodes)}</span>
<span class="gi">+</span>
<span class="gi">+        # The LCS problem is basically a repeated subgraph isomorphism problem</span>
<span class="gi">+        # with smaller and smaller subgraphs. We store the nodes that are</span>
<span class="gi">+        # &quot;part of&quot; the subgraph in to_be_mapped, and we make it a little</span>
<span class="gi">+        # smaller every iteration.</span>
<span class="gi">+</span>
<span class="gi">+        current_size = len(next(iter(to_be_mapped), []))</span>
<span class="gi">+</span>
<span class="gi">+        found_iso = False</span>
<span class="gi">+        if current_size &lt;= len(self.graph):</span>
<span class="gi">+            # There&#39;s no point in trying to find isomorphisms of</span>
<span class="gi">+            # graph &gt;= subgraph if subgraph has more nodes than graph.</span>
<span class="gi">+</span>
<span class="gi">+            # Try the isomorphism first with the nodes with lowest ID. So sort</span>
<span class="gi">+            # them. Those are more likely to be part of the final</span>
<span class="gi">+            # correspondence. This makes finding the first answer(s) faster. In</span>
<span class="gi">+            # theory.</span>
<span class="gi">+            for nodes in sorted(to_be_mapped, key=sorted):</span>
<span class="gi">+                # Find the isomorphism between subgraph[to_be_mapped] &lt;= graph</span>
<span class="gi">+                next_sgn = min(nodes, key=lambda n: min(candidates[n], key=len))</span>
<span class="gi">+                isomorphs = self._map_nodes(</span>
<span class="gi">+                    next_sgn, candidates, constraints, to_be_mapped=nodes</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                # This is effectively `yield from isomorphs`, except that we look</span>
<span class="gi">+                # whether an item was yielded.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    item = next(isomorphs)</span>
<span class="gi">+                except StopIteration:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield item</span>
<span class="gi">+                    yield from isomorphs</span>
<span class="gi">+                    found_iso = True</span>
<span class="gi">+</span>
<span class="gi">+        # BASECASE</span>
<span class="gi">+        if found_iso or current_size == 1:</span>
<span class="gi">+            # Shrinking has no point because either 1) we end up with a smaller</span>
<span class="gi">+            # common subgraph (and we want the largest), or 2) there&#39;ll be no</span>
<span class="gi">+            # more subgraph.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        left_to_be_mapped = set()</span>
<span class="gi">+        for nodes in to_be_mapped:</span>
<span class="gi">+            for sgn in nodes:</span>
<span class="gi">+                # We&#39;re going to remove sgn from to_be_mapped, but subject to</span>
<span class="gi">+                # symmetry constraints. We know that for every constraint we</span>
<span class="gi">+                # have those subgraph nodes are equal. So whenever we would</span>
<span class="gi">+                # remove the lower part of a constraint, remove the higher</span>
<span class="gi">+                # instead. This is all dealth with by _remove_node. And because</span>
<span class="gi">+                # left_to_be_mapped is a set, we don&#39;t do double work.</span>
<span class="gi">+</span>
<span class="gi">+                # And finally, make the subgraph one node smaller.</span>
<span class="gi">+                # REDUCTION</span>
<span class="gi">+                new_nodes = self._remove_node(sgn, nodes, constraints)</span>
<span class="gi">+                left_to_be_mapped.add(new_nodes)</span>
<span class="gi">+        # COMBINATION</span>
<span class="gi">+        yield from self._largest_common_subgraph(</span>
<span class="gi">+            candidates, constraints, to_be_mapped=left_to_be_mapped</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _remove_node(node, nodes, constraints):
<span class="gu">@@ -487,7 +969,14 @@ class ISMAGS:</span>
<span class="w"> </span>        those subgraph nodes are equal. So whenever we would remove the
<span class="w"> </span>        lower part of a constraint, remove the higher instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while True:</span>
<span class="gi">+            for low, high in constraints:</span>
<span class="gi">+                if low == node and high in nodes:</span>
<span class="gi">+                    node = high</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:  # no break, couldn&#39;t find node in constraints</span>
<span class="gi">+                break</span>
<span class="gi">+        return frozenset(nodes - {node})</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _find_permutations(top_partitions, bottom_partitions):
<span class="gu">@@ -496,7 +985,18 @@ class ISMAGS:</span>
<span class="w"> </span>        different. Ensures that all partitions in both top and bottom
<span class="w"> </span>        partitions have size 1.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Find permutations</span>
<span class="gi">+        permutations = set()</span>
<span class="gi">+        for top, bot in zip(top_partitions, bottom_partitions):</span>
<span class="gi">+            # top and bot have only one element</span>
<span class="gi">+            if len(top) != 1 or len(bot) != 1:</span>
<span class="gi">+                raise IndexError(</span>
<span class="gi">+                    &quot;Not all nodes are coupled. This is&quot;</span>
<span class="gi">+                    f&quot; impossible: {top_partitions}, {bottom_partitions}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if top != bot:</span>
<span class="gi">+                permutations.add(frozenset((next(iter(top)), next(iter(bot)))))</span>
<span class="gi">+        return permutations</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _update_orbits(orbits, permutations):
<span class="gu">@@ -505,21 +1005,159 @@ class ISMAGS:</span>
<span class="w"> </span>        For every pair of items in permutations their respective orbits are
<span class="w"> </span>        merged.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _couple_nodes(self, top_partitions, bottom_partitions, pair_idx,</span>
<span class="gd">-        t_node, b_node, graph, edge_colors):</span>
<span class="gi">+        for permutation in permutations:</span>
<span class="gi">+            node, node2 = permutation</span>
<span class="gi">+            # Find the orbits that contain node and node2, and replace the</span>
<span class="gi">+            # orbit containing node with the union</span>
<span class="gi">+            first = second = None</span>
<span class="gi">+            for idx, orbit in enumerate(orbits):</span>
<span class="gi">+                if first is not None and second is not None:</span>
<span class="gi">+                    break</span>
<span class="gi">+                if node in orbit:</span>
<span class="gi">+                    first = idx</span>
<span class="gi">+                if node2 in orbit:</span>
<span class="gi">+                    second = idx</span>
<span class="gi">+            if first != second:</span>
<span class="gi">+                orbits[first].update(orbits[second])</span>
<span class="gi">+                del orbits[second]</span>
<span class="gi">+</span>
<span class="gi">+    def _couple_nodes(</span>
<span class="gi">+        self,</span>
<span class="gi">+        top_partitions,</span>
<span class="gi">+        bottom_partitions,</span>
<span class="gi">+        pair_idx,</span>
<span class="gi">+        t_node,</span>
<span class="gi">+        b_node,</span>
<span class="gi">+        graph,</span>
<span class="gi">+        edge_colors,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Generate new partitions from top and bottom_partitions where t_node is
<span class="w"> </span>        coupled to b_node. pair_idx is the index of the partitions where t_ and
<span class="w"> </span>        b_node can be found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _process_ordered_pair_partitions(self, graph, top_partitions,</span>
<span class="gd">-        bottom_partitions, edge_colors, orbits=None, cosets=None):</span>
<span class="gi">+        t_partition = top_partitions[pair_idx]</span>
<span class="gi">+        b_partition = bottom_partitions[pair_idx]</span>
<span class="gi">+        assert t_node in t_partition and b_node in b_partition</span>
<span class="gi">+        # Couple node to node2. This means they get their own partition</span>
<span class="gi">+        new_top_partitions = [top.copy() for top in top_partitions]</span>
<span class="gi">+        new_bottom_partitions = [bot.copy() for bot in bottom_partitions]</span>
<span class="gi">+        new_t_groups = {t_node}, t_partition - {t_node}</span>
<span class="gi">+        new_b_groups = {b_node}, b_partition - {b_node}</span>
<span class="gi">+        # Replace the old partitions with the coupled ones</span>
<span class="gi">+        del new_top_partitions[pair_idx]</span>
<span class="gi">+        del new_bottom_partitions[pair_idx]</span>
<span class="gi">+        new_top_partitions[pair_idx:pair_idx] = new_t_groups</span>
<span class="gi">+        new_bottom_partitions[pair_idx:pair_idx] = new_b_groups</span>
<span class="gi">+</span>
<span class="gi">+        new_top_partitions = self._refine_node_partitions(</span>
<span class="gi">+            graph, new_top_partitions, edge_colors</span>
<span class="gi">+        )</span>
<span class="gi">+        new_bottom_partitions = self._refine_node_partitions(</span>
<span class="gi">+            graph, new_bottom_partitions, edge_colors, branch=True</span>
<span class="gi">+        )</span>
<span class="gi">+        new_top_partitions = list(new_top_partitions)</span>
<span class="gi">+        assert len(new_top_partitions) == 1</span>
<span class="gi">+        new_top_partitions = new_top_partitions[0]</span>
<span class="gi">+        for bot in new_bottom_partitions:</span>
<span class="gi">+            yield list(new_top_partitions), bot</span>
<span class="gi">+</span>
<span class="gi">+    def _process_ordered_pair_partitions(</span>
<span class="gi">+        self,</span>
<span class="gi">+        graph,</span>
<span class="gi">+        top_partitions,</span>
<span class="gi">+        bottom_partitions,</span>
<span class="gi">+        edge_colors,</span>
<span class="gi">+        orbits=None,</span>
<span class="gi">+        cosets=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Processes ordered pair partitions as per the reference paper. Finds and
<span class="w"> </span>        returns all permutations and cosets that leave the graph unchanged.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if orbits is None:</span>
<span class="gi">+            orbits = [{node} for node in graph.nodes]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Note that we don&#39;t copy orbits when we are given one. This means</span>
<span class="gi">+            # we leak information between the recursive branches. This is</span>
<span class="gi">+            # intentional!</span>
<span class="gi">+            orbits = orbits</span>
<span class="gi">+        if cosets is None:</span>
<span class="gi">+            cosets = {}</span>
<span class="gi">+        else:</span>
<span class="gi">+            cosets = cosets.copy()</span>
<span class="gi">+</span>
<span class="gi">+        assert all(</span>
<span class="gi">+            len(t_p) == len(b_p) for t_p, b_p in zip(top_partitions, bottom_partitions)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # BASECASE</span>
<span class="gi">+        if all(len(top) == 1 for top in top_partitions):</span>
<span class="gi">+            # All nodes are mapped</span>
<span class="gi">+            permutations = self._find_permutations(top_partitions, bottom_partitions)</span>
<span class="gi">+            self._update_orbits(orbits, permutations)</span>
<span class="gi">+            if permutations:</span>
<span class="gi">+                return [permutations], cosets</span>
<span class="gi">+            else:</span>
<span class="gi">+                return [], cosets</span>
<span class="gi">+</span>
<span class="gi">+        permutations = []</span>
<span class="gi">+        unmapped_nodes = {</span>
<span class="gi">+            (node, idx)</span>
<span class="gi">+            for idx, t_partition in enumerate(top_partitions)</span>
<span class="gi">+            for node in t_partition</span>
<span class="gi">+            if len(t_partition) &gt; 1</span>
<span class="gi">+        }</span>
<span class="gi">+        node, pair_idx = min(unmapped_nodes)</span>
<span class="gi">+        b_partition = bottom_partitions[pair_idx]</span>
<span class="gi">+</span>
<span class="gi">+        for node2 in sorted(b_partition):</span>
<span class="gi">+            if len(b_partition) == 1:</span>
<span class="gi">+                # Can never result in symmetry</span>
<span class="gi">+                continue</span>
<span class="gi">+            if node != node2 and any(</span>
<span class="gi">+                node in orbit and node2 in orbit for orbit in orbits</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Orbit prune branch</span>
<span class="gi">+                continue</span>
<span class="gi">+            # REDUCTION</span>
<span class="gi">+            # Couple node to node2</span>
<span class="gi">+            partitions = self._couple_nodes(</span>
<span class="gi">+                top_partitions,</span>
<span class="gi">+                bottom_partitions,</span>
<span class="gi">+                pair_idx,</span>
<span class="gi">+                node,</span>
<span class="gi">+                node2,</span>
<span class="gi">+                graph,</span>
<span class="gi">+                edge_colors,</span>
<span class="gi">+            )</span>
<span class="gi">+            for opp in partitions:</span>
<span class="gi">+                new_top_partitions, new_bottom_partitions = opp</span>
<span class="gi">+</span>
<span class="gi">+                new_perms, new_cosets = self._process_ordered_pair_partitions(</span>
<span class="gi">+                    graph,</span>
<span class="gi">+                    new_top_partitions,</span>
<span class="gi">+                    new_bottom_partitions,</span>
<span class="gi">+                    edge_colors,</span>
<span class="gi">+                    orbits,</span>
<span class="gi">+                    cosets,</span>
<span class="gi">+                )</span>
<span class="gi">+                # COMBINATION</span>
<span class="gi">+                permutations += new_perms</span>
<span class="gi">+                cosets.update(new_cosets)</span>
<span class="gi">+</span>
<span class="gi">+        mapped = {</span>
<span class="gi">+            k</span>
<span class="gi">+            for top, bottom in zip(top_partitions, bottom_partitions)</span>
<span class="gi">+            for k in top</span>
<span class="gi">+            if len(top) == 1 and top == bottom</span>
<span class="gi">+        }</span>
<span class="gi">+        ks = {k for k in graph.nodes if k &lt; node}</span>
<span class="gi">+        # Have all nodes with ID &lt; node been mapped?</span>
<span class="gi">+        find_coset = ks &lt;= mapped and node not in cosets</span>
<span class="gi">+        if find_coset:</span>
<span class="gi">+            # Find the orbit that contains node</span>
<span class="gi">+            for orbit in orbits:</span>
<span class="gi">+                if node in orbit:</span>
<span class="gi">+                    cosets[node] = orbit.copy()</span>
<span class="gi">+        return permutations, cosets</span>
<span class="gh">diff --git a/networkx/algorithms/isomorphism/isomorph.py b/networkx/algorithms/isomorphism/isomorph.py</span>
<span class="gh">index 2f0f36208..00395b71c 100644</span>
<span class="gd">--- a/networkx/algorithms/isomorphism/isomorph.py</span>
<span class="gi">+++ b/networkx/algorithms/isomorphism/isomorph.py</span>
<span class="gu">@@ -3,11 +3,16 @@ Graph isomorphism functions.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="gd">-__all__ = [&#39;could_be_isomorphic&#39;, &#39;fast_could_be_isomorphic&#39;,</span>
<span class="gd">-    &#39;faster_could_be_isomorphic&#39;, &#39;is_isomorphic&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;could_be_isomorphic&quot;,</span>
<span class="gi">+    &quot;fast_could_be_isomorphic&quot;,</span>
<span class="gi">+    &quot;faster_could_be_isomorphic&quot;,</span>
<span class="gi">+    &quot;is_isomorphic&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1})</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1})</span>
<span class="w"> </span>def could_be_isomorphic(G1, G2):
<span class="w"> </span>    &quot;&quot;&quot;Returns False if graphs are definitely not isomorphic.
<span class="w"> </span>    True does NOT guarantee isomorphism.
<span class="gu">@@ -25,13 +30,37 @@ def could_be_isomorphic(G1, G2):</span>
<span class="w"> </span>    involving that node.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Check global properties</span>
<span class="gi">+    if G1.order() != G2.order():</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Check local properties</span>
<span class="gi">+    d1 = G1.degree()</span>
<span class="gi">+    t1 = nx.triangles(G1)</span>
<span class="gi">+    clqs_1 = list(nx.find_cliques(G1))</span>
<span class="gi">+    c1 = {n: sum(1 for c in clqs_1 if n in c) for n in G1}  # number of cliques</span>
<span class="gi">+    props1 = [[d, t1[v], c1[v]] for v, d in d1]</span>
<span class="gi">+    props1.sort()</span>
<span class="gi">+</span>
<span class="gi">+    d2 = G2.degree()</span>
<span class="gi">+    t2 = nx.triangles(G2)</span>
<span class="gi">+    clqs_2 = list(nx.find_cliques(G2))</span>
<span class="gi">+    c2 = {n: sum(1 for c in clqs_2 if n in c) for n in G2}  # number of cliques</span>
<span class="gi">+    props2 = [[d, t2[v], c2[v]] for v, d in d2]</span>
<span class="gi">+    props2.sort()</span>
<span class="gi">+</span>
<span class="gi">+    if props1 != props2:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # OK...</span>
<span class="gi">+    return True</span>


<span class="w"> </span>graph_could_be_isomorphic = could_be_isomorphic


<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1})</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1})</span>
<span class="w"> </span>def fast_could_be_isomorphic(G1, G2):
<span class="w"> </span>    &quot;&quot;&quot;Returns False if graphs are definitely not isomorphic.

<span class="gu">@@ -47,13 +76,32 @@ def fast_could_be_isomorphic(G1, G2):</span>
<span class="w"> </span>    Checks for matching degree and triangle sequences. The triangle
<span class="w"> </span>    sequence contains the number of triangles each node is part of.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check global properties</span>
<span class="gi">+    if G1.order() != G2.order():</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Check local properties</span>
<span class="gi">+    d1 = G1.degree()</span>
<span class="gi">+    t1 = nx.triangles(G1)</span>
<span class="gi">+    props1 = [[d, t1[v]] for v, d in d1]</span>
<span class="gi">+    props1.sort()</span>
<span class="gi">+</span>
<span class="gi">+    d2 = G2.degree()</span>
<span class="gi">+    t2 = nx.triangles(G2)</span>
<span class="gi">+    props2 = [[d, t2[v]] for v, d in d2]</span>
<span class="gi">+    props2.sort()</span>
<span class="gi">+</span>
<span class="gi">+    if props1 != props2:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # OK...</span>
<span class="gi">+    return True</span>


<span class="w"> </span>fast_graph_could_be_isomorphic = fast_could_be_isomorphic


<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1})</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1})</span>
<span class="w"> </span>def faster_could_be_isomorphic(G1, G2):
<span class="w"> </span>    &quot;&quot;&quot;Returns False if graphs are definitely not isomorphic.

<span class="gu">@@ -68,14 +116,29 @@ def faster_could_be_isomorphic(G1, G2):</span>
<span class="w"> </span>    -----
<span class="w"> </span>    Checks for matching degree sequences.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check global properties</span>
<span class="gi">+    if G1.order() != G2.order():</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Check local properties</span>
<span class="gi">+    d1 = sorted(d for n, d in G1.degree())</span>
<span class="gi">+    d2 = sorted(d for n, d in G2.degree())</span>
<span class="gi">+</span>
<span class="gi">+    if d1 != d2:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # OK...</span>
<span class="gi">+    return True</span>


<span class="w"> </span>faster_graph_could_be_isomorphic = faster_could_be_isomorphic


<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1}, preserve_edge_attrs=</span>
<span class="gd">-    &#39;edge_match&#39;, preserve_node_attrs=&#39;node_match&#39;)</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1},</span>
<span class="gi">+    preserve_edge_attrs=&quot;edge_match&quot;,</span>
<span class="gi">+    preserve_node_attrs=&quot;node_match&quot;,</span>
<span class="gi">+)</span>
<span class="w"> </span>def is_isomorphic(G1, G2, node_match=None, edge_match=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if the graphs G1 and G2 are isomorphic and False otherwise.

<span class="gu">@@ -173,4 +236,13 @@ def is_isomorphic(G1, G2, node_match=None, edge_match=None):</span>
<span class="w"> </span>       Pattern Recognition, Cuen, pp. 149-159, 2001.
<span class="w"> </span>       https://www.researchgate.net/publication/200034365_An_Improved_Algorithm_for_Matching_Large_Graphs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G1.is_directed() and G2.is_directed():</span>
<span class="gi">+        GM = nx.algorithms.isomorphism.DiGraphMatcher</span>
<span class="gi">+    elif (not G1.is_directed()) and (not G2.is_directed()):</span>
<span class="gi">+        GM = nx.algorithms.isomorphism.GraphMatcher</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NetworkXError(&quot;Graphs G1 and G2 are not of the same type.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    gm = GM(G1, G2, node_match=node_match, edge_match=edge_match)</span>
<span class="gi">+</span>
<span class="gi">+    return gm.is_isomorphic()</span>
<span class="gh">diff --git a/networkx/algorithms/isomorphism/isomorphvf2.py b/networkx/algorithms/isomorphism/isomorphvf2.py</span>
<span class="gh">index 9b795efe0..1b6cc7d75 100644</span>
<span class="gd">--- a/networkx/algorithms/isomorphism/isomorphvf2.py</span>
<span class="gi">+++ b/networkx/algorithms/isomorphism/isomorphvf2.py</span>
<span class="gu">@@ -138,8 +138,15 @@ graph isomorphism problem is most likely not NP-complete (although no</span>
<span class="w"> </span>polynomial-time algorithm is known to exist).

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# This work was originally coded by Christopher Ellison</span>
<span class="gi">+# as part of the Computational Mechanics Python (CMPy) project.</span>
<span class="gi">+# James P. Crutchfield, principal investigator.</span>
<span class="gi">+# Complexity Sciences Center and Physics Department, UC Davis.</span>
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gd">-__all__ = [&#39;GraphMatcher&#39;, &#39;DiGraphMatcher&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;GraphMatcher&quot;, &quot;DiGraphMatcher&quot;]</span>


<span class="w"> </span>class GraphMatcher:
<span class="gu">@@ -170,20 +177,65 @@ class GraphMatcher:</span>
<span class="w"> </span>        self.G1_nodes = set(G1.nodes())
<span class="w"> </span>        self.G2_nodes = set(G2.nodes())
<span class="w"> </span>        self.G2_node_order = {n: i for i, n in enumerate(G2)}
<span class="gi">+</span>
<span class="gi">+        # Set recursion limit.</span>
<span class="w"> </span>        self.old_recursion_limit = sys.getrecursionlimit()
<span class="w"> </span>        expected_max_recursion_level = len(self.G2)
<span class="w"> </span>        if self.old_recursion_limit &lt; 1.5 * expected_max_recursion_level:
<span class="gi">+            # Give some breathing room.</span>
<span class="w"> </span>            sys.setrecursionlimit(int(1.5 * expected_max_recursion_level))
<span class="gd">-        self.test = &#39;graph&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Declare that we will be searching for a graph-graph isomorphism.</span>
<span class="gi">+        self.test = &quot;graph&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Initialize state</span>
<span class="w"> </span>        self.initialize()

<span class="w"> </span>    def reset_recursion_limit(self):
<span class="w"> </span>        &quot;&quot;&quot;Restores the recursion limit.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO:</span>
<span class="gi">+        # Currently, we use recursion and set the recursion level higher.</span>
<span class="gi">+        # It would be nice to restore the level, but because the</span>
<span class="gi">+        # (Di)GraphMatcher classes make use of cyclic references, garbage</span>
<span class="gi">+        # collection will never happen when we define __del__() to</span>
<span class="gi">+        # restore the recursion level. The result is a memory leak.</span>
<span class="gi">+        # So for now, we do not automatically restore the recursion level,</span>
<span class="gi">+        # and instead provide a method to do this manually. Eventually,</span>
<span class="gi">+        # we should turn this into a non-recursive implementation.</span>
<span class="gi">+        sys.setrecursionlimit(self.old_recursion_limit)</span>

<span class="w"> </span>    def candidate_pairs_iter(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterator over candidate pairs of nodes in G1 and G2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # All computations are done using the current state!</span>
<span class="gi">+</span>
<span class="gi">+        G1_nodes = self.G1_nodes</span>
<span class="gi">+        G2_nodes = self.G2_nodes</span>
<span class="gi">+        min_key = self.G2_node_order.__getitem__</span>
<span class="gi">+</span>
<span class="gi">+        # First we compute the inout-terminal sets.</span>
<span class="gi">+        T1_inout = [node for node in self.inout_1 if node not in self.core_1]</span>
<span class="gi">+        T2_inout = [node for node in self.inout_2 if node not in self.core_2]</span>
<span class="gi">+</span>
<span class="gi">+        # If T1_inout and T2_inout are both nonempty.</span>
<span class="gi">+        # P(s) = T1_inout x {min T2_inout}</span>
<span class="gi">+        if T1_inout and T2_inout:</span>
<span class="gi">+            node_2 = min(T2_inout, key=min_key)</span>
<span class="gi">+            for node_1 in T1_inout:</span>
<span class="gi">+                yield node_1, node_2</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If T1_inout and T2_inout were both empty....</span>
<span class="gi">+            # P(s) = (N_1 - M_1) x {min (N_2 - M_2)}</span>
<span class="gi">+            # if not (T1_inout or T2_inout):  # as suggested by  [2], incorrect</span>
<span class="gi">+            if 1:  # as inferred from [1], correct</span>
<span class="gi">+                # First we determine the candidate node for G2</span>
<span class="gi">+                other_node = min(G2_nodes - set(self.core_2), key=min_key)</span>
<span class="gi">+                for node in self.G1:</span>
<span class="gi">+                    if node not in self.core_1:</span>
<span class="gi">+                        yield node, other_node</span>
<span class="gi">+</span>
<span class="gi">+        # For all other cases, we don&#39;t have any candidate pairs.</span>

<span class="w"> </span>    def initialize(self):
<span class="w"> </span>        &quot;&quot;&quot;Reinitializes the state of the algorithm.
<span class="gu">@@ -192,15 +244,59 @@ class GraphMatcher:</span>
<span class="w"> </span>        If only subclassing GraphMatcher, a redefinition is not necessary.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # core_1[n] contains the index of the node paired with n, which is m,</span>
<span class="gi">+        #           provided n is in the mapping.</span>
<span class="gi">+        # core_2[m] contains the index of the node paired with m, which is n,</span>
<span class="gi">+        #           provided m is in the mapping.</span>
<span class="gi">+        self.core_1 = {}</span>
<span class="gi">+        self.core_2 = {}</span>
<span class="gi">+</span>
<span class="gi">+        # See the paper for definitions of M_x and T_x^{y}</span>
<span class="gi">+</span>
<span class="gi">+        # inout_1[n]  is non-zero if n is in M_1 or in T_1^{inout}</span>
<span class="gi">+        # inout_2[m]  is non-zero if m is in M_2 or in T_2^{inout}</span>
<span class="gi">+        #</span>
<span class="gi">+        # The value stored is the depth of the SSR tree when the node became</span>
<span class="gi">+        # part of the corresponding set.</span>
<span class="gi">+        self.inout_1 = {}</span>
<span class="gi">+        self.inout_2 = {}</span>
<span class="gi">+        # Practically, these sets simply store the nodes in the subgraph.</span>
<span class="gi">+</span>
<span class="gi">+        self.state = GMState(self)</span>
<span class="gi">+</span>
<span class="gi">+        # Provide a convenient way to access the isomorphism mapping.</span>
<span class="gi">+        self.mapping = self.core_1.copy()</span>

<span class="w"> </span>    def is_isomorphic(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if G1 and G2 are isomorphic graphs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Let&#39;s do two very quick checks!</span>
<span class="gi">+        # QUESTION: Should we call faster_graph_could_be_isomorphic(G1,G2)?</span>
<span class="gi">+        # For now, I just copy the code.</span>
<span class="gi">+</span>
<span class="gi">+        # Check global properties</span>
<span class="gi">+        if self.G1.order() != self.G2.order():</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Check local properties</span>
<span class="gi">+        d1 = sorted(d for n, d in self.G1.degree())</span>
<span class="gi">+        d2 = sorted(d for n, d in self.G2.degree())</span>
<span class="gi">+        if d1 != d2:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            x = next(self.isomorphisms_iter())</span>
<span class="gi">+            return True</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    def isomorphisms_iter(self):
<span class="w"> </span>        &quot;&quot;&quot;Generator over isomorphisms between G1 and G2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Declare that we are looking for a graph-graph isomorphism.</span>
<span class="gi">+        self.test = &quot;graph&quot;</span>
<span class="gi">+        self.initialize()</span>
<span class="gi">+        yield from self.match()</span>

<span class="w"> </span>    def match(self):
<span class="w"> </span>        &quot;&quot;&quot;Extends the isomorphism mapping.
<span class="gu">@@ -211,7 +307,21 @@ class GraphMatcher:</span>
<span class="w"> </span>        we yield the mapping.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if len(self.core_1) == len(self.G2):</span>
<span class="gi">+            # Save the final mapping, otherwise garbage collection deletes it.</span>
<span class="gi">+            self.mapping = self.core_1.copy()</span>
<span class="gi">+            # The mapping is complete.</span>
<span class="gi">+            yield self.mapping</span>
<span class="gi">+        else:</span>
<span class="gi">+            for G1_node, G2_node in self.candidate_pairs_iter():</span>
<span class="gi">+                if self.syntactic_feasibility(G1_node, G2_node):</span>
<span class="gi">+                    if self.semantic_feasibility(G1_node, G2_node):</span>
<span class="gi">+                        # Recursive call, adding the feasible state.</span>
<span class="gi">+                        newstate = self.state.__class__(self, G1_node, G2_node)</span>
<span class="gi">+                        yield from self.match()</span>
<span class="gi">+</span>
<span class="gi">+                        # restore data structures</span>
<span class="gi">+                        newstate.restore()</span>

<span class="w"> </span>    def semantic_feasibility(self, G1_node, G2_node):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if adding (G1_node, G2_node) is semantically feasible.
<span class="gu">@@ -251,23 +361,41 @@ class GraphMatcher:</span>
<span class="w"> </span>        the above form to keep the match() method functional. Implementations
<span class="w"> </span>        should consider multigraphs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def subgraph_is_isomorphic(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if a subgraph of G1 is isomorphic to G2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            x = next(self.subgraph_isomorphisms_iter())</span>
<span class="gi">+            return True</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    def subgraph_is_monomorphic(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if a subgraph of G1 is monomorphic to G2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            x = next(self.subgraph_monomorphisms_iter())</span>
<span class="gi">+            return True</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    #    subgraph_is_isomorphic.__doc__ += &quot;\n&quot; + subgraph.replace(&#39;\n&#39;,&#39;\n&#39;+indent)</span>

<span class="w"> </span>    def subgraph_isomorphisms_iter(self):
<span class="w"> </span>        &quot;&quot;&quot;Generator over isomorphisms between a subgraph of G1 and G2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Declare that we are looking for graph-subgraph isomorphism.</span>
<span class="gi">+        self.test = &quot;subgraph&quot;</span>
<span class="gi">+        self.initialize()</span>
<span class="gi">+        yield from self.match()</span>

<span class="w"> </span>    def subgraph_monomorphisms_iter(self):
<span class="w"> </span>        &quot;&quot;&quot;Generator over monomorphisms between a subgraph of G1 and G2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Declare that we are looking for graph-subgraph monomorphism.</span>
<span class="gi">+        self.test = &quot;mono&quot;</span>
<span class="gi">+        self.initialize()</span>
<span class="gi">+        yield from self.match()</span>
<span class="gi">+</span>
<span class="gi">+    #    subgraph_isomorphisms_iter.__doc__ += &quot;\n&quot; + subgraph.replace(&#39;\n&#39;,&#39;\n&#39;+indent)</span>

<span class="w"> </span>    def syntactic_feasibility(self, G1_node, G2_node):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if adding (G1_node, G2_node) is syntactically feasible.
<span class="gu">@@ -277,7 +405,120 @@ class GraphMatcher:</span>
<span class="w"> </span>        The addition is allowable if the inclusion of the candidate pair does
<span class="w"> </span>        not make it impossible for an isomorphism/monomorphism to be found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # The VF2 algorithm was designed to work with graphs having, at most,</span>
<span class="gi">+        # one edge connecting any two nodes.  This is not the case when</span>
<span class="gi">+        # dealing with an MultiGraphs.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Basically, when we test the look-ahead rules R_neighbor, we will</span>
<span class="gi">+        # make sure that the number of edges are checked. We also add</span>
<span class="gi">+        # a R_self check to verify that the number of selfloops is acceptable.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Users might be comparing Graph instances with MultiGraph instances.</span>
<span class="gi">+        # So the generic GraphMatcher class must work with MultiGraphs.</span>
<span class="gi">+        # Care must be taken since the value in the innermost dictionary is a</span>
<span class="gi">+        # singlet for Graph instances.  For MultiGraphs, the value in the</span>
<span class="gi">+        # innermost dictionary is a list.</span>
<span class="gi">+</span>
<span class="gi">+        ###</span>
<span class="gi">+        # Test at each step to get a return value as soon as possible.</span>
<span class="gi">+        ###</span>
<span class="gi">+</span>
<span class="gi">+        # Look ahead 0</span>
<span class="gi">+</span>
<span class="gi">+        # R_self</span>
<span class="gi">+</span>
<span class="gi">+        # The number of selfloops for G1_node must equal the number of</span>
<span class="gi">+        # self-loops for G2_node. Without this check, we would fail on</span>
<span class="gi">+        # R_neighbor at the next recursion level. But it is good to prune the</span>
<span class="gi">+        # search tree now.</span>
<span class="gi">+</span>
<span class="gi">+        if self.test == &quot;mono&quot;:</span>
<span class="gi">+            if self.G1.number_of_edges(G1_node, G1_node) &lt; self.G2.number_of_edges(</span>
<span class="gi">+                G2_node, G2_node</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.G1.number_of_edges(G1_node, G1_node) != self.G2.number_of_edges(</span>
<span class="gi">+                G2_node, G2_node</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        # R_neighbor</span>
<span class="gi">+</span>
<span class="gi">+        # For each neighbor n&#39; of n in the partial mapping, the corresponding</span>
<span class="gi">+        # node m&#39; is a neighbor of m, and vice versa. Also, the number of</span>
<span class="gi">+        # edges must be equal.</span>
<span class="gi">+        if self.test != &quot;mono&quot;:</span>
<span class="gi">+            for neighbor in self.G1[G1_node]:</span>
<span class="gi">+                if neighbor in self.core_1:</span>
<span class="gi">+                    if self.core_1[neighbor] not in self.G2[G2_node]:</span>
<span class="gi">+                        return False</span>
<span class="gi">+                    elif self.G1.number_of_edges(</span>
<span class="gi">+                        neighbor, G1_node</span>
<span class="gi">+                    ) != self.G2.number_of_edges(self.core_1[neighbor], G2_node):</span>
<span class="gi">+                        return False</span>
<span class="gi">+</span>
<span class="gi">+        for neighbor in self.G2[G2_node]:</span>
<span class="gi">+            if neighbor in self.core_2:</span>
<span class="gi">+                if self.core_2[neighbor] not in self.G1[G1_node]:</span>
<span class="gi">+                    return False</span>
<span class="gi">+                elif self.test == &quot;mono&quot;:</span>
<span class="gi">+                    if self.G1.number_of_edges(</span>
<span class="gi">+                        self.core_2[neighbor], G1_node</span>
<span class="gi">+                    ) &lt; self.G2.number_of_edges(neighbor, G2_node):</span>
<span class="gi">+                        return False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if self.G1.number_of_edges(</span>
<span class="gi">+                        self.core_2[neighbor], G1_node</span>
<span class="gi">+                    ) != self.G2.number_of_edges(neighbor, G2_node):</span>
<span class="gi">+                        return False</span>
<span class="gi">+</span>
<span class="gi">+        if self.test != &quot;mono&quot;:</span>
<span class="gi">+            # Look ahead 1</span>
<span class="gi">+</span>
<span class="gi">+            # R_terminout</span>
<span class="gi">+            # The number of neighbors of n in T_1^{inout} is equal to the</span>
<span class="gi">+            # number of neighbors of m that are in T_2^{inout}, and vice versa.</span>
<span class="gi">+            num1 = 0</span>
<span class="gi">+            for neighbor in self.G1[G1_node]:</span>
<span class="gi">+                if (neighbor in self.inout_1) and (neighbor not in self.core_1):</span>
<span class="gi">+                    num1 += 1</span>
<span class="gi">+            num2 = 0</span>
<span class="gi">+            for neighbor in self.G2[G2_node]:</span>
<span class="gi">+                if (neighbor in self.inout_2) and (neighbor not in self.core_2):</span>
<span class="gi">+                    num2 += 1</span>
<span class="gi">+            if self.test == &quot;graph&quot;:</span>
<span class="gi">+                if num1 != num2:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:  # self.test == &#39;subgraph&#39;</span>
<span class="gi">+                if not (num1 &gt;= num2):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+            # Look ahead 2</span>
<span class="gi">+</span>
<span class="gi">+            # R_new</span>
<span class="gi">+</span>
<span class="gi">+            # The number of neighbors of n that are neither in the core_1 nor</span>
<span class="gi">+            # T_1^{inout} is equal to the number of neighbors of m</span>
<span class="gi">+            # that are neither in core_2 nor T_2^{inout}.</span>
<span class="gi">+            num1 = 0</span>
<span class="gi">+            for neighbor in self.G1[G1_node]:</span>
<span class="gi">+                if neighbor not in self.inout_1:</span>
<span class="gi">+                    num1 += 1</span>
<span class="gi">+            num2 = 0</span>
<span class="gi">+            for neighbor in self.G2[G2_node]:</span>
<span class="gi">+                if neighbor not in self.inout_2:</span>
<span class="gi">+                    num2 += 1</span>
<span class="gi">+            if self.test == &quot;graph&quot;:</span>
<span class="gi">+                if num1 != num2:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:  # self.test == &#39;subgraph&#39;</span>
<span class="gi">+                if not (num1 &gt;= num2):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise, this node pair is syntactically feasible!</span>
<span class="gi">+        return True</span>


<span class="w"> </span>class DiGraphMatcher(GraphMatcher):
<span class="gu">@@ -304,7 +545,50 @@ class DiGraphMatcher(GraphMatcher):</span>

<span class="w"> </span>    def candidate_pairs_iter(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterator over candidate pairs of nodes in G1 and G2.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # All computations are done using the current state!</span>
<span class="gi">+</span>
<span class="gi">+        G1_nodes = self.G1_nodes</span>
<span class="gi">+        G2_nodes = self.G2_nodes</span>
<span class="gi">+        min_key = self.G2_node_order.__getitem__</span>
<span class="gi">+</span>
<span class="gi">+        # First we compute the out-terminal sets.</span>
<span class="gi">+        T1_out = [node for node in self.out_1 if node not in self.core_1]</span>
<span class="gi">+        T2_out = [node for node in self.out_2 if node not in self.core_2]</span>
<span class="gi">+</span>
<span class="gi">+        # If T1_out and T2_out are both nonempty.</span>
<span class="gi">+        # P(s) = T1_out x {min T2_out}</span>
<span class="gi">+        if T1_out and T2_out:</span>
<span class="gi">+            node_2 = min(T2_out, key=min_key)</span>
<span class="gi">+            for node_1 in T1_out:</span>
<span class="gi">+                yield node_1, node_2</span>
<span class="gi">+</span>
<span class="gi">+        # If T1_out and T2_out were both empty....</span>
<span class="gi">+        # We compute the in-terminal sets.</span>
<span class="gi">+</span>
<span class="gi">+        # elif not (T1_out or T2_out):   # as suggested by [2], incorrect</span>
<span class="gi">+        else:  # as suggested by [1], correct</span>
<span class="gi">+            T1_in = [node for node in self.in_1 if node not in self.core_1]</span>
<span class="gi">+            T2_in = [node for node in self.in_2 if node not in self.core_2]</span>
<span class="gi">+</span>
<span class="gi">+            # If T1_in and T2_in are both nonempty.</span>
<span class="gi">+            # P(s) = T1_out x {min T2_out}</span>
<span class="gi">+            if T1_in and T2_in:</span>
<span class="gi">+                node_2 = min(T2_in, key=min_key)</span>
<span class="gi">+                for node_1 in T1_in:</span>
<span class="gi">+                    yield node_1, node_2</span>
<span class="gi">+</span>
<span class="gi">+            # If all terminal sets are empty...</span>
<span class="gi">+            # P(s) = (N_1 - M_1) x {min (N_2 - M_2)}</span>
<span class="gi">+</span>
<span class="gi">+            # elif not (T1_in or T2_in):   # as suggested by  [2], incorrect</span>
<span class="gi">+            else:  # as inferred from [1], correct</span>
<span class="gi">+                node_2 = min(G2_nodes - set(self.core_2), key=min_key)</span>
<span class="gi">+                for node_1 in G1_nodes:</span>
<span class="gi">+                    if node_1 not in self.core_1:</span>
<span class="gi">+                        yield node_1, node_2</span>
<span class="gi">+</span>
<span class="gi">+        # For all other cases, we don&#39;t have any candidate pairs.</span>

<span class="w"> </span>    def initialize(self):
<span class="w"> </span>        &quot;&quot;&quot;Reinitializes the state of the algorithm.
<span class="gu">@@ -312,7 +596,33 @@ class DiGraphMatcher(GraphMatcher):</span>
<span class="w"> </span>        This method should be redefined if using something other than DiGMState.
<span class="w"> </span>        If only subclassing GraphMatcher, a redefinition is not necessary.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # core_1[n] contains the index of the node paired with n, which is m,</span>
<span class="gi">+        #           provided n is in the mapping.</span>
<span class="gi">+        # core_2[m] contains the index of the node paired with m, which is n,</span>
<span class="gi">+        #           provided m is in the mapping.</span>
<span class="gi">+        self.core_1 = {}</span>
<span class="gi">+        self.core_2 = {}</span>
<span class="gi">+</span>
<span class="gi">+        # See the paper for definitions of M_x and T_x^{y}</span>
<span class="gi">+</span>
<span class="gi">+        # in_1[n]  is non-zero if n is in M_1 or in T_1^{in}</span>
<span class="gi">+        # out_1[n] is non-zero if n is in M_1 or in T_1^{out}</span>
<span class="gi">+        #</span>
<span class="gi">+        # in_2[m]  is non-zero if m is in M_2 or in T_2^{in}</span>
<span class="gi">+        # out_2[m] is non-zero if m is in M_2 or in T_2^{out}</span>
<span class="gi">+        #</span>
<span class="gi">+        # The value stored is the depth of the search tree when the node became</span>
<span class="gi">+        # part of the corresponding set.</span>
<span class="gi">+        self.in_1 = {}</span>
<span class="gi">+        self.in_2 = {}</span>
<span class="gi">+        self.out_1 = {}</span>
<span class="gi">+        self.out_2 = {}</span>
<span class="gi">+</span>
<span class="gi">+        self.state = DiGMState(self)</span>
<span class="gi">+</span>
<span class="gi">+        # Provide a convenient way to access the isomorphism mapping.</span>
<span class="gi">+        self.mapping = self.core_1.copy()</span>

<span class="w"> </span>    def syntactic_feasibility(self, G1_node, G2_node):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if adding (G1_node, G2_node) is syntactically feasible.
<span class="gu">@@ -322,7 +632,219 @@ class DiGraphMatcher(GraphMatcher):</span>
<span class="w"> </span>        The addition is allowable if the inclusion of the candidate pair does
<span class="w"> </span>        not make it impossible for an isomorphism/monomorphism to be found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # The VF2 algorithm was designed to work with graphs having, at most,</span>
<span class="gi">+        # one edge connecting any two nodes.  This is not the case when</span>
<span class="gi">+        # dealing with an MultiGraphs.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Basically, when we test the look-ahead rules R_pred and R_succ, we</span>
<span class="gi">+        # will make sure that the number of edges are checked.  We also add</span>
<span class="gi">+        # a R_self check to verify that the number of selfloops is acceptable.</span>
<span class="gi">+</span>
<span class="gi">+        # Users might be comparing DiGraph instances with MultiDiGraph</span>
<span class="gi">+        # instances. So the generic DiGraphMatcher class must work with</span>
<span class="gi">+        # MultiDiGraphs. Care must be taken since the value in the innermost</span>
<span class="gi">+        # dictionary is a singlet for DiGraph instances.  For MultiDiGraphs,</span>
<span class="gi">+        # the value in the innermost dictionary is a list.</span>
<span class="gi">+</span>
<span class="gi">+        ###</span>
<span class="gi">+        # Test at each step to get a return value as soon as possible.</span>
<span class="gi">+        ###</span>
<span class="gi">+</span>
<span class="gi">+        # Look ahead 0</span>
<span class="gi">+</span>
<span class="gi">+        # R_self</span>
<span class="gi">+</span>
<span class="gi">+        # The number of selfloops for G1_node must equal the number of</span>
<span class="gi">+        # self-loops for G2_node. Without this check, we would fail on R_pred</span>
<span class="gi">+        # at the next recursion level. This should prune the tree even further.</span>
<span class="gi">+        if self.test == &quot;mono&quot;:</span>
<span class="gi">+            if self.G1.number_of_edges(G1_node, G1_node) &lt; self.G2.number_of_edges(</span>
<span class="gi">+                G2_node, G2_node</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.G1.number_of_edges(G1_node, G1_node) != self.G2.number_of_edges(</span>
<span class="gi">+                G2_node, G2_node</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        # R_pred</span>
<span class="gi">+</span>
<span class="gi">+        # For each predecessor n&#39; of n in the partial mapping, the</span>
<span class="gi">+        # corresponding node m&#39; is a predecessor of m, and vice versa. Also,</span>
<span class="gi">+        # the number of edges must be equal</span>
<span class="gi">+        if self.test != &quot;mono&quot;:</span>
<span class="gi">+            for predecessor in self.G1.pred[G1_node]:</span>
<span class="gi">+                if predecessor in self.core_1:</span>
<span class="gi">+                    if self.core_1[predecessor] not in self.G2.pred[G2_node]:</span>
<span class="gi">+                        return False</span>
<span class="gi">+                    elif self.G1.number_of_edges(</span>
<span class="gi">+                        predecessor, G1_node</span>
<span class="gi">+                    ) != self.G2.number_of_edges(self.core_1[predecessor], G2_node):</span>
<span class="gi">+                        return False</span>
<span class="gi">+</span>
<span class="gi">+        for predecessor in self.G2.pred[G2_node]:</span>
<span class="gi">+            if predecessor in self.core_2:</span>
<span class="gi">+                if self.core_2[predecessor] not in self.G1.pred[G1_node]:</span>
<span class="gi">+                    return False</span>
<span class="gi">+                elif self.test == &quot;mono&quot;:</span>
<span class="gi">+                    if self.G1.number_of_edges(</span>
<span class="gi">+                        self.core_2[predecessor], G1_node</span>
<span class="gi">+                    ) &lt; self.G2.number_of_edges(predecessor, G2_node):</span>
<span class="gi">+                        return False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if self.G1.number_of_edges(</span>
<span class="gi">+                        self.core_2[predecessor], G1_node</span>
<span class="gi">+                    ) != self.G2.number_of_edges(predecessor, G2_node):</span>
<span class="gi">+                        return False</span>
<span class="gi">+</span>
<span class="gi">+        # R_succ</span>
<span class="gi">+</span>
<span class="gi">+        # For each successor n&#39; of n in the partial mapping, the corresponding</span>
<span class="gi">+        # node m&#39; is a successor of m, and vice versa. Also, the number of</span>
<span class="gi">+        # edges must be equal.</span>
<span class="gi">+        if self.test != &quot;mono&quot;:</span>
<span class="gi">+            for successor in self.G1[G1_node]:</span>
<span class="gi">+                if successor in self.core_1:</span>
<span class="gi">+                    if self.core_1[successor] not in self.G2[G2_node]:</span>
<span class="gi">+                        return False</span>
<span class="gi">+                    elif self.G1.number_of_edges(</span>
<span class="gi">+                        G1_node, successor</span>
<span class="gi">+                    ) != self.G2.number_of_edges(G2_node, self.core_1[successor]):</span>
<span class="gi">+                        return False</span>
<span class="gi">+</span>
<span class="gi">+        for successor in self.G2[G2_node]:</span>
<span class="gi">+            if successor in self.core_2:</span>
<span class="gi">+                if self.core_2[successor] not in self.G1[G1_node]:</span>
<span class="gi">+                    return False</span>
<span class="gi">+                elif self.test == &quot;mono&quot;:</span>
<span class="gi">+                    if self.G1.number_of_edges(</span>
<span class="gi">+                        G1_node, self.core_2[successor]</span>
<span class="gi">+                    ) &lt; self.G2.number_of_edges(G2_node, successor):</span>
<span class="gi">+                        return False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if self.G1.number_of_edges(</span>
<span class="gi">+                        G1_node, self.core_2[successor]</span>
<span class="gi">+                    ) != self.G2.number_of_edges(G2_node, successor):</span>
<span class="gi">+                        return False</span>
<span class="gi">+</span>
<span class="gi">+        if self.test != &quot;mono&quot;:</span>
<span class="gi">+            # Look ahead 1</span>
<span class="gi">+</span>
<span class="gi">+            # R_termin</span>
<span class="gi">+            # The number of predecessors of n that are in T_1^{in} is equal to the</span>
<span class="gi">+            # number of predecessors of m that are in T_2^{in}.</span>
<span class="gi">+            num1 = 0</span>
<span class="gi">+            for predecessor in self.G1.pred[G1_node]:</span>
<span class="gi">+                if (predecessor in self.in_1) and (predecessor not in self.core_1):</span>
<span class="gi">+                    num1 += 1</span>
<span class="gi">+            num2 = 0</span>
<span class="gi">+            for predecessor in self.G2.pred[G2_node]:</span>
<span class="gi">+                if (predecessor in self.in_2) and (predecessor not in self.core_2):</span>
<span class="gi">+                    num2 += 1</span>
<span class="gi">+            if self.test == &quot;graph&quot;:</span>
<span class="gi">+                if num1 != num2:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:  # self.test == &#39;subgraph&#39;</span>
<span class="gi">+                if not (num1 &gt;= num2):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+            # The number of successors of n that are in T_1^{in} is equal to the</span>
<span class="gi">+            # number of successors of m that are in T_2^{in}.</span>
<span class="gi">+            num1 = 0</span>
<span class="gi">+            for successor in self.G1[G1_node]:</span>
<span class="gi">+                if (successor in self.in_1) and (successor not in self.core_1):</span>
<span class="gi">+                    num1 += 1</span>
<span class="gi">+            num2 = 0</span>
<span class="gi">+            for successor in self.G2[G2_node]:</span>
<span class="gi">+                if (successor in self.in_2) and (successor not in self.core_2):</span>
<span class="gi">+                    num2 += 1</span>
<span class="gi">+            if self.test == &quot;graph&quot;:</span>
<span class="gi">+                if num1 != num2:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:  # self.test == &#39;subgraph&#39;</span>
<span class="gi">+                if not (num1 &gt;= num2):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+            # R_termout</span>
<span class="gi">+</span>
<span class="gi">+            # The number of predecessors of n that are in T_1^{out} is equal to the</span>
<span class="gi">+            # number of predecessors of m that are in T_2^{out}.</span>
<span class="gi">+            num1 = 0</span>
<span class="gi">+            for predecessor in self.G1.pred[G1_node]:</span>
<span class="gi">+                if (predecessor in self.out_1) and (predecessor not in self.core_1):</span>
<span class="gi">+                    num1 += 1</span>
<span class="gi">+            num2 = 0</span>
<span class="gi">+            for predecessor in self.G2.pred[G2_node]:</span>
<span class="gi">+                if (predecessor in self.out_2) and (predecessor not in self.core_2):</span>
<span class="gi">+                    num2 += 1</span>
<span class="gi">+            if self.test == &quot;graph&quot;:</span>
<span class="gi">+                if num1 != num2:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:  # self.test == &#39;subgraph&#39;</span>
<span class="gi">+                if not (num1 &gt;= num2):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+            # The number of successors of n that are in T_1^{out} is equal to the</span>
<span class="gi">+            # number of successors of m that are in T_2^{out}.</span>
<span class="gi">+            num1 = 0</span>
<span class="gi">+            for successor in self.G1[G1_node]:</span>
<span class="gi">+                if (successor in self.out_1) and (successor not in self.core_1):</span>
<span class="gi">+                    num1 += 1</span>
<span class="gi">+            num2 = 0</span>
<span class="gi">+            for successor in self.G2[G2_node]:</span>
<span class="gi">+                if (successor in self.out_2) and (successor not in self.core_2):</span>
<span class="gi">+                    num2 += 1</span>
<span class="gi">+            if self.test == &quot;graph&quot;:</span>
<span class="gi">+                if num1 != num2:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:  # self.test == &#39;subgraph&#39;</span>
<span class="gi">+                if not (num1 &gt;= num2):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+            # Look ahead 2</span>
<span class="gi">+</span>
<span class="gi">+            # R_new</span>
<span class="gi">+</span>
<span class="gi">+            # The number of predecessors of n that are neither in the core_1 nor</span>
<span class="gi">+            # T_1^{in} nor T_1^{out} is equal to the number of predecessors of m</span>
<span class="gi">+            # that are neither in core_2 nor T_2^{in} nor T_2^{out}.</span>
<span class="gi">+            num1 = 0</span>
<span class="gi">+            for predecessor in self.G1.pred[G1_node]:</span>
<span class="gi">+                if (predecessor not in self.in_1) and (predecessor not in self.out_1):</span>
<span class="gi">+                    num1 += 1</span>
<span class="gi">+            num2 = 0</span>
<span class="gi">+            for predecessor in self.G2.pred[G2_node]:</span>
<span class="gi">+                if (predecessor not in self.in_2) and (predecessor not in self.out_2):</span>
<span class="gi">+                    num2 += 1</span>
<span class="gi">+            if self.test == &quot;graph&quot;:</span>
<span class="gi">+                if num1 != num2:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:  # self.test == &#39;subgraph&#39;</span>
<span class="gi">+                if not (num1 &gt;= num2):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+            # The number of successors of n that are neither in the core_1 nor</span>
<span class="gi">+            # T_1^{in} nor T_1^{out} is equal to the number of successors of m</span>
<span class="gi">+            # that are neither in core_2 nor T_2^{in} nor T_2^{out}.</span>
<span class="gi">+            num1 = 0</span>
<span class="gi">+            for successor in self.G1[G1_node]:</span>
<span class="gi">+                if (successor not in self.in_1) and (successor not in self.out_1):</span>
<span class="gi">+                    num1 += 1</span>
<span class="gi">+            num2 = 0</span>
<span class="gi">+            for successor in self.G2[G2_node]:</span>
<span class="gi">+                if (successor not in self.in_2) and (successor not in self.out_2):</span>
<span class="gi">+                    num2 += 1</span>
<span class="gi">+            if self.test == &quot;graph&quot;:</span>
<span class="gi">+                if num1 != num2:</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:  # self.test == &#39;subgraph&#39;</span>
<span class="gi">+                if not (num1 &gt;= num2):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+        # Otherwise, this node pair is syntactically feasible!</span>
<span class="gi">+        return True</span>


<span class="w"> </span>class GMState:
<span class="gu">@@ -342,42 +864,75 @@ class GMState:</span>
<span class="w"> </span>        isomorphism mapping.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.GM = GM
<span class="gi">+</span>
<span class="gi">+        # Initialize the last stored node pair.</span>
<span class="w"> </span>        self.G1_node = None
<span class="w"> </span>        self.G2_node = None
<span class="w"> </span>        self.depth = len(GM.core_1)
<span class="gi">+</span>
<span class="w"> </span>        if G1_node is None or G2_node is None:
<span class="gi">+            # Then we reset the class variables</span>
<span class="w"> </span>            GM.core_1 = {}
<span class="w"> </span>            GM.core_2 = {}
<span class="w"> </span>            GM.inout_1 = {}
<span class="w"> </span>            GM.inout_2 = {}
<span class="gi">+</span>
<span class="gi">+        # Watch out! G1_node == 0 should evaluate to True.</span>
<span class="w"> </span>        if G1_node is not None and G2_node is not None:
<span class="gi">+            # Add the node pair to the isomorphism mapping.</span>
<span class="w"> </span>            GM.core_1[G1_node] = G2_node
<span class="w"> </span>            GM.core_2[G2_node] = G1_node
<span class="gi">+</span>
<span class="gi">+            # Store the node that was added last.</span>
<span class="w"> </span>            self.G1_node = G1_node
<span class="w"> </span>            self.G2_node = G2_node
<span class="gi">+</span>
<span class="gi">+            # Now we must update the other two vectors.</span>
<span class="gi">+            # We will add only if it is not in there already!</span>
<span class="w"> </span>            self.depth = len(GM.core_1)
<span class="gi">+</span>
<span class="gi">+            # First we add the new nodes...</span>
<span class="w"> </span>            if G1_node not in GM.inout_1:
<span class="w"> </span>                GM.inout_1[G1_node] = self.depth
<span class="w"> </span>            if G2_node not in GM.inout_2:
<span class="w"> </span>                GM.inout_2[G2_node] = self.depth
<span class="gi">+</span>
<span class="gi">+            # Now we add every other node...</span>
<span class="gi">+</span>
<span class="gi">+            # Updates for T_1^{inout}</span>
<span class="w"> </span>            new_nodes = set()
<span class="w"> </span>            for node in GM.core_1:
<span class="gd">-                new_nodes.update([neighbor for neighbor in GM.G1[node] if </span>
<span class="gd">-                    neighbor not in GM.core_1])</span>
<span class="gi">+                new_nodes.update(</span>
<span class="gi">+                    [neighbor for neighbor in GM.G1[node] if neighbor not in GM.core_1]</span>
<span class="gi">+                )</span>
<span class="w"> </span>            for node in new_nodes:
<span class="w"> </span>                if node not in GM.inout_1:
<span class="w"> </span>                    GM.inout_1[node] = self.depth
<span class="gi">+</span>
<span class="gi">+            # Updates for T_2^{inout}</span>
<span class="w"> </span>            new_nodes = set()
<span class="w"> </span>            for node in GM.core_2:
<span class="gd">-                new_nodes.update([neighbor for neighbor in GM.G2[node] if </span>
<span class="gd">-                    neighbor not in GM.core_2])</span>
<span class="gi">+                new_nodes.update(</span>
<span class="gi">+                    [neighbor for neighbor in GM.G2[node] if neighbor not in GM.core_2]</span>
<span class="gi">+                )</span>
<span class="w"> </span>            for node in new_nodes:
<span class="w"> </span>                if node not in GM.inout_2:
<span class="w"> </span>                    GM.inout_2[node] = self.depth

<span class="w"> </span>    def restore(self):
<span class="w"> </span>        &quot;&quot;&quot;Deletes the GMState object and restores the class variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # First we remove the node that was added from the core vectors.</span>
<span class="gi">+        # Watch out! G1_node == 0 should evaluate to True.</span>
<span class="gi">+        if self.G1_node is not None and self.G2_node is not None:</span>
<span class="gi">+            del self.GM.core_1[self.G1_node]</span>
<span class="gi">+            del self.GM.core_2[self.G2_node]</span>
<span class="gi">+</span>
<span class="gi">+        # Now we revert the other two vectors.</span>
<span class="gi">+        # Thus, we delete all entries which have this depth level.</span>
<span class="gi">+        for vector in (self.GM.inout_1, self.GM.inout_2):</span>
<span class="gi">+            for node in list(vector.keys()):</span>
<span class="gi">+                if vector[node] == self.depth:</span>
<span class="gi">+                    del vector[node]</span>


<span class="w"> </span>class DiGMState:
<span class="gu">@@ -398,57 +953,113 @@ class DiGMState:</span>
<span class="w"> </span>        isomorphism mapping.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.GM = GM
<span class="gi">+</span>
<span class="gi">+        # Initialize the last stored node pair.</span>
<span class="w"> </span>        self.G1_node = None
<span class="w"> </span>        self.G2_node = None
<span class="w"> </span>        self.depth = len(GM.core_1)
<span class="gi">+</span>
<span class="w"> </span>        if G1_node is None or G2_node is None:
<span class="gi">+            # Then we reset the class variables</span>
<span class="w"> </span>            GM.core_1 = {}
<span class="w"> </span>            GM.core_2 = {}
<span class="w"> </span>            GM.in_1 = {}
<span class="w"> </span>            GM.in_2 = {}
<span class="w"> </span>            GM.out_1 = {}
<span class="w"> </span>            GM.out_2 = {}
<span class="gi">+</span>
<span class="gi">+        # Watch out! G1_node == 0 should evaluate to True.</span>
<span class="w"> </span>        if G1_node is not None and G2_node is not None:
<span class="gi">+            # Add the node pair to the isomorphism mapping.</span>
<span class="w"> </span>            GM.core_1[G1_node] = G2_node
<span class="w"> </span>            GM.core_2[G2_node] = G1_node
<span class="gi">+</span>
<span class="gi">+            # Store the node that was added last.</span>
<span class="w"> </span>            self.G1_node = G1_node
<span class="w"> </span>            self.G2_node = G2_node
<span class="gi">+</span>
<span class="gi">+            # Now we must update the other four vectors.</span>
<span class="gi">+            # We will add only if it is not in there already!</span>
<span class="w"> </span>            self.depth = len(GM.core_1)
<span class="gi">+</span>
<span class="gi">+            # First we add the new nodes...</span>
<span class="w"> </span>            for vector in (GM.in_1, GM.out_1):
<span class="w"> </span>                if G1_node not in vector:
<span class="w"> </span>                    vector[G1_node] = self.depth
<span class="w"> </span>            for vector in (GM.in_2, GM.out_2):
<span class="w"> </span>                if G2_node not in vector:
<span class="w"> </span>                    vector[G2_node] = self.depth
<span class="gi">+</span>
<span class="gi">+            # Now we add every other node...</span>
<span class="gi">+</span>
<span class="gi">+            # Updates for T_1^{in}</span>
<span class="w"> </span>            new_nodes = set()
<span class="w"> </span>            for node in GM.core_1:
<span class="gd">-                new_nodes.update([predecessor for predecessor in GM.G1.</span>
<span class="gd">-                    predecessors(node) if predecessor not in GM.core_1])</span>
<span class="gi">+                new_nodes.update(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        predecessor</span>
<span class="gi">+                        for predecessor in GM.G1.predecessors(node)</span>
<span class="gi">+                        if predecessor not in GM.core_1</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="w"> </span>            for node in new_nodes:
<span class="w"> </span>                if node not in GM.in_1:
<span class="w"> </span>                    GM.in_1[node] = self.depth
<span class="gi">+</span>
<span class="gi">+            # Updates for T_2^{in}</span>
<span class="w"> </span>            new_nodes = set()
<span class="w"> </span>            for node in GM.core_2:
<span class="gd">-                new_nodes.update([predecessor for predecessor in GM.G2.</span>
<span class="gd">-                    predecessors(node) if predecessor not in GM.core_2])</span>
<span class="gi">+                new_nodes.update(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        predecessor</span>
<span class="gi">+                        for predecessor in GM.G2.predecessors(node)</span>
<span class="gi">+                        if predecessor not in GM.core_2</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="w"> </span>            for node in new_nodes:
<span class="w"> </span>                if node not in GM.in_2:
<span class="w"> </span>                    GM.in_2[node] = self.depth
<span class="gi">+</span>
<span class="gi">+            # Updates for T_1^{out}</span>
<span class="w"> </span>            new_nodes = set()
<span class="w"> </span>            for node in GM.core_1:
<span class="gd">-                new_nodes.update([successor for successor in GM.G1.</span>
<span class="gd">-                    successors(node) if successor not in GM.core_1])</span>
<span class="gi">+                new_nodes.update(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        successor</span>
<span class="gi">+                        for successor in GM.G1.successors(node)</span>
<span class="gi">+                        if successor not in GM.core_1</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="w"> </span>            for node in new_nodes:
<span class="w"> </span>                if node not in GM.out_1:
<span class="w"> </span>                    GM.out_1[node] = self.depth
<span class="gi">+</span>
<span class="gi">+            # Updates for T_2^{out}</span>
<span class="w"> </span>            new_nodes = set()
<span class="w"> </span>            for node in GM.core_2:
<span class="gd">-                new_nodes.update([successor for successor in GM.G2.</span>
<span class="gd">-                    successors(node) if successor not in GM.core_2])</span>
<span class="gi">+                new_nodes.update(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        successor</span>
<span class="gi">+                        for successor in GM.G2.successors(node)</span>
<span class="gi">+                        if successor not in GM.core_2</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="w"> </span>            for node in new_nodes:
<span class="w"> </span>                if node not in GM.out_2:
<span class="w"> </span>                    GM.out_2[node] = self.depth

<span class="w"> </span>    def restore(self):
<span class="w"> </span>        &quot;&quot;&quot;Deletes the DiGMState object and restores the class variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # First we remove the node that was added from the core vectors.</span>
<span class="gi">+        # Watch out! G1_node == 0 should evaluate to True.</span>
<span class="gi">+        if self.G1_node is not None and self.G2_node is not None:</span>
<span class="gi">+            del self.GM.core_1[self.G1_node]</span>
<span class="gi">+            del self.GM.core_2[self.G2_node]</span>
<span class="gi">+</span>
<span class="gi">+        # Now we revert the other four vectors.</span>
<span class="gi">+        # Thus, we delete all entries which have this depth level.</span>
<span class="gi">+        for vector in (self.GM.in_1, self.GM.in_2, self.GM.out_1, self.GM.out_2):</span>
<span class="gi">+            for node in list(vector.keys()):</span>
<span class="gi">+                if vector[node] == self.depth:</span>
<span class="gi">+                    del vector[node]</span>
<span class="gh">diff --git a/networkx/algorithms/isomorphism/matchhelpers.py b/networkx/algorithms/isomorphism/matchhelpers.py</span>
<span class="gh">index 0f9d47ddc..8185f34eb 100644</span>
<span class="gd">--- a/networkx/algorithms/isomorphism/matchhelpers.py</span>
<span class="gi">+++ b/networkx/algorithms/isomorphism/matchhelpers.py</span>
<span class="gu">@@ -4,18 +4,28 @@ edge_match functions to use during isomorphism checks.</span>
<span class="w"> </span>import math
<span class="w"> </span>import types
<span class="w"> </span>from itertools import permutations
<span class="gd">-__all__ = [&#39;categorical_node_match&#39;, &#39;categorical_edge_match&#39;,</span>
<span class="gd">-    &#39;categorical_multiedge_match&#39;, &#39;numerical_node_match&#39;,</span>
<span class="gd">-    &#39;numerical_edge_match&#39;, &#39;numerical_multiedge_match&#39;,</span>
<span class="gd">-    &#39;generic_node_match&#39;, &#39;generic_edge_match&#39;, &#39;generic_multiedge_match&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;categorical_node_match&quot;,</span>
<span class="gi">+    &quot;categorical_edge_match&quot;,</span>
<span class="gi">+    &quot;categorical_multiedge_match&quot;,</span>
<span class="gi">+    &quot;numerical_node_match&quot;,</span>
<span class="gi">+    &quot;numerical_edge_match&quot;,</span>
<span class="gi">+    &quot;numerical_multiedge_match&quot;,</span>
<span class="gi">+    &quot;generic_node_match&quot;,</span>
<span class="gi">+    &quot;generic_edge_match&quot;,</span>
<span class="gi">+    &quot;generic_multiedge_match&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def copyfunc(f, name=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a deepcopy of a function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return types.FunctionType(</span>
<span class="gi">+        f.__code__, f.__globals__, name or f.__name__, f.__defaults__, f.__closure__</span>
<span class="gi">+    )</span>


<span class="gd">-def allclose(x, y, rtol=1e-05, atol=1e-08):</span>
<span class="gi">+def allclose(x, y, rtol=1.0000000000000001e-05, atol=1e-08):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns True if x and y are sufficiently close, elementwise.

<span class="w"> </span>    Parameters
<span class="gu">@@ -26,7 +36,8 @@ def allclose(x, y, rtol=1e-05, atol=1e-08):</span>
<span class="w"> </span>        The absolute error tolerance.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # assume finite weights, see numpy.allclose() for reference</span>
<span class="gi">+    return all(math.isclose(xi, yi, rel_tol=rtol, abs_tol=atol) for xi, yi in zip(x, y))</span>


<span class="w"> </span>categorical_doc = &quot;&quot;&quot;
<span class="gu">@@ -57,14 +68,59 @@ Examples</span>
<span class="w"> </span>&gt;&gt;&gt; nm = iso.categorical_node_match([&quot;color&quot;, &quot;size&quot;], [&quot;red&quot;, 2])

<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-categorical_edge_match = copyfunc(categorical_node_match,</span>
<span class="gd">-    &#39;categorical_edge_match&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def categorical_node_match(attr, default):</span>
<span class="gi">+    if isinstance(attr, str):</span>
<span class="gi">+</span>
<span class="gi">+        def match(data1, data2):</span>
<span class="gi">+            return data1.get(attr, default) == data2.get(attr, default)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        attrs = list(zip(attr, default))  # Python 3</span>
<span class="gi">+</span>
<span class="gi">+        def match(data1, data2):</span>
<span class="gi">+            return all(data1.get(attr, d) == data2.get(attr, d) for attr, d in attrs)</span>
<span class="gi">+</span>
<span class="gi">+    return match</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+categorical_edge_match = copyfunc(categorical_node_match, &quot;categorical_edge_match&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def categorical_multiedge_match(attr, default):</span>
<span class="gi">+    if isinstance(attr, str):</span>
<span class="gi">+</span>
<span class="gi">+        def match(datasets1, datasets2):</span>
<span class="gi">+            values1 = {data.get(attr, default) for data in datasets1.values()}</span>
<span class="gi">+            values2 = {data.get(attr, default) for data in datasets2.values()}</span>
<span class="gi">+            return values1 == values2</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        attrs = list(zip(attr, default))  # Python 3</span>
<span class="gi">+</span>
<span class="gi">+        def match(datasets1, datasets2):</span>
<span class="gi">+            values1 = set()</span>
<span class="gi">+            for data1 in datasets1.values():</span>
<span class="gi">+                x = tuple(data1.get(attr, d) for attr, d in attrs)</span>
<span class="gi">+                values1.add(x)</span>
<span class="gi">+            values2 = set()</span>
<span class="gi">+            for data2 in datasets2.values():</span>
<span class="gi">+                x = tuple(data2.get(attr, d) for attr, d in attrs)</span>
<span class="gi">+                values2.add(x)</span>
<span class="gi">+            return values1 == values2</span>
<span class="gi">+</span>
<span class="gi">+    return match</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Docstrings for categorical functions.</span>
<span class="w"> </span>categorical_node_match.__doc__ = categorical_doc
<span class="gd">-categorical_edge_match.__doc__ = categorical_doc.replace(&#39;node&#39;, &#39;edge&#39;)</span>
<span class="gd">-tmpdoc = categorical_doc.replace(&#39;node&#39;, &#39;edge&#39;)</span>
<span class="gd">-tmpdoc = tmpdoc.replace(&#39;categorical_edge_match&#39;, &#39;categorical_multiedge_match&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+categorical_edge_match.__doc__ = categorical_doc.replace(&quot;node&quot;, &quot;edge&quot;)</span>
<span class="gi">+tmpdoc = categorical_doc.replace(&quot;node&quot;, &quot;edge&quot;)</span>
<span class="gi">+tmpdoc = tmpdoc.replace(&quot;categorical_edge_match&quot;, &quot;categorical_multiedge_match&quot;)</span>
<span class="w"> </span>categorical_multiedge_match.__doc__ = tmpdoc
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>numerical_doc = &quot;&quot;&quot;
<span class="w"> </span>Returns a comparison function for a numerical node attribute.

<span class="gu">@@ -97,12 +153,72 @@ Examples</span>
<span class="w"> </span>&gt;&gt;&gt; nm = iso.numerical_node_match([&quot;weight&quot;, &quot;linewidth&quot;], [0.25, 0.5])

<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-numerical_edge_match = copyfunc(numerical_node_match, &#39;numerical_edge_match&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def numerical_node_match(attr, default, rtol=1.0000000000000001e-05, atol=1e-08):</span>
<span class="gi">+    if isinstance(attr, str):</span>
<span class="gi">+</span>
<span class="gi">+        def match(data1, data2):</span>
<span class="gi">+            return math.isclose(</span>
<span class="gi">+                data1.get(attr, default),</span>
<span class="gi">+                data2.get(attr, default),</span>
<span class="gi">+                rel_tol=rtol,</span>
<span class="gi">+                abs_tol=atol,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        attrs = list(zip(attr, default))  # Python 3</span>
<span class="gi">+</span>
<span class="gi">+        def match(data1, data2):</span>
<span class="gi">+            values1 = [data1.get(attr, d) for attr, d in attrs]</span>
<span class="gi">+            values2 = [data2.get(attr, d) for attr, d in attrs]</span>
<span class="gi">+            return allclose(values1, values2, rtol=rtol, atol=atol)</span>
<span class="gi">+</span>
<span class="gi">+    return match</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+numerical_edge_match = copyfunc(numerical_node_match, &quot;numerical_edge_match&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def numerical_multiedge_match(attr, default, rtol=1.0000000000000001e-05, atol=1e-08):</span>
<span class="gi">+    if isinstance(attr, str):</span>
<span class="gi">+</span>
<span class="gi">+        def match(datasets1, datasets2):</span>
<span class="gi">+            values1 = sorted(data.get(attr, default) for data in datasets1.values())</span>
<span class="gi">+            values2 = sorted(data.get(attr, default) for data in datasets2.values())</span>
<span class="gi">+            return allclose(values1, values2, rtol=rtol, atol=atol)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        attrs = list(zip(attr, default))  # Python 3</span>
<span class="gi">+</span>
<span class="gi">+        def match(datasets1, datasets2):</span>
<span class="gi">+            values1 = []</span>
<span class="gi">+            for data1 in datasets1.values():</span>
<span class="gi">+                x = tuple(data1.get(attr, d) for attr, d in attrs)</span>
<span class="gi">+                values1.append(x)</span>
<span class="gi">+            values2 = []</span>
<span class="gi">+            for data2 in datasets2.values():</span>
<span class="gi">+                x = tuple(data2.get(attr, d) for attr, d in attrs)</span>
<span class="gi">+                values2.append(x)</span>
<span class="gi">+            values1.sort()</span>
<span class="gi">+            values2.sort()</span>
<span class="gi">+            for xi, yi in zip(values1, values2):</span>
<span class="gi">+                if not allclose(xi, yi, rtol=rtol, atol=atol):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+    return match</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Docstrings for numerical functions.</span>
<span class="w"> </span>numerical_node_match.__doc__ = numerical_doc
<span class="gd">-numerical_edge_match.__doc__ = numerical_doc.replace(&#39;node&#39;, &#39;edge&#39;)</span>
<span class="gd">-tmpdoc = numerical_doc.replace(&#39;node&#39;, &#39;edge&#39;)</span>
<span class="gd">-tmpdoc = tmpdoc.replace(&#39;numerical_edge_match&#39;, &#39;numerical_multiedge_match&#39;)</span>
<span class="gi">+numerical_edge_match.__doc__ = numerical_doc.replace(&quot;node&quot;, &quot;edge&quot;)</span>
<span class="gi">+tmpdoc = numerical_doc.replace(&quot;node&quot;, &quot;edge&quot;)</span>
<span class="gi">+tmpdoc = tmpdoc.replace(&quot;numerical_edge_match&quot;, &quot;numerical_multiedge_match&quot;)</span>
<span class="w"> </span>numerical_multiedge_match.__doc__ = tmpdoc
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>generic_doc = &quot;&quot;&quot;
<span class="w"> </span>Returns a comparison function for a generic attribute.

<span class="gu">@@ -137,7 +253,28 @@ Examples</span>
<span class="w"> </span>&gt;&gt;&gt; nm = generic_node_match([&quot;weight&quot;, &quot;color&quot;], [1.0, &quot;red&quot;], [isclose, eq])

<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-generic_edge_match = copyfunc(generic_node_match, &#39;generic_edge_match&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generic_node_match(attr, default, op):</span>
<span class="gi">+    if isinstance(attr, str):</span>
<span class="gi">+</span>
<span class="gi">+        def match(data1, data2):</span>
<span class="gi">+            return op(data1.get(attr, default), data2.get(attr, default))</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        attrs = list(zip(attr, default, op))  # Python 3</span>
<span class="gi">+</span>
<span class="gi">+        def match(data1, data2):</span>
<span class="gi">+            for attr, d, operator in attrs:</span>
<span class="gi">+                if not operator(data1.get(attr, d), data2.get(attr, d)):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+    return match</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+generic_edge_match = copyfunc(generic_node_match, &quot;generic_edge_match&quot;)</span>


<span class="w"> </span>def generic_multiedge_match(attr, default, op):
<span class="gu">@@ -176,8 +313,39 @@ def generic_multiedge_match(attr, default, op):</span>
<span class="w"> </span>    &gt;&gt;&gt; nm = generic_node_match([&quot;weight&quot;, &quot;color&quot;], [1.0, &quot;red&quot;], [isclose, eq])

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gi">+    # This is slow, but generic.</span>
<span class="gi">+    # We must test every possible isomorphism between the edges.</span>
<span class="gi">+    if isinstance(attr, str):</span>
<span class="gi">+        attr = [attr]</span>
<span class="gi">+        default = [default]</span>
<span class="gi">+        op = [op]</span>
<span class="gi">+    attrs = list(zip(attr, default))  # Python 3</span>
<span class="gi">+</span>
<span class="gi">+    def match(datasets1, datasets2):</span>
<span class="gi">+        values1 = []</span>
<span class="gi">+        for data1 in datasets1.values():</span>
<span class="gi">+            x = tuple(data1.get(attr, d) for attr, d in attrs)</span>
<span class="gi">+            values1.append(x)</span>
<span class="gi">+        values2 = []</span>
<span class="gi">+        for data2 in datasets2.values():</span>
<span class="gi">+            x = tuple(data2.get(attr, d) for attr, d in attrs)</span>
<span class="gi">+            values2.append(x)</span>
<span class="gi">+        for vals2 in permutations(values2):</span>
<span class="gi">+            for xi, yi in zip(values1, vals2):</span>
<span class="gi">+                if not all(map(lambda x, y, z: z(x, y), xi, yi, op)):</span>
<span class="gi">+                    # This is not an isomorphism, go to next permutation.</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Then we found an isomorphism.</span>
<span class="gi">+                return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Then there are no isomorphisms between the multiedges.</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    return match</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Docstrings for numerical functions.</span>
<span class="w"> </span>generic_node_match.__doc__ = generic_doc
<span class="gd">-generic_edge_match.__doc__ = generic_doc.replace(&#39;node&#39;, &#39;edge&#39;)</span>
<span class="gi">+generic_edge_match.__doc__ = generic_doc.replace(&quot;node&quot;, &quot;edge&quot;)</span>
<span class="gh">diff --git a/networkx/algorithms/isomorphism/temporalisomorphvf2.py b/networkx/algorithms/isomorphism/temporalisomorphvf2.py</span>
<span class="gh">index b0d999d9e..b78ecf149 100644</span>
<span class="gd">--- a/networkx/algorithms/isomorphism/temporalisomorphvf2.py</span>
<span class="gi">+++ b/networkx/algorithms/isomorphism/temporalisomorphvf2.py</span>
<span class="gu">@@ -64,13 +64,15 @@ Notes</span>
<span class="w"> </span>Handles directed and undirected graphs and graphs with parallel edges.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from .isomorphvf2 import DiGraphMatcher, GraphMatcher
<span class="gd">-__all__ = [&#39;TimeRespectingGraphMatcher&#39;, &#39;TimeRespectingDiGraphMatcher&#39;]</span>

<span class="gi">+__all__ = [&quot;TimeRespectingGraphMatcher&quot;, &quot;TimeRespectingDiGraphMatcher&quot;]</span>

<span class="gd">-class TimeRespectingGraphMatcher(GraphMatcher):</span>

<span class="gi">+class TimeRespectingGraphMatcher(GraphMatcher):</span>
<span class="w"> </span>    def __init__(self, G1, G2, temporal_attribute_name, delta):
<span class="w"> </span>        &quot;&quot;&quot;Initialize TimeRespectingGraphMatcher.

<span class="gu">@@ -98,13 +100,27 @@ class TimeRespectingGraphMatcher(GraphMatcher):</span>
<span class="w"> </span>        Edges one hop out from a node in the mapping should be
<span class="w"> </span>        time-respecting with respect to each other.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dates = []</span>
<span class="gi">+        for n in neighbors:</span>
<span class="gi">+            if isinstance(Gx, nx.Graph):  # Graph G[u][v] returns the data dictionary.</span>
<span class="gi">+                dates.append(Gx[Gx_node][n][self.temporal_attribute_name])</span>
<span class="gi">+            else:  # MultiGraph G[u][v] returns a dictionary of key -&gt; data dictionary.</span>
<span class="gi">+                for edge in Gx[Gx_node][</span>
<span class="gi">+                    n</span>
<span class="gi">+                ].values():  # Iterates all edges between node pair.</span>
<span class="gi">+                    dates.append(edge[self.temporal_attribute_name])</span>
<span class="gi">+        if any(x is None for x in dates):</span>
<span class="gi">+            raise ValueError(&quot;Datetime not supplied for at least one edge.&quot;)</span>
<span class="gi">+        return not dates or max(dates) - min(dates) &lt;= self.delta</span>

<span class="w"> </span>    def two_hop(self, Gx, core_x, Gx_node, neighbors):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Paths of length 2 from Gx_node should be time-respecting.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return all(</span>
<span class="gi">+            self.one_hop(Gx, v, [n for n in Gx[v] if n in core_x] + [Gx_node])</span>
<span class="gi">+            for v in neighbors</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def semantic_feasibility(self, G1_node, G2_node):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if adding (G1_node, G2_node) is semantically
<span class="gu">@@ -114,11 +130,16 @@ class TimeRespectingGraphMatcher(GraphMatcher):</span>
<span class="w"> </span>        maintain the self.tests if needed, to keep the match() method
<span class="w"> </span>        functional. Implementations should consider multigraphs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        neighbors = [n for n in self.G1[G1_node] if n in self.core_1]</span>
<span class="gi">+        if not self.one_hop(self.G1, G1_node, neighbors):  # Fail fast on first node.</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not self.two_hop(self.G1, self.core_1, G1_node, neighbors):</span>
<span class="gi">+            return False</span>
<span class="gi">+        # Otherwise, this node is semantically feasible!</span>
<span class="gi">+        return True</span>


<span class="w"> </span>class TimeRespectingDiGraphMatcher(DiGraphMatcher):
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, G1, G2, temporal_attribute_name, delta):
<span class="w"> </span>        &quot;&quot;&quot;Initialize TimeRespectingDiGraphMatcher.

<span class="gu">@@ -145,31 +166,85 @@ class TimeRespectingDiGraphMatcher(DiGraphMatcher):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the dates of edges from predecessors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pred_dates = []</span>
<span class="gi">+        if isinstance(Gx, nx.DiGraph):  # Graph G[u][v] returns the data dictionary.</span>
<span class="gi">+            for n in pred:</span>
<span class="gi">+                pred_dates.append(Gx[n][Gx_node][self.temporal_attribute_name])</span>
<span class="gi">+        else:  # MultiGraph G[u][v] returns a dictionary of key -&gt; data dictionary.</span>
<span class="gi">+            for n in pred:</span>
<span class="gi">+                for edge in Gx[n][</span>
<span class="gi">+                    Gx_node</span>
<span class="gi">+                ].values():  # Iterates all edge data between node pair.</span>
<span class="gi">+                    pred_dates.append(edge[self.temporal_attribute_name])</span>
<span class="gi">+        return pred_dates</span>

<span class="w"> </span>    def get_succ_dates(self, Gx, Gx_node, core_x, succ):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get the dates of edges to successors.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        succ_dates = []</span>
<span class="gi">+        if isinstance(Gx, nx.DiGraph):  # Graph G[u][v] returns the data dictionary.</span>
<span class="gi">+            for n in succ:</span>
<span class="gi">+                succ_dates.append(Gx[Gx_node][n][self.temporal_attribute_name])</span>
<span class="gi">+        else:  # MultiGraph G[u][v] returns a dictionary of key -&gt; data dictionary.</span>
<span class="gi">+            for n in succ:</span>
<span class="gi">+                for edge in Gx[Gx_node][</span>
<span class="gi">+                    n</span>
<span class="gi">+                ].values():  # Iterates all edge data between node pair.</span>
<span class="gi">+                    succ_dates.append(edge[self.temporal_attribute_name])</span>
<span class="gi">+        return succ_dates</span>

<span class="w"> </span>    def one_hop(self, Gx, Gx_node, core_x, pred, succ):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The ego node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pred_dates = self.get_pred_dates(Gx, Gx_node, core_x, pred)</span>
<span class="gi">+        succ_dates = self.get_succ_dates(Gx, Gx_node, core_x, succ)</span>
<span class="gi">+        return self.test_one(pred_dates, succ_dates) and self.test_two(</span>
<span class="gi">+            pred_dates, succ_dates</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def two_hop_pred(self, Gx, Gx_node, core_x, pred):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The predecessors of the ego node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return all(</span>
<span class="gi">+            self.one_hop(</span>
<span class="gi">+                Gx,</span>
<span class="gi">+                p,</span>
<span class="gi">+                core_x,</span>
<span class="gi">+                self.preds(Gx, core_x, p),</span>
<span class="gi">+                self.succs(Gx, core_x, p, Gx_node),</span>
<span class="gi">+            )</span>
<span class="gi">+            for p in pred</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def two_hop_succ(self, Gx, Gx_node, core_x, succ):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The successors of the ego node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return all(</span>
<span class="gi">+            self.one_hop(</span>
<span class="gi">+                Gx,</span>
<span class="gi">+                s,</span>
<span class="gi">+                core_x,</span>
<span class="gi">+                self.preds(Gx, core_x, s, Gx_node),</span>
<span class="gi">+                self.succs(Gx, core_x, s),</span>
<span class="gi">+            )</span>
<span class="gi">+            for s in succ</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def preds(self, Gx, core_x, v, Gx_node=None):</span>
<span class="gi">+        pred = [n for n in Gx.predecessors(v) if n in core_x]</span>
<span class="gi">+        if Gx_node:</span>
<span class="gi">+            pred.append(Gx_node)</span>
<span class="gi">+        return pred</span>
<span class="gi">+</span>
<span class="gi">+    def succs(self, Gx, core_x, v, Gx_node=None):</span>
<span class="gi">+        succ = [n for n in Gx.successors(v) if n in core_x]</span>
<span class="gi">+        if Gx_node:</span>
<span class="gi">+            succ.append(Gx_node)</span>
<span class="gi">+        return succ</span>

<span class="w"> </span>    def test_one(self, pred_dates, succ_dates):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -177,14 +252,33 @@ class TimeRespectingDiGraphMatcher(DiGraphMatcher):</span>
<span class="w"> </span>        time-respecting with respect to each other, regardless of
<span class="w"> </span>        direction.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        time_respecting = True</span>
<span class="gi">+        dates = pred_dates + succ_dates</span>
<span class="gi">+</span>
<span class="gi">+        if any(x is None for x in dates):</span>
<span class="gi">+            raise ValueError(&quot;Date or datetime not supplied for at least one edge.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        dates.sort()  # Small to large.</span>
<span class="gi">+        if 0 &lt; len(dates) and not (dates[-1] - dates[0] &lt;= self.delta):</span>
<span class="gi">+            time_respecting = False</span>
<span class="gi">+        return time_respecting</span>

<span class="w"> </span>    def test_two(self, pred_dates, succ_dates):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Edges from a dual Gx_node in the mapping should be ordered in
<span class="w"> </span>        a time-respecting manner.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        time_respecting = True</span>
<span class="gi">+        pred_dates.sort()</span>
<span class="gi">+        succ_dates.sort()</span>
<span class="gi">+        # First out before last in; negative of the necessary condition for time-respect.</span>
<span class="gi">+        if (</span>
<span class="gi">+            0 &lt; len(succ_dates)</span>
<span class="gi">+            and 0 &lt; len(pred_dates)</span>
<span class="gi">+            and succ_dates[0] &lt; pred_dates[-1]</span>
<span class="gi">+        ):</span>
<span class="gi">+            time_respecting = False</span>
<span class="gi">+        return time_respecting</span>

<span class="w"> </span>    def semantic_feasibility(self, G1_node, G2_node):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if adding (G1_node, G2_node) is semantically
<span class="gu">@@ -194,4 +288,17 @@ class TimeRespectingDiGraphMatcher(DiGraphMatcher):</span>
<span class="w"> </span>        maintain the self.tests if needed, to keep the match() method
<span class="w"> </span>        functional. Implementations should consider multigraphs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        pred, succ = (</span>
<span class="gi">+            [n for n in self.G1.predecessors(G1_node) if n in self.core_1],</span>
<span class="gi">+            [n for n in self.G1.successors(G1_node) if n in self.core_1],</span>
<span class="gi">+        )</span>
<span class="gi">+        if not self.one_hop(</span>
<span class="gi">+            self.G1, G1_node, self.core_1, pred, succ</span>
<span class="gi">+        ):  # Fail fast on first node.</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not self.two_hop_pred(self.G1, G1_node, self.core_1, pred):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not self.two_hop_succ(self.G1, G1_node, self.core_1, succ):</span>
<span class="gi">+            return False</span>
<span class="gi">+        # Otherwise, this node is semantically feasible!</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/networkx/algorithms/isomorphism/tree_isomorphism.py b/networkx/algorithms/isomorphism/tree_isomorphism.py</span>
<span class="gh">index e4c940843..e409d515f 100644</span>
<span class="gd">--- a/networkx/algorithms/isomorphism/tree_isomorphism.py</span>
<span class="gi">+++ b/networkx/algorithms/isomorphism/tree_isomorphism.py</span>
<span class="gu">@@ -17,12 +17,14 @@ McGill University SOCS 308-250B, Winter 2002</span>
<span class="w"> </span>by Matthew Suderman
<span class="w"> </span>http://crypto.cs.mcgill.ca/~crepeau/CS250/2004/HW5+.pdf
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;rooted_tree_isomorphism&#39;, &#39;tree_isomorphism&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;rooted_tree_isomorphism&quot;, &quot;tree_isomorphism&quot;]</span>


<span class="gd">-@nx._dispatchable(graphs={&#39;t1&#39;: 0, &#39;t2&#39;: 2}, returns_graph=True)</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;t1&quot;: 0, &quot;t2&quot;: 2}, returns_graph=True)</span>
<span class="w"> </span>def root_trees(t1, root1, t2, root2):
<span class="w"> </span>    &quot;&quot;&quot;Create a single digraph dT of free trees t1 and t2
<span class="w"> </span>    #   with roots root1 and root2 respectively
<span class="gu">@@ -33,10 +35,74 @@ def root_trees(t1, root1, t2, root2):</span>
<span class="w"> </span>    # t1 is numbers from 1 ... n
<span class="w"> </span>    # t2 is numbered from n+1 to 2n
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    dT = nx.DiGraph()</span>
<span class="gi">+</span>
<span class="gi">+    newroot1 = 1  # left root will be 1</span>
<span class="gi">+    newroot2 = nx.number_of_nodes(t1) + 1  # right will be n+1</span>
<span class="gi">+</span>
<span class="gi">+    # may be overlap in node names here so need separate maps</span>
<span class="gi">+    # given the old name, what is the new</span>
<span class="gi">+    namemap1 = {root1: newroot1}</span>
<span class="gi">+    namemap2 = {root2: newroot2}</span>
<span class="gi">+</span>
<span class="gi">+    # add an edge from our new root to root1 and root2</span>
<span class="gi">+    dT.add_edge(0, namemap1[root1])</span>
<span class="gi">+    dT.add_edge(0, namemap2[root2])</span>
<span class="gi">+</span>
<span class="gi">+    for i, (v1, v2) in enumerate(nx.bfs_edges(t1, root1)):</span>
<span class="gi">+        namemap1[v2] = i + namemap1[root1] + 1</span>
<span class="gi">+        dT.add_edge(namemap1[v1], namemap1[v2])</span>
<span class="gi">+</span>
<span class="gi">+    for i, (v1, v2) in enumerate(nx.bfs_edges(t2, root2)):</span>
<span class="gi">+        namemap2[v2] = i + namemap2[root2] + 1</span>
<span class="gi">+        dT.add_edge(namemap2[v1], namemap2[v2])</span>
<span class="gi">+</span>
<span class="gi">+    # now we really want the inverse of namemap1 and namemap2</span>
<span class="gi">+    # giving the old name given the new</span>
<span class="gi">+    # since the values of namemap1 and namemap2 are unique</span>
<span class="gi">+    # there won&#39;t be collisions</span>
<span class="gi">+    namemap = {}</span>
<span class="gi">+    for old, new in namemap1.items():</span>
<span class="gi">+        namemap[new] = old</span>
<span class="gi">+    for old, new in namemap2.items():</span>
<span class="gi">+        namemap[new] = old</span>
<span class="gi">+</span>
<span class="gi">+    return (dT, namemap, newroot1, newroot2)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# figure out the level of each node, with 0 at root</span>
<span class="gi">+@nx._dispatchable</span>
<span class="gi">+def assign_levels(G, root):</span>
<span class="gi">+    level = {}</span>
<span class="gi">+    level[root] = 0</span>
<span class="gi">+    for v1, v2 in nx.bfs_edges(G, root):</span>
<span class="gi">+        level[v2] = level[v1] + 1</span>

<span class="gd">-@nx._dispatchable(graphs={&#39;t1&#39;: 0, &#39;t2&#39;: 2})</span>
<span class="gi">+    return level</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# now group the nodes at each level</span>
<span class="gi">+def group_by_levels(levels):</span>
<span class="gi">+    L = {}</span>
<span class="gi">+    for n, lev in levels.items():</span>
<span class="gi">+        if lev not in L:</span>
<span class="gi">+            L[lev] = []</span>
<span class="gi">+        L[lev].append(n)</span>
<span class="gi">+</span>
<span class="gi">+    return L</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# now lets get the isomorphism by walking the ordered_children</span>
<span class="gi">+def generate_isomorphism(v, w, M, ordered_children):</span>
<span class="gi">+    # make sure tree1 comes first</span>
<span class="gi">+    assert v &lt; w</span>
<span class="gi">+    M.append((v, w))</span>
<span class="gi">+    for i, (x, y) in enumerate(zip(ordered_children[v], ordered_children[w])):</span>
<span class="gi">+        generate_isomorphism(x, y, M, ordered_children)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;t1&quot;: 0, &quot;t2&quot;: 2})</span>
<span class="w"> </span>def rooted_tree_isomorphism(t1, root1, t2, root2):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Given two rooted trees `t1` and `t2`,
<span class="gu">@@ -78,12 +144,74 @@ def rooted_tree_isomorphism(t1, root1, t2, root2):</span>

<span class="w"> </span>        If `t1` and `t2` are not isomorphic, then it returns the empty list.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    assert nx.is_tree(t1)</span>
<span class="gi">+    assert nx.is_tree(t2)</span>
<span class="gi">+</span>
<span class="gi">+    # get the rooted tree formed by combining them</span>
<span class="gi">+    # with unique names</span>
<span class="gi">+    (dT, namemap, newroot1, newroot2) = root_trees(t1, root1, t2, root2)</span>
<span class="gi">+</span>
<span class="gi">+    # compute the distance from the root, with 0 for our</span>
<span class="gi">+    levels = assign_levels(dT, 0)</span>
<span class="gi">+</span>
<span class="gi">+    # height</span>
<span class="gi">+    h = max(levels.values())</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(graphs={&#39;t1&#39;: 0, &#39;t2&#39;: 1})</span>
<span class="gi">+    # collect nodes into a dict by level</span>
<span class="gi">+    L = group_by_levels(levels)</span>
<span class="gi">+</span>
<span class="gi">+    # each node has a label, initially set to 0</span>
<span class="gi">+    label = {v: 0 for v in dT}</span>
<span class="gi">+    # and also ordered_labels and ordered_children</span>
<span class="gi">+    # which will store ordered tuples</span>
<span class="gi">+    ordered_labels = {v: () for v in dT}</span>
<span class="gi">+    ordered_children = {v: () for v in dT}</span>
<span class="gi">+</span>
<span class="gi">+    # nothing to do on last level so start on h-1</span>
<span class="gi">+    # also nothing to do for our fake level 0, so skip that</span>
<span class="gi">+    for i in range(h - 1, 0, -1):</span>
<span class="gi">+        # update the ordered_labels and ordered_children</span>
<span class="gi">+        # for any children</span>
<span class="gi">+        for v in L[i]:</span>
<span class="gi">+            # nothing to do if no children</span>
<span class="gi">+            if dT.out_degree(v) &gt; 0:</span>
<span class="gi">+                # get all the pairs of labels and nodes of children</span>
<span class="gi">+                # and sort by labels</span>
<span class="gi">+                s = sorted((label[u], u) for u in dT.successors(v))</span>
<span class="gi">+</span>
<span class="gi">+                # invert to give a list of two tuples</span>
<span class="gi">+                # the sorted labels, and the corresponding children</span>
<span class="gi">+                ordered_labels[v], ordered_children[v] = list(zip(*s))</span>
<span class="gi">+</span>
<span class="gi">+        # now collect and sort the sorted ordered_labels</span>
<span class="gi">+        # for all nodes in L[i], carrying along the node</span>
<span class="gi">+        forlabel = sorted((ordered_labels[v], v) for v in L[i])</span>
<span class="gi">+</span>
<span class="gi">+        # now assign labels to these nodes, according to the sorted order</span>
<span class="gi">+        # starting from 0, where identical ordered_labels get the same label</span>
<span class="gi">+        current = 0</span>
<span class="gi">+        for i, (ol, v) in enumerate(forlabel):</span>
<span class="gi">+            # advance to next label if not 0, and different from previous</span>
<span class="gi">+            if (i != 0) and (ol != forlabel[i - 1][0]):</span>
<span class="gi">+                current += 1</span>
<span class="gi">+            label[v] = current</span>
<span class="gi">+</span>
<span class="gi">+    # they are isomorphic if the labels of newroot1 and newroot2 are 0</span>
<span class="gi">+    isomorphism = []</span>
<span class="gi">+    if label[newroot1] == 0 and label[newroot2] == 0:</span>
<span class="gi">+        generate_isomorphism(newroot1, newroot2, isomorphism, ordered_children)</span>
<span class="gi">+</span>
<span class="gi">+        # get the mapping back in terms of the old names</span>
<span class="gi">+        # return in sorted order for neatness</span>
<span class="gi">+        isomorphism = [(namemap[u], namemap[v]) for (u, v) in isomorphism]</span>
<span class="gi">+</span>
<span class="gi">+    return isomorphism</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;t1&quot;: 0, &quot;t2&quot;: 1})</span>
<span class="w"> </span>def tree_isomorphism(t1, t2):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Given two undirected (or free) trees `t1` and `t2`,
<span class="gu">@@ -117,4 +245,40 @@ def tree_isomorphism(t1, t2):</span>
<span class="w"> </span>    -----
<span class="w"> </span>    This runs in O(n*log(n)) time for trees with n nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    assert nx.is_tree(t1)</span>
<span class="gi">+    assert nx.is_tree(t2)</span>
<span class="gi">+</span>
<span class="gi">+    # To be isomorphic, t1 and t2 must have the same number of nodes.</span>
<span class="gi">+    if nx.number_of_nodes(t1) != nx.number_of_nodes(t2):</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    # Another shortcut is that the sorted degree sequences need to be the same.</span>
<span class="gi">+    degree_sequence1 = sorted(d for (n, d) in t1.degree())</span>
<span class="gi">+    degree_sequence2 = sorted(d for (n, d) in t2.degree())</span>
<span class="gi">+</span>
<span class="gi">+    if degree_sequence1 != degree_sequence2:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    # A tree can have either 1 or 2 centers.</span>
<span class="gi">+    # If the number doesn&#39;t match then t1 and t2 are not isomorphic.</span>
<span class="gi">+    center1 = nx.center(t1)</span>
<span class="gi">+    center2 = nx.center(t2)</span>
<span class="gi">+</span>
<span class="gi">+    if len(center1) != len(center2):</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    # If there is only 1 center in each, then use it.</span>
<span class="gi">+    if len(center1) == 1:</span>
<span class="gi">+        return rooted_tree_isomorphism(t1, center1[0], t2, center2[0])</span>
<span class="gi">+</span>
<span class="gi">+    # If there both have 2 centers,  then try the first for t1</span>
<span class="gi">+    # with the first for t2.</span>
<span class="gi">+    attempts = rooted_tree_isomorphism(t1, center1[0], t2, center2[0])</span>
<span class="gi">+</span>
<span class="gi">+    # If that worked we&#39;re done.</span>
<span class="gi">+    if len(attempts) &gt; 0:</span>
<span class="gi">+        return attempts</span>
<span class="gi">+</span>
<span class="gi">+    # Otherwise, try center1[0] with the center2[1], and see if that works</span>
<span class="gi">+    return rooted_tree_isomorphism(t1, center1[0], t2, center2[1])</span>
<span class="gh">diff --git a/networkx/algorithms/isomorphism/vf2pp.py b/networkx/algorithms/isomorphism/vf2pp.py</span>
<span class="gh">index 13e668d89..589e06447 100644</span>
<span class="gd">--- a/networkx/algorithms/isomorphism/vf2pp.py</span>
<span class="gi">+++ b/networkx/algorithms/isomorphism/vf2pp.py</span>
<span class="gu">@@ -62,19 +62,42 @@ References</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import collections
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;vf2pp_isomorphism&#39;, &#39;vf2pp_is_isomorphic&#39;, &#39;vf2pp_all_isomorphisms&#39;</span>
<span class="gd">-    ]</span>
<span class="gd">-_GraphParameters = collections.namedtuple(&#39;_GraphParameters&#39;, [&#39;G1&#39;, &#39;G2&#39;,</span>
<span class="gd">-    &#39;G1_labels&#39;, &#39;G2_labels&#39;, &#39;nodes_of_G1Labels&#39;, &#39;nodes_of_G2Labels&#39;,</span>
<span class="gd">-    &#39;G2_nodes_of_degree&#39;])</span>
<span class="gd">-_StateParameters = collections.namedtuple(&#39;_StateParameters&#39;, [&#39;mapping&#39;,</span>
<span class="gd">-    &#39;reverse_mapping&#39;, &#39;T1&#39;, &#39;T1_in&#39;, &#39;T1_tilde&#39;, &#39;T1_tilde_in&#39;, &#39;T2&#39;,</span>
<span class="gd">-    &#39;T2_in&#39;, &#39;T2_tilde&#39;, &#39;T2_tilde_in&#39;])</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1}, node_attrs={&#39;node_label&#39;:</span>
<span class="gd">-    &#39;default_label&#39;})</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;vf2pp_isomorphism&quot;, &quot;vf2pp_is_isomorphic&quot;, &quot;vf2pp_all_isomorphisms&quot;]</span>
<span class="gi">+</span>
<span class="gi">+_GraphParameters = collections.namedtuple(</span>
<span class="gi">+    &quot;_GraphParameters&quot;,</span>
<span class="gi">+    [</span>
<span class="gi">+        &quot;G1&quot;,</span>
<span class="gi">+        &quot;G2&quot;,</span>
<span class="gi">+        &quot;G1_labels&quot;,</span>
<span class="gi">+        &quot;G2_labels&quot;,</span>
<span class="gi">+        &quot;nodes_of_G1Labels&quot;,</span>
<span class="gi">+        &quot;nodes_of_G2Labels&quot;,</span>
<span class="gi">+        &quot;G2_nodes_of_degree&quot;,</span>
<span class="gi">+    ],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+_StateParameters = collections.namedtuple(</span>
<span class="gi">+    &quot;_StateParameters&quot;,</span>
<span class="gi">+    [</span>
<span class="gi">+        &quot;mapping&quot;,</span>
<span class="gi">+        &quot;reverse_mapping&quot;,</span>
<span class="gi">+        &quot;T1&quot;,</span>
<span class="gi">+        &quot;T1_in&quot;,</span>
<span class="gi">+        &quot;T1_tilde&quot;,</span>
<span class="gi">+        &quot;T1_tilde_in&quot;,</span>
<span class="gi">+        &quot;T2&quot;,</span>
<span class="gi">+        &quot;T2_in&quot;,</span>
<span class="gi">+        &quot;T2_tilde&quot;,</span>
<span class="gi">+        &quot;T2_tilde_in&quot;,</span>
<span class="gi">+    ],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1}, node_attrs={&quot;node_label&quot;: &quot;default_label&quot;})</span>
<span class="w"> </span>def vf2pp_isomorphism(G1, G2, node_label=None, default_label=None):
<span class="w"> </span>    &quot;&quot;&quot;Return an isomorphic mapping between `G1` and `G2` if it exists.

<span class="gu">@@ -98,11 +121,14 @@ def vf2pp_isomorphism(G1, G2, node_label=None, default_label=None):</span>
<span class="w"> </span>    dict or None
<span class="w"> </span>        Node mapping if the two graphs are isomorphic. None otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        mapping = next(vf2pp_all_isomorphisms(G1, G2, node_label, default_label))</span>
<span class="gi">+        return mapping</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return None</span>


<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1}, node_attrs={&#39;node_label&#39;:</span>
<span class="gd">-    &#39;default_label&#39;})</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1}, node_attrs={&quot;node_label&quot;: &quot;default_label&quot;})</span>
<span class="w"> </span>def vf2pp_is_isomorphic(G1, G2, node_label=None, default_label=None):
<span class="w"> </span>    &quot;&quot;&quot;Examines whether G1 and G2 are isomorphic.

<span class="gu">@@ -126,11 +152,12 @@ def vf2pp_is_isomorphic(G1, G2, node_label=None, default_label=None):</span>
<span class="w"> </span>    bool
<span class="w"> </span>        True if the two graphs are isomorphic, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if vf2pp_isomorphism(G1, G2, node_label, default_label) is not None:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>


<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1}, node_attrs={&#39;node_label&#39;:</span>
<span class="gd">-    &#39;default_label&#39;})</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1}, node_attrs={&quot;node_label&quot;: &quot;default_label&quot;})</span>
<span class="w"> </span>def vf2pp_all_isomorphisms(G1, G2, node_label=None, default_label=None):
<span class="w"> </span>    &quot;&quot;&quot;Yields all the possible mappings between G1 and G2.

<span class="gu">@@ -154,11 +181,112 @@ def vf2pp_all_isomorphisms(G1, G2, node_label=None, default_label=None):</span>
<span class="w"> </span>    dict
<span class="w"> </span>        Isomorphic mapping between the nodes in `G1` and `G2`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G1.number_of_nodes() == 0 or G2.number_of_nodes() == 0:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Create the degree dicts based on graph type</span>
<span class="gi">+    if G1.is_directed():</span>
<span class="gi">+        G1_degree = {</span>
<span class="gi">+            n: (in_degree, out_degree)</span>
<span class="gi">+            for (n, in_degree), (_, out_degree) in zip(G1.in_degree, G1.out_degree)</span>
<span class="gi">+        }</span>
<span class="gi">+        G2_degree = {</span>
<span class="gi">+            n: (in_degree, out_degree)</span>
<span class="gi">+            for (n, in_degree), (_, out_degree) in zip(G2.in_degree, G2.out_degree)</span>
<span class="gi">+        }</span>
<span class="gi">+    else:</span>
<span class="gi">+        G1_degree = dict(G1.degree)</span>
<span class="gi">+        G2_degree = dict(G2.degree)</span>
<span class="gi">+</span>
<span class="gi">+    if not G1.is_directed():</span>
<span class="gi">+        find_candidates = _find_candidates</span>
<span class="gi">+        restore_Tinout = _restore_Tinout</span>
<span class="gi">+    else:</span>
<span class="gi">+        find_candidates = _find_candidates_Di</span>
<span class="gi">+        restore_Tinout = _restore_Tinout_Di</span>
<span class="gi">+</span>
<span class="gi">+    # Check that both graphs have the same number of nodes and degree sequence</span>
<span class="gi">+    if G1.order() != G2.order():</span>
<span class="gi">+        return False</span>
<span class="gi">+    if sorted(G1_degree.values()) != sorted(G2_degree.values()):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize parameters and cache necessary information about degree and labels</span>
<span class="gi">+    graph_params, state_params = _initialize_parameters(</span>
<span class="gi">+        G1, G2, G2_degree, node_label, default_label</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Check if G1 and G2 have the same labels, and that number of nodes per label is equal between the two graphs</span>
<span class="gi">+    if not _precheck_label_properties(graph_params):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate the optimal node ordering</span>
<span class="gi">+    node_order = _matching_order(graph_params)</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize the stack</span>
<span class="gi">+    stack = []</span>
<span class="gi">+    candidates = iter(</span>
<span class="gi">+        find_candidates(node_order[0], graph_params, state_params, G1_degree)</span>
<span class="gi">+    )</span>
<span class="gi">+    stack.append((node_order[0], candidates))</span>
<span class="gi">+</span>
<span class="gi">+    mapping = state_params.mapping</span>
<span class="gi">+    reverse_mapping = state_params.reverse_mapping</span>
<span class="gi">+</span>
<span class="gi">+    # Index of the node from the order, currently being examined</span>
<span class="gi">+    matching_node = 1</span>
<span class="gi">+</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        current_node, candidate_nodes = stack[-1]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            candidate = next(candidate_nodes)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            # If no remaining candidates, return to a previous state, and follow another branch</span>
<span class="gi">+            stack.pop()</span>
<span class="gi">+            matching_node -= 1</span>
<span class="gi">+            if stack:</span>
<span class="gi">+                # Pop the previously added u-v pair, and look for a different candidate _v for u</span>
<span class="gi">+                popped_node1, _ = stack[-1]</span>
<span class="gi">+                popped_node2 = mapping[popped_node1]</span>
<span class="gi">+                mapping.pop(popped_node1)</span>
<span class="gi">+                reverse_mapping.pop(popped_node2)</span>
<span class="gi">+                restore_Tinout(popped_node1, popped_node2, graph_params, state_params)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if _feasibility(current_node, candidate, graph_params, state_params):</span>
<span class="gi">+            # Terminate if mapping is extended to its full</span>
<span class="gi">+            if len(mapping) == G2.number_of_nodes() - 1:</span>
<span class="gi">+                cp_mapping = mapping.copy()</span>
<span class="gi">+                cp_mapping[current_node] = candidate</span>
<span class="gi">+                yield cp_mapping</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Feasibility rules pass, so extend the mapping and update the parameters</span>
<span class="gi">+            mapping[current_node] = candidate</span>
<span class="gi">+            reverse_mapping[candidate] = current_node</span>
<span class="gi">+            _update_Tinout(current_node, candidate, graph_params, state_params)</span>
<span class="gi">+            # Append the next node and its candidates to the stack</span>
<span class="gi">+            candidates = iter(</span>
<span class="gi">+                find_candidates(</span>
<span class="gi">+                    node_order[matching_node], graph_params, state_params, G1_degree</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            stack.append((node_order[matching_node], candidates))</span>
<span class="gi">+            matching_node += 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _precheck_label_properties(graph_params):</span>
<span class="gi">+    G1, G2, G1_labels, G2_labels, nodes_of_G1Labels, nodes_of_G2Labels, _ = graph_params</span>
<span class="gi">+    if any(</span>
<span class="gi">+        label not in nodes_of_G1Labels or len(nodes_of_G1Labels[label]) != len(nodes)</span>
<span class="gi">+        for label, nodes in nodes_of_G2Labels.items()</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="gd">-def _initialize_parameters(G1, G2, G2_degree, node_label=None, default_label=-1</span>
<span class="gd">-    ):</span>
<span class="gi">+def _initialize_parameters(G1, G2, G2_degree, node_label=None, default_label=-1):</span>
<span class="w"> </span>    &quot;&quot;&quot;Initializes all the necessary parameters for VF2++

<span class="w"> </span>    Parameters
<span class="gu">@@ -193,7 +321,45 @@ def _initialize_parameters(G1, G2, G2_degree, node_label=None, default_label=-1</span>
<span class="w"> </span>        T1_out, T2_out: set
<span class="w"> </span>            Ti_out contains all the nodes from Gi, that are neither in the mapping nor in Ti
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G1_labels = dict(G1.nodes(data=node_label, default=default_label))</span>
<span class="gi">+    G2_labels = dict(G2.nodes(data=node_label, default=default_label))</span>
<span class="gi">+</span>
<span class="gi">+    graph_params = _GraphParameters(</span>
<span class="gi">+        G1,</span>
<span class="gi">+        G2,</span>
<span class="gi">+        G1_labels,</span>
<span class="gi">+        G2_labels,</span>
<span class="gi">+        nx.utils.groups(G1_labels),</span>
<span class="gi">+        nx.utils.groups(G2_labels),</span>
<span class="gi">+        nx.utils.groups(G2_degree),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    T1, T1_in = set(), set()</span>
<span class="gi">+    T2, T2_in = set(), set()</span>
<span class="gi">+    if G1.is_directed():</span>
<span class="gi">+        T1_tilde, T1_tilde_in = (</span>
<span class="gi">+            set(G1.nodes()),</span>
<span class="gi">+            set(),</span>
<span class="gi">+        )  # todo: do we need Ti_tilde_in? What nodes does it have?</span>
<span class="gi">+        T2_tilde, T2_tilde_in = set(G2.nodes()), set()</span>
<span class="gi">+    else:</span>
<span class="gi">+        T1_tilde, T1_tilde_in = set(G1.nodes()), set()</span>
<span class="gi">+        T2_tilde, T2_tilde_in = set(G2.nodes()), set()</span>
<span class="gi">+</span>
<span class="gi">+    state_params = _StateParameters(</span>
<span class="gi">+        {},</span>
<span class="gi">+        {},</span>
<span class="gi">+        T1,</span>
<span class="gi">+        T1_in,</span>
<span class="gi">+        T1_tilde,</span>
<span class="gi">+        T1_tilde_in,</span>
<span class="gi">+        T2,</span>
<span class="gi">+        T2_in,</span>
<span class="gi">+        T2_tilde,</span>
<span class="gi">+        T2_tilde_in,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return graph_params, state_params</span>


<span class="w"> </span>def _matching_order(graph_params):
<span class="gu">@@ -222,10 +388,54 @@ def _matching_order(graph_params):</span>
<span class="w"> </span>    node_order: list
<span class="w"> </span>        The ordering of the nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _find_candidates(u, graph_params, state_params, G1_degree):</span>
<span class="gi">+    G1, G2, G1_labels, _, _, nodes_of_G2Labels, _ = graph_params</span>
<span class="gi">+    if not G1 and not G2:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    if G1.is_directed():</span>
<span class="gi">+        G1 = G1.to_undirected(as_view=True)</span>
<span class="gi">+</span>
<span class="gi">+    V1_unordered = set(G1.nodes())</span>
<span class="gi">+    label_rarity = {label: len(nodes) for label, nodes in nodes_of_G2Labels.items()}</span>
<span class="gi">+    used_degrees = {node: 0 for node in G1}</span>
<span class="gi">+    node_order = []</span>
<span class="gi">+</span>
<span class="gi">+    while V1_unordered:</span>
<span class="gi">+        max_rarity = min(label_rarity[G1_labels[x]] for x in V1_unordered)</span>
<span class="gi">+        rarest_nodes = [</span>
<span class="gi">+            n for n in V1_unordered if label_rarity[G1_labels[n]] == max_rarity</span>
<span class="gi">+        ]</span>
<span class="gi">+        max_node = max(rarest_nodes, key=G1.degree)</span>
<span class="gi">+</span>
<span class="gi">+        for dlevel_nodes in nx.bfs_layers(G1, max_node):</span>
<span class="gi">+            nodes_to_add = dlevel_nodes.copy()</span>
<span class="gi">+            while nodes_to_add:</span>
<span class="gi">+                max_used_degree = max(used_degrees[n] for n in nodes_to_add)</span>
<span class="gi">+                max_used_degree_nodes = [</span>
<span class="gi">+                    n for n in nodes_to_add if used_degrees[n] == max_used_degree</span>
<span class="gi">+                ]</span>
<span class="gi">+                max_degree = max(G1.degree[n] for n in max_used_degree_nodes)</span>
<span class="gi">+                max_degree_nodes = [</span>
<span class="gi">+                    n for n in max_used_degree_nodes if G1.degree[n] == max_degree</span>
<span class="gi">+                ]</span>
<span class="gi">+                next_node = min(</span>
<span class="gi">+                    max_degree_nodes, key=lambda x: label_rarity[G1_labels[x]]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                node_order.append(next_node)</span>
<span class="gi">+                for node in G1.neighbors(next_node):</span>
<span class="gi">+                    used_degrees[node] += 1</span>
<span class="gi">+</span>
<span class="gi">+                nodes_to_add.remove(next_node)</span>
<span class="gi">+                label_rarity[G1_labels[next_node]] -= 1</span>
<span class="gi">+                V1_unordered.discard(next_node)</span>
<span class="gi">+</span>
<span class="gi">+    return node_order</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_candidates(</span>
<span class="gi">+    u, graph_params, state_params, G1_degree</span>
<span class="gi">+):  # todo: make the 4th argument the degree of u</span>
<span class="w"> </span>    &quot;&quot;&quot;Given node u of G1, finds the candidates of u from G2.

<span class="w"> </span>    Parameters
<span class="gu">@@ -263,7 +473,92 @@ def _find_candidates(u, graph_params, state_params, G1_degree):</span>
<span class="w"> </span>    candidates: set
<span class="w"> </span>        The nodes from G2 which are candidates for u.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G1, G2, G1_labels, _, _, nodes_of_G2Labels, G2_nodes_of_degree = graph_params</span>
<span class="gi">+    mapping, reverse_mapping, _, _, _, _, _, _, T2_tilde, _ = state_params</span>
<span class="gi">+</span>
<span class="gi">+    covered_nbrs = [nbr for nbr in G1[u] if nbr in mapping]</span>
<span class="gi">+    if not covered_nbrs:</span>
<span class="gi">+        candidates = set(nodes_of_G2Labels[G1_labels[u]])</span>
<span class="gi">+        candidates.intersection_update(G2_nodes_of_degree[G1_degree[u]])</span>
<span class="gi">+        candidates.intersection_update(T2_tilde)</span>
<span class="gi">+        candidates.difference_update(reverse_mapping)</span>
<span class="gi">+        if G1.is_multigraph():</span>
<span class="gi">+            candidates.difference_update(</span>
<span class="gi">+                {</span>
<span class="gi">+                    node</span>
<span class="gi">+                    for node in candidates</span>
<span class="gi">+                    if G1.number_of_edges(u, u) != G2.number_of_edges(node, node)</span>
<span class="gi">+                }</span>
<span class="gi">+            )</span>
<span class="gi">+        return candidates</span>
<span class="gi">+</span>
<span class="gi">+    nbr1 = covered_nbrs[0]</span>
<span class="gi">+    common_nodes = set(G2[mapping[nbr1]])</span>
<span class="gi">+</span>
<span class="gi">+    for nbr1 in covered_nbrs[1:]:</span>
<span class="gi">+        common_nodes.intersection_update(G2[mapping[nbr1]])</span>
<span class="gi">+</span>
<span class="gi">+    common_nodes.difference_update(reverse_mapping)</span>
<span class="gi">+    common_nodes.intersection_update(G2_nodes_of_degree[G1_degree[u]])</span>
<span class="gi">+    common_nodes.intersection_update(nodes_of_G2Labels[G1_labels[u]])</span>
<span class="gi">+    if G1.is_multigraph():</span>
<span class="gi">+        common_nodes.difference_update(</span>
<span class="gi">+            {</span>
<span class="gi">+                node</span>
<span class="gi">+                for node in common_nodes</span>
<span class="gi">+                if G1.number_of_edges(u, u) != G2.number_of_edges(node, node)</span>
<span class="gi">+            }</span>
<span class="gi">+        )</span>
<span class="gi">+    return common_nodes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_candidates_Di(u, graph_params, state_params, G1_degree):</span>
<span class="gi">+    G1, G2, G1_labels, _, _, nodes_of_G2Labels, G2_nodes_of_degree = graph_params</span>
<span class="gi">+    mapping, reverse_mapping, _, _, _, _, _, _, T2_tilde, _ = state_params</span>
<span class="gi">+</span>
<span class="gi">+    covered_successors = [succ for succ in G1[u] if succ in mapping]</span>
<span class="gi">+    covered_predecessors = [pred for pred in G1.pred[u] if pred in mapping]</span>
<span class="gi">+</span>
<span class="gi">+    if not (covered_successors or covered_predecessors):</span>
<span class="gi">+        candidates = set(nodes_of_G2Labels[G1_labels[u]])</span>
<span class="gi">+        candidates.intersection_update(G2_nodes_of_degree[G1_degree[u]])</span>
<span class="gi">+        candidates.intersection_update(T2_tilde)</span>
<span class="gi">+        candidates.difference_update(reverse_mapping)</span>
<span class="gi">+        if G1.is_multigraph():</span>
<span class="gi">+            candidates.difference_update(</span>
<span class="gi">+                {</span>
<span class="gi">+                    node</span>
<span class="gi">+                    for node in candidates</span>
<span class="gi">+                    if G1.number_of_edges(u, u) != G2.number_of_edges(node, node)</span>
<span class="gi">+                }</span>
<span class="gi">+            )</span>
<span class="gi">+        return candidates</span>
<span class="gi">+</span>
<span class="gi">+    if covered_successors:</span>
<span class="gi">+        succ1 = covered_successors[0]</span>
<span class="gi">+        common_nodes = set(G2.pred[mapping[succ1]])</span>
<span class="gi">+</span>
<span class="gi">+        for succ1 in covered_successors[1:]:</span>
<span class="gi">+            common_nodes.intersection_update(G2.pred[mapping[succ1]])</span>
<span class="gi">+    else:</span>
<span class="gi">+        pred1 = covered_predecessors.pop()</span>
<span class="gi">+        common_nodes = set(G2[mapping[pred1]])</span>
<span class="gi">+</span>
<span class="gi">+    for pred1 in covered_predecessors:</span>
<span class="gi">+        common_nodes.intersection_update(G2[mapping[pred1]])</span>
<span class="gi">+</span>
<span class="gi">+    common_nodes.difference_update(reverse_mapping)</span>
<span class="gi">+    common_nodes.intersection_update(G2_nodes_of_degree[G1_degree[u]])</span>
<span class="gi">+    common_nodes.intersection_update(nodes_of_G2Labels[G1_labels[u]])</span>
<span class="gi">+    if G1.is_multigraph():</span>
<span class="gi">+        common_nodes.difference_update(</span>
<span class="gi">+            {</span>
<span class="gi">+                node</span>
<span class="gi">+                for node in common_nodes</span>
<span class="gi">+                if G1.number_of_edges(u, u) != G2.number_of_edges(node, node)</span>
<span class="gi">+            }</span>
<span class="gi">+        )</span>
<span class="gi">+    return common_nodes</span>


<span class="w"> </span>def _feasibility(node1, node2, graph_params, state_params):
<span class="gu">@@ -308,7 +603,16 @@ def _feasibility(node1, node2, graph_params, state_params):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    True if all checks are successful, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G1 = graph_params.G1</span>
<span class="gi">+</span>
<span class="gi">+    if _cut_PT(node1, node2, graph_params, state_params):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if G1.is_multigraph():</span>
<span class="gi">+        if not _consistent_PT(node1, node2, graph_params, state_params):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def _cut_PT(u, v, graph_params, state_params):
<span class="gu">@@ -348,7 +652,85 @@ def _cut_PT(u, v, graph_params, state_params):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    True if we should prune this branch, i.e. the node pair failed the cutting checks. False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G1, G2, G1_labels, G2_labels, _, _, _ = graph_params</span>
<span class="gi">+    (</span>
<span class="gi">+        _,</span>
<span class="gi">+        _,</span>
<span class="gi">+        T1,</span>
<span class="gi">+        T1_in,</span>
<span class="gi">+        T1_tilde,</span>
<span class="gi">+        _,</span>
<span class="gi">+        T2,</span>
<span class="gi">+        T2_in,</span>
<span class="gi">+        T2_tilde,</span>
<span class="gi">+        _,</span>
<span class="gi">+    ) = state_params</span>
<span class="gi">+</span>
<span class="gi">+    u_labels_predecessors, v_labels_predecessors = {}, {}</span>
<span class="gi">+    if G1.is_directed():</span>
<span class="gi">+        u_labels_predecessors = nx.utils.groups(</span>
<span class="gi">+            {n1: G1_labels[n1] for n1 in G1.pred[u]}</span>
<span class="gi">+        )</span>
<span class="gi">+        v_labels_predecessors = nx.utils.groups(</span>
<span class="gi">+            {n2: G2_labels[n2] for n2 in G2.pred[v]}</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if set(u_labels_predecessors.keys()) != set(v_labels_predecessors.keys()):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    u_labels_successors = nx.utils.groups({n1: G1_labels[n1] for n1 in G1[u]})</span>
<span class="gi">+    v_labels_successors = nx.utils.groups({n2: G2_labels[n2] for n2 in G2[v]})</span>
<span class="gi">+</span>
<span class="gi">+    # if the neighbors of u, do not have the same labels as those of v, NOT feasible.</span>
<span class="gi">+    if set(u_labels_successors.keys()) != set(v_labels_successors.keys()):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    for label, G1_nbh in u_labels_successors.items():</span>
<span class="gi">+        G2_nbh = v_labels_successors[label]</span>
<span class="gi">+</span>
<span class="gi">+        if G1.is_multigraph():</span>
<span class="gi">+            # Check for every neighbor in the neighborhood, if u-nbr1 has same edges as v-nbr2</span>
<span class="gi">+            u_nbrs_edges = sorted(G1.number_of_edges(u, x) for x in G1_nbh)</span>
<span class="gi">+            v_nbrs_edges = sorted(G2.number_of_edges(v, x) for x in G2_nbh)</span>
<span class="gi">+            if any(</span>
<span class="gi">+                u_nbr_edges != v_nbr_edges</span>
<span class="gi">+                for u_nbr_edges, v_nbr_edges in zip(u_nbrs_edges, v_nbrs_edges)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        if len(T1.intersection(G1_nbh)) != len(T2.intersection(G2_nbh)):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if len(T1_tilde.intersection(G1_nbh)) != len(T2_tilde.intersection(G2_nbh)):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if G1.is_directed() and len(T1_in.intersection(G1_nbh)) != len(</span>
<span class="gi">+            T2_in.intersection(G2_nbh)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    if not G1.is_directed():</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    for label, G1_pred in u_labels_predecessors.items():</span>
<span class="gi">+        G2_pred = v_labels_predecessors[label]</span>
<span class="gi">+</span>
<span class="gi">+        if G1.is_multigraph():</span>
<span class="gi">+            # Check for every neighbor in the neighborhood, if u-nbr1 has same edges as v-nbr2</span>
<span class="gi">+            u_pred_edges = sorted(G1.number_of_edges(u, x) for x in G1_pred)</span>
<span class="gi">+            v_pred_edges = sorted(G2.number_of_edges(v, x) for x in G2_pred)</span>
<span class="gi">+            if any(</span>
<span class="gi">+                u_nbr_edges != v_nbr_edges</span>
<span class="gi">+                for u_nbr_edges, v_nbr_edges in zip(u_pred_edges, v_pred_edges)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        if len(T1.intersection(G1_pred)) != len(T2.intersection(G2_pred)):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if len(T1_tilde.intersection(G1_pred)) != len(T2_tilde.intersection(G2_pred)):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if len(T1_in.intersection(G1_pred)) != len(T2_in.intersection(G2_pred)):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def _consistent_PT(u, v, graph_params, state_params):
<span class="gu">@@ -388,7 +770,41 @@ def _consistent_PT(u, v, graph_params, state_params):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    True if the pair passes all the consistency checks successfully. False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G1, G2 = graph_params.G1, graph_params.G2</span>
<span class="gi">+    mapping, reverse_mapping = state_params.mapping, state_params.reverse_mapping</span>
<span class="gi">+</span>
<span class="gi">+    for neighbor in G1[u]:</span>
<span class="gi">+        if neighbor in mapping:</span>
<span class="gi">+            if G1.number_of_edges(u, neighbor) != G2.number_of_edges(</span>
<span class="gi">+                v, mapping[neighbor]</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+    for neighbor in G2[v]:</span>
<span class="gi">+        if neighbor in reverse_mapping:</span>
<span class="gi">+            if G1.number_of_edges(u, reverse_mapping[neighbor]) != G2.number_of_edges(</span>
<span class="gi">+                v, neighbor</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+    if not G1.is_directed():</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    for predecessor in G1.pred[u]:</span>
<span class="gi">+        if predecessor in mapping:</span>
<span class="gi">+            if G1.number_of_edges(predecessor, u) != G2.number_of_edges(</span>
<span class="gi">+                mapping[predecessor], v</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+    for predecessor in G2.pred[v]:</span>
<span class="gi">+        if predecessor in reverse_mapping:</span>
<span class="gi">+            if G1.number_of_edges(</span>
<span class="gi">+                reverse_mapping[predecessor], u</span>
<span class="gi">+            ) != G2.number_of_edges(predecessor, v):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def _update_Tinout(new_node1, new_node2, graph_params, state_params):
<span class="gu">@@ -431,7 +847,55 @@ def _update_Tinout(new_node1, new_node2, graph_params, state_params):</span>
<span class="w"> </span>        T1_tilde, T2_tilde: set
<span class="w"> </span>            Ti_out contains all the nodes from Gi, that are neither in the mapping nor in Ti
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G1, G2, _, _, _, _, _ = graph_params</span>
<span class="gi">+    (</span>
<span class="gi">+        mapping,</span>
<span class="gi">+        reverse_mapping,</span>
<span class="gi">+        T1,</span>
<span class="gi">+        T1_in,</span>
<span class="gi">+        T1_tilde,</span>
<span class="gi">+        T1_tilde_in,</span>
<span class="gi">+        T2,</span>
<span class="gi">+        T2_in,</span>
<span class="gi">+        T2_tilde,</span>
<span class="gi">+        T2_tilde_in,</span>
<span class="gi">+    ) = state_params</span>
<span class="gi">+</span>
<span class="gi">+    uncovered_successors_G1 = {succ for succ in G1[new_node1] if succ not in mapping}</span>
<span class="gi">+    uncovered_successors_G2 = {</span>
<span class="gi">+        succ for succ in G2[new_node2] if succ not in reverse_mapping</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    # Add the uncovered neighbors of node1 and node2 in T1 and T2 respectively</span>
<span class="gi">+    T1.update(uncovered_successors_G1)</span>
<span class="gi">+    T2.update(uncovered_successors_G2)</span>
<span class="gi">+    T1.discard(new_node1)</span>
<span class="gi">+    T2.discard(new_node2)</span>
<span class="gi">+</span>
<span class="gi">+    T1_tilde.difference_update(uncovered_successors_G1)</span>
<span class="gi">+    T2_tilde.difference_update(uncovered_successors_G2)</span>
<span class="gi">+    T1_tilde.discard(new_node1)</span>
<span class="gi">+    T2_tilde.discard(new_node2)</span>
<span class="gi">+</span>
<span class="gi">+    if not G1.is_directed():</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    uncovered_predecessors_G1 = {</span>
<span class="gi">+        pred for pred in G1.pred[new_node1] if pred not in mapping</span>
<span class="gi">+    }</span>
<span class="gi">+    uncovered_predecessors_G2 = {</span>
<span class="gi">+        pred for pred in G2.pred[new_node2] if pred not in reverse_mapping</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    T1_in.update(uncovered_predecessors_G1)</span>
<span class="gi">+    T2_in.update(uncovered_predecessors_G2)</span>
<span class="gi">+    T1_in.discard(new_node1)</span>
<span class="gi">+    T2_in.discard(new_node2)</span>
<span class="gi">+</span>
<span class="gi">+    T1_tilde.difference_update(uncovered_predecessors_G1)</span>
<span class="gi">+    T2_tilde.difference_update(uncovered_predecessors_G2)</span>
<span class="gi">+    T1_tilde.discard(new_node1)</span>
<span class="gi">+    T2_tilde.discard(new_node2)</span>


<span class="w"> </span>def _restore_Tinout(popped_node1, popped_node2, graph_params, state_params):
<span class="gu">@@ -467,4 +931,138 @@ def _restore_Tinout(popped_node1, popped_node2, graph_params, state_params):</span>
<span class="w"> </span>        T1_tilde, T2_tilde: set
<span class="w"> </span>            Ti_out contains all the nodes from Gi, that are neither in the mapping nor in Ti
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # If the node we want to remove from the mapping, has at least one covered neighbor, add it to T1.</span>
<span class="gi">+    G1, G2, _, _, _, _, _ = graph_params</span>
<span class="gi">+    (</span>
<span class="gi">+        mapping,</span>
<span class="gi">+        reverse_mapping,</span>
<span class="gi">+        T1,</span>
<span class="gi">+        T1_in,</span>
<span class="gi">+        T1_tilde,</span>
<span class="gi">+        T1_tilde_in,</span>
<span class="gi">+        T2,</span>
<span class="gi">+        T2_in,</span>
<span class="gi">+        T2_tilde,</span>
<span class="gi">+        T2_tilde_in,</span>
<span class="gi">+    ) = state_params</span>
<span class="gi">+</span>
<span class="gi">+    is_added = False</span>
<span class="gi">+    for neighbor in G1[popped_node1]:</span>
<span class="gi">+        if neighbor in mapping:</span>
<span class="gi">+            # if a neighbor of the excluded node1 is in the mapping, keep node1 in T1</span>
<span class="gi">+            is_added = True</span>
<span class="gi">+            T1.add(popped_node1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # check if its neighbor has another connection with a covered node. If not, only then exclude it from T1</span>
<span class="gi">+            if any(nbr in mapping for nbr in G1[neighbor]):</span>
<span class="gi">+                continue</span>
<span class="gi">+            T1.discard(neighbor)</span>
<span class="gi">+            T1_tilde.add(neighbor)</span>
<span class="gi">+</span>
<span class="gi">+    # Case where the node is not present in neither the mapping nor T1. By definition, it should belong to T1_tilde</span>
<span class="gi">+    if not is_added:</span>
<span class="gi">+        T1_tilde.add(popped_node1)</span>
<span class="gi">+</span>
<span class="gi">+    is_added = False</span>
<span class="gi">+    for neighbor in G2[popped_node2]:</span>
<span class="gi">+        if neighbor in reverse_mapping:</span>
<span class="gi">+            is_added = True</span>
<span class="gi">+            T2.add(popped_node2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if any(nbr in reverse_mapping for nbr in G2[neighbor]):</span>
<span class="gi">+                continue</span>
<span class="gi">+            T2.discard(neighbor)</span>
<span class="gi">+            T2_tilde.add(neighbor)</span>
<span class="gi">+</span>
<span class="gi">+    if not is_added:</span>
<span class="gi">+        T2_tilde.add(popped_node2)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _restore_Tinout_Di(popped_node1, popped_node2, graph_params, state_params):</span>
<span class="gi">+    # If the node we want to remove from the mapping, has at least one covered neighbor, add it to T1.</span>
<span class="gi">+    G1, G2, _, _, _, _, _ = graph_params</span>
<span class="gi">+    (</span>
<span class="gi">+        mapping,</span>
<span class="gi">+        reverse_mapping,</span>
<span class="gi">+        T1,</span>
<span class="gi">+        T1_in,</span>
<span class="gi">+        T1_tilde,</span>
<span class="gi">+        T1_tilde_in,</span>
<span class="gi">+        T2,</span>
<span class="gi">+        T2_in,</span>
<span class="gi">+        T2_tilde,</span>
<span class="gi">+        T2_tilde_in,</span>
<span class="gi">+    ) = state_params</span>
<span class="gi">+</span>
<span class="gi">+    is_added = False</span>
<span class="gi">+    for successor in G1[popped_node1]:</span>
<span class="gi">+        if successor in mapping:</span>
<span class="gi">+            # if a neighbor of the excluded node1 is in the mapping, keep node1 in T1</span>
<span class="gi">+            is_added = True</span>
<span class="gi">+            T1_in.add(popped_node1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # check if its neighbor has another connection with a covered node. If not, only then exclude it from T1</span>
<span class="gi">+            if not any(pred in mapping for pred in G1.pred[successor]):</span>
<span class="gi">+                T1.discard(successor)</span>
<span class="gi">+</span>
<span class="gi">+            if not any(succ in mapping for succ in G1[successor]):</span>
<span class="gi">+                T1_in.discard(successor)</span>
<span class="gi">+</span>
<span class="gi">+            if successor not in T1:</span>
<span class="gi">+                if successor not in T1_in:</span>
<span class="gi">+                    T1_tilde.add(successor)</span>
<span class="gi">+</span>
<span class="gi">+    for predecessor in G1.pred[popped_node1]:</span>
<span class="gi">+        if predecessor in mapping:</span>
<span class="gi">+            # if a neighbor of the excluded node1 is in the mapping, keep node1 in T1</span>
<span class="gi">+            is_added = True</span>
<span class="gi">+            T1.add(popped_node1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # check if its neighbor has another connection with a covered node. If not, only then exclude it from T1</span>
<span class="gi">+            if not any(pred in mapping for pred in G1.pred[predecessor]):</span>
<span class="gi">+                T1.discard(predecessor)</span>
<span class="gi">+</span>
<span class="gi">+            if not any(succ in mapping for succ in G1[predecessor]):</span>
<span class="gi">+                T1_in.discard(predecessor)</span>
<span class="gi">+</span>
<span class="gi">+            if not (predecessor in T1 or predecessor in T1_in):</span>
<span class="gi">+                T1_tilde.add(predecessor)</span>
<span class="gi">+</span>
<span class="gi">+    # Case where the node is not present in neither the mapping nor T1. By definition it should belong to T1_tilde</span>
<span class="gi">+    if not is_added:</span>
<span class="gi">+        T1_tilde.add(popped_node1)</span>
<span class="gi">+</span>
<span class="gi">+    is_added = False</span>
<span class="gi">+    for successor in G2[popped_node2]:</span>
<span class="gi">+        if successor in reverse_mapping:</span>
<span class="gi">+            is_added = True</span>
<span class="gi">+            T2_in.add(popped_node2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not any(pred in reverse_mapping for pred in G2.pred[successor]):</span>
<span class="gi">+                T2.discard(successor)</span>
<span class="gi">+</span>
<span class="gi">+            if not any(succ in reverse_mapping for succ in G2[successor]):</span>
<span class="gi">+                T2_in.discard(successor)</span>
<span class="gi">+</span>
<span class="gi">+            if successor not in T2:</span>
<span class="gi">+                if successor not in T2_in:</span>
<span class="gi">+                    T2_tilde.add(successor)</span>
<span class="gi">+</span>
<span class="gi">+    for predecessor in G2.pred[popped_node2]:</span>
<span class="gi">+        if predecessor in reverse_mapping:</span>
<span class="gi">+            # if a neighbor of the excluded node1 is in the mapping, keep node1 in T1</span>
<span class="gi">+            is_added = True</span>
<span class="gi">+            T2.add(popped_node2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # check if its neighbor has another connection with a covered node. If not, only then exclude it from T1</span>
<span class="gi">+            if not any(pred in reverse_mapping for pred in G2.pred[predecessor]):</span>
<span class="gi">+                T2.discard(predecessor)</span>
<span class="gi">+</span>
<span class="gi">+            if not any(succ in reverse_mapping for succ in G2[predecessor]):</span>
<span class="gi">+                T2_in.discard(predecessor)</span>
<span class="gi">+</span>
<span class="gi">+            if not (predecessor in T2 or predecessor in T2_in):</span>
<span class="gi">+                T2_tilde.add(predecessor)</span>
<span class="gi">+</span>
<span class="gi">+    if not is_added:</span>
<span class="gi">+        T2_tilde.add(popped_node2)</span>
<span class="gh">diff --git a/networkx/algorithms/isomorphism/vf2userfunc.py b/networkx/algorithms/isomorphism/vf2userfunc.py</span>
<span class="gh">index 0a09206b2..9484edc04 100644</span>
<span class="gd">--- a/networkx/algorithms/isomorphism/vf2userfunc.py</span>
<span class="gi">+++ b/networkx/algorithms/isomorphism/vf2userfunc.py</span>
<span class="gu">@@ -30,14 +30,44 @@</span>
<span class="w"> </span>    So, all of the edge attribute dictionaries are passed to edge_match, and
<span class="w"> </span>    it must determine if there is an isomorphism between the two sets of edges.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from . import isomorphvf2 as vf2
<span class="gd">-__all__ = [&#39;GraphMatcher&#39;, &#39;DiGraphMatcher&#39;, &#39;MultiGraphMatcher&#39;,</span>
<span class="gd">-    &#39;MultiDiGraphMatcher&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;GraphMatcher&quot;, &quot;DiGraphMatcher&quot;, &quot;MultiGraphMatcher&quot;, &quot;MultiDiGraphMatcher&quot;]</span>


<span class="w"> </span>def _semantic_feasibility(self, G1_node, G2_node):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if mapping G1_node to G2_node is semantically feasible.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Make sure the nodes match</span>
<span class="gi">+    if self.node_match is not None:</span>
<span class="gi">+        nm = self.node_match(self.G1.nodes[G1_node], self.G2.nodes[G2_node])</span>
<span class="gi">+        if not nm:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    # Make sure the edges match</span>
<span class="gi">+    if self.edge_match is not None:</span>
<span class="gi">+        # Cached lookups</span>
<span class="gi">+        G1nbrs = self.G1_adj[G1_node]</span>
<span class="gi">+        G2nbrs = self.G2_adj[G2_node]</span>
<span class="gi">+        core_1 = self.core_1</span>
<span class="gi">+        edge_match = self.edge_match</span>
<span class="gi">+</span>
<span class="gi">+        for neighbor in G1nbrs:</span>
<span class="gi">+            # G1_node is not in core_1, so we must handle R_self separately</span>
<span class="gi">+            if neighbor == G1_node:</span>
<span class="gi">+                if G2_node in G2nbrs and not edge_match(</span>
<span class="gi">+                    G1nbrs[G1_node], G2nbrs[G2_node]</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            elif neighbor in core_1:</span>
<span class="gi">+                G2_nbr = core_1[neighbor]</span>
<span class="gi">+                if G2_nbr in G2nbrs and not edge_match(</span>
<span class="gi">+                    G1nbrs[neighbor], G2nbrs[G2_nbr]</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return False</span>
<span class="gi">+        # syntactic check has already verified that neighbors are symmetric</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>


<span class="w"> </span>class GraphMatcher(vf2.GraphMatcher):
<span class="gu">@@ -76,10 +106,14 @@ class GraphMatcher(vf2.GraphMatcher):</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        vf2.GraphMatcher.__init__(self, G1, G2)
<span class="gi">+</span>
<span class="w"> </span>        self.node_match = node_match
<span class="w"> </span>        self.edge_match = edge_match
<span class="gi">+</span>
<span class="gi">+        # These will be modified during checks to minimize code repeat.</span>
<span class="w"> </span>        self.G1_adj = self.G1.adj
<span class="w"> </span>        self.G2_adj = self.G2.adj
<span class="gi">+</span>
<span class="w"> </span>    semantic_feasibility = _semantic_feasibility


<span class="gu">@@ -119,14 +153,35 @@ class DiGraphMatcher(vf2.DiGraphMatcher):</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        vf2.DiGraphMatcher.__init__(self, G1, G2)
<span class="gi">+</span>
<span class="w"> </span>        self.node_match = node_match
<span class="w"> </span>        self.edge_match = edge_match
<span class="gi">+</span>
<span class="gi">+        # These will be modified during checks to minimize code repeat.</span>
<span class="w"> </span>        self.G1_adj = self.G1.adj
<span class="w"> </span>        self.G2_adj = self.G2.adj

<span class="w"> </span>    def semantic_feasibility(self, G1_node, G2_node):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if mapping G1_node to G2_node is semantically feasible.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Test node_match and also test edge_match on successors</span>
<span class="gi">+        feasible = _semantic_feasibility(self, G1_node, G2_node)</span>
<span class="gi">+        if not feasible:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Test edge_match on predecessors</span>
<span class="gi">+        self.G1_adj = self.G1.pred</span>
<span class="gi">+        self.G2_adj = self.G2.pred</span>
<span class="gi">+        feasible = _semantic_feasibility(self, G1_node, G2_node)</span>
<span class="gi">+        self.G1_adj = self.G1.adj</span>
<span class="gi">+        self.G2_adj = self.G2.adj</span>
<span class="gi">+</span>
<span class="gi">+        return feasible</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# The &quot;semantics&quot; of edge_match are different for multi(di)graphs, but</span>
<span class="gi">+# the implementation is the same.  So, technically we do not need to</span>
<span class="gi">+# provide &quot;multi&quot; versions, but we do so to match NetworkX&#39;s base classes.</span>


<span class="w"> </span>class MultiGraphMatcher(GraphMatcher):
<span class="gh">diff --git a/networkx/algorithms/link_analysis/hits_alg.py b/networkx/algorithms/link_analysis/hits_alg.py</span>
<span class="gh">index ec8d0cf04..e7b5141aa 100644</span>
<span class="gd">--- a/networkx/algorithms/link_analysis/hits_alg.py</span>
<span class="gi">+++ b/networkx/algorithms/link_analysis/hits_alg.py</span>
<span class="gu">@@ -1,11 +1,12 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Hubs and authorities analysis of graph structure.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;hits&#39;]</span>

<span class="gi">+__all__ = [&quot;hits&quot;]</span>

<span class="gd">-@nx._dispatchable(preserve_edge_attrs={&#39;G&#39;: {&#39;weight&#39;: 1}})</span>
<span class="gd">-def hits(G, max_iter=100, tol=1e-08, nstart=None, normalized=True):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(preserve_edge_attrs={&quot;G&quot;: {&quot;weight&quot;: 1}})</span>
<span class="gi">+def hits(G, max_iter=100, tol=1.0e-8, nstart=None, normalized=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns HITS hubs and authorities values for nodes.

<span class="w"> </span>    The HITS algorithm computes two numbers for a node.
<span class="gu">@@ -69,7 +70,81 @@ def hits(G, max_iter=100, tol=1e-08, nstart=None, normalized=True):</span>
<span class="w"> </span>       doi:10.1145/324133.324140.
<span class="w"> </span>       http://www.cs.cornell.edu/home/kleinber/auth.pdf.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}, {}</span>
<span class="gi">+    A = nx.adjacency_matrix(G, nodelist=list(G), dtype=float)</span>
<span class="gi">+</span>
<span class="gi">+    if nstart is not None:</span>
<span class="gi">+        nstart = np.array(list(nstart.values()))</span>
<span class="gi">+    if max_iter &lt;= 0:</span>
<span class="gi">+        raise nx.PowerIterationFailedConvergence(max_iter)</span>
<span class="gi">+    try:</span>
<span class="gi">+        _, _, vt = sp.sparse.linalg.svds(A, k=1, v0=nstart, maxiter=max_iter, tol=tol)</span>
<span class="gi">+    except sp.sparse.linalg.ArpackNoConvergence as exc:</span>
<span class="gi">+        raise nx.PowerIterationFailedConvergence(max_iter) from exc</span>
<span class="gi">+</span>
<span class="gi">+    a = vt.flatten().real</span>
<span class="gi">+    h = A @ a</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        h /= h.sum()</span>
<span class="gi">+        a /= a.sum()</span>
<span class="gi">+    hubs = dict(zip(G, map(float, h)))</span>
<span class="gi">+    authorities = dict(zip(G, map(float, a)))</span>
<span class="gi">+    return hubs, authorities</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _hits_python(G, max_iter=100, tol=1.0e-8, nstart=None, normalized=True):</span>
<span class="gi">+    if isinstance(G, nx.MultiGraph | nx.MultiDiGraph):</span>
<span class="gi">+        raise Exception(&quot;hits() not defined for graphs with multiedges.&quot;)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}, {}</span>
<span class="gi">+    # choose fixed starting vector if not given</span>
<span class="gi">+    if nstart is None:</span>
<span class="gi">+        h = dict.fromkeys(G, 1.0 / G.number_of_nodes())</span>
<span class="gi">+    else:</span>
<span class="gi">+        h = nstart</span>
<span class="gi">+        # normalize starting vector</span>
<span class="gi">+        s = 1.0 / sum(h.values())</span>
<span class="gi">+        for k in h:</span>
<span class="gi">+            h[k] *= s</span>
<span class="gi">+    for _ in range(max_iter):  # power iteration: make up to max_iter iterations</span>
<span class="gi">+        hlast = h</span>
<span class="gi">+        h = dict.fromkeys(hlast.keys(), 0)</span>
<span class="gi">+        a = dict.fromkeys(hlast.keys(), 0)</span>
<span class="gi">+        # this &quot;matrix multiply&quot; looks odd because it is</span>
<span class="gi">+        # doing a left multiply a^T=hlast^T*G</span>
<span class="gi">+        for n in h:</span>
<span class="gi">+            for nbr in G[n]:</span>
<span class="gi">+                a[nbr] += hlast[n] * G[n][nbr].get(&quot;weight&quot;, 1)</span>
<span class="gi">+        # now multiply h=Ga</span>
<span class="gi">+        for n in h:</span>
<span class="gi">+            for nbr in G[n]:</span>
<span class="gi">+                h[n] += a[nbr] * G[n][nbr].get(&quot;weight&quot;, 1)</span>
<span class="gi">+        # normalize vector</span>
<span class="gi">+        s = 1.0 / max(h.values())</span>
<span class="gi">+        for n in h:</span>
<span class="gi">+            h[n] *= s</span>
<span class="gi">+        # normalize vector</span>
<span class="gi">+        s = 1.0 / max(a.values())</span>
<span class="gi">+        for n in a:</span>
<span class="gi">+            a[n] *= s</span>
<span class="gi">+        # check convergence, l1 norm</span>
<span class="gi">+        err = sum(abs(h[n] - hlast[n]) for n in h)</span>
<span class="gi">+        if err &lt; tol:</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.PowerIterationFailedConvergence(max_iter)</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        s = 1.0 / sum(a.values())</span>
<span class="gi">+        for n in a:</span>
<span class="gi">+            a[n] *= s</span>
<span class="gi">+        s = 1.0 / sum(h.values())</span>
<span class="gi">+        for n in h:</span>
<span class="gi">+            h[n] *= s</span>
<span class="gi">+    return h, a</span>


<span class="w"> </span>def _hits_numpy(G, normalized=True):
<span class="gu">@@ -132,10 +207,31 @@ def _hits_numpy(G, normalized=True):</span>
<span class="w"> </span>       doi:10.1145/324133.324140.
<span class="w"> </span>       http://www.cs.cornell.edu/home/kleinber/auth.pdf.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _hits_scipy(G, max_iter=100, tol=1e-06, nstart=None, normalized=True):</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}, {}</span>
<span class="gi">+    adj_ary = nx.to_numpy_array(G)</span>
<span class="gi">+    # Hub matrix</span>
<span class="gi">+    H = adj_ary @ adj_ary.T</span>
<span class="gi">+    e, ev = np.linalg.eig(H)</span>
<span class="gi">+    h = ev[:, np.argmax(e)]  # eigenvector corresponding to the maximum eigenvalue</span>
<span class="gi">+    # Authority matrix</span>
<span class="gi">+    A = adj_ary.T @ adj_ary</span>
<span class="gi">+    e, ev = np.linalg.eig(A)</span>
<span class="gi">+    a = ev[:, np.argmax(e)]  # eigenvector corresponding to the maximum eigenvalue</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        h /= h.sum()</span>
<span class="gi">+        a /= a.sum()</span>
<span class="gi">+    else:</span>
<span class="gi">+        h /= h.max()</span>
<span class="gi">+        a /= a.max()</span>
<span class="gi">+    hubs = dict(zip(G, map(float, h)))</span>
<span class="gi">+    authorities = dict(zip(G, map(float, a)))</span>
<span class="gi">+    return hubs, authorities</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _hits_scipy(G, max_iter=100, tol=1.0e-6, nstart=None, normalized=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns HITS hubs and authorities values for nodes.


<span class="gu">@@ -203,4 +299,39 @@ def _hits_scipy(G, max_iter=100, tol=1e-06, nstart=None, normalized=True):</span>
<span class="w"> </span>       doi:10.1145/324133.324140.
<span class="w"> </span>       http://www.cs.cornell.edu/home/kleinber/auth.pdf.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}, {}</span>
<span class="gi">+    A = nx.to_scipy_sparse_array(G, nodelist=list(G))</span>
<span class="gi">+    (n, _) = A.shape  # should be square</span>
<span class="gi">+    ATA = A.T @ A  # authority matrix</span>
<span class="gi">+    # choose fixed starting vector if not given</span>
<span class="gi">+    if nstart is None:</span>
<span class="gi">+        x = np.ones((n, 1)) / n</span>
<span class="gi">+    else:</span>
<span class="gi">+        x = np.array([nstart.get(n, 0) for n in list(G)], dtype=float)</span>
<span class="gi">+        x /= x.sum()</span>
<span class="gi">+</span>
<span class="gi">+    # power iteration on authority matrix</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while True:</span>
<span class="gi">+        xlast = x</span>
<span class="gi">+        x = ATA @ x</span>
<span class="gi">+        x /= x.max()</span>
<span class="gi">+        # check convergence, l1 norm</span>
<span class="gi">+        err = np.absolute(x - xlast).sum()</span>
<span class="gi">+        if err &lt; tol:</span>
<span class="gi">+            break</span>
<span class="gi">+        if i &gt; max_iter:</span>
<span class="gi">+            raise nx.PowerIterationFailedConvergence(max_iter)</span>
<span class="gi">+        i += 1</span>
<span class="gi">+</span>
<span class="gi">+    a = x.flatten()</span>
<span class="gi">+    h = A @ a</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        h /= h.sum()</span>
<span class="gi">+        a /= a.sum()</span>
<span class="gi">+    hubs = dict(zip(G, map(float, h)))</span>
<span class="gi">+    authorities = dict(zip(G, map(float, a)))</span>
<span class="gi">+    return hubs, authorities</span>
<span class="gh">diff --git a/networkx/algorithms/link_analysis/pagerank_alg.py b/networkx/algorithms/link_analysis/pagerank_alg.py</span>
<span class="gh">index e4b75265e..2a4af6e5f 100644</span>
<span class="gd">--- a/networkx/algorithms/link_analysis/pagerank_alg.py</span>
<span class="gi">+++ b/networkx/algorithms/link_analysis/pagerank_alg.py</span>
<span class="gu">@@ -1,12 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;PageRank analysis of graph structure. &quot;&quot;&quot;
<span class="w"> </span>from warnings import warn
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;pagerank&#39;, &#39;google_matrix&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;pagerank&quot;, &quot;google_matrix&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def pagerank(G, alpha=0.85, personalization=None, max_iter=100, tol=1e-06,</span>
<span class="gd">-    nstart=None, weight=&#39;weight&#39;, dangling=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def pagerank(</span>
<span class="gi">+    G,</span>
<span class="gi">+    alpha=0.85,</span>
<span class="gi">+    personalization=None,</span>
<span class="gi">+    max_iter=100,</span>
<span class="gi">+    tol=1.0e-6,</span>
<span class="gi">+    nstart=None,</span>
<span class="gi">+    weight=&quot;weight&quot;,</span>
<span class="gi">+    dangling=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the PageRank of the nodes in the graph.

<span class="w"> </span>    PageRank computes a ranking of the nodes in the graph G based on
<span class="gu">@@ -97,12 +107,75 @@ def pagerank(G, alpha=0.85, personalization=None, max_iter=100, tol=1e-06,</span>
<span class="w"> </span>       http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&amp;doc=1999-66&amp;format=pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def google_matrix(G, alpha=0.85, personalization=None, nodelist=None,</span>
<span class="gd">-    weight=&#39;weight&#39;, dangling=None):</span>
<span class="gi">+    return _pagerank_scipy(</span>
<span class="gi">+        G, alpha, personalization, max_iter, tol, nstart, weight, dangling</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _pagerank_python(</span>
<span class="gi">+    G,</span>
<span class="gi">+    alpha=0.85,</span>
<span class="gi">+    personalization=None,</span>
<span class="gi">+    max_iter=100,</span>
<span class="gi">+    tol=1.0e-6,</span>
<span class="gi">+    nstart=None,</span>
<span class="gi">+    weight=&quot;weight&quot;,</span>
<span class="gi">+    dangling=None,</span>
<span class="gi">+):</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    D = G.to_directed()</span>
<span class="gi">+</span>
<span class="gi">+    # Create a copy in (right) stochastic form</span>
<span class="gi">+    W = nx.stochastic_graph(D, weight=weight)</span>
<span class="gi">+    N = W.number_of_nodes()</span>
<span class="gi">+</span>
<span class="gi">+    # Choose fixed starting vector if not given</span>
<span class="gi">+    if nstart is None:</span>
<span class="gi">+        x = dict.fromkeys(W, 1.0 / N)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Normalized nstart vector</span>
<span class="gi">+        s = sum(nstart.values())</span>
<span class="gi">+        x = {k: v / s for k, v in nstart.items()}</span>
<span class="gi">+</span>
<span class="gi">+    if personalization is None:</span>
<span class="gi">+        # Assign uniform personalization vector if not given</span>
<span class="gi">+        p = dict.fromkeys(W, 1.0 / N)</span>
<span class="gi">+    else:</span>
<span class="gi">+        s = sum(personalization.values())</span>
<span class="gi">+        p = {k: v / s for k, v in personalization.items()}</span>
<span class="gi">+</span>
<span class="gi">+    if dangling is None:</span>
<span class="gi">+        # Use personalization vector if dangling vector not specified</span>
<span class="gi">+        dangling_weights = p</span>
<span class="gi">+    else:</span>
<span class="gi">+        s = sum(dangling.values())</span>
<span class="gi">+        dangling_weights = {k: v / s for k, v in dangling.items()}</span>
<span class="gi">+    dangling_nodes = [n for n in W if W.out_degree(n, weight=weight) == 0.0]</span>
<span class="gi">+</span>
<span class="gi">+    # power iteration: make up to max_iter iterations</span>
<span class="gi">+    for _ in range(max_iter):</span>
<span class="gi">+        xlast = x</span>
<span class="gi">+        x = dict.fromkeys(xlast.keys(), 0)</span>
<span class="gi">+        danglesum = alpha * sum(xlast[n] for n in dangling_nodes)</span>
<span class="gi">+        for n in x:</span>
<span class="gi">+            # this matrix multiply looks odd because it is</span>
<span class="gi">+            # doing a left multiply x^T=xlast^T*W</span>
<span class="gi">+            for _, nbr, wt in W.edges(n, data=weight):</span>
<span class="gi">+                x[nbr] += alpha * xlast[n] * wt</span>
<span class="gi">+            x[n] += danglesum * dangling_weights.get(n, 0) + (1.0 - alpha) * p.get(n, 0)</span>
<span class="gi">+        # check convergence, l1 norm</span>
<span class="gi">+        err = sum(abs(x[n] - xlast[n]) for n in x)</span>
<span class="gi">+        if err &lt; N * tol:</span>
<span class="gi">+            return x</span>
<span class="gi">+    raise nx.PowerIterationFailedConvergence(max_iter)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def google_matrix(</span>
<span class="gi">+    G, alpha=0.85, personalization=None, nodelist=None, weight=&quot;weight&quot;, dangling=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the Google matrix of the graph.

<span class="w"> </span>    Parameters
<span class="gu">@@ -159,11 +232,45 @@ def google_matrix(G, alpha=0.85, personalization=None, nodelist=None,</span>
<span class="w"> </span>    --------
<span class="w"> </span>    pagerank
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+</span>
<span class="gi">+    A = nx.to_numpy_array(G, nodelist=nodelist, weight=weight)</span>
<span class="gi">+    N = len(G)</span>
<span class="gi">+    if N == 0:</span>
<span class="gi">+        return A</span>
<span class="gi">+</span>
<span class="gi">+    # Personalization vector</span>
<span class="gi">+    if personalization is None:</span>
<span class="gi">+        p = np.repeat(1.0 / N, N)</span>
<span class="gi">+    else:</span>
<span class="gi">+        p = np.array([personalization.get(n, 0) for n in nodelist], dtype=float)</span>
<span class="gi">+        if p.sum() == 0:</span>
<span class="gi">+            raise ZeroDivisionError</span>
<span class="gi">+        p /= p.sum()</span>

<span class="gi">+    # Dangling nodes</span>
<span class="gi">+    if dangling is None:</span>
<span class="gi">+        dangling_weights = p</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Convert the dangling dictionary into an array in nodelist order</span>
<span class="gi">+        dangling_weights = np.array([dangling.get(n, 0) for n in nodelist], dtype=float)</span>
<span class="gi">+        dangling_weights /= dangling_weights.sum()</span>
<span class="gi">+    dangling_nodes = np.where(A.sum(axis=1) == 0)[0]</span>

<span class="gd">-def _pagerank_numpy(G, alpha=0.85, personalization=None, weight=&#39;weight&#39;,</span>
<span class="gd">-    dangling=None):</span>
<span class="gi">+    # Assign dangling_weights to any dangling nodes (nodes with no out links)</span>
<span class="gi">+    A[dangling_nodes] = dangling_weights</span>
<span class="gi">+</span>
<span class="gi">+    A /= A.sum(axis=1)[:, np.newaxis]  # Normalize rows to sum to 1</span>
<span class="gi">+</span>
<span class="gi">+    return alpha * A + (1 - alpha) * p</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _pagerank_numpy(</span>
<span class="gi">+    G, alpha=0.85, personalization=None, weight=&quot;weight&quot;, dangling=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the PageRank of the nodes in the graph.

<span class="w"> </span>    PageRank computes a ranking of the nodes in the graph G based on
<span class="gu">@@ -232,11 +339,32 @@ def _pagerank_numpy(G, alpha=0.85, personalization=None, weight=&#39;weight&#39;,</span>
<span class="w"> </span>       The PageRank citation ranking: Bringing order to the Web. 1999
<span class="w"> </span>       http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&amp;doc=1999-66&amp;format=pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _pagerank_scipy(G, alpha=0.85, personalization=None, max_iter=100, tol=</span>
<span class="gd">-    1e-06, nstart=None, weight=&#39;weight&#39;, dangling=None):</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+    M = google_matrix(</span>
<span class="gi">+        G, alpha, personalization=personalization, weight=weight, dangling=dangling</span>
<span class="gi">+    )</span>
<span class="gi">+    # use numpy LAPACK solver</span>
<span class="gi">+    eigenvalues, eigenvectors = np.linalg.eig(M.T)</span>
<span class="gi">+    ind = np.argmax(eigenvalues)</span>
<span class="gi">+    # eigenvector of largest eigenvalue is at ind, normalized</span>
<span class="gi">+    largest = np.array(eigenvectors[:, ind]).flatten().real</span>
<span class="gi">+    norm = largest.sum()</span>
<span class="gi">+    return dict(zip(G, map(float, largest / norm)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _pagerank_scipy(</span>
<span class="gi">+    G,</span>
<span class="gi">+    alpha=0.85,</span>
<span class="gi">+    personalization=None,</span>
<span class="gi">+    max_iter=100,</span>
<span class="gi">+    tol=1.0e-6,</span>
<span class="gi">+    nstart=None,</span>
<span class="gi">+    weight=&quot;weight&quot;,</span>
<span class="gi">+    dangling=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the PageRank of the nodes in the graph.

<span class="w"> </span>    PageRank computes a ranking of the nodes in the graph G based on
<span class="gu">@@ -321,4 +449,51 @@ def _pagerank_scipy(G, alpha=0.85, personalization=None, max_iter=100, tol=</span>
<span class="w"> </span>       The PageRank citation ranking: Bringing order to the Web. 1999
<span class="w"> </span>       http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&amp;doc=1999-66&amp;format=pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    N = len(G)</span>
<span class="gi">+    if N == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    nodelist = list(G)</span>
<span class="gi">+    A = nx.to_scipy_sparse_array(G, nodelist=nodelist, weight=weight, dtype=float)</span>
<span class="gi">+    S = A.sum(axis=1)</span>
<span class="gi">+    S[S != 0] = 1.0 / S[S != 0]</span>
<span class="gi">+    # TODO: csr_array</span>
<span class="gi">+    Q = sp.sparse.csr_array(sp.sparse.spdiags(S.T, 0, *A.shape))</span>
<span class="gi">+    A = Q @ A</span>
<span class="gi">+</span>
<span class="gi">+    # initial vector</span>
<span class="gi">+    if nstart is None:</span>
<span class="gi">+        x = np.repeat(1.0 / N, N)</span>
<span class="gi">+    else:</span>
<span class="gi">+        x = np.array([nstart.get(n, 0) for n in nodelist], dtype=float)</span>
<span class="gi">+        x /= x.sum()</span>
<span class="gi">+</span>
<span class="gi">+    # Personalization vector</span>
<span class="gi">+    if personalization is None:</span>
<span class="gi">+        p = np.repeat(1.0 / N, N)</span>
<span class="gi">+    else:</span>
<span class="gi">+        p = np.array([personalization.get(n, 0) for n in nodelist], dtype=float)</span>
<span class="gi">+        if p.sum() == 0:</span>
<span class="gi">+            raise ZeroDivisionError</span>
<span class="gi">+        p /= p.sum()</span>
<span class="gi">+    # Dangling nodes</span>
<span class="gi">+    if dangling is None:</span>
<span class="gi">+        dangling_weights = p</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Convert the dangling dictionary into an array in nodelist order</span>
<span class="gi">+        dangling_weights = np.array([dangling.get(n, 0) for n in nodelist], dtype=float)</span>
<span class="gi">+        dangling_weights /= dangling_weights.sum()</span>
<span class="gi">+    is_dangling = np.where(S == 0)[0]</span>
<span class="gi">+</span>
<span class="gi">+    # power iteration: make up to max_iter iterations</span>
<span class="gi">+    for _ in range(max_iter):</span>
<span class="gi">+        xlast = x</span>
<span class="gi">+        x = alpha * (x @ A + sum(x[is_dangling]) * dangling_weights) + (1 - alpha) * p</span>
<span class="gi">+        # check convergence, l1 norm</span>
<span class="gi">+        err = np.absolute(x - xlast).sum()</span>
<span class="gi">+        if err &lt; N * tol:</span>
<span class="gi">+            return dict(zip(nodelist, map(float, x)))</span>
<span class="gi">+    raise nx.PowerIterationFailedConvergence(max_iter)</span>
<span class="gh">diff --git a/networkx/algorithms/link_prediction.py b/networkx/algorithms/link_prediction.py</span>
<span class="gh">index daa47abeb..1fb24243a 100644</span>
<span class="gd">--- a/networkx/algorithms/link_prediction.py</span>
<span class="gi">+++ b/networkx/algorithms/link_prediction.py</span>
<span class="gu">@@ -1,13 +1,23 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Link prediction algorithms.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from math import log
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;resource_allocation_index&#39;, &#39;jaccard_coefficient&#39;,</span>
<span class="gd">-    &#39;adamic_adar_index&#39;, &#39;preferential_attachment&#39;,</span>
<span class="gd">-    &#39;cn_soundarajan_hopcroft&#39;, &#39;ra_index_soundarajan_hopcroft&#39;,</span>
<span class="gd">-    &#39;within_inter_cluster&#39;, &#39;common_neighbor_centrality&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;resource_allocation_index&quot;,</span>
<span class="gi">+    &quot;jaccard_coefficient&quot;,</span>
<span class="gi">+    &quot;adamic_adar_index&quot;,</span>
<span class="gi">+    &quot;preferential_attachment&quot;,</span>
<span class="gi">+    &quot;cn_soundarajan_hopcroft&quot;,</span>
<span class="gi">+    &quot;ra_index_soundarajan_hopcroft&quot;,</span>
<span class="gi">+    &quot;within_inter_cluster&quot;,</span>
<span class="gi">+    &quot;common_neighbor_centrality&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def _apply_prediction(G, func, ebunch=None):
<span class="gu">@@ -25,22 +35,30 @@ def _apply_prediction(G, func, ebunch=None):</span>
<span class="w"> </span>    non-edges in the graph `G` will be used.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    if ebunch is None:</span>
<span class="gi">+        ebunch = nx.non_edges(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u, v in ebunch:</span>
<span class="gi">+            if u not in G:</span>
<span class="gi">+                raise nx.NodeNotFound(f&quot;Node {u} not in G.&quot;)</span>
<span class="gi">+            if v not in G:</span>
<span class="gi">+                raise nx.NodeNotFound(f&quot;Node {v} not in G.&quot;)</span>
<span class="gi">+    return ((u, v, func(u, v)) for u, v in ebunch)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def resource_allocation_index(G, ebunch=None):
<span class="gd">-    &quot;&quot;&quot;Compute the resource allocation index of all node pairs in ebunch.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the resource allocation index of all node pairs in ebunch.</span>

<span class="w"> </span>    Resource allocation index of `u` and `v` is defined as

<span class="w"> </span>    .. math::

<span class="gd">-        \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{1}{|\\Gamma(w)|}</span>
<span class="gi">+        \sum_{w \in \Gamma(u) \cap \Gamma(v)} \frac{1}{|\Gamma(w)|}</span>

<span class="gd">-    where $\\Gamma(u)$ denotes the set of neighbors of $u$.</span>
<span class="gi">+    where $\Gamma(u)$ denotes the set of neighbors of $u$.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -84,22 +102,26 @@ def resource_allocation_index(G, ebunch=None):</span>
<span class="w"> </span>       Eur. Phys. J. B 71 (2009) 623.
<span class="w"> </span>       https://arxiv.org/pdf/0901.0553.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def predict(u, v):</span>
<span class="gi">+        return sum(1 / G.degree(w) for w in nx.common_neighbors(G, u, v))</span>
<span class="gi">+</span>
<span class="gi">+    return _apply_prediction(G, predict, ebunch)</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def jaccard_coefficient(G, ebunch=None):
<span class="gd">-    &quot;&quot;&quot;Compute the Jaccard coefficient of all node pairs in ebunch.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the Jaccard coefficient of all node pairs in ebunch.</span>

<span class="w"> </span>    Jaccard coefficient of nodes `u` and `v` is defined as

<span class="w"> </span>    .. math::

<span class="gd">-        \\frac{|\\Gamma(u) \\cap \\Gamma(v)|}{|\\Gamma(u) \\cup \\Gamma(v)|}</span>
<span class="gi">+        \frac{|\Gamma(u) \cap \Gamma(v)|}{|\Gamma(u) \cup \Gamma(v)|}</span>

<span class="gd">-    where $\\Gamma(u)$ denotes the set of neighbors of $u$.</span>
<span class="gi">+    where $\Gamma(u)$ denotes the set of neighbors of $u$.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -142,22 +164,29 @@ def jaccard_coefficient(G, ebunch=None):</span>
<span class="w"> </span>           The Link Prediction Problem for Social Networks (2004).
<span class="w"> </span>           http://www.cs.cornell.edu/home/kleinber/link-pred.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def predict(u, v):</span>
<span class="gi">+        union_size = len(set(G[u]) | set(G[v]))</span>
<span class="gi">+        if union_size == 0:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        return len(nx.common_neighbors(G, u, v)) / union_size</span>
<span class="gi">+</span>
<span class="gi">+    return _apply_prediction(G, predict, ebunch)</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def adamic_adar_index(G, ebunch=None):
<span class="gd">-    &quot;&quot;&quot;Compute the Adamic-Adar index of all node pairs in ebunch.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the Adamic-Adar index of all node pairs in ebunch.</span>

<span class="w"> </span>    Adamic-Adar index of `u` and `v` is defined as

<span class="w"> </span>    .. math::

<span class="gd">-        \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{1}{\\log |\\Gamma(w)|}</span>
<span class="gi">+        \sum_{w \in \Gamma(u) \cap \Gamma(v)} \frac{1}{\log |\Gamma(w)|}</span>

<span class="gd">-    where $\\Gamma(u)$ denotes the set of neighbors of $u$.</span>
<span class="gi">+    where $\Gamma(u)$ denotes the set of neighbors of $u$.</span>
<span class="w"> </span>    This index leads to zero-division for nodes only connected via self-loops.
<span class="w"> </span>    It is intended to be used when no self-loops are present.

<span class="gu">@@ -202,14 +231,18 @@ def adamic_adar_index(G, ebunch=None):</span>
<span class="w"> </span>           The Link Prediction Problem for Social Networks (2004).
<span class="w"> </span>           http://www.cs.cornell.edu/home/kleinber/link-pred.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def predict(u, v):</span>
<span class="gi">+        return sum(1 / log(G.degree(w)) for w in nx.common_neighbors(G, u, v))</span>
<span class="gi">+</span>
<span class="gi">+    return _apply_prediction(G, predict, ebunch)</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def common_neighbor_centrality(G, ebunch=None, alpha=0.8):
<span class="gd">-    &quot;&quot;&quot;Return the CCPA score for each pair of nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Return the CCPA score for each pair of nodes.</span>

<span class="w"> </span>    Compute the Common Neighbor and Centrality based Parameterized Algorithm(CCPA)
<span class="w"> </span>    score of all node pairs in ebunch.
<span class="gu">@@ -218,10 +251,10 @@ def common_neighbor_centrality(G, ebunch=None, alpha=0.8):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        \\alpha \\cdot (|\\Gamma (u){\\cap }^{}\\Gamma (v)|)+(1-\\alpha )\\cdot \\frac{N}{{d}_{uv}}</span>
<span class="gi">+        \alpha \cdot (|\Gamma (u){\cap }^{}\Gamma (v)|)+(1-\alpha )\cdot \frac{N}{{d}_{uv}}</span>

<span class="gd">-    where $\\Gamma(u)$ denotes the set of neighbors of $u$, $\\Gamma(v)$ denotes the</span>
<span class="gd">-    set of neighbors of $v$, $\\alpha$ is  parameter varies between [0,1], $N$ denotes</span>
<span class="gi">+    where $\Gamma(u)$ denotes the set of neighbors of $u$, $\Gamma(v)$ denotes the</span>
<span class="gi">+    set of neighbors of $v$, $\alpha$ is  parameter varies between [0,1], $N$ denotes</span>
<span class="w"> </span>    total number of nodes in the Graph and ${d}_{uv}$ denotes shortest distance
<span class="w"> </span>    between $u$ and $v$.

<span class="gu">@@ -288,22 +321,44 @@ def common_neighbor_centrality(G, ebunch=None, alpha=0.8):</span>
<span class="w"> </span>           Sci Rep 10, 364 (2020).
<span class="w"> </span>           https://doi.org/10.1038/s41598-019-57304-y
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    # When alpha == 1, the CCPA score simplifies to the number of common neighbors.</span>
<span class="gi">+    if alpha == 1:</span>
<span class="gi">+</span>
<span class="gi">+        def predict(u, v):</span>
<span class="gi">+            if u == v:</span>
<span class="gi">+                raise nx.NetworkXAlgorithmError(&quot;Self loops are not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            return len(nx.common_neighbors(G, u, v))</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        spl = dict(nx.shortest_path_length(G))</span>
<span class="gi">+        inf = float(&quot;inf&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def predict(u, v):</span>
<span class="gi">+            if u == v:</span>
<span class="gi">+                raise nx.NetworkXAlgorithmError(&quot;Self loops are not supported&quot;)</span>
<span class="gi">+            path_len = spl[u].get(v, inf)</span>
<span class="gi">+</span>
<span class="gi">+            n_nbrs = len(nx.common_neighbors(G, u, v))</span>
<span class="gi">+            return alpha * n_nbrs + (1 - alpha) * len(G) / path_len</span>
<span class="gi">+</span>
<span class="gi">+    return _apply_prediction(G, predict, ebunch)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def preferential_attachment(G, ebunch=None):
<span class="gd">-    &quot;&quot;&quot;Compute the preferential attachment score of all node pairs in ebunch.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the preferential attachment score of all node pairs in ebunch.</span>

<span class="w"> </span>    Preferential attachment score of `u` and `v` is defined as

<span class="w"> </span>    .. math::

<span class="gd">-        |\\Gamma(u)| |\\Gamma(v)|</span>
<span class="gi">+        |\Gamma(u)| |\Gamma(v)|</span>

<span class="gd">-    where $\\Gamma(u)$ denotes the set of neighbors of $u$.</span>
<span class="gi">+    where $\Gamma(u)$ denotes the set of neighbors of $u$.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -346,14 +401,18 @@ def preferential_attachment(G, ebunch=None):</span>
<span class="w"> </span>           The Link Prediction Problem for Social Networks (2004).
<span class="w"> </span>           http://www.cs.cornell.edu/home/kleinber/link-pred.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def predict(u, v):</span>
<span class="gi">+        return G.degree(u) * G.degree(v)</span>
<span class="gi">+</span>
<span class="gi">+    return _apply_prediction(G, predict, ebunch)</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(node_attrs=&#39;community&#39;)</span>
<span class="gd">-def cn_soundarajan_hopcroft(G, ebunch=None, community=&#39;community&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Count the number of common neighbors of all node pairs in ebunch</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;community&quot;)</span>
<span class="gi">+def cn_soundarajan_hopcroft(G, ebunch=None, community=&quot;community&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Count the number of common neighbors of all node pairs in ebunch</span>
<span class="w"> </span>        using community information.

<span class="w"> </span>    For two nodes $u$ and $v$, this function computes the number of
<span class="gu">@@ -362,10 +421,10 @@ def cn_soundarajan_hopcroft(G, ebunch=None, community=&#39;community&#39;):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        |\\Gamma(u) \\cap \\Gamma(v)| + \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} f(w)</span>
<span class="gi">+        |\Gamma(u) \cap \Gamma(v)| + \sum_{w \in \Gamma(u) \cap \Gamma(v)} f(w)</span>

<span class="w"> </span>    where $f(w)$ equals 1 if $w$ belongs to the same community as $u$
<span class="gd">-    and $v$ or 0 otherwise and $\\Gamma(u)$ denotes the set of</span>
<span class="gi">+    and $v$ or 0 otherwise and $\Gamma(u)$ denotes the set of</span>
<span class="w"> </span>    neighbors of $u$.

<span class="w"> </span>    Parameters
<span class="gu">@@ -422,14 +481,24 @@ def cn_soundarajan_hopcroft(G, ebunch=None, community=&#39;community&#39;):</span>
<span class="w"> </span>       World Wide Web (WWW &#39;12 Companion). ACM, New York, NY, USA, 607-608.
<span class="w"> </span>       http://doi.acm.org/10.1145/2187980.2188150
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def predict(u, v):</span>
<span class="gi">+        Cu = _community(G, u, community)</span>
<span class="gi">+        Cv = _community(G, v, community)</span>
<span class="gi">+        cnbors = nx.common_neighbors(G, u, v)</span>
<span class="gi">+        neighbors = (</span>
<span class="gi">+            sum(_community(G, w, community) == Cu for w in cnbors) if Cu == Cv else 0</span>
<span class="gi">+        )</span>
<span class="gi">+        return len(cnbors) + neighbors</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(node_attrs=&#39;community&#39;)</span>
<span class="gd">-def ra_index_soundarajan_hopcroft(G, ebunch=None, community=&#39;community&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the resource allocation index of all node pairs in</span>
<span class="gi">+    return _apply_prediction(G, predict, ebunch)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;community&quot;)</span>
<span class="gi">+def ra_index_soundarajan_hopcroft(G, ebunch=None, community=&quot;community&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the resource allocation index of all node pairs in</span>
<span class="w"> </span>    ebunch using community information.

<span class="w"> </span>    For two nodes $u$ and $v$, this function computes the resource
<span class="gu">@@ -438,10 +507,10 @@ def ra_index_soundarajan_hopcroft(G, ebunch=None, community=&#39;community&#39;):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{f(w)}{|\\Gamma(w)|}</span>
<span class="gi">+        \sum_{w \in \Gamma(u) \cap \Gamma(v)} \frac{f(w)}{|\Gamma(w)|}</span>

<span class="w"> </span>    where $f(w)$ equals 1 if $w$ belongs to the same community as $u$
<span class="gd">-    and $v$ or 0 otherwise and $\\Gamma(u)$ denotes the set of</span>
<span class="gi">+    and $v$ or 0 otherwise and $\Gamma(u)$ denotes the set of</span>
<span class="w"> </span>    neighbors of $u$.

<span class="w"> </span>    Parameters
<span class="gu">@@ -500,13 +569,22 @@ def ra_index_soundarajan_hopcroft(G, ebunch=None, community=&#39;community&#39;):</span>
<span class="w"> </span>       World Wide Web (WWW &#39;12 Companion). ACM, New York, NY, USA, 607-608.
<span class="w"> </span>       http://doi.acm.org/10.1145/2187980.2188150
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def predict(u, v):</span>
<span class="gi">+        Cu = _community(G, u, community)</span>
<span class="gi">+        Cv = _community(G, v, community)</span>
<span class="gi">+        if Cu != Cv:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        cnbors = nx.common_neighbors(G, u, v)</span>
<span class="gi">+        return sum(1 / G.degree(w) for w in cnbors if _community(G, w, community) == Cu)</span>
<span class="gi">+</span>
<span class="gi">+    return _apply_prediction(G, predict, ebunch)</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(node_attrs=&#39;community&#39;)</span>
<span class="gd">-def within_inter_cluster(G, ebunch=None, delta=0.001, community=&#39;community&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;community&quot;)</span>
<span class="gi">+def within_inter_cluster(G, ebunch=None, delta=0.001, community=&quot;community&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute the ratio of within- and inter-cluster common neighbors
<span class="w"> </span>    of all node pairs in ebunch.

<span class="gu">@@ -583,9 +661,28 @@ def within_inter_cluster(G, ebunch=None, delta=0.001, community=&#39;community&#39;):</span>
<span class="w"> </span>       Artificial Intelligence (SBIA&#39;12)
<span class="w"> </span>       https://doi.org/10.1007/978-3-642-34459-6_10
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if delta &lt;= 0:</span>
<span class="gi">+        raise nx.NetworkXAlgorithmError(&quot;Delta must be greater than zero&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def predict(u, v):</span>
<span class="gi">+        Cu = _community(G, u, community)</span>
<span class="gi">+        Cv = _community(G, v, community)</span>
<span class="gi">+        if Cu != Cv:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        cnbors = nx.common_neighbors(G, u, v)</span>
<span class="gi">+        within = {w for w in cnbors if _community(G, w, community) == Cu}</span>
<span class="gi">+        inter = cnbors - within</span>
<span class="gi">+        return len(within) / (len(inter) + delta)</span>
<span class="gi">+</span>
<span class="gi">+    return _apply_prediction(G, predict, ebunch)</span>


<span class="w"> </span>def _community(G, u, community):
<span class="w"> </span>    &quot;&quot;&quot;Get the community of the given node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    node_u = G.nodes[u]</span>
<span class="gi">+    try:</span>
<span class="gi">+        return node_u[community]</span>
<span class="gi">+    except KeyError as err:</span>
<span class="gi">+        raise nx.NetworkXAlgorithmError(</span>
<span class="gi">+            f&quot;No community information available for Node {u}&quot;</span>
<span class="gi">+        ) from err</span>
<span class="gh">diff --git a/networkx/algorithms/lowest_common_ancestors.py b/networkx/algorithms/lowest_common_ancestors.py</span>
<span class="gh">index eada700b2..f695ec208 100644</span>
<span class="gd">--- a/networkx/algorithms/lowest_common_ancestors.py</span>
<span class="gi">+++ b/networkx/algorithms/lowest_common_ancestors.py</span>
<span class="gu">@@ -2,13 +2,18 @@</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from collections.abc import Mapping, Set
<span class="w"> </span>from itertools import combinations_with_replacement
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import UnionFind, arbitrary_element, not_implemented_for
<span class="gd">-__all__ = [&#39;all_pairs_lowest_common_ancestor&#39;,</span>
<span class="gd">-    &#39;tree_all_pairs_lowest_common_ancestor&#39;, &#39;lowest_common_ancestor&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;all_pairs_lowest_common_ancestor&quot;,</span>
<span class="gi">+    &quot;tree_all_pairs_lowest_common_ancestor&quot;,</span>
<span class="gi">+    &quot;lowest_common_ancestor&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def all_pairs_lowest_common_ancestor(G, pairs=None):
<span class="w"> </span>    &quot;&quot;&quot;Return the lowest common ancestor of all pairs or the provided pairs
<span class="gu">@@ -58,10 +63,55 @@ def all_pairs_lowest_common_ancestor(G, pairs=None):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    lowest_common_ancestor
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    if not nx.is_directed_acyclic_graph(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;LCA only defined on directed acyclic graphs.&quot;)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;LCA meaningless on null graphs.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if pairs is None:</span>
<span class="gi">+        pairs = combinations_with_replacement(G, 2)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Convert iterator to iterable, if necessary. Trim duplicates.</span>
<span class="gi">+        pairs = dict.fromkeys(pairs)</span>
<span class="gi">+        # Verify that each of the nodes in the provided pairs is in G</span>
<span class="gi">+        nodeset = set(G)</span>
<span class="gi">+        for pair in pairs:</span>
<span class="gi">+            if set(pair) - nodeset:</span>
<span class="gi">+                raise nx.NodeNotFound(</span>
<span class="gi">+                    f&quot;Node(s) {set(pair) - nodeset} from pair {pair} not in G.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    # Once input validation is done, construct the generator</span>
<span class="gi">+    def generate_lca_from_pairs(G, pairs):</span>
<span class="gi">+        ancestor_cache = {}</span>
<span class="gi">+</span>
<span class="gi">+        for v, w in pairs:</span>
<span class="gi">+            if v not in ancestor_cache:</span>
<span class="gi">+                ancestor_cache[v] = nx.ancestors(G, v)</span>
<span class="gi">+                ancestor_cache[v].add(v)</span>
<span class="gi">+            if w not in ancestor_cache:</span>
<span class="gi">+                ancestor_cache[w] = nx.ancestors(G, w)</span>
<span class="gi">+                ancestor_cache[w].add(w)</span>
<span class="gi">+</span>
<span class="gi">+            common_ancestors = ancestor_cache[v] &amp; ancestor_cache[w]</span>
<span class="gi">+</span>
<span class="gi">+            if common_ancestors:</span>
<span class="gi">+                common_ancestor = next(iter(common_ancestors))</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    successor = None</span>
<span class="gi">+                    for lower_ancestor in G.successors(common_ancestor):</span>
<span class="gi">+                        if lower_ancestor in common_ancestors:</span>
<span class="gi">+                            successor = lower_ancestor</span>
<span class="gi">+                            break</span>
<span class="gi">+                    if successor is None:</span>
<span class="gi">+                        break</span>
<span class="gi">+                    common_ancestor = successor</span>
<span class="gi">+                yield ((v, w), common_ancestor)</span>
<span class="gi">+</span>
<span class="gi">+    return generate_lca_from_pairs(G, pairs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def lowest_common_ancestor(G, node1, node2, default=None):
<span class="w"> </span>    &quot;&quot;&quot;Compute the lowest common ancestor of the given pair of nodes.
<span class="gu">@@ -91,13 +141,18 @@ def lowest_common_ancestor(G, node1, node2, default=None):</span>
<span class="w"> </span>    See Also
<span class="w"> </span>    --------
<span class="w"> </span>    all_pairs_lowest_common_ancestor&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    ans = list(all_pairs_lowest_common_ancestor(G, pairs=[(node1, node2)]))</span>
<span class="gi">+    if ans:</span>
<span class="gi">+        assert len(ans) == 1</span>
<span class="gi">+        return ans[0][1]</span>
<span class="gi">+    return default</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def tree_all_pairs_lowest_common_ancestor(G, root=None, pairs=None):
<span class="gd">-    &quot;&quot;&quot;Yield the lowest common ancestor for sets of pairs in a tree.</span>
<span class="gi">+    r&quot;&quot;&quot;Yield the lowest common ancestor for sets of pairs in a tree.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -142,7 +197,7 @@ def tree_all_pairs_lowest_common_ancestor(G, root=None, pairs=None):</span>
<span class="w"> </span>    -----
<span class="w"> </span>    Only defined on non-null trees represented with directed edges from
<span class="w"> </span>    parents to children. Uses Tarjan&#39;s off-line lowest-common-ancestors
<span class="gd">-    algorithm. Runs in time $O(4 \\times (V + E + P))$ time, where 4 is the largest</span>
<span class="gi">+    algorithm. Runs in time $O(4 \times (V + E + P))$ time, where 4 is the largest</span>
<span class="w"> </span>    value of the inverse Ackermann function likely to ever come up in actual
<span class="w"> </span>    use, and $P$ is the number of pairs requested (or $V^2$ if all are needed).

<span class="gu">@@ -154,4 +209,60 @@ def tree_all_pairs_lowest_common_ancestor(G, root=None, pairs=None):</span>
<span class="w"> </span>    all_pairs_lowest_common_ancestor: similar routine for general DAGs
<span class="w"> </span>    lowest_common_ancestor: just a single pair for general DAGs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;LCA meaningless on null graphs.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Index pairs of interest for efficient lookup from either side.</span>
<span class="gi">+    if pairs is not None:</span>
<span class="gi">+        pair_dict = defaultdict(set)</span>
<span class="gi">+        # See note on all_pairs_lowest_common_ancestor.</span>
<span class="gi">+        if not isinstance(pairs, Mapping | Set):</span>
<span class="gi">+            pairs = set(pairs)</span>
<span class="gi">+        for u, v in pairs:</span>
<span class="gi">+            for n in (u, v):</span>
<span class="gi">+                if n not in G:</span>
<span class="gi">+                    msg = f&quot;The node {str(n)} is not in the digraph.&quot;</span>
<span class="gi">+                    raise nx.NodeNotFound(msg)</span>
<span class="gi">+            pair_dict[u].add(v)</span>
<span class="gi">+            pair_dict[v].add(u)</span>
<span class="gi">+</span>
<span class="gi">+    # If root is not specified, find the exactly one node with in degree 0 and</span>
<span class="gi">+    # use it. Raise an error if none are found, or more than one is. Also check</span>
<span class="gi">+    # for any nodes with in degree larger than 1, which would imply G is not a</span>
<span class="gi">+    # tree.</span>
<span class="gi">+    if root is None:</span>
<span class="gi">+        for n, deg in G.in_degree:</span>
<span class="gi">+            if deg == 0:</span>
<span class="gi">+                if root is not None:</span>
<span class="gi">+                    msg = &quot;No root specified and tree has multiple sources.&quot;</span>
<span class="gi">+                    raise nx.NetworkXError(msg)</span>
<span class="gi">+                root = n</span>
<span class="gi">+            # checking deg&gt;1 is not sufficient for MultiDiGraphs</span>
<span class="gi">+            elif deg &gt; 1 and len(G.pred[n]) &gt; 1:</span>
<span class="gi">+                msg = &quot;Tree LCA only defined on trees; use DAG routine.&quot;</span>
<span class="gi">+                raise nx.NetworkXError(msg)</span>
<span class="gi">+    if root is None:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph contains a cycle.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Iterative implementation of Tarjan&#39;s offline lca algorithm</span>
<span class="gi">+    # as described in CLRS on page 521 (2nd edition)/page 584 (3rd edition)</span>
<span class="gi">+    uf = UnionFind()</span>
<span class="gi">+    ancestors = {}</span>
<span class="gi">+    for node in G:</span>
<span class="gi">+        ancestors[node] = uf[node]</span>
<span class="gi">+</span>
<span class="gi">+    colors = defaultdict(bool)</span>
<span class="gi">+    for node in nx.dfs_postorder_nodes(G, root):</span>
<span class="gi">+        colors[node] = True</span>
<span class="gi">+        for v in pair_dict[node] if pairs is not None else G:</span>
<span class="gi">+            if colors[v]:</span>
<span class="gi">+                # If the user requested both directions of a pair, give it.</span>
<span class="gi">+                # Otherwise, just give one.</span>
<span class="gi">+                if pairs is not None and (node, v) in pairs:</span>
<span class="gi">+                    yield (node, v), ancestors[uf[v]]</span>
<span class="gi">+                if pairs is None or (v, node) in pairs:</span>
<span class="gi">+                    yield (v, node), ancestors[uf[v]]</span>
<span class="gi">+        if node != root:</span>
<span class="gi">+            parent = arbitrary_element(G.pred[node])</span>
<span class="gi">+            uf.union(parent, node)</span>
<span class="gi">+            ancestors[uf[parent]] = parent</span>
<span class="gh">diff --git a/networkx/algorithms/matching.py b/networkx/algorithms/matching.py</span>
<span class="gh">index 5ab7a21ea..f346c2e05 100644</span>
<span class="gd">--- a/networkx/algorithms/matching.py</span>
<span class="gi">+++ b/networkx/algorithms/matching.py</span>
<span class="gu">@@ -1,17 +1,25 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing and verifying matchings in a graph.&quot;&quot;&quot;
<span class="w"> </span>from collections import Counter
<span class="w"> </span>from itertools import combinations, repeat
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;is_matching&#39;, &#39;is_maximal_matching&#39;, &#39;is_perfect_matching&#39;,</span>
<span class="gd">-    &#39;max_weight_matching&#39;, &#39;min_weight_matching&#39;, &#39;maximal_matching&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;is_matching&quot;,</span>
<span class="gi">+    &quot;is_maximal_matching&quot;,</span>
<span class="gi">+    &quot;is_perfect_matching&quot;,</span>
<span class="gi">+    &quot;max_weight_matching&quot;,</span>
<span class="gi">+    &quot;min_weight_matching&quot;,</span>
<span class="gi">+    &quot;maximal_matching&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def maximal_matching(G):
<span class="gd">-    &quot;&quot;&quot;Find a maximal matching in the graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Find a maximal matching in the graph.</span>

<span class="w"> </span>    A matching is a subset of edges in which no node occurs more than once.
<span class="w"> </span>    A maximal matching cannot add more edges and still be a matching.
<span class="gu">@@ -37,7 +45,16 @@ def maximal_matching(G):</span>
<span class="w"> </span>    The algorithm greedily selects a maximal matching M of the graph G
<span class="w"> </span>    (i.e. no superset of M exists). It runs in $O(|E|)$ time.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    matching = set()</span>
<span class="gi">+    nodes = set()</span>
<span class="gi">+    for edge in G.edges():</span>
<span class="gi">+        # If the edge isn&#39;t covered, add it to the matching</span>
<span class="gi">+        # then remove neighborhood of u and v from consideration.</span>
<span class="gi">+        u, v = edge</span>
<span class="gi">+        if u not in nodes and v not in nodes and u != v:</span>
<span class="gi">+            matching.add(edge)</span>
<span class="gi">+            nodes.update(edge)</span>
<span class="gi">+    return matching</span>


<span class="w"> </span>def matching_dict_to_set(matching):
<span class="gu">@@ -54,7 +71,15 @@ def matching_dict_to_set(matching):</span>
<span class="w"> </span>    example, key ``u`` with value ``v`` and key ``v`` with value ``u``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = set()</span>
<span class="gi">+    for edge in matching.items():</span>
<span class="gi">+        u, v = edge</span>
<span class="gi">+        if (v, u) in edges or edge in edges:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if u == v:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;Selfloops cannot appear in matchings {edge}&quot;)</span>
<span class="gi">+        edges.add(edge)</span>
<span class="gi">+    return edges</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -98,7 +123,24 @@ def is_matching(G, matching):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(matching, dict):</span>
<span class="gi">+        matching = matching_dict_to_set(matching)</span>
<span class="gi">+</span>
<span class="gi">+    nodes = set()</span>
<span class="gi">+    for edge in matching:</span>
<span class="gi">+        if len(edge) != 2:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;matching has non-2-tuple edge {edge}&quot;)</span>
<span class="gi">+        u, v = edge</span>
<span class="gi">+        if u not in G or v not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;matching contains edge {edge} with node not in G&quot;)</span>
<span class="gi">+        if u == v:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not G.has_edge(u, v):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if u in nodes or v in nodes:</span>
<span class="gi">+            return False</span>
<span class="gi">+        nodes.update(edge)</span>
<span class="gi">+    return True</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -132,7 +174,35 @@ def is_maximal_matching(G, matching):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(matching, dict):</span>
<span class="gi">+        matching = matching_dict_to_set(matching)</span>
<span class="gi">+    # If the given set is not a matching, then it is not a maximal matching.</span>
<span class="gi">+    edges = set()</span>
<span class="gi">+    nodes = set()</span>
<span class="gi">+    for edge in matching:</span>
<span class="gi">+        if len(edge) != 2:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;matching has non-2-tuple edge {edge}&quot;)</span>
<span class="gi">+        u, v = edge</span>
<span class="gi">+        if u not in G or v not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;matching contains edge {edge} with node not in G&quot;)</span>
<span class="gi">+        if u == v:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not G.has_edge(u, v):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if u in nodes or v in nodes:</span>
<span class="gi">+            return False</span>
<span class="gi">+        nodes.update(edge)</span>
<span class="gi">+        edges.add(edge)</span>
<span class="gi">+        edges.add((v, u))</span>
<span class="gi">+    # A matching is maximal if adding any new edge from G to it</span>
<span class="gi">+    # causes the resulting set to match some node twice.</span>
<span class="gi">+    # Be careful to check for adding selfloops</span>
<span class="gi">+    for u, v in G.edges:</span>
<span class="gi">+        if (u, v) not in edges:</span>
<span class="gi">+            # could add edge (u, v) to edges and have a bigger matching</span>
<span class="gi">+            if u not in nodes and v not in nodes and u != v:</span>
<span class="gi">+                return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -167,13 +237,30 @@ def is_perfect_matching(G, matching):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def min_weight_matching(G, weight=&#39;weight&#39;):</span>
<span class="gi">+    if isinstance(matching, dict):</span>
<span class="gi">+        matching = matching_dict_to_set(matching)</span>
<span class="gi">+</span>
<span class="gi">+    nodes = set()</span>
<span class="gi">+    for edge in matching:</span>
<span class="gi">+        if len(edge) != 2:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;matching has non-2-tuple edge {edge}&quot;)</span>
<span class="gi">+        u, v = edge</span>
<span class="gi">+        if u not in G or v not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;matching contains edge {edge} with node not in G&quot;)</span>
<span class="gi">+        if u == v:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not G.has_edge(u, v):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if u in nodes or v in nodes:</span>
<span class="gi">+            return False</span>
<span class="gi">+        nodes.update(edge)</span>
<span class="gi">+    return len(nodes) == len(G)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def min_weight_matching(G, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Computing a minimum-weight maximal matching of G.

<span class="w"> </span>    Use the maximum-weight algorithm with edge weights subtracted
<span class="gu">@@ -221,13 +308,20 @@ def min_weight_matching(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    max_weight_matching
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def max_weight_matching(G, maxcardinality=False, weight=&#39;weight&#39;):</span>
<span class="gi">+    if len(G.edges) == 0:</span>
<span class="gi">+        return max_weight_matching(G, maxcardinality=True, weight=weight)</span>
<span class="gi">+    G_edges = G.edges(data=weight, default=1)</span>
<span class="gi">+    max_weight = 1 + max(w for _, _, w in G_edges)</span>
<span class="gi">+    InvG = nx.Graph()</span>
<span class="gi">+    edges = ((u, v, max_weight - w) for u, v, w in G_edges)</span>
<span class="gi">+    InvG.add_weighted_edges_from(edges, weight=weight)</span>
<span class="gi">+    return max_weight_matching(InvG, maxcardinality=True, weight=weight)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def max_weight_matching(G, maxcardinality=False, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute a maximum-weighted matching of G.

<span class="w"> </span>    A matching is a subset of edges in which no node occurs more than once.
<span class="gu">@@ -286,4 +380,772 @@ def max_weight_matching(G, maxcardinality=False, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    .. [1] &quot;Efficient Algorithms for Finding Maximum Matching in Graphs&quot;,
<span class="w"> </span>       Zvi Galil, ACM Computing Surveys, 1986.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    #</span>
<span class="gi">+    # The algorithm is taken from &quot;Efficient Algorithms for Finding Maximum</span>
<span class="gi">+    # Matching in Graphs&quot; by Zvi Galil, ACM Computing Surveys, 1986.</span>
<span class="gi">+    # It is based on the &quot;blossom&quot; method for finding augmenting paths and</span>
<span class="gi">+    # the &quot;primal-dual&quot; method for finding a matching of maximum weight, both</span>
<span class="gi">+    # methods invented by Jack Edmonds.</span>
<span class="gi">+    #</span>
<span class="gi">+    # A C program for maximum weight matching by Ed Rothberg was used</span>
<span class="gi">+    # extensively to validate this new code.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Many terms used in the code comments are explained in the paper</span>
<span class="gi">+    # by Galil. You will probably need the paper to make sense of this code.</span>
<span class="gi">+    #</span>
<span class="gi">+</span>
<span class="gi">+    class NoNode:</span>
<span class="gi">+        &quot;&quot;&quot;Dummy value which is different from any node.&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    class Blossom:</span>
<span class="gi">+        &quot;&quot;&quot;Representation of a non-trivial blossom or sub-blossom.&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        __slots__ = [&quot;childs&quot;, &quot;edges&quot;, &quot;mybestedges&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        # b.childs is an ordered list of b&#39;s sub-blossoms, starting with</span>
<span class="gi">+        # the base and going round the blossom.</span>
<span class="gi">+</span>
<span class="gi">+        # b.edges is the list of b&#39;s connecting edges, such that</span>
<span class="gi">+        # b.edges[i] = (v, w) where v is a vertex in b.childs[i]</span>
<span class="gi">+        # and w is a vertex in b.childs[wrap(i+1)].</span>
<span class="gi">+</span>
<span class="gi">+        # If b is a top-level S-blossom,</span>
<span class="gi">+        # b.mybestedges is a list of least-slack edges to neighboring</span>
<span class="gi">+        # S-blossoms, or None if no such list has been computed yet.</span>
<span class="gi">+        # This is used for efficient computation of delta3.</span>
<span class="gi">+</span>
<span class="gi">+        # Generate the blossom&#39;s leaf vertices.</span>
<span class="gi">+        def leaves(self):</span>
<span class="gi">+            stack = [*self.childs]</span>
<span class="gi">+            while stack:</span>
<span class="gi">+                t = stack.pop()</span>
<span class="gi">+                if isinstance(t, Blossom):</span>
<span class="gi">+                    stack.extend(t.childs)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield t</span>
<span class="gi">+</span>
<span class="gi">+    # Get a list of vertices.</span>
<span class="gi">+    gnodes = list(G)</span>
<span class="gi">+    if not gnodes:</span>
<span class="gi">+        return set()  # don&#39;t bother with empty graphs</span>
<span class="gi">+</span>
<span class="gi">+    # Find the maximum edge weight.</span>
<span class="gi">+    maxweight = 0</span>
<span class="gi">+    allinteger = True</span>
<span class="gi">+    for i, j, d in G.edges(data=True):</span>
<span class="gi">+        wt = d.get(weight, 1)</span>
<span class="gi">+        if i != j and wt &gt; maxweight:</span>
<span class="gi">+            maxweight = wt</span>
<span class="gi">+        allinteger = allinteger and (str(type(wt)).split(&quot;&#39;&quot;)[1] in (&quot;int&quot;, &quot;long&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    # If v is a matched vertex, mate[v] is its partner vertex.</span>
<span class="gi">+    # If v is a single vertex, v does not occur as a key in mate.</span>
<span class="gi">+    # Initially all vertices are single; updated during augmentation.</span>
<span class="gi">+    mate = {}</span>
<span class="gi">+</span>
<span class="gi">+    # If b is a top-level blossom,</span>
<span class="gi">+    # label.get(b) is None if b is unlabeled (free),</span>
<span class="gi">+    #                 1 if b is an S-blossom,</span>
<span class="gi">+    #                 2 if b is a T-blossom.</span>
<span class="gi">+    # The label of a vertex is found by looking at the label of its top-level</span>
<span class="gi">+    # containing blossom.</span>
<span class="gi">+    # If v is a vertex inside a T-blossom, label[v] is 2 iff v is reachable</span>
<span class="gi">+    # from an S-vertex outside the blossom.</span>
<span class="gi">+    # Labels are assigned during a stage and reset after each augmentation.</span>
<span class="gi">+    label = {}</span>
<span class="gi">+</span>
<span class="gi">+    # If b is a labeled top-level blossom,</span>
<span class="gi">+    # labeledge[b] = (v, w) is the edge through which b obtained its label</span>
<span class="gi">+    # such that w is a vertex in b, or None if b&#39;s base vertex is single.</span>
<span class="gi">+    # If w is a vertex inside a T-blossom and label[w] == 2,</span>
<span class="gi">+    # labeledge[w] = (v, w) is an edge through which w is reachable from</span>
<span class="gi">+    # outside the blossom.</span>
<span class="gi">+    labeledge = {}</span>
<span class="gi">+</span>
<span class="gi">+    # If v is a vertex, inblossom[v] is the top-level blossom to which v</span>
<span class="gi">+    # belongs.</span>
<span class="gi">+    # If v is a top-level vertex, inblossom[v] == v since v is itself</span>
<span class="gi">+    # a (trivial) top-level blossom.</span>
<span class="gi">+    # Initially all vertices are top-level trivial blossoms.</span>
<span class="gi">+    inblossom = dict(zip(gnodes, gnodes))</span>
<span class="gi">+</span>
<span class="gi">+    # If b is a sub-blossom,</span>
<span class="gi">+    # blossomparent[b] is its immediate parent (sub-)blossom.</span>
<span class="gi">+    # If b is a top-level blossom, blossomparent[b] is None.</span>
<span class="gi">+    blossomparent = dict(zip(gnodes, repeat(None)))</span>
<span class="gi">+</span>
<span class="gi">+    # If b is a (sub-)blossom,</span>
<span class="gi">+    # blossombase[b] is its base VERTEX (i.e. recursive sub-blossom).</span>
<span class="gi">+    blossombase = dict(zip(gnodes, gnodes))</span>
<span class="gi">+</span>
<span class="gi">+    # If w is a free vertex (or an unreached vertex inside a T-blossom),</span>
<span class="gi">+    # bestedge[w] = (v, w) is the least-slack edge from an S-vertex,</span>
<span class="gi">+    # or None if there is no such edge.</span>
<span class="gi">+    # If b is a (possibly trivial) top-level S-blossom,</span>
<span class="gi">+    # bestedge[b] = (v, w) is the least-slack edge to a different S-blossom</span>
<span class="gi">+    # (v inside b), or None if there is no such edge.</span>
<span class="gi">+    # This is used for efficient computation of delta2 and delta3.</span>
<span class="gi">+    bestedge = {}</span>
<span class="gi">+</span>
<span class="gi">+    # If v is a vertex,</span>
<span class="gi">+    # dualvar[v] = 2 * u(v) where u(v) is the v&#39;s variable in the dual</span>
<span class="gi">+    # optimization problem (if all edge weights are integers, multiplication</span>
<span class="gi">+    # by two ensures that all values remain integers throughout the algorithm).</span>
<span class="gi">+    # Initially, u(v) = maxweight / 2.</span>
<span class="gi">+    dualvar = dict(zip(gnodes, repeat(maxweight)))</span>
<span class="gi">+</span>
<span class="gi">+    # If b is a non-trivial blossom,</span>
<span class="gi">+    # blossomdual[b] = z(b) where z(b) is b&#39;s variable in the dual</span>
<span class="gi">+    # optimization problem.</span>
<span class="gi">+    blossomdual = {}</span>
<span class="gi">+</span>
<span class="gi">+    # If (v, w) in allowedge or (w, v) in allowedg, then the edge</span>
<span class="gi">+    # (v, w) is known to have zero slack in the optimization problem;</span>
<span class="gi">+    # otherwise the edge may or may not have zero slack.</span>
<span class="gi">+    allowedge = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Queue of newly discovered S-vertices.</span>
<span class="gi">+    queue = []</span>
<span class="gi">+</span>
<span class="gi">+    # Return 2 * slack of edge (v, w) (does not work inside blossoms).</span>
<span class="gi">+    def slack(v, w):</span>
<span class="gi">+        return dualvar[v] + dualvar[w] - 2 * G[v][w].get(weight, 1)</span>
<span class="gi">+</span>
<span class="gi">+    # Assign label t to the top-level blossom containing vertex w,</span>
<span class="gi">+    # coming through an edge from vertex v.</span>
<span class="gi">+    def assignLabel(w, t, v):</span>
<span class="gi">+        b = inblossom[w]</span>
<span class="gi">+        assert label.get(w) is None and label.get(b) is None</span>
<span class="gi">+        label[w] = label[b] = t</span>
<span class="gi">+        if v is not None:</span>
<span class="gi">+            labeledge[w] = labeledge[b] = (v, w)</span>
<span class="gi">+        else:</span>
<span class="gi">+            labeledge[w] = labeledge[b] = None</span>
<span class="gi">+        bestedge[w] = bestedge[b] = None</span>
<span class="gi">+        if t == 1:</span>
<span class="gi">+            # b became an S-vertex/blossom; add it(s vertices) to the queue.</span>
<span class="gi">+            if isinstance(b, Blossom):</span>
<span class="gi">+                queue.extend(b.leaves())</span>
<span class="gi">+            else:</span>
<span class="gi">+                queue.append(b)</span>
<span class="gi">+        elif t == 2:</span>
<span class="gi">+            # b became a T-vertex/blossom; assign label S to its mate.</span>
<span class="gi">+            # (If b is a non-trivial blossom, its base is the only vertex</span>
<span class="gi">+            # with an external mate.)</span>
<span class="gi">+            base = blossombase[b]</span>
<span class="gi">+            assignLabel(mate[base], 1, base)</span>
<span class="gi">+</span>
<span class="gi">+    # Trace back from vertices v and w to discover either a new blossom</span>
<span class="gi">+    # or an augmenting path. Return the base vertex of the new blossom,</span>
<span class="gi">+    # or NoNode if an augmenting path was found.</span>
<span class="gi">+    def scanBlossom(v, w):</span>
<span class="gi">+        # Trace back from v and w, placing breadcrumbs as we go.</span>
<span class="gi">+        path = []</span>
<span class="gi">+        base = NoNode</span>
<span class="gi">+        while v is not NoNode:</span>
<span class="gi">+            # Look for a breadcrumb in v&#39;s blossom or put a new breadcrumb.</span>
<span class="gi">+            b = inblossom[v]</span>
<span class="gi">+            if label[b] &amp; 4:</span>
<span class="gi">+                base = blossombase[b]</span>
<span class="gi">+                break</span>
<span class="gi">+            assert label[b] == 1</span>
<span class="gi">+            path.append(b)</span>
<span class="gi">+            label[b] = 5</span>
<span class="gi">+            # Trace one step back.</span>
<span class="gi">+            if labeledge[b] is None:</span>
<span class="gi">+                # The base of blossom b is single; stop tracing this path.</span>
<span class="gi">+                assert blossombase[b] not in mate</span>
<span class="gi">+                v = NoNode</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert labeledge[b][0] == mate[blossombase[b]]</span>
<span class="gi">+                v = labeledge[b][0]</span>
<span class="gi">+                b = inblossom[v]</span>
<span class="gi">+                assert label[b] == 2</span>
<span class="gi">+                # b is a T-blossom; trace one more step back.</span>
<span class="gi">+                v = labeledge[b][0]</span>
<span class="gi">+            # Swap v and w so that we alternate between both paths.</span>
<span class="gi">+            if w is not NoNode:</span>
<span class="gi">+                v, w = w, v</span>
<span class="gi">+        # Remove breadcrumbs.</span>
<span class="gi">+        for b in path:</span>
<span class="gi">+            label[b] = 1</span>
<span class="gi">+        # Return base vertex, if we found one.</span>
<span class="gi">+        return base</span>
<span class="gi">+</span>
<span class="gi">+    # Construct a new blossom with given base, through S-vertices v and w.</span>
<span class="gi">+    # Label the new blossom as S; set its dual variable to zero;</span>
<span class="gi">+    # relabel its T-vertices to S and add them to the queue.</span>
<span class="gi">+    def addBlossom(base, v, w):</span>
<span class="gi">+        bb = inblossom[base]</span>
<span class="gi">+        bv = inblossom[v]</span>
<span class="gi">+        bw = inblossom[w]</span>
<span class="gi">+        # Create blossom.</span>
<span class="gi">+        b = Blossom()</span>
<span class="gi">+        blossombase[b] = base</span>
<span class="gi">+        blossomparent[b] = None</span>
<span class="gi">+        blossomparent[bb] = b</span>
<span class="gi">+        # Make list of sub-blossoms and their interconnecting edge endpoints.</span>
<span class="gi">+        b.childs = path = []</span>
<span class="gi">+        b.edges = edgs = [(v, w)]</span>
<span class="gi">+        # Trace back from v to base.</span>
<span class="gi">+        while bv != bb:</span>
<span class="gi">+            # Add bv to the new blossom.</span>
<span class="gi">+            blossomparent[bv] = b</span>
<span class="gi">+            path.append(bv)</span>
<span class="gi">+            edgs.append(labeledge[bv])</span>
<span class="gi">+            assert label[bv] == 2 or (</span>
<span class="gi">+                label[bv] == 1 and labeledge[bv][0] == mate[blossombase[bv]]</span>
<span class="gi">+            )</span>
<span class="gi">+            # Trace one step back.</span>
<span class="gi">+            v = labeledge[bv][0]</span>
<span class="gi">+            bv = inblossom[v]</span>
<span class="gi">+        # Add base sub-blossom; reverse lists.</span>
<span class="gi">+        path.append(bb)</span>
<span class="gi">+        path.reverse()</span>
<span class="gi">+        edgs.reverse()</span>
<span class="gi">+        # Trace back from w to base.</span>
<span class="gi">+        while bw != bb:</span>
<span class="gi">+            # Add bw to the new blossom.</span>
<span class="gi">+            blossomparent[bw] = b</span>
<span class="gi">+            path.append(bw)</span>
<span class="gi">+            edgs.append((labeledge[bw][1], labeledge[bw][0]))</span>
<span class="gi">+            assert label[bw] == 2 or (</span>
<span class="gi">+                label[bw] == 1 and labeledge[bw][0] == mate[blossombase[bw]]</span>
<span class="gi">+            )</span>
<span class="gi">+            # Trace one step back.</span>
<span class="gi">+            w = labeledge[bw][0]</span>
<span class="gi">+            bw = inblossom[w]</span>
<span class="gi">+        # Set label to S.</span>
<span class="gi">+        assert label[bb] == 1</span>
<span class="gi">+        label[b] = 1</span>
<span class="gi">+        labeledge[b] = labeledge[bb]</span>
<span class="gi">+        # Set dual variable to zero.</span>
<span class="gi">+        blossomdual[b] = 0</span>
<span class="gi">+        # Relabel vertices.</span>
<span class="gi">+        for v in b.leaves():</span>
<span class="gi">+            if label[inblossom[v]] == 2:</span>
<span class="gi">+                # This T-vertex now turns into an S-vertex because it becomes</span>
<span class="gi">+                # part of an S-blossom; add it to the queue.</span>
<span class="gi">+                queue.append(v)</span>
<span class="gi">+            inblossom[v] = b</span>
<span class="gi">+        # Compute b.mybestedges.</span>
<span class="gi">+        bestedgeto = {}</span>
<span class="gi">+        for bv in path:</span>
<span class="gi">+            if isinstance(bv, Blossom):</span>
<span class="gi">+                if bv.mybestedges is not None:</span>
<span class="gi">+                    # Walk this subblossom&#39;s least-slack edges.</span>
<span class="gi">+                    nblist = bv.mybestedges</span>
<span class="gi">+                    # The sub-blossom won&#39;t need this data again.</span>
<span class="gi">+                    bv.mybestedges = None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # This subblossom does not have a list of least-slack</span>
<span class="gi">+                    # edges; get the information from the vertices.</span>
<span class="gi">+                    nblist = [</span>
<span class="gi">+                        (v, w) for v in bv.leaves() for w in G.neighbors(v) if v != w</span>
<span class="gi">+                    ]</span>
<span class="gi">+            else:</span>
<span class="gi">+                nblist = [(bv, w) for w in G.neighbors(bv) if bv != w]</span>
<span class="gi">+            for k in nblist:</span>
<span class="gi">+                (i, j) = k</span>
<span class="gi">+                if inblossom[j] == b:</span>
<span class="gi">+                    i, j = j, i</span>
<span class="gi">+                bj = inblossom[j]</span>
<span class="gi">+                if (</span>
<span class="gi">+                    bj != b</span>
<span class="gi">+                    and label.get(bj) == 1</span>
<span class="gi">+                    and ((bj not in bestedgeto) or slack(i, j) &lt; slack(*bestedgeto[bj]))</span>
<span class="gi">+                ):</span>
<span class="gi">+                    bestedgeto[bj] = k</span>
<span class="gi">+            # Forget about least-slack edge of the subblossom.</span>
<span class="gi">+            bestedge[bv] = None</span>
<span class="gi">+        b.mybestedges = list(bestedgeto.values())</span>
<span class="gi">+        # Select bestedge[b].</span>
<span class="gi">+        mybestedge = None</span>
<span class="gi">+        bestedge[b] = None</span>
<span class="gi">+        for k in b.mybestedges:</span>
<span class="gi">+            kslack = slack(*k)</span>
<span class="gi">+            if mybestedge is None or kslack &lt; mybestslack:</span>
<span class="gi">+                mybestedge = k</span>
<span class="gi">+                mybestslack = kslack</span>
<span class="gi">+        bestedge[b] = mybestedge</span>
<span class="gi">+</span>
<span class="gi">+    # Expand the given top-level blossom.</span>
<span class="gi">+    def expandBlossom(b, endstage):</span>
<span class="gi">+        # This is an obnoxiously complicated recursive function for the sake of</span>
<span class="gi">+        # a stack-transformation.  So, we hack around the complexity by using</span>
<span class="gi">+        # a trampoline pattern.  By yielding the arguments to each recursive</span>
<span class="gi">+        # call, we keep the actual callstack flat.</span>
<span class="gi">+</span>
<span class="gi">+        def _recurse(b, endstage):</span>
<span class="gi">+            # Convert sub-blossoms into top-level blossoms.</span>
<span class="gi">+            for s in b.childs:</span>
<span class="gi">+                blossomparent[s] = None</span>
<span class="gi">+                if isinstance(s, Blossom):</span>
<span class="gi">+                    if endstage and blossomdual[s] == 0:</span>
<span class="gi">+                        # Recursively expand this sub-blossom.</span>
<span class="gi">+                        yield s</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        for v in s.leaves():</span>
<span class="gi">+                            inblossom[v] = s</span>
<span class="gi">+                else:</span>
<span class="gi">+                    inblossom[s] = s</span>
<span class="gi">+            # If we expand a T-blossom during a stage, its sub-blossoms must be</span>
<span class="gi">+            # relabeled.</span>
<span class="gi">+            if (not endstage) and label.get(b) == 2:</span>
<span class="gi">+                # Start at the sub-blossom through which the expanding</span>
<span class="gi">+                # blossom obtained its label, and relabel sub-blossoms untili</span>
<span class="gi">+                # we reach the base.</span>
<span class="gi">+                # Figure out through which sub-blossom the expanding blossom</span>
<span class="gi">+                # obtained its label initially.</span>
<span class="gi">+                entrychild = inblossom[labeledge[b][1]]</span>
<span class="gi">+                # Decide in which direction we will go round the blossom.</span>
<span class="gi">+                j = b.childs.index(entrychild)</span>
<span class="gi">+                if j &amp; 1:</span>
<span class="gi">+                    # Start index is odd; go forward and wrap.</span>
<span class="gi">+                    j -= len(b.childs)</span>
<span class="gi">+                    jstep = 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Start index is even; go backward.</span>
<span class="gi">+                    jstep = -1</span>
<span class="gi">+                # Move along the blossom until we get to the base.</span>
<span class="gi">+                v, w = labeledge[b]</span>
<span class="gi">+                while j != 0:</span>
<span class="gi">+                    # Relabel the T-sub-blossom.</span>
<span class="gi">+                    if jstep == 1:</span>
<span class="gi">+                        p, q = b.edges[j]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        q, p = b.edges[j - 1]</span>
<span class="gi">+                    label[w] = None</span>
<span class="gi">+                    label[q] = None</span>
<span class="gi">+                    assignLabel(w, 2, v)</span>
<span class="gi">+                    # Step to the next S-sub-blossom and note its forward edge.</span>
<span class="gi">+                    allowedge[(p, q)] = allowedge[(q, p)] = True</span>
<span class="gi">+                    j += jstep</span>
<span class="gi">+                    if jstep == 1:</span>
<span class="gi">+                        v, w = b.edges[j]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        w, v = b.edges[j - 1]</span>
<span class="gi">+                    # Step to the next T-sub-blossom.</span>
<span class="gi">+                    allowedge[(v, w)] = allowedge[(w, v)] = True</span>
<span class="gi">+                    j += jstep</span>
<span class="gi">+                # Relabel the base T-sub-blossom WITHOUT stepping through to</span>
<span class="gi">+                # its mate (so don&#39;t call assignLabel).</span>
<span class="gi">+                bw = b.childs[j]</span>
<span class="gi">+                label[w] = label[bw] = 2</span>
<span class="gi">+                labeledge[w] = labeledge[bw] = (v, w)</span>
<span class="gi">+                bestedge[bw] = None</span>
<span class="gi">+                # Continue along the blossom until we get back to entrychild.</span>
<span class="gi">+                j += jstep</span>
<span class="gi">+                while b.childs[j] != entrychild:</span>
<span class="gi">+                    # Examine the vertices of the sub-blossom to see whether</span>
<span class="gi">+                    # it is reachable from a neighboring S-vertex outside the</span>
<span class="gi">+                    # expanding blossom.</span>
<span class="gi">+                    bv = b.childs[j]</span>
<span class="gi">+                    if label.get(bv) == 1:</span>
<span class="gi">+                        # This sub-blossom just got label S through one of its</span>
<span class="gi">+                        # neighbors; leave it be.</span>
<span class="gi">+                        j += jstep</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if isinstance(bv, Blossom):</span>
<span class="gi">+                        for v in bv.leaves():</span>
<span class="gi">+                            if label.get(v):</span>
<span class="gi">+                                break</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        v = bv</span>
<span class="gi">+                    # If the sub-blossom contains a reachable vertex, assign</span>
<span class="gi">+                    # label T to the sub-blossom.</span>
<span class="gi">+                    if label.get(v):</span>
<span class="gi">+                        assert label[v] == 2</span>
<span class="gi">+                        assert inblossom[v] == bv</span>
<span class="gi">+                        label[v] = None</span>
<span class="gi">+                        label[mate[blossombase[bv]]] = None</span>
<span class="gi">+                        assignLabel(v, 2, labeledge[v][0])</span>
<span class="gi">+                    j += jstep</span>
<span class="gi">+            # Remove the expanded blossom entirely.</span>
<span class="gi">+            label.pop(b, None)</span>
<span class="gi">+            labeledge.pop(b, None)</span>
<span class="gi">+            bestedge.pop(b, None)</span>
<span class="gi">+            del blossomparent[b]</span>
<span class="gi">+            del blossombase[b]</span>
<span class="gi">+            del blossomdual[b]</span>
<span class="gi">+</span>
<span class="gi">+        # Now, we apply the trampoline pattern.  We simulate a recursive</span>
<span class="gi">+        # callstack by maintaining a stack of generators, each yielding a</span>
<span class="gi">+        # sequence of function arguments.  We grow the stack by appending a call</span>
<span class="gi">+        # to _recurse on each argument tuple, and shrink the stack whenever a</span>
<span class="gi">+        # generator is exhausted.</span>
<span class="gi">+        stack = [_recurse(b, endstage)]</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            top = stack[-1]</span>
<span class="gi">+            for s in top:</span>
<span class="gi">+                stack.append(_recurse(s, endstage))</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+    # Swap matched/unmatched edges over an alternating path through blossom b</span>
<span class="gi">+    # between vertex v and the base vertex. Keep blossom bookkeeping</span>
<span class="gi">+    # consistent.</span>
<span class="gi">+    def augmentBlossom(b, v):</span>
<span class="gi">+        # This is an obnoxiously complicated recursive function for the sake of</span>
<span class="gi">+        # a stack-transformation.  So, we hack around the complexity by using</span>
<span class="gi">+        # a trampoline pattern.  By yielding the arguments to each recursive</span>
<span class="gi">+        # call, we keep the actual callstack flat.</span>
<span class="gi">+</span>
<span class="gi">+        def _recurse(b, v):</span>
<span class="gi">+            # Bubble up through the blossom tree from vertex v to an immediate</span>
<span class="gi">+            # sub-blossom of b.</span>
<span class="gi">+            t = v</span>
<span class="gi">+            while blossomparent[t] != b:</span>
<span class="gi">+                t = blossomparent[t]</span>
<span class="gi">+            # Recursively deal with the first sub-blossom.</span>
<span class="gi">+            if isinstance(t, Blossom):</span>
<span class="gi">+                yield (t, v)</span>
<span class="gi">+            # Decide in which direction we will go round the blossom.</span>
<span class="gi">+            i = j = b.childs.index(t)</span>
<span class="gi">+            if i &amp; 1:</span>
<span class="gi">+                # Start index is odd; go forward and wrap.</span>
<span class="gi">+                j -= len(b.childs)</span>
<span class="gi">+                jstep = 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Start index is even; go backward.</span>
<span class="gi">+                jstep = -1</span>
<span class="gi">+            # Move along the blossom until we get to the base.</span>
<span class="gi">+            while j != 0:</span>
<span class="gi">+                # Step to the next sub-blossom and augment it recursively.</span>
<span class="gi">+                j += jstep</span>
<span class="gi">+                t = b.childs[j]</span>
<span class="gi">+                if jstep == 1:</span>
<span class="gi">+                    w, x = b.edges[j]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    x, w = b.edges[j - 1]</span>
<span class="gi">+                if isinstance(t, Blossom):</span>
<span class="gi">+                    yield (t, w)</span>
<span class="gi">+                # Step to the next sub-blossom and augment it recursively.</span>
<span class="gi">+                j += jstep</span>
<span class="gi">+                t = b.childs[j]</span>
<span class="gi">+                if isinstance(t, Blossom):</span>
<span class="gi">+                    yield (t, x)</span>
<span class="gi">+                # Match the edge connecting those sub-blossoms.</span>
<span class="gi">+                mate[w] = x</span>
<span class="gi">+                mate[x] = w</span>
<span class="gi">+            # Rotate the list of sub-blossoms to put the new base at the front.</span>
<span class="gi">+            b.childs = b.childs[i:] + b.childs[:i]</span>
<span class="gi">+            b.edges = b.edges[i:] + b.edges[:i]</span>
<span class="gi">+            blossombase[b] = blossombase[b.childs[0]]</span>
<span class="gi">+            assert blossombase[b] == v</span>
<span class="gi">+</span>
<span class="gi">+        # Now, we apply the trampoline pattern.  We simulate a recursive</span>
<span class="gi">+        # callstack by maintaining a stack of generators, each yielding a</span>
<span class="gi">+        # sequence of function arguments.  We grow the stack by appending a call</span>
<span class="gi">+        # to _recurse on each argument tuple, and shrink the stack whenever a</span>
<span class="gi">+        # generator is exhausted.</span>
<span class="gi">+        stack = [_recurse(b, v)]</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            top = stack[-1]</span>
<span class="gi">+            for args in top:</span>
<span class="gi">+                stack.append(_recurse(*args))</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+    # Swap matched/unmatched edges over an alternating path between two</span>
<span class="gi">+    # single vertices. The augmenting path runs through S-vertices v and w.</span>
<span class="gi">+    def augmentMatching(v, w):</span>
<span class="gi">+        for s, j in ((v, w), (w, v)):</span>
<span class="gi">+            # Match vertex s to vertex j. Then trace back from s</span>
<span class="gi">+            # until we find a single vertex, swapping matched and unmatched</span>
<span class="gi">+            # edges as we go.</span>
<span class="gi">+            while 1:</span>
<span class="gi">+                bs = inblossom[s]</span>
<span class="gi">+                assert label[bs] == 1</span>
<span class="gi">+                assert (labeledge[bs] is None and blossombase[bs] not in mate) or (</span>
<span class="gi">+                    labeledge[bs][0] == mate[blossombase[bs]]</span>
<span class="gi">+                )</span>
<span class="gi">+                # Augment through the S-blossom from s to base.</span>
<span class="gi">+                if isinstance(bs, Blossom):</span>
<span class="gi">+                    augmentBlossom(bs, s)</span>
<span class="gi">+                # Update mate[s]</span>
<span class="gi">+                mate[s] = j</span>
<span class="gi">+                # Trace one step back.</span>
<span class="gi">+                if labeledge[bs] is None:</span>
<span class="gi">+                    # Reached single vertex; stop.</span>
<span class="gi">+                    break</span>
<span class="gi">+                t = labeledge[bs][0]</span>
<span class="gi">+                bt = inblossom[t]</span>
<span class="gi">+                assert label[bt] == 2</span>
<span class="gi">+                # Trace one more step back.</span>
<span class="gi">+                s, j = labeledge[bt]</span>
<span class="gi">+                # Augment through the T-blossom from j to base.</span>
<span class="gi">+                assert blossombase[bt] == t</span>
<span class="gi">+                if isinstance(bt, Blossom):</span>
<span class="gi">+                    augmentBlossom(bt, j)</span>
<span class="gi">+                # Update mate[j]</span>
<span class="gi">+                mate[j] = s</span>
<span class="gi">+</span>
<span class="gi">+    # Verify that the optimum solution has been reached.</span>
<span class="gi">+    def verifyOptimum():</span>
<span class="gi">+        if maxcardinality:</span>
<span class="gi">+            # Vertices may have negative dual;</span>
<span class="gi">+            # find a constant non-negative number to add to all vertex duals.</span>
<span class="gi">+            vdualoffset = max(0, -min(dualvar.values()))</span>
<span class="gi">+        else:</span>
<span class="gi">+            vdualoffset = 0</span>
<span class="gi">+        # 0. all dual variables are non-negative</span>
<span class="gi">+        assert min(dualvar.values()) + vdualoffset &gt;= 0</span>
<span class="gi">+        assert len(blossomdual) == 0 or min(blossomdual.values()) &gt;= 0</span>
<span class="gi">+        # 0. all edges have non-negative slack and</span>
<span class="gi">+        # 1. all matched edges have zero slack;</span>
<span class="gi">+        for i, j, d in G.edges(data=True):</span>
<span class="gi">+            wt = d.get(weight, 1)</span>
<span class="gi">+            if i == j:</span>
<span class="gi">+                continue  # ignore self-loops</span>
<span class="gi">+            s = dualvar[i] + dualvar[j] - 2 * wt</span>
<span class="gi">+            iblossoms = [i]</span>
<span class="gi">+            jblossoms = [j]</span>
<span class="gi">+            while blossomparent[iblossoms[-1]] is not None:</span>
<span class="gi">+                iblossoms.append(blossomparent[iblossoms[-1]])</span>
<span class="gi">+            while blossomparent[jblossoms[-1]] is not None:</span>
<span class="gi">+                jblossoms.append(blossomparent[jblossoms[-1]])</span>
<span class="gi">+            iblossoms.reverse()</span>
<span class="gi">+            jblossoms.reverse()</span>
<span class="gi">+            for bi, bj in zip(iblossoms, jblossoms):</span>
<span class="gi">+                if bi != bj:</span>
<span class="gi">+                    break</span>
<span class="gi">+                s += 2 * blossomdual[bi]</span>
<span class="gi">+            assert s &gt;= 0</span>
<span class="gi">+            if mate.get(i) == j or mate.get(j) == i:</span>
<span class="gi">+                assert mate[i] == j and mate[j] == i</span>
<span class="gi">+                assert s == 0</span>
<span class="gi">+        # 2. all single vertices have zero dual value;</span>
<span class="gi">+        for v in gnodes:</span>
<span class="gi">+            assert (v in mate) or dualvar[v] + vdualoffset == 0</span>
<span class="gi">+        # 3. all blossoms with positive dual value are full.</span>
<span class="gi">+        for b in blossomdual:</span>
<span class="gi">+            if blossomdual[b] &gt; 0:</span>
<span class="gi">+                assert len(b.edges) % 2 == 1</span>
<span class="gi">+                for i, j in b.edges[1::2]:</span>
<span class="gi">+                    assert mate[i] == j and mate[j] == i</span>
<span class="gi">+        # Ok.</span>
<span class="gi">+</span>
<span class="gi">+    # Main loop: continue until no further improvement is possible.</span>
<span class="gi">+    while 1:</span>
<span class="gi">+        # Each iteration of this loop is a &quot;stage&quot;.</span>
<span class="gi">+        # A stage finds an augmenting path and uses that to improve</span>
<span class="gi">+        # the matching.</span>
<span class="gi">+</span>
<span class="gi">+        # Remove labels from top-level blossoms/vertices.</span>
<span class="gi">+        label.clear()</span>
<span class="gi">+        labeledge.clear()</span>
<span class="gi">+</span>
<span class="gi">+        # Forget all about least-slack edges.</span>
<span class="gi">+        bestedge.clear()</span>
<span class="gi">+        for b in blossomdual:</span>
<span class="gi">+            b.mybestedges = None</span>
<span class="gi">+</span>
<span class="gi">+        # Loss of labeling means that we can not be sure that currently</span>
<span class="gi">+        # allowable edges remain allowable throughout this stage.</span>
<span class="gi">+        allowedge.clear()</span>
<span class="gi">+</span>
<span class="gi">+        # Make queue empty.</span>
<span class="gi">+        queue[:] = []</span>
<span class="gi">+</span>
<span class="gi">+        # Label single blossoms/vertices with S and put them in the queue.</span>
<span class="gi">+        for v in gnodes:</span>
<span class="gi">+            if (v not in mate) and label.get(inblossom[v]) is None:</span>
<span class="gi">+                assignLabel(v, 1, None)</span>
<span class="gi">+</span>
<span class="gi">+        # Loop until we succeed in augmenting the matching.</span>
<span class="gi">+        augmented = 0</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            # Each iteration of this loop is a &quot;substage&quot;.</span>
<span class="gi">+            # A substage tries to find an augmenting path;</span>
<span class="gi">+            # if found, the path is used to improve the matching and</span>
<span class="gi">+            # the stage ends. If there is no augmenting path, the</span>
<span class="gi">+            # primal-dual method is used to pump some slack out of</span>
<span class="gi">+            # the dual variables.</span>
<span class="gi">+</span>
<span class="gi">+            # Continue labeling until all vertices which are reachable</span>
<span class="gi">+            # through an alternating path have got a label.</span>
<span class="gi">+            while queue and not augmented:</span>
<span class="gi">+                # Take an S vertex from the queue.</span>
<span class="gi">+                v = queue.pop()</span>
<span class="gi">+                assert label[inblossom[v]] == 1</span>
<span class="gi">+</span>
<span class="gi">+                # Scan its neighbors:</span>
<span class="gi">+                for w in G.neighbors(v):</span>
<span class="gi">+                    if w == v:</span>
<span class="gi">+                        continue  # ignore self-loops</span>
<span class="gi">+                    # w is a neighbor to v</span>
<span class="gi">+                    bv = inblossom[v]</span>
<span class="gi">+                    bw = inblossom[w]</span>
<span class="gi">+                    if bv == bw:</span>
<span class="gi">+                        # this edge is internal to a blossom; ignore it</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if (v, w) not in allowedge:</span>
<span class="gi">+                        kslack = slack(v, w)</span>
<span class="gi">+                        if kslack &lt;= 0:</span>
<span class="gi">+                            # edge k has zero slack =&gt; it is allowable</span>
<span class="gi">+                            allowedge[(v, w)] = allowedge[(w, v)] = True</span>
<span class="gi">+                    if (v, w) in allowedge:</span>
<span class="gi">+                        if label.get(bw) is None:</span>
<span class="gi">+                            # (C1) w is a free vertex;</span>
<span class="gi">+                            # label w with T and label its mate with S (R12).</span>
<span class="gi">+                            assignLabel(w, 2, v)</span>
<span class="gi">+                        elif label.get(bw) == 1:</span>
<span class="gi">+                            # (C2) w is an S-vertex (not in the same blossom);</span>
<span class="gi">+                            # follow back-links to discover either an</span>
<span class="gi">+                            # augmenting path or a new blossom.</span>
<span class="gi">+                            base = scanBlossom(v, w)</span>
<span class="gi">+                            if base is not NoNode:</span>
<span class="gi">+                                # Found a new blossom; add it to the blossom</span>
<span class="gi">+                                # bookkeeping and turn it into an S-blossom.</span>
<span class="gi">+                                addBlossom(base, v, w)</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                # Found an augmenting path; augment the</span>
<span class="gi">+                                # matching and end this stage.</span>
<span class="gi">+                                augmentMatching(v, w)</span>
<span class="gi">+                                augmented = 1</span>
<span class="gi">+                                break</span>
<span class="gi">+                        elif label.get(w) is None:</span>
<span class="gi">+                            # w is inside a T-blossom, but w itself has not</span>
<span class="gi">+                            # yet been reached from outside the blossom;</span>
<span class="gi">+                            # mark it as reached (we need this to relabel</span>
<span class="gi">+                            # during T-blossom expansion).</span>
<span class="gi">+                            assert label[bw] == 2</span>
<span class="gi">+                            label[w] = 2</span>
<span class="gi">+                            labeledge[w] = (v, w)</span>
<span class="gi">+                    elif label.get(bw) == 1:</span>
<span class="gi">+                        # keep track of the least-slack non-allowable edge to</span>
<span class="gi">+                        # a different S-blossom.</span>
<span class="gi">+                        if bestedge.get(bv) is None or kslack &lt; slack(*bestedge[bv]):</span>
<span class="gi">+                            bestedge[bv] = (v, w)</span>
<span class="gi">+                    elif label.get(w) is None:</span>
<span class="gi">+                        # w is a free vertex (or an unreached vertex inside</span>
<span class="gi">+                        # a T-blossom) but we can not reach it yet;</span>
<span class="gi">+                        # keep track of the least-slack edge that reaches w.</span>
<span class="gi">+                        if bestedge.get(w) is None or kslack &lt; slack(*bestedge[w]):</span>
<span class="gi">+                            bestedge[w] = (v, w)</span>
<span class="gi">+</span>
<span class="gi">+            if augmented:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            # There is no augmenting path under these constraints;</span>
<span class="gi">+            # compute delta and reduce slack in the optimization problem.</span>
<span class="gi">+            # (Note that our vertex dual variables, edge slacks and delta&#39;s</span>
<span class="gi">+            # are pre-multiplied by two.)</span>
<span class="gi">+            deltatype = -1</span>
<span class="gi">+            delta = deltaedge = deltablossom = None</span>
<span class="gi">+</span>
<span class="gi">+            # Compute delta1: the minimum value of any vertex dual.</span>
<span class="gi">+            if not maxcardinality:</span>
<span class="gi">+                deltatype = 1</span>
<span class="gi">+                delta = min(dualvar.values())</span>
<span class="gi">+</span>
<span class="gi">+            # Compute delta2: the minimum slack on any edge between</span>
<span class="gi">+            # an S-vertex and a free vertex.</span>
<span class="gi">+            for v in G.nodes():</span>
<span class="gi">+                if label.get(inblossom[v]) is None and bestedge.get(v) is not None:</span>
<span class="gi">+                    d = slack(*bestedge[v])</span>
<span class="gi">+                    if deltatype == -1 or d &lt; delta:</span>
<span class="gi">+                        delta = d</span>
<span class="gi">+                        deltatype = 2</span>
<span class="gi">+                        deltaedge = bestedge[v]</span>
<span class="gi">+</span>
<span class="gi">+            # Compute delta3: half the minimum slack on any edge between</span>
<span class="gi">+            # a pair of S-blossoms.</span>
<span class="gi">+            for b in blossomparent:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    blossomparent[b] is None</span>
<span class="gi">+                    and label.get(b) == 1</span>
<span class="gi">+                    and bestedge.get(b) is not None</span>
<span class="gi">+                ):</span>
<span class="gi">+                    kslack = slack(*bestedge[b])</span>
<span class="gi">+                    if allinteger:</span>
<span class="gi">+                        assert (kslack % 2) == 0</span>
<span class="gi">+                        d = kslack // 2</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        d = kslack / 2.0</span>
<span class="gi">+                    if deltatype == -1 or d &lt; delta:</span>
<span class="gi">+                        delta = d</span>
<span class="gi">+                        deltatype = 3</span>
<span class="gi">+                        deltaedge = bestedge[b]</span>
<span class="gi">+</span>
<span class="gi">+            # Compute delta4: minimum z variable of any T-blossom.</span>
<span class="gi">+            for b in blossomdual:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    blossomparent[b] is None</span>
<span class="gi">+                    and label.get(b) == 2</span>
<span class="gi">+                    and (deltatype == -1 or blossomdual[b] &lt; delta)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    delta = blossomdual[b]</span>
<span class="gi">+                    deltatype = 4</span>
<span class="gi">+                    deltablossom = b</span>
<span class="gi">+</span>
<span class="gi">+            if deltatype == -1:</span>
<span class="gi">+                # No further improvement possible; max-cardinality optimum</span>
<span class="gi">+                # reached. Do a final delta update to make the optimum</span>
<span class="gi">+                # verifiable.</span>
<span class="gi">+                assert maxcardinality</span>
<span class="gi">+                deltatype = 1</span>
<span class="gi">+                delta = max(0, min(dualvar.values()))</span>
<span class="gi">+</span>
<span class="gi">+            # Update dual variables according to delta.</span>
<span class="gi">+            for v in gnodes:</span>
<span class="gi">+                if label.get(inblossom[v]) == 1:</span>
<span class="gi">+                    # S-vertex: 2*u = 2*u - 2*delta</span>
<span class="gi">+                    dualvar[v] -= delta</span>
<span class="gi">+                elif label.get(inblossom[v]) == 2:</span>
<span class="gi">+                    # T-vertex: 2*u = 2*u + 2*delta</span>
<span class="gi">+                    dualvar[v] += delta</span>
<span class="gi">+            for b in blossomdual:</span>
<span class="gi">+                if blossomparent[b] is None:</span>
<span class="gi">+                    if label.get(b) == 1:</span>
<span class="gi">+                        # top-level S-blossom: z = z + 2*delta</span>
<span class="gi">+                        blossomdual[b] += delta</span>
<span class="gi">+                    elif label.get(b) == 2:</span>
<span class="gi">+                        # top-level T-blossom: z = z - 2*delta</span>
<span class="gi">+                        blossomdual[b] -= delta</span>
<span class="gi">+</span>
<span class="gi">+            # Take action at the point where minimum delta occurred.</span>
<span class="gi">+            if deltatype == 1:</span>
<span class="gi">+                # No further improvement possible; optimum reached.</span>
<span class="gi">+                break</span>
<span class="gi">+            elif deltatype == 2:</span>
<span class="gi">+                # Use the least-slack edge to continue the search.</span>
<span class="gi">+                (v, w) = deltaedge</span>
<span class="gi">+                assert label[inblossom[v]] == 1</span>
<span class="gi">+                allowedge[(v, w)] = allowedge[(w, v)] = True</span>
<span class="gi">+                queue.append(v)</span>
<span class="gi">+            elif deltatype == 3:</span>
<span class="gi">+                # Use the least-slack edge to continue the search.</span>
<span class="gi">+                (v, w) = deltaedge</span>
<span class="gi">+                allowedge[(v, w)] = allowedge[(w, v)] = True</span>
<span class="gi">+                assert label[inblossom[v]] == 1</span>
<span class="gi">+                queue.append(v)</span>
<span class="gi">+            elif deltatype == 4:</span>
<span class="gi">+                # Expand the least-z blossom.</span>
<span class="gi">+                expandBlossom(deltablossom, False)</span>
<span class="gi">+</span>
<span class="gi">+            # End of a this substage.</span>
<span class="gi">+</span>
<span class="gi">+        # Paranoia check that the matching is symmetric.</span>
<span class="gi">+        for v in mate:</span>
<span class="gi">+            assert mate[mate[v]] == v</span>
<span class="gi">+</span>
<span class="gi">+        # Stop when no more augmenting path can be found.</span>
<span class="gi">+        if not augmented:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        # End of a stage; expand all S-blossoms which have zero dual.</span>
<span class="gi">+        for b in list(blossomdual.keys()):</span>
<span class="gi">+            if b not in blossomdual:</span>
<span class="gi">+                continue  # already expanded</span>
<span class="gi">+            if blossomparent[b] is None and label.get(b) == 1 and blossomdual[b] == 0:</span>
<span class="gi">+                expandBlossom(b, True)</span>
<span class="gi">+</span>
<span class="gi">+    # Verify that we reached the optimum solution (only for integer weights).</span>
<span class="gi">+    if allinteger:</span>
<span class="gi">+        verifyOptimum()</span>
<span class="gi">+</span>
<span class="gi">+    return matching_dict_to_set(mate)</span>
<span class="gh">diff --git a/networkx/algorithms/minors/contraction.py b/networkx/algorithms/minors/contraction.py</span>
<span class="gh">index 0af897e59..9f4d89fa8 100644</span>
<span class="gd">--- a/networkx/algorithms/minors/contraction.py</span>
<span class="gi">+++ b/networkx/algorithms/minors/contraction.py</span>
<span class="gu">@@ -1,11 +1,19 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Provides functions for computing minors of a graph.&quot;&quot;&quot;
<span class="w"> </span>from itertools import chain, combinations, permutations, product
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx import density
<span class="w"> </span>from networkx.exception import NetworkXException
<span class="w"> </span>from networkx.utils import arbitrary_element
<span class="gd">-__all__ = [&#39;contracted_edge&#39;, &#39;contracted_nodes&#39;, &#39;equivalence_classes&#39;,</span>
<span class="gd">-    &#39;identified_nodes&#39;, &#39;quotient_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;contracted_edge&quot;,</span>
<span class="gi">+    &quot;contracted_nodes&quot;,</span>
<span class="gi">+    &quot;equivalence_classes&quot;,</span>
<span class="gi">+    &quot;identified_nodes&quot;,</span>
<span class="gi">+    &quot;quotient_graph&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>chaini = chain.from_iterable


<span class="gu">@@ -65,12 +73,39 @@ def equivalence_classes(iterable, relation):</span>
<span class="w"> </span>    &gt;&gt;&gt; equivalence_classes(X, mod3)  # doctest: +SKIP
<span class="w"> </span>    {frozenset({1, 4, 7}), frozenset({8, 2, 5}), frozenset({0, 9, 3, 6})}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, returns_graph=True)</span>
<span class="gd">-def quotient_graph(G, partition, edge_relation=None, node_data=None,</span>
<span class="gd">-    edge_data=None, weight=&#39;weight&#39;, relabel=False, create_using=None):</span>
<span class="gi">+    # For simplicity of implementation, we initialize the return value as a</span>
<span class="gi">+    # list of lists, then convert it to a set of sets at the end of the</span>
<span class="gi">+    # function.</span>
<span class="gi">+    blocks = []</span>
<span class="gi">+    # Determine the equivalence class for each element of the iterable.</span>
<span class="gi">+    for y in iterable:</span>
<span class="gi">+        # Each element y must be in *exactly one* equivalence class.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Each block is guaranteed to be non-empty</span>
<span class="gi">+        for block in blocks:</span>
<span class="gi">+            x = arbitrary_element(block)</span>
<span class="gi">+            if relation(x, y):</span>
<span class="gi">+                block.append(y)</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If the element y is not part of any known equivalence class, it</span>
<span class="gi">+            # must be in its own, so we create a new singleton equivalence</span>
<span class="gi">+            # class for it.</span>
<span class="gi">+            blocks.append([y])</span>
<span class="gi">+    return {frozenset(block) for block in blocks}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, returns_graph=True)</span>
<span class="gi">+def quotient_graph(</span>
<span class="gi">+    G,</span>
<span class="gi">+    partition,</span>
<span class="gi">+    edge_relation=None,</span>
<span class="gi">+    node_data=None,</span>
<span class="gi">+    edge_data=None,</span>
<span class="gi">+    weight=&quot;weight&quot;,</span>
<span class="gi">+    relabel=False,</span>
<span class="gi">+    create_using=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the quotient graph of `G` under the specified equivalence
<span class="w"> </span>    relation on nodes.

<span class="gu">@@ -261,17 +296,137 @@ def quotient_graph(G, partition, edge_relation=None, node_data=None,</span>
<span class="w"> </span>           Cambridge University Press, 2004.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _quotient_graph(G, partition, edge_relation, node_data, edge_data,</span>
<span class="gd">-    weight, relabel, create_using):</span>
<span class="gi">+    # If the user provided an equivalence relation as a function to compute</span>
<span class="gi">+    # the blocks of the partition on the nodes of G induced by the</span>
<span class="gi">+    # equivalence relation.</span>
<span class="gi">+    if callable(partition):</span>
<span class="gi">+        # equivalence_classes always return partition of whole G.</span>
<span class="gi">+        partition = equivalence_classes(G, partition)</span>
<span class="gi">+        if not nx.community.is_partition(G, partition):</span>
<span class="gi">+            raise nx.NetworkXException(</span>
<span class="gi">+                &quot;Input `partition` is not an equivalence relation for nodes of G&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        return _quotient_graph(</span>
<span class="gi">+            G,</span>
<span class="gi">+            partition,</span>
<span class="gi">+            edge_relation,</span>
<span class="gi">+            node_data,</span>
<span class="gi">+            edge_data,</span>
<span class="gi">+            weight,</span>
<span class="gi">+            relabel,</span>
<span class="gi">+            create_using,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # If the partition is a dict, it is assumed to be one where the keys are</span>
<span class="gi">+    # user-defined block labels, and values are block lists, tuples or sets.</span>
<span class="gi">+    if isinstance(partition, dict):</span>
<span class="gi">+        partition = list(partition.values())</span>
<span class="gi">+</span>
<span class="gi">+    # If the user provided partition as a collection of sets. Then we</span>
<span class="gi">+    # need to check if partition covers all of G nodes. If the answer</span>
<span class="gi">+    # is &#39;No&#39; then we need to prepare suitable subgraph view.</span>
<span class="gi">+    partition_nodes = set().union(*partition)</span>
<span class="gi">+    if len(partition_nodes) != len(G):</span>
<span class="gi">+        G = G.subgraph(partition_nodes)</span>
<span class="gi">+    # Each node in the graph/subgraph must be in exactly one block.</span>
<span class="gi">+    if not nx.community.is_partition(G, partition):</span>
<span class="gi">+        raise NetworkXException(&quot;each node must be in exactly one part of `partition`&quot;)</span>
<span class="gi">+    return _quotient_graph(</span>
<span class="gi">+        G,</span>
<span class="gi">+        partition,</span>
<span class="gi">+        edge_relation,</span>
<span class="gi">+        node_data,</span>
<span class="gi">+        edge_data,</span>
<span class="gi">+        weight,</span>
<span class="gi">+        relabel,</span>
<span class="gi">+        create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _quotient_graph(</span>
<span class="gi">+    G, partition, edge_relation, node_data, edge_data, weight, relabel, create_using</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Construct the quotient graph assuming input has been checked&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(preserve_all_attrs=True, mutates_input={&#39;not copy&#39;: 4},</span>
<span class="gd">-    returns_graph=True)</span>
<span class="gi">+    if create_using is None:</span>
<span class="gi">+        H = G.__class__()</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = nx.empty_graph(0, create_using)</span>
<span class="gi">+    # By default set some basic information about the subgraph that each block</span>
<span class="gi">+    # represents on the nodes in the quotient graph.</span>
<span class="gi">+    if node_data is None:</span>
<span class="gi">+</span>
<span class="gi">+        def node_data(b):</span>
<span class="gi">+            S = G.subgraph(b)</span>
<span class="gi">+            return {</span>
<span class="gi">+                &quot;graph&quot;: S,</span>
<span class="gi">+                &quot;nnodes&quot;: len(S),</span>
<span class="gi">+                &quot;nedges&quot;: S.number_of_edges(),</span>
<span class="gi">+                &quot;density&quot;: density(S),</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+    # Each block of the partition becomes a node in the quotient graph.</span>
<span class="gi">+    partition = [frozenset(b) for b in partition]</span>
<span class="gi">+    H.add_nodes_from((b, node_data(b)) for b in partition)</span>
<span class="gi">+    # By default, the edge relation is the relation defined as follows. B is</span>
<span class="gi">+    # adjacent to C if a node in B is adjacent to a node in C, according to the</span>
<span class="gi">+    # edge set of G.</span>
<span class="gi">+    #</span>
<span class="gi">+    # This is not a particularly efficient implementation of this relation:</span>
<span class="gi">+    # there are O(n^2) pairs to check and each check may require O(log n) time</span>
<span class="gi">+    # (to check set membership). This can certainly be parallelized.</span>
<span class="gi">+    if edge_relation is None:</span>
<span class="gi">+</span>
<span class="gi">+        def edge_relation(b, c):</span>
<span class="gi">+            return any(v in G[u] for u, v in product(b, c))</span>
<span class="gi">+</span>
<span class="gi">+    # By default, sum the weights of the edges joining pairs of nodes across</span>
<span class="gi">+    # blocks to get the weight of the edge joining those two blocks.</span>
<span class="gi">+    if edge_data is None:</span>
<span class="gi">+</span>
<span class="gi">+        def edge_data(b, c):</span>
<span class="gi">+            edgedata = (</span>
<span class="gi">+                d</span>
<span class="gi">+                for u, v, d in G.edges(b | c, data=True)</span>
<span class="gi">+                if (u in b and v in c) or (u in c and v in b)</span>
<span class="gi">+            )</span>
<span class="gi">+            return {&quot;weight&quot;: sum(d.get(weight, 1) for d in edgedata)}</span>
<span class="gi">+</span>
<span class="gi">+    block_pairs = permutations(H, 2) if H.is_directed() else combinations(H, 2)</span>
<span class="gi">+    # In a multigraph, add one edge in the quotient graph for each edge</span>
<span class="gi">+    # in the original graph.</span>
<span class="gi">+    if H.is_multigraph():</span>
<span class="gi">+        edges = chaini(</span>
<span class="gi">+            (</span>
<span class="gi">+                (b, c, G.get_edge_data(u, v, default={}))</span>
<span class="gi">+                for u, v in product(b, c)</span>
<span class="gi">+                if v in G[u]</span>
<span class="gi">+            )</span>
<span class="gi">+            for b, c in block_pairs</span>
<span class="gi">+            if edge_relation(b, c)</span>
<span class="gi">+        )</span>
<span class="gi">+    # In a simple graph, apply the edge data function to each pair of</span>
<span class="gi">+    # blocks to determine the edge data attributes to apply to each edge</span>
<span class="gi">+    # in the quotient graph.</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = (</span>
<span class="gi">+            (b, c, edge_data(b, c)) for (b, c) in block_pairs if edge_relation(b, c)</span>
<span class="gi">+        )</span>
<span class="gi">+    H.add_edges_from(edges)</span>
<span class="gi">+    # If requested by the user, relabel the nodes to be integers,</span>
<span class="gi">+    # numbered in increasing order from zero in the same order as the</span>
<span class="gi">+    # iteration order of `partition`.</span>
<span class="gi">+    if relabel:</span>
<span class="gi">+        # Can&#39;t use nx.convert_node_labels_to_integers() here since we</span>
<span class="gi">+        # want the order of iteration to be the same for backward</span>
<span class="gi">+        # compatibility with the nx.blockmodel() function.</span>
<span class="gi">+        labels = {b: i for i, b in enumerate(partition)}</span>
<span class="gi">+        H = nx.relabel_nodes(H, labels)</span>
<span class="gi">+    return H</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    preserve_all_attrs=True, mutates_input={&quot;not copy&quot;: 4}, returns_graph=True</span>
<span class="gi">+)</span>
<span class="w"> </span>def contracted_nodes(G, u, v, self_loops=True, copy=True):
<span class="w"> </span>    &quot;&quot;&quot;Returns the graph that results from contracting `u` and `v`.

<span class="gu">@@ -361,14 +516,54 @@ def contracted_nodes(G, u, v, self_loops=True, copy=True):</span>
<span class="w"> </span>    quotient_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Copying has significant overhead and can be disabled if needed</span>
<span class="gi">+    if copy:</span>
<span class="gi">+        H = G.copy()</span>
<span class="gi">+    else:</span>
<span class="gi">+        H = G</span>
<span class="gi">+</span>
<span class="gi">+    # edge code uses G.edges(v) instead of G.adj[v] to handle multiedges</span>
<span class="gi">+    if H.is_directed():</span>
<span class="gi">+        edges_to_remap = chain(G.in_edges(v, data=True), G.out_edges(v, data=True))</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges_to_remap = G.edges(v, data=True)</span>
<span class="gi">+</span>
<span class="gi">+    # If the H=G, the generators change as H changes</span>
<span class="gi">+    # This makes the edges_to_remap independent of H</span>
<span class="gi">+    if not copy:</span>
<span class="gi">+        edges_to_remap = list(edges_to_remap)</span>
<span class="gi">+</span>
<span class="gi">+    v_data = H.nodes[v]</span>
<span class="gi">+    H.remove_node(v)</span>
<span class="gi">+</span>
<span class="gi">+    for prev_w, prev_x, d in edges_to_remap:</span>
<span class="gi">+        w = prev_w if prev_w != v else u</span>
<span class="gi">+        x = prev_x if prev_x != v else u</span>
<span class="gi">+</span>
<span class="gi">+        if ({prev_w, prev_x} == {u, v}) and not self_loops:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if not H.has_edge(w, x) or G.is_multigraph():</span>
<span class="gi">+            H.add_edge(w, x, **d)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if &quot;contraction&quot; in H.edges[(w, x)]:</span>
<span class="gi">+                H.edges[(w, x)][&quot;contraction&quot;][(prev_w, prev_x)] = d</span>
<span class="gi">+            else:</span>
<span class="gi">+                H.edges[(w, x)][&quot;contraction&quot;] = {(prev_w, prev_x): d}</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;contraction&quot; in H.nodes[u]:</span>
<span class="gi">+        H.nodes[u][&quot;contraction&quot;][v] = v_data</span>
<span class="gi">+    else:</span>
<span class="gi">+        H.nodes[u][&quot;contraction&quot;] = {v: v_data}</span>
<span class="gi">+    return H</span>


<span class="w"> </span>identified_nodes = contracted_nodes


<span class="gd">-@nx._dispatchable(preserve_edge_attrs=True, mutates_input={&#39;not copy&#39;: 3},</span>
<span class="gd">-    returns_graph=True)</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    preserve_edge_attrs=True, mutates_input={&quot;not copy&quot;: 3}, returns_graph=True</span>
<span class="gi">+)</span>
<span class="w"> </span>def contracted_edge(G, edge, self_loops=True, copy=True):
<span class="w"> </span>    &quot;&quot;&quot;Returns the graph that results from contracting the specified edge.

<span class="gu">@@ -432,4 +627,7 @@ def contracted_edge(G, edge, self_loops=True, copy=True):</span>
<span class="w"> </span>    quotient_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    u, v = edge[:2]</span>
<span class="gi">+    if not G.has_edge(u, v):</span>
<span class="gi">+        raise ValueError(f&quot;Edge {edge} does not exist in graph G; cannot contract it&quot;)</span>
<span class="gi">+    return contracted_nodes(G, u, v, self_loops=self_loops, copy=copy)</span>
<span class="gh">diff --git a/networkx/algorithms/mis.py b/networkx/algorithms/mis.py</span>
<span class="gh">index ad5d704ff..fc70514d9 100644</span>
<span class="gd">--- a/networkx/algorithms/mis.py</span>
<span class="gi">+++ b/networkx/algorithms/mis.py</span>
<span class="gu">@@ -4,10 +4,11 @@ Algorithm to find a maximal (not maximum) independent set.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;maximal_independent_set&#39;]</span>

<span class="gi">+__all__ = [&quot;maximal_independent_set&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@py_random_state(2)
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def maximal_independent_set(G, nodes=None, seed=None):
<span class="gu">@@ -58,4 +59,19 @@ def maximal_independent_set(G, nodes=None, seed=None):</span>
<span class="w"> </span>    This algorithm does not solve the maximum independent set problem.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nodes:</span>
<span class="gi">+        nodes = {seed.choice(list(G))}</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodes = set(nodes)</span>
<span class="gi">+    if not nodes.issubset(G):</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(f&quot;{nodes} is not a subset of the nodes of G&quot;)</span>
<span class="gi">+    neighbors = set.union(*[set(G.adj[v]) for v in nodes])</span>
<span class="gi">+    if set.intersection(neighbors, nodes):</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(f&quot;{nodes} is not an independent set of G&quot;)</span>
<span class="gi">+    indep_nodes = list(nodes)</span>
<span class="gi">+    available_nodes = set(G.nodes()).difference(neighbors.union(nodes))</span>
<span class="gi">+    while available_nodes:</span>
<span class="gi">+        node = seed.choice(list(available_nodes))</span>
<span class="gi">+        indep_nodes.append(node)</span>
<span class="gi">+        available_nodes.difference_update(list(G.adj[node]) + [node])</span>
<span class="gi">+    return indep_nodes</span>
<span class="gh">diff --git a/networkx/algorithms/moral.py b/networkx/algorithms/moral.py</span>
<span class="gh">index 12b42bcc6..e2acf80f6 100644</span>
<span class="gd">--- a/networkx/algorithms/moral.py</span>
<span class="gi">+++ b/networkx/algorithms/moral.py</span>
<span class="gu">@@ -1,14 +1,17 @@</span>
<span class="gd">-&quot;&quot;&quot;Function for computing the moral graph of a directed graph.&quot;&quot;&quot;</span>
<span class="gi">+r&quot;&quot;&quot;Function for computing the moral graph of a directed graph.&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;moral_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;moral_graph&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def moral_graph(G):
<span class="gd">-    &quot;&quot;&quot;Return the Moral Graph</span>
<span class="gi">+    r&quot;&quot;&quot;Return the Moral Graph</span>

<span class="w"> </span>    Returns the moralized graph of a given directed graph.

<span class="gu">@@ -49,4 +52,8 @@ def moral_graph(G):</span>
<span class="w"> </span>           In Proceedings of the Eleventh conference on Uncertainty
<span class="w"> </span>           in artificial intelligence (UAI&#39;95)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    H = G.to_undirected()</span>
<span class="gi">+    for preds in G.pred.values():</span>
<span class="gi">+        predecessors_combinations = itertools.combinations(preds, r=2)</span>
<span class="gi">+        H.add_edges_from(predecessors_combinations)</span>
<span class="gi">+    return H</span>
<span class="gh">diff --git a/networkx/algorithms/node_classification.py b/networkx/algorithms/node_classification.py</span>
<span class="gh">index 2b44f241e..42e7e6ba2 100644</span>
<span class="gd">--- a/networkx/algorithms/node_classification.py</span>
<span class="gi">+++ b/networkx/algorithms/node_classification.py</span>
<span class="gu">@@ -23,12 +23,13 @@ Semi-supervised learning using gaussian fields and harmonic functions.</span>
<span class="w"> </span>In ICML (Vol. 3, pp. 912-919).
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;harmonic_function&#39;, &#39;local_and_global_consistency&#39;]</span>

<span class="gi">+__all__ = [&quot;harmonic_function&quot;, &quot;local_and_global_consistency&quot;]</span>

<span class="gd">-@nx.utils.not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(node_attrs=&#39;label_name&#39;)</span>
<span class="gd">-def harmonic_function(G, max_iter=30, label_name=&#39;label&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;label_name&quot;)</span>
<span class="gi">+def harmonic_function(G, max_iter=30, label_name=&quot;label&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node classification by Harmonic function

<span class="w"> </span>    Function for computing Harmonic function algorithm by Zhu et al.
<span class="gu">@@ -71,13 +72,41 @@ def harmonic_function(G, max_iter=30, label_name=&#39;label&#39;):</span>
<span class="w"> </span>    Semi-supervised learning using gaussian fields and harmonic functions.
<span class="w"> </span>    In ICML (Vol. 3, pp. 912-919).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    X = nx.to_scipy_sparse_array(G)  # adjacency matrix</span>
<span class="gi">+    labels, label_dict = _get_label_info(G, label_name)</span>
<span class="gi">+</span>
<span class="gi">+    if labels.shape[0] == 0:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;No node on the input graph is labeled by &#39;{label_name}&#39;.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    n_samples = X.shape[0]</span>
<span class="gi">+    n_classes = label_dict.shape[0]</span>
<span class="gi">+    F = np.zeros((n_samples, n_classes))</span>
<span class="gi">+</span>
<span class="gi">+    # Build propagation matrix</span>
<span class="gi">+    degrees = X.sum(axis=0)</span>
<span class="gi">+    degrees[degrees == 0] = 1  # Avoid division by 0</span>
<span class="gi">+    # TODO: csr_array</span>
<span class="gi">+    D = sp.sparse.csr_array(sp.sparse.diags((1.0 / degrees), offsets=0))</span>
<span class="gi">+    P = (D @ X).tolil()</span>
<span class="gi">+    P[labels[:, 0]] = 0  # labels[:, 0] indicates IDs of labeled nodes</span>
<span class="gi">+    # Build base matrix</span>
<span class="gi">+    B = np.zeros((n_samples, n_classes))</span>
<span class="gi">+    B[labels[:, 0], labels[:, 1]] = 1</span>
<span class="gi">+</span>
<span class="gi">+    for _ in range(max_iter):</span>
<span class="gi">+        F = (P @ F) + B</span>
<span class="gi">+</span>
<span class="gi">+    return label_dict[np.argmax(F, axis=1)].tolist()</span>


<span class="gd">-@nx.utils.not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(node_attrs=&#39;label_name&#39;)</span>
<span class="gd">-def local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name=&#39;label&#39;</span>
<span class="gd">-    ):</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;label_name&quot;)</span>
<span class="gi">+def local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name=&quot;label&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node classification by Local and Global Consistency

<span class="w"> </span>    Function for computing Local and global consistency algorithm by Zhou et al.
<span class="gu">@@ -122,7 +151,35 @@ def local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name=&#39;label&#39;</span>
<span class="w"> </span>    Learning with local and global consistency.
<span class="w"> </span>    Advances in neural information processing systems, 16(16), 321-328.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    X = nx.to_scipy_sparse_array(G)  # adjacency matrix</span>
<span class="gi">+    labels, label_dict = _get_label_info(G, label_name)</span>
<span class="gi">+</span>
<span class="gi">+    if labels.shape[0] == 0:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;No node on the input graph is labeled by &#39;{label_name}&#39;.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    n_samples = X.shape[0]</span>
<span class="gi">+    n_classes = label_dict.shape[0]</span>
<span class="gi">+    F = np.zeros((n_samples, n_classes))</span>
<span class="gi">+</span>
<span class="gi">+    # Build propagation matrix</span>
<span class="gi">+    degrees = X.sum(axis=0)</span>
<span class="gi">+    degrees[degrees == 0] = 1  # Avoid division by 0</span>
<span class="gi">+    # TODO: csr_array</span>
<span class="gi">+    D2 = np.sqrt(sp.sparse.csr_array(sp.sparse.diags((1.0 / degrees), offsets=0)))</span>
<span class="gi">+    P = alpha * ((D2 @ X) @ D2)</span>
<span class="gi">+    # Build base matrix</span>
<span class="gi">+    B = np.zeros((n_samples, n_classes))</span>
<span class="gi">+    B[labels[:, 0], labels[:, 1]] = 1 - alpha</span>
<span class="gi">+</span>
<span class="gi">+    for _ in range(max_iter):</span>
<span class="gi">+        F = (P @ F) + B</span>
<span class="gi">+</span>
<span class="gi">+    return label_dict[np.argmax(F, axis=1)].tolist()</span>


<span class="w"> </span>def _get_label_info(G, label_name):
<span class="gu">@@ -142,4 +199,20 @@ def _get_label_info(G, label_name):</span>
<span class="w"> </span>        Array of labels
<span class="w"> </span>        i-th element contains the label corresponding label ID `i`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    labels = []</span>
<span class="gi">+    label_to_id = {}</span>
<span class="gi">+    lid = 0</span>
<span class="gi">+    for i, n in enumerate(G.nodes(data=True)):</span>
<span class="gi">+        if label_name in n[1]:</span>
<span class="gi">+            label = n[1][label_name]</span>
<span class="gi">+            if label not in label_to_id:</span>
<span class="gi">+                label_to_id[label] = lid</span>
<span class="gi">+                lid += 1</span>
<span class="gi">+            labels.append([i, label_to_id[label]])</span>
<span class="gi">+    labels = np.array(labels)</span>
<span class="gi">+    label_dict = np.array(</span>
<span class="gi">+        [label for label, _ in sorted(label_to_id.items(), key=lambda x: x[1])]</span>
<span class="gi">+    )</span>
<span class="gi">+    return (labels, label_dict)</span>
<span class="gh">diff --git a/networkx/algorithms/non_randomness.py b/networkx/algorithms/non_randomness.py</span>
<span class="gh">index 5270ca312..85483d330 100644</span>
<span class="gd">--- a/networkx/algorithms/non_randomness.py</span>
<span class="gi">+++ b/networkx/algorithms/non_randomness.py</span>
<span class="gu">@@ -1,15 +1,18 @@</span>
<span class="gd">-&quot;&quot;&quot; Computation of graph non-randomness</span>
<span class="gi">+r&quot;&quot;&quot; Computation of graph non-randomness</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;non_randomness&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;non_randomness&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def non_randomness(G, k=None, weight=&#39;weight&#39;):</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def non_randomness(G, k=None, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute the non-randomness of graph G.

<span class="w"> </span>    The first returned value nr is the sum of non-randomness values of all
<span class="gu">@@ -69,4 +72,25 @@ def non_randomness(G, k=None, weight=&#39;weight&#39;):</span>
<span class="w"> </span>           On Randomness Measures for Social Networks,
<span class="w"> </span>           SIAM International Conference on Data Mining. 2009
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXException(&quot;Non connected graph.&quot;)</span>
<span class="gi">+    if len(list(nx.selfloop_edges(G))) &gt; 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph must not contain self-loops&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        k = len(tuple(nx.community.label_propagation_communities(G)))</span>
<span class="gi">+</span>
<span class="gi">+    # eq. 4.4</span>
<span class="gi">+    eigenvalues = np.linalg.eigvals(nx.to_numpy_array(G, weight=weight))</span>
<span class="gi">+    nr = float(np.real(np.sum(eigenvalues[:k])))</span>
<span class="gi">+</span>
<span class="gi">+    n = G.number_of_nodes()</span>
<span class="gi">+    m = G.number_of_edges()</span>
<span class="gi">+    p = (2 * k * m) / (n * (n - k))</span>
<span class="gi">+</span>
<span class="gi">+    # eq. 4.5</span>
<span class="gi">+    nr_rd = (nr - ((n - 2 * k) * p + k)) / math.sqrt(2 * k * p * (1 - p))</span>
<span class="gi">+</span>
<span class="gi">+    return nr, nr_rd</span>
<span class="gh">diff --git a/networkx/algorithms/operators/all.py b/networkx/algorithms/operators/all.py</span>
<span class="gh">index f28c3f056..ba1304b6c 100644</span>
<span class="gd">--- a/networkx/algorithms/operators/all.py</span>
<span class="gi">+++ b/networkx/algorithms/operators/all.py</span>
<span class="gu">@@ -1,13 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Operations on many graphs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from itertools import chain, repeat
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;union_all&#39;, &#39;compose_all&#39;, &#39;disjoint_union_all&#39;, &#39;intersection_all&#39;</span>
<span class="gd">-    ]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;union_all&quot;, &quot;compose_all&quot;, &quot;disjoint_union_all&quot;, &quot;intersection_all&quot;]</span>


<span class="gd">-@nx._dispatchable(graphs=&#39;[graphs]&#39;, preserve_all_attrs=True, returns_graph</span>
<span class="gd">-    =True)</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;[graphs]&quot;, preserve_all_attrs=True, returns_graph=True)</span>
<span class="w"> </span>def union_all(graphs, rename=()):
<span class="w"> </span>    &quot;&quot;&quot;Returns the union of all graphs.

<span class="gu">@@ -65,11 +65,52 @@ def union_all(graphs, rename=()):</span>
<span class="w"> </span>    union
<span class="w"> </span>    disjoint_union_all
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;[graphs]&#39;, preserve_all_attrs=True, returns_graph</span>
<span class="gd">-    =True)</span>
<span class="gi">+    R = None</span>
<span class="gi">+    seen_nodes = set()</span>
<span class="gi">+</span>
<span class="gi">+    # rename graph to obtain disjoint node labels</span>
<span class="gi">+    def add_prefix(graph, prefix):</span>
<span class="gi">+        if prefix is None:</span>
<span class="gi">+            return graph</span>
<span class="gi">+</span>
<span class="gi">+        def label(x):</span>
<span class="gi">+            return f&quot;{prefix}{x}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return nx.relabel_nodes(graph, label)</span>
<span class="gi">+</span>
<span class="gi">+    rename = chain(rename, repeat(None))</span>
<span class="gi">+    graphs = (add_prefix(G, name) for G, name in zip(graphs, rename))</span>
<span class="gi">+</span>
<span class="gi">+    for i, G in enumerate(graphs):</span>
<span class="gi">+        G_nodes_set = set(G.nodes)</span>
<span class="gi">+        if i == 0:</span>
<span class="gi">+            # Union is the same type as first graph</span>
<span class="gi">+            R = G.__class__()</span>
<span class="gi">+        elif G.is_directed() != R.is_directed():</span>
<span class="gi">+            raise nx.NetworkXError(&quot;All graphs must be directed or undirected.&quot;)</span>
<span class="gi">+        elif G.is_multigraph() != R.is_multigraph():</span>
<span class="gi">+            raise nx.NetworkXError(&quot;All graphs must be graphs or multigraphs.&quot;)</span>
<span class="gi">+        elif not seen_nodes.isdisjoint(G_nodes_set):</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;The node sets of the graphs are not disjoint.\n&quot;</span>
<span class="gi">+                &quot;Use `rename` to specify prefixes for the graphs or use\n&quot;</span>
<span class="gi">+                &quot;disjoint_union(G1, G2, ..., GN).&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        seen_nodes |= G_nodes_set</span>
<span class="gi">+        R.graph.update(G.graph)</span>
<span class="gi">+        R.add_nodes_from(G.nodes(data=True))</span>
<span class="gi">+        R.add_edges_from(</span>
<span class="gi">+            G.edges(keys=True, data=True) if G.is_multigraph() else G.edges(data=True)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if R is None:</span>
<span class="gi">+        raise ValueError(&quot;cannot apply union_all to an empty list&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;[graphs]&quot;, preserve_all_attrs=True, returns_graph=True)</span>
<span class="w"> </span>def disjoint_union_all(graphs):
<span class="w"> </span>    &quot;&quot;&quot;Returns the disjoint union of all graphs.

<span class="gu">@@ -111,11 +152,19 @@ def disjoint_union_all(graphs):</span>
<span class="w"> </span>    If a graph attribute is present in multiple graphs, then the value
<span class="w"> </span>    from the last graph in the list with that attribute is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def yield_relabeled(graphs):</span>
<span class="gi">+        first_label = 0</span>
<span class="gi">+        for G in graphs:</span>
<span class="gi">+            yield nx.convert_node_labels_to_integers(G, first_label=first_label)</span>
<span class="gi">+            first_label += len(G)</span>
<span class="gi">+</span>
<span class="gi">+    R = union_all(yield_relabeled(graphs))</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>

<span class="gd">-@nx._dispatchable(graphs=&#39;[graphs]&#39;, preserve_all_attrs=True, returns_graph</span>
<span class="gd">-    =True)</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;[graphs]&quot;, preserve_all_attrs=True, returns_graph=True)</span>
<span class="w"> </span>def compose_all(graphs):
<span class="w"> </span>    &quot;&quot;&quot;Returns the composition of all graphs.

<span class="gu">@@ -157,10 +206,31 @@ def compose_all(graphs):</span>
<span class="w"> </span>    If a graph attribute is present in multiple graphs, then the value
<span class="w"> </span>    from the last graph in the list with that attribute is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = None</span>
<span class="gi">+</span>
<span class="gi">+    # add graph attributes, H attributes take precedent over G attributes</span>
<span class="gi">+    for i, G in enumerate(graphs):</span>
<span class="gi">+        if i == 0:</span>
<span class="gi">+            # create new graph</span>
<span class="gi">+            R = G.__class__()</span>
<span class="gi">+        elif G.is_directed() != R.is_directed():</span>
<span class="gi">+            raise nx.NetworkXError(&quot;All graphs must be directed or undirected.&quot;)</span>
<span class="gi">+        elif G.is_multigraph() != R.is_multigraph():</span>
<span class="gi">+            raise nx.NetworkXError(&quot;All graphs must be graphs or multigraphs.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        R.graph.update(G.graph)</span>
<span class="gi">+        R.add_nodes_from(G.nodes(data=True))</span>
<span class="gi">+        R.add_edges_from(</span>
<span class="gi">+            G.edges(keys=True, data=True) if G.is_multigraph() else G.edges(data=True)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if R is None:</span>
<span class="gi">+        raise ValueError(&quot;cannot apply compose_all to an empty list&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>


<span class="gd">-@nx._dispatchable(graphs=&#39;[graphs]&#39;, returns_graph=True)</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;[graphs]&quot;, returns_graph=True)</span>
<span class="w"> </span>def intersection_all(graphs):
<span class="w"> </span>    &quot;&quot;&quot;Returns a new graph that contains only the nodes and the edges that exist in
<span class="w"> </span>    all graphs.
<span class="gu">@@ -219,4 +289,33 @@ def intersection_all(graphs):</span>
<span class="w"> </span>    [(2, 3)]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = None</span>
<span class="gi">+</span>
<span class="gi">+    for i, G in enumerate(graphs):</span>
<span class="gi">+        G_nodes_set = set(G.nodes)</span>
<span class="gi">+        G_edges_set = set(G.edges)</span>
<span class="gi">+        if not G.is_directed():</span>
<span class="gi">+            if G.is_multigraph():</span>
<span class="gi">+                G_edges_set.update((v, u, k) for u, v, k in list(G_edges_set))</span>
<span class="gi">+            else:</span>
<span class="gi">+                G_edges_set.update((v, u) for u, v in list(G_edges_set))</span>
<span class="gi">+        if i == 0:</span>
<span class="gi">+            # create new graph</span>
<span class="gi">+            R = G.__class__()</span>
<span class="gi">+            node_intersection = G_nodes_set</span>
<span class="gi">+            edge_intersection = G_edges_set</span>
<span class="gi">+        elif G.is_directed() != R.is_directed():</span>
<span class="gi">+            raise nx.NetworkXError(&quot;All graphs must be directed or undirected.&quot;)</span>
<span class="gi">+        elif G.is_multigraph() != R.is_multigraph():</span>
<span class="gi">+            raise nx.NetworkXError(&quot;All graphs must be graphs or multigraphs.&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node_intersection &amp;= G_nodes_set</span>
<span class="gi">+            edge_intersection &amp;= G_edges_set</span>
<span class="gi">+</span>
<span class="gi">+    if R is None:</span>
<span class="gi">+        raise ValueError(&quot;cannot apply intersection_all to an empty list&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    R.add_nodes_from(node_intersection)</span>
<span class="gi">+    R.add_edges_from(edge_intersection)</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>
<span class="gh">diff --git a/networkx/algorithms/operators/binary.py b/networkx/algorithms/operators/binary.py</span>
<span class="gh">index 714600916..0ca3a7b6b 100644</span>
<span class="gd">--- a/networkx/algorithms/operators/binary.py</span>
<span class="gi">+++ b/networkx/algorithms/operators/binary.py</span>
<span class="gu">@@ -2,9 +2,17 @@</span>
<span class="w"> </span>Operations on graphs including union, intersection, difference.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;union&#39;, &#39;compose&#39;, &#39;disjoint_union&#39;, &#39;intersection&#39;,</span>
<span class="gd">-    &#39;difference&#39;, &#39;symmetric_difference&#39;, &#39;full_join&#39;]</span>
<span class="gd">-_G_H = {&#39;G&#39;: 0, &#39;H&#39;: 1}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;union&quot;,</span>
<span class="gi">+    &quot;compose&quot;,</span>
<span class="gi">+    &quot;disjoint_union&quot;,</span>
<span class="gi">+    &quot;intersection&quot;,</span>
<span class="gi">+    &quot;difference&quot;,</span>
<span class="gi">+    &quot;symmetric_difference&quot;,</span>
<span class="gi">+    &quot;full_join&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+_G_H = {&quot;G&quot;: 0, &quot;H&quot;: 1}</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, preserve_all_attrs=True, returns_graph=True)
<span class="gu">@@ -60,7 +68,7 @@ def union(G, H, rename=()):</span>


<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return nx.union_all([G, H], rename)</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, preserve_all_attrs=True, returns_graph=True)
<span class="gu">@@ -114,7 +122,7 @@ def disjoint_union(G, H):</span>
<span class="w"> </span>    &gt;&gt;&gt; U.edges
<span class="w"> </span>    EdgeView([(0, 1), (0, 2), (1, 2), (3, 4), (4, 6), (5, 6)])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return nx.disjoint_union_all([G, H])</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, returns_graph=True)
<span class="gu">@@ -159,7 +167,7 @@ def intersection(G, H):</span>
<span class="w"> </span>    &gt;&gt;&gt; R.edges
<span class="w"> </span>    EdgeView([(1, 2)])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return nx.intersection_all([G, H])</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, returns_graph=True)
<span class="gu">@@ -199,7 +207,22 @@ def difference(G, H):</span>
<span class="w"> </span>    &gt;&gt;&gt; R.edges
<span class="w"> </span>    EdgeView([(0, 2), (1, 3)])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # create new graph</span>
<span class="gi">+    if not G.is_multigraph() == H.is_multigraph():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;G and H must both be graphs or multigraphs.&quot;)</span>
<span class="gi">+    R = nx.create_empty_copy(G, with_data=False)</span>
<span class="gi">+</span>
<span class="gi">+    if set(G) != set(H):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Node sets of graphs not equal&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        edges = G.edges(keys=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = G.edges()</span>
<span class="gi">+    for e in edges:</span>
<span class="gi">+        if not H.has_edge(*e):</span>
<span class="gi">+            R.add_edge(*e)</span>
<span class="gi">+    return R</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, returns_graph=True)
<span class="gu">@@ -232,7 +255,37 @@ def symmetric_difference(G, H):</span>
<span class="w"> </span>    &gt;&gt;&gt; R.edges
<span class="w"> </span>    EdgeView([(0, 2), (0, 3), (1, 3)])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # create new graph</span>
<span class="gi">+    if not G.is_multigraph() == H.is_multigraph():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;G and H must both be graphs or multigraphs.&quot;)</span>
<span class="gi">+    R = nx.create_empty_copy(G, with_data=False)</span>
<span class="gi">+</span>
<span class="gi">+    if set(G) != set(H):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Node sets of graphs not equal&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    gnodes = set(G)  # set of nodes in G</span>
<span class="gi">+    hnodes = set(H)  # set of nodes in H</span>
<span class="gi">+    nodes = gnodes.symmetric_difference(hnodes)</span>
<span class="gi">+    R.add_nodes_from(nodes)</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        edges = G.edges(keys=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = G.edges()</span>
<span class="gi">+    # we could copy the data here but then this function doesn&#39;t</span>
<span class="gi">+    # match intersection and difference</span>
<span class="gi">+    for e in edges:</span>
<span class="gi">+        if not H.has_edge(*e):</span>
<span class="gi">+            R.add_edge(*e)</span>
<span class="gi">+</span>
<span class="gi">+    if H.is_multigraph():</span>
<span class="gi">+        edges = H.edges(keys=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = H.edges()</span>
<span class="gi">+    for e in edges:</span>
<span class="gi">+        if not G.has_edge(*e):</span>
<span class="gi">+            R.add_edge(*e)</span>
<span class="gi">+    return R</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, preserve_all_attrs=True, returns_graph=True)
<span class="gu">@@ -313,7 +366,7 @@ def compose(G, H):</span>
<span class="w"> </span>    &gt;&gt;&gt; print(GcomposeH.edges[(3, 0)][&quot;weight&quot;])
<span class="w"> </span>    100.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return nx.compose_all([G, H])</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, preserve_all_attrs=True, returns_graph=True)
<span class="gu">@@ -370,4 +423,26 @@ def full_join(G, H, rename=(None, None)):</span>
<span class="w"> </span>    union
<span class="w"> </span>    disjoint_union
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = union(G, H, rename)</span>
<span class="gi">+</span>
<span class="gi">+    def add_prefix(graph, prefix):</span>
<span class="gi">+        if prefix is None:</span>
<span class="gi">+            return graph</span>
<span class="gi">+</span>
<span class="gi">+        def label(x):</span>
<span class="gi">+            return f&quot;{prefix}{x}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return nx.relabel_nodes(graph, label)</span>
<span class="gi">+</span>
<span class="gi">+    G = add_prefix(G, rename[0])</span>
<span class="gi">+    H = add_prefix(H, rename[1])</span>
<span class="gi">+</span>
<span class="gi">+    for i in G:</span>
<span class="gi">+        for j in H:</span>
<span class="gi">+            R.add_edge(i, j)</span>
<span class="gi">+    if R.is_directed():</span>
<span class="gi">+        for i in H:</span>
<span class="gi">+            for j in G:</span>
<span class="gi">+                R.add_edge(i, j)</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>
<span class="gh">diff --git a/networkx/algorithms/operators/product.py b/networkx/algorithms/operators/product.py</span>
<span class="gh">index b3ac7e77f..dc3427004 100644</span>
<span class="gd">--- a/networkx/algorithms/operators/product.py</span>
<span class="gi">+++ b/networkx/algorithms/operators/product.py</span>
<span class="gu">@@ -2,20 +2,134 @@</span>
<span class="w"> </span>Graph products.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from itertools import product
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;tensor_product&#39;, &#39;cartesian_product&#39;, &#39;lexicographic_product&#39;,</span>
<span class="gd">-    &#39;strong_product&#39;, &#39;power&#39;, &#39;rooted_product&#39;, &#39;corona_product&#39;,</span>
<span class="gd">-    &#39;modular_product&#39;]</span>
<span class="gd">-_G_H = {&#39;G&#39;: 0, &#39;H&#39;: 1}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;tensor_product&quot;,</span>
<span class="gi">+    &quot;cartesian_product&quot;,</span>
<span class="gi">+    &quot;lexicographic_product&quot;,</span>
<span class="gi">+    &quot;strong_product&quot;,</span>
<span class="gi">+    &quot;power&quot;,</span>
<span class="gi">+    &quot;rooted_product&quot;,</span>
<span class="gi">+    &quot;corona_product&quot;,</span>
<span class="gi">+    &quot;modular_product&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+_G_H = {&quot;G&quot;: 0, &quot;H&quot;: 1}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _dict_product(d1, d2):</span>
<span class="gi">+    return {k: (d1.get(k), d2.get(k)) for k in set(d1) | set(d2)}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Generators for producing graph products</span>
<span class="gi">+def _node_product(G, H):</span>
<span class="gi">+    for u, v in product(G, H):</span>
<span class="gi">+        yield ((u, v), _dict_product(G.nodes[u], H.nodes[v]))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _directed_edges_cross_edges(G, H):</span>
<span class="gi">+    if not G.is_multigraph() and not H.is_multigraph():</span>
<span class="gi">+        for u, v, c in G.edges(data=True):</span>
<span class="gi">+            for x, y, d in H.edges(data=True):</span>
<span class="gi">+                yield (u, x), (v, y), _dict_product(c, d)</span>
<span class="gi">+    if not G.is_multigraph() and H.is_multigraph():</span>
<span class="gi">+        for u, v, c in G.edges(data=True):</span>
<span class="gi">+            for x, y, k, d in H.edges(data=True, keys=True):</span>
<span class="gi">+                yield (u, x), (v, y), k, _dict_product(c, d)</span>
<span class="gi">+    if G.is_multigraph() and not H.is_multigraph():</span>
<span class="gi">+        for u, v, k, c in G.edges(data=True, keys=True):</span>
<span class="gi">+            for x, y, d in H.edges(data=True):</span>
<span class="gi">+                yield (u, x), (v, y), k, _dict_product(c, d)</span>
<span class="gi">+    if G.is_multigraph() and H.is_multigraph():</span>
<span class="gi">+        for u, v, j, c in G.edges(data=True, keys=True):</span>
<span class="gi">+            for x, y, k, d in H.edges(data=True, keys=True):</span>
<span class="gi">+                yield (u, x), (v, y), (j, k), _dict_product(c, d)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _undirected_edges_cross_edges(G, H):</span>
<span class="gi">+    if not G.is_multigraph() and not H.is_multigraph():</span>
<span class="gi">+        for u, v, c in G.edges(data=True):</span>
<span class="gi">+            for x, y, d in H.edges(data=True):</span>
<span class="gi">+                yield (v, x), (u, y), _dict_product(c, d)</span>
<span class="gi">+    if not G.is_multigraph() and H.is_multigraph():</span>
<span class="gi">+        for u, v, c in G.edges(data=True):</span>
<span class="gi">+            for x, y, k, d in H.edges(data=True, keys=True):</span>
<span class="gi">+                yield (v, x), (u, y), k, _dict_product(c, d)</span>
<span class="gi">+    if G.is_multigraph() and not H.is_multigraph():</span>
<span class="gi">+        for u, v, k, c in G.edges(data=True, keys=True):</span>
<span class="gi">+            for x, y, d in H.edges(data=True):</span>
<span class="gi">+                yield (v, x), (u, y), k, _dict_product(c, d)</span>
<span class="gi">+    if G.is_multigraph() and H.is_multigraph():</span>
<span class="gi">+        for u, v, j, c in G.edges(data=True, keys=True):</span>
<span class="gi">+            for x, y, k, d in H.edges(data=True, keys=True):</span>
<span class="gi">+                yield (v, x), (u, y), (j, k), _dict_product(c, d)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _edges_cross_nodes(G, H):</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        for u, v, k, d in G.edges(data=True, keys=True):</span>
<span class="gi">+            for x in H:</span>
<span class="gi">+                yield (u, x), (v, x), k, d</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u, v, d in G.edges(data=True):</span>
<span class="gi">+            for x in H:</span>
<span class="gi">+                if H.is_multigraph():</span>
<span class="gi">+                    yield (u, x), (v, x), None, d</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield (u, x), (v, x), d</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _nodes_cross_edges(G, H):</span>
<span class="gi">+    if H.is_multigraph():</span>
<span class="gi">+        for x in G:</span>
<span class="gi">+            for u, v, k, d in H.edges(data=True, keys=True):</span>
<span class="gi">+                yield (x, u), (x, v), k, d</span>
<span class="gi">+    else:</span>
<span class="gi">+        for x in G:</span>
<span class="gi">+            for u, v, d in H.edges(data=True):</span>
<span class="gi">+                if G.is_multigraph():</span>
<span class="gi">+                    yield (x, u), (x, v), None, d</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield (x, u), (x, v), d</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _edges_cross_nodes_and_nodes(G, H):</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        for u, v, k, d in G.edges(data=True, keys=True):</span>
<span class="gi">+            for x in H:</span>
<span class="gi">+                for y in H:</span>
<span class="gi">+                    yield (u, x), (v, y), k, d</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u, v, d in G.edges(data=True):</span>
<span class="gi">+            for x in H:</span>
<span class="gi">+                for y in H:</span>
<span class="gi">+                    if H.is_multigraph():</span>
<span class="gi">+                        yield (u, x), (v, y), None, d</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield (u, x), (v, y), d</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _init_product_graph(G, H):</span>
<span class="gi">+    if G.is_directed() != H.is_directed():</span>
<span class="gi">+        msg = &quot;G and H must be both directed or both undirected&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    if G.is_multigraph() or H.is_multigraph():</span>
<span class="gi">+        GH = nx.MultiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        GH = nx.Graph()</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        GH = GH.to_directed()</span>
<span class="gi">+    return GH</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, preserve_node_attrs=True, returns_graph=True)
<span class="w"> </span>def tensor_product(G, H):
<span class="gd">-    &quot;&quot;&quot;Returns the tensor product of G and H.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the tensor product of G and H.</span>

<span class="w"> </span>    The tensor product $P$ of the graphs $G$ and $H$ has a node set that
<span class="gd">-    is the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.</span>
<span class="gi">+    is the Cartesian product of the node sets, $V(P)=V(G) \times V(H)$.</span>
<span class="w"> </span>    $P$ has an edge $((u,v), (x,y))$ if and only if $(u,x)$ is an edge in $G$
<span class="w"> </span>    and $(v,y)$ is an edge in $H$.

<span class="gu">@@ -58,15 +172,20 @@ def tensor_product(G, H):</span>
<span class="w"> </span>    Edge attributes and edge keys (for multigraphs) are also copied to the
<span class="w"> </span>    new product graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    GH = _init_product_graph(G, H)</span>
<span class="gi">+    GH.add_nodes_from(_node_product(G, H))</span>
<span class="gi">+    GH.add_edges_from(_directed_edges_cross_edges(G, H))</span>
<span class="gi">+    if not GH.is_directed():</span>
<span class="gi">+        GH.add_edges_from(_undirected_edges_cross_edges(G, H))</span>
<span class="gi">+    return GH</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, preserve_node_attrs=True, returns_graph=True)
<span class="w"> </span>def cartesian_product(G, H):
<span class="gd">-    &quot;&quot;&quot;Returns the Cartesian product of G and H.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Cartesian product of G and H.</span>

<span class="w"> </span>    The Cartesian product $P$ of the graphs $G$ and $H$ has a node set that
<span class="gd">-    is the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.</span>
<span class="gi">+    is the Cartesian product of the node sets, $V(P)=V(G) \times V(H)$.</span>
<span class="w"> </span>    $P$ has an edge $((u,v),(x,y))$ if and only if either $u$ is equal to $x$
<span class="w"> </span>    and both $v$ and $y$ are adjacent in $H$ or if $v$ is equal to $y$ and
<span class="w"> </span>    both $u$ and $x$ are adjacent in $G$.
<span class="gu">@@ -106,15 +225,19 @@ def cartesian_product(G, H):</span>
<span class="w"> </span>    Edge attributes and edge keys (for multigraphs) are also copied to the
<span class="w"> </span>    new product graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    GH = _init_product_graph(G, H)</span>
<span class="gi">+    GH.add_nodes_from(_node_product(G, H))</span>
<span class="gi">+    GH.add_edges_from(_edges_cross_nodes(G, H))</span>
<span class="gi">+    GH.add_edges_from(_nodes_cross_edges(G, H))</span>
<span class="gi">+    return GH</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, preserve_node_attrs=True, returns_graph=True)
<span class="w"> </span>def lexicographic_product(G, H):
<span class="gd">-    &quot;&quot;&quot;Returns the lexicographic product of G and H.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the lexicographic product of G and H.</span>

<span class="w"> </span>    The lexicographical product $P$ of the graphs $G$ and $H$ has a node set
<span class="gd">-    that is the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.</span>
<span class="gi">+    that is the Cartesian product of the node sets, $V(P)=V(G) \times V(H)$.</span>
<span class="w"> </span>    $P$ has an edge $((u,v), (x,y))$ if and only if $(u,v)$ is an edge in $G$
<span class="w"> </span>    or $u==v$ and $(x,y)$ is an edge in $H$.

<span class="gu">@@ -153,15 +276,21 @@ def lexicographic_product(G, H):</span>
<span class="w"> </span>    Edge attributes and edge keys (for multigraphs) are also copied to the
<span class="w"> </span>    new product graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    GH = _init_product_graph(G, H)</span>
<span class="gi">+    GH.add_nodes_from(_node_product(G, H))</span>
<span class="gi">+    # Edges in G regardless of H designation</span>
<span class="gi">+    GH.add_edges_from(_edges_cross_nodes_and_nodes(G, H))</span>
<span class="gi">+    # For each x in G, only if there is an edge in H</span>
<span class="gi">+    GH.add_edges_from(_nodes_cross_edges(G, H))</span>
<span class="gi">+    return GH</span>


<span class="w"> </span>@nx._dispatchable(graphs=_G_H, preserve_node_attrs=True, returns_graph=True)
<span class="w"> </span>def strong_product(G, H):
<span class="gd">-    &quot;&quot;&quot;Returns the strong product of G and H.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the strong product of G and H.</span>

<span class="w"> </span>    The strong product $P$ of the graphs $G$ and $H$ has a node set that
<span class="gd">-    is the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.</span>
<span class="gi">+    is the Cartesian product of the node sets, $V(P)=V(G) \times V(H)$.</span>
<span class="w"> </span>    $P$ has an edge $((u,v), (x,y))$ if and only if
<span class="w"> </span>    $u==v$ and $(x,y)$ is an edge in $H$, or
<span class="w"> </span>    $x==y$ and $(u,v)$ is an edge in $G$, or
<span class="gu">@@ -202,11 +331,18 @@ def strong_product(G, H):</span>
<span class="w"> </span>    Edge attributes and edge keys (for multigraphs) are also copied to the
<span class="w"> </span>    new product graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    GH = _init_product_graph(G, H)</span>
<span class="gi">+    GH.add_nodes_from(_node_product(G, H))</span>
<span class="gi">+    GH.add_edges_from(_nodes_cross_edges(G, H))</span>
<span class="gi">+    GH.add_edges_from(_edges_cross_nodes(G, H))</span>
<span class="gi">+    GH.add_edges_from(_directed_edges_cross_edges(G, H))</span>
<span class="gi">+    if not GH.is_directed():</span>
<span class="gi">+        GH.add_edges_from(_undirected_edges_cross_edges(G, H))</span>
<span class="gi">+    return GH</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def power(G, k):
<span class="w"> </span>    &quot;&quot;&quot;Returns the specified power of a graph.
<span class="gu">@@ -270,10 +406,32 @@ def power(G, k):</span>
<span class="w"> </span>    *Graph Theory* by Bondy and Murty [1]_.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    if k &lt;= 0:</span>
<span class="gi">+        raise ValueError(&quot;k must be a positive integer&quot;)</span>
<span class="gi">+    H = nx.Graph()</span>
<span class="gi">+    H.add_nodes_from(G)</span>
<span class="gi">+    # update BFS code to ignore self loops.</span>
<span class="gi">+    for n in G:</span>
<span class="gi">+        seen = {}  # level (number of hops) when seen in BFS</span>
<span class="gi">+        level = 1  # the current level</span>
<span class="gi">+        nextlevel = G[n]</span>
<span class="gi">+        while nextlevel:</span>
<span class="gi">+            thislevel = nextlevel  # advance to next level</span>
<span class="gi">+            nextlevel = {}  # and start a new list (fringe)</span>
<span class="gi">+            for v in thislevel:</span>
<span class="gi">+                if v == n:  # avoid self loop</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if v not in seen:</span>
<span class="gi">+                    seen[v] = level  # set the level of vertex v</span>
<span class="gi">+                    nextlevel.update(G[v])  # add neighbors of v</span>
<span class="gi">+            if k &lt;= level:</span>
<span class="gi">+                break</span>
<span class="gi">+            level += 1</span>
<span class="gi">+        H.add_edges_from((n, nbr) for nbr in seen)</span>
<span class="gi">+    return H</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=_G_H, returns_graph=True)
<span class="w"> </span>def rooted_product(G, H, root):
<span class="w"> </span>    &quot;&quot;&quot;Return the rooted product of graphs G and H rooted at root in H.
<span class="gu">@@ -300,16 +458,25 @@ def rooted_product(G, H, root):</span>
<span class="w"> </span>    The nodes of R are the Cartesian Product of the nodes of G and H.
<span class="w"> </span>    The nodes of G and H are not relabeled.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if root not in H:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;root must be a vertex in H&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    R = nx.Graph()</span>
<span class="gi">+    R.add_nodes_from(product(G, H))</span>

<span class="gi">+    R.add_edges_from(((e[0], root), (e[1], root)) for e in G.edges())</span>
<span class="gi">+    R.add_edges_from(((g, e[0]), (g, e[1])) for g in G for e in H.edges())</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    return R</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=_G_H, returns_graph=True)
<span class="w"> </span>def corona_product(G, H):
<span class="gd">-    &quot;&quot;&quot;Returns the Corona product of G and H.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Corona product of G and H.</span>

<span class="gd">-    The corona product of $G$ and $H$ is the graph $C = G \\circ H$ obtained by</span>
<span class="gi">+    The corona product of $G$ and $H$ is the graph $C = G \circ H$ obtained by</span>
<span class="w"> </span>    taking one copy of $G$, called the center graph, $|V(G)|$ copies of $H$,
<span class="w"> </span>    called the outer graph, and making the $i$-th vertex of $G$ adjacent to
<span class="w"> </span>    every vertex of the $i$-th copy of $H$, where $1 ≤ i ≤ |V(G)|$.
<span class="gu">@@ -349,16 +516,33 @@ def corona_product(G, H):</span>
<span class="w"> </span>    [2] A. Faraji, &quot;Corona Product in Graph Theory,&quot; Ali Faraji, May 11, 2021.
<span class="w"> </span>        https://blog.alifaraji.ir/math/graph-theory/corona-product.html (accessed Dec. 07, 2021).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    GH = _init_product_graph(G, H)</span>
<span class="gi">+    GH.add_nodes_from(G)</span>
<span class="gi">+    GH.add_edges_from(G.edges)</span>
<span class="gi">+</span>
<span class="gi">+    for G_node in G:</span>
<span class="gi">+        # copy nodes of H in GH, call it H_i</span>
<span class="gi">+        GH.add_nodes_from((G_node, v) for v in H)</span>
<span class="gi">+</span>
<span class="gi">+        # copy edges of H_i based on H</span>
<span class="gi">+        GH.add_edges_from(</span>
<span class="gi">+            ((G_node, e0), (G_node, e1), d) for e0, e1, d in H.edges.data()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # creating new edges between H_i and a G&#39;s node</span>
<span class="gi">+        GH.add_edges_from((G_node, (G_node, H_node)) for H_node in H)</span>
<span class="gi">+</span>
<span class="gi">+    return GH</span>


<span class="gd">-@nx._dispatchable(graphs=_G_H, preserve_edge_attrs=True,</span>
<span class="gd">-    preserve_node_attrs=True, returns_graph=True)</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs=_G_H, preserve_edge_attrs=True, preserve_node_attrs=True, returns_graph=True</span>
<span class="gi">+)</span>
<span class="w"> </span>def modular_product(G, H):
<span class="gd">-    &quot;&quot;&quot;Returns the Modular product of G and H.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Modular product of G and H.</span>

<span class="gd">-    The modular product of `G` and `H` is the graph $M = G \\nabla H$,</span>
<span class="gd">-    consisting of the node set $V(M) = V(G) \\times V(H)$ that is the Cartesian</span>
<span class="gi">+    The modular product of `G` and `H` is the graph $M = G \nabla H$,</span>
<span class="gi">+    consisting of the node set $V(M) = V(G) \times V(H)$ that is the Cartesian</span>
<span class="w"> </span>    product of the node sets of `G` and `H`. Further, M contains an edge ((u, v), (x, y)):

<span class="w"> </span>    - if u is adjacent to x in `G` and v is adjacent to y in `H`, or
<span class="gu">@@ -418,4 +602,29 @@ def modular_product(G, H):</span>
<span class="w"> </span>        entrance to the task of finding the nondensity of a graph.&quot; Proc. Third
<span class="w"> </span>        All-Union Conference on Problems of Theoretical Cybernetics. 1974.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed() or H.is_directed():</span>
<span class="gi">+        raise nx.NetworkXNotImplemented(</span>
<span class="gi">+            &quot;Modular product not implemented for directed graphs&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if G.is_multigraph() or H.is_multigraph():</span>
<span class="gi">+        raise nx.NetworkXNotImplemented(</span>
<span class="gi">+            &quot;Modular product not implemented for multigraphs&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    GH = _init_product_graph(G, H)</span>
<span class="gi">+    GH.add_nodes_from(_node_product(G, H))</span>
<span class="gi">+</span>
<span class="gi">+    for u, v, c in G.edges(data=True):</span>
<span class="gi">+        for x, y, d in H.edges(data=True):</span>
<span class="gi">+            GH.add_edge((u, x), (v, y), **_dict_product(c, d))</span>
<span class="gi">+            GH.add_edge((v, x), (u, y), **_dict_product(c, d))</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.complement(G)</span>
<span class="gi">+    H = nx.complement(H)</span>
<span class="gi">+</span>
<span class="gi">+    for u, v, c in G.edges(data=True):</span>
<span class="gi">+        for x, y, d in H.edges(data=True):</span>
<span class="gi">+            GH.add_edge((u, x), (v, y), **_dict_product(c, d))</span>
<span class="gi">+            GH.add_edge((v, x), (u, y), **_dict_product(c, d))</span>
<span class="gi">+</span>
<span class="gi">+    return GH</span>
<span class="gh">diff --git a/networkx/algorithms/operators/unary.py b/networkx/algorithms/operators/unary.py</span>
<span class="gh">index 9026b3bcb..64be249f6 100644</span>
<span class="gd">--- a/networkx/algorithms/operators/unary.py</span>
<span class="gi">+++ b/networkx/algorithms/operators/unary.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Unary operations on graphs&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;complement&#39;, &#39;reverse&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;complement&quot;, &quot;reverse&quot;]</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -31,7 +32,12 @@ def complement(G):</span>
<span class="w"> </span>    EdgeView([(1, 4), (1, 5), (2, 4), (2, 5), (4, 5)])

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = G.__class__()</span>
<span class="gi">+    R.add_nodes_from(G)</span>
<span class="gi">+    R.add_edges_from(</span>
<span class="gi">+        ((n, n2) for n, nbrs in G.adjacency() for n2 in G if n2 not in nbrs if n != n2)</span>
<span class="gi">+    )</span>
<span class="gi">+    return R</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -64,4 +70,7 @@ def reverse(G, copy=True):</span>
<span class="w"> </span>    OutEdgeView([(2, 1), (3, 1), (3, 2), (4, 3), (5, 3)])

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Cannot reverse an undirected graph.&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return G.reverse(copy=copy)</span>
<span class="gh">diff --git a/networkx/algorithms/planar_drawing.py b/networkx/algorithms/planar_drawing.py</span>
<span class="gh">index 2439880d2..ea25809b6 100644</span>
<span class="gd">--- a/networkx/algorithms/planar_drawing.py</span>
<span class="gi">+++ b/networkx/algorithms/planar_drawing.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;combinatorial_embedding_to_pos&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;combinatorial_embedding_to_pos&quot;]</span>


<span class="w"> </span>def combinatorial_embedding_to_pos(embedding, fully_triangulate=False):
<span class="gu">@@ -33,12 +35,106 @@ def combinatorial_embedding_to_pos(embedding, fully_triangulate=False):</span>
<span class="w"> </span>        http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(embedding.nodes()) &lt; 4:</span>
<span class="gi">+        # Position the node in any triangle</span>
<span class="gi">+        default_positions = [(0, 0), (2, 0), (1, 1)]</span>
<span class="gi">+        pos = {}</span>
<span class="gi">+        for i, v in enumerate(embedding.nodes()):</span>
<span class="gi">+            pos[v] = default_positions[i]</span>
<span class="gi">+        return pos</span>
<span class="gi">+</span>
<span class="gi">+    embedding, outer_face = triangulate_embedding(embedding, fully_triangulate)</span>
<span class="gi">+</span>
<span class="gi">+    # The following dicts map a node to another node</span>
<span class="gi">+    # If a node is not in the key set it means that the node is not yet in G_k</span>
<span class="gi">+    # If a node maps to None then the corresponding subtree does not exist</span>
<span class="gi">+    left_t_child = {}</span>
<span class="gi">+    right_t_child = {}</span>
<span class="gi">+</span>
<span class="gi">+    # The following dicts map a node to an integer</span>
<span class="gi">+    delta_x = {}</span>
<span class="gi">+    y_coordinate = {}</span>
<span class="gi">+</span>
<span class="gi">+    node_list = get_canonical_ordering(embedding, outer_face)</span>
<span class="gi">+</span>
<span class="gi">+    # 1. Phase: Compute relative positions</span>
<span class="gi">+</span>
<span class="gi">+    # Initialization</span>
<span class="gi">+    v1, v2, v3 = node_list[0][0], node_list[1][0], node_list[2][0]</span>
<span class="gi">+</span>
<span class="gi">+    delta_x[v1] = 0</span>
<span class="gi">+    y_coordinate[v1] = 0</span>
<span class="gi">+    right_t_child[v1] = v3</span>
<span class="gi">+    left_t_child[v1] = None</span>
<span class="gi">+</span>
<span class="gi">+    delta_x[v2] = 1</span>
<span class="gi">+    y_coordinate[v2] = 0</span>
<span class="gi">+    right_t_child[v2] = None</span>
<span class="gi">+    left_t_child[v2] = None</span>
<span class="gi">+</span>
<span class="gi">+    delta_x[v3] = 1</span>
<span class="gi">+    y_coordinate[v3] = 1</span>
<span class="gi">+    right_t_child[v3] = v2</span>
<span class="gi">+    left_t_child[v3] = None</span>
<span class="gi">+</span>
<span class="gi">+    for k in range(3, len(node_list)):</span>
<span class="gi">+        vk, contour_nbrs = node_list[k]</span>
<span class="gi">+        wp = contour_nbrs[0]</span>
<span class="gi">+        wp1 = contour_nbrs[1]</span>
<span class="gi">+        wq = contour_nbrs[-1]</span>
<span class="gi">+        wq1 = contour_nbrs[-2]</span>
<span class="gi">+        adds_mult_tri = len(contour_nbrs) &gt; 2</span>
<span class="gi">+</span>
<span class="gi">+        # Stretch gaps:</span>
<span class="gi">+        delta_x[wp1] += 1</span>
<span class="gi">+        delta_x[wq] += 1</span>
<span class="gi">+</span>
<span class="gi">+        delta_x_wp_wq = sum(delta_x[x] for x in contour_nbrs[1:])</span>
<span class="gi">+</span>
<span class="gi">+        # Adjust offsets</span>
<span class="gi">+        delta_x[vk] = (-y_coordinate[wp] + delta_x_wp_wq + y_coordinate[wq]) // 2</span>
<span class="gi">+        y_coordinate[vk] = (y_coordinate[wp] + delta_x_wp_wq + y_coordinate[wq]) // 2</span>
<span class="gi">+        delta_x[wq] = delta_x_wp_wq - delta_x[vk]</span>
<span class="gi">+        if adds_mult_tri:</span>
<span class="gi">+            delta_x[wp1] -= delta_x[vk]</span>
<span class="gi">+</span>
<span class="gi">+        # Install v_k:</span>
<span class="gi">+        right_t_child[wp] = vk</span>
<span class="gi">+        right_t_child[vk] = wq</span>
<span class="gi">+        if adds_mult_tri:</span>
<span class="gi">+            left_t_child[vk] = wp1</span>
<span class="gi">+            right_t_child[wq1] = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            left_t_child[vk] = None</span>
<span class="gi">+</span>
<span class="gi">+    # 2. Phase: Set absolute positions</span>
<span class="gi">+    pos = {}</span>
<span class="gi">+    pos[v1] = (0, y_coordinate[v1])</span>
<span class="gi">+    remaining_nodes = [v1]</span>
<span class="gi">+    while remaining_nodes:</span>
<span class="gi">+        parent_node = remaining_nodes.pop()</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate position for left child</span>
<span class="gi">+        set_position(</span>
<span class="gi">+            parent_node, left_t_child, remaining_nodes, delta_x, y_coordinate, pos</span>
<span class="gi">+        )</span>
<span class="gi">+        # Calculate position for right child</span>
<span class="gi">+        set_position(</span>
<span class="gi">+            parent_node, right_t_child, remaining_nodes, delta_x, y_coordinate, pos</span>
<span class="gi">+        )</span>
<span class="gi">+    return pos</span>


<span class="w"> </span>def set_position(parent, tree, remaining_nodes, delta_x, y_coordinate, pos):
<span class="w"> </span>    &quot;&quot;&quot;Helper method to calculate the absolute position of nodes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    child = tree[parent]</span>
<span class="gi">+    parent_node_x = pos[parent][0]</span>
<span class="gi">+    if child is not None:</span>
<span class="gi">+        # Calculate pos of child</span>
<span class="gi">+        child_x = parent_node_x + delta_x[child]</span>
<span class="gi">+        pos[child] = (child_x, y_coordinate[child])</span>
<span class="gi">+        # Remember to calculate pos of its children</span>
<span class="gi">+        remaining_nodes.append(child)</span>


<span class="w"> </span>def get_canonical_ordering(embedding, outer_face):
<span class="gu">@@ -88,7 +184,124 @@ def get_canonical_ordering(embedding, outer_face):</span>
<span class="w"> </span>        http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    v1 = outer_face[0]</span>
<span class="gi">+    v2 = outer_face[1]</span>
<span class="gi">+    chords = defaultdict(int)  # Maps nodes to the number of their chords</span>
<span class="gi">+    marked_nodes = set()</span>
<span class="gi">+    ready_to_pick = set(outer_face)</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize outer_face_ccw_nbr (do not include v1 -&gt; v2)</span>
<span class="gi">+    outer_face_ccw_nbr = {}</span>
<span class="gi">+    prev_nbr = v2</span>
<span class="gi">+    for idx in range(2, len(outer_face)):</span>
<span class="gi">+        outer_face_ccw_nbr[prev_nbr] = outer_face[idx]</span>
<span class="gi">+        prev_nbr = outer_face[idx]</span>
<span class="gi">+    outer_face_ccw_nbr[prev_nbr] = v1</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize outer_face_cw_nbr (do not include v2 -&gt; v1)</span>
<span class="gi">+    outer_face_cw_nbr = {}</span>
<span class="gi">+    prev_nbr = v1</span>
<span class="gi">+    for idx in range(len(outer_face) - 1, 0, -1):</span>
<span class="gi">+        outer_face_cw_nbr[prev_nbr] = outer_face[idx]</span>
<span class="gi">+        prev_nbr = outer_face[idx]</span>
<span class="gi">+</span>
<span class="gi">+    def is_outer_face_nbr(x, y):</span>
<span class="gi">+        if x not in outer_face_ccw_nbr:</span>
<span class="gi">+            return outer_face_cw_nbr[x] == y</span>
<span class="gi">+        if x not in outer_face_cw_nbr:</span>
<span class="gi">+            return outer_face_ccw_nbr[x] == y</span>
<span class="gi">+        return outer_face_ccw_nbr[x] == y or outer_face_cw_nbr[x] == y</span>
<span class="gi">+</span>
<span class="gi">+    def is_on_outer_face(x):</span>
<span class="gi">+        return x not in marked_nodes and (x in outer_face_ccw_nbr or x == v1)</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize number of chords</span>
<span class="gi">+    for v in outer_face:</span>
<span class="gi">+        for nbr in embedding.neighbors_cw_order(v):</span>
<span class="gi">+            if is_on_outer_face(nbr) and not is_outer_face_nbr(v, nbr):</span>
<span class="gi">+                chords[v] += 1</span>
<span class="gi">+                ready_to_pick.discard(v)</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize canonical_ordering</span>
<span class="gi">+    canonical_ordering = [None] * len(embedding.nodes())</span>
<span class="gi">+    canonical_ordering[0] = (v1, [])</span>
<span class="gi">+    canonical_ordering[1] = (v2, [])</span>
<span class="gi">+    ready_to_pick.discard(v1)</span>
<span class="gi">+    ready_to_pick.discard(v2)</span>
<span class="gi">+</span>
<span class="gi">+    for k in range(len(embedding.nodes()) - 1, 1, -1):</span>
<span class="gi">+        # 1. Pick v from ready_to_pick</span>
<span class="gi">+        v = ready_to_pick.pop()</span>
<span class="gi">+        marked_nodes.add(v)</span>
<span class="gi">+</span>
<span class="gi">+        # v has exactly two neighbors on the outer face (wp and wq)</span>
<span class="gi">+        wp = None</span>
<span class="gi">+        wq = None</span>
<span class="gi">+        # Iterate over neighbors of v to find wp and wq</span>
<span class="gi">+        nbr_iterator = iter(embedding.neighbors_cw_order(v))</span>
<span class="gi">+        while True:</span>
<span class="gi">+            nbr = next(nbr_iterator)</span>
<span class="gi">+            if nbr in marked_nodes:</span>
<span class="gi">+                # Only consider nodes that are not yet removed</span>
<span class="gi">+                continue</span>
<span class="gi">+            if is_on_outer_face(nbr):</span>
<span class="gi">+                # nbr is either wp or wq</span>
<span class="gi">+                if nbr == v1:</span>
<span class="gi">+                    wp = v1</span>
<span class="gi">+                elif nbr == v2:</span>
<span class="gi">+                    wq = v2</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if outer_face_cw_nbr[nbr] == v:</span>
<span class="gi">+                        # nbr is wp</span>
<span class="gi">+                        wp = nbr</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # nbr is wq</span>
<span class="gi">+                        wq = nbr</span>
<span class="gi">+            if wp is not None and wq is not None:</span>
<span class="gi">+                # We don&#39;t need to iterate any further</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        # Obtain new nodes on outer face (neighbors of v from wp to wq)</span>
<span class="gi">+        wp_wq = [wp]</span>
<span class="gi">+        nbr = wp</span>
<span class="gi">+        while nbr != wq:</span>
<span class="gi">+            # Get next neighbor (clockwise on the outer face)</span>
<span class="gi">+            next_nbr = embedding[v][nbr][&quot;ccw&quot;]</span>
<span class="gi">+            wp_wq.append(next_nbr)</span>
<span class="gi">+            # Update outer face</span>
<span class="gi">+            outer_face_cw_nbr[nbr] = next_nbr</span>
<span class="gi">+            outer_face_ccw_nbr[next_nbr] = nbr</span>
<span class="gi">+            # Move to next neighbor of v</span>
<span class="gi">+            nbr = next_nbr</span>
<span class="gi">+</span>
<span class="gi">+        if len(wp_wq) == 2:</span>
<span class="gi">+            # There was a chord between wp and wq, decrease number of chords</span>
<span class="gi">+            chords[wp] -= 1</span>
<span class="gi">+            if chords[wp] == 0:</span>
<span class="gi">+                ready_to_pick.add(wp)</span>
<span class="gi">+            chords[wq] -= 1</span>
<span class="gi">+            if chords[wq] == 0:</span>
<span class="gi">+                ready_to_pick.add(wq)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Update all chords involving w_(p+1) to w_(q-1)</span>
<span class="gi">+            new_face_nodes = set(wp_wq[1:-1])</span>
<span class="gi">+            for w in new_face_nodes:</span>
<span class="gi">+                # If we do not find a chord for w later we can pick it next</span>
<span class="gi">+                ready_to_pick.add(w)</span>
<span class="gi">+                for nbr in embedding.neighbors_cw_order(w):</span>
<span class="gi">+                    if is_on_outer_face(nbr) and not is_outer_face_nbr(w, nbr):</span>
<span class="gi">+                        # There is a chord involving w</span>
<span class="gi">+                        chords[w] += 1</span>
<span class="gi">+                        ready_to_pick.discard(w)</span>
<span class="gi">+                        if nbr not in new_face_nodes:</span>
<span class="gi">+                            # Also increase chord for the neighbor</span>
<span class="gi">+                            # We only iterator over new_face_nodes</span>
<span class="gi">+                            chords[nbr] += 1</span>
<span class="gi">+                            ready_to_pick.discard(nbr)</span>
<span class="gi">+        # Set the canonical ordering node and the list of contour neighbors</span>
<span class="gi">+        canonical_ordering[k] = (v, wp_wq)</span>
<span class="gi">+</span>
<span class="gi">+    return canonical_ordering</span>


<span class="w"> </span>def triangulate_face(embedding, v1, v2):
<span class="gu">@@ -101,7 +314,23 @@ def triangulate_face(embedding, v1, v2):</span>
<span class="w"> </span>        The half-edge (v1, v2) belongs to the face that gets triangulated
<span class="w"> </span>    v2 : node
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _, v3 = embedding.next_face_half_edge(v1, v2)</span>
<span class="gi">+    _, v4 = embedding.next_face_half_edge(v2, v3)</span>
<span class="gi">+    if v1 in (v2, v3):</span>
<span class="gi">+        # The component has less than 3 nodes</span>
<span class="gi">+        return</span>
<span class="gi">+    while v1 != v4:</span>
<span class="gi">+        # Add edge if not already present on other side</span>
<span class="gi">+        if embedding.has_edge(v1, v3):</span>
<span class="gi">+            # Cannot triangulate at this position</span>
<span class="gi">+            v1, v2, v3 = v2, v3, v4</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Add edge for triangulation</span>
<span class="gi">+            embedding.add_half_edge(v1, v3, ccw=v2)</span>
<span class="gi">+            embedding.add_half_edge(v3, v1, cw=v2)</span>
<span class="gi">+            v1, v2, v3 = v1, v3, v4</span>
<span class="gi">+        # Get next node</span>
<span class="gi">+        _, v4 = embedding.next_face_half_edge(v2, v3)</span>


<span class="w"> </span>def triangulate_embedding(embedding, fully_triangulate=True):
<span class="gu">@@ -131,7 +360,46 @@ def triangulate_embedding(embedding, fully_triangulate=True):</span>
<span class="w"> </span>        nodes.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(embedding.nodes) &lt;= 1:</span>
<span class="gi">+        return embedding, list(embedding.nodes)</span>
<span class="gi">+    embedding = nx.PlanarEmbedding(embedding)</span>
<span class="gi">+</span>
<span class="gi">+    # Get a list with a node for each connected component</span>
<span class="gi">+    component_nodes = [next(iter(x)) for x in nx.connected_components(embedding)]</span>
<span class="gi">+</span>
<span class="gi">+    # 1. Make graph a single component (add edge between components)</span>
<span class="gi">+    for i in range(len(component_nodes) - 1):</span>
<span class="gi">+        v1 = component_nodes[i]</span>
<span class="gi">+        v2 = component_nodes[i + 1]</span>
<span class="gi">+        embedding.connect_components(v1, v2)</span>
<span class="gi">+</span>
<span class="gi">+    # 2. Calculate faces, ensure 2-connectedness and determine outer face</span>
<span class="gi">+    outer_face = []  # A face with the most number of nodes</span>
<span class="gi">+    face_list = []</span>
<span class="gi">+    edges_visited = set()  # Used to keep track of already visited faces</span>
<span class="gi">+    for v in embedding.nodes():</span>
<span class="gi">+        for w in embedding.neighbors_cw_order(v):</span>
<span class="gi">+            new_face = make_bi_connected(embedding, v, w, edges_visited)</span>
<span class="gi">+            if new_face:</span>
<span class="gi">+                # Found a new face</span>
<span class="gi">+                face_list.append(new_face)</span>
<span class="gi">+                if len(new_face) &gt; len(outer_face):</span>
<span class="gi">+                    # The face is a candidate to be the outer face</span>
<span class="gi">+                    outer_face = new_face</span>
<span class="gi">+</span>
<span class="gi">+    # 3. Triangulate (internal) faces</span>
<span class="gi">+    for face in face_list:</span>
<span class="gi">+        if face is not outer_face or fully_triangulate:</span>
<span class="gi">+            # Triangulate this face</span>
<span class="gi">+            triangulate_face(embedding, face[0], face[1])</span>
<span class="gi">+</span>
<span class="gi">+    if fully_triangulate:</span>
<span class="gi">+        v1 = outer_face[0]</span>
<span class="gi">+        v2 = outer_face[1]</span>
<span class="gi">+        v3 = embedding[v2][v1][&quot;ccw&quot;]</span>
<span class="gi">+        outer_face = [v1, v2, v3]</span>
<span class="gi">+</span>
<span class="gi">+    return embedding, outer_face</span>


<span class="w"> </span>def make_bi_connected(embedding, starting_node, outgoing_node, edges_counted):
<span class="gu">@@ -156,4 +424,41 @@ def make_bi_connected(embedding, starting_node, outgoing_node, edges_counted):</span>
<span class="w"> </span>    face_nodes: list
<span class="w"> </span>        A list of all nodes at the border of this face
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Check if the face has already been calculated</span>
<span class="gi">+    if (starting_node, outgoing_node) in edges_counted:</span>
<span class="gi">+        # This face was already counted</span>
<span class="gi">+        return []</span>
<span class="gi">+    edges_counted.add((starting_node, outgoing_node))</span>
<span class="gi">+</span>
<span class="gi">+    # Add all edges to edges_counted which have this face to their left</span>
<span class="gi">+    v1 = starting_node</span>
<span class="gi">+    v2 = outgoing_node</span>
<span class="gi">+    face_list = [starting_node]  # List of nodes around the face</span>
<span class="gi">+    face_set = set(face_list)  # Set for faster queries</span>
<span class="gi">+    _, v3 = embedding.next_face_half_edge(v1, v2)</span>
<span class="gi">+</span>
<span class="gi">+    # Move the nodes v1, v2, v3 around the face:</span>
<span class="gi">+    while v2 != starting_node or v3 != outgoing_node:</span>
<span class="gi">+        if v1 == v2:</span>
<span class="gi">+            raise nx.NetworkXException(&quot;Invalid half-edge&quot;)</span>
<span class="gi">+        # cycle is not completed yet</span>
<span class="gi">+        if v2 in face_set:</span>
<span class="gi">+            # v2 encountered twice: Add edge to ensure 2-connectedness</span>
<span class="gi">+            embedding.add_half_edge(v1, v3, ccw=v2)</span>
<span class="gi">+            embedding.add_half_edge(v3, v1, cw=v2)</span>
<span class="gi">+            edges_counted.add((v2, v3))</span>
<span class="gi">+            edges_counted.add((v3, v1))</span>
<span class="gi">+            v2 = v1</span>
<span class="gi">+        else:</span>
<span class="gi">+            face_set.add(v2)</span>
<span class="gi">+            face_list.append(v2)</span>
<span class="gi">+</span>
<span class="gi">+        # set next edge</span>
<span class="gi">+        v1 = v2</span>
<span class="gi">+        v2, v3 = embedding.next_face_half_edge(v2, v3)</span>
<span class="gi">+</span>
<span class="gi">+        # remember that this edge has been counted</span>
<span class="gi">+        edges_counted.add((v1, v2))</span>
<span class="gi">+</span>
<span class="gi">+    return face_list</span>
<span class="gh">diff --git a/networkx/algorithms/planarity.py b/networkx/algorithms/planarity.py</span>
<span class="gh">index 5c1c4f969..17d0bec5a 100644</span>
<span class="gd">--- a/networkx/algorithms/planarity.py</span>
<span class="gi">+++ b/networkx/algorithms/planarity.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;check_planarity&#39;, &#39;is_planar&#39;, &#39;PlanarEmbedding&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;check_planarity&quot;, &quot;is_planar&quot;, &quot;PlanarEmbedding&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -32,7 +34,8 @@ def is_planar(G):</span>
<span class="w"> </span>    check_planarity :
<span class="w"> </span>        Check if graph is planar *and* return a `PlanarEmbedding` instance if True.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return check_planarity(G, counterexample=False)[0]</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -97,13 +100,34 @@ def check_planarity(G, counterexample=False):</span>
<span class="w"> </span>        Lecture Notes Series on Computing: Volume 12
<span class="w"> </span>        2004
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    planarity_state = LRPlanarity(G)</span>
<span class="gi">+    embedding = planarity_state.lr_planarity()</span>
<span class="gi">+    if embedding is None:</span>
<span class="gi">+        # graph is not planar</span>
<span class="gi">+        if counterexample:</span>
<span class="gi">+            return False, get_counterexample(G)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False, None</span>
<span class="gi">+    else:</span>
<span class="gi">+        # graph is planar</span>
<span class="gi">+        return True, embedding</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def check_planarity_recursive(G, counterexample=False):
<span class="w"> </span>    &quot;&quot;&quot;Recursive version of :meth:`check_planarity`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    planarity_state = LRPlanarity(G)</span>
<span class="gi">+    embedding = planarity_state.lr_planarity_recursive()</span>
<span class="gi">+    if embedding is None:</span>
<span class="gi">+        # graph is not planar</span>
<span class="gi">+        if counterexample:</span>
<span class="gi">+            return False, get_counterexample_recursive(G)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False, None</span>
<span class="gi">+    else:</span>
<span class="gi">+        # graph is planar</span>
<span class="gi">+        return True, embedding</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -126,13 +150,46 @@ def get_counterexample(G):</span>
<span class="w"> </span>        A Kuratowski subgraph that proves that G is not planar.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # copy graph</span>
<span class="gi">+    G = nx.Graph(G)</span>
<span class="gi">+</span>
<span class="gi">+    if check_planarity(G)[0]:</span>
<span class="gi">+        raise nx.NetworkXException(&quot;G is planar - no counter example.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # find Kuratowski subgraph</span>
<span class="gi">+    subgraph = nx.Graph()</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        nbrs = list(G[u])</span>
<span class="gi">+        for v in nbrs:</span>
<span class="gi">+            G.remove_edge(u, v)</span>
<span class="gi">+            if check_planarity(G)[0]:</span>
<span class="gi">+                G.add_edge(u, v)</span>
<span class="gi">+                subgraph.add_edge(u, v)</span>
<span class="gi">+</span>
<span class="gi">+    return subgraph</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def get_counterexample_recursive(G):
<span class="w"> </span>    &quot;&quot;&quot;Recursive version of :meth:`get_counterexample`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # copy graph</span>
<span class="gi">+    G = nx.Graph(G)</span>
<span class="gi">+</span>
<span class="gi">+    if check_planarity_recursive(G)[0]:</span>
<span class="gi">+        raise nx.NetworkXException(&quot;G is planar - no counter example.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # find Kuratowski subgraph</span>
<span class="gi">+    subgraph = nx.Graph()</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        nbrs = list(G[u])</span>
<span class="gi">+        for v in nbrs:</span>
<span class="gi">+            G.remove_edge(u, v)</span>
<span class="gi">+            if check_planarity_recursive(G)[0]:</span>
<span class="gi">+                G.add_edge(u, v)</span>
<span class="gi">+                subgraph.add_edge(u, v)</span>
<span class="gi">+</span>
<span class="gi">+    return subgraph</span>


<span class="w"> </span>class Interval:
<span class="gu">@@ -149,15 +206,18 @@ class Interval:</span>

<span class="w"> </span>    def empty(self):
<span class="w"> </span>        &quot;&quot;&quot;Check if the interval is empty&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.low is None and self.high is None</span>

<span class="w"> </span>    def copy(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns a copy of this interval&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Interval(self.low, self.high)</span>

<span class="w"> </span>    def conflicting(self, b, planarity_state):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if interval I conflicts with edge b&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            not self.empty()</span>
<span class="gi">+            and planarity_state.lowpt[self.high] &gt; planarity_state.lowpt[b]</span>
<span class="gi">+        )</span>


<span class="w"> </span>class ConflictPair:
<span class="gu">@@ -173,47 +233,90 @@ class ConflictPair:</span>

<span class="w"> </span>    def swap(self):
<span class="w"> </span>        &quot;&quot;&quot;Swap left and right intervals&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        temp = self.left</span>
<span class="gi">+        self.left = self.right</span>
<span class="gi">+        self.right = temp</span>

<span class="w"> </span>    def lowest(self, planarity_state):
<span class="w"> </span>        &quot;&quot;&quot;Returns the lowest lowpoint of a conflict pair&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.left.empty():</span>
<span class="gi">+            return planarity_state.lowpt[self.right.low]</span>
<span class="gi">+        if self.right.empty():</span>
<span class="gi">+            return planarity_state.lowpt[self.left.low]</span>
<span class="gi">+        return min(</span>
<span class="gi">+            planarity_state.lowpt[self.left.low], planarity_state.lowpt[self.right.low]</span>
<span class="gi">+        )</span>


<span class="w"> </span>def top_of_stack(l):
<span class="w"> </span>    &quot;&quot;&quot;Returns the element on top of the stack.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not l:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return l[-1]</span>


<span class="w"> </span>class LRPlanarity:
<span class="w"> </span>    &quot;&quot;&quot;A class to maintain the state during planarity check.&quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;G&#39;, &#39;roots&#39;, &#39;height&#39;, &#39;lowpt&#39;, &#39;lowpt2&#39;, &#39;nesting_depth&#39;,</span>
<span class="gd">-        &#39;parent_edge&#39;, &#39;DG&#39;, &#39;adjs&#39;, &#39;ordered_adjs&#39;, &#39;ref&#39;, &#39;side&#39;, &#39;S&#39;,</span>
<span class="gd">-        &#39;stack_bottom&#39;, &#39;lowpt_edge&#39;, &#39;left_ref&#39;, &#39;right_ref&#39;, &#39;embedding&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [</span>
<span class="gi">+        &quot;G&quot;,</span>
<span class="gi">+        &quot;roots&quot;,</span>
<span class="gi">+        &quot;height&quot;,</span>
<span class="gi">+        &quot;lowpt&quot;,</span>
<span class="gi">+        &quot;lowpt2&quot;,</span>
<span class="gi">+        &quot;nesting_depth&quot;,</span>
<span class="gi">+        &quot;parent_edge&quot;,</span>
<span class="gi">+        &quot;DG&quot;,</span>
<span class="gi">+        &quot;adjs&quot;,</span>
<span class="gi">+        &quot;ordered_adjs&quot;,</span>
<span class="gi">+        &quot;ref&quot;,</span>
<span class="gi">+        &quot;side&quot;,</span>
<span class="gi">+        &quot;S&quot;,</span>
<span class="gi">+        &quot;stack_bottom&quot;,</span>
<span class="gi">+        &quot;lowpt_edge&quot;,</span>
<span class="gi">+        &quot;left_ref&quot;,</span>
<span class="gi">+        &quot;right_ref&quot;,</span>
<span class="gi">+        &quot;embedding&quot;,</span>
<span class="gi">+    ]</span>

<span class="w"> </span>    def __init__(self, G):
<span class="gi">+        # copy G without adding self-loops</span>
<span class="w"> </span>        self.G = nx.Graph()
<span class="w"> </span>        self.G.add_nodes_from(G.nodes)
<span class="w"> </span>        for e in G.edges:
<span class="w"> </span>            if e[0] != e[1]:
<span class="w"> </span>                self.G.add_edge(e[0], e[1])
<span class="gi">+</span>
<span class="w"> </span>        self.roots = []
<span class="gd">-        self.height = defaultdict(lambda : None)</span>
<span class="gd">-        self.lowpt = {}</span>
<span class="gd">-        self.lowpt2 = {}</span>
<span class="gd">-        self.nesting_depth = {}</span>
<span class="gd">-        self.parent_edge = defaultdict(lambda : None)</span>
<span class="gi">+</span>
<span class="gi">+        # distance from tree root</span>
<span class="gi">+        self.height = defaultdict(lambda: None)</span>
<span class="gi">+</span>
<span class="gi">+        self.lowpt = {}  # height of lowest return point of an edge</span>
<span class="gi">+        self.lowpt2 = {}  # height of second lowest return point</span>
<span class="gi">+        self.nesting_depth = {}  # for nesting order</span>
<span class="gi">+</span>
<span class="gi">+        # None -&gt; missing edge</span>
<span class="gi">+        self.parent_edge = defaultdict(lambda: None)</span>
<span class="gi">+</span>
<span class="gi">+        # oriented DFS graph</span>
<span class="w"> </span>        self.DG = nx.DiGraph()
<span class="w"> </span>        self.DG.add_nodes_from(G.nodes)
<span class="gi">+</span>
<span class="w"> </span>        self.adjs = {}
<span class="w"> </span>        self.ordered_adjs = {}
<span class="gd">-        self.ref = defaultdict(lambda : None)</span>
<span class="gd">-        self.side = defaultdict(lambda : 1)</span>
<span class="gi">+</span>
<span class="gi">+        self.ref = defaultdict(lambda: None)</span>
<span class="gi">+        self.side = defaultdict(lambda: 1)</span>
<span class="gi">+</span>
<span class="gi">+        # stack of conflict pairs</span>
<span class="w"> </span>        self.S = []
<span class="w"> </span>        self.stack_bottom = {}
<span class="w"> </span>        self.lowpt_edge = {}
<span class="gi">+</span>
<span class="w"> </span>        self.left_ref = {}
<span class="w"> </span>        self.right_ref = {}
<span class="gi">+</span>
<span class="w"> </span>        self.embedding = PlanarEmbedding()

<span class="w"> </span>    def lr_planarity(self):
<span class="gu">@@ -224,43 +327,442 @@ class LRPlanarity:</span>
<span class="w"> </span>        embedding : dict
<span class="w"> </span>            If the graph is planar an embedding is returned. Otherwise None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.G.order() &gt; 2 and self.G.size() &gt; 3 * self.G.order() - 6:</span>
<span class="gi">+            # graph is not planar</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # make adjacency lists for dfs</span>
<span class="gi">+        for v in self.G:</span>
<span class="gi">+            self.adjs[v] = list(self.G[v])</span>
<span class="gi">+</span>
<span class="gi">+        # orientation of the graph by depth first search traversal</span>
<span class="gi">+        for v in self.G:</span>
<span class="gi">+            if self.height[v] is None:</span>
<span class="gi">+                self.height[v] = 0</span>
<span class="gi">+                self.roots.append(v)</span>
<span class="gi">+                self.dfs_orientation(v)</span>
<span class="gi">+</span>
<span class="gi">+        # Free no longer used variables</span>
<span class="gi">+        self.G = None</span>
<span class="gi">+        self.lowpt2 = None</span>
<span class="gi">+        self.adjs = None</span>
<span class="gi">+</span>
<span class="gi">+        # testing</span>
<span class="gi">+        for v in self.DG:  # sort the adjacency lists by nesting depth</span>
<span class="gi">+            # note: this sorting leads to non linear time</span>
<span class="gi">+            self.ordered_adjs[v] = sorted(</span>
<span class="gi">+                self.DG[v], key=lambda x: self.nesting_depth[(v, x)]</span>
<span class="gi">+            )</span>
<span class="gi">+        for v in self.roots:</span>
<span class="gi">+            if not self.dfs_testing(v):</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        # Free no longer used variables</span>
<span class="gi">+        self.height = None</span>
<span class="gi">+        self.lowpt = None</span>
<span class="gi">+        self.S = None</span>
<span class="gi">+        self.stack_bottom = None</span>
<span class="gi">+        self.lowpt_edge = None</span>
<span class="gi">+</span>
<span class="gi">+        for e in self.DG.edges:</span>
<span class="gi">+            self.nesting_depth[e] = self.sign(e) * self.nesting_depth[e]</span>
<span class="gi">+</span>
<span class="gi">+        self.embedding.add_nodes_from(self.DG.nodes)</span>
<span class="gi">+        for v in self.DG:</span>
<span class="gi">+            # sort the adjacency lists again</span>
<span class="gi">+            self.ordered_adjs[v] = sorted(</span>
<span class="gi">+                self.DG[v], key=lambda x: self.nesting_depth[(v, x)]</span>
<span class="gi">+            )</span>
<span class="gi">+            # initialize the embedding</span>
<span class="gi">+            previous_node = None</span>
<span class="gi">+            for w in self.ordered_adjs[v]:</span>
<span class="gi">+                self.embedding.add_half_edge(v, w, ccw=previous_node)</span>
<span class="gi">+                previous_node = w</span>
<span class="gi">+</span>
<span class="gi">+        # Free no longer used variables</span>
<span class="gi">+        self.DG = None</span>
<span class="gi">+        self.nesting_depth = None</span>
<span class="gi">+        self.ref = None</span>
<span class="gi">+</span>
<span class="gi">+        # compute the complete embedding</span>
<span class="gi">+        for v in self.roots:</span>
<span class="gi">+            self.dfs_embedding(v)</span>
<span class="gi">+</span>
<span class="gi">+        # Free no longer used variables</span>
<span class="gi">+        self.roots = None</span>
<span class="gi">+        self.parent_edge = None</span>
<span class="gi">+        self.ordered_adjs = None</span>
<span class="gi">+        self.left_ref = None</span>
<span class="gi">+        self.right_ref = None</span>
<span class="gi">+        self.side = None</span>
<span class="gi">+</span>
<span class="gi">+        return self.embedding</span>

<span class="w"> </span>    def lr_planarity_recursive(self):
<span class="w"> </span>        &quot;&quot;&quot;Recursive version of :meth:`lr_planarity`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.G.order() &gt; 2 and self.G.size() &gt; 3 * self.G.order() - 6:</span>
<span class="gi">+            # graph is not planar</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # orientation of the graph by depth first search traversal</span>
<span class="gi">+        for v in self.G:</span>
<span class="gi">+            if self.height[v] is None:</span>
<span class="gi">+                self.height[v] = 0</span>
<span class="gi">+                self.roots.append(v)</span>
<span class="gi">+                self.dfs_orientation_recursive(v)</span>
<span class="gi">+</span>
<span class="gi">+        # Free no longer used variable</span>
<span class="gi">+        self.G = None</span>
<span class="gi">+</span>
<span class="gi">+        # testing</span>
<span class="gi">+        for v in self.DG:  # sort the adjacency lists by nesting depth</span>
<span class="gi">+            # note: this sorting leads to non linear time</span>
<span class="gi">+            self.ordered_adjs[v] = sorted(</span>
<span class="gi">+                self.DG[v], key=lambda x: self.nesting_depth[(v, x)]</span>
<span class="gi">+            )</span>
<span class="gi">+        for v in self.roots:</span>
<span class="gi">+            if not self.dfs_testing_recursive(v):</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        for e in self.DG.edges:</span>
<span class="gi">+            self.nesting_depth[e] = self.sign_recursive(e) * self.nesting_depth[e]</span>
<span class="gi">+</span>
<span class="gi">+        self.embedding.add_nodes_from(self.DG.nodes)</span>
<span class="gi">+        for v in self.DG:</span>
<span class="gi">+            # sort the adjacency lists again</span>
<span class="gi">+            self.ordered_adjs[v] = sorted(</span>
<span class="gi">+                self.DG[v], key=lambda x: self.nesting_depth[(v, x)]</span>
<span class="gi">+            )</span>
<span class="gi">+            # initialize the embedding</span>
<span class="gi">+            previous_node = None</span>
<span class="gi">+            for w in self.ordered_adjs[v]:</span>
<span class="gi">+                self.embedding.add_half_edge(v, w, ccw=previous_node)</span>
<span class="gi">+                previous_node = w</span>
<span class="gi">+</span>
<span class="gi">+        # compute the complete embedding</span>
<span class="gi">+        for v in self.roots:</span>
<span class="gi">+            self.dfs_embedding_recursive(v)</span>
<span class="gi">+</span>
<span class="gi">+        return self.embedding</span>

<span class="w"> </span>    def dfs_orientation(self, v):
<span class="w"> </span>        &quot;&quot;&quot;Orient the graph by DFS, compute lowpoints and nesting order.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # the recursion stack</span>
<span class="gi">+        dfs_stack = [v]</span>
<span class="gi">+        # index of next edge to handle in adjacency list of each node</span>
<span class="gi">+        ind = defaultdict(lambda: 0)</span>
<span class="gi">+        # boolean to indicate whether to skip the initial work for an edge</span>
<span class="gi">+        skip_init = defaultdict(lambda: False)</span>
<span class="gi">+</span>
<span class="gi">+        while dfs_stack:</span>
<span class="gi">+            v = dfs_stack.pop()</span>
<span class="gi">+            e = self.parent_edge[v]</span>
<span class="gi">+</span>
<span class="gi">+            for w in self.adjs[v][ind[v] :]:</span>
<span class="gi">+                vw = (v, w)</span>
<span class="gi">+</span>
<span class="gi">+                if not skip_init[vw]:</span>
<span class="gi">+                    if (v, w) in self.DG.edges or (w, v) in self.DG.edges:</span>
<span class="gi">+                        ind[v] += 1</span>
<span class="gi">+                        continue  # the edge was already oriented</span>
<span class="gi">+</span>
<span class="gi">+                    self.DG.add_edge(v, w)  # orient the edge</span>
<span class="gi">+</span>
<span class="gi">+                    self.lowpt[vw] = self.height[v]</span>
<span class="gi">+                    self.lowpt2[vw] = self.height[v]</span>
<span class="gi">+                    if self.height[w] is None:  # (v, w) is a tree edge</span>
<span class="gi">+                        self.parent_edge[w] = vw</span>
<span class="gi">+                        self.height[w] = self.height[v] + 1</span>
<span class="gi">+</span>
<span class="gi">+                        dfs_stack.append(v)  # revisit v after finishing w</span>
<span class="gi">+                        dfs_stack.append(w)  # visit w next</span>
<span class="gi">+                        skip_init[vw] = True  # don&#39;t redo this block</span>
<span class="gi">+                        break  # handle next node in dfs_stack (i.e. w)</span>
<span class="gi">+                    else:  # (v, w) is a back edge</span>
<span class="gi">+                        self.lowpt[vw] = self.height[w]</span>
<span class="gi">+</span>
<span class="gi">+                # determine nesting graph</span>
<span class="gi">+                self.nesting_depth[vw] = 2 * self.lowpt[vw]</span>
<span class="gi">+                if self.lowpt2[vw] &lt; self.height[v]:  # chordal</span>
<span class="gi">+                    self.nesting_depth[vw] += 1</span>
<span class="gi">+</span>
<span class="gi">+                # update lowpoints of parent edge e</span>
<span class="gi">+                if e is not None:</span>
<span class="gi">+                    if self.lowpt[vw] &lt; self.lowpt[e]:</span>
<span class="gi">+                        self.lowpt2[e] = min(self.lowpt[e], self.lowpt2[vw])</span>
<span class="gi">+                        self.lowpt[e] = self.lowpt[vw]</span>
<span class="gi">+                    elif self.lowpt[vw] &gt; self.lowpt[e]:</span>
<span class="gi">+                        self.lowpt2[e] = min(self.lowpt2[e], self.lowpt[vw])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.lowpt2[e] = min(self.lowpt2[e], self.lowpt2[vw])</span>
<span class="gi">+</span>
<span class="gi">+                ind[v] += 1</span>

<span class="w"> </span>    def dfs_orientation_recursive(self, v):
<span class="w"> </span>        &quot;&quot;&quot;Recursive version of :meth:`dfs_orientation`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        e = self.parent_edge[v]</span>
<span class="gi">+        for w in self.G[v]:</span>
<span class="gi">+            if (v, w) in self.DG.edges or (w, v) in self.DG.edges:</span>
<span class="gi">+                continue  # the edge was already oriented</span>
<span class="gi">+            vw = (v, w)</span>
<span class="gi">+            self.DG.add_edge(v, w)  # orient the edge</span>
<span class="gi">+</span>
<span class="gi">+            self.lowpt[vw] = self.height[v]</span>
<span class="gi">+            self.lowpt2[vw] = self.height[v]</span>
<span class="gi">+            if self.height[w] is None:  # (v, w) is a tree edge</span>
<span class="gi">+                self.parent_edge[w] = vw</span>
<span class="gi">+                self.height[w] = self.height[v] + 1</span>
<span class="gi">+                self.dfs_orientation_recursive(w)</span>
<span class="gi">+            else:  # (v, w) is a back edge</span>
<span class="gi">+                self.lowpt[vw] = self.height[w]</span>
<span class="gi">+</span>
<span class="gi">+            # determine nesting graph</span>
<span class="gi">+            self.nesting_depth[vw] = 2 * self.lowpt[vw]</span>
<span class="gi">+            if self.lowpt2[vw] &lt; self.height[v]:  # chordal</span>
<span class="gi">+                self.nesting_depth[vw] += 1</span>
<span class="gi">+</span>
<span class="gi">+            # update lowpoints of parent edge e</span>
<span class="gi">+            if e is not None:</span>
<span class="gi">+                if self.lowpt[vw] &lt; self.lowpt[e]:</span>
<span class="gi">+                    self.lowpt2[e] = min(self.lowpt[e], self.lowpt2[vw])</span>
<span class="gi">+                    self.lowpt[e] = self.lowpt[vw]</span>
<span class="gi">+                elif self.lowpt[vw] &gt; self.lowpt[e]:</span>
<span class="gi">+                    self.lowpt2[e] = min(self.lowpt2[e], self.lowpt[vw])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.lowpt2[e] = min(self.lowpt2[e], self.lowpt2[vw])</span>

<span class="w"> </span>    def dfs_testing(self, v):
<span class="w"> </span>        &quot;&quot;&quot;Test for LR partition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # the recursion stack</span>
<span class="gi">+        dfs_stack = [v]</span>
<span class="gi">+        # index of next edge to handle in adjacency list of each node</span>
<span class="gi">+        ind = defaultdict(lambda: 0)</span>
<span class="gi">+        # boolean to indicate whether to skip the initial work for an edge</span>
<span class="gi">+        skip_init = defaultdict(lambda: False)</span>
<span class="gi">+</span>
<span class="gi">+        while dfs_stack:</span>
<span class="gi">+            v = dfs_stack.pop()</span>
<span class="gi">+            e = self.parent_edge[v]</span>
<span class="gi">+            # to indicate whether to skip the final block after the for loop</span>
<span class="gi">+            skip_final = False</span>
<span class="gi">+</span>
<span class="gi">+            for w in self.ordered_adjs[v][ind[v] :]:</span>
<span class="gi">+                ei = (v, w)</span>
<span class="gi">+</span>
<span class="gi">+                if not skip_init[ei]:</span>
<span class="gi">+                    self.stack_bottom[ei] = top_of_stack(self.S)</span>
<span class="gi">+</span>
<span class="gi">+                    if ei == self.parent_edge[w]:  # tree edge</span>
<span class="gi">+                        dfs_stack.append(v)  # revisit v after finishing w</span>
<span class="gi">+                        dfs_stack.append(w)  # visit w next</span>
<span class="gi">+                        skip_init[ei] = True  # don&#39;t redo this block</span>
<span class="gi">+                        skip_final = True  # skip final work after breaking</span>
<span class="gi">+                        break  # handle next node in dfs_stack (i.e. w)</span>
<span class="gi">+                    else:  # back edge</span>
<span class="gi">+                        self.lowpt_edge[ei] = ei</span>
<span class="gi">+                        self.S.append(ConflictPair(right=Interval(ei, ei)))</span>
<span class="gi">+</span>
<span class="gi">+                # integrate new return edges</span>
<span class="gi">+                if self.lowpt[ei] &lt; self.height[v]:</span>
<span class="gi">+                    if w == self.ordered_adjs[v][0]:  # e_i has return edge</span>
<span class="gi">+                        self.lowpt_edge[e] = self.lowpt_edge[ei]</span>
<span class="gi">+                    else:  # add constraints of e_i</span>
<span class="gi">+                        if not self.add_constraints(ei, e):</span>
<span class="gi">+                            # graph is not planar</span>
<span class="gi">+                            return False</span>
<span class="gi">+</span>
<span class="gi">+                ind[v] += 1</span>
<span class="gi">+</span>
<span class="gi">+            if not skip_final:</span>
<span class="gi">+                # remove back edges returning to parent</span>
<span class="gi">+                if e is not None:  # v isn&#39;t root</span>
<span class="gi">+                    self.remove_back_edges(e)</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def dfs_testing_recursive(self, v):
<span class="w"> </span>        &quot;&quot;&quot;Recursive version of :meth:`dfs_testing`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        e = self.parent_edge[v]</span>
<span class="gi">+        for w in self.ordered_adjs[v]:</span>
<span class="gi">+            ei = (v, w)</span>
<span class="gi">+            self.stack_bottom[ei] = top_of_stack(self.S)</span>
<span class="gi">+            if ei == self.parent_edge[w]:  # tree edge</span>
<span class="gi">+                if not self.dfs_testing_recursive(w):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            else:  # back edge</span>
<span class="gi">+                self.lowpt_edge[ei] = ei</span>
<span class="gi">+                self.S.append(ConflictPair(right=Interval(ei, ei)))</span>
<span class="gi">+</span>
<span class="gi">+            # integrate new return edges</span>
<span class="gi">+            if self.lowpt[ei] &lt; self.height[v]:</span>
<span class="gi">+                if w == self.ordered_adjs[v][0]:  # e_i has return edge</span>
<span class="gi">+                    self.lowpt_edge[e] = self.lowpt_edge[ei]</span>
<span class="gi">+                else:  # add constraints of e_i</span>
<span class="gi">+                    if not self.add_constraints(ei, e):</span>
<span class="gi">+                        # graph is not planar</span>
<span class="gi">+                        return False</span>
<span class="gi">+</span>
<span class="gi">+        # remove back edges returning to parent</span>
<span class="gi">+        if e is not None:  # v isn&#39;t root</span>
<span class="gi">+            self.remove_back_edges(e)</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def add_constraints(self, ei, e):</span>
<span class="gi">+        P = ConflictPair()</span>
<span class="gi">+        # merge return edges of e_i into P.right</span>
<span class="gi">+        while True:</span>
<span class="gi">+            Q = self.S.pop()</span>
<span class="gi">+            if not Q.left.empty():</span>
<span class="gi">+                Q.swap()</span>
<span class="gi">+            if not Q.left.empty():  # not planar</span>
<span class="gi">+                return False</span>
<span class="gi">+            if self.lowpt[Q.right.low] &gt; self.lowpt[e]:</span>
<span class="gi">+                # merge intervals</span>
<span class="gi">+                if P.right.empty():  # topmost interval</span>
<span class="gi">+                    P.right = Q.right.copy()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.ref[P.right.low] = Q.right.high</span>
<span class="gi">+                P.right.low = Q.right.low</span>
<span class="gi">+            else:  # align</span>
<span class="gi">+                self.ref[Q.right.low] = self.lowpt_edge[e]</span>
<span class="gi">+            if top_of_stack(self.S) == self.stack_bottom[ei]:</span>
<span class="gi">+                break</span>
<span class="gi">+        # merge conflicting return edges of e_1,...,e_i-1 into P.L</span>
<span class="gi">+        while top_of_stack(self.S).left.conflicting(ei, self) or top_of_stack(</span>
<span class="gi">+            self.S</span>
<span class="gi">+        ).right.conflicting(ei, self):</span>
<span class="gi">+            Q = self.S.pop()</span>
<span class="gi">+            if Q.right.conflicting(ei, self):</span>
<span class="gi">+                Q.swap()</span>
<span class="gi">+            if Q.right.conflicting(ei, self):  # not planar</span>
<span class="gi">+                return False</span>
<span class="gi">+            # merge interval below lowpt(e_i) into P.R</span>
<span class="gi">+            self.ref[P.right.low] = Q.right.high</span>
<span class="gi">+            if Q.right.low is not None:</span>
<span class="gi">+                P.right.low = Q.right.low</span>
<span class="gi">+</span>
<span class="gi">+            if P.left.empty():  # topmost interval</span>
<span class="gi">+                P.left = Q.left.copy()</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.ref[P.left.low] = Q.left.high</span>
<span class="gi">+            P.left.low = Q.left.low</span>
<span class="gi">+</span>
<span class="gi">+        if not (P.left.empty() and P.right.empty()):</span>
<span class="gi">+            self.S.append(P)</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def remove_back_edges(self, e):</span>
<span class="gi">+        u = e[0]</span>
<span class="gi">+        # trim back edges ending at parent u</span>
<span class="gi">+        # drop entire conflict pairs</span>
<span class="gi">+        while self.S and top_of_stack(self.S).lowest(self) == self.height[u]:</span>
<span class="gi">+            P = self.S.pop()</span>
<span class="gi">+            if P.left.low is not None:</span>
<span class="gi">+                self.side[P.left.low] = -1</span>
<span class="gi">+</span>
<span class="gi">+        if self.S:  # one more conflict pair to consider</span>
<span class="gi">+            P = self.S.pop()</span>
<span class="gi">+            # trim left interval</span>
<span class="gi">+            while P.left.high is not None and P.left.high[1] == u:</span>
<span class="gi">+                P.left.high = self.ref[P.left.high]</span>
<span class="gi">+            if P.left.high is None and P.left.low is not None:</span>
<span class="gi">+                # just emptied</span>
<span class="gi">+                self.ref[P.left.low] = P.right.low</span>
<span class="gi">+                self.side[P.left.low] = -1</span>
<span class="gi">+                P.left.low = None</span>
<span class="gi">+            # trim right interval</span>
<span class="gi">+            while P.right.high is not None and P.right.high[1] == u:</span>
<span class="gi">+                P.right.high = self.ref[P.right.high]</span>
<span class="gi">+            if P.right.high is None and P.right.low is not None:</span>
<span class="gi">+                # just emptied</span>
<span class="gi">+                self.ref[P.right.low] = P.left.low</span>
<span class="gi">+                self.side[P.right.low] = -1</span>
<span class="gi">+                P.right.low = None</span>
<span class="gi">+            self.S.append(P)</span>
<span class="gi">+</span>
<span class="gi">+        # side of e is side of a highest return edge</span>
<span class="gi">+        if self.lowpt[e] &lt; self.height[u]:  # e has return edge</span>
<span class="gi">+            hl = top_of_stack(self.S).left.high</span>
<span class="gi">+            hr = top_of_stack(self.S).right.high</span>
<span class="gi">+</span>
<span class="gi">+            if hl is not None and (hr is None or self.lowpt[hl] &gt; self.lowpt[hr]):</span>
<span class="gi">+                self.ref[e] = hl</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.ref[e] = hr</span>

<span class="w"> </span>    def dfs_embedding(self, v):
<span class="w"> </span>        &quot;&quot;&quot;Completes the embedding.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # the recursion stack</span>
<span class="gi">+        dfs_stack = [v]</span>
<span class="gi">+        # index of next edge to handle in adjacency list of each node</span>
<span class="gi">+        ind = defaultdict(lambda: 0)</span>
<span class="gi">+</span>
<span class="gi">+        while dfs_stack:</span>
<span class="gi">+            v = dfs_stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+            for w in self.ordered_adjs[v][ind[v] :]:</span>
<span class="gi">+                ind[v] += 1</span>
<span class="gi">+                ei = (v, w)</span>
<span class="gi">+</span>
<span class="gi">+                if ei == self.parent_edge[w]:  # tree edge</span>
<span class="gi">+                    self.embedding.add_half_edge_first(w, v)</span>
<span class="gi">+                    self.left_ref[v] = w</span>
<span class="gi">+                    self.right_ref[v] = w</span>
<span class="gi">+</span>
<span class="gi">+                    dfs_stack.append(v)  # revisit v after finishing w</span>
<span class="gi">+                    dfs_stack.append(w)  # visit w next</span>
<span class="gi">+                    break  # handle next node in dfs_stack (i.e. w)</span>
<span class="gi">+                else:  # back edge</span>
<span class="gi">+                    if self.side[ei] == 1:</span>
<span class="gi">+                        self.embedding.add_half_edge(w, v, ccw=self.right_ref[w])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.embedding.add_half_edge(w, v, cw=self.left_ref[w])</span>
<span class="gi">+                        self.left_ref[w] = v</span>

<span class="w"> </span>    def dfs_embedding_recursive(self, v):
<span class="w"> </span>        &quot;&quot;&quot;Recursive version of :meth:`dfs_embedding`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for w in self.ordered_adjs[v]:</span>
<span class="gi">+            ei = (v, w)</span>
<span class="gi">+            if ei == self.parent_edge[w]:  # tree edge</span>
<span class="gi">+                self.embedding.add_half_edge_first(w, v)</span>
<span class="gi">+                self.left_ref[v] = w</span>
<span class="gi">+                self.right_ref[v] = w</span>
<span class="gi">+                self.dfs_embedding_recursive(w)</span>
<span class="gi">+            else:  # back edge</span>
<span class="gi">+                if self.side[ei] == 1:</span>
<span class="gi">+                    # place v directly after right_ref[w] in embed. list of w</span>
<span class="gi">+                    self.embedding.add_half_edge(w, v, ccw=self.right_ref[w])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # place v directly before left_ref[w] in embed. list of w</span>
<span class="gi">+                    self.embedding.add_half_edge(w, v, cw=self.left_ref[w])</span>
<span class="gi">+                    self.left_ref[w] = v</span>

<span class="w"> </span>    def sign(self, e):
<span class="w"> </span>        &quot;&quot;&quot;Resolve the relative side of an edge to the absolute side.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # the recursion stack</span>
<span class="gi">+        dfs_stack = [e]</span>
<span class="gi">+        # dict to remember reference edges</span>
<span class="gi">+        old_ref = defaultdict(lambda: None)</span>
<span class="gi">+</span>
<span class="gi">+        while dfs_stack:</span>
<span class="gi">+            e = dfs_stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+            if self.ref[e] is not None:</span>
<span class="gi">+                dfs_stack.append(e)  # revisit e after finishing self.ref[e]</span>
<span class="gi">+                dfs_stack.append(self.ref[e])  # visit self.ref[e] next</span>
<span class="gi">+                old_ref[e] = self.ref[e]  # remember value of self.ref[e]</span>
<span class="gi">+                self.ref[e] = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.side[e] *= self.side[old_ref[e]]</span>
<span class="gi">+</span>
<span class="gi">+        return self.side[e]</span>

<span class="w"> </span>    def sign_recursive(self, e):
<span class="w"> </span>        &quot;&quot;&quot;Recursive version of :meth:`sign`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.ref[e] is not None:</span>
<span class="gi">+            self.side[e] = self.side[e] * self.sign_recursive(self.ref[e])</span>
<span class="gi">+            self.ref[e] = None</span>
<span class="gi">+        return self.side[e]</span>


<span class="w"> </span>class PlanarEmbedding(nx.DiGraph):
<span class="gu">@@ -365,7 +867,9 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        Any edge additions to a PlanarEmbedding should be done using
<span class="w"> </span>        method `add_half_edge`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(</span>
<span class="gi">+            &quot;Use `add_half_edge` method to add edges to a PlanarEmbedding.&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def get_data(self):
<span class="w"> </span>        &quot;&quot;&quot;Converts the adjacency structure into a better readable structure.
<span class="gu">@@ -381,7 +885,10 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        set_data

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        embedding = {}</span>
<span class="gi">+        for v in self:</span>
<span class="gi">+            embedding[v] = list(self.neighbors_cw_order(v))</span>
<span class="gi">+        return embedding</span>

<span class="w"> </span>    def set_data(self, data):
<span class="w"> </span>        &quot;&quot;&quot;Inserts edges according to given sorted neighbor list.
<span class="gu">@@ -399,7 +906,11 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        get_data

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for v in data:</span>
<span class="gi">+            ref = None</span>
<span class="gi">+            for w in reversed(data[v]):</span>
<span class="gi">+                self.add_half_edge(v, w, cw=ref)</span>
<span class="gi">+                ref = w</span>

<span class="w"> </span>    def remove_node(self, n):
<span class="w"> </span>        &quot;&quot;&quot;Remove node n.
<span class="gu">@@ -423,7 +934,24 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        remove_nodes_from

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            for u in self._pred[n]:</span>
<span class="gi">+                succs_u = self._succ[u]</span>
<span class="gi">+                un_cw = succs_u[n][&quot;cw&quot;]</span>
<span class="gi">+                un_ccw = succs_u[n][&quot;ccw&quot;]</span>
<span class="gi">+                del succs_u[n]</span>
<span class="gi">+                del self._pred[u][n]</span>
<span class="gi">+                if n != un_cw:</span>
<span class="gi">+                    succs_u[un_cw][&quot;ccw&quot;] = un_ccw</span>
<span class="gi">+                    succs_u[un_ccw][&quot;cw&quot;] = un_cw</span>
<span class="gi">+            del self._node[n]</span>
<span class="gi">+            del self._succ[n]</span>
<span class="gi">+            del self._pred[n]</span>
<span class="gi">+        except KeyError as err:  # NetworkXError if n not in self</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;The node {n} is not in the planar embedding.&quot;</span>
<span class="gi">+            ) from err</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_nodes_from(self, nodes):
<span class="w"> </span>        &quot;&quot;&quot;Remove multiple nodes.
<span class="gu">@@ -449,7 +977,10 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        object to `G.remove_nodes_from`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for n in nodes:</span>
<span class="gi">+            if n in self._node:</span>
<span class="gi">+                self.remove_node(n)</span>
<span class="gi">+            # silently skip non-existing nodes</span>

<span class="w"> </span>    def neighbors_cw_order(self, v):
<span class="w"> </span>        &quot;&quot;&quot;Generator for the neighbors of v in clockwise order.
<span class="gu">@@ -463,7 +994,16 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        node

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        succs = self._succ[v]</span>
<span class="gi">+        if not succs:</span>
<span class="gi">+            # v has no neighbors</span>
<span class="gi">+            return</span>
<span class="gi">+        start_node = next(reversed(succs))</span>
<span class="gi">+        yield start_node</span>
<span class="gi">+        current_node = succs[start_node][&quot;cw&quot;]</span>
<span class="gi">+        while start_node != current_node:</span>
<span class="gi">+            yield current_node</span>
<span class="gi">+            current_node = succs[current_node][&quot;cw&quot;]</span>

<span class="w"> </span>    def add_half_edge(self, start_node, end_node, *, cw=None, ccw=None):
<span class="w"> </span>        &quot;&quot;&quot;Adds a half-edge from `start_node` to `end_node`.
<span class="gu">@@ -498,7 +1038,47 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        --------
<span class="w"> </span>        connect_components
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        succs = self._succ.get(start_node)</span>
<span class="gi">+        if succs:</span>
<span class="gi">+            # there is already some edge out of start_node</span>
<span class="gi">+            leftmost_nbr = next(reversed(self._succ[start_node]))</span>
<span class="gi">+            if cw is not None:</span>
<span class="gi">+                if cw not in succs:</span>
<span class="gi">+                    raise nx.NetworkXError(&quot;Invalid clockwise reference node.&quot;)</span>
<span class="gi">+                if ccw is not None:</span>
<span class="gi">+                    raise nx.NetworkXError(&quot;Only one of cw/ccw can be specified.&quot;)</span>
<span class="gi">+                ref_ccw = succs[cw][&quot;ccw&quot;]</span>
<span class="gi">+                super().add_edge(start_node, end_node, cw=cw, ccw=ref_ccw)</span>
<span class="gi">+                succs[ref_ccw][&quot;cw&quot;] = end_node</span>
<span class="gi">+                succs[cw][&quot;ccw&quot;] = end_node</span>
<span class="gi">+                # when (cw == leftmost_nbr), the newly added neighbor is</span>
<span class="gi">+                # already at the end of dict self._succ[start_node] and</span>
<span class="gi">+                # takes the place of the former leftmost_nbr</span>
<span class="gi">+                move_leftmost_nbr_to_end = cw != leftmost_nbr</span>
<span class="gi">+            elif ccw is not None:</span>
<span class="gi">+                if ccw not in succs:</span>
<span class="gi">+                    raise nx.NetworkXError(&quot;Invalid counterclockwise reference node.&quot;)</span>
<span class="gi">+                ref_cw = succs[ccw][&quot;cw&quot;]</span>
<span class="gi">+                super().add_edge(start_node, end_node, cw=ref_cw, ccw=ccw)</span>
<span class="gi">+                succs[ref_cw][&quot;ccw&quot;] = end_node</span>
<span class="gi">+                succs[ccw][&quot;cw&quot;] = end_node</span>
<span class="gi">+                move_leftmost_nbr_to_end = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise nx.NetworkXError(</span>
<span class="gi">+                    &quot;Node already has out-half-edge(s), either cw or ccw reference node required.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if move_leftmost_nbr_to_end:</span>
<span class="gi">+                # LRPlanarity (via self.add_half_edge_first()) requires that</span>
<span class="gi">+                # we keep track of the leftmost neighbor, which we accomplish</span>
<span class="gi">+                # by keeping it as the last key in dict self._succ[start_node]</span>
<span class="gi">+                succs[leftmost_nbr] = succs.pop(leftmost_nbr)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            if cw is not None or ccw is not None:</span>
<span class="gi">+                raise nx.NetworkXError(&quot;Invalid reference node.&quot;)</span>
<span class="gi">+            # adding the first edge out of start_node</span>
<span class="gi">+            super().add_edge(start_node, end_node, ccw=end_node, cw=end_node)</span>

<span class="w"> </span>    def check_structure(self):
<span class="w"> </span>        &quot;&quot;&quot;Runs without exceptions if this object is valid.
<span class="gu">@@ -517,7 +1097,46 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>            This exception is raised with a short explanation if the
<span class="w"> </span>            PlanarEmbedding is invalid.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check fundamental structure</span>
<span class="gi">+        for v in self:</span>
<span class="gi">+            try:</span>
<span class="gi">+                sorted_nbrs = set(self.neighbors_cw_order(v))</span>
<span class="gi">+            except KeyError as err:</span>
<span class="gi">+                msg = f&quot;Bad embedding. Missing orientation for a neighbor of {v}&quot;</span>
<span class="gi">+                raise nx.NetworkXException(msg) from err</span>
<span class="gi">+</span>
<span class="gi">+            unsorted_nbrs = set(self[v])</span>
<span class="gi">+            if sorted_nbrs != unsorted_nbrs:</span>
<span class="gi">+                msg = &quot;Bad embedding. Edge orientations not set correctly.&quot;</span>
<span class="gi">+                raise nx.NetworkXException(msg)</span>
<span class="gi">+            for w in self[v]:</span>
<span class="gi">+                # Check if opposite half-edge exists</span>
<span class="gi">+                if not self.has_edge(w, v):</span>
<span class="gi">+                    msg = &quot;Bad embedding. Opposite half-edge is missing.&quot;</span>
<span class="gi">+                    raise nx.NetworkXException(msg)</span>
<span class="gi">+</span>
<span class="gi">+        # Check planarity</span>
<span class="gi">+        counted_half_edges = set()</span>
<span class="gi">+        for component in nx.connected_components(self):</span>
<span class="gi">+            if len(component) == 1:</span>
<span class="gi">+                # Don&#39;t need to check single node component</span>
<span class="gi">+                continue</span>
<span class="gi">+            num_nodes = len(component)</span>
<span class="gi">+            num_half_edges = 0</span>
<span class="gi">+            num_faces = 0</span>
<span class="gi">+            for v in component:</span>
<span class="gi">+                for w in self.neighbors_cw_order(v):</span>
<span class="gi">+                    num_half_edges += 1</span>
<span class="gi">+                    if (v, w) not in counted_half_edges:</span>
<span class="gi">+                        # We encountered a new face</span>
<span class="gi">+                        num_faces += 1</span>
<span class="gi">+                        # Mark all half-edges belonging to this face</span>
<span class="gi">+                        self.traverse_face(v, w, counted_half_edges)</span>
<span class="gi">+            num_edges = num_half_edges // 2  # num_half_edges is even</span>
<span class="gi">+            if num_nodes - num_edges + num_faces != 2:</span>
<span class="gi">+                # The result does not match Euler&#39;s formula</span>
<span class="gi">+                msg = &quot;Bad embedding. The graph does not match Euler&#39;s formula&quot;</span>
<span class="gi">+                raise nx.NetworkXException(msg)</span>

<span class="w"> </span>    def add_half_edge_ccw(self, start_node, end_node, reference_neighbor):
<span class="w"> </span>        &quot;&quot;&quot;Adds a half-edge from start_node to end_node.
<span class="gu">@@ -546,7 +1165,7 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        connect_components

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_half_edge(start_node, end_node, cw=reference_neighbor)</span>

<span class="w"> </span>    def add_half_edge_cw(self, start_node, end_node, reference_neighbor):
<span class="w"> </span>        &quot;&quot;&quot;Adds a half-edge from start_node to end_node.
<span class="gu">@@ -574,7 +1193,7 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        add_half_edge_ccw
<span class="w"> </span>        connect_components
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_half_edge(start_node, end_node, ccw=reference_neighbor)</span>

<span class="w"> </span>    def remove_edge(self, u, v):
<span class="w"> </span>        &quot;&quot;&quot;Remove the edge between u and v.
<span class="gu">@@ -594,7 +1213,28 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        --------
<span class="w"> </span>        remove_edges_from : remove a collection of edges
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            succs_u = self._succ[u]</span>
<span class="gi">+            succs_v = self._succ[v]</span>
<span class="gi">+            uv_cw = succs_u[v][&quot;cw&quot;]</span>
<span class="gi">+            uv_ccw = succs_u[v][&quot;ccw&quot;]</span>
<span class="gi">+            vu_cw = succs_v[u][&quot;cw&quot;]</span>
<span class="gi">+            vu_ccw = succs_v[u][&quot;ccw&quot;]</span>
<span class="gi">+            del succs_u[v]</span>
<span class="gi">+            del self._pred[v][u]</span>
<span class="gi">+            del succs_v[u]</span>
<span class="gi">+            del self._pred[u][v]</span>
<span class="gi">+            if v != uv_cw:</span>
<span class="gi">+                succs_u[uv_cw][&quot;ccw&quot;] = uv_ccw</span>
<span class="gi">+                succs_u[uv_ccw][&quot;cw&quot;] = uv_cw</span>
<span class="gi">+            if u != vu_cw:</span>
<span class="gi">+                succs_v[vu_cw][&quot;ccw&quot;] = vu_ccw</span>
<span class="gi">+                succs_v[vu_ccw][&quot;cw&quot;] = vu_cw</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;The edge {u}-{v} is not in the planar embedding.&quot;</span>
<span class="gi">+            ) from err</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_edges_from(self, ebunch):
<span class="w"> </span>        &quot;&quot;&quot;Remove all edges specified in ebunch.
<span class="gu">@@ -622,7 +1262,12 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        &gt;&gt;&gt; ebunch = [(1, 2), (2, 3)]
<span class="w"> </span>        &gt;&gt;&gt; G.remove_edges_from(ebunch)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for e in ebunch:</span>
<span class="gi">+            u, v = e[:2]  # ignore edge data</span>
<span class="gi">+            # assuming that the PlanarEmbedding is valid, if the half_edge</span>
<span class="gi">+            # (u, v) is in the graph, then so is half_edge (v, u)</span>
<span class="gi">+            if u in self._succ and v in self._succ[u]:</span>
<span class="gi">+                self.remove_edge(u, v)</span>

<span class="w"> </span>    def connect_components(self, v, w):
<span class="w"> </span>        &quot;&quot;&quot;Adds half-edges for (v, w) and (w, v) at some position.
<span class="gu">@@ -643,7 +1288,16 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        --------
<span class="w"> </span>        add_half_edge
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if v in self._succ and self._succ[v]:</span>
<span class="gi">+            ref = next(reversed(self._succ[v]))</span>
<span class="gi">+        else:</span>
<span class="gi">+            ref = None</span>
<span class="gi">+        self.add_half_edge(v, w, cw=ref)</span>
<span class="gi">+        if w in self._succ and self._succ[w]:</span>
<span class="gi">+            ref = next(reversed(self._succ[w]))</span>
<span class="gi">+        else:</span>
<span class="gi">+            ref = None</span>
<span class="gi">+        self.add_half_edge(w, v, cw=ref)</span>

<span class="w"> </span>    def add_half_edge_first(self, start_node, end_node):
<span class="w"> </span>        &quot;&quot;&quot;Add a half-edge and set end_node as start_node&#39;s leftmost neighbor.
<span class="gu">@@ -661,7 +1315,11 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        add_half_edge
<span class="w"> </span>        connect_components
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        succs = self._succ.get(start_node)</span>
<span class="gi">+        # the leftmost neighbor is the last entry in the</span>
<span class="gi">+        # self._succ[start_node] dict</span>
<span class="gi">+        leftmost_nbr = next(reversed(succs)) if succs else None</span>
<span class="gi">+        self.add_half_edge(start_node, end_node, cw=leftmost_nbr)</span>

<span class="w"> </span>    def next_face_half_edge(self, v, w):
<span class="w"> </span>        &quot;&quot;&quot;Returns the following half-edge left of a face.
<span class="gu">@@ -675,7 +1333,8 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        -------
<span class="w"> </span>        half-edge : tuple
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_node = self[w][v][&quot;ccw&quot;]</span>
<span class="gi">+        return w, new_node</span>

<span class="w"> </span>    def traverse_face(self, v, w, mark_half_edges=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns nodes on the face that belong to the half-edge (v, w).
<span class="gu">@@ -701,7 +1360,24 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        face : list
<span class="w"> </span>            A list of nodes that lie on this face.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if mark_half_edges is None:</span>
<span class="gi">+            mark_half_edges = set()</span>
<span class="gi">+</span>
<span class="gi">+        face_nodes = [v]</span>
<span class="gi">+        mark_half_edges.add((v, w))</span>
<span class="gi">+        prev_node = v</span>
<span class="gi">+        cur_node = w</span>
<span class="gi">+        # Last half-edge is (incoming_node, v)</span>
<span class="gi">+        incoming_node = self[v][w][&quot;cw&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        while cur_node != v or prev_node != incoming_node:</span>
<span class="gi">+            face_nodes.append(cur_node)</span>
<span class="gi">+            prev_node, cur_node = self.next_face_half_edge(prev_node, cur_node)</span>
<span class="gi">+            if (prev_node, cur_node) in mark_half_edges:</span>
<span class="gi">+                raise nx.NetworkXException(&quot;Bad planar embedding. Impossible face.&quot;)</span>
<span class="gi">+            mark_half_edges.add((prev_node, cur_node))</span>
<span class="gi">+</span>
<span class="gi">+        return face_nodes</span>

<span class="w"> </span>    def is_directed(self):
<span class="w"> </span>        &quot;&quot;&quot;A valid PlanarEmbedding is undirected.
<span class="gu">@@ -710,4 +1386,17 @@ class PlanarEmbedding(nx.DiGraph):</span>
<span class="w"> </span>        half-edge (v, w) the half-edge in the opposite direction (w, v) is also
<span class="w"> </span>        contained.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def copy(self, as_view=False):</span>
<span class="gi">+        if as_view is True:</span>
<span class="gi">+            return nx.graphviews.generic_graph_view(self)</span>
<span class="gi">+        G = self.__class__()</span>
<span class="gi">+        G.graph.update(self.graph)</span>
<span class="gi">+        G.add_nodes_from((n, d.copy()) for n, d in self._node.items())</span>
<span class="gi">+        super(self.__class__, G).add_edges_from(</span>
<span class="gi">+            (u, v, datadict.copy())</span>
<span class="gi">+            for u, nbrs in self._adj.items()</span>
<span class="gi">+            for v, datadict in nbrs.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        return G</span>
<span class="gh">diff --git a/networkx/algorithms/polynomials.py b/networkx/algorithms/polynomials.py</span>
<span class="gh">index 29cd24353..217c7dbe3 100644</span>
<span class="gd">--- a/networkx/algorithms/polynomials.py</span>
<span class="gi">+++ b/networkx/algorithms/polynomials.py</span>
<span class="gu">@@ -19,18 +19,20 @@ x**4 - 6*x**2 - 8*x - 3</span>


<span class="w"> </span>.. [1] Y. Shi, M. Dehmer, X. Li, I. Gutman,
<span class="gd">-   &quot;Graph Polynomials\&quot;</span>
<span class="gi">+   &quot;Graph Polynomials&quot;</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections import deque
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;tutte_polynomial&#39;, &#39;chromatic_polynomial&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;tutte_polynomial&quot;, &quot;chromatic_polynomial&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def tutte_polynomial(G):
<span class="gd">-    &quot;&quot;&quot;Returns the Tutte polynomial of `G`</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Tutte polynomial of `G`</span>

<span class="w"> </span>    This function computes the Tutte polynomial via an iterative version of
<span class="w"> </span>    the deletion-contraction algorithm.
<span class="gu">@@ -51,25 +53,25 @@ def tutte_polynomial(G):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        T_G(x, y) = \\sum_{A \\in E} (x-1)^{c(A) - c(E)} (y-1)^{c(A) + |A| - n(G)}</span>
<span class="gi">+        T_G(x, y) = \sum_{A \in E} (x-1)^{c(A) - c(E)} (y-1)^{c(A) + |A| - n(G)}</span>

<span class="w"> </span>    Def 2 (spanning tree expansion): Let `G` be an undirected graph, `T` a spanning
<span class="w"> </span>    tree of `G`, and `E` the edge set of `G`. Let `E` have an arbitrary strict
<span class="w"> </span>    linear order `L`. Let `B_e` be the unique minimal nonempty edge cut of
<span class="gd">-    $E \\setminus T \\cup {e}$. An edge `e` is internally active with respect to</span>
<span class="gi">+    $E \setminus T \cup {e}$. An edge `e` is internally active with respect to</span>
<span class="w"> </span>    `T` and `L` if `e` is the least edge in `B_e` according to the linear order
<span class="w"> </span>    `L`. The internal activity of `T` (denoted `i(T)`) is the number of edges
<span class="gd">-    in $E \\setminus T$ that are internally active with respect to `T` and `L`.</span>
<span class="gd">-    Let `P_e` be the unique path in $T \\cup {e}$ whose source and target vertex</span>
<span class="gi">+    in $E \setminus T$ that are internally active with respect to `T` and `L`.</span>
<span class="gi">+    Let `P_e` be the unique path in $T \cup {e}$ whose source and target vertex</span>
<span class="w"> </span>    are the same. An edge `e` is externally active with respect to `T` and `L`
<span class="w"> </span>    if `e` is the least edge in `P_e` according to the linear order `L`. The
<span class="w"> </span>    external activity of `T` (denoted `e(T)`) is the number of edges in
<span class="gd">-    $E \\setminus T$ that are externally active with respect to `T` and `L`.</span>
<span class="gi">+    $E \setminus T$ that are externally active with respect to `T` and `L`.</span>
<span class="w"> </span>    Then [4]_ [5]_:

<span class="w"> </span>    .. math::

<span class="gd">-        T_G(x, y) = \\sum_{T \\text{ a spanning tree of } G} x^{i(T)} y^{e(T)}</span>
<span class="gi">+        T_G(x, y) = \sum_{T \text{ a spanning tree of } G} x^{i(T)} y^{e(T)}</span>

<span class="w"> </span>    Def 3 (deletion-contraction recurrence): For `G` an undirected graph, `G-e`
<span class="w"> </span>    the graph obtained from `G` by deleting edge `e`, `G/e` the graph obtained
<span class="gu">@@ -77,10 +79,10 @@ def tutte_polynomial(G):</span>
<span class="w"> </span>    and `l(G)` the number of self-loops of `G`:

<span class="w"> </span>    .. math::
<span class="gd">-        T_G(x, y) = \\begin{cases}</span>
<span class="gd">-          x^{k(G)} y^{l(G)}, &amp; \\text{if all edges are cut-edges or self-loops} \\\\</span>
<span class="gd">-           T_{G-e}(x, y) + T_{G/e}(x, y), &amp; \\text{otherwise, for an arbitrary edge $e$ not a cut-edge or loop}</span>
<span class="gd">-        \\end{cases}</span>
<span class="gi">+        T_G(x, y) = \begin{cases}</span>
<span class="gi">+          x^{k(G)} y^{l(G)}, &amp; \text{if all edges are cut-edges or self-loops} \\</span>
<span class="gi">+           T_{G-e}(x, y) + T_{G/e}(x, y), &amp; \text{otherwise, for an arbitrary edge $e$ not a cut-edge or loop}</span>
<span class="gi">+        \end{cases}</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -147,13 +149,40 @@ def tutte_polynomial(G):</span>
<span class="w"> </span>       Structural Analysis of Complex Networks, 2011
<span class="w"> </span>       https://arxiv.org/pdf/0803.3079.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    import sympy</span>
<span class="gi">+</span>
<span class="gi">+    x = sympy.Symbol(&quot;x&quot;)</span>
<span class="gi">+    y = sympy.Symbol(&quot;y&quot;)</span>
<span class="gi">+    stack = deque()</span>
<span class="gi">+    stack.append(nx.MultiGraph(G))</span>
<span class="gi">+</span>
<span class="gi">+    polynomial = 0</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        G = stack.pop()</span>
<span class="gi">+        bridges = set(nx.bridges(G))</span>
<span class="gi">+</span>
<span class="gi">+        e = None</span>
<span class="gi">+        for i in G.edges:</span>
<span class="gi">+            if (i[0], i[1]) not in bridges and i[0] != i[1]:</span>
<span class="gi">+                e = i</span>
<span class="gi">+                break</span>
<span class="gi">+        if not e:</span>
<span class="gi">+            loops = list(nx.selfloop_edges(G, keys=True))</span>
<span class="gi">+            polynomial += x ** len(bridges) * y ** len(loops)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # deletion-contraction</span>
<span class="gi">+            C = nx.contracted_edge(G, e, self_loops=True)</span>
<span class="gi">+            C.remove_edge(e[0], e[0])</span>
<span class="gi">+            G.remove_edge(*e)</span>
<span class="gi">+            stack.append(G)</span>
<span class="gi">+            stack.append(C)</span>
<span class="gi">+    return sympy.simplify(polynomial)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def chromatic_polynomial(G):
<span class="gd">-    &quot;&quot;&quot;Returns the chromatic polynomial of `G`</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the chromatic polynomial of `G`</span>

<span class="w"> </span>    This function computes the chromatic polynomial via an iterative version of
<span class="w"> </span>    the deletion-contraction algorithm.
<span class="gu">@@ -171,7 +200,7 @@ def chromatic_polynomial(G):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        X_G(x) = \\sum_{S \\subseteq E} (-1)^{|S|} x^{c(G(S))}</span>
<span class="gi">+        X_G(x) = \sum_{S \subseteq E} (-1)^{|S|} x^{c(G(S))}</span>


<span class="w"> </span>    Def 2 (interpolating polynomial):
<span class="gu">@@ -179,7 +208,7 @@ def chromatic_polynomial(G):</span>
<span class="w"> </span>    and `k_i` the number of distinct ways to color the vertices of `G` with `i`
<span class="w"> </span>    unique colors (for `i` a natural number at most `n(G)`), `X_G(x)` is the
<span class="w"> </span>    unique Lagrange interpolating polynomial of degree `n(G)` through the points
<span class="gd">-    `(0, k_0), (1, k_1), \\dots, (n(G), k_{n(G)})` [2]_.</span>
<span class="gi">+    `(0, k_0), (1, k_1), \dots, (n(G), k_{n(G)})` [2]_.</span>


<span class="w"> </span>    Def 3 (chromatic recurrence):
<span class="gu">@@ -188,10 +217,10 @@ def chromatic_polynomial(G):</span>
<span class="w"> </span>    the number of vertices of `G`, and `e(G)` the number of edges of `G` [3]_:

<span class="w"> </span>    .. math::
<span class="gd">-        X_G(x) = \\begin{cases}</span>
<span class="gd">-          x^{n(G)}, &amp; \\text{if $e(G)=0$} \\\\</span>
<span class="gd">-           X_{G-e}(x) - X_{G/e}(x), &amp; \\text{otherwise, for an arbitrary edge $e$}</span>
<span class="gd">-        \\end{cases}</span>
<span class="gi">+        X_G(x) = \begin{cases}</span>
<span class="gi">+          x^{n(G)}, &amp; \text{if $e(G)=0$} \\</span>
<span class="gi">+           X_{G-e}(x) - X_{G/e}(x), &amp; \text{otherwise, for an arbitrary edge $e$}</span>
<span class="gi">+        \end{cases}</span>

<span class="w"> </span>    This formulation is also known as the Fundamental Reduction Theorem [4]_.

<span class="gu">@@ -253,4 +282,24 @@ def chromatic_polynomial(G):</span>
<span class="w"> </span>       Discrete Mathematics, 2006
<span class="w"> </span>       https://math.mit.edu/~rstan/pubs/pubfiles/18.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import sympy</span>
<span class="gi">+</span>
<span class="gi">+    x = sympy.Symbol(&quot;x&quot;)</span>
<span class="gi">+    stack = deque()</span>
<span class="gi">+    stack.append(nx.MultiGraph(G, contraction_idx=0))</span>
<span class="gi">+</span>
<span class="gi">+    polynomial = 0</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        G = stack.pop()</span>
<span class="gi">+        edges = list(G.edges)</span>
<span class="gi">+        if not edges:</span>
<span class="gi">+            polynomial += (-1) ** G.graph[&quot;contraction_idx&quot;] * x ** len(G)</span>
<span class="gi">+        else:</span>
<span class="gi">+            e = edges[0]</span>
<span class="gi">+            C = nx.contracted_edge(G, e, self_loops=True)</span>
<span class="gi">+            C.graph[&quot;contraction_idx&quot;] = G.graph[&quot;contraction_idx&quot;] + 1</span>
<span class="gi">+            C.remove_edge(e[0], e[0])</span>
<span class="gi">+            G.remove_edge(*e)</span>
<span class="gi">+            stack.append(G)</span>
<span class="gi">+            stack.append(C)</span>
<span class="gi">+    return polynomial</span>
<span class="gh">diff --git a/networkx/algorithms/reciprocity.py b/networkx/algorithms/reciprocity.py</span>
<span class="gh">index e288fcf22..25b0fa1ba 100644</span>
<span class="gd">--- a/networkx/algorithms/reciprocity.py</span>
<span class="gi">+++ b/networkx/algorithms/reciprocity.py</span>
<span class="gu">@@ -1,19 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Algorithms to calculate reciprocity in a directed graph.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx import NetworkXError
<span class="gi">+</span>
<span class="w"> </span>from ..utils import not_implemented_for
<span class="gd">-__all__ = [&#39;reciprocity&#39;, &#39;overall_reciprocity&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;reciprocity&quot;, &quot;overall_reciprocity&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;, &#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;, &quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def reciprocity(G, nodes=None):
<span class="gd">-    &quot;&quot;&quot;Compute the reciprocity in a directed graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the reciprocity in a directed graph.</span>

<span class="w"> </span>    The reciprocity of a directed graph is defined as the ratio
<span class="w"> </span>    of the number of edges pointing in both directions to the total
<span class="w"> </span>    number of edges in the graph.
<span class="gd">-    Formally, $r = |{(u,v) \\in G|(v,u) \\in G}| / |{(u,v) \\in G}|$.</span>
<span class="gi">+    Formally, $r = |{(u,v) \in G|(v,u) \in G}| / |{(u,v) \in G}|$.</span>

<span class="w"> </span>    The reciprocity of a single node u is defined similarly,
<span class="w"> </span>    it is the ratio of the number of edges in both directions to
<span class="gu">@@ -37,15 +39,43 @@ def reciprocity(G, nodes=None):</span>
<span class="w"> </span>    In such cases this function will return None.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # If `nodes` is not specified, calculate the reciprocity of the graph.</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        return overall_reciprocity(G)</span>
<span class="gi">+</span>
<span class="gi">+    # If `nodes` represents a single node in the graph, return only its</span>
<span class="gi">+    # reciprocity.</span>
<span class="gi">+    if nodes in G:</span>
<span class="gi">+        reciprocity = next(_reciprocity_iter(G, nodes))[1]</span>
<span class="gi">+        if reciprocity is None:</span>
<span class="gi">+            raise NetworkXError(&quot;Not defined for isolated nodes.&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return reciprocity</span>
<span class="gi">+</span>
<span class="gi">+    # Otherwise, `nodes` represents an iterable of nodes, so return a</span>
<span class="gi">+    # dictionary mapping node to its reciprocity.</span>
<span class="gi">+    return dict(_reciprocity_iter(G, nodes))</span>


<span class="w"> </span>def _reciprocity_iter(G, nodes):
<span class="w"> </span>    &quot;&quot;&quot;Return an iterator of (node, reciprocity).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = G.nbunch_iter(nodes)</span>
<span class="gi">+    for node in n:</span>
<span class="gi">+        pred = set(G.predecessors(node))</span>
<span class="gi">+        succ = set(G.successors(node))</span>
<span class="gi">+        overlap = pred &amp; succ</span>
<span class="gi">+        n_total = len(pred) + len(succ)</span>

<span class="gi">+        # Reciprocity is not defined for isolated nodes.</span>
<span class="gi">+        # Return None.</span>
<span class="gi">+        if n_total == 0:</span>
<span class="gi">+            yield (node, None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            reciprocity = 2 * len(overlap) / n_total</span>
<span class="gi">+            yield (node, reciprocity)</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;, &#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;, &quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def overall_reciprocity(G):
<span class="w"> </span>    &quot;&quot;&quot;Compute the reciprocity for the whole graph.
<span class="gu">@@ -58,4 +88,10 @@ def overall_reciprocity(G):</span>
<span class="w"> </span>       A networkx graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n_all_edge = G.number_of_edges()</span>
<span class="gi">+    n_overlap_edge = (n_all_edge - G.to_undirected().number_of_edges()) * 2</span>
<span class="gi">+</span>
<span class="gi">+    if n_all_edge == 0:</span>
<span class="gi">+        raise NetworkXError(&quot;Not defined for empty graphs&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return n_overlap_edge / n_all_edge</span>
<span class="gh">diff --git a/networkx/algorithms/regular.py b/networkx/algorithms/regular.py</span>
<span class="gh">index 42826bc6a..058ad3654 100644</span>
<span class="gd">--- a/networkx/algorithms/regular.py</span>
<span class="gi">+++ b/networkx/algorithms/regular.py</span>
<span class="gu">@@ -1,7 +1,8 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing and verifying regular graphs.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;is_regular&#39;, &#39;is_k_regular&#39;, &#39;k_factor&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;is_regular&quot;, &quot;is_k_regular&quot;, &quot;k_factor&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -28,10 +29,21 @@ def is_regular(G):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;Graph has no nodes.&quot;)</span>
<span class="gi">+    n1 = nx.utils.arbitrary_element(G)</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        d1 = G.degree(n1)</span>
<span class="gi">+        return all(d1 == d for _, d in G.degree)</span>
<span class="gi">+    else:</span>
<span class="gi">+        d_in = G.in_degree(n1)</span>
<span class="gi">+        in_regular = all(d_in == d for _, d in G.in_degree)</span>
<span class="gi">+        d_out = G.out_degree(n1)</span>
<span class="gi">+        out_regular = all(d_out == d for _, d in G.out_degree)</span>
<span class="gi">+        return in_regular and out_regular</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_k_regular(G, k):
<span class="w"> </span>    &quot;&quot;&quot;Determines whether the graph ``G`` is a k-regular graph.
<span class="gu">@@ -54,13 +66,13 @@ def is_k_regular(G, k):</span>
<span class="w"> </span>    False

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return all(d == k for n, d in G.degree)</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(preserve_edge_attrs=True, returns_graph=True)
<span class="gd">-def k_factor(G, k, matching_weight=&#39;weight&#39;):</span>
<span class="gi">+def k_factor(G, k, matching_weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute a k-factor of G

<span class="w"> </span>    A k-factor of a graph is a spanning k-regular subgraph.
<span class="gu">@@ -96,4 +108,107 @@ def k_factor(G, k, matching_weight=&#39;weight&#39;):</span>
<span class="w"> </span>       Meijer, Henk, Yurai Núñez-Rodríguez, and David Rappaport,
<span class="w"> </span>       Information processing letters, 2009.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    from networkx.algorithms.matching import is_perfect_matching, max_weight_matching</span>
<span class="gi">+</span>
<span class="gi">+    class LargeKGadget:</span>
<span class="gi">+        def __init__(self, k, degree, node, g):</span>
<span class="gi">+            self.original = node</span>
<span class="gi">+            self.g = g</span>
<span class="gi">+            self.k = k</span>
<span class="gi">+            self.degree = degree</span>
<span class="gi">+</span>
<span class="gi">+            self.outer_vertices = [(node, x) for x in range(degree)]</span>
<span class="gi">+            self.core_vertices = [(node, x + degree) for x in range(degree - k)]</span>
<span class="gi">+</span>
<span class="gi">+        def replace_node(self):</span>
<span class="gi">+            adj_view = self.g[self.original]</span>
<span class="gi">+            neighbors = list(adj_view.keys())</span>
<span class="gi">+            edge_attrs = list(adj_view.values())</span>
<span class="gi">+            for outer, neighbor, edge_attrs in zip(</span>
<span class="gi">+                self.outer_vertices, neighbors, edge_attrs</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.g.add_edge(outer, neighbor, **edge_attrs)</span>
<span class="gi">+            for core in self.core_vertices:</span>
<span class="gi">+                for outer in self.outer_vertices:</span>
<span class="gi">+                    self.g.add_edge(core, outer)</span>
<span class="gi">+            self.g.remove_node(self.original)</span>
<span class="gi">+</span>
<span class="gi">+        def restore_node(self):</span>
<span class="gi">+            self.g.add_node(self.original)</span>
<span class="gi">+            for outer in self.outer_vertices:</span>
<span class="gi">+                adj_view = self.g[outer]</span>
<span class="gi">+                for neighbor, edge_attrs in list(adj_view.items()):</span>
<span class="gi">+                    if neighbor not in self.core_vertices:</span>
<span class="gi">+                        self.g.add_edge(self.original, neighbor, **edge_attrs)</span>
<span class="gi">+                        break</span>
<span class="gi">+            g.remove_nodes_from(self.outer_vertices)</span>
<span class="gi">+            g.remove_nodes_from(self.core_vertices)</span>
<span class="gi">+</span>
<span class="gi">+    class SmallKGadget:</span>
<span class="gi">+        def __init__(self, k, degree, node, g):</span>
<span class="gi">+            self.original = node</span>
<span class="gi">+            self.k = k</span>
<span class="gi">+            self.degree = degree</span>
<span class="gi">+            self.g = g</span>
<span class="gi">+</span>
<span class="gi">+            self.outer_vertices = [(node, x) for x in range(degree)]</span>
<span class="gi">+            self.inner_vertices = [(node, x + degree) for x in range(degree)]</span>
<span class="gi">+            self.core_vertices = [(node, x + 2 * degree) for x in range(k)]</span>
<span class="gi">+</span>
<span class="gi">+        def replace_node(self):</span>
<span class="gi">+            adj_view = self.g[self.original]</span>
<span class="gi">+            for outer, inner, (neighbor, edge_attrs) in zip(</span>
<span class="gi">+                self.outer_vertices, self.inner_vertices, list(adj_view.items())</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.g.add_edge(outer, inner)</span>
<span class="gi">+                self.g.add_edge(outer, neighbor, **edge_attrs)</span>
<span class="gi">+            for core in self.core_vertices:</span>
<span class="gi">+                for inner in self.inner_vertices:</span>
<span class="gi">+                    self.g.add_edge(core, inner)</span>
<span class="gi">+            self.g.remove_node(self.original)</span>
<span class="gi">+</span>
<span class="gi">+        def restore_node(self):</span>
<span class="gi">+            self.g.add_node(self.original)</span>
<span class="gi">+            for outer in self.outer_vertices:</span>
<span class="gi">+                adj_view = self.g[outer]</span>
<span class="gi">+                for neighbor, edge_attrs in adj_view.items():</span>
<span class="gi">+                    if neighbor not in self.core_vertices:</span>
<span class="gi">+                        self.g.add_edge(self.original, neighbor, **edge_attrs)</span>
<span class="gi">+                        break</span>
<span class="gi">+            self.g.remove_nodes_from(self.outer_vertices)</span>
<span class="gi">+            self.g.remove_nodes_from(self.inner_vertices)</span>
<span class="gi">+            self.g.remove_nodes_from(self.core_vertices)</span>
<span class="gi">+</span>
<span class="gi">+    # Step 1</span>
<span class="gi">+    if any(d &lt; k for _, d in G.degree):</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(&quot;Graph contains a vertex with degree less than k&quot;)</span>
<span class="gi">+    g = G.copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Step 2</span>
<span class="gi">+    gadgets = []</span>
<span class="gi">+    for node, degree in list(g.degree):</span>
<span class="gi">+        if k &lt; degree / 2.0:</span>
<span class="gi">+            gadget = SmallKGadget(k, degree, node, g)</span>
<span class="gi">+        else:</span>
<span class="gi">+            gadget = LargeKGadget(k, degree, node, g)</span>
<span class="gi">+        gadget.replace_node()</span>
<span class="gi">+        gadgets.append(gadget)</span>
<span class="gi">+</span>
<span class="gi">+    # Step 3</span>
<span class="gi">+    matching = max_weight_matching(g, maxcardinality=True, weight=matching_weight)</span>
<span class="gi">+</span>
<span class="gi">+    # Step 4</span>
<span class="gi">+    if not is_perfect_matching(g, matching):</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(</span>
<span class="gi">+            &quot;Cannot find k-factor because no perfect matching exists&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    for edge in g.edges():</span>
<span class="gi">+        if edge not in matching and (edge[1], edge[0]) not in matching:</span>
<span class="gi">+            g.remove_edge(edge[0], edge[1])</span>
<span class="gi">+</span>
<span class="gi">+    for gadget in gadgets:</span>
<span class="gi">+        gadget.restore_node()</span>
<span class="gi">+</span>
<span class="gi">+    return g</span>
<span class="gh">diff --git a/networkx/algorithms/richclub.py b/networkx/algorithms/richclub.py</span>
<span class="gh">index 5a1d6688f..445b27d14 100644</span>
<span class="gd">--- a/networkx/algorithms/richclub.py</span>
<span class="gi">+++ b/networkx/algorithms/richclub.py</span>
<span class="gu">@@ -1,15 +1,18 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing rich-club coefficients.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from itertools import accumulate
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;rich_club_coefficient&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;rich_club_coefficient&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def rich_club_coefficient(G, normalized=True, Q=100, seed=None):
<span class="gd">-    &quot;&quot;&quot;Returns the rich-club coefficient of the graph `G`.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the rich-club coefficient of the graph `G`.</span>

<span class="w"> </span>    For each degree *k*, the *rich-club coefficient* is the ratio of the
<span class="w"> </span>    number of actual to the number of potential edges for nodes with
<span class="gu">@@ -17,7 +20,7 @@ def rich_club_coefficient(G, normalized=True, Q=100, seed=None):</span>

<span class="w"> </span>    .. math::

<span class="gd">-        \\phi(k) = \\frac{2 E_k}{N_k (N_k - 1)}</span>
<span class="gi">+        \phi(k) = \frac{2 E_k}{N_k (N_k - 1)}</span>

<span class="w"> </span>    where `N_k` is the number of nodes with degree larger than *k*, and
<span class="w"> </span>    `E_k` is the number of edges among those nodes.
<span class="gu">@@ -81,7 +84,20 @@ def rich_club_coefficient(G, normalized=True, Q=100, seed=None):</span>
<span class="w"> </span>       &quot;Uniform generation of random graphs with arbitrary degree
<span class="w"> </span>       sequences&quot;, 2006. https://arxiv.org/abs/cond-mat/0312028
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nx.number_of_selfloops(G) &gt; 0:</span>
<span class="gi">+        raise Exception(</span>
<span class="gi">+            &quot;rich_club_coefficient is not implemented for graphs with self loops.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    rc = _compute_rc(G)</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        # make R a copy of G, randomize with Q*|E| double edge swaps</span>
<span class="gi">+        # and use rich_club coefficient of R to normalize</span>
<span class="gi">+        R = G.copy()</span>
<span class="gi">+        E = R.number_of_edges()</span>
<span class="gi">+        nx.double_edge_swap(R, Q * E, max_tries=Q * E * 10, seed=seed)</span>
<span class="gi">+        rcran = _compute_rc(R)</span>
<span class="gi">+        rc = {k: v / rcran[k] for k, v in rc.items()}</span>
<span class="gi">+    return rc</span>


<span class="w"> </span>def _compute_rc(G):
<span class="gu">@@ -94,4 +110,29 @@ def _compute_rc(G):</span>
<span class="w"> </span>    that degree.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    deghist = nx.degree_histogram(G)</span>
<span class="gi">+    total = sum(deghist)</span>
<span class="gi">+    # Compute the number of nodes with degree greater than `k`, for each</span>
<span class="gi">+    # degree `k` (omitting the last entry, which is zero).</span>
<span class="gi">+    nks = (total - cs for cs in accumulate(deghist) if total - cs &gt; 1)</span>
<span class="gi">+    # Create a sorted list of pairs of edge endpoint degrees.</span>
<span class="gi">+    #</span>
<span class="gi">+    # The list is sorted in reverse order so that we can pop from the</span>
<span class="gi">+    # right side of the list later, instead of popping from the left</span>
<span class="gi">+    # side of the list, which would have a linear time cost.</span>
<span class="gi">+    edge_degrees = sorted((sorted(map(G.degree, e)) for e in G.edges()), reverse=True)</span>
<span class="gi">+    ek = G.number_of_edges()</span>
<span class="gi">+    if ek == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    k1, k2 = edge_degrees.pop()</span>
<span class="gi">+    rc = {}</span>
<span class="gi">+    for d, nk in enumerate(nks):</span>
<span class="gi">+        while k1 &lt;= d:</span>
<span class="gi">+            if len(edge_degrees) == 0:</span>
<span class="gi">+                ek = 0</span>
<span class="gi">+                break</span>
<span class="gi">+            k1, k2 = edge_degrees.pop()</span>
<span class="gi">+            ek -= 1</span>
<span class="gi">+        rc[d] = 2 * ek / (nk * (nk - 1))</span>
<span class="gi">+    return rc</span>
<span class="gh">diff --git a/networkx/algorithms/similarity.py b/networkx/algorithms/similarity.py</span>
<span class="gh">index 095581ae6..7af9c8980 100644</span>
<span class="gd">--- a/networkx/algorithms/similarity.py</span>
<span class="gi">+++ b/networkx/algorithms/similarity.py</span>
<span class="gu">@@ -12,24 +12,49 @@ and/or `optimize_edit_paths`.</span>
<span class="w"> </span>At the same time, I encourage capable people to investigate
<span class="w"> </span>alternative GED algorithms, in order to improve the choices available.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="w"> </span>import time
<span class="w"> </span>import warnings
<span class="w"> </span>from dataclasses import dataclass
<span class="w"> </span>from itertools import product
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import np_random_state
<span class="gd">-__all__ = [&#39;graph_edit_distance&#39;, &#39;optimal_edit_paths&#39;,</span>
<span class="gd">-    &#39;optimize_graph_edit_distance&#39;, &#39;optimize_edit_paths&#39;,</span>
<span class="gd">-    &#39;simrank_similarity&#39;, &#39;panther_similarity&#39;, &#39;generate_random_paths&#39;]</span>

<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1}, preserve_edge_attrs=True,</span>
<span class="gd">-    preserve_node_attrs=True)</span>
<span class="gd">-def graph_edit_distance(G1, G2, node_match=None, edge_match=None,</span>
<span class="gd">-    node_subst_cost=None, node_del_cost=None, node_ins_cost=None,</span>
<span class="gd">-    edge_subst_cost=None, edge_del_cost=None, edge_ins_cost=None, roots=</span>
<span class="gd">-    None, upper_bound=None, timeout=None):</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;graph_edit_distance&quot;,</span>
<span class="gi">+    &quot;optimal_edit_paths&quot;,</span>
<span class="gi">+    &quot;optimize_graph_edit_distance&quot;,</span>
<span class="gi">+    &quot;optimize_edit_paths&quot;,</span>
<span class="gi">+    &quot;simrank_similarity&quot;,</span>
<span class="gi">+    &quot;panther_similarity&quot;,</span>
<span class="gi">+    &quot;generate_random_paths&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def debug_print(*args, **kwargs):</span>
<span class="gi">+    print(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1}, preserve_edge_attrs=True, preserve_node_attrs=True</span>
<span class="gi">+)</span>
<span class="gi">+def graph_edit_distance(</span>
<span class="gi">+    G1,</span>
<span class="gi">+    G2,</span>
<span class="gi">+    node_match=None,</span>
<span class="gi">+    edge_match=None,</span>
<span class="gi">+    node_subst_cost=None,</span>
<span class="gi">+    node_del_cost=None,</span>
<span class="gi">+    node_ins_cost=None,</span>
<span class="gi">+    edge_subst_cost=None,</span>
<span class="gi">+    edge_del_cost=None,</span>
<span class="gi">+    edge_ins_cost=None,</span>
<span class="gi">+    roots=None,</span>
<span class="gi">+    upper_bound=None,</span>
<span class="gi">+    timeout=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns GED (graph edit distance) between graphs G1 and G2.

<span class="w"> </span>    Graph edit distance is a graph similarity measure analogous to
<span class="gu">@@ -164,14 +189,42 @@ def graph_edit_distance(G1, G2, node_match=None, edge_match=None,</span>
<span class="w"> </span>       https://hal.archives-ouvertes.fr/hal-01168816

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1})</span>
<span class="gd">-def optimal_edit_paths(G1, G2, node_match=None, edge_match=None,</span>
<span class="gd">-    node_subst_cost=None, node_del_cost=None, node_ins_cost=None,</span>
<span class="gd">-    edge_subst_cost=None, edge_del_cost=None, edge_ins_cost=None,</span>
<span class="gd">-    upper_bound=None):</span>
<span class="gi">+    bestcost = None</span>
<span class="gi">+    for _, _, cost in optimize_edit_paths(</span>
<span class="gi">+        G1,</span>
<span class="gi">+        G2,</span>
<span class="gi">+        node_match,</span>
<span class="gi">+        edge_match,</span>
<span class="gi">+        node_subst_cost,</span>
<span class="gi">+        node_del_cost,</span>
<span class="gi">+        node_ins_cost,</span>
<span class="gi">+        edge_subst_cost,</span>
<span class="gi">+        edge_del_cost,</span>
<span class="gi">+        edge_ins_cost,</span>
<span class="gi">+        upper_bound,</span>
<span class="gi">+        True,</span>
<span class="gi">+        roots,</span>
<span class="gi">+        timeout,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # assert bestcost is None or cost &lt; bestcost</span>
<span class="gi">+        bestcost = cost</span>
<span class="gi">+    return bestcost</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1})</span>
<span class="gi">+def optimal_edit_paths(</span>
<span class="gi">+    G1,</span>
<span class="gi">+    G2,</span>
<span class="gi">+    node_match=None,</span>
<span class="gi">+    edge_match=None,</span>
<span class="gi">+    node_subst_cost=None,</span>
<span class="gi">+    node_del_cost=None,</span>
<span class="gi">+    node_ins_cost=None,</span>
<span class="gi">+    edge_subst_cost=None,</span>
<span class="gi">+    edge_del_cost=None,</span>
<span class="gi">+    edge_ins_cost=None,</span>
<span class="gi">+    upper_bound=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns all minimum-cost edit paths transforming G1 to G2.

<span class="w"> </span>    Graph edit path is a sequence of node and edge edit operations
<span class="gu">@@ -306,14 +359,44 @@ def optimal_edit_paths(G1, G2, node_match=None, edge_match=None,</span>
<span class="w"> </span>       https://hal.archives-ouvertes.fr/hal-01168816

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1})</span>
<span class="gd">-def optimize_graph_edit_distance(G1, G2, node_match=None, edge_match=None,</span>
<span class="gd">-    node_subst_cost=None, node_del_cost=None, node_ins_cost=None,</span>
<span class="gd">-    edge_subst_cost=None, edge_del_cost=None, edge_ins_cost=None,</span>
<span class="gd">-    upper_bound=None):</span>
<span class="gi">+    paths = []</span>
<span class="gi">+    bestcost = None</span>
<span class="gi">+    for vertex_path, edge_path, cost in optimize_edit_paths(</span>
<span class="gi">+        G1,</span>
<span class="gi">+        G2,</span>
<span class="gi">+        node_match,</span>
<span class="gi">+        edge_match,</span>
<span class="gi">+        node_subst_cost,</span>
<span class="gi">+        node_del_cost,</span>
<span class="gi">+        node_ins_cost,</span>
<span class="gi">+        edge_subst_cost,</span>
<span class="gi">+        edge_del_cost,</span>
<span class="gi">+        edge_ins_cost,</span>
<span class="gi">+        upper_bound,</span>
<span class="gi">+        False,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # assert bestcost is None or cost &lt;= bestcost</span>
<span class="gi">+        if bestcost is not None and cost &lt; bestcost:</span>
<span class="gi">+            paths = []</span>
<span class="gi">+        paths.append((vertex_path, edge_path))</span>
<span class="gi">+        bestcost = cost</span>
<span class="gi">+    return paths, bestcost</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1})</span>
<span class="gi">+def optimize_graph_edit_distance(</span>
<span class="gi">+    G1,</span>
<span class="gi">+    G2,</span>
<span class="gi">+    node_match=None,</span>
<span class="gi">+    edge_match=None,</span>
<span class="gi">+    node_subst_cost=None,</span>
<span class="gi">+    node_del_cost=None,</span>
<span class="gi">+    node_ins_cost=None,</span>
<span class="gi">+    edge_subst_cost=None,</span>
<span class="gi">+    edge_del_cost=None,</span>
<span class="gi">+    edge_ins_cost=None,</span>
<span class="gi">+    upper_bound=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns consecutive approximations of GED (graph edit distance)
<span class="w"> </span>    between graphs G1 and G2.

<span class="gu">@@ -434,15 +517,42 @@ def optimize_graph_edit_distance(G1, G2, node_match=None, edge_match=None,</span>
<span class="w"> </span>       &lt;10.5220/0005209202710278&gt;. &lt;hal-01168816&gt;
<span class="w"> </span>       https://hal.archives-ouvertes.fr/hal-01168816
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(graphs={&#39;G1&#39;: 0, &#39;G2&#39;: 1}, preserve_edge_attrs=True,</span>
<span class="gd">-    preserve_node_attrs=True)</span>
<span class="gd">-def optimize_edit_paths(G1, G2, node_match=None, edge_match=None,</span>
<span class="gd">-    node_subst_cost=None, node_del_cost=None, node_ins_cost=None,</span>
<span class="gd">-    edge_subst_cost=None, edge_del_cost=None, edge_ins_cost=None,</span>
<span class="gd">-    upper_bound=None, strictly_decreasing=True, roots=None, timeout=None):</span>
<span class="gi">+    for _, _, cost in optimize_edit_paths(</span>
<span class="gi">+        G1,</span>
<span class="gi">+        G2,</span>
<span class="gi">+        node_match,</span>
<span class="gi">+        edge_match,</span>
<span class="gi">+        node_subst_cost,</span>
<span class="gi">+        node_del_cost,</span>
<span class="gi">+        node_ins_cost,</span>
<span class="gi">+        edge_subst_cost,</span>
<span class="gi">+        edge_del_cost,</span>
<span class="gi">+        edge_ins_cost,</span>
<span class="gi">+        upper_bound,</span>
<span class="gi">+        True,</span>
<span class="gi">+    ):</span>
<span class="gi">+        yield cost</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    graphs={&quot;G1&quot;: 0, &quot;G2&quot;: 1}, preserve_edge_attrs=True, preserve_node_attrs=True</span>
<span class="gi">+)</span>
<span class="gi">+def optimize_edit_paths(</span>
<span class="gi">+    G1,</span>
<span class="gi">+    G2,</span>
<span class="gi">+    node_match=None,</span>
<span class="gi">+    edge_match=None,</span>
<span class="gi">+    node_subst_cost=None,</span>
<span class="gi">+    node_del_cost=None,</span>
<span class="gi">+    node_ins_cost=None,</span>
<span class="gi">+    edge_subst_cost=None,</span>
<span class="gi">+    edge_del_cost=None,</span>
<span class="gi">+    edge_ins_cost=None,</span>
<span class="gi">+    upper_bound=None,</span>
<span class="gi">+    strictly_decreasing=True,</span>
<span class="gi">+    roots=None,</span>
<span class="gi">+    timeout=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;GED (graph edit distance) calculation: advanced interface.

<span class="w"> </span>    Graph edit path is a sequence of node and edge edit operations
<span class="gu">@@ -573,12 +683,545 @@ def optimize_edit_paths(G1, G2, node_match=None, edge_match=None,</span>
<span class="w"> </span>       https://hal.archives-ouvertes.fr/hal-01168816

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO: support DiGraph</span>
<span class="gi">+</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    @dataclass</span>
<span class="gi">+    class CostMatrix:</span>
<span class="gi">+        C: ...</span>
<span class="gi">+        lsa_row_ind: ...</span>
<span class="gi">+        lsa_col_ind: ...</span>
<span class="gi">+        ls: ...</span>
<span class="gi">+</span>
<span class="gi">+    def make_CostMatrix(C, m, n):</span>
<span class="gi">+        # assert(C.shape == (m + n, m + n))</span>
<span class="gi">+        lsa_row_ind, lsa_col_ind = sp.optimize.linear_sum_assignment(C)</span>
<span class="gi">+</span>
<span class="gi">+        # Fixup dummy assignments:</span>
<span class="gi">+        # each substitution i&lt;-&gt;j should have dummy assignment m+j&lt;-&gt;n+i</span>
<span class="gi">+        # NOTE: fast reduce of Cv relies on it</span>
<span class="gi">+        # assert len(lsa_row_ind) == len(lsa_col_ind)</span>
<span class="gi">+        indexes = zip(range(len(lsa_row_ind)), lsa_row_ind, lsa_col_ind)</span>
<span class="gi">+        subst_ind = [k for k, i, j in indexes if i &lt; m and j &lt; n]</span>
<span class="gi">+        indexes = zip(range(len(lsa_row_ind)), lsa_row_ind, lsa_col_ind)</span>
<span class="gi">+        dummy_ind = [k for k, i, j in indexes if i &gt;= m and j &gt;= n]</span>
<span class="gi">+        # assert len(subst_ind) == len(dummy_ind)</span>
<span class="gi">+        lsa_row_ind[dummy_ind] = lsa_col_ind[subst_ind] + m</span>
<span class="gi">+        lsa_col_ind[dummy_ind] = lsa_row_ind[subst_ind] + n</span>
<span class="gi">+</span>
<span class="gi">+        return CostMatrix(</span>
<span class="gi">+            C, lsa_row_ind, lsa_col_ind, C[lsa_row_ind, lsa_col_ind].sum()</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def extract_C(C, i, j, m, n):</span>
<span class="gi">+        # assert(C.shape == (m + n, m + n))</span>
<span class="gi">+        row_ind = [k in i or k - m in j for k in range(m + n)]</span>
<span class="gi">+        col_ind = [k in j or k - n in i for k in range(m + n)]</span>
<span class="gi">+        return C[row_ind, :][:, col_ind]</span>
<span class="gi">+</span>
<span class="gi">+    def reduce_C(C, i, j, m, n):</span>
<span class="gi">+        # assert(C.shape == (m + n, m + n))</span>
<span class="gi">+        row_ind = [k not in i and k - m not in j for k in range(m + n)]</span>
<span class="gi">+        col_ind = [k not in j and k - n not in i for k in range(m + n)]</span>
<span class="gi">+        return C[row_ind, :][:, col_ind]</span>
<span class="gi">+</span>
<span class="gi">+    def reduce_ind(ind, i):</span>
<span class="gi">+        # assert set(ind) == set(range(len(ind)))</span>
<span class="gi">+        rind = ind[[k not in i for k in ind]]</span>
<span class="gi">+        for k in set(i):</span>
<span class="gi">+            rind[rind &gt;= k] -= 1</span>
<span class="gi">+        return rind</span>
<span class="gi">+</span>
<span class="gi">+    def match_edges(u, v, pending_g, pending_h, Ce, matched_uv=None):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Parameters:</span>
<span class="gi">+            u, v: matched vertices, u=None or v=None for</span>
<span class="gi">+               deletion/insertion</span>
<span class="gi">+            pending_g, pending_h: lists of edges not yet mapped</span>
<span class="gi">+            Ce: CostMatrix of pending edge mappings</span>
<span class="gi">+            matched_uv: partial vertex edit path</span>
<span class="gi">+                list of tuples (u, v) of previously matched vertex</span>
<span class="gi">+                    mappings u&lt;-&gt;v, u=None or v=None for</span>
<span class="gi">+                    deletion/insertion</span>
<span class="gi">+</span>
<span class="gi">+        Returns:</span>
<span class="gi">+            list of (i, j): indices of edge mappings g&lt;-&gt;h</span>
<span class="gi">+            localCe: local CostMatrix of edge mappings</span>
<span class="gi">+                (basically submatrix of Ce at cross of rows i, cols j)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        M = len(pending_g)</span>
<span class="gi">+        N = len(pending_h)</span>
<span class="gi">+        # assert Ce.C.shape == (M + N, M + N)</span>
<span class="gi">+</span>
<span class="gi">+        # only attempt to match edges after one node match has been made</span>
<span class="gi">+        # this will stop self-edges on the first node being automatically deleted</span>
<span class="gi">+        # even when a substitution is the better option</span>
<span class="gi">+        if matched_uv is None or len(matched_uv) == 0:</span>
<span class="gi">+            g_ind = []</span>
<span class="gi">+            h_ind = []</span>
<span class="gi">+        else:</span>
<span class="gi">+            g_ind = [</span>
<span class="gi">+                i</span>
<span class="gi">+                for i in range(M)</span>
<span class="gi">+                if pending_g[i][:2] == (u, u)</span>
<span class="gi">+                or any(</span>
<span class="gi">+                    pending_g[i][:2] in ((p, u), (u, p), (p, p)) for p, q in matched_uv</span>
<span class="gi">+                )</span>
<span class="gi">+            ]</span>
<span class="gi">+            h_ind = [</span>
<span class="gi">+                j</span>
<span class="gi">+                for j in range(N)</span>
<span class="gi">+                if pending_h[j][:2] == (v, v)</span>
<span class="gi">+                or any(</span>
<span class="gi">+                    pending_h[j][:2] in ((q, v), (v, q), (q, q)) for p, q in matched_uv</span>
<span class="gi">+                )</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+        m = len(g_ind)</span>
<span class="gi">+        n = len(h_ind)</span>
<span class="gi">+</span>
<span class="gi">+        if m or n:</span>
<span class="gi">+            C = extract_C(Ce.C, g_ind, h_ind, M, N)</span>
<span class="gi">+            # assert C.shape == (m + n, m + n)</span>
<span class="gi">+</span>
<span class="gi">+            # Forbid structurally invalid matches</span>
<span class="gi">+            # NOTE: inf remembered from Ce construction</span>
<span class="gi">+            for k, i in enumerate(g_ind):</span>
<span class="gi">+                g = pending_g[i][:2]</span>
<span class="gi">+                for l, j in enumerate(h_ind):</span>
<span class="gi">+                    h = pending_h[j][:2]</span>
<span class="gi">+                    if nx.is_directed(G1) or nx.is_directed(G2):</span>
<span class="gi">+                        if any(</span>
<span class="gi">+                            g == (p, u) and h == (q, v) or g == (u, p) and h == (v, q)</span>
<span class="gi">+                            for p, q in matched_uv</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if any(</span>
<span class="gi">+                            g in ((p, u), (u, p)) and h in ((q, v), (v, q))</span>
<span class="gi">+                            for p, q in matched_uv</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    if g == (u, u) or any(g == (p, p) for p, q in matched_uv):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if h == (v, v) or any(h == (q, q) for p, q in matched_uv):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    C[k, l] = inf</span>
<span class="gi">+</span>
<span class="gi">+            localCe = make_CostMatrix(C, m, n)</span>
<span class="gi">+            ij = [</span>
<span class="gi">+                (</span>
<span class="gi">+                    g_ind[k] if k &lt; m else M + h_ind[l],</span>
<span class="gi">+                    h_ind[l] if l &lt; n else N + g_ind[k],</span>
<span class="gi">+                )</span>
<span class="gi">+                for k, l in zip(localCe.lsa_row_ind, localCe.lsa_col_ind)</span>
<span class="gi">+                if k &lt; m or l &lt; n</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            ij = []</span>
<span class="gi">+            localCe = CostMatrix(np.empty((0, 0)), [], [], 0)</span>
<span class="gi">+</span>
<span class="gi">+        return ij, localCe</span>
<span class="gi">+</span>
<span class="gi">+    def reduce_Ce(Ce, ij, m, n):</span>
<span class="gi">+        if len(ij):</span>
<span class="gi">+            i, j = zip(*ij)</span>
<span class="gi">+            m_i = m - sum(1 for t in i if t &lt; m)</span>
<span class="gi">+            n_j = n - sum(1 for t in j if t &lt; n)</span>
<span class="gi">+            return make_CostMatrix(reduce_C(Ce.C, i, j, m, n), m_i, n_j)</span>
<span class="gi">+        return Ce</span>
<span class="gi">+</span>
<span class="gi">+    def get_edit_ops(</span>
<span class="gi">+        matched_uv, pending_u, pending_v, Cv, pending_g, pending_h, Ce, matched_cost</span>
<span class="gi">+    ):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Parameters:</span>
<span class="gi">+            matched_uv: partial vertex edit path</span>
<span class="gi">+                list of tuples (u, v) of vertex mappings u&lt;-&gt;v,</span>
<span class="gi">+                u=None or v=None for deletion/insertion</span>
<span class="gi">+            pending_u, pending_v: lists of vertices not yet mapped</span>
<span class="gi">+            Cv: CostMatrix of pending vertex mappings</span>
<span class="gi">+            pending_g, pending_h: lists of edges not yet mapped</span>
<span class="gi">+            Ce: CostMatrix of pending edge mappings</span>
<span class="gi">+            matched_cost: cost of partial edit path</span>
<span class="gi">+</span>
<span class="gi">+        Returns:</span>
<span class="gi">+            sequence of</span>
<span class="gi">+                (i, j): indices of vertex mapping u&lt;-&gt;v</span>
<span class="gi">+                Cv_ij: reduced CostMatrix of pending vertex mappings</span>
<span class="gi">+                    (basically Cv with row i, col j removed)</span>
<span class="gi">+                list of (x, y): indices of edge mappings g&lt;-&gt;h</span>
<span class="gi">+                Ce_xy: reduced CostMatrix of pending edge mappings</span>
<span class="gi">+                    (basically Ce with rows x, cols y removed)</span>
<span class="gi">+                cost: total cost of edit operation</span>
<span class="gi">+            NOTE: most promising ops first</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        m = len(pending_u)</span>
<span class="gi">+        n = len(pending_v)</span>
<span class="gi">+        # assert Cv.C.shape == (m + n, m + n)</span>
<span class="gi">+</span>
<span class="gi">+        # 1) a vertex mapping from optimal linear sum assignment</span>
<span class="gi">+        i, j = min(</span>
<span class="gi">+            (k, l) for k, l in zip(Cv.lsa_row_ind, Cv.lsa_col_ind) if k &lt; m or l &lt; n</span>
<span class="gi">+        )</span>
<span class="gi">+        xy, localCe = match_edges(</span>
<span class="gi">+            pending_u[i] if i &lt; m else None,</span>
<span class="gi">+            pending_v[j] if j &lt; n else None,</span>
<span class="gi">+            pending_g,</span>
<span class="gi">+            pending_h,</span>
<span class="gi">+            Ce,</span>
<span class="gi">+            matched_uv,</span>
<span class="gi">+        )</span>
<span class="gi">+        Ce_xy = reduce_Ce(Ce, xy, len(pending_g), len(pending_h))</span>
<span class="gi">+        # assert Ce.ls &lt;= localCe.ls + Ce_xy.ls</span>
<span class="gi">+        if prune(matched_cost + Cv.ls + localCe.ls + Ce_xy.ls):</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            # get reduced Cv efficiently</span>
<span class="gi">+            Cv_ij = CostMatrix(</span>
<span class="gi">+                reduce_C(Cv.C, (i,), (j,), m, n),</span>
<span class="gi">+                reduce_ind(Cv.lsa_row_ind, (i, m + j)),</span>
<span class="gi">+                reduce_ind(Cv.lsa_col_ind, (j, n + i)),</span>
<span class="gi">+                Cv.ls - Cv.C[i, j],</span>
<span class="gi">+            )</span>
<span class="gi">+            yield (i, j), Cv_ij, xy, Ce_xy, Cv.C[i, j] + localCe.ls</span>
<span class="gi">+</span>
<span class="gi">+        # 2) other candidates, sorted by lower-bound cost estimate</span>
<span class="gi">+        other = []</span>
<span class="gi">+        fixed_i, fixed_j = i, j</span>
<span class="gi">+        if m &lt;= n:</span>
<span class="gi">+            candidates = (</span>
<span class="gi">+                (t, fixed_j)</span>
<span class="gi">+                for t in range(m + n)</span>
<span class="gi">+                if t != fixed_i and (t &lt; m or t == m + fixed_j)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            candidates = (</span>
<span class="gi">+                (fixed_i, t)</span>
<span class="gi">+                for t in range(m + n)</span>
<span class="gi">+                if t != fixed_j and (t &lt; n or t == n + fixed_i)</span>
<span class="gi">+            )</span>
<span class="gi">+        for i, j in candidates:</span>
<span class="gi">+            if prune(matched_cost + Cv.C[i, j] + Ce.ls):</span>
<span class="gi">+                continue</span>
<span class="gi">+            Cv_ij = make_CostMatrix(</span>
<span class="gi">+                reduce_C(Cv.C, (i,), (j,), m, n),</span>
<span class="gi">+                m - 1 if i &lt; m else m,</span>
<span class="gi">+                n - 1 if j &lt; n else n,</span>
<span class="gi">+            )</span>
<span class="gi">+            # assert Cv.ls &lt;= Cv.C[i, j] + Cv_ij.ls</span>
<span class="gi">+            if prune(matched_cost + Cv.C[i, j] + Cv_ij.ls + Ce.ls):</span>
<span class="gi">+                continue</span>
<span class="gi">+            xy, localCe = match_edges(</span>
<span class="gi">+                pending_u[i] if i &lt; m else None,</span>
<span class="gi">+                pending_v[j] if j &lt; n else None,</span>
<span class="gi">+                pending_g,</span>
<span class="gi">+                pending_h,</span>
<span class="gi">+                Ce,</span>
<span class="gi">+                matched_uv,</span>
<span class="gi">+            )</span>
<span class="gi">+            if prune(matched_cost + Cv.C[i, j] + Cv_ij.ls + localCe.ls):</span>
<span class="gi">+                continue</span>
<span class="gi">+            Ce_xy = reduce_Ce(Ce, xy, len(pending_g), len(pending_h))</span>
<span class="gi">+            # assert Ce.ls &lt;= localCe.ls + Ce_xy.ls</span>
<span class="gi">+            if prune(matched_cost + Cv.C[i, j] + Cv_ij.ls + localCe.ls + Ce_xy.ls):</span>
<span class="gi">+                continue</span>
<span class="gi">+            other.append(((i, j), Cv_ij, xy, Ce_xy, Cv.C[i, j] + localCe.ls))</span>
<span class="gi">+</span>
<span class="gi">+        yield from sorted(other, key=lambda t: t[4] + t[1].ls + t[3].ls)</span>
<span class="gi">+</span>
<span class="gi">+    def get_edit_paths(</span>
<span class="gi">+        matched_uv,</span>
<span class="gi">+        pending_u,</span>
<span class="gi">+        pending_v,</span>
<span class="gi">+        Cv,</span>
<span class="gi">+        matched_gh,</span>
<span class="gi">+        pending_g,</span>
<span class="gi">+        pending_h,</span>
<span class="gi">+        Ce,</span>
<span class="gi">+        matched_cost,</span>
<span class="gi">+    ):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Parameters:</span>
<span class="gi">+            matched_uv: partial vertex edit path</span>
<span class="gi">+                list of tuples (u, v) of vertex mappings u&lt;-&gt;v,</span>
<span class="gi">+                u=None or v=None for deletion/insertion</span>
<span class="gi">+            pending_u, pending_v: lists of vertices not yet mapped</span>
<span class="gi">+            Cv: CostMatrix of pending vertex mappings</span>
<span class="gi">+            matched_gh: partial edge edit path</span>
<span class="gi">+                list of tuples (g, h) of edge mappings g&lt;-&gt;h,</span>
<span class="gi">+                g=None or h=None for deletion/insertion</span>
<span class="gi">+            pending_g, pending_h: lists of edges not yet mapped</span>
<span class="gi">+            Ce: CostMatrix of pending edge mappings</span>
<span class="gi">+            matched_cost: cost of partial edit path</span>
<span class="gi">+</span>
<span class="gi">+        Returns:</span>
<span class="gi">+            sequence of (vertex_path, edge_path, cost)</span>
<span class="gi">+                vertex_path: complete vertex edit path</span>
<span class="gi">+                    list of tuples (u, v) of vertex mappings u&lt;-&gt;v,</span>
<span class="gi">+                    u=None or v=None for deletion/insertion</span>
<span class="gi">+                edge_path: complete edge edit path</span>
<span class="gi">+                    list of tuples (g, h) of edge mappings g&lt;-&gt;h,</span>
<span class="gi">+                    g=None or h=None for deletion/insertion</span>
<span class="gi">+                cost: total cost of edit path</span>
<span class="gi">+            NOTE: path costs are non-increasing</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # debug_print(&#39;matched-uv:&#39;, matched_uv)</span>
<span class="gi">+        # debug_print(&#39;matched-gh:&#39;, matched_gh)</span>
<span class="gi">+        # debug_print(&#39;matched-cost:&#39;, matched_cost)</span>
<span class="gi">+        # debug_print(&#39;pending-u:&#39;, pending_u)</span>
<span class="gi">+        # debug_print(&#39;pending-v:&#39;, pending_v)</span>
<span class="gi">+        # debug_print(Cv.C)</span>
<span class="gi">+        # assert list(sorted(G1.nodes)) == list(sorted(list(u for u, v in matched_uv if u is not None) + pending_u))</span>
<span class="gi">+        # assert list(sorted(G2.nodes)) == list(sorted(list(v for u, v in matched_uv if v is not None) + pending_v))</span>
<span class="gi">+        # debug_print(&#39;pending-g:&#39;, pending_g)</span>
<span class="gi">+        # debug_print(&#39;pending-h:&#39;, pending_h)</span>
<span class="gi">+        # debug_print(Ce.C)</span>
<span class="gi">+        # assert list(sorted(G1.edges)) == list(sorted(list(g for g, h in matched_gh if g is not None) + pending_g))</span>
<span class="gi">+        # assert list(sorted(G2.edges)) == list(sorted(list(h for g, h in matched_gh if h is not None) + pending_h))</span>
<span class="gi">+        # debug_print()</span>
<span class="gi">+</span>
<span class="gi">+        if prune(matched_cost + Cv.ls + Ce.ls):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not max(len(pending_u), len(pending_v)):</span>
<span class="gi">+            # assert not len(pending_g)</span>
<span class="gi">+            # assert not len(pending_h)</span>
<span class="gi">+            # path completed!</span>
<span class="gi">+            # assert matched_cost &lt;= maxcost_value</span>
<span class="gi">+            nonlocal maxcost_value</span>
<span class="gi">+            maxcost_value = min(maxcost_value, matched_cost)</span>
<span class="gi">+            yield matched_uv, matched_gh, matched_cost</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            edit_ops = get_edit_ops(</span>
<span class="gi">+                matched_uv,</span>
<span class="gi">+                pending_u,</span>
<span class="gi">+                pending_v,</span>
<span class="gi">+                Cv,</span>
<span class="gi">+                pending_g,</span>
<span class="gi">+                pending_h,</span>
<span class="gi">+                Ce,</span>
<span class="gi">+                matched_cost,</span>
<span class="gi">+            )</span>
<span class="gi">+            for ij, Cv_ij, xy, Ce_xy, edit_cost in edit_ops:</span>
<span class="gi">+                i, j = ij</span>
<span class="gi">+                # assert Cv.C[i, j] + sum(Ce.C[t] for t in xy) == edit_cost</span>
<span class="gi">+                if prune(matched_cost + edit_cost + Cv_ij.ls + Ce_xy.ls):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # dive deeper</span>
<span class="gi">+                u = pending_u.pop(i) if i &lt; len(pending_u) else None</span>
<span class="gi">+                v = pending_v.pop(j) if j &lt; len(pending_v) else None</span>
<span class="gi">+                matched_uv.append((u, v))</span>
<span class="gi">+                for x, y in xy:</span>
<span class="gi">+                    len_g = len(pending_g)</span>
<span class="gi">+                    len_h = len(pending_h)</span>
<span class="gi">+                    matched_gh.append(</span>
<span class="gi">+                        (</span>
<span class="gi">+                            pending_g[x] if x &lt; len_g else None,</span>
<span class="gi">+                            pending_h[y] if y &lt; len_h else None,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                sortedx = sorted(x for x, y in xy)</span>
<span class="gi">+                sortedy = sorted(y for x, y in xy)</span>
<span class="gi">+                G = [</span>
<span class="gi">+                    (pending_g.pop(x) if x &lt; len(pending_g) else None)</span>
<span class="gi">+                    for x in reversed(sortedx)</span>
<span class="gi">+                ]</span>
<span class="gi">+                H = [</span>
<span class="gi">+                    (pending_h.pop(y) if y &lt; len(pending_h) else None)</span>
<span class="gi">+                    for y in reversed(sortedy)</span>
<span class="gi">+                ]</span>
<span class="gi">+</span>
<span class="gi">+                yield from get_edit_paths(</span>
<span class="gi">+                    matched_uv,</span>
<span class="gi">+                    pending_u,</span>
<span class="gi">+                    pending_v,</span>
<span class="gi">+                    Cv_ij,</span>
<span class="gi">+                    matched_gh,</span>
<span class="gi">+                    pending_g,</span>
<span class="gi">+                    pending_h,</span>
<span class="gi">+                    Ce_xy,</span>
<span class="gi">+                    matched_cost + edit_cost,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                # backtrack</span>
<span class="gi">+                if u is not None:</span>
<span class="gi">+                    pending_u.insert(i, u)</span>
<span class="gi">+                if v is not None:</span>
<span class="gi">+                    pending_v.insert(j, v)</span>
<span class="gi">+                matched_uv.pop()</span>
<span class="gi">+                for x, g in zip(sortedx, reversed(G)):</span>
<span class="gi">+                    if g is not None:</span>
<span class="gi">+                        pending_g.insert(x, g)</span>
<span class="gi">+                for y, h in zip(sortedy, reversed(H)):</span>
<span class="gi">+                    if h is not None:</span>
<span class="gi">+                        pending_h.insert(y, h)</span>
<span class="gi">+                for _ in xy:</span>
<span class="gi">+                    matched_gh.pop()</span>
<span class="gi">+</span>
<span class="gi">+    # Initialization</span>
<span class="gi">+</span>
<span class="gi">+    pending_u = list(G1.nodes)</span>
<span class="gi">+    pending_v = list(G2.nodes)</span>
<span class="gi">+</span>
<span class="gi">+    initial_cost = 0</span>
<span class="gi">+    if roots:</span>
<span class="gi">+        root_u, root_v = roots</span>
<span class="gi">+        if root_u not in pending_u or root_v not in pending_v:</span>
<span class="gi">+            raise nx.NodeNotFound(&quot;Root node not in graph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # remove roots from pending</span>
<span class="gi">+        pending_u.remove(root_u)</span>
<span class="gi">+        pending_v.remove(root_v)</span>
<span class="gi">+</span>
<span class="gi">+    # cost matrix of vertex mappings</span>
<span class="gi">+    m = len(pending_u)</span>
<span class="gi">+    n = len(pending_v)</span>
<span class="gi">+    C = np.zeros((m + n, m + n))</span>
<span class="gi">+    if node_subst_cost:</span>
<span class="gi">+        C[0:m, 0:n] = np.array(</span>
<span class="gi">+            [</span>
<span class="gi">+                node_subst_cost(G1.nodes[u], G2.nodes[v])</span>
<span class="gi">+                for u in pending_u</span>
<span class="gi">+                for v in pending_v</span>
<span class="gi">+            ]</span>
<span class="gi">+        ).reshape(m, n)</span>
<span class="gi">+        if roots:</span>
<span class="gi">+            initial_cost = node_subst_cost(G1.nodes[root_u], G2.nodes[root_v])</span>
<span class="gi">+    elif node_match:</span>
<span class="gi">+        C[0:m, 0:n] = np.array(</span>
<span class="gi">+            [</span>
<span class="gi">+                1 - int(node_match(G1.nodes[u], G2.nodes[v]))</span>
<span class="gi">+                for u in pending_u</span>
<span class="gi">+                for v in pending_v</span>
<span class="gi">+            ]</span>
<span class="gi">+        ).reshape(m, n)</span>
<span class="gi">+        if roots:</span>
<span class="gi">+            initial_cost = 1 - node_match(G1.nodes[root_u], G2.nodes[root_v])</span>
<span class="gi">+    else:</span>
<span class="gi">+        # all zeroes</span>
<span class="gi">+        pass</span>
<span class="gi">+    # assert not min(m, n) or C[0:m, 0:n].min() &gt;= 0</span>
<span class="gi">+    if node_del_cost:</span>
<span class="gi">+        del_costs = [node_del_cost(G1.nodes[u]) for u in pending_u]</span>
<span class="gi">+    else:</span>
<span class="gi">+        del_costs = [1] * len(pending_u)</span>
<span class="gi">+    # assert not m or min(del_costs) &gt;= 0</span>
<span class="gi">+    if node_ins_cost:</span>
<span class="gi">+        ins_costs = [node_ins_cost(G2.nodes[v]) for v in pending_v]</span>
<span class="gi">+    else:</span>
<span class="gi">+        ins_costs = [1] * len(pending_v)</span>
<span class="gi">+    # assert not n or min(ins_costs) &gt;= 0</span>
<span class="gi">+    inf = C[0:m, 0:n].sum() + sum(del_costs) + sum(ins_costs) + 1</span>
<span class="gi">+    C[0:m, n : n + m] = np.array(</span>
<span class="gi">+        [del_costs[i] if i == j else inf for i in range(m) for j in range(m)]</span>
<span class="gi">+    ).reshape(m, m)</span>
<span class="gi">+    C[m : m + n, 0:n] = np.array(</span>
<span class="gi">+        [ins_costs[i] if i == j else inf for i in range(n) for j in range(n)]</span>
<span class="gi">+    ).reshape(n, n)</span>
<span class="gi">+    Cv = make_CostMatrix(C, m, n)</span>
<span class="gi">+    # debug_print(f&quot;Cv: {m} x {n}&quot;)</span>
<span class="gi">+    # debug_print(Cv.C)</span>
<span class="gi">+</span>
<span class="gi">+    pending_g = list(G1.edges)</span>
<span class="gi">+    pending_h = list(G2.edges)</span>
<span class="gi">+</span>
<span class="gi">+    # cost matrix of edge mappings</span>
<span class="gi">+    m = len(pending_g)</span>
<span class="gi">+    n = len(pending_h)</span>
<span class="gi">+    C = np.zeros((m + n, m + n))</span>
<span class="gi">+    if edge_subst_cost:</span>
<span class="gi">+        C[0:m, 0:n] = np.array(</span>
<span class="gi">+            [</span>
<span class="gi">+                edge_subst_cost(G1.edges[g], G2.edges[h])</span>
<span class="gi">+                for g in pending_g</span>
<span class="gi">+                for h in pending_h</span>
<span class="gi">+            ]</span>
<span class="gi">+        ).reshape(m, n)</span>
<span class="gi">+    elif edge_match:</span>
<span class="gi">+        C[0:m, 0:n] = np.array(</span>
<span class="gi">+            [</span>
<span class="gi">+                1 - int(edge_match(G1.edges[g], G2.edges[h]))</span>
<span class="gi">+                for g in pending_g</span>
<span class="gi">+                for h in pending_h</span>
<span class="gi">+            ]</span>
<span class="gi">+        ).reshape(m, n)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # all zeroes</span>
<span class="gi">+        pass</span>
<span class="gi">+    # assert not min(m, n) or C[0:m, 0:n].min() &gt;= 0</span>
<span class="gi">+    if edge_del_cost:</span>
<span class="gi">+        del_costs = [edge_del_cost(G1.edges[g]) for g in pending_g]</span>
<span class="gi">+    else:</span>
<span class="gi">+        del_costs = [1] * len(pending_g)</span>
<span class="gi">+    # assert not m or min(del_costs) &gt;= 0</span>
<span class="gi">+    if edge_ins_cost:</span>
<span class="gi">+        ins_costs = [edge_ins_cost(G2.edges[h]) for h in pending_h]</span>
<span class="gi">+    else:</span>
<span class="gi">+        ins_costs = [1] * len(pending_h)</span>
<span class="gi">+    # assert not n or min(ins_costs) &gt;= 0</span>
<span class="gi">+    inf = C[0:m, 0:n].sum() + sum(del_costs) + sum(ins_costs) + 1</span>
<span class="gi">+    C[0:m, n : n + m] = np.array(</span>
<span class="gi">+        [del_costs[i] if i == j else inf for i in range(m) for j in range(m)]</span>
<span class="gi">+    ).reshape(m, m)</span>
<span class="gi">+    C[m : m + n, 0:n] = np.array(</span>
<span class="gi">+        [ins_costs[i] if i == j else inf for i in range(n) for j in range(n)]</span>
<span class="gi">+    ).reshape(n, n)</span>
<span class="gi">+    Ce = make_CostMatrix(C, m, n)</span>
<span class="gi">+    # debug_print(f&#39;Ce: {m} x {n}&#39;)</span>
<span class="gi">+    # debug_print(Ce.C)</span>
<span class="gi">+    # debug_print()</span>
<span class="gi">+</span>
<span class="gi">+    maxcost_value = Cv.C.sum() + Ce.C.sum() + 1</span>
<span class="gi">+</span>
<span class="gi">+    if timeout is not None:</span>
<span class="gi">+        if timeout &lt;= 0:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Timeout value must be greater than 0&quot;)</span>
<span class="gi">+        start = time.perf_counter()</span>
<span class="gi">+</span>
<span class="gi">+    def prune(cost):</span>
<span class="gi">+        if timeout is not None:</span>
<span class="gi">+            if time.perf_counter() - start &gt; timeout:</span>
<span class="gi">+                return True</span>
<span class="gi">+        if upper_bound is not None:</span>
<span class="gi">+            if cost &gt; upper_bound:</span>
<span class="gi">+                return True</span>
<span class="gi">+        if cost &gt; maxcost_value:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if strictly_decreasing and cost &gt;= maxcost_value:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Now go!</span>
<span class="gi">+</span>
<span class="gi">+    done_uv = [] if roots is None else [roots]</span>
<span class="gi">+</span>
<span class="gi">+    for vertex_path, edge_path, cost in get_edit_paths(</span>
<span class="gi">+        done_uv, pending_u, pending_v, Cv, [], pending_g, pending_h, Ce, initial_cost</span>
<span class="gi">+    ):</span>
<span class="gi">+        # assert sorted(G1.nodes) == sorted(u for u, v in vertex_path if u is not None)</span>
<span class="gi">+        # assert sorted(G2.nodes) == sorted(v for u, v in vertex_path if v is not None)</span>
<span class="gi">+        # assert sorted(G1.edges) == sorted(g for g, h in edge_path if g is not None)</span>
<span class="gi">+        # assert sorted(G2.edges) == sorted(h for g, h in edge_path if h is not None)</span>
<span class="gi">+        # print(vertex_path, edge_path, cost, file = sys.stderr)</span>
<span class="gi">+        # assert cost == maxcost_value</span>
<span class="gi">+        yield list(vertex_path), list(edge_path), float(cost)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gd">-def simrank_similarity(G, source=None, target=None, importance_factor=0.9,</span>
<span class="gd">-    max_iterations=1000, tolerance=0.0001):</span>
<span class="gi">+def simrank_similarity(</span>
<span class="gi">+    G,</span>
<span class="gi">+    source=None,</span>
<span class="gi">+    target=None,</span>
<span class="gi">+    importance_factor=0.9,</span>
<span class="gi">+    max_iterations=1000,</span>
<span class="gi">+    tolerance=1e-4,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the SimRank similarity of nodes in the graph ``G``.

<span class="w"> </span>    SimRank is a similarity metric that says &quot;two objects are considered
<span class="gu">@@ -683,11 +1326,45 @@ def simrank_similarity(G, source=None, target=None, importance_factor=0.9,</span>
<span class="w"> </span>           International Conference on Knowledge Discovery and Data Mining,
<span class="w"> </span>           pp. 538--543. ACM Press, 2002.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _simrank_similarity_python(G, source=None, target=None,</span>
<span class="gd">-    importance_factor=0.9, max_iterations=1000, tolerance=0.0001):</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    nodelist = list(G)</span>
<span class="gi">+    if source is not None:</span>
<span class="gi">+        if source not in nodelist:</span>
<span class="gi">+            raise nx.NodeNotFound(f&quot;Source node {source} not in G&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            s_indx = nodelist.index(source)</span>
<span class="gi">+    else:</span>
<span class="gi">+        s_indx = None</span>
<span class="gi">+</span>
<span class="gi">+    if target is not None:</span>
<span class="gi">+        if target not in nodelist:</span>
<span class="gi">+            raise nx.NodeNotFound(f&quot;Target node {target} not in G&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            t_indx = nodelist.index(target)</span>
<span class="gi">+    else:</span>
<span class="gi">+        t_indx = None</span>
<span class="gi">+</span>
<span class="gi">+    x = _simrank_similarity_numpy(</span>
<span class="gi">+        G, s_indx, t_indx, importance_factor, max_iterations, tolerance</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(x, np.ndarray):</span>
<span class="gi">+        if x.ndim == 1:</span>
<span class="gi">+            return dict(zip(G, x.tolist()))</span>
<span class="gi">+        # else x.ndim == 2</span>
<span class="gi">+        return {u: dict(zip(G, row)) for u, row in zip(G, x.tolist())}</span>
<span class="gi">+    return float(x)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _simrank_similarity_python(</span>
<span class="gi">+    G,</span>
<span class="gi">+    source=None,</span>
<span class="gi">+    target=None,</span>
<span class="gi">+    importance_factor=0.9,</span>
<span class="gi">+    max_iterations=1000,</span>
<span class="gi">+    tolerance=1e-4,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the SimRank similarity of nodes in the graph ``G``.

<span class="w"> </span>    This pure Python version is provided for pedagogical purposes.
<span class="gu">@@ -702,11 +1379,52 @@ def _simrank_similarity_python(G, source=None, target=None,</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.similarity._simrank_similarity_python(G, source=0, target=0)
<span class="w"> </span>    1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _simrank_similarity_numpy(G, source=None, target=None,</span>
<span class="gd">-    importance_factor=0.9, max_iterations=1000, tolerance=0.0001):</span>
<span class="gi">+    # build up our similarity adjacency dictionary output</span>
<span class="gi">+    newsim = {u: {v: 1 if u == v else 0 for v in G} for u in G}</span>
<span class="gi">+</span>
<span class="gi">+    # These functions compute the update to the similarity value of the nodes</span>
<span class="gi">+    # `u` and `v` with respect to the previous similarity values.</span>
<span class="gi">+    def avg_sim(s):</span>
<span class="gi">+        return sum(newsim[w][x] for (w, x) in s) / len(s) if s else 0.0</span>
<span class="gi">+</span>
<span class="gi">+    Gadj = G.pred if G.is_directed() else G.adj</span>
<span class="gi">+</span>
<span class="gi">+    def sim(u, v):</span>
<span class="gi">+        return importance_factor * avg_sim(list(product(Gadj[u], Gadj[v])))</span>
<span class="gi">+</span>
<span class="gi">+    for its in range(max_iterations):</span>
<span class="gi">+        oldsim = newsim</span>
<span class="gi">+        newsim = {u: {v: sim(u, v) if u != v else 1 for v in G} for u in G}</span>
<span class="gi">+        is_close = all(</span>
<span class="gi">+            all(</span>
<span class="gi">+                abs(newsim[u][v] - old) &lt;= tolerance * (1 + abs(old))</span>
<span class="gi">+                for v, old in nbrs.items()</span>
<span class="gi">+            )</span>
<span class="gi">+            for u, nbrs in oldsim.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        if is_close:</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    if its + 1 == max_iterations:</span>
<span class="gi">+        raise nx.ExceededMaxIterations(</span>
<span class="gi">+            f&quot;simrank did not converge after {max_iterations} iterations.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if source is not None and target is not None:</span>
<span class="gi">+        return newsim[source][target]</span>
<span class="gi">+    if source is not None:</span>
<span class="gi">+        return newsim[source]</span>
<span class="gi">+    return newsim</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _simrank_similarity_numpy(</span>
<span class="gi">+    G,</span>
<span class="gi">+    source=None,</span>
<span class="gi">+    target=None,</span>
<span class="gi">+    importance_factor=0.9,</span>
<span class="gi">+    max_iterations=1000,</span>
<span class="gi">+    tolerance=1e-4,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Calculate SimRank of nodes in ``G`` using matrices with ``numpy``.

<span class="w"> </span>    The SimRank algorithm for determining node similarity is defined in
<span class="gu">@@ -772,13 +1490,47 @@ def _simrank_similarity_numpy(G, source=None, target=None,</span>
<span class="w"> </span>           International Conference on Knowledge Discovery and Data Mining,
<span class="w"> </span>           pp. 538--543. ACM Press, 2002.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def panther_similarity(G, source, k=5, path_length=5, c=0.5, delta=0.1, eps</span>
<span class="gd">-    =None, weight=&#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the Panther similarity of nodes in the graph `G` to node ``v``.</span>
<span class="gi">+    # This algorithm follows roughly</span>
<span class="gi">+    #</span>
<span class="gi">+    #     S = max{C * (A.T * S * A), I}</span>
<span class="gi">+    #</span>
<span class="gi">+    # where C is the importance factor, A is the column normalized</span>
<span class="gi">+    # adjacency matrix, and I is the identity matrix.</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    adjacency_matrix = nx.to_numpy_array(G)</span>
<span class="gi">+</span>
<span class="gi">+    # column-normalize the ``adjacency_matrix``</span>
<span class="gi">+    s = np.array(adjacency_matrix.sum(axis=0))</span>
<span class="gi">+    s[s == 0] = 1</span>
<span class="gi">+    adjacency_matrix /= s  # adjacency_matrix.sum(axis=0)</span>
<span class="gi">+</span>
<span class="gi">+    newsim = np.eye(len(G), dtype=np.float64)</span>
<span class="gi">+    for its in range(max_iterations):</span>
<span class="gi">+        prevsim = newsim.copy()</span>
<span class="gi">+        newsim = importance_factor * ((adjacency_matrix.T @ prevsim) @ adjacency_matrix)</span>
<span class="gi">+        np.fill_diagonal(newsim, 1.0)</span>
<span class="gi">+</span>
<span class="gi">+        if np.allclose(prevsim, newsim, atol=tolerance):</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    if its + 1 == max_iterations:</span>
<span class="gi">+        raise nx.ExceededMaxIterations(</span>
<span class="gi">+            f&quot;simrank did not converge after {max_iterations} iterations.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if source is not None and target is not None:</span>
<span class="gi">+        return float(newsim[source, target])</span>
<span class="gi">+    if source is not None:</span>
<span class="gi">+        return newsim[source]</span>
<span class="gi">+    return newsim</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def panther_similarity(</span>
<span class="gi">+    G, source, k=5, path_length=5, c=0.5, delta=0.1, eps=None, weight=&quot;weight&quot;</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Panther similarity of nodes in the graph `G` to node ``v``.</span>

<span class="w"> </span>    Panther is a similarity metric that says &quot;two objects are considered
<span class="w"> </span>    to be similar if they frequently appear on the same paths.&quot; [1]_.
<span class="gu">@@ -798,8 +1550,8 @@ def panther_similarity(G, source, k=5, path_length=5, c=0.5, delta=0.1, eps</span>
<span class="w"> </span>        of sample random paths to generate.
<span class="w"> </span>    delta : float (default = 0.1)
<span class="w"> </span>        The probability that the similarity $S$ is not an epsilon-approximation to (R, phi),
<span class="gd">-        where $R$ is the number of random paths and $\\phi$ is the probability</span>
<span class="gd">-        that an element sampled from a set $A \\subseteq D$, where $D$ is the domain.</span>
<span class="gi">+        where $R$ is the number of random paths and $\phi$ is the probability</span>
<span class="gi">+        that an element sampled from a set $A \subseteq D$, where $D$ is the domain.</span>
<span class="w"> </span>    eps : float or None (default = None)
<span class="w"> </span>        The error bound. Per [1]_, a good value is ``sqrt(1/|E|)``. Therefore,
<span class="w"> </span>        if no value is provided, the recommended computed value will be used.
<span class="gu">@@ -840,13 +1592,82 @@ def panther_similarity(G, source, k=5, path_length=5, c=0.5, delta=0.1, eps</span>
<span class="w"> </span>           on Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445–1454).
<span class="w"> </span>           Association for Computing Machinery. https://doi.org/10.1145/2783258.2783267.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if source not in G:</span>
<span class="gi">+        raise nx.NodeNotFound(f&quot;Source node {source} not in G&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    isolates = set(nx.isolates(G))</span>
<span class="gi">+</span>
<span class="gi">+    if source in isolates:</span>
<span class="gi">+        raise nx.NetworkXUnfeasible(</span>
<span class="gi">+            f&quot;Panther similarity is not defined for the isolated source node {source}.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    G = G.subgraph([node for node in G.nodes if node not in isolates]).copy()</span>
<span class="gi">+</span>
<span class="gi">+    num_nodes = G.number_of_nodes()</span>
<span class="gi">+    if num_nodes &lt; k:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            f&quot;Number of nodes is {num_nodes}, but requested k is {k}. &quot;</span>
<span class="gi">+            &quot;Setting k to number of nodes.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        k = num_nodes</span>
<span class="gi">+    # According to [1], they empirically determined</span>
<span class="gi">+    # a good value for ``eps`` to be sqrt( 1 / |E| )</span>
<span class="gi">+    if eps is None:</span>
<span class="gi">+        eps = np.sqrt(1.0 / G.number_of_edges())</span>
<span class="gi">+</span>
<span class="gi">+    inv_node_map = {name: index for index, name in enumerate(G.nodes)}</span>
<span class="gi">+    node_map = np.array(G)</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate the sample size ``R`` for how many paths</span>
<span class="gi">+    # to randomly generate</span>
<span class="gi">+    t_choose_2 = math.comb(path_length, 2)</span>
<span class="gi">+    sample_size = int((c / eps**2) * (np.log2(t_choose_2) + 1 + np.log(1 / delta)))</span>
<span class="gi">+    index_map = {}</span>
<span class="gi">+    _ = list(</span>
<span class="gi">+        generate_random_paths(</span>
<span class="gi">+            G, sample_size, path_length=path_length, index_map=index_map, weight=weight</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    S = np.zeros(num_nodes)</span>
<span class="gi">+</span>
<span class="gi">+    inv_sample_size = 1 / sample_size</span>
<span class="gi">+</span>
<span class="gi">+    source_paths = set(index_map[source])</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate the path similarities</span>
<span class="gi">+    # between ``source`` (v) and ``node`` (v_j)</span>
<span class="gi">+    # using our inverted index mapping of</span>
<span class="gi">+    # vertices to paths</span>
<span class="gi">+    for node, paths in index_map.items():</span>
<span class="gi">+        # Only consider paths where both</span>
<span class="gi">+        # ``node`` and ``source`` are present</span>
<span class="gi">+        common_paths = source_paths.intersection(paths)</span>
<span class="gi">+        S[inv_node_map[node]] = len(common_paths) * inv_sample_size</span>
<span class="gi">+</span>
<span class="gi">+    # Retrieve top ``k`` similar</span>
<span class="gi">+    # Note: the below performed anywhere from 4-10x faster</span>
<span class="gi">+    # (depending on input sizes) vs the equivalent ``np.argsort(S)[::-1]``</span>
<span class="gi">+    top_k_unsorted = np.argpartition(S, -k)[-k:]</span>
<span class="gi">+    top_k_sorted = top_k_unsorted[np.argsort(S[top_k_unsorted])][::-1]</span>
<span class="gi">+</span>
<span class="gi">+    # Add back the similarity scores</span>
<span class="gi">+    top_k_with_val = dict(</span>
<span class="gi">+        zip(node_map[top_k_sorted].tolist(), S[top_k_sorted].tolist())</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Remove the self-similarity</span>
<span class="gi">+    top_k_with_val.pop(source, None)</span>
<span class="gi">+    return top_k_with_val</span>


<span class="w"> </span>@np_random_state(5)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def generate_random_paths(G, sample_size, path_length=5, index_map=None,</span>
<span class="gd">-    weight=&#39;weight&#39;, seed=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def generate_random_paths(</span>
<span class="gi">+    G, sample_size, path_length=5, index_map=None, weight=&quot;weight&quot;, seed=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Randomly generate `sample_size` paths of length `path_length`.

<span class="w"> </span>    Parameters
<span class="gu">@@ -900,4 +1721,57 @@ def generate_random_paths(G, sample_size, path_length=5, index_map=None,</span>
<span class="w"> </span>           on Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445–1454).
<span class="w"> </span>           Association for Computing Machinery. https://doi.org/10.1145/2783258.2783267.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    randint_fn = (</span>
<span class="gi">+        seed.integers if isinstance(seed, np.random.Generator) else seed.randint</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate transition probabilities between</span>
<span class="gi">+    # every pair of vertices according to Eq. (3)</span>
<span class="gi">+    adj_mat = nx.to_numpy_array(G, weight=weight)</span>
<span class="gi">+    inv_row_sums = np.reciprocal(adj_mat.sum(axis=1)).reshape(-1, 1)</span>
<span class="gi">+    transition_probabilities = adj_mat * inv_row_sums</span>
<span class="gi">+</span>
<span class="gi">+    node_map = list(G)</span>
<span class="gi">+    num_nodes = G.number_of_nodes()</span>
<span class="gi">+</span>
<span class="gi">+    for path_index in range(sample_size):</span>
<span class="gi">+        # Sample current vertex v = v_i uniformly at random</span>
<span class="gi">+        node_index = randint_fn(num_nodes)</span>
<span class="gi">+        node = node_map[node_index]</span>
<span class="gi">+</span>
<span class="gi">+        # Add v into p_r and add p_r into the path set</span>
<span class="gi">+        # of v, i.e., P_v</span>
<span class="gi">+        path = [node]</span>
<span class="gi">+</span>
<span class="gi">+        # Build the inverted index (P_v) of vertices to paths</span>
<span class="gi">+        if index_map is not None:</span>
<span class="gi">+            if node in index_map:</span>
<span class="gi">+                index_map[node].add(path_index)</span>
<span class="gi">+            else:</span>
<span class="gi">+                index_map[node] = {path_index}</span>
<span class="gi">+</span>
<span class="gi">+        starting_index = node_index</span>
<span class="gi">+        for _ in range(path_length):</span>
<span class="gi">+            # Randomly sample a neighbor (v_j) according</span>
<span class="gi">+            # to transition probabilities from ``node`` (v) to its neighbors</span>
<span class="gi">+            nbr_index = seed.choice(</span>
<span class="gi">+                num_nodes, p=transition_probabilities[starting_index]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Set current vertex (v = v_j)</span>
<span class="gi">+            starting_index = nbr_index</span>
<span class="gi">+</span>
<span class="gi">+            # Add v into p_r</span>
<span class="gi">+            nbr_node = node_map[nbr_index]</span>
<span class="gi">+            path.append(nbr_node)</span>
<span class="gi">+</span>
<span class="gi">+            # Add p_r into P_v</span>
<span class="gi">+            if index_map is not None:</span>
<span class="gi">+                if nbr_node in index_map:</span>
<span class="gi">+                    index_map[nbr_node].add(path_index)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    index_map[nbr_node] = {path_index}</span>
<span class="gi">+</span>
<span class="gi">+        yield path</span>
<span class="gh">diff --git a/networkx/algorithms/simple_paths.py b/networkx/algorithms/simple_paths.py</span>
<span class="gh">index c96d21ae5..1bd2feb70 100644</span>
<span class="gd">--- a/networkx/algorithms/simple_paths.py</span>
<span class="gi">+++ b/networkx/algorithms/simple_paths.py</span>
<span class="gu">@@ -1,10 +1,16 @@</span>
<span class="w"> </span>from heapq import heappop, heappush
<span class="w"> </span>from itertools import count
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.shortest_paths.weighted import _weight_function
<span class="w"> </span>from networkx.utils import not_implemented_for, pairwise
<span class="gd">-__all__ = [&#39;all_simple_paths&#39;, &#39;is_simple_path&#39;, &#39;shortest_simple_paths&#39;,</span>
<span class="gd">-    &#39;all_simple_edge_paths&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;all_simple_paths&quot;,</span>
<span class="gi">+    &quot;is_simple_path&quot;,</span>
<span class="gi">+    &quot;shortest_simple_paths&quot;,</span>
<span class="gi">+    &quot;all_simple_edge_paths&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -62,7 +68,27 @@ def is_simple_path(G, nodes):</span>
<span class="w"> </span>    False

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The empty list is not a valid path. Could also return</span>
<span class="gi">+    # NetworkXPointlessConcept here.</span>
<span class="gi">+    if len(nodes) == 0:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # If the list is a single node, just check that the node is actually</span>
<span class="gi">+    # in the graph.</span>
<span class="gi">+    if len(nodes) == 1:</span>
<span class="gi">+        return nodes[0] in G</span>
<span class="gi">+</span>
<span class="gi">+    # check that all nodes in the list are in the graph, if at least one</span>
<span class="gi">+    # is not in the graph, then this is not a simple path</span>
<span class="gi">+    if not all(n in G for n in nodes):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # If the list contains repeated nodes, then it&#39;s not a simple path</span>
<span class="gi">+    if len(set(nodes)) != len(nodes):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Test that each adjacent pair of nodes is adjacent.</span>
<span class="gi">+    return all(v in G[u] for u, v in pairwise(nodes))</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -227,7 +253,8 @@ def all_simple_paths(G, source, target, cutoff=None):</span>
<span class="w"> </span>    all_shortest_paths, shortest_path, has_path

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for edge_path in all_simple_edge_paths(G, source, target, cutoff):</span>
<span class="gi">+        yield [source] + [edge[1] for edge in edge_path]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -315,11 +342,67 @@ def all_simple_edge_paths(G, source, target, cutoff=None):</span>
<span class="w"> </span>    all_shortest_paths, shortest_path, all_simple_paths

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    if source not in G:</span>
<span class="gi">+        raise nx.NodeNotFound(f&quot;source node {source} not in graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if target in G:</span>
<span class="gi">+        targets = {target}</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            targets = set(target)</span>
<span class="gi">+        except TypeError as err:</span>
<span class="gi">+            raise nx.NodeNotFound(f&quot;target node {target} not in graph&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    cutoff = cutoff if cutoff is not None else len(G) - 1</span>
<span class="gi">+</span>
<span class="gi">+    if cutoff &gt;= 0 and targets:</span>
<span class="gi">+        yield from _all_simple_edge_paths(G, source, targets, cutoff)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _all_simple_edge_paths(G, source, targets, cutoff):</span>
<span class="gi">+    # We simulate recursion with a stack, keeping the current path being explored</span>
<span class="gi">+    # and the outgoing edge iterators at each point in the stack.</span>
<span class="gi">+    # To avoid unnecessary checks, the loop is structured in a way such that a path</span>
<span class="gi">+    # is considered for yielding only after a new node/edge is added.</span>
<span class="gi">+    # We bootstrap the search by adding a dummy iterator to the stack that only yields</span>
<span class="gi">+    # a dummy edge to source (so that the trivial path has a chance of being included).</span>
<span class="gi">+</span>
<span class="gi">+    get_edges = (</span>
<span class="gi">+        (lambda node: G.edges(node, keys=True))</span>
<span class="gi">+        if G.is_multigraph()</span>
<span class="gi">+        else (lambda node: G.edges(node))</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # The current_path is a dictionary that maps nodes in the path to the edge that was</span>
<span class="gi">+    # used to enter that node (instead of a list of edges) because we want both a fast</span>
<span class="gi">+    # membership test for nodes in the path and the preservation of insertion order.</span>
<span class="gi">+    current_path = {None: None}</span>
<span class="gi">+    stack = [iter([(None, source)])]</span>
<span class="gi">+</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        # 1. Try to extend the current path.</span>
<span class="gi">+        next_edge = next((e for e in stack[-1] if e[1] not in current_path), None)</span>
<span class="gi">+        if next_edge is None:</span>
<span class="gi">+            # All edges of the last node in the current path have been explored.</span>
<span class="gi">+            stack.pop()</span>
<span class="gi">+            current_path.popitem()</span>
<span class="gi">+            continue</span>
<span class="gi">+        previous_node, next_node, *_ = next_edge</span>
<span class="gi">+</span>
<span class="gi">+        # 2. Check if we&#39;ve reached a target.</span>
<span class="gi">+        if next_node in targets:</span>
<span class="gi">+            yield (list(current_path.values()) + [next_edge])[2:]  # remove dummy edge</span>
<span class="gi">+</span>
<span class="gi">+        # 3. Only expand the search through the next node if it makes sense.</span>
<span class="gi">+        if len(current_path) - 1 &lt; cutoff and (</span>
<span class="gi">+            targets - current_path.keys() - {next_node}</span>
<span class="gi">+        ):</span>
<span class="gi">+            current_path[next_node] = next_edge</span>
<span class="gi">+            stack.append(iter(get_edges(next_node)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def shortest_simple_paths(G, source, target, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Generate all simple paths in the graph G from source to target,
<span class="w"> </span>       starting from shortest ones.
<span class="gu">@@ -407,11 +490,66 @@ def shortest_simple_paths(G, source, target, weight=None):</span>
<span class="w"> </span>       (Jul., 1971), pp. 712-716.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if source not in G:</span>
<span class="gi">+        raise nx.NodeNotFound(f&quot;source node {source} not in graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if target not in G:</span>
<span class="gi">+        raise nx.NodeNotFound(f&quot;target node {target} not in graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if weight is None:</span>
<span class="gi">+        length_func = len</span>
<span class="gi">+        shortest_path_func = _bidirectional_shortest_path</span>
<span class="gi">+    else:</span>
<span class="gi">+        wt = _weight_function(G, weight)</span>
<span class="gi">+</span>
<span class="gi">+        def length_func(path):</span>
<span class="gi">+            return sum(</span>
<span class="gi">+                wt(u, v, G.get_edge_data(u, v)) for (u, v) in zip(path, path[1:])</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        shortest_path_func = _bidirectional_dijkstra</span>
<span class="gi">+</span>
<span class="gi">+    listA = []</span>
<span class="gi">+    listB = PathBuffer()</span>
<span class="gi">+    prev_path = None</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if not prev_path:</span>
<span class="gi">+            length, path = shortest_path_func(G, source, target, weight=weight)</span>
<span class="gi">+            listB.push(length, path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ignore_nodes = set()</span>
<span class="gi">+            ignore_edges = set()</span>
<span class="gi">+            for i in range(1, len(prev_path)):</span>
<span class="gi">+                root = prev_path[:i]</span>
<span class="gi">+                root_length = length_func(root)</span>
<span class="gi">+                for path in listA:</span>
<span class="gi">+                    if path[:i] == root:</span>
<span class="gi">+                        ignore_edges.add((path[i - 1], path[i]))</span>
<span class="gi">+                try:</span>
<span class="gi">+                    length, spur = shortest_path_func(</span>
<span class="gi">+                        G,</span>
<span class="gi">+                        root[-1],</span>
<span class="gi">+                        target,</span>
<span class="gi">+                        ignore_nodes=ignore_nodes,</span>
<span class="gi">+                        ignore_edges=ignore_edges,</span>
<span class="gi">+                        weight=weight,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    path = root[:-1] + spur</span>
<span class="gi">+                    listB.push(root_length + length, path)</span>
<span class="gi">+                except nx.NetworkXNoPath:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                ignore_nodes.add(root[-1])</span>
<span class="gi">+</span>
<span class="gi">+        if listB:</span>
<span class="gi">+            path = listB.pop()</span>
<span class="gi">+            yield path</span>
<span class="gi">+            listA.append(path)</span>
<span class="gi">+            prev_path = path</span>
<span class="gi">+        else:</span>
<span class="gi">+            break</span>


<span class="w"> </span>class PathBuffer:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self.paths = set()
<span class="w"> </span>        self.sortedpaths = []
<span class="gu">@@ -420,9 +558,22 @@ class PathBuffer:</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self.sortedpaths)

<span class="gi">+    def push(self, cost, path):</span>
<span class="gi">+        hashable_path = tuple(path)</span>
<span class="gi">+        if hashable_path not in self.paths:</span>
<span class="gi">+            heappush(self.sortedpaths, (cost, next(self.counter), path))</span>
<span class="gi">+            self.paths.add(hashable_path)</span>
<span class="gi">+</span>
<span class="gi">+    def pop(self):</span>
<span class="gi">+        (cost, num, path) = heappop(self.sortedpaths)</span>
<span class="gi">+        hashable_path = tuple(path)</span>
<span class="gi">+        self.paths.remove(hashable_path)</span>
<span class="gi">+        return path</span>

<span class="gd">-def _bidirectional_shortest_path(G, source, target, ignore_nodes=None,</span>
<span class="gd">-    ignore_edges=None, weight=None):</span>
<span class="gi">+</span>
<span class="gi">+def _bidirectional_shortest_path(</span>
<span class="gi">+    G, source, target, ignore_nodes=None, ignore_edges=None, weight=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the shortest path between source and target ignoring
<span class="w"> </span>       nodes and edges in the containers ignore_nodes and ignore_edges.

<span class="gu">@@ -464,21 +615,133 @@ def _bidirectional_shortest_path(G, source, target, ignore_nodes=None,</span>
<span class="w"> </span>    shortest_path

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _bidirectional_pred_succ(G, source, target, ignore_nodes=None,</span>
<span class="gd">-    ignore_edges=None):</span>
<span class="gi">+    # call helper to do the real work</span>
<span class="gi">+    results = _bidirectional_pred_succ(G, source, target, ignore_nodes, ignore_edges)</span>
<span class="gi">+    pred, succ, w = results</span>
<span class="gi">+</span>
<span class="gi">+    # build path from pred+w+succ</span>
<span class="gi">+    path = []</span>
<span class="gi">+    # from w to target</span>
<span class="gi">+    while w is not None:</span>
<span class="gi">+        path.append(w)</span>
<span class="gi">+        w = succ[w]</span>
<span class="gi">+    # from source to w</span>
<span class="gi">+    w = pred[path[0]]</span>
<span class="gi">+    while w is not None:</span>
<span class="gi">+        path.insert(0, w)</span>
<span class="gi">+        w = pred[w]</span>
<span class="gi">+</span>
<span class="gi">+    return len(path), path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _bidirectional_pred_succ(G, source, target, ignore_nodes=None, ignore_edges=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Bidirectional shortest path helper.
<span class="w"> </span>    Returns (pred,succ,w) where
<span class="w"> </span>    pred is a dictionary of predecessors from w to the source, and
<span class="w"> </span>    succ is a dictionary of successors from w to the target.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _bidirectional_dijkstra(G, source, target, weight=&#39;weight&#39;,</span>
<span class="gd">-    ignore_nodes=None, ignore_edges=None):</span>
<span class="gi">+    # does BFS from both source and target and meets in the middle</span>
<span class="gi">+    if ignore_nodes and (source in ignore_nodes or target in ignore_nodes):</span>
<span class="gi">+        raise nx.NetworkXNoPath(f&quot;No path between {source} and {target}.&quot;)</span>
<span class="gi">+    if target == source:</span>
<span class="gi">+        return ({target: None}, {source: None}, source)</span>
<span class="gi">+</span>
<span class="gi">+    # handle either directed or undirected</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        Gpred = G.predecessors</span>
<span class="gi">+        Gsucc = G.successors</span>
<span class="gi">+    else:</span>
<span class="gi">+        Gpred = G.neighbors</span>
<span class="gi">+        Gsucc = G.neighbors</span>
<span class="gi">+</span>
<span class="gi">+    # support optional nodes filter</span>
<span class="gi">+    if ignore_nodes:</span>
<span class="gi">+</span>
<span class="gi">+        def filter_iter(nodes):</span>
<span class="gi">+            def iterate(v):</span>
<span class="gi">+                for w in nodes(v):</span>
<span class="gi">+                    if w not in ignore_nodes:</span>
<span class="gi">+                        yield w</span>
<span class="gi">+</span>
<span class="gi">+            return iterate</span>
<span class="gi">+</span>
<span class="gi">+        Gpred = filter_iter(Gpred)</span>
<span class="gi">+        Gsucc = filter_iter(Gsucc)</span>
<span class="gi">+</span>
<span class="gi">+    # support optional edges filter</span>
<span class="gi">+    if ignore_edges:</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+</span>
<span class="gi">+            def filter_pred_iter(pred_iter):</span>
<span class="gi">+                def iterate(v):</span>
<span class="gi">+                    for w in pred_iter(v):</span>
<span class="gi">+                        if (w, v) not in ignore_edges:</span>
<span class="gi">+                            yield w</span>
<span class="gi">+</span>
<span class="gi">+                return iterate</span>
<span class="gi">+</span>
<span class="gi">+            def filter_succ_iter(succ_iter):</span>
<span class="gi">+                def iterate(v):</span>
<span class="gi">+                    for w in succ_iter(v):</span>
<span class="gi">+                        if (v, w) not in ignore_edges:</span>
<span class="gi">+                            yield w</span>
<span class="gi">+</span>
<span class="gi">+                return iterate</span>
<span class="gi">+</span>
<span class="gi">+            Gpred = filter_pred_iter(Gpred)</span>
<span class="gi">+            Gsucc = filter_succ_iter(Gsucc)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def filter_iter(nodes):</span>
<span class="gi">+                def iterate(v):</span>
<span class="gi">+                    for w in nodes(v):</span>
<span class="gi">+                        if (v, w) not in ignore_edges and (w, v) not in ignore_edges:</span>
<span class="gi">+                            yield w</span>
<span class="gi">+</span>
<span class="gi">+                return iterate</span>
<span class="gi">+</span>
<span class="gi">+            Gpred = filter_iter(Gpred)</span>
<span class="gi">+            Gsucc = filter_iter(Gsucc)</span>
<span class="gi">+</span>
<span class="gi">+    # predecessor and successors in search</span>
<span class="gi">+    pred = {source: None}</span>
<span class="gi">+    succ = {target: None}</span>
<span class="gi">+</span>
<span class="gi">+    # initialize fringes, start with forward</span>
<span class="gi">+    forward_fringe = [source]</span>
<span class="gi">+    reverse_fringe = [target]</span>
<span class="gi">+</span>
<span class="gi">+    while forward_fringe and reverse_fringe:</span>
<span class="gi">+        if len(forward_fringe) &lt;= len(reverse_fringe):</span>
<span class="gi">+            this_level = forward_fringe</span>
<span class="gi">+            forward_fringe = []</span>
<span class="gi">+            for v in this_level:</span>
<span class="gi">+                for w in Gsucc(v):</span>
<span class="gi">+                    if w not in pred:</span>
<span class="gi">+                        forward_fringe.append(w)</span>
<span class="gi">+                        pred[w] = v</span>
<span class="gi">+                    if w in succ:</span>
<span class="gi">+                        # found path</span>
<span class="gi">+                        return pred, succ, w</span>
<span class="gi">+        else:</span>
<span class="gi">+            this_level = reverse_fringe</span>
<span class="gi">+            reverse_fringe = []</span>
<span class="gi">+            for v in this_level:</span>
<span class="gi">+                for w in Gpred(v):</span>
<span class="gi">+                    if w not in succ:</span>
<span class="gi">+                        succ[w] = v</span>
<span class="gi">+                        reverse_fringe.append(w)</span>
<span class="gi">+                    if w in pred:</span>
<span class="gi">+                        # found path</span>
<span class="gi">+                        return pred, succ, w</span>
<span class="gi">+</span>
<span class="gi">+    raise nx.NetworkXNoPath(f&quot;No path between {source} and {target}.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _bidirectional_dijkstra(</span>
<span class="gi">+    G, source, target, weight=&quot;weight&quot;, ignore_nodes=None, ignore_edges=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Dijkstra&#39;s algorithm for shortest paths using bidirectional search.

<span class="w"> </span>    This function returns the shortest path between source and target
<span class="gu">@@ -545,4 +808,130 @@ def _bidirectional_dijkstra(G, source, target, weight=&#39;weight&#39;,</span>
<span class="w"> </span>    shortest_path
<span class="w"> </span>    shortest_path_length
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if ignore_nodes and (source in ignore_nodes or target in ignore_nodes):</span>
<span class="gi">+        raise nx.NetworkXNoPath(f&quot;No path between {source} and {target}.&quot;)</span>
<span class="gi">+    if source == target:</span>
<span class="gi">+        if source not in G:</span>
<span class="gi">+            raise nx.NodeNotFound(f&quot;Node {source} not in graph&quot;)</span>
<span class="gi">+        return (0, [source])</span>
<span class="gi">+</span>
<span class="gi">+    # handle either directed or undirected</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        Gpred = G.predecessors</span>
<span class="gi">+        Gsucc = G.successors</span>
<span class="gi">+    else:</span>
<span class="gi">+        Gpred = G.neighbors</span>
<span class="gi">+        Gsucc = G.neighbors</span>
<span class="gi">+</span>
<span class="gi">+    # support optional nodes filter</span>
<span class="gi">+    if ignore_nodes:</span>
<span class="gi">+</span>
<span class="gi">+        def filter_iter(nodes):</span>
<span class="gi">+            def iterate(v):</span>
<span class="gi">+                for w in nodes(v):</span>
<span class="gi">+                    if w not in ignore_nodes:</span>
<span class="gi">+                        yield w</span>
<span class="gi">+</span>
<span class="gi">+            return iterate</span>
<span class="gi">+</span>
<span class="gi">+        Gpred = filter_iter(Gpred)</span>
<span class="gi">+        Gsucc = filter_iter(Gsucc)</span>
<span class="gi">+</span>
<span class="gi">+    # support optional edges filter</span>
<span class="gi">+    if ignore_edges:</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+</span>
<span class="gi">+            def filter_pred_iter(pred_iter):</span>
<span class="gi">+                def iterate(v):</span>
<span class="gi">+                    for w in pred_iter(v):</span>
<span class="gi">+                        if (w, v) not in ignore_edges:</span>
<span class="gi">+                            yield w</span>
<span class="gi">+</span>
<span class="gi">+                return iterate</span>
<span class="gi">+</span>
<span class="gi">+            def filter_succ_iter(succ_iter):</span>
<span class="gi">+                def iterate(v):</span>
<span class="gi">+                    for w in succ_iter(v):</span>
<span class="gi">+                        if (v, w) not in ignore_edges:</span>
<span class="gi">+                            yield w</span>
<span class="gi">+</span>
<span class="gi">+                return iterate</span>
<span class="gi">+</span>
<span class="gi">+            Gpred = filter_pred_iter(Gpred)</span>
<span class="gi">+            Gsucc = filter_succ_iter(Gsucc)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def filter_iter(nodes):</span>
<span class="gi">+                def iterate(v):</span>
<span class="gi">+                    for w in nodes(v):</span>
<span class="gi">+                        if (v, w) not in ignore_edges and (w, v) not in ignore_edges:</span>
<span class="gi">+                            yield w</span>
<span class="gi">+</span>
<span class="gi">+                return iterate</span>
<span class="gi">+</span>
<span class="gi">+            Gpred = filter_iter(Gpred)</span>
<span class="gi">+            Gsucc = filter_iter(Gsucc)</span>
<span class="gi">+</span>
<span class="gi">+    push = heappush</span>
<span class="gi">+    pop = heappop</span>
<span class="gi">+    # Init:   Forward             Backward</span>
<span class="gi">+    dists = [{}, {}]  # dictionary of final distances</span>
<span class="gi">+    paths = [{source: [source]}, {target: [target]}]  # dictionary of paths</span>
<span class="gi">+    fringe = [[], []]  # heap of (distance, node) tuples for</span>
<span class="gi">+    # extracting next node to expand</span>
<span class="gi">+    seen = [{source: 0}, {target: 0}]  # dictionary of distances to</span>
<span class="gi">+    # nodes seen</span>
<span class="gi">+    c = count()</span>
<span class="gi">+    # initialize fringe heap</span>
<span class="gi">+    push(fringe[0], (0, next(c), source))</span>
<span class="gi">+    push(fringe[1], (0, next(c), target))</span>
<span class="gi">+    # neighs for extracting correct neighbor information</span>
<span class="gi">+    neighs = [Gsucc, Gpred]</span>
<span class="gi">+    # variables to hold shortest discovered path</span>
<span class="gi">+    # finaldist = 1e30000</span>
<span class="gi">+    finalpath = []</span>
<span class="gi">+    dir = 1</span>
<span class="gi">+    while fringe[0] and fringe[1]:</span>
<span class="gi">+        # choose direction</span>
<span class="gi">+        # dir == 0 is forward direction and dir == 1 is back</span>
<span class="gi">+        dir = 1 - dir</span>
<span class="gi">+        # extract closest to expand</span>
<span class="gi">+        (dist, _, v) = pop(fringe[dir])</span>
<span class="gi">+        if v in dists[dir]:</span>
<span class="gi">+            # Shortest path to v has already been found</span>
<span class="gi">+            continue</span>
<span class="gi">+        # update distance</span>
<span class="gi">+        dists[dir][v] = dist  # equal to seen[dir][v]</span>
<span class="gi">+        if v in dists[1 - dir]:</span>
<span class="gi">+            # if we have scanned v in both directions we are done</span>
<span class="gi">+            # we have now discovered the shortest path</span>
<span class="gi">+            return (finaldist, finalpath)</span>
<span class="gi">+</span>
<span class="gi">+        wt = _weight_function(G, weight)</span>
<span class="gi">+        for w in neighs[dir](v):</span>
<span class="gi">+            if dir == 0:  # forward</span>
<span class="gi">+                minweight = wt(v, w, G.get_edge_data(v, w))</span>
<span class="gi">+                vwLength = dists[dir][v] + minweight</span>
<span class="gi">+            else:  # back, must remember to change v,w-&gt;w,v</span>
<span class="gi">+                minweight = wt(w, v, G.get_edge_data(w, v))</span>
<span class="gi">+                vwLength = dists[dir][v] + minweight</span>
<span class="gi">+</span>
<span class="gi">+            if w in dists[dir]:</span>
<span class="gi">+                if vwLength &lt; dists[dir][w]:</span>
<span class="gi">+                    raise ValueError(&quot;Contradictory paths found: negative weights?&quot;)</span>
<span class="gi">+            elif w not in seen[dir] or vwLength &lt; seen[dir][w]:</span>
<span class="gi">+                # relaxing</span>
<span class="gi">+                seen[dir][w] = vwLength</span>
<span class="gi">+                push(fringe[dir], (vwLength, next(c), w))</span>
<span class="gi">+                paths[dir][w] = paths[dir][v] + [w]</span>
<span class="gi">+                if w in seen[0] and w in seen[1]:</span>
<span class="gi">+                    # see if this path is better than the already</span>
<span class="gi">+                    # discovered shortest path</span>
<span class="gi">+                    totaldist = seen[0][w] + seen[1][w]</span>
<span class="gi">+                    if finalpath == [] or finaldist &gt; totaldist:</span>
<span class="gi">+                        finaldist = totaldist</span>
<span class="gi">+                        revpath = paths[1][w][:]</span>
<span class="gi">+                        revpath.reverse()</span>
<span class="gi">+                        finalpath = paths[0][w] + revpath[1:]</span>
<span class="gi">+    raise nx.NetworkXNoPath(f&quot;No path between {source} and {target}.&quot;)</span>
<span class="gh">diff --git a/networkx/algorithms/smallworld.py b/networkx/algorithms/smallworld.py</span>
<span class="gh">index d916d5515..05ae17082 100644</span>
<span class="gd">--- a/networkx/algorithms/smallworld.py</span>
<span class="gi">+++ b/networkx/algorithms/smallworld.py</span>
<span class="gu">@@ -16,11 +16,12 @@ For more information, see the Wikipedia article on small-world network [1]_.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;random_reference&#39;, &#39;lattice_reference&#39;, &#39;sigma&#39;, &#39;omega&#39;]</span>

<span class="gi">+__all__ = [&quot;random_reference&quot;, &quot;lattice_reference&quot;, &quot;sigma&quot;, &quot;omega&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@py_random_state(3)
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def random_reference(G, niter=1, connectivity=True, seed=None):
<span class="gu">@@ -62,11 +63,63 @@ def random_reference(G, niter=1, connectivity=True, seed=None):</span>
<span class="w"> </span>           &quot;Specificity and stability in topology of protein networks.&quot;
<span class="w"> </span>           Science 296.5569 (2002): 910-913.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    if len(G) &lt; 4:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph has fewer than four nodes.&quot;)</span>
<span class="gi">+    if len(G.edges) &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph has fewer that 2 edges&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    from networkx.utils import cumulative_distribution, discrete_sequence</span>
<span class="gi">+</span>
<span class="gi">+    local_conn = nx.connectivity.local_edge_connectivity</span>
<span class="gi">+</span>
<span class="gi">+    G = G.copy()</span>
<span class="gi">+    keys, degrees = zip(*G.degree())  # keys, degree</span>
<span class="gi">+    cdf = cumulative_distribution(degrees)  # cdf of degree</span>
<span class="gi">+    nnodes = len(G)</span>
<span class="gi">+    nedges = nx.number_of_edges(G)</span>
<span class="gi">+    niter = niter * nedges</span>
<span class="gi">+    ntries = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))</span>
<span class="gi">+    swapcount = 0</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(niter):</span>
<span class="gi">+        n = 0</span>
<span class="gi">+        while n &lt; ntries:</span>
<span class="gi">+            # pick two random edges without creating edge list</span>
<span class="gi">+            # choose source node indices from discrete distribution</span>
<span class="gi">+            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)</span>
<span class="gi">+            if ai == ci:</span>
<span class="gi">+                continue  # same source, skip</span>
<span class="gi">+            a = keys[ai]  # convert index to label</span>
<span class="gi">+            c = keys[ci]</span>
<span class="gi">+            # choose target uniformly from neighbors</span>
<span class="gi">+            b = seed.choice(list(G.neighbors(a)))</span>
<span class="gi">+            d = seed.choice(list(G.neighbors(c)))</span>
<span class="gi">+            if b in [a, c, d] or d in [a, b, c]:</span>
<span class="gi">+                continue  # all vertices should be different</span>
<span class="gi">+</span>
<span class="gi">+            # don&#39;t create parallel edges</span>
<span class="gi">+            if (d not in G[a]) and (b not in G[c]):</span>
<span class="gi">+                G.add_edge(a, d)</span>
<span class="gi">+                G.add_edge(c, b)</span>
<span class="gi">+                G.remove_edge(a, b)</span>
<span class="gi">+                G.remove_edge(c, d)</span>
<span class="gi">+</span>
<span class="gi">+                # Check if the graph is still connected</span>
<span class="gi">+                if connectivity and local_conn(G, a, b) == 0:</span>
<span class="gi">+                    # Not connected, revert the swap</span>
<span class="gi">+                    G.remove_edge(a, d)</span>
<span class="gi">+                    G.remove_edge(c, b)</span>
<span class="gi">+                    G.add_edge(a, b)</span>
<span class="gi">+                    G.add_edge(c, d)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    swapcount += 1</span>
<span class="gi">+                    break</span>
<span class="gi">+            n += 1</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@py_random_state(4)
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def lattice_reference(G, niter=5, D=None, connectivity=True, seed=None):
<span class="gu">@@ -114,11 +167,83 @@ def lattice_reference(G, niter=5, D=None, connectivity=True, seed=None):</span>
<span class="w"> </span>       &quot;Specificity and stability in topology of protein networks.&quot;
<span class="w"> </span>       Science 296.5569 (2002): 910-913.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    from networkx.utils import cumulative_distribution, discrete_sequence</span>
<span class="gi">+</span>
<span class="gi">+    local_conn = nx.connectivity.local_edge_connectivity</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) &lt; 4:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph has fewer than four nodes.&quot;)</span>
<span class="gi">+    if len(G.edges) &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph has fewer that 2 edges&quot;)</span>
<span class="gi">+    # Instead of choosing uniformly at random from a generated edge list,</span>
<span class="gi">+    # this algorithm chooses nonuniformly from the set of nodes with</span>
<span class="gi">+    # probability weighted by degree.</span>
<span class="gi">+    G = G.copy()</span>
<span class="gi">+    keys, degrees = zip(*G.degree())  # keys, degree</span>
<span class="gi">+    cdf = cumulative_distribution(degrees)  # cdf of degree</span>
<span class="gi">+</span>
<span class="gi">+    nnodes = len(G)</span>
<span class="gi">+    nedges = nx.number_of_edges(G)</span>
<span class="gi">+    if D is None:</span>
<span class="gi">+        D = np.zeros((nnodes, nnodes))</span>
<span class="gi">+        un = np.arange(1, nnodes)</span>
<span class="gi">+        um = np.arange(nnodes - 1, 0, -1)</span>
<span class="gi">+        u = np.append((0,), np.where(un &lt; um, un, um))</span>
<span class="gi">+</span>
<span class="gi">+        for v in range(int(np.ceil(nnodes / 2))):</span>
<span class="gi">+            D[nnodes - v - 1, :] = np.append(u[v + 1 :], u[: v + 1])</span>
<span class="gi">+            D[v, :] = D[nnodes - v - 1, :][::-1]</span>
<span class="gi">+</span>
<span class="gi">+    niter = niter * nedges</span>
<span class="gi">+    # maximal number of rewiring attempts per &#39;niter&#39;</span>
<span class="gi">+    max_attempts = int(nnodes * nedges / (nnodes * (nnodes - 1) / 2))</span>
<span class="gi">+</span>
<span class="gi">+    for _ in range(niter):</span>
<span class="gi">+        n = 0</span>
<span class="gi">+        while n &lt; max_attempts:</span>
<span class="gi">+            # pick two random edges without creating edge list</span>
<span class="gi">+            # choose source node indices from discrete distribution</span>
<span class="gi">+            (ai, ci) = discrete_sequence(2, cdistribution=cdf, seed=seed)</span>
<span class="gi">+            if ai == ci:</span>
<span class="gi">+                continue  # same source, skip</span>
<span class="gi">+            a = keys[ai]  # convert index to label</span>
<span class="gi">+            c = keys[ci]</span>
<span class="gi">+            # choose target uniformly from neighbors</span>
<span class="gi">+            b = seed.choice(list(G.neighbors(a)))</span>
<span class="gi">+            d = seed.choice(list(G.neighbors(c)))</span>
<span class="gi">+            bi = keys.index(b)</span>
<span class="gi">+            di = keys.index(d)</span>
<span class="gi">+</span>
<span class="gi">+            if b in [a, c, d] or d in [a, b, c]:</span>
<span class="gi">+                continue  # all vertices should be different</span>
<span class="gi">+</span>
<span class="gi">+            # don&#39;t create parallel edges</span>
<span class="gi">+            if (d not in G[a]) and (b not in G[c]):</span>
<span class="gi">+                if D[ai, bi] + D[ci, di] &gt;= D[ai, ci] + D[bi, di]:</span>
<span class="gi">+                    # only swap if we get closer to the diagonal</span>
<span class="gi">+                    G.add_edge(a, d)</span>
<span class="gi">+                    G.add_edge(c, b)</span>
<span class="gi">+                    G.remove_edge(a, b)</span>
<span class="gi">+                    G.remove_edge(c, d)</span>
<span class="gi">+</span>
<span class="gi">+                    # Check if the graph is still connected</span>
<span class="gi">+                    if connectivity and local_conn(G, a, b) == 0:</span>
<span class="gi">+                        # Not connected, revert the swap</span>
<span class="gi">+                        G.remove_edge(a, d)</span>
<span class="gi">+                        G.remove_edge(c, b)</span>
<span class="gi">+                        G.add_edge(a, b)</span>
<span class="gi">+                        G.add_edge(c, d)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        break</span>
<span class="gi">+            n += 1</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@py_random_state(3)
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def sigma(G, niter=100, nrand=10, seed=None):
<span class="gu">@@ -166,11 +291,28 @@ def sigma(G, niter=100, nrand=10, seed=None):</span>
<span class="w"> </span>           Canonical Network Equivalence&quot;.
<span class="w"> </span>           PLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    # Compute the mean clustering coefficient and average shortest path length</span>
<span class="gi">+    # for an equivalent random graph</span>
<span class="gi">+    randMetrics = {&quot;C&quot;: [], &quot;L&quot;: []}</span>
<span class="gi">+    for i in range(nrand):</span>
<span class="gi">+        Gr = random_reference(G, niter=niter, seed=seed)</span>
<span class="gi">+        randMetrics[&quot;C&quot;].append(nx.transitivity(Gr))</span>
<span class="gi">+        randMetrics[&quot;L&quot;].append(nx.average_shortest_path_length(Gr))</span>
<span class="gi">+</span>
<span class="gi">+    C = nx.transitivity(G)</span>
<span class="gi">+    L = nx.average_shortest_path_length(G)</span>
<span class="gi">+    Cr = np.mean(randMetrics[&quot;C&quot;])</span>
<span class="gi">+    Lr = np.mean(randMetrics[&quot;L&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    sigma = (C / Cr) / (L / Lr)</span>
<span class="gi">+</span>
<span class="gi">+    return float(sigma)</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@py_random_state(3)
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def omega(G, niter=5, nrand=10, seed=None):
<span class="gu">@@ -224,4 +366,38 @@ def omega(G, niter=5, nrand=10, seed=None):</span>
<span class="w"> </span>           Brain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.
<span class="w"> </span>           doi:10.1089/brain.2011.0038.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    # Compute the mean clustering coefficient and average shortest path length</span>
<span class="gi">+    # for an equivalent random graph</span>
<span class="gi">+    randMetrics = {&quot;C&quot;: [], &quot;L&quot;: []}</span>
<span class="gi">+</span>
<span class="gi">+    # Calculate initial average clustering coefficient which potentially will</span>
<span class="gi">+    # get replaced by higher clustering coefficients from generated lattice</span>
<span class="gi">+    # reference graphs</span>
<span class="gi">+    Cl = nx.average_clustering(G)</span>
<span class="gi">+</span>
<span class="gi">+    niter_lattice_reference = niter</span>
<span class="gi">+    niter_random_reference = niter * 2</span>
<span class="gi">+</span>
<span class="gi">+    for _ in range(nrand):</span>
<span class="gi">+        # Generate random graph</span>
<span class="gi">+        Gr = random_reference(G, niter=niter_random_reference, seed=seed)</span>
<span class="gi">+        randMetrics[&quot;L&quot;].append(nx.average_shortest_path_length(Gr))</span>
<span class="gi">+</span>
<span class="gi">+        # Generate lattice graph</span>
<span class="gi">+        Gl = lattice_reference(G, niter=niter_lattice_reference, seed=seed)</span>
<span class="gi">+</span>
<span class="gi">+        # Replace old clustering coefficient, if clustering is higher in</span>
<span class="gi">+        # generated lattice reference</span>
<span class="gi">+        Cl_temp = nx.average_clustering(Gl)</span>
<span class="gi">+        if Cl_temp &gt; Cl:</span>
<span class="gi">+            Cl = Cl_temp</span>
<span class="gi">+</span>
<span class="gi">+    C = nx.average_clustering(G)</span>
<span class="gi">+    L = nx.average_shortest_path_length(G)</span>
<span class="gi">+    Lr = np.mean(randMetrics[&quot;L&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    omega = (Lr / L) - (C / Cl)</span>
<span class="gi">+</span>
<span class="gi">+    return float(omega)</span>
<span class="gh">diff --git a/networkx/algorithms/smetric.py b/networkx/algorithms/smetric.py</span>
<span class="gh">index a94fa7d50..5a27014ee 100644</span>
<span class="gd">--- a/networkx/algorithms/smetric.py</span>
<span class="gi">+++ b/networkx/algorithms/smetric.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;s_metric&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;s_metric&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -33,4 +34,27 @@ def s_metric(G, **kwargs):</span>
<span class="w"> </span>           Definition, Properties, and  Implications (Extended Version), 2005.
<span class="w"> </span>           https://arxiv.org/abs/cond-mat/0501169
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # NOTE: This entire code block + the **kwargs in the signature can all be</span>
<span class="gi">+    # removed when the deprecation expires.</span>
<span class="gi">+    # Normalized is always False, since all `normalized=True` did was raise</span>
<span class="gi">+    # a NotImplementedError</span>
<span class="gi">+    if kwargs:</span>
<span class="gi">+        # Warn for `normalize`, raise for any other kwarg</span>
<span class="gi">+        if &quot;normalized&quot; in kwargs:</span>
<span class="gi">+            import warnings</span>
<span class="gi">+</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &quot;\n\nThe `normalized` keyword is deprecated and will be removed\n&quot;</span>
<span class="gi">+                &quot;in the future. To silence this warning, remove `normalized`\n&quot;</span>
<span class="gi">+                &quot;when calling `s_metric`.\n\n&quot;</span>
<span class="gi">+                &quot;The value of `normalized` is ignored.&quot;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=3,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Typical raising behavior for Python when kwarg not recognized</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&quot;s_metric got an unexpected keyword argument &#39;{list(kwargs.keys())[0]}&#39;&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    return float(sum(G.degree(u) * G.degree(v) for (u, v) in G.edges()))</span>
<span class="gh">diff --git a/networkx/algorithms/sparsifiers.py b/networkx/algorithms/sparsifiers.py</span>
<span class="gh">index 49426f9d8..870b7ba6f 100644</span>
<span class="gd">--- a/networkx/algorithms/sparsifiers.py</span>
<span class="gi">+++ b/networkx/algorithms/sparsifiers.py</span>
<span class="gu">@@ -1,14 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing sparsifiers of graphs.&quot;&quot;&quot;
<span class="w"> </span>import math
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;spanner&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;spanner&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@py_random_state(3)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, returns_graph=True)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, returns_graph=True)</span>
<span class="w"> </span>def spanner(G, stretch, weight=None, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a spanner of the given graph with the given stretch.

<span class="gu">@@ -61,7 +63,127 @@ def spanner(G, stretch, weight=None, seed=None):</span>
<span class="w"> </span>    Algorithm for Computing Sparse Spanners in Weighted Graphs.
<span class="w"> </span>    Random Struct. Algorithms 30(4): 532-563 (2007).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if stretch &lt; 1:</span>
<span class="gi">+        raise ValueError(&quot;stretch must be at least 1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    k = (stretch + 1) // 2</span>
<span class="gi">+</span>
<span class="gi">+    # initialize spanner H with empty edge set</span>
<span class="gi">+    H = nx.empty_graph()</span>
<span class="gi">+    H.add_nodes_from(G.nodes)</span>
<span class="gi">+</span>
<span class="gi">+    # phase 1: forming the clusters</span>
<span class="gi">+    # the residual graph has V&#39; from the paper as its node set</span>
<span class="gi">+    # and E&#39; from the paper as its edge set</span>
<span class="gi">+    residual_graph = _setup_residual_graph(G, weight)</span>
<span class="gi">+    # clustering is a dictionary that maps nodes in a cluster to the</span>
<span class="gi">+    # cluster center</span>
<span class="gi">+    clustering = {v: v for v in G.nodes}</span>
<span class="gi">+    sample_prob = math.pow(G.number_of_nodes(), -1 / k)</span>
<span class="gi">+    size_limit = 2 * math.pow(G.number_of_nodes(), 1 + 1 / k)</span>
<span class="gi">+</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while i &lt; k - 1:</span>
<span class="gi">+        # step 1: sample centers</span>
<span class="gi">+        sampled_centers = set()</span>
<span class="gi">+        for center in set(clustering.values()):</span>
<span class="gi">+            if seed.random() &lt; sample_prob:</span>
<span class="gi">+                sampled_centers.add(center)</span>
<span class="gi">+</span>
<span class="gi">+        # combined loop for steps 2 and 3</span>
<span class="gi">+        edges_to_add = set()</span>
<span class="gi">+        edges_to_remove = set()</span>
<span class="gi">+        new_clustering = {}</span>
<span class="gi">+        for v in residual_graph.nodes:</span>
<span class="gi">+            if clustering[v] in sampled_centers:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # step 2: find neighboring (sampled) clusters and</span>
<span class="gi">+            # lightest edges to them</span>
<span class="gi">+            lightest_edge_neighbor, lightest_edge_weight = _lightest_edge_dicts(</span>
<span class="gi">+                residual_graph, clustering, v</span>
<span class="gi">+            )</span>
<span class="gi">+            neighboring_sampled_centers = (</span>
<span class="gi">+                set(lightest_edge_weight.keys()) &amp; sampled_centers</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # step 3: add edges to spanner</span>
<span class="gi">+            if not neighboring_sampled_centers:</span>
<span class="gi">+                # connect to each neighboring center via lightest edge</span>
<span class="gi">+                for neighbor in lightest_edge_neighbor.values():</span>
<span class="gi">+                    edges_to_add.add((v, neighbor))</span>
<span class="gi">+                # remove all incident edges</span>
<span class="gi">+                for neighbor in residual_graph.adj[v]:</span>
<span class="gi">+                    edges_to_remove.add((v, neighbor))</span>
<span class="gi">+</span>
<span class="gi">+            else:  # there is a neighboring sampled center</span>
<span class="gi">+                closest_center = min(</span>
<span class="gi">+                    neighboring_sampled_centers, key=lightest_edge_weight.get</span>
<span class="gi">+                )</span>
<span class="gi">+                closest_center_weight = lightest_edge_weight[closest_center]</span>
<span class="gi">+                closest_center_neighbor = lightest_edge_neighbor[closest_center]</span>
<span class="gi">+</span>
<span class="gi">+                edges_to_add.add((v, closest_center_neighbor))</span>
<span class="gi">+                new_clustering[v] = closest_center</span>
<span class="gi">+</span>
<span class="gi">+                # connect to centers with edge weight less than</span>
<span class="gi">+                # closest_center_weight</span>
<span class="gi">+                for center, edge_weight in lightest_edge_weight.items():</span>
<span class="gi">+                    if edge_weight &lt; closest_center_weight:</span>
<span class="gi">+                        neighbor = lightest_edge_neighbor[center]</span>
<span class="gi">+                        edges_to_add.add((v, neighbor))</span>
<span class="gi">+</span>
<span class="gi">+                # remove edges to centers with edge weight less than</span>
<span class="gi">+                # closest_center_weight</span>
<span class="gi">+                for neighbor in residual_graph.adj[v]:</span>
<span class="gi">+                    nbr_cluster = clustering[neighbor]</span>
<span class="gi">+                    nbr_weight = lightest_edge_weight[nbr_cluster]</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        nbr_cluster == closest_center</span>
<span class="gi">+                        or nbr_weight &lt; closest_center_weight</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        edges_to_remove.add((v, neighbor))</span>
<span class="gi">+</span>
<span class="gi">+        # check whether iteration added too many edges to spanner,</span>
<span class="gi">+        # if so repeat</span>
<span class="gi">+        if len(edges_to_add) &gt; size_limit:</span>
<span class="gi">+            # an iteration is repeated O(1) times on expectation</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # iteration succeeded</span>
<span class="gi">+        i = i + 1</span>
<span class="gi">+</span>
<span class="gi">+        # actually add edges to spanner</span>
<span class="gi">+        for u, v in edges_to_add:</span>
<span class="gi">+            _add_edge_to_spanner(H, residual_graph, u, v, weight)</span>
<span class="gi">+</span>
<span class="gi">+        # actually delete edges from residual graph</span>
<span class="gi">+        residual_graph.remove_edges_from(edges_to_remove)</span>
<span class="gi">+</span>
<span class="gi">+        # copy old clustering data to new_clustering</span>
<span class="gi">+        for node, center in clustering.items():</span>
<span class="gi">+            if center in sampled_centers:</span>
<span class="gi">+                new_clustering[node] = center</span>
<span class="gi">+        clustering = new_clustering</span>
<span class="gi">+</span>
<span class="gi">+        # step 4: remove intra-cluster edges</span>
<span class="gi">+        for u in residual_graph.nodes:</span>
<span class="gi">+            for v in list(residual_graph.adj[u]):</span>
<span class="gi">+                if clustering[u] == clustering[v]:</span>
<span class="gi">+                    residual_graph.remove_edge(u, v)</span>
<span class="gi">+</span>
<span class="gi">+        # update residual graph node set</span>
<span class="gi">+        for v in list(residual_graph.nodes):</span>
<span class="gi">+            if v not in clustering:</span>
<span class="gi">+                residual_graph.remove_node(v)</span>
<span class="gi">+</span>
<span class="gi">+    # phase 2: vertex-cluster joining</span>
<span class="gi">+    for v in residual_graph.nodes:</span>
<span class="gi">+        lightest_edge_neighbor, _ = _lightest_edge_dicts(residual_graph, clustering, v)</span>
<span class="gi">+        for neighbor in lightest_edge_neighbor.values():</span>
<span class="gi">+            _add_edge_to_spanner(H, residual_graph, v, neighbor, weight)</span>
<span class="gi">+</span>
<span class="gi">+    return H</span>


<span class="w"> </span>def _setup_residual_graph(G, weight):
<span class="gu">@@ -88,7 +210,16 @@ def _setup_residual_graph(G, weight):</span>
<span class="w"> </span>    NetworkX graph
<span class="w"> </span>        The residual graph used for the Baswana-Sen algorithm.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    residual_graph = G.copy()</span>
<span class="gi">+</span>
<span class="gi">+    # establish unique edge weights, even for unweighted graphs</span>
<span class="gi">+    for u, v in G.edges():</span>
<span class="gi">+        if not weight:</span>
<span class="gi">+            residual_graph[u][v][&quot;weight&quot;] = (id(u), id(v))</span>
<span class="gi">+        else:</span>
<span class="gi">+            residual_graph[u][v][&quot;weight&quot;] = (G[u][v][weight], id(u), id(v))</span>
<span class="gi">+</span>
<span class="gi">+    return residual_graph</span>


<span class="w"> </span>def _lightest_edge_dicts(residual_graph, clustering, node):
<span class="gu">@@ -123,7 +254,18 @@ def _lightest_edge_dicts(residual_graph, clustering, node):</span>
<span class="w"> </span>    residual graph then the center of the cluster is not a key in the
<span class="w"> </span>    returned dictionaries.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lightest_edge_neighbor = {}</span>
<span class="gi">+    lightest_edge_weight = {}</span>
<span class="gi">+    for neighbor in residual_graph.adj[node]:</span>
<span class="gi">+        nbr_center = clustering[neighbor]</span>
<span class="gi">+        weight = residual_graph[node][neighbor][&quot;weight&quot;]</span>
<span class="gi">+        if (</span>
<span class="gi">+            nbr_center not in lightest_edge_weight</span>
<span class="gi">+            or weight &lt; lightest_edge_weight[nbr_center]</span>
<span class="gi">+        ):</span>
<span class="gi">+            lightest_edge_neighbor[nbr_center] = neighbor</span>
<span class="gi">+            lightest_edge_weight[nbr_center] = weight</span>
<span class="gi">+    return lightest_edge_neighbor, lightest_edge_weight</span>


<span class="w"> </span>def _add_edge_to_spanner(H, residual_graph, u, v, weight):
<span class="gu">@@ -148,4 +290,6 @@ def _add_edge_to_spanner(H, residual_graph, u, v, weight):</span>
<span class="w"> </span>    weight : object
<span class="w"> </span>        The edge attribute to use as distance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    H.add_edge(u, v)</span>
<span class="gi">+    if weight:</span>
<span class="gi">+        H[u][v][weight] = residual_graph[u][v][&quot;weight&quot;][0]</span>
<span class="gh">diff --git a/networkx/algorithms/structuralholes.py b/networkx/algorithms/structuralholes.py</span>
<span class="gh">index b7e22f07f..bae42d060 100644</span>
<span class="gd">--- a/networkx/algorithms/structuralholes.py</span>
<span class="gi">+++ b/networkx/algorithms/structuralholes.py</span>
<span class="gu">@@ -1,9 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing measures of structural holes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;constraint&#39;, &#39;local_constraint&#39;, &#39;effective_size&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;constraint&quot;, &quot;local_constraint&quot;, &quot;effective_size&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def mutual_weight(G, u, v, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the sum of the weights of the edge from `u` to `v` and
<span class="w"> </span>    the edge from `v` to `u` in `G`.
<span class="gu">@@ -15,10 +17,18 @@ def mutual_weight(G, u, v, weight=None):</span>
<span class="w"> </span>    Pre-conditions: `u` and `v` must both be in `G`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        a_uv = G[u][v].get(weight, 1)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        a_uv = 0</span>
<span class="gi">+    try:</span>
<span class="gi">+        a_vu = G[v][u].get(weight, 1)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        a_vu = 0</span>
<span class="gi">+    return a_uv + a_vu</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def normalized_mutual_weight(G, u, v, norm=sum, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns normalized mutual weight of the edges from `u` to `v`
<span class="w"> </span>    with respect to the mutual weights of the neighbors of `u` in `G`.
<span class="gu">@@ -35,12 +45,13 @@ def normalized_mutual_weight(G, u, v, norm=sum, weight=None):</span>
<span class="w"> </span>    attribute used as weight.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scale = norm(mutual_weight(G, u, w, weight) for w in set(nx.all_neighbors(G, u)))</span>
<span class="gi">+    return 0 if scale == 0 else mutual_weight(G, u, v, weight) / scale</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def effective_size(G, nodes=None, weight=None):
<span class="gd">-    &quot;&quot;&quot;Returns the effective size of all nodes in the graph ``G``.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the effective size of all nodes in the graph ``G``.</span>

<span class="w"> </span>    The *effective size* of a node&#39;s ego network is based on the concept
<span class="w"> </span>    of redundancy. A person&#39;s ego network has redundancy to the extent
<span class="gu">@@ -51,8 +62,8 @@ def effective_size(G, nodes=None, weight=None):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       e(u) = \\sum_{v \\in N(u) \\setminus \\{u\\}}</span>
<span class="gd">-       \\left(1 - \\sum_{w \\in N(v)} p_{uw} m_{vw}\\right)</span>
<span class="gi">+       e(u) = \sum_{v \in N(u) \setminus \{u\}}</span>
<span class="gi">+       \left(1 - \sum_{w \in N(v)} p_{uw} m_{vw}\right)</span>

<span class="w"> </span>    where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the
<span class="w"> </span>    normalized mutual weight of the (directed or undirected) edges
<span class="gu">@@ -67,7 +78,7 @@ def effective_size(G, nodes=None, weight=None):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       e(u) = n - \\frac{2t}{n}</span>
<span class="gi">+       e(u) = n - \frac{2t}{n}</span>

<span class="w"> </span>    where `t` is the number of ties in the ego network (not including
<span class="w"> </span>    ties to ego) and `n` is the number of nodes (excluding ego).
<span class="gu">@@ -118,12 +129,42 @@ def effective_size(G, nodes=None, weight=None):</span>
<span class="w"> </span>           http://www.analytictech.com/connections/v20(1)/holes.htm

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    def redundancy(G, u, v, weight=None):</span>
<span class="gi">+        nmw = normalized_mutual_weight</span>
<span class="gi">+        r = sum(</span>
<span class="gi">+            nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight)</span>
<span class="gi">+            for w in set(nx.all_neighbors(G, u))</span>
<span class="gi">+        )</span>
<span class="gi">+        return 1 - r</span>
<span class="gi">+</span>
<span class="gi">+    effective_size = {}</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = G</span>
<span class="gi">+    # Use Borgatti&#39;s simplified formula for unweighted and undirected graphs</span>
<span class="gi">+    if not G.is_directed() and weight is None:</span>
<span class="gi">+        for v in nodes:</span>
<span class="gi">+            # Effective size is not defined for isolated nodes</span>
<span class="gi">+            if len(G[v]) == 0:</span>
<span class="gi">+                effective_size[v] = float(&quot;nan&quot;)</span>
<span class="gi">+                continue</span>
<span class="gi">+            E = nx.ego_graph(G, v, center=False, undirected=True)</span>
<span class="gi">+            effective_size[v] = len(E) - (2 * E.size()) / len(E)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for v in nodes:</span>
<span class="gi">+            # Effective size is not defined for isolated nodes</span>
<span class="gi">+            if len(G[v]) == 0:</span>
<span class="gi">+                effective_size[v] = float(&quot;nan&quot;)</span>
<span class="gi">+                continue</span>
<span class="gi">+            effective_size[v] = sum(</span>
<span class="gi">+                redundancy(G, v, u, weight) for u in set(nx.all_neighbors(G, v))</span>
<span class="gi">+            )</span>
<span class="gi">+    return effective_size</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def constraint(G, nodes=None, weight=None):
<span class="gd">-    &quot;&quot;&quot;Returns the constraint on all nodes in the graph ``G``.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the constraint on all nodes in the graph ``G``.</span>

<span class="w"> </span>    The *constraint* is a measure of the extent to which a node *v* is
<span class="w"> </span>    invested in those nodes that are themselves invested in the
<span class="gu">@@ -132,10 +173,10 @@ def constraint(G, nodes=None, weight=None):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       c(v) = \\sum_{w \\in N(v) \\setminus \\{v\\}} \\ell(v, w)</span>
<span class="gi">+       c(v) = \sum_{w \in N(v) \setminus \{v\}} \ell(v, w)</span>

<span class="w"> </span>    where $N(v)$ is the subset of the neighbors of `v` that are either
<span class="gd">-    predecessors or successors of `v` and $\\ell(v, w)$ is the local</span>
<span class="gi">+    predecessors or successors of `v` and $\ell(v, w)$ is the local</span>
<span class="w"> </span>    constraint on `v` with respect to `w` [1]_. For the definition of local
<span class="w"> </span>    constraint, see :func:`local_constraint`.

<span class="gu">@@ -168,20 +209,31 @@ def constraint(G, nodes=None, weight=None):</span>
<span class="w"> </span>           American Journal of Sociology (110): 349–399.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    if nodes is None:</span>
<span class="gi">+        nodes = G</span>
<span class="gi">+    constraint = {}</span>
<span class="gi">+    for v in nodes:</span>
<span class="gi">+        # Constraint is not defined for isolated nodes</span>
<span class="gi">+        if len(G[v]) == 0:</span>
<span class="gi">+            constraint[v] = float(&quot;nan&quot;)</span>
<span class="gi">+            continue</span>
<span class="gi">+        constraint[v] = sum(</span>
<span class="gi">+            local_constraint(G, v, n, weight) for n in set(nx.all_neighbors(G, v))</span>
<span class="gi">+        )</span>
<span class="gi">+    return constraint</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def local_constraint(G, u, v, weight=None):
<span class="gd">-    &quot;&quot;&quot;Returns the local constraint on the node ``u`` with respect to</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the local constraint on the node ``u`` with respect to</span>
<span class="w"> </span>    the node ``v`` in the graph ``G``.

<span class="w"> </span>    Formally, the *local constraint on u with respect to v*, denoted
<span class="gd">-    $\\ell(u, v)$, is defined by</span>
<span class="gi">+    $\ell(u, v)$, is defined by</span>

<span class="w"> </span>    .. math::

<span class="gd">-       \\ell(u, v) = \\left(p_{uv} + \\sum_{w \\in N(v)} p_{uw} p_{wv}\\right)^2,</span>
<span class="gi">+       \ell(u, v) = \left(p_{uv} + \sum_{w \in N(v)} p_{uw} p_{wv}\right)^2,</span>

<span class="w"> </span>    where $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the
<span class="w"> </span>    normalized mutual weight of the (directed or undirected) edges
<span class="gu">@@ -222,4 +274,10 @@ def local_constraint(G, u, v, weight=None):</span>
<span class="w"> </span>           American Journal of Sociology (110): 349–399.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nmw = normalized_mutual_weight</span>
<span class="gi">+    direct = nmw(G, u, v, weight=weight)</span>
<span class="gi">+    indirect = sum(</span>
<span class="gi">+        nmw(G, u, w, weight=weight) * nmw(G, w, v, weight=weight)</span>
<span class="gi">+        for w in set(nx.all_neighbors(G, u))</span>
<span class="gi">+    )</span>
<span class="gi">+    return (direct + indirect) ** 2</span>
<span class="gh">diff --git a/networkx/algorithms/summarization.py b/networkx/algorithms/summarization.py</span>
<span class="gh">index c37617f80..794a77ab3 100644</span>
<span class="gd">--- a/networkx/algorithms/summarization.py</span>
<span class="gi">+++ b/networkx/algorithms/summarization.py</span>
<span class="gu">@@ -59,11 +59,13 @@ For more information on graph summarization, see `Graph Summarization Methods</span>
<span class="w"> </span>and Applications: A Survey &lt;https://dl.acm.org/doi/abs/10.1145/3186727&gt;`_
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections import Counter, defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;dedensify&#39;, &#39;snap_aggregation&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;dedensify&quot;, &quot;snap_aggregation&quot;]</span>


<span class="gd">-@nx._dispatchable(mutates_input={&#39;not copy&#39;: 3}, returns_graph=True)</span>
<span class="gi">+@nx._dispatchable(mutates_input={&quot;not copy&quot;: 3}, returns_graph=True)</span>
<span class="w"> </span>def dedensify(G, threshold, prefix=None, copy=True):
<span class="w"> </span>    &quot;&quot;&quot;Compresses neighborhoods around high-degree nodes

<span class="gu">@@ -168,12 +170,60 @@ def dedensify(G, threshold, prefix=None, copy=True):</span>
<span class="w"> </span>       Knowledge Discovery and Data Mining (pp. 1755-1764).
<span class="w"> </span>       http://www.cs.umd.edu/~abadi/papers/graph-dedense.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _snap_build_graph(G, groups, node_attributes, edge_attributes,</span>
<span class="gd">-    neighbor_info, edge_types, prefix, supernode_attribute, superedge_attribute</span>
<span class="gd">-    ):</span>
<span class="gi">+    if threshold &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;The degree threshold must be &gt;= 2&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    degrees = G.in_degree if G.is_directed() else G.degree</span>
<span class="gi">+    # Group nodes based on degree threshold</span>
<span class="gi">+    high_degree_nodes = {n for n, d in degrees if d &gt; threshold}</span>
<span class="gi">+    low_degree_nodes = G.nodes() - high_degree_nodes</span>
<span class="gi">+</span>
<span class="gi">+    auxiliary = {}</span>
<span class="gi">+    for node in G:</span>
<span class="gi">+        high_degree_nbrs = frozenset(high_degree_nodes &amp; set(G[node]))</span>
<span class="gi">+        if high_degree_nbrs:</span>
<span class="gi">+            if high_degree_nbrs in auxiliary:</span>
<span class="gi">+                auxiliary[high_degree_nbrs].add(node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                auxiliary[high_degree_nbrs] = {node}</span>
<span class="gi">+</span>
<span class="gi">+    if copy:</span>
<span class="gi">+        G = G.copy()</span>
<span class="gi">+</span>
<span class="gi">+    compressor_nodes = set()</span>
<span class="gi">+    for index, (high_degree_nodes, low_degree_nodes) in enumerate(auxiliary.items()):</span>
<span class="gi">+        low_degree_node_count = len(low_degree_nodes)</span>
<span class="gi">+        high_degree_node_count = len(high_degree_nodes)</span>
<span class="gi">+        old_edges = high_degree_node_count * low_degree_node_count</span>
<span class="gi">+        new_edges = high_degree_node_count + low_degree_node_count</span>
<span class="gi">+        if old_edges &lt;= new_edges:</span>
<span class="gi">+            continue</span>
<span class="gi">+        compression_node = &quot;&quot;.join(str(node) for node in high_degree_nodes)</span>
<span class="gi">+        if prefix:</span>
<span class="gi">+            compression_node = str(prefix) + compression_node</span>
<span class="gi">+        for node in low_degree_nodes:</span>
<span class="gi">+            for high_node in high_degree_nodes:</span>
<span class="gi">+                if G.has_edge(node, high_node):</span>
<span class="gi">+                    G.remove_edge(node, high_node)</span>
<span class="gi">+</span>
<span class="gi">+            G.add_edge(node, compression_node)</span>
<span class="gi">+        for node in high_degree_nodes:</span>
<span class="gi">+            G.add_edge(compression_node, node)</span>
<span class="gi">+        compressor_nodes.add(compression_node)</span>
<span class="gi">+    return G, compressor_nodes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _snap_build_graph(</span>
<span class="gi">+    G,</span>
<span class="gi">+    groups,</span>
<span class="gi">+    node_attributes,</span>
<span class="gi">+    edge_attributes,</span>
<span class="gi">+    neighbor_info,</span>
<span class="gi">+    edge_types,</span>
<span class="gi">+    prefix,</span>
<span class="gi">+    supernode_attribute,</span>
<span class="gi">+    superedge_attribute,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Build the summary graph from the data structures produced in the SNAP aggregation algorithm

<span class="gu">@@ -209,7 +259,48 @@ def _snap_build_graph(G, groups, node_attributes, edge_attributes,</span>
<span class="w"> </span>    -------
<span class="w"> </span>    summary graph: Networkx graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    output = G.__class__()</span>
<span class="gi">+    node_label_lookup = {}</span>
<span class="gi">+    for index, group_id in enumerate(groups):</span>
<span class="gi">+        group_set = groups[group_id]</span>
<span class="gi">+        supernode = f&quot;{prefix}{index}&quot;</span>
<span class="gi">+        node_label_lookup[group_id] = supernode</span>
<span class="gi">+        supernode_attributes = {</span>
<span class="gi">+            attr: G.nodes[next(iter(group_set))][attr] for attr in node_attributes</span>
<span class="gi">+        }</span>
<span class="gi">+        supernode_attributes[supernode_attribute] = group_set</span>
<span class="gi">+        output.add_node(supernode, **supernode_attributes)</span>
<span class="gi">+</span>
<span class="gi">+    for group_id in groups:</span>
<span class="gi">+        group_set = groups[group_id]</span>
<span class="gi">+        source_supernode = node_label_lookup[group_id]</span>
<span class="gi">+        for other_group, group_edge_types in neighbor_info[</span>
<span class="gi">+            next(iter(group_set))</span>
<span class="gi">+        ].items():</span>
<span class="gi">+            if group_edge_types:</span>
<span class="gi">+                target_supernode = node_label_lookup[other_group]</span>
<span class="gi">+                summary_graph_edge = (source_supernode, target_supernode)</span>
<span class="gi">+</span>
<span class="gi">+                edge_types = [</span>
<span class="gi">+                    dict(zip(edge_attributes, edge_type))</span>
<span class="gi">+                    for edge_type in group_edge_types</span>
<span class="gi">+                ]</span>
<span class="gi">+</span>
<span class="gi">+                has_edge = output.has_edge(*summary_graph_edge)</span>
<span class="gi">+                if output.is_multigraph():</span>
<span class="gi">+                    if not has_edge:</span>
<span class="gi">+                        for edge_type in edge_types:</span>
<span class="gi">+                            output.add_edge(*summary_graph_edge, **edge_type)</span>
<span class="gi">+                    elif not output.is_directed():</span>
<span class="gi">+                        existing_edge_data = output.get_edge_data(*summary_graph_edge)</span>
<span class="gi">+                        for edge_type in edge_types:</span>
<span class="gi">+                            if edge_type not in existing_edge_data.values():</span>
<span class="gi">+                                output.add_edge(*summary_graph_edge, **edge_type)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    superedge_attributes = {superedge_attribute: edge_types}</span>
<span class="gi">+                    output.add_edge(*summary_graph_edge, **superedge_attributes)</span>
<span class="gi">+</span>
<span class="gi">+    return output</span>


<span class="w"> </span>def _snap_eligible_group(G, groups, group_lookup, edge_types):
<span class="gu">@@ -235,7 +326,33 @@ def _snap_eligible_group(G, groups, group_lookup, edge_types):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    tuple: group ID to split, and neighbor-groups participation_counts data structure
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nbr_info = {node: {gid: Counter() for gid in groups} for node in group_lookup}</span>
<span class="gi">+    for group_id in groups:</span>
<span class="gi">+        current_group = groups[group_id]</span>
<span class="gi">+</span>
<span class="gi">+        # build nbr_info for nodes in group</span>
<span class="gi">+        for node in current_group:</span>
<span class="gi">+            nbr_info[node] = {group_id: Counter() for group_id in groups}</span>
<span class="gi">+            edges = G.edges(node, keys=True) if G.is_multigraph() else G.edges(node)</span>
<span class="gi">+            for edge in edges:</span>
<span class="gi">+                neighbor = edge[1]</span>
<span class="gi">+                edge_type = edge_types[edge]</span>
<span class="gi">+                neighbor_group_id = group_lookup[neighbor]</span>
<span class="gi">+                nbr_info[node][neighbor_group_id][edge_type] += 1</span>
<span class="gi">+</span>
<span class="gi">+        # check if group_id is eligible to be split</span>
<span class="gi">+        group_size = len(current_group)</span>
<span class="gi">+        for other_group_id in groups:</span>
<span class="gi">+            edge_counts = Counter()</span>
<span class="gi">+            for node in current_group:</span>
<span class="gi">+                edge_counts.update(nbr_info[node][other_group_id].keys())</span>
<span class="gi">+</span>
<span class="gi">+            if not all(count == group_size for count in edge_counts.values()):</span>
<span class="gi">+                # only the nbr_info of the returned group_id is required for handling group splits</span>
<span class="gi">+                return group_id, nbr_info</span>
<span class="gi">+</span>
<span class="gi">+    # if no eligible groups, complete nbr_info is calculated</span>
<span class="gi">+    return None, nbr_info</span>


<span class="w"> </span>def _snap_split(groups, neighbor_info, group_lookup, group_id):
<span class="gu">@@ -266,13 +383,38 @@ def _snap_split(groups, neighbor_info, group_lookup, group_id):</span>
<span class="w"> </span>    dict
<span class="w"> </span>        The updated groups based on the split
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(node_attrs=&#39;[node_attributes]&#39;, edge_attrs=</span>
<span class="gd">-    &#39;[edge_attributes]&#39;, returns_graph=True)</span>
<span class="gd">-def snap_aggregation(G, node_attributes, edge_attributes=(), prefix=</span>
<span class="gd">-    &#39;Supernode-&#39;, supernode_attribute=&#39;group&#39;, superedge_attribute=&#39;types&#39;):</span>
<span class="gi">+    new_group_mappings = defaultdict(set)</span>
<span class="gi">+    for node in groups[group_id]:</span>
<span class="gi">+        signature = tuple(</span>
<span class="gi">+            frozenset(edge_types) for edge_types in neighbor_info[node].values()</span>
<span class="gi">+        )</span>
<span class="gi">+        new_group_mappings[signature].add(node)</span>
<span class="gi">+</span>
<span class="gi">+    # leave the biggest new_group as the original group</span>
<span class="gi">+    new_groups = sorted(new_group_mappings.values(), key=len)</span>
<span class="gi">+    for new_group in new_groups[:-1]:</span>
<span class="gi">+        # Assign unused integer as the new_group_id</span>
<span class="gi">+        # ids are tuples, so will not interact with the original group_ids</span>
<span class="gi">+        new_group_id = len(groups)</span>
<span class="gi">+        groups[new_group_id] = new_group</span>
<span class="gi">+        groups[group_id] -= new_group</span>
<span class="gi">+        for node in new_group:</span>
<span class="gi">+            group_lookup[node] = new_group_id</span>
<span class="gi">+</span>
<span class="gi">+    return groups</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    node_attrs=&quot;[node_attributes]&quot;, edge_attrs=&quot;[edge_attributes]&quot;, returns_graph=True</span>
<span class="gi">+)</span>
<span class="gi">+def snap_aggregation(</span>
<span class="gi">+    G,</span>
<span class="gi">+    node_attributes,</span>
<span class="gi">+    edge_attributes=(),</span>
<span class="gi">+    prefix=&quot;Supernode-&quot;,</span>
<span class="gi">+    supernode_attribute=&quot;group&quot;,</span>
<span class="gi">+    superedge_attribute=&quot;types&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Creates a summary graph based on attributes and connectivity.

<span class="w"> </span>    This function uses the Summarization by Grouping Nodes on Attributes
<span class="gu">@@ -379,4 +521,43 @@ def snap_aggregation(G, node_attributes, edge_attributes=(), prefix=</span>
<span class="w"> </span>       Management of Data (SIGMOD’08), pages 567–580, Vancouver, Canada,
<span class="w"> </span>       June 2008.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edge_types = {</span>
<span class="gi">+        edge: tuple(attrs.get(attr) for attr in edge_attributes)</span>
<span class="gi">+        for edge, attrs in G.edges.items()</span>
<span class="gi">+    }</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            # list is needed to avoid mutating while iterating</span>
<span class="gi">+            edges = [((v, u, k), etype) for (u, v, k), etype in edge_types.items()]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # list is needed to avoid mutating while iterating</span>
<span class="gi">+            edges = [((v, u), etype) for (u, v), etype in edge_types.items()]</span>
<span class="gi">+        edge_types.update(edges)</span>
<span class="gi">+</span>
<span class="gi">+    group_lookup = {</span>
<span class="gi">+        node: tuple(attrs[attr] for attr in node_attributes)</span>
<span class="gi">+        for node, attrs in G.nodes.items()</span>
<span class="gi">+    }</span>
<span class="gi">+    groups = defaultdict(set)</span>
<span class="gi">+    for node, node_type in group_lookup.items():</span>
<span class="gi">+        groups[node_type].add(node)</span>
<span class="gi">+</span>
<span class="gi">+    eligible_group_id, nbr_info = _snap_eligible_group(</span>
<span class="gi">+        G, groups, group_lookup, edge_types</span>
<span class="gi">+    )</span>
<span class="gi">+    while eligible_group_id:</span>
<span class="gi">+        groups = _snap_split(groups, nbr_info, group_lookup, eligible_group_id)</span>
<span class="gi">+        eligible_group_id, nbr_info = _snap_eligible_group(</span>
<span class="gi">+            G, groups, group_lookup, edge_types</span>
<span class="gi">+        )</span>
<span class="gi">+    return _snap_build_graph(</span>
<span class="gi">+        G,</span>
<span class="gi">+        groups,</span>
<span class="gi">+        node_attributes,</span>
<span class="gi">+        edge_attributes,</span>
<span class="gi">+        nbr_info,</span>
<span class="gi">+        edge_types,</span>
<span class="gi">+        prefix,</span>
<span class="gi">+        supernode_attribute,</span>
<span class="gi">+        superedge_attribute,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/networkx/algorithms/swap.py b/networkx/algorithms/swap.py</span>
<span class="gh">index 2df913522..c190f970b 100644</span>
<span class="gd">--- a/networkx/algorithms/swap.py</span>
<span class="gi">+++ b/networkx/algorithms/swap.py</span>
<span class="gu">@@ -1,13 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Swap edges in a graph.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;double_edge_swap&#39;, &#39;connected_double_edge_swap&#39;,</span>
<span class="gd">-    &#39;directed_edge_swap&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;double_edge_swap&quot;, &quot;connected_double_edge_swap&quot;, &quot;directed_edge_swap&quot;]</span>


<span class="gd">-@nx.utils.not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@py_random_state(3)
<span class="w"> </span>@nx._dispatchable(mutates_input=True, returns_graph=True)
<span class="w"> </span>def directed_edge_swap(G, *, nswap=1, max_tries=100, seed=None):
<span class="gu">@@ -68,7 +70,66 @@ def directed_edge_swap(G, *, nswap=1, max_tries=100, seed=None):</span>
<span class="w"> </span>           Degree Sequence with 2-Edge Swaps.” Mathematics Stack Exchange,
<span class="w"> </span>           https://math.stackexchange.com/questions/22272/. Accessed 30 May 2022.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nswap &gt; max_tries:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Number of swaps &gt; number of tries allowed.&quot;)</span>
<span class="gi">+    if len(G) &lt; 4:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;DiGraph has fewer than four nodes.&quot;)</span>
<span class="gi">+    if len(G.edges) &lt; 3:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;DiGraph has fewer than 3 edges&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Instead of choosing uniformly at random from a generated edge list,</span>
<span class="gi">+    # this algorithm chooses nonuniformly from the set of nodes with</span>
<span class="gi">+    # probability weighted by degree.</span>
<span class="gi">+    tries = 0</span>
<span class="gi">+    swapcount = 0</span>
<span class="gi">+    keys, degrees = zip(*G.degree())  # keys, degree</span>
<span class="gi">+    cdf = nx.utils.cumulative_distribution(degrees)  # cdf of degree</span>
<span class="gi">+    discrete_sequence = nx.utils.discrete_sequence</span>
<span class="gi">+</span>
<span class="gi">+    while swapcount &lt; nswap:</span>
<span class="gi">+        # choose source node index from discrete distribution</span>
<span class="gi">+        start_index = discrete_sequence(1, cdistribution=cdf, seed=seed)[0]</span>
<span class="gi">+        start = keys[start_index]</span>
<span class="gi">+        tries += 1</span>
<span class="gi">+</span>
<span class="gi">+        if tries &gt; max_tries:</span>
<span class="gi">+            msg = f&quot;Maximum number of swap attempts ({tries}) exceeded before desired swaps achieved ({nswap}).&quot;</span>
<span class="gi">+            raise nx.NetworkXAlgorithmError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        # If the given node doesn&#39;t have any out edges, then there isn&#39;t anything to swap</span>
<span class="gi">+        if G.out_degree(start) == 0:</span>
<span class="gi">+            continue</span>
<span class="gi">+        second = seed.choice(list(G.succ[start]))</span>
<span class="gi">+        if start == second:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if G.out_degree(second) == 0:</span>
<span class="gi">+            continue</span>
<span class="gi">+        third = seed.choice(list(G.succ[second]))</span>
<span class="gi">+        if second == third:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if G.out_degree(third) == 0:</span>
<span class="gi">+            continue</span>
<span class="gi">+        fourth = seed.choice(list(G.succ[third]))</span>
<span class="gi">+        if third == fourth:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            third not in G.succ[start]</span>
<span class="gi">+            and fourth not in G.succ[second]</span>
<span class="gi">+            and second not in G.succ[third]</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Swap nodes</span>
<span class="gi">+            G.add_edge(start, third)</span>
<span class="gi">+            G.add_edge(third, second)</span>
<span class="gi">+            G.add_edge(second, fourth)</span>
<span class="gi">+            G.remove_edge(start, second)</span>
<span class="gi">+            G.remove_edge(second, third)</span>
<span class="gi">+            G.remove_edge(third, fourth)</span>
<span class="gi">+            swapcount += 1</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -121,7 +182,52 @@ def double_edge_swap(G, nswap=1, max_tries=100, seed=None):</span>

<span class="w"> </span>    The graph G is modified in place.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;double_edge_swap() not defined for directed graphs. Use directed_edge_swap instead.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if nswap &gt; max_tries:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Number of swaps &gt; number of tries allowed.&quot;)</span>
<span class="gi">+    if len(G) &lt; 4:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph has fewer than four nodes.&quot;)</span>
<span class="gi">+    if len(G.edges) &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph has fewer than 2 edges&quot;)</span>
<span class="gi">+    # Instead of choosing uniformly at random from a generated edge list,</span>
<span class="gi">+    # this algorithm chooses nonuniformly from the set of nodes with</span>
<span class="gi">+    # probability weighted by degree.</span>
<span class="gi">+    n = 0</span>
<span class="gi">+    swapcount = 0</span>
<span class="gi">+    keys, degrees = zip(*G.degree())  # keys, degree</span>
<span class="gi">+    cdf = nx.utils.cumulative_distribution(degrees)  # cdf of degree</span>
<span class="gi">+    discrete_sequence = nx.utils.discrete_sequence</span>
<span class="gi">+    while swapcount &lt; nswap:</span>
<span class="gi">+        #        if random.random() &lt; 0.5: continue # trick to avoid periodicities?</span>
<span class="gi">+        # pick two random edges without creating edge list</span>
<span class="gi">+        # choose source node indices from discrete distribution</span>
<span class="gi">+        (ui, xi) = discrete_sequence(2, cdistribution=cdf, seed=seed)</span>
<span class="gi">+        if ui == xi:</span>
<span class="gi">+            continue  # same source, skip</span>
<span class="gi">+        u = keys[ui]  # convert index to label</span>
<span class="gi">+        x = keys[xi]</span>
<span class="gi">+        # choose target uniformly from neighbors</span>
<span class="gi">+        v = seed.choice(list(G[u]))</span>
<span class="gi">+        y = seed.choice(list(G[x]))</span>
<span class="gi">+        if v == y:</span>
<span class="gi">+            continue  # same target, skip</span>
<span class="gi">+        if (x not in G[u]) and (y not in G[v]):  # don&#39;t create parallel edges</span>
<span class="gi">+            G.add_edge(u, x)</span>
<span class="gi">+            G.add_edge(v, y)</span>
<span class="gi">+            G.remove_edge(u, v)</span>
<span class="gi">+            G.remove_edge(x, y)</span>
<span class="gi">+            swapcount += 1</span>
<span class="gi">+        if n &gt;= max_tries:</span>
<span class="gi">+            e = (</span>
<span class="gi">+                f&quot;Maximum number of swap attempts ({n}) exceeded &quot;</span>
<span class="gi">+                f&quot;before desired swaps achieved ({nswap}).&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise nx.NetworkXAlgorithmError(e)</span>
<span class="gi">+        n += 1</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -194,4 +300,108 @@ def connected_double_edge_swap(G, nswap=1, _window_threshold=3, seed=None):</span>
<span class="w"> </span>           power law random graphs, 2003.
<span class="w"> </span>           http://citeseer.ist.psu.edu/gkantsidis03markov.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph not connected&quot;)</span>
<span class="gi">+    if len(G) &lt; 4:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph has fewer than four nodes.&quot;)</span>
<span class="gi">+    n = 0</span>
<span class="gi">+    swapcount = 0</span>
<span class="gi">+    deg = G.degree()</span>
<span class="gi">+    # Label key for nodes</span>
<span class="gi">+    dk = [n for n, d in G.degree()]</span>
<span class="gi">+    cdf = nx.utils.cumulative_distribution([d for n, d in G.degree()])</span>
<span class="gi">+    discrete_sequence = nx.utils.discrete_sequence</span>
<span class="gi">+    window = 1</span>
<span class="gi">+    while n &lt; nswap:</span>
<span class="gi">+        wcount = 0</span>
<span class="gi">+        swapped = []</span>
<span class="gi">+        # If the window is small, we just check each time whether the graph is</span>
<span class="gi">+        # connected by checking if the nodes that were just separated are still</span>
<span class="gi">+        # connected.</span>
<span class="gi">+        if window &lt; _window_threshold:</span>
<span class="gi">+            # This Boolean keeps track of whether there was a failure or not.</span>
<span class="gi">+            fail = False</span>
<span class="gi">+            while wcount &lt; window and n &lt; nswap:</span>
<span class="gi">+                # Pick two random edges without creating the edge list. Choose</span>
<span class="gi">+                # source nodes from the discrete degree distribution.</span>
<span class="gi">+                (ui, xi) = discrete_sequence(2, cdistribution=cdf, seed=seed)</span>
<span class="gi">+                # If the source nodes are the same, skip this pair.</span>
<span class="gi">+                if ui == xi:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # Convert an index to a node label.</span>
<span class="gi">+                u = dk[ui]</span>
<span class="gi">+                x = dk[xi]</span>
<span class="gi">+                # Choose targets uniformly from neighbors.</span>
<span class="gi">+                v = seed.choice(list(G.neighbors(u)))</span>
<span class="gi">+                y = seed.choice(list(G.neighbors(x)))</span>
<span class="gi">+                # If the target nodes are the same, skip this pair.</span>
<span class="gi">+                if v == y:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if x not in G[u] and y not in G[v]:</span>
<span class="gi">+                    G.remove_edge(u, v)</span>
<span class="gi">+                    G.remove_edge(x, y)</span>
<span class="gi">+                    G.add_edge(u, x)</span>
<span class="gi">+                    G.add_edge(v, y)</span>
<span class="gi">+                    swapped.append((u, v, x, y))</span>
<span class="gi">+                    swapcount += 1</span>
<span class="gi">+                n += 1</span>
<span class="gi">+                # If G remains connected...</span>
<span class="gi">+                if nx.has_path(G, u, v):</span>
<span class="gi">+                    wcount += 1</span>
<span class="gi">+                # Otherwise, undo the changes.</span>
<span class="gi">+                else:</span>
<span class="gi">+                    G.add_edge(u, v)</span>
<span class="gi">+                    G.add_edge(x, y)</span>
<span class="gi">+                    G.remove_edge(u, x)</span>
<span class="gi">+                    G.remove_edge(v, y)</span>
<span class="gi">+                    swapcount -= 1</span>
<span class="gi">+                    fail = True</span>
<span class="gi">+            # If one of the swaps failed, reduce the window size.</span>
<span class="gi">+            if fail:</span>
<span class="gi">+                window = math.ceil(window / 2)</span>
<span class="gi">+            else:</span>
<span class="gi">+                window += 1</span>
<span class="gi">+        # If the window is large, then there is a good chance that a bunch of</span>
<span class="gi">+        # swaps will work. It&#39;s quicker to do all those swaps first and then</span>
<span class="gi">+        # check if the graph remains connected.</span>
<span class="gi">+        else:</span>
<span class="gi">+            while wcount &lt; window and n &lt; nswap:</span>
<span class="gi">+                # Pick two random edges without creating the edge list. Choose</span>
<span class="gi">+                # source nodes from the discrete degree distribution.</span>
<span class="gi">+                (ui, xi) = discrete_sequence(2, cdistribution=cdf, seed=seed)</span>
<span class="gi">+                # If the source nodes are the same, skip this pair.</span>
<span class="gi">+                if ui == xi:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # Convert an index to a node label.</span>
<span class="gi">+                u = dk[ui]</span>
<span class="gi">+                x = dk[xi]</span>
<span class="gi">+                # Choose targets uniformly from neighbors.</span>
<span class="gi">+                v = seed.choice(list(G.neighbors(u)))</span>
<span class="gi">+                y = seed.choice(list(G.neighbors(x)))</span>
<span class="gi">+                # If the target nodes are the same, skip this pair.</span>
<span class="gi">+                if v == y:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if x not in G[u] and y not in G[v]:</span>
<span class="gi">+                    G.remove_edge(u, v)</span>
<span class="gi">+                    G.remove_edge(x, y)</span>
<span class="gi">+                    G.add_edge(u, x)</span>
<span class="gi">+                    G.add_edge(v, y)</span>
<span class="gi">+                    swapped.append((u, v, x, y))</span>
<span class="gi">+                    swapcount += 1</span>
<span class="gi">+                n += 1</span>
<span class="gi">+                wcount += 1</span>
<span class="gi">+            # If the graph remains connected, increase the window size.</span>
<span class="gi">+            if nx.is_connected(G):</span>
<span class="gi">+                window += 1</span>
<span class="gi">+            # Otherwise, undo the changes from the previous window and decrease</span>
<span class="gi">+            # the window size.</span>
<span class="gi">+            else:</span>
<span class="gi">+                while swapped:</span>
<span class="gi">+                    (u, v, x, y) = swapped.pop()</span>
<span class="gi">+                    G.add_edge(u, v)</span>
<span class="gi">+                    G.add_edge(x, y)</span>
<span class="gi">+                    G.remove_edge(u, x)</span>
<span class="gi">+                    G.remove_edge(v, y)</span>
<span class="gi">+                    swapcount -= 1</span>
<span class="gi">+                window = math.ceil(window / 2)</span>
<span class="gi">+    return swapcount</span>
<span class="gh">diff --git a/networkx/algorithms/threshold.py b/networkx/algorithms/threshold.py</span>
<span class="gh">index d48f32d59..bcc03d106 100644</span>
<span class="gd">--- a/networkx/algorithms/threshold.py</span>
<span class="gi">+++ b/networkx/algorithms/threshold.py</span>
<span class="gu">@@ -2,9 +2,11 @@</span>
<span class="w"> </span>Threshold Graphs - Creation, manipulation and identification.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from math import sqrt
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;is_threshold_graph&#39;, &#39;find_threshold_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;is_threshold_graph&quot;, &quot;find_threshold_graph&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -36,7 +38,7 @@ def is_threshold_graph(G):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] Threshold graphs: https://en.wikipedia.org/wiki/Threshold_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return is_threshold_sequence([d for n, d in G.degree()])</span>


<span class="w"> </span>def is_threshold_sequence(degree_sequence):
<span class="gu">@@ -49,7 +51,17 @@ def is_threshold_sequence(degree_sequence):</span>
<span class="w"> </span>    node that connects to the remaining nodes.  If this deconstruction
<span class="w"> </span>    fails then the sequence is not a threshold sequence.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ds = degree_sequence[:]  # get a copy so we don&#39;t destroy original</span>
<span class="gi">+    ds.sort()</span>
<span class="gi">+    while ds:</span>
<span class="gi">+        if ds[0] == 0:  # if isolated node</span>
<span class="gi">+            ds.pop(0)  # remove it</span>
<span class="gi">+            continue</span>
<span class="gi">+        if ds[-1] != len(ds) - 1:  # is the largest degree node dominating?</span>
<span class="gi">+            return False  # no, not a threshold degree sequence</span>
<span class="gi">+        ds.pop()  # yes, largest is the dominating node</span>
<span class="gi">+        ds = [d - 1 for d in ds]  # remove it and decrement all degrees</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def creation_sequence(degree_sequence, with_labels=False, compact=False):
<span class="gu">@@ -80,7 +92,35 @@ def creation_sequence(degree_sequence, with_labels=False, compact=False):</span>

<span class="w"> </span>    Returns None if the sequence is not a threshold sequence
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if with_labels and compact:</span>
<span class="gi">+        raise ValueError(&quot;compact sequences cannot be labeled&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # make an indexed copy</span>
<span class="gi">+    if isinstance(degree_sequence, dict):  # labeled degree sequence</span>
<span class="gi">+        ds = [[degree, label] for (label, degree) in degree_sequence.items()]</span>
<span class="gi">+    else:</span>
<span class="gi">+        ds = [[d, i] for i, d in enumerate(degree_sequence)]</span>
<span class="gi">+    ds.sort()</span>
<span class="gi">+    cs = []  # creation sequence</span>
<span class="gi">+    while ds:</span>
<span class="gi">+        if ds[0][0] == 0:  # isolated node</span>
<span class="gi">+            (d, v) = ds.pop(0)</span>
<span class="gi">+            if len(ds) &gt; 0:  # make sure we start with a d</span>
<span class="gi">+                cs.insert(0, (v, &quot;i&quot;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                cs.insert(0, (v, &quot;d&quot;))</span>
<span class="gi">+            continue</span>
<span class="gi">+        if ds[-1][0] != len(ds) - 1:  # Not dominating node</span>
<span class="gi">+            return None  # not a threshold degree sequence</span>
<span class="gi">+        (d, v) = ds.pop()</span>
<span class="gi">+        cs.insert(0, (v, &quot;d&quot;))</span>
<span class="gi">+        ds = [[d[0] - 1, d[1]] for d in ds]  # decrement due to removing node</span>
<span class="gi">+</span>
<span class="gi">+    if with_labels:</span>
<span class="gi">+        return cs</span>
<span class="gi">+    if compact:</span>
<span class="gi">+        return make_compact(cs)</span>
<span class="gi">+    return [v[1] for v in cs]  # not labeled</span>


<span class="w"> </span>def make_compact(creation_sequence):
<span class="gu">@@ -105,7 +145,26 @@ def make_compact(creation_sequence):</span>
<span class="w"> </span>    &gt;&gt;&gt; make_compact([3, 1, 2])
<span class="w"> </span>    [3, 1, 2]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    first = creation_sequence[0]</span>
<span class="gi">+    if isinstance(first, str):  # creation sequence</span>
<span class="gi">+        cs = creation_sequence[:]</span>
<span class="gi">+    elif isinstance(first, tuple):  # labeled creation sequence</span>
<span class="gi">+        cs = [s[1] for s in creation_sequence]</span>
<span class="gi">+    elif isinstance(first, int):  # compact creation sequence</span>
<span class="gi">+        return creation_sequence</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Not a valid creation sequence type&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    ccs = []</span>
<span class="gi">+    count = 1  # count the run lengths of d&#39;s or i&#39;s.</span>
<span class="gi">+    for i in range(1, len(cs)):</span>
<span class="gi">+        if cs[i] == cs[i - 1]:</span>
<span class="gi">+            count += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            ccs.append(count)</span>
<span class="gi">+            count = 1</span>
<span class="gi">+    ccs.append(count)  # don&#39;t forget the last one</span>
<span class="gi">+    return ccs</span>


<span class="w"> </span>def uncompact(creation_sequence):
<span class="gu">@@ -115,7 +174,21 @@ def uncompact(creation_sequence):</span>
<span class="w"> </span>    If the creation_sequence is already standard, return it.
<span class="w"> </span>    See creation_sequence.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    first = creation_sequence[0]</span>
<span class="gi">+    if isinstance(first, str):  # creation sequence</span>
<span class="gi">+        return creation_sequence</span>
<span class="gi">+    elif isinstance(first, tuple):  # labeled creation sequence</span>
<span class="gi">+        return creation_sequence</span>
<span class="gi">+    elif isinstance(first, int):  # compact creation sequence</span>
<span class="gi">+        ccscopy = creation_sequence[:]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Not a valid creation sequence type&quot;)</span>
<span class="gi">+    cs = []</span>
<span class="gi">+    while ccscopy:</span>
<span class="gi">+        cs.extend(ccscopy.pop(0) * [&quot;d&quot;])</span>
<span class="gi">+        if ccscopy:</span>
<span class="gi">+            cs.extend(ccscopy.pop(0) * [&quot;i&quot;])</span>
<span class="gi">+    return cs</span>


<span class="w"> </span>def creation_sequence_to_weights(creation_sequence):
<span class="gu">@@ -125,11 +198,49 @@ def creation_sequence_to_weights(creation_sequence):</span>
<span class="w"> </span>    are scaled so that the threshold is 1.0.  The order of the
<span class="w"> </span>    nodes is the same as that in the creation sequence.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def weights_to_creation_sequence(weights, threshold=1, with_labels=False,</span>
<span class="gd">-    compact=False):</span>
<span class="gi">+    # Turn input sequence into a labeled creation sequence</span>
<span class="gi">+    first = creation_sequence[0]</span>
<span class="gi">+    if isinstance(first, str):  # creation sequence</span>
<span class="gi">+        if isinstance(creation_sequence, list):</span>
<span class="gi">+            wseq = creation_sequence[:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            wseq = list(creation_sequence)  # string like &#39;ddidid&#39;</span>
<span class="gi">+    elif isinstance(first, tuple):  # labeled creation sequence</span>
<span class="gi">+        wseq = [v[1] for v in creation_sequence]</span>
<span class="gi">+    elif isinstance(first, int):  # compact creation sequence</span>
<span class="gi">+        wseq = uncompact(creation_sequence)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Not a valid creation sequence type&quot;)</span>
<span class="gi">+    # pass through twice--first backwards</span>
<span class="gi">+    wseq.reverse()</span>
<span class="gi">+    w = 0</span>
<span class="gi">+    prev = &quot;i&quot;</span>
<span class="gi">+    for j, s in enumerate(wseq):</span>
<span class="gi">+        if s == &quot;i&quot;:</span>
<span class="gi">+            wseq[j] = w</span>
<span class="gi">+            prev = s</span>
<span class="gi">+        elif prev == &quot;i&quot;:</span>
<span class="gi">+            prev = s</span>
<span class="gi">+            w += 1</span>
<span class="gi">+    wseq.reverse()  # now pass through forwards</span>
<span class="gi">+    for j, s in enumerate(wseq):</span>
<span class="gi">+        if s == &quot;d&quot;:</span>
<span class="gi">+            wseq[j] = w</span>
<span class="gi">+            prev = s</span>
<span class="gi">+        elif prev == &quot;d&quot;:</span>
<span class="gi">+            prev = s</span>
<span class="gi">+            w += 1</span>
<span class="gi">+    # Now scale weights</span>
<span class="gi">+    if prev == &quot;d&quot;:</span>
<span class="gi">+        w += 1</span>
<span class="gi">+    wscale = 1 / w</span>
<span class="gi">+    return [ww * wscale for ww in wseq]</span>
<span class="gi">+    # return wseq</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def weights_to_creation_sequence(</span>
<span class="gi">+    weights, threshold=1, with_labels=False, compact=False</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a creation sequence for a threshold graph
<span class="w"> </span>    determined by the weights and threshold given as input.
<span class="gu">@@ -157,9 +268,39 @@ def weights_to_creation_sequence(weights, threshold=1, with_labels=False,</span>

<span class="w"> </span>    with_labels and compact cannot both be True.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    if with_labels and compact:</span>
<span class="gi">+        raise ValueError(&quot;compact sequences cannot be labeled&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # make an indexed copy</span>
<span class="gi">+    if isinstance(weights, dict):  # labeled weights</span>
<span class="gi">+        wseq = [[w, label] for (label, w) in weights.items()]</span>
<span class="gi">+    else:</span>
<span class="gi">+        wseq = [[w, i] for i, w in enumerate(weights)]</span>
<span class="gi">+    wseq.sort()</span>
<span class="gi">+    cs = []  # creation sequence</span>
<span class="gi">+    cutoff = threshold - wseq[-1][0]</span>
<span class="gi">+    while wseq:</span>
<span class="gi">+        if wseq[0][0] &lt; cutoff:  # isolated node</span>
<span class="gi">+            (w, label) = wseq.pop(0)</span>
<span class="gi">+            cs.append((label, &quot;i&quot;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            (w, label) = wseq.pop()</span>
<span class="gi">+            cs.append((label, &quot;d&quot;))</span>
<span class="gi">+            cutoff = threshold - wseq[-1][0]</span>
<span class="gi">+        if len(wseq) == 1:  # make sure we start with a d</span>
<span class="gi">+            (w, label) = wseq.pop()</span>
<span class="gi">+            cs.append((label, &quot;d&quot;))</span>
<span class="gi">+    # put in correct order</span>
<span class="gi">+    cs.reverse()</span>
<span class="gi">+</span>
<span class="gi">+    if with_labels:</span>
<span class="gi">+        return cs</span>
<span class="gi">+    if compact:</span>
<span class="gi">+        return make_compact(cs)</span>
<span class="gi">+    return [v[1] for v in cs]  # not labeled</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Manipulating NetworkX.Graphs in context of threshold graphs</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def threshold_graph(creation_sequence, create_using=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -177,7 +318,39 @@ def threshold_graph(creation_sequence, create_using=None):</span>

<span class="w"> </span>    Returns None if the sequence is not valid
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Turn input sequence into a labeled creation sequence</span>
<span class="gi">+    first = creation_sequence[0]</span>
<span class="gi">+    if isinstance(first, str):  # creation sequence</span>
<span class="gi">+        ci = list(enumerate(creation_sequence))</span>
<span class="gi">+    elif isinstance(first, tuple):  # labeled creation sequence</span>
<span class="gi">+        ci = creation_sequence[:]</span>
<span class="gi">+    elif isinstance(first, int):  # compact creation sequence</span>
<span class="gi">+        cs = uncompact(creation_sequence)</span>
<span class="gi">+        ci = list(enumerate(cs))</span>
<span class="gi">+    else:</span>
<span class="gi">+        print(&quot;not a valid creation sequence type&quot;)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G.name = &quot;Threshold Graph&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # add nodes and edges</span>
<span class="gi">+    # if type is &#39;i&#39; just add nodea</span>
<span class="gi">+    # if type is a d connect to everything previous</span>
<span class="gi">+    while ci:</span>
<span class="gi">+        (v, node_type) = ci.pop(0)</span>
<span class="gi">+        if node_type == &quot;d&quot;:  # dominating type, connect to all existing nodes</span>
<span class="gi">+            # We use `for u in list(G):` instead of</span>
<span class="gi">+            # `for u in G:` because we edit the graph `G` in</span>
<span class="gi">+            # the loop. Hence using an iterator will result in</span>
<span class="gi">+            # `RuntimeError: dictionary changed size during iteration`</span>
<span class="gi">+            for u in list(G):</span>
<span class="gi">+                G.add_edge(v, u)</span>
<span class="gi">+        G.add_node(v)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -187,7 +360,13 @@ def find_alternating_4_cycle(G):</span>
<span class="w"> </span>    Otherwise returns the cycle as [a,b,c,d] where (a,b)
<span class="w"> </span>    and (c,d) are edges and (a,c) and (b,d) are not.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for u, v in G.edges():</span>
<span class="gi">+        for w in G.nodes():</span>
<span class="gi">+            if not G.has_edge(u, w) and u != w:</span>
<span class="gi">+                for x in G.neighbors(w):</span>
<span class="gi">+                    if not G.has_edge(v, x) and v != x:</span>
<span class="gi">+                        return [u, v, w, x]</span>
<span class="gi">+    return False</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -222,7 +401,7 @@ def find_threshold_graph(G, create_using=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] Threshold graphs: https://en.wikipedia.org/wiki/Threshold_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return threshold_graph(find_creation_sequence(G), create_using)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -231,15 +410,51 @@ def find_creation_sequence(G):</span>
<span class="w"> </span>    Find a threshold subgraph that is close to largest in G.
<span class="w"> </span>    Returns the labeled creation sequence of that threshold graph.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    cs = []</span>
<span class="gi">+    # get a local pointer to the working part of the graph</span>
<span class="gi">+    H = G</span>
<span class="gi">+    while H.order() &gt; 0:</span>
<span class="gi">+        # get new degree sequence on subgraph</span>
<span class="gi">+        dsdict = dict(H.degree())</span>
<span class="gi">+        ds = [(d, v) for v, d in dsdict.items()]</span>
<span class="gi">+        ds.sort()</span>
<span class="gi">+        # Update threshold graph nodes</span>
<span class="gi">+        if ds[-1][0] == 0:  # all are isolated</span>
<span class="gi">+            cs.extend(zip(dsdict, [&quot;i&quot;] * (len(ds) - 1) + [&quot;d&quot;]))</span>
<span class="gi">+            break  # Done!</span>
<span class="gi">+        # pull off isolated nodes</span>
<span class="gi">+        while ds[0][0] == 0:</span>
<span class="gi">+            (d, iso) = ds.pop(0)</span>
<span class="gi">+            cs.append((iso, &quot;i&quot;))</span>
<span class="gi">+        # find new biggest node</span>
<span class="gi">+        (d, bigv) = ds.pop()</span>
<span class="gi">+        # add edges of star to t_g</span>
<span class="gi">+        cs.append((bigv, &quot;d&quot;))</span>
<span class="gi">+        # form subgraph of neighbors of big node</span>
<span class="gi">+        H = H.subgraph(H.neighbors(bigv))</span>
<span class="gi">+    cs.reverse()</span>
<span class="gi">+    return cs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Properties of Threshold Graphs</span>
<span class="w"> </span>def triangles(creation_sequence):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Compute number of triangles in the threshold graph with the
<span class="w"> </span>    given creation sequence.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # shortcut algorithm that doesn&#39;t require computing number</span>
<span class="gi">+    # of triangles at each node.</span>
<span class="gi">+    cs = creation_sequence  # alias</span>
<span class="gi">+    dr = cs.count(&quot;d&quot;)  # number of d&#39;s in sequence</span>
<span class="gi">+    ntri = dr * (dr - 1) * (dr - 2) / 6  # number of triangles in clique of nd d&#39;s</span>
<span class="gi">+    # now add dr choose 2 triangles for every &#39;i&#39; in sequence where</span>
<span class="gi">+    # dr is the number of d&#39;s to the right of the current i</span>
<span class="gi">+    for i, typ in enumerate(cs):</span>
<span class="gi">+        if typ == &quot;i&quot;:</span>
<span class="gi">+            ntri += dr * (dr - 1) / 2</span>
<span class="gi">+        else:</span>
<span class="gi">+            dr -= 1</span>
<span class="gi">+    return ntri</span>


<span class="w"> </span>def triangle_sequence(creation_sequence):
<span class="gu">@@ -247,14 +462,44 @@ def triangle_sequence(creation_sequence):</span>
<span class="w"> </span>    Return triangle sequence for the given threshold graph creation sequence.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cs = creation_sequence</span>
<span class="gi">+    seq = []</span>
<span class="gi">+    dr = cs.count(&quot;d&quot;)  # number of d&#39;s to the right of the current pos</span>
<span class="gi">+    dcur = (dr - 1) * (dr - 2) // 2  # number of triangles through a node of clique dr</span>
<span class="gi">+    irun = 0  # number of i&#39;s in the last run</span>
<span class="gi">+    drun = 0  # number of d&#39;s in the last run</span>
<span class="gi">+    for i, sym in enumerate(cs):</span>
<span class="gi">+        if sym == &quot;d&quot;:</span>
<span class="gi">+            drun += 1</span>
<span class="gi">+            tri = dcur + (dr - 1) * irun  # new triangles at this d</span>
<span class="gi">+        else:  # cs[i]=&quot;i&quot;:</span>
<span class="gi">+            if prevsym == &quot;d&quot;:  # new string of i&#39;s</span>
<span class="gi">+                dcur += (dr - 1) * irun  # accumulate shared shortest paths</span>
<span class="gi">+                irun = 0  # reset i run counter</span>
<span class="gi">+                dr -= drun  # reduce number of d&#39;s to right</span>
<span class="gi">+                drun = 0  # reset d run counter</span>
<span class="gi">+            irun += 1</span>
<span class="gi">+            tri = dr * (dr - 1) // 2  # new triangles at this i</span>
<span class="gi">+        seq.append(tri)</span>
<span class="gi">+        prevsym = sym</span>
<span class="gi">+    return seq</span>


<span class="w"> </span>def cluster_sequence(creation_sequence):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return cluster sequence for the given threshold graph creation sequence.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    triseq = triangle_sequence(creation_sequence)</span>
<span class="gi">+    degseq = degree_sequence(creation_sequence)</span>
<span class="gi">+    cseq = []</span>
<span class="gi">+    for i, deg in enumerate(degseq):</span>
<span class="gi">+        tri = triseq[i]</span>
<span class="gi">+        if deg &lt;= 1:  # isolated vertex or single pair gets cc 0</span>
<span class="gi">+            cseq.append(0)</span>
<span class="gi">+            continue</span>
<span class="gi">+        max_size = (deg * (deg - 1)) // 2</span>
<span class="gi">+        cseq.append(tri / max_size)</span>
<span class="gi">+    return cseq</span>


<span class="w"> </span>def degree_sequence(creation_sequence):
<span class="gu">@@ -262,7 +507,16 @@ def degree_sequence(creation_sequence):</span>
<span class="w"> </span>    Return degree sequence for the threshold graph with the given
<span class="w"> </span>    creation sequence
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cs = creation_sequence  # alias</span>
<span class="gi">+    seq = []</span>
<span class="gi">+    rd = cs.count(&quot;d&quot;)  # number of d to the right</span>
<span class="gi">+    for i, sym in enumerate(cs):</span>
<span class="gi">+        if sym == &quot;d&quot;:</span>
<span class="gi">+            rd -= 1</span>
<span class="gi">+            seq.append(rd + i)</span>
<span class="gi">+        else:</span>
<span class="gi">+            seq.append(rd)</span>
<span class="gi">+    return seq</span>


<span class="w"> </span>def density(creation_sequence):
<span class="gu">@@ -270,14 +524,45 @@ def density(creation_sequence):</span>
<span class="w"> </span>    Return the density of the graph with this creation_sequence.
<span class="w"> </span>    The density is the fraction of possible edges present.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    N = len(creation_sequence)</span>
<span class="gi">+    two_size = sum(degree_sequence(creation_sequence))</span>
<span class="gi">+    two_possible = N * (N - 1)</span>
<span class="gi">+    den = two_size / two_possible</span>
<span class="gi">+    return den</span>


<span class="w"> </span>def degree_correlation(creation_sequence):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return the degree-degree correlation over all edges.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cs = creation_sequence</span>
<span class="gi">+    s1 = 0  # deg_i*deg_j</span>
<span class="gi">+    s2 = 0  # deg_i^2+deg_j^2</span>
<span class="gi">+    s3 = 0  # deg_i+deg_j</span>
<span class="gi">+    m = 0  # number of edges</span>
<span class="gi">+    rd = cs.count(&quot;d&quot;)  # number of d nodes to the right</span>
<span class="gi">+    rdi = [i for i, sym in enumerate(cs) if sym == &quot;d&quot;]  # index of &quot;d&quot;s</span>
<span class="gi">+    ds = degree_sequence(cs)</span>
<span class="gi">+    for i, sym in enumerate(cs):</span>
<span class="gi">+        if sym == &quot;d&quot;:</span>
<span class="gi">+            if i != rdi[0]:</span>
<span class="gi">+                print(&quot;Logic error in degree_correlation&quot;, i, rdi)</span>
<span class="gi">+                raise ValueError</span>
<span class="gi">+            rdi.pop(0)</span>
<span class="gi">+        degi = ds[i]</span>
<span class="gi">+        for dj in rdi:</span>
<span class="gi">+            degj = ds[dj]</span>
<span class="gi">+            s1 += degj * degi</span>
<span class="gi">+            s2 += degi**2 + degj**2</span>
<span class="gi">+            s3 += degi + degj</span>
<span class="gi">+            m += 1</span>
<span class="gi">+    denom = 2 * m * s2 - s3 * s3</span>
<span class="gi">+    numer = 4 * m * s1 - s3 * s3</span>
<span class="gi">+    if denom == 0:</span>
<span class="gi">+        if numer == 0:</span>
<span class="gi">+            return 1</span>
<span class="gi">+        raise ValueError(f&quot;Zero Denominator but Numerator is {numer}&quot;)</span>
<span class="gi">+    return numer / denom</span>


<span class="w"> </span>def shortest_path(creation_sequence, u, v):
<span class="gu">@@ -297,7 +582,40 @@ def shortest_path(creation_sequence, u, v):</span>
<span class="w"> </span>    Returns a list of vertices from u to v.
<span class="w"> </span>    Example: if they are neighbors, it returns [u,v]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Turn input sequence into a labeled creation sequence</span>
<span class="gi">+    first = creation_sequence[0]</span>
<span class="gi">+    if isinstance(first, str):  # creation sequence</span>
<span class="gi">+        cs = [(i, creation_sequence[i]) for i in range(len(creation_sequence))]</span>
<span class="gi">+    elif isinstance(first, tuple):  # labeled creation sequence</span>
<span class="gi">+        cs = creation_sequence[:]</span>
<span class="gi">+    elif isinstance(first, int):  # compact creation sequence</span>
<span class="gi">+        ci = uncompact(creation_sequence)</span>
<span class="gi">+        cs = [(i, ci[i]) for i in range(len(ci))]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Not a valid creation sequence type&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    verts = [s[0] for s in cs]</span>
<span class="gi">+    if v not in verts:</span>
<span class="gi">+        raise ValueError(f&quot;Vertex {v} not in graph from creation_sequence&quot;)</span>
<span class="gi">+    if u not in verts:</span>
<span class="gi">+        raise ValueError(f&quot;Vertex {u} not in graph from creation_sequence&quot;)</span>
<span class="gi">+    # Done checking</span>
<span class="gi">+    if u == v:</span>
<span class="gi">+        return [u]</span>
<span class="gi">+</span>
<span class="gi">+    uindex = verts.index(u)</span>
<span class="gi">+    vindex = verts.index(v)</span>
<span class="gi">+    bigind = max(uindex, vindex)</span>
<span class="gi">+    if cs[bigind][1] == &quot;d&quot;:</span>
<span class="gi">+        return [u, v]</span>
<span class="gi">+    # must be that cs[bigind][1]==&#39;i&#39;</span>
<span class="gi">+    cs = cs[bigind:]</span>
<span class="gi">+    while cs:</span>
<span class="gi">+        vert = cs.pop()</span>
<span class="gi">+        if vert[1] == &quot;d&quot;:</span>
<span class="gi">+            return [u, vert[0], v]</span>
<span class="gi">+    # All after u are type &#39;i&#39; so no connection</span>
<span class="gi">+    return -1</span>


<span class="w"> </span>def shortest_path_length(creation_sequence, i):
<span class="gu">@@ -312,7 +630,38 @@ def shortest_path_length(creation_sequence, i):</span>
<span class="w"> </span>    Paths lengths in threshold graphs are at most 2.
<span class="w"> </span>    Length to unreachable nodes is set to -1.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Turn input sequence into a labeled creation sequence</span>
<span class="gi">+    first = creation_sequence[0]</span>
<span class="gi">+    if isinstance(first, str):  # creation sequence</span>
<span class="gi">+        if isinstance(creation_sequence, list):</span>
<span class="gi">+            cs = creation_sequence[:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            cs = list(creation_sequence)</span>
<span class="gi">+    elif isinstance(first, tuple):  # labeled creation sequence</span>
<span class="gi">+        cs = [v[1] for v in creation_sequence]</span>
<span class="gi">+        i = [v[0] for v in creation_sequence].index(i)</span>
<span class="gi">+    elif isinstance(first, int):  # compact creation sequence</span>
<span class="gi">+        cs = uncompact(creation_sequence)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&quot;Not a valid creation sequence type&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Compute</span>
<span class="gi">+    N = len(cs)</span>
<span class="gi">+    spl = [2] * N  # length 2 to every node</span>
<span class="gi">+    spl[i] = 0  # except self which is 0</span>
<span class="gi">+    # 1 for all d&#39;s to the right</span>
<span class="gi">+    for j in range(i + 1, N):</span>
<span class="gi">+        if cs[j] == &quot;d&quot;:</span>
<span class="gi">+            spl[j] = 1</span>
<span class="gi">+    if cs[i] == &quot;d&quot;:  # 1 for all nodes to the left</span>
<span class="gi">+        for j in range(i):</span>
<span class="gi">+            spl[j] = 1</span>
<span class="gi">+    # and -1 for any trailing i to indicate unreachable</span>
<span class="gi">+    for j in range(N - 1, 0, -1):</span>
<span class="gi">+        if cs[j] == &quot;d&quot;:</span>
<span class="gi">+            break</span>
<span class="gi">+        spl[j] = -1</span>
<span class="gi">+    return spl</span>


<span class="w"> </span>def betweenness_sequence(creation_sequence, normalized=True):
<span class="gu">@@ -321,7 +670,38 @@ def betweenness_sequence(creation_sequence, normalized=True):</span>
<span class="w"> </span>    sequence.  The result is unscaled.  To scale the values
<span class="w"> </span>    to the interval [0,1] divide by (n-1)*(n-2).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cs = creation_sequence</span>
<span class="gi">+    seq = []  # betweenness</span>
<span class="gi">+    lastchar = &quot;d&quot;  # first node is always a &#39;d&#39;</span>
<span class="gi">+    dr = float(cs.count(&quot;d&quot;))  # number of d&#39;s to the right of current pos</span>
<span class="gi">+    irun = 0  # number of i&#39;s in the last run</span>
<span class="gi">+    drun = 0  # number of d&#39;s in the last run</span>
<span class="gi">+    dlast = 0.0  # betweenness of last d</span>
<span class="gi">+    for i, c in enumerate(cs):</span>
<span class="gi">+        if c == &quot;d&quot;:  # cs[i]==&quot;d&quot;:</span>
<span class="gi">+            # betweenness = amt shared with earlier d&#39;s and i&#39;s</span>
<span class="gi">+            #             + new isolated nodes covered</span>
<span class="gi">+            #             + new paths to all previous nodes</span>
<span class="gi">+            b = dlast + (irun - 1) * irun / dr + 2 * irun * (i - drun - irun) / dr</span>
<span class="gi">+            drun += 1  # update counter</span>
<span class="gi">+        else:  # cs[i]=&quot;i&quot;:</span>
<span class="gi">+            if lastchar == &quot;d&quot;:  # if this is a new run of i&#39;s</span>
<span class="gi">+                dlast = b  # accumulate betweenness</span>
<span class="gi">+                dr -= drun  # update number of d&#39;s to the right</span>
<span class="gi">+                drun = 0  # reset d counter</span>
<span class="gi">+                irun = 0  # reset i counter</span>
<span class="gi">+            b = 0  # isolated nodes have zero betweenness</span>
<span class="gi">+            irun += 1  # add another i to the run</span>
<span class="gi">+        seq.append(float(b))</span>
<span class="gi">+        lastchar = c</span>
<span class="gi">+</span>
<span class="gi">+    # normalize by the number of possible shortest paths</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        order = len(cs)</span>
<span class="gi">+        scale = 1.0 / ((order - 1) * (order - 2))</span>
<span class="gi">+        seq = [s * scale for s in seq]</span>
<span class="gi">+</span>
<span class="gi">+    return seq</span>


<span class="w"> </span>def eigenvectors(creation_sequence):
<span class="gu">@@ -336,7 +716,50 @@ def eigenvectors(creation_sequence):</span>
<span class="w"> </span>    Notice that the order of the eigenvalues returned by eigenvalues(cs)
<span class="w"> </span>    may not correspond to the order of these eigenvectors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ccs = make_compact(creation_sequence)</span>
<span class="gi">+    N = sum(ccs)</span>
<span class="gi">+    vec = [0] * N</span>
<span class="gi">+    val = vec[:]</span>
<span class="gi">+    # get number of type d nodes to the right (all for first node)</span>
<span class="gi">+    dr = sum(ccs[::2])</span>
<span class="gi">+</span>
<span class="gi">+    nn = ccs[0]</span>
<span class="gi">+    vec[0] = [1.0 / sqrt(N)] * N</span>
<span class="gi">+    val[0] = 0</span>
<span class="gi">+    e = dr</span>
<span class="gi">+    dr -= nn</span>
<span class="gi">+    type_d = True</span>
<span class="gi">+    i = 1</span>
<span class="gi">+    dd = 1</span>
<span class="gi">+    while dd &lt; nn:</span>
<span class="gi">+        scale = 1.0 / sqrt(dd * dd + i)</span>
<span class="gi">+        vec[i] = i * [-scale] + [dd * scale] + [0] * (N - i - 1)</span>
<span class="gi">+        val[i] = e</span>
<span class="gi">+        i += 1</span>
<span class="gi">+        dd += 1</span>
<span class="gi">+    if len(ccs) == 1:</span>
<span class="gi">+        return (val, vec)</span>
<span class="gi">+    for nn in ccs[1:]:</span>
<span class="gi">+        scale = 1.0 / sqrt(nn * i * (i + nn))</span>
<span class="gi">+        vec[i] = i * [-nn * scale] + nn * [i * scale] + [0] * (N - i - nn)</span>
<span class="gi">+        # find eigenvalue</span>
<span class="gi">+        type_d = not type_d</span>
<span class="gi">+        if type_d:</span>
<span class="gi">+            e = i + dr</span>
<span class="gi">+            dr -= nn</span>
<span class="gi">+        else:</span>
<span class="gi">+            e = dr</span>
<span class="gi">+        val[i] = e</span>
<span class="gi">+        st = i</span>
<span class="gi">+        i += 1</span>
<span class="gi">+        dd = 1</span>
<span class="gi">+        while dd &lt; nn:</span>
<span class="gi">+            scale = 1.0 / sqrt(i - st + dd * dd)</span>
<span class="gi">+            vec[i] = [0] * st + (i - st) * [-scale] + [dd * scale] + [0] * (N - i - 1)</span>
<span class="gi">+            val[i] = e</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            dd += 1</span>
<span class="gi">+    return (val, vec)</span>


<span class="w"> </span>def spectral_projection(u, eigenpairs):
<span class="gu">@@ -352,7 +775,12 @@ def spectral_projection(u, eigenpairs):</span>
<span class="w"> </span>    There&#39;s not a lot of error checking on lengths of
<span class="w"> </span>    arrays, etc. so be careful.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    coeff = []</span>
<span class="gi">+    evect = eigenpairs[1]</span>
<span class="gi">+    for ev in evect:</span>
<span class="gi">+        c = sum(evv * uv for (evv, uv) in zip(ev, u))</span>
<span class="gi">+        coeff.append(c)</span>
<span class="gi">+    return coeff</span>


<span class="w"> </span>def eigenvalues(creation_sequence):
<span class="gu">@@ -375,7 +803,26 @@ def eigenvalues(creation_sequence):</span>
<span class="w"> </span>      }

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    degseq = degree_sequence(creation_sequence)</span>
<span class="gi">+    degseq.sort()</span>
<span class="gi">+    eiglist = []  # zero is always one eigenvalue</span>
<span class="gi">+    eig = 0</span>
<span class="gi">+    row = len(degseq)</span>
<span class="gi">+    bigdeg = degseq.pop()</span>
<span class="gi">+    while row:</span>
<span class="gi">+        if bigdeg &lt; row:</span>
<span class="gi">+            eiglist.append(eig)</span>
<span class="gi">+            row -= 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            eig += 1</span>
<span class="gi">+            if degseq:</span>
<span class="gi">+                bigdeg = degseq.pop()</span>
<span class="gi">+            else:</span>
<span class="gi">+                bigdeg = 0</span>
<span class="gi">+    return eiglist</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Threshold graph creation routines</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -398,9 +845,21 @@ def random_threshold_sequence(n, p, seed=None):</span>
<span class="w"> </span>        Indicator of random number generation state.
<span class="w"> </span>        See :ref:`Randomness&lt;randomness&gt;`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not (0 &lt;= p &lt;= 1):</span>
<span class="gi">+        raise ValueError(&quot;p must be in [0,1]&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    cs = [&quot;d&quot;]  # threshold sequences always start with a d</span>
<span class="gi">+    for i in range(1, n):</span>
<span class="gi">+        if seed.random() &lt; p:</span>
<span class="gi">+            cs.append(&quot;d&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            cs.append(&quot;i&quot;)</span>
<span class="gi">+    return cs</span>


<span class="gi">+# maybe *_d_threshold_sequence routines should</span>
<span class="gi">+# be (or be called from) a single routine with a more descriptive name</span>
<span class="gi">+# and a keyword parameter?</span>
<span class="w"> </span>def right_d_threshold_sequence(n, m):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a skewed threshold graph with a given number
<span class="gu">@@ -412,7 +871,27 @@ def right_d_threshold_sequence(n, m):</span>
<span class="w"> </span>    FIXME: describe algorithm

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cs = [&quot;d&quot;] + [&quot;i&quot;] * (n - 1)  # create sequence with n insolated nodes</span>
<span class="gi">+</span>
<span class="gi">+    #  m &lt;n : not enough edges, make disconnected</span>
<span class="gi">+    if m &lt; n:</span>
<span class="gi">+        cs[m] = &quot;d&quot;</span>
<span class="gi">+        return cs</span>
<span class="gi">+</span>
<span class="gi">+    # too many edges</span>
<span class="gi">+    if m &gt; n * (n - 1) / 2:</span>
<span class="gi">+        raise ValueError(&quot;Too many edges for this many nodes.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # connected case m &gt;n-1</span>
<span class="gi">+    ind = n - 1</span>
<span class="gi">+    sum = n - 1</span>
<span class="gi">+    while sum &lt; m:</span>
<span class="gi">+        cs[ind] = &quot;d&quot;</span>
<span class="gi">+        ind -= 1</span>
<span class="gi">+        sum += ind</span>
<span class="gi">+    ind = m - (sum - ind)</span>
<span class="gi">+    cs[ind] = &quot;d&quot;</span>
<span class="gi">+    return cs</span>


<span class="w"> </span>def left_d_threshold_sequence(n, m):
<span class="gu">@@ -426,7 +905,28 @@ def left_d_threshold_sequence(n, m):</span>
<span class="w"> </span>    FIXME: describe algorithm

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cs = [&quot;d&quot;] + [&quot;i&quot;] * (n - 1)  # create sequence with n insolated nodes</span>
<span class="gi">+</span>
<span class="gi">+    #  m &lt;n : not enough edges, make disconnected</span>
<span class="gi">+    if m &lt; n:</span>
<span class="gi">+        cs[m] = &quot;d&quot;</span>
<span class="gi">+        return cs</span>
<span class="gi">+</span>
<span class="gi">+    # too many edges</span>
<span class="gi">+    if m &gt; n * (n - 1) / 2:</span>
<span class="gi">+        raise ValueError(&quot;Too many edges for this many nodes.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Connected case when M&gt;N-1</span>
<span class="gi">+    cs[n - 1] = &quot;d&quot;</span>
<span class="gi">+    sum = n - 1</span>
<span class="gi">+    ind = 1</span>
<span class="gi">+    while sum &lt; m:</span>
<span class="gi">+        cs[ind] = &quot;d&quot;</span>
<span class="gi">+        sum += ind</span>
<span class="gi">+        ind += 1</span>
<span class="gi">+    if sum &gt; m:  # be sure not to change the first vertex</span>
<span class="gi">+        cs[sum - m] = &quot;i&quot;</span>
<span class="gi">+    return cs</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -448,4 +948,32 @@ def swap_d(cs, p_split=1.0, p_combine=1.0, seed=None):</span>
<span class="w"> </span>        Indicator of random number generation state.
<span class="w"> </span>        See :ref:`Randomness&lt;randomness&gt;`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # preprocess the creation sequence</span>
<span class="gi">+    dlist = [i for (i, node_type) in enumerate(cs[1:-1]) if node_type == &quot;d&quot;]</span>
<span class="gi">+    # split</span>
<span class="gi">+    if seed.random() &lt; p_split:</span>
<span class="gi">+        choice = seed.choice(dlist)</span>
<span class="gi">+        split_to = seed.choice(range(choice))</span>
<span class="gi">+        flip_side = choice - split_to</span>
<span class="gi">+        if split_to != flip_side and cs[split_to] == &quot;i&quot; and cs[flip_side] == &quot;i&quot;:</span>
<span class="gi">+            cs[choice] = &quot;i&quot;</span>
<span class="gi">+            cs[split_to] = &quot;d&quot;</span>
<span class="gi">+            cs[flip_side] = &quot;d&quot;</span>
<span class="gi">+            dlist.remove(choice)</span>
<span class="gi">+            # don&#39;t add or combine may reverse this action</span>
<span class="gi">+            # dlist.extend([split_to,flip_side])</span>
<span class="gi">+    #            print &gt;&gt;sys.stderr,&quot;split at %s to %s and %s&quot;%(choice,split_to,flip_side)</span>
<span class="gi">+    # combine</span>
<span class="gi">+    if seed.random() &lt; p_combine and dlist:</span>
<span class="gi">+        first_choice = seed.choice(dlist)</span>
<span class="gi">+        second_choice = seed.choice(dlist)</span>
<span class="gi">+        target = first_choice + second_choice</span>
<span class="gi">+        if target &gt;= len(cs) or cs[target] == &quot;d&quot; or first_choice == second_choice:</span>
<span class="gi">+            return cs</span>
<span class="gi">+        # OK to combine</span>
<span class="gi">+        cs[first_choice] = &quot;i&quot;</span>
<span class="gi">+        cs[second_choice] = &quot;i&quot;</span>
<span class="gi">+        cs[target] = &quot;d&quot;</span>
<span class="gi">+    #        print &gt;&gt;sys.stderr,&quot;combine %s and %s to make %s.&quot;%(first_choice,second_choice,target)</span>
<span class="gi">+</span>
<span class="gi">+    return cs</span>
<span class="gh">diff --git a/networkx/algorithms/time_dependent.py b/networkx/algorithms/time_dependent.py</span>
<span class="gh">index 6990d4d0b..d67cdcf0b 100644</span>
<span class="gd">--- a/networkx/algorithms/time_dependent.py</span>
<span class="gi">+++ b/networkx/algorithms/time_dependent.py</span>
<span class="gu">@@ -1,14 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Time dependent algorithms.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;cd_index&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;cd_index&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(node_attrs={&#39;time&#39;: None, &#39;weight&#39;: 1})</span>
<span class="gd">-def cd_index(G, node, time_delta, *, time=&#39;time&#39;, weight=None):</span>
<span class="gd">-    &quot;&quot;&quot;Compute the CD index for `node` within the graph `G`.</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(node_attrs={&quot;time&quot;: None, &quot;weight&quot;: 1})</span>
<span class="gi">+def cd_index(G, node, time_delta, *, time=&quot;time&quot;, weight=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Compute the CD index for `node` within the graph `G`.</span>

<span class="w"> </span>    Calculates the CD index for the given node of the graph,
<span class="w"> </span>    considering only its predecessors who have the `time` attribute
<span class="gu">@@ -85,7 +87,7 @@ def cd_index(G, node, time_delta, *, time=&#39;time&#39;, weight=None):</span>
<span class="w"> </span>    below:

<span class="w"> </span>    .. math::
<span class="gd">-        CD_{t}=\\frac{1}{n_{t}}\\sum_{i=1}^{n}\\frac{-2f_{it}b_{it}+f_{it}}{w_{it}},</span>
<span class="gi">+        CD_{t}=\frac{1}{n_{t}}\sum_{i=1}^{n}\frac{-2f_{it}b_{it}+f_{it}}{w_{it}},</span>

<span class="w"> </span>    where `f_{it}` equals 1 if `i` cites the focal patent else 0, `b_{it}` equals
<span class="w"> </span>    1 if `i` cites any of the focal patents successors else 0, `n_{t}` is the number
<span class="gu">@@ -108,4 +110,33 @@ def cd_index(G, node, time_delta, *, time=&#39;time&#39;, weight=None):</span>
<span class="w"> </span>           http://russellfunk.org/cdindex/static/papers/funk_ms_2017.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not all(time in G.nodes[n] for n in G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Not all nodes have a &#39;time&#39; attribute.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # get target_date</span>
<span class="gi">+        target_date = G.nodes[node][time] + time_delta</span>
<span class="gi">+        # keep the predecessors that existed before the target date</span>
<span class="gi">+        pred = {i for i in G.pred[node] if G.nodes[i][time] &lt;= target_date}</span>
<span class="gi">+    except:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;Addition and comparison are not supported between &#39;time_delta&#39; &quot;</span>
<span class="gi">+            &quot;and &#39;time&#39; types.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # -1 if any edge between node&#39;s predecessors and node&#39;s successors, else 1</span>
<span class="gi">+    b = [-1 if any(j in G[i] for j in G[node]) else 1 for i in pred]</span>
<span class="gi">+</span>
<span class="gi">+    # n is size of the union of the focal node&#39;s predecessors and its successors&#39; predecessors</span>
<span class="gi">+    n = len(pred.union(*(G.pred[s].keys() - {node} for s in G[node])))</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;The cd index cannot be defined.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # calculate cd index</span>
<span class="gi">+    if weight is None:</span>
<span class="gi">+        return round(sum(bi for bi in b) / n, 2)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # If a node has the specified weight attribute, its weight is used in the calculation</span>
<span class="gi">+        # otherwise, a weight of 1 is assumed for that node</span>
<span class="gi">+        weights = [G.nodes[i].get(weight, 1) for i in pred]</span>
<span class="gi">+        return round(sum(bi / wt for bi, wt in zip(b, weights)) / n, 2)</span>
<span class="gh">diff --git a/networkx/algorithms/tournament.py b/networkx/algorithms/tournament.py</span>
<span class="gh">index 81de98140..43a71faa7 100644</span>
<span class="gd">--- a/networkx/algorithms/tournament.py</span>
<span class="gi">+++ b/networkx/algorithms/tournament.py</span>
<span class="gu">@@ -21,11 +21,19 @@ To access the functions in this module, you must access them through the</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from itertools import combinations
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms.simple_paths import is_simple_path as is_path
<span class="w"> </span>from networkx.utils import arbitrary_element, not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;hamiltonian_path&#39;, &#39;is_reachable&#39;, &#39;is_strongly_connected&#39;,</span>
<span class="gd">-    &#39;is_tournament&#39;, &#39;random_tournament&#39;, &#39;score_sequence&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;hamiltonian_path&quot;,</span>
<span class="gi">+    &quot;is_reachable&quot;,</span>
<span class="gi">+    &quot;is_strongly_connected&quot;,</span>
<span class="gi">+    &quot;is_tournament&quot;,</span>
<span class="gi">+    &quot;random_tournament&quot;,</span>
<span class="gi">+    &quot;score_sequence&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def index_satisfying(iterable, condition):
<span class="gu">@@ -40,11 +48,23 @@ def index_satisfying(iterable, condition):</span>
<span class="w"> </span>    function raises :exc:`ValueError`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    # Pre-condition: iterable must not be empty.</span>
<span class="gi">+    for i, x in enumerate(iterable):</span>
<span class="gi">+        if condition(x):</span>
<span class="gi">+            return i</span>
<span class="gi">+    # If we reach the end of the iterable without finding an element</span>
<span class="gi">+    # that satisfies the condition, return the length of the iterable,</span>
<span class="gi">+    # which is one greater than the index of its last element. If the</span>
<span class="gi">+    # iterable was empty, `i` will not be defined, so we raise an</span>
<span class="gi">+    # exception.</span>
<span class="gi">+    try:</span>
<span class="gi">+        return i + 1</span>
<span class="gi">+    except NameError as err:</span>
<span class="gi">+        raise ValueError(&quot;iterable must be non-empty&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_tournament(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns True if and only if `G` is a tournament.
<span class="gu">@@ -75,11 +95,15 @@ def is_tournament(G):</span>
<span class="w"> </span>    the convention used here.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # In a tournament, there is exactly one directed edge joining each pair.</span>
<span class="gi">+    return (</span>
<span class="gi">+        all((v in G[u]) ^ (u in G[v]) for u, v in combinations(G, 2))</span>
<span class="gi">+        and nx.number_of_selfloops(G) == 0</span>
<span class="gi">+    )</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def hamiltonian_path(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns a Hamiltonian path in the given tournament graph.
<span class="gu">@@ -113,13 +137,23 @@ def hamiltonian_path(G):</span>
<span class="w"> </span>    $n$ is the number of nodes in the graph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return []</span>
<span class="gi">+    if len(G) == 1:</span>
<span class="gi">+        return [arbitrary_element(G)]</span>
<span class="gi">+    v = arbitrary_element(G)</span>
<span class="gi">+    hampath = hamiltonian_path(G.subgraph(set(G) - {v}))</span>
<span class="gi">+    # Get the index of the first node in the path that does *not* have</span>
<span class="gi">+    # an edge to `v`, then insert `v` before that node.</span>
<span class="gi">+    index = index_satisfying(hampath, lambda u: v not in G[u])</span>
<span class="gi">+    hampath.insert(index, v)</span>
<span class="gi">+    return hampath</span>


<span class="w"> </span>@py_random_state(1)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_tournament(n, seed=None):
<span class="gd">-    &quot;&quot;&quot;Returns a random tournament graph on `n` nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a random tournament graph on `n` nodes.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -138,16 +172,20 @@ def random_tournament(n, seed=None):</span>
<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="w"> </span>    This algorithm adds, for each pair of distinct nodes, an edge with
<span class="gd">-    uniformly random orientation. In other words, `\\binom{n}{2}` flips</span>
<span class="gi">+    uniformly random orientation. In other words, `\binom{n}{2}` flips</span>
<span class="w"> </span>    of an unbiased coin decide the orientations of the edges in the
<span class="w"> </span>    graph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Flip an unbiased coin for each pair of distinct nodes.</span>
<span class="gi">+    coins = (seed.random() for i in range((n * (n - 1)) // 2))</span>
<span class="gi">+    pairs = combinations(range(n), 2)</span>
<span class="gi">+    edges = ((u, v) if r &lt; 0.5 else (v, u) for (u, v), r in zip(pairs, coins))</span>
<span class="gi">+    return nx.DiGraph(edges)</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def score_sequence(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the score sequence for the given tournament graph.
<span class="gu">@@ -174,14 +212,14 @@ def score_sequence(G):</span>
<span class="w"> </span>    [1, 1, 2, 2]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sorted(d for v, d in G.out_degree())</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(preserve_edge_attrs={&#39;G&#39;: {&#39;weight&#39;: 1}})</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(preserve_edge_attrs={&quot;G&quot;: {&quot;weight&quot;: 1}})</span>
<span class="w"> </span>def tournament_matrix(G):
<span class="gd">-    &quot;&quot;&quot;Returns the tournament matrix for the given tournament graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the tournament matrix for the given tournament graph.</span>

<span class="w"> </span>    This function requires SciPy.

<span class="gu">@@ -191,11 +229,11 @@ def tournament_matrix(G):</span>
<span class="w"> </span>    .. math::

<span class="w"> </span>       T_{i j} =
<span class="gd">-       \\begin{cases}</span>
<span class="gd">-       +1 &amp; \\text{if } (i, j) \\in E \\\\</span>
<span class="gd">-       -1 &amp; \\text{if } (j, i) \\in E \\\\</span>
<span class="gd">-       0 &amp; \\text{if } i == j.</span>
<span class="gd">-       \\end{cases}</span>
<span class="gi">+       \begin{cases}</span>
<span class="gi">+       +1 &amp; \text{if } (i, j) \in E \\</span>
<span class="gi">+       -1 &amp; \text{if } (j, i) \in E \\</span>
<span class="gi">+       0 &amp; \text{if } i == j.</span>
<span class="gi">+       \end{cases}</span>

<span class="w"> </span>    An equivalent definition is `T = A - A^T`, where *A* is the
<span class="w"> </span>    adjacency matrix of the graph `G`.
<span class="gu">@@ -216,11 +254,12 @@ def tournament_matrix(G):</span>
<span class="w"> </span>        If SciPy is not available.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    A = nx.adjacency_matrix(G)</span>
<span class="gi">+    return A - A.T</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_reachable(G, s, t):
<span class="w"> </span>    &quot;&quot;&quot;Decides whether there is a path from `s` to `t` in the
<span class="gu">@@ -276,12 +315,41 @@ def is_reachable(G, s, t):</span>
<span class="w"> </span>           *Electronic Colloquium on Computational Complexity*. 2001.
<span class="w"> </span>           &lt;http://eccc.hpi-web.de/report/2001/092/&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def two_neighborhood(G, v):</span>
<span class="gi">+        &quot;&quot;&quot;Returns the set of nodes at distance at most two from `v`.</span>
<span class="gi">+</span>
<span class="gi">+        `G` must be a graph and `v` a node in that graph.</span>
<span class="gi">+</span>
<span class="gi">+        The returned set includes the nodes at distance zero (that is,</span>
<span class="gi">+        the node `v` itself), the nodes at distance one (that is, the</span>
<span class="gi">+        out-neighbors of `v`), and the nodes at distance two.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # TODO This is trivially parallelizable.</span>
<span class="gi">+        return {</span>
<span class="gi">+            x for x in G if x == v or x in G[v] or any(is_path(G, [v, z, x]) for z in G)</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def is_closed(G, nodes):</span>
<span class="gi">+        &quot;&quot;&quot;Decides whether the given set of nodes is closed.</span>
<span class="gi">+</span>
<span class="gi">+        A set *S* of nodes is *closed* if for each node *u* in the graph</span>
<span class="gi">+        not in *S* and for each node *v* in *S*, there is an edge from</span>
<span class="gi">+        *u* to *v*.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # TODO This is trivially parallelizable.</span>
<span class="gi">+        return all(v in G[u] for u in set(G) - nodes for v in nodes)</span>
<span class="gi">+</span>
<span class="gi">+    # TODO This is trivially parallelizable.</span>
<span class="gi">+    neighborhoods = [two_neighborhood(G, v) for v in G]</span>
<span class="gi">+    return all(not (is_closed(G, S) and s in S and t not in S) for S in neighborhoods)</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(name=&#39;tournament_is_strongly_connected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;tournament_is_strongly_connected&quot;)</span>
<span class="w"> </span>def is_strongly_connected(G):
<span class="w"> </span>    &quot;&quot;&quot;Decides whether the given tournament is strongly connected.

<span class="gu">@@ -334,4 +402,5 @@ def is_strongly_connected(G):</span>
<span class="w"> </span>           &lt;http://eccc.hpi-web.de/report/2001/092/&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO This is trivially parallelizable.</span>
<span class="gi">+    return all(is_reachable(G, u, v) for u in G for v in G)</span>
<span class="gh">diff --git a/networkx/algorithms/traversal/beamsearch.py b/networkx/algorithms/traversal/beamsearch.py</span>
<span class="gh">index 05b79ba54..ab90f44ae 100644</span>
<span class="gd">--- a/networkx/algorithms/traversal/beamsearch.py</span>
<span class="gi">+++ b/networkx/algorithms/traversal/beamsearch.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Basic algorithms for breadth-first searching the nodes of a graph.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;bfs_beam_edges&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;bfs_beam_edges&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -59,4 +60,30 @@ def bfs_beam_edges(G, source, value, width=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(nx.bfs_beam_edges(G, source=0, value=centrality.get, width=3))
<span class="w"> </span>    [(0, 2), (0, 1), (0, 8), (2, 32), (1, 13), (8, 33)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if width is None:</span>
<span class="gi">+        width = len(G)</span>
<span class="gi">+</span>
<span class="gi">+    def successors(v):</span>
<span class="gi">+        &quot;&quot;&quot;Returns a list of the best neighbors of a node.</span>
<span class="gi">+</span>
<span class="gi">+        `v` is a node in the graph `G`.</span>
<span class="gi">+</span>
<span class="gi">+        The &quot;best&quot; neighbors are chosen according to the `value`</span>
<span class="gi">+        function (higher is better). Only the `width` best neighbors of</span>
<span class="gi">+        `v` are returned.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # TODO The Python documentation states that for small values, it</span>
<span class="gi">+        # is better to use `heapq.nlargest`. We should determine the</span>
<span class="gi">+        # threshold at which its better to use `heapq.nlargest()`</span>
<span class="gi">+        # instead of `sorted()[:]` and apply that optimization here.</span>
<span class="gi">+        #</span>
<span class="gi">+        # If `width` is greater than the number of neighbors of `v`, all</span>
<span class="gi">+        # neighbors are returned by the semantics of slicing in</span>
<span class="gi">+        # Python. This occurs in the special case that the user did not</span>
<span class="gi">+        # specify a `width`: in this case all neighbors are always</span>
<span class="gi">+        # returned, so this is just a (slower) implementation of</span>
<span class="gi">+        # `bfs_edges(G, source)` but with a sorted enqueue step.</span>
<span class="gi">+        return iter(sorted(G.neighbors(v), key=value, reverse=True)[:width])</span>
<span class="gi">+</span>
<span class="gi">+    yield from nx.generic_bfs_edges(G, source, successors)</span>
<span class="gh">diff --git a/networkx/algorithms/traversal/breadth_first_search.py b/networkx/algorithms/traversal/breadth_first_search.py</span>
<span class="gh">index 3e1cee697..b87cca124 100644</span>
<span class="gd">--- a/networkx/algorithms/traversal/breadth_first_search.py</span>
<span class="gi">+++ b/networkx/algorithms/traversal/breadth_first_search.py</span>
<span class="gu">@@ -1,14 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Basic algorithms for breadth-first searching the nodes of a graph.&quot;&quot;&quot;
<span class="w"> </span>from collections import deque
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;bfs_edges&#39;, &#39;bfs_tree&#39;, &#39;bfs_predecessors&#39;, &#39;bfs_successors&#39;,</span>
<span class="gd">-    &#39;descendants_at_distance&#39;, &#39;bfs_layers&#39;, &#39;bfs_labeled_edges&#39;,</span>
<span class="gd">-    &#39;generic_bfs_edges&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;bfs_edges&quot;,</span>
<span class="gi">+    &quot;bfs_tree&quot;,</span>
<span class="gi">+    &quot;bfs_predecessors&quot;,</span>
<span class="gi">+    &quot;bfs_successors&quot;,</span>
<span class="gi">+    &quot;descendants_at_distance&quot;,</span>
<span class="gi">+    &quot;bfs_layers&quot;,</span>
<span class="gi">+    &quot;bfs_labeled_edges&quot;,</span>
<span class="gi">+    &quot;generic_bfs_edges&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gd">-def generic_bfs_edges(G, source, neighbors=None, depth_limit=None,</span>
<span class="gd">-    sort_neighbors=None):</span>
<span class="gi">+def generic_bfs_edges(G, source, neighbors=None, depth_limit=None, sort_neighbors=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over edges in a breadth-first search.

<span class="w"> </span>    The breadth-first search begins at `source` and enqueues the
<span class="gu">@@ -85,7 +93,40 @@ def generic_bfs_edges(G, source, neighbors=None, depth_limit=None,</span>
<span class="w"> </span>    .. _PADS: http://www.ics.uci.edu/~eppstein/PADS/BFS.py
<span class="w"> </span>    .. _Depth-limited-search: https://en.wikipedia.org/wiki/Depth-limited_search
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if neighbors is None:</span>
<span class="gi">+        neighbors = G.neighbors</span>
<span class="gi">+    if sort_neighbors is not None:</span>
<span class="gi">+        import warnings</span>
<span class="gi">+</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;The sort_neighbors parameter is deprecated and will be removed\n&quot;</span>
<span class="gi">+                &quot;in NetworkX 3.4, use the neighbors parameter instead.&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        _neighbors = neighbors</span>
<span class="gi">+        neighbors = lambda node: iter(sort_neighbors(_neighbors(node)))</span>
<span class="gi">+    if depth_limit is None:</span>
<span class="gi">+        depth_limit = len(G)</span>
<span class="gi">+</span>
<span class="gi">+    seen = {source}</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    depth = 0</span>
<span class="gi">+    next_parents_children = [(source, neighbors(source))]</span>
<span class="gi">+    while next_parents_children and depth &lt; depth_limit:</span>
<span class="gi">+        this_parents_children = next_parents_children</span>
<span class="gi">+        next_parents_children = []</span>
<span class="gi">+        for parent, children in this_parents_children:</span>
<span class="gi">+            for child in children:</span>
<span class="gi">+                if child not in seen:</span>
<span class="gi">+                    seen.add(child)</span>
<span class="gi">+                    next_parents_children.append((child, neighbors(child)))</span>
<span class="gi">+                    yield parent, child</span>
<span class="gi">+            if len(seen) == n:</span>
<span class="gi">+                return</span>
<span class="gi">+        depth += 1</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -164,7 +205,17 @@ def bfs_edges(G, source, reverse=False, depth_limit=None, sort_neighbors=None):</span>
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.edgebfs.edge_bfs`

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if reverse and G.is_directed():</span>
<span class="gi">+        successors = G.predecessors</span>
<span class="gi">+    else:</span>
<span class="gi">+        successors = G.neighbors</span>
<span class="gi">+</span>
<span class="gi">+    if sort_neighbors is not None:</span>
<span class="gi">+        yield from generic_bfs_edges(</span>
<span class="gi">+            G, source, lambda node: iter(sort_neighbors(successors(node))), depth_limit</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield from generic_bfs_edges(G, source, successors, depth_limit)</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -222,7 +273,17 @@ def bfs_tree(G, source, reverse=False, depth_limit=None, sort_neighbors=None):</span>
<span class="w"> </span>    bfs_edges
<span class="w"> </span>    edge_bfs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    T = nx.DiGraph()</span>
<span class="gi">+    T.add_node(source)</span>
<span class="gi">+    edges_gen = bfs_edges(</span>
<span class="gi">+        G,</span>
<span class="gi">+        source,</span>
<span class="gi">+        reverse=reverse,</span>
<span class="gi">+        depth_limit=depth_limit,</span>
<span class="gi">+        sort_neighbors=sort_neighbors,</span>
<span class="gi">+    )</span>
<span class="gi">+    T.add_edges_from(edges_gen)</span>
<span class="gi">+    return T</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -285,7 +346,10 @@ def bfs_predecessors(G, source, depth_limit=None, sort_neighbors=None):</span>
<span class="w"> </span>    bfs_edges
<span class="w"> </span>    edge_bfs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for s, t in bfs_edges(</span>
<span class="gi">+        G, source, depth_limit=depth_limit, sort_neighbors=sort_neighbors</span>
<span class="gi">+    ):</span>
<span class="gi">+        yield (t, s)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -348,7 +412,18 @@ def bfs_successors(G, source, depth_limit=None, sort_neighbors=None):</span>
<span class="w"> </span>    bfs_edges
<span class="w"> </span>    edge_bfs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent = source</span>
<span class="gi">+    children = []</span>
<span class="gi">+    for p, c in bfs_edges(</span>
<span class="gi">+        G, source, depth_limit=depth_limit, sort_neighbors=sort_neighbors</span>
<span class="gi">+    ):</span>
<span class="gi">+        if p == parent:</span>
<span class="gi">+            children.append(c)</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield (parent, children)</span>
<span class="gi">+        children = [c]</span>
<span class="gi">+        parent = p</span>
<span class="gi">+    yield (parent, children)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -380,13 +455,33 @@ def bfs_layers(G, sources):</span>
<span class="w"> </span>    &gt;&gt;&gt; dict(enumerate(nx.bfs_layers(H, [1, 6])))
<span class="w"> </span>    {0: [1, 6], 1: [0, 3, 4, 2], 2: [5]}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sources in G:</span>
<span class="gi">+        sources = [sources]</span>
<span class="gi">+</span>
<span class="gi">+    current_layer = list(sources)</span>
<span class="gi">+    visited = set(sources)</span>
<span class="gi">+</span>
<span class="gi">+    for source in current_layer:</span>
<span class="gi">+        if source not in G:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;The node {source} is not in the graph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # this is basically BFS, except that the current layer only stores the nodes at</span>
<span class="gi">+    # same distance from sources at each iteration</span>
<span class="gi">+    while current_layer:</span>
<span class="gi">+        yield current_layer</span>
<span class="gi">+        next_layer = []</span>
<span class="gi">+        for node in current_layer:</span>
<span class="gi">+            for child in G[node]:</span>
<span class="gi">+                if child not in visited:</span>
<span class="gi">+                    visited.add(child)</span>
<span class="gi">+                    next_layer.append(child)</span>
<span class="gi">+        current_layer = next_layer</span>


<span class="gd">-REVERSE_EDGE = &#39;reverse&#39;</span>
<span class="gd">-TREE_EDGE = &#39;tree&#39;</span>
<span class="gd">-FORWARD_EDGE = &#39;forward&#39;</span>
<span class="gd">-LEVEL_EDGE = &#39;level&#39;</span>
<span class="gi">+REVERSE_EDGE = &quot;reverse&quot;</span>
<span class="gi">+TREE_EDGE = &quot;tree&quot;</span>
<span class="gi">+FORWARD_EDGE = &quot;forward&quot;</span>
<span class="gi">+LEVEL_EDGE = &quot;level&quot;</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -430,7 +525,38 @@ def bfs_labeled_edges(G, sources):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(nx.bfs_labeled_edges(G, [0, 1]))
<span class="w"> </span>    [(0, 1, &#39;level&#39;), (0, 2, &#39;tree&#39;), (1, 2, &#39;forward&#39;)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sources in G:</span>
<span class="gi">+        sources = [sources]</span>
<span class="gi">+</span>
<span class="gi">+    neighbors = G._adj</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    visited = set()</span>
<span class="gi">+    visit = visited.discard if directed else visited.add</span>
<span class="gi">+    # We use visited in a negative sense, so the visited set stays empty for the</span>
<span class="gi">+    # directed case and level edges are reported on their first occurrence in</span>
<span class="gi">+    # the undirected case.  Note our use of visited.discard -- this is built-in</span>
<span class="gi">+    # thus somewhat faster than a python-defined def nop(x): pass</span>
<span class="gi">+    depth = {s: 0 for s in sources}</span>
<span class="gi">+    queue = deque(depth.items())</span>
<span class="gi">+    push = queue.append</span>
<span class="gi">+    pop = queue.popleft</span>
<span class="gi">+    while queue:</span>
<span class="gi">+        u, du = pop()</span>
<span class="gi">+        for v in neighbors[u]:</span>
<span class="gi">+            if v not in depth:</span>
<span class="gi">+                depth[v] = dv = du + 1</span>
<span class="gi">+                push((v, dv))</span>
<span class="gi">+                yield u, v, TREE_EDGE</span>
<span class="gi">+            else:</span>
<span class="gi">+                dv = depth[v]</span>
<span class="gi">+                if du == dv:</span>
<span class="gi">+                    if v not in visited:</span>
<span class="gi">+                        yield u, v, LEVEL_EDGE</span>
<span class="gi">+                elif du &lt; dv:</span>
<span class="gi">+                    yield u, v, FORWARD_EDGE</span>
<span class="gi">+                elif directed:</span>
<span class="gi">+                    yield u, v, REVERSE_EDGE</span>
<span class="gi">+        visit(u)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -463,4 +589,11 @@ def descendants_at_distance(G, source, distance):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.descendants_at_distance(H, 5, 1)
<span class="w"> </span>    set()
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if source not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;The node {source} is not in the graph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    bfs_generator = nx.bfs_layers(G, source)</span>
<span class="gi">+    for i, layer in enumerate(bfs_generator):</span>
<span class="gi">+        if i == distance:</span>
<span class="gi">+            return set(layer)</span>
<span class="gi">+    return set()</span>
<span class="gh">diff --git a/networkx/algorithms/traversal/depth_first_search.py b/networkx/algorithms/traversal/depth_first_search.py</span>
<span class="gh">index 104f282d5..3ca0f91d9 100644</span>
<span class="gd">--- a/networkx/algorithms/traversal/depth_first_search.py</span>
<span class="gi">+++ b/networkx/algorithms/traversal/depth_first_search.py</span>
<span class="gu">@@ -1,8 +1,17 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Basic algorithms for depth-first searching the nodes of a graph.&quot;&quot;&quot;
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;dfs_edges&#39;, &#39;dfs_tree&#39;, &#39;dfs_predecessors&#39;, &#39;dfs_successors&#39;,</span>
<span class="gd">-    &#39;dfs_preorder_nodes&#39;, &#39;dfs_postorder_nodes&#39;, &#39;dfs_labeled_edges&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;dfs_edges&quot;,</span>
<span class="gi">+    &quot;dfs_tree&quot;,</span>
<span class="gi">+    &quot;dfs_predecessors&quot;,</span>
<span class="gi">+    &quot;dfs_successors&quot;,</span>
<span class="gi">+    &quot;dfs_preorder_nodes&quot;,</span>
<span class="gi">+    &quot;dfs_postorder_nodes&quot;,</span>
<span class="gi">+    &quot;dfs_labeled_edges&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -65,7 +74,41 @@ def dfs_edges(G, source=None, depth_limit=None, *, sort_neighbors=None):</span>
<span class="w"> </span>    .. [1] http://www.ics.uci.edu/~eppstein/PADS
<span class="w"> </span>    .. [2] https://en.wikipedia.org/wiki/Depth-limited_search
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if source is None:</span>
<span class="gi">+        # edges for all components</span>
<span class="gi">+        nodes = G</span>
<span class="gi">+    else:</span>
<span class="gi">+        # edges for components with source</span>
<span class="gi">+        nodes = [source]</span>
<span class="gi">+    if depth_limit is None:</span>
<span class="gi">+        depth_limit = len(G)</span>
<span class="gi">+</span>
<span class="gi">+    get_children = (</span>
<span class="gi">+        G.neighbors</span>
<span class="gi">+        if sort_neighbors is None</span>
<span class="gi">+        else lambda n: iter(sort_neighbors(G.neighbors(n)))</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    visited = set()</span>
<span class="gi">+    for start in nodes:</span>
<span class="gi">+        if start in visited:</span>
<span class="gi">+            continue</span>
<span class="gi">+        visited.add(start)</span>
<span class="gi">+        stack = [(start, get_children(start))]</span>
<span class="gi">+        depth_now = 1</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            parent, children = stack[-1]</span>
<span class="gi">+            for child in children:</span>
<span class="gi">+                if child not in visited:</span>
<span class="gi">+                    yield parent, child</span>
<span class="gi">+                    visited.add(child)</span>
<span class="gi">+                    if depth_now &lt; depth_limit:</span>
<span class="gi">+                        stack.append((child, get_children(child)))</span>
<span class="gi">+                        depth_now += 1</span>
<span class="gi">+                        break</span>
<span class="gi">+            else:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+                depth_now -= 1</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gu">@@ -110,7 +153,13 @@ def dfs_tree(G, source=None, depth_limit=None, *, sort_neighbors=None):</span>
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    T = nx.DiGraph()</span>
<span class="gi">+    if source is None:</span>
<span class="gi">+        T.add_nodes_from(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        T.add_node(source)</span>
<span class="gi">+    T.add_edges_from(dfs_edges(G, source, depth_limit, sort_neighbors=sort_neighbors))</span>
<span class="gi">+    return T</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -169,7 +218,10 @@ def dfs_predecessors(G, source=None, depth_limit=None, *, sort_neighbors=None):</span>
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return {</span>
<span class="gi">+        t: s</span>
<span class="gi">+        for s, t in dfs_edges(G, source, depth_limit, sort_neighbors=sort_neighbors)</span>
<span class="gi">+    }</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -228,12 +280,19 @@ def dfs_successors(G, source=None, depth_limit=None, *, sort_neighbors=None):</span>
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    d = defaultdict(list)</span>
<span class="gi">+    for s, t in dfs_edges(</span>
<span class="gi">+        G,</span>
<span class="gi">+        source=source,</span>
<span class="gi">+        depth_limit=depth_limit,</span>
<span class="gi">+        sort_neighbors=sort_neighbors,</span>
<span class="gi">+    ):</span>
<span class="gi">+        d[s].append(t)</span>
<span class="gi">+    return dict(d)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gd">-def dfs_postorder_nodes(G, source=None, depth_limit=None, *, sort_neighbors</span>
<span class="gd">-    =None):</span>
<span class="gi">+def dfs_postorder_nodes(G, source=None, depth_limit=None, *, sort_neighbors=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate nodes in a depth-first-search post-ordering starting at source.

<span class="w"> </span>    Parameters
<span class="gu">@@ -285,12 +344,14 @@ def dfs_postorder_nodes(G, source=None, depth_limit=None, *, sort_neighbors</span>
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = nx.dfs_labeled_edges(</span>
<span class="gi">+        G, source=source, depth_limit=depth_limit, sort_neighbors=sort_neighbors</span>
<span class="gi">+    )</span>
<span class="gi">+    return (v for u, v, d in edges if d == &quot;reverse&quot;)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gd">-def dfs_preorder_nodes(G, source=None, depth_limit=None, *, sort_neighbors=None</span>
<span class="gd">-    ):</span>
<span class="gi">+def dfs_preorder_nodes(G, source=None, depth_limit=None, *, sort_neighbors=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate nodes in a depth-first-search pre-ordering starting at source.

<span class="w"> </span>    Parameters
<span class="gu">@@ -342,12 +403,14 @@ def dfs_preorder_nodes(G, source=None, depth_limit=None, *, sort_neighbors=None</span>
<span class="w"> </span>    dfs_labeled_edges
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.breadth_first_search.bfs_edges`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = nx.dfs_labeled_edges(</span>
<span class="gi">+        G, source=source, depth_limit=depth_limit, sort_neighbors=sort_neighbors</span>
<span class="gi">+    )</span>
<span class="gi">+    return (v for u, v, d in edges if d == &quot;forward&quot;)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gd">-def dfs_labeled_edges(G, source=None, depth_limit=None, *, sort_neighbors=None</span>
<span class="gd">-    ):</span>
<span class="gi">+def dfs_labeled_edges(G, source=None, depth_limit=None, *, sort_neighbors=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over edges in a depth-first-search (DFS) labeled by type.

<span class="w"> </span>    Parameters
<span class="gu">@@ -418,4 +481,48 @@ def dfs_labeled_edges(G, source=None, depth_limit=None, *, sort_neighbors=None</span>
<span class="w"> </span>    dfs_preorder_nodes
<span class="w"> </span>    dfs_postorder_nodes
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Based on http://www.ics.uci.edu/~eppstein/PADS/DFS.py</span>
<span class="gi">+    # by D. Eppstein, July 2004.</span>
<span class="gi">+    if source is None:</span>
<span class="gi">+        # edges for all components</span>
<span class="gi">+        nodes = G</span>
<span class="gi">+    else:</span>
<span class="gi">+        # edges for components with source</span>
<span class="gi">+        nodes = [source]</span>
<span class="gi">+    if depth_limit is None:</span>
<span class="gi">+        depth_limit = len(G)</span>
<span class="gi">+</span>
<span class="gi">+    get_children = (</span>
<span class="gi">+        G.neighbors</span>
<span class="gi">+        if sort_neighbors is None</span>
<span class="gi">+        else lambda n: iter(sort_neighbors(G.neighbors(n)))</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    visited = set()</span>
<span class="gi">+    for start in nodes:</span>
<span class="gi">+        if start in visited:</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield start, start, &quot;forward&quot;</span>
<span class="gi">+        visited.add(start)</span>
<span class="gi">+        stack = [(start, get_children(start))]</span>
<span class="gi">+        depth_now = 1</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            parent, children = stack[-1]</span>
<span class="gi">+            for child in children:</span>
<span class="gi">+                if child in visited:</span>
<span class="gi">+                    yield parent, child, &quot;nontree&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield parent, child, &quot;forward&quot;</span>
<span class="gi">+                    visited.add(child)</span>
<span class="gi">+                    if depth_now &lt; depth_limit:</span>
<span class="gi">+                        stack.append((child, iter(get_children(child))))</span>
<span class="gi">+                        depth_now += 1</span>
<span class="gi">+                        break</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield parent, child, &quot;reverse-depth_limit&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+                depth_now -= 1</span>
<span class="gi">+                if stack:</span>
<span class="gi">+                    yield stack[-1][0], parent, &quot;reverse&quot;</span>
<span class="gi">+        yield start, start, &quot;reverse&quot;</span>
<span class="gh">diff --git a/networkx/algorithms/traversal/edgebfs.py b/networkx/algorithms/traversal/edgebfs.py</span>
<span class="gh">index 52b0e9277..484ae12b5 100644</span>
<span class="gd">--- a/networkx/algorithms/traversal/edgebfs.py</span>
<span class="gi">+++ b/networkx/algorithms/traversal/edgebfs.py</span>
<span class="gu">@@ -7,10 +7,13 @@ Algorithms for a breadth-first traversal of edges in a graph.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections import deque
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-FORWARD = &#39;forward&#39;</span>
<span class="gd">-REVERSE = &#39;reverse&#39;</span>
<span class="gd">-__all__ = [&#39;edge_bfs&#39;]</span>
<span class="gi">+</span>
<span class="gi">+FORWARD = &quot;forward&quot;</span>
<span class="gi">+REVERSE = &quot;reverse&quot;</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;edge_bfs&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -101,4 +104,74 @@ def edge_bfs(G, source=None, orientation=None):</span>
<span class="w"> </span>    edge_dfs

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodes = list(G.nbunch_iter(source))</span>
<span class="gi">+    if not nodes:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    kwds = {&quot;data&quot;: False}</span>
<span class="gi">+    if G.is_multigraph() is True:</span>
<span class="gi">+        kwds[&quot;keys&quot;] = True</span>
<span class="gi">+</span>
<span class="gi">+    # set up edge lookup</span>
<span class="gi">+    if orientation is None:</span>
<span class="gi">+</span>
<span class="gi">+        def edges_from(node):</span>
<span class="gi">+            return iter(G.edges(node, **kwds))</span>
<span class="gi">+</span>
<span class="gi">+    elif not directed or orientation == &quot;original&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        def edges_from(node):</span>
<span class="gi">+            for e in G.edges(node, **kwds):</span>
<span class="gi">+                yield e + (FORWARD,)</span>
<span class="gi">+</span>
<span class="gi">+    elif orientation == &quot;reverse&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        def edges_from(node):</span>
<span class="gi">+            for e in G.in_edges(node, **kwds):</span>
<span class="gi">+                yield e + (REVERSE,)</span>
<span class="gi">+</span>
<span class="gi">+    elif orientation == &quot;ignore&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        def edges_from(node):</span>
<span class="gi">+            for e in G.edges(node, **kwds):</span>
<span class="gi">+                yield e + (FORWARD,)</span>
<span class="gi">+            for e in G.in_edges(node, **kwds):</span>
<span class="gi">+                yield e + (REVERSE,)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;invalid orientation argument.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        neighbors = G.successors</span>
<span class="gi">+</span>
<span class="gi">+        def edge_id(edge):</span>
<span class="gi">+            # remove direction indicator</span>
<span class="gi">+            return edge[:-1] if orientation is not None else edge</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        neighbors = G.neighbors</span>
<span class="gi">+</span>
<span class="gi">+        def edge_id(edge):</span>
<span class="gi">+            return (frozenset(edge[:2]),) + edge[2:]</span>
<span class="gi">+</span>
<span class="gi">+    check_reverse = directed and orientation in (&quot;reverse&quot;, &quot;ignore&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # start BFS</span>
<span class="gi">+    visited_nodes = set(nodes)</span>
<span class="gi">+    visited_edges = set()</span>
<span class="gi">+    queue = deque([(n, edges_from(n)) for n in nodes])</span>
<span class="gi">+    while queue:</span>
<span class="gi">+        parent, children_edges = queue.popleft()</span>
<span class="gi">+        for edge in children_edges:</span>
<span class="gi">+            if check_reverse and edge[-1] == REVERSE:</span>
<span class="gi">+                child = edge[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                child = edge[1]</span>
<span class="gi">+            if child not in visited_nodes:</span>
<span class="gi">+                visited_nodes.add(child)</span>
<span class="gi">+                queue.append((child, edges_from(child)))</span>
<span class="gi">+            edgeid = edge_id(edge)</span>
<span class="gi">+            if edgeid not in visited_edges:</span>
<span class="gi">+                visited_edges.add(edgeid)</span>
<span class="gi">+                yield edge</span>
<span class="gh">diff --git a/networkx/algorithms/traversal/edgedfs.py b/networkx/algorithms/traversal/edgedfs.py</span>
<span class="gh">index a681b37dc..010f68246 100644</span>
<span class="gd">--- a/networkx/algorithms/traversal/edgedfs.py</span>
<span class="gi">+++ b/networkx/algorithms/traversal/edgedfs.py</span>
<span class="gu">@@ -7,9 +7,11 @@ Algorithms for a depth-first traversal of edges in a graph.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-FORWARD = &#39;forward&#39;</span>
<span class="gd">-REVERSE = &#39;reverse&#39;</span>
<span class="gd">-__all__ = [&#39;edge_dfs&#39;]</span>
<span class="gi">+</span>
<span class="gi">+FORWARD = &quot;forward&quot;</span>
<span class="gi">+REVERSE = &quot;reverse&quot;</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;edge_dfs&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -89,4 +91,85 @@ def edge_dfs(G, source=None, orientation=None):</span>
<span class="w"> </span>    :func:`~networkx.algorithms.traversal.depth_first_search.dfs_edges`

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodes = list(G.nbunch_iter(source))</span>
<span class="gi">+    if not nodes:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    kwds = {&quot;data&quot;: False}</span>
<span class="gi">+    if G.is_multigraph() is True:</span>
<span class="gi">+        kwds[&quot;keys&quot;] = True</span>
<span class="gi">+</span>
<span class="gi">+    # set up edge lookup</span>
<span class="gi">+    if orientation is None:</span>
<span class="gi">+</span>
<span class="gi">+        def edges_from(node):</span>
<span class="gi">+            return iter(G.edges(node, **kwds))</span>
<span class="gi">+</span>
<span class="gi">+    elif not directed or orientation == &quot;original&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        def edges_from(node):</span>
<span class="gi">+            for e in G.edges(node, **kwds):</span>
<span class="gi">+                yield e + (FORWARD,)</span>
<span class="gi">+</span>
<span class="gi">+    elif orientation == &quot;reverse&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        def edges_from(node):</span>
<span class="gi">+            for e in G.in_edges(node, **kwds):</span>
<span class="gi">+                yield e + (REVERSE,)</span>
<span class="gi">+</span>
<span class="gi">+    elif orientation == &quot;ignore&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        def edges_from(node):</span>
<span class="gi">+            for e in G.edges(node, **kwds):</span>
<span class="gi">+                yield e + (FORWARD,)</span>
<span class="gi">+            for e in G.in_edges(node, **kwds):</span>
<span class="gi">+                yield e + (REVERSE,)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;invalid orientation argument.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # set up formation of edge_id to easily look up if edge already returned</span>
<span class="gi">+    if directed:</span>
<span class="gi">+</span>
<span class="gi">+        def edge_id(edge):</span>
<span class="gi">+            # remove direction indicator</span>
<span class="gi">+            return edge[:-1] if orientation is not None else edge</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def edge_id(edge):</span>
<span class="gi">+            # single id for undirected requires frozenset on nodes</span>
<span class="gi">+            return (frozenset(edge[:2]),) + edge[2:]</span>
<span class="gi">+</span>
<span class="gi">+    # Basic setup</span>
<span class="gi">+    check_reverse = directed and orientation in (&quot;reverse&quot;, &quot;ignore&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    visited_edges = set()</span>
<span class="gi">+    visited_nodes = set()</span>
<span class="gi">+    edges = {}</span>
<span class="gi">+</span>
<span class="gi">+    # start DFS</span>
<span class="gi">+    for start_node in nodes:</span>
<span class="gi">+        stack = [start_node]</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            current_node = stack[-1]</span>
<span class="gi">+            if current_node not in visited_nodes:</span>
<span class="gi">+                edges[current_node] = edges_from(current_node)</span>
<span class="gi">+                visited_nodes.add(current_node)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                edge = next(edges[current_node])</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                # No more edges from the current node.</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+            else:</span>
<span class="gi">+                edgeid = edge_id(edge)</span>
<span class="gi">+                if edgeid not in visited_edges:</span>
<span class="gi">+                    visited_edges.add(edgeid)</span>
<span class="gi">+                    # Mark the traversed &quot;to&quot; node as to-be-explored.</span>
<span class="gi">+                    if check_reverse and edge[-1] == REVERSE:</span>
<span class="gi">+                        stack.append(edge[0])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        stack.append(edge[1])</span>
<span class="gi">+                    yield edge</span>
<span class="gh">diff --git a/networkx/algorithms/tree/branchings.py b/networkx/algorithms/tree/branchings.py</span>
<span class="gh">index 35cadd659..6c0e34906 100644</span>
<span class="gd">--- a/networkx/algorithms/tree/branchings.py</span>
<span class="gi">+++ b/networkx/algorithms/tree/branchings.py</span>
<span class="gu">@@ -7,25 +7,73 @@ This implementation is based on:</span>
<span class="w"> </span>    233–240. URL: http://archive.org/details/jresv71Bn4p233

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+# TODO: Implement method from Gabow, Galil, Spence and Tarjan:</span>
<span class="gi">+#</span>
<span class="gi">+# @article{</span>
<span class="gi">+#    year={1986},</span>
<span class="gi">+#    issn={0209-9683},</span>
<span class="gi">+#    journal={Combinatorica},</span>
<span class="gi">+#    volume={6},</span>
<span class="gi">+#    number={2},</span>
<span class="gi">+#    doi={10.1007/BF02579168},</span>
<span class="gi">+#    title={Efficient algorithms for finding minimum spanning trees in</span>
<span class="gi">+#        undirected and directed graphs},</span>
<span class="gi">+#    url={https://doi.org/10.1007/BF02579168},</span>
<span class="gi">+#    publisher={Springer-Verlag},</span>
<span class="gi">+#    keywords={68 B 15; 68 C 05},</span>
<span class="gi">+#    author={Gabow, Harold N. and Galil, Zvi and Spencer, Thomas and Tarjan,</span>
<span class="gi">+#        Robert E.},</span>
<span class="gi">+#    pages={109-122},</span>
<span class="gi">+#    language={English}</span>
<span class="gi">+# }</span>
<span class="w"> </span>import string
<span class="w"> </span>from dataclasses import dataclass, field
<span class="w"> </span>from operator import itemgetter
<span class="w"> </span>from queue import PriorityQueue
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gi">+</span>
<span class="w"> </span>from .recognition import is_arborescence, is_branching
<span class="gd">-__all__ = [&#39;branching_weight&#39;, &#39;greedy_branching&#39;, &#39;maximum_branching&#39;,</span>
<span class="gd">-    &#39;minimum_branching&#39;, &#39;minimal_branching&#39;,</span>
<span class="gd">-    &#39;maximum_spanning_arborescence&#39;, &#39;minimum_spanning_arborescence&#39;,</span>
<span class="gd">-    &#39;ArborescenceIterator&#39;, &#39;Edmonds&#39;]</span>
<span class="gd">-KINDS = {&#39;max&#39;, &#39;min&#39;}</span>
<span class="gd">-STYLES = {&#39;branching&#39;: &#39;branching&#39;, &#39;arborescence&#39;: &#39;arborescence&#39;,</span>
<span class="gd">-    &#39;spanning arborescence&#39;: &#39;arborescence&#39;}</span>
<span class="gd">-INF = float(&#39;inf&#39;)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs={&#39;attr&#39;: &#39;default&#39;})</span>
<span class="gd">-def branching_weight(G, attr=&#39;weight&#39;, default=1):</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;branching_weight&quot;,</span>
<span class="gi">+    &quot;greedy_branching&quot;,</span>
<span class="gi">+    &quot;maximum_branching&quot;,</span>
<span class="gi">+    &quot;minimum_branching&quot;,</span>
<span class="gi">+    &quot;minimal_branching&quot;,</span>
<span class="gi">+    &quot;maximum_spanning_arborescence&quot;,</span>
<span class="gi">+    &quot;minimum_spanning_arborescence&quot;,</span>
<span class="gi">+    &quot;ArborescenceIterator&quot;,</span>
<span class="gi">+    &quot;Edmonds&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+KINDS = {&quot;max&quot;, &quot;min&quot;}</span>
<span class="gi">+</span>
<span class="gi">+STYLES = {</span>
<span class="gi">+    &quot;branching&quot;: &quot;branching&quot;,</span>
<span class="gi">+    &quot;arborescence&quot;: &quot;arborescence&quot;,</span>
<span class="gi">+    &quot;spanning arborescence&quot;: &quot;arborescence&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+INF = float(&quot;inf&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@py_random_state(1)</span>
<span class="gi">+def random_string(L=15, seed=None):</span>
<span class="gi">+    return &quot;&quot;.join([seed.choice(string.ascii_letters) for n in range(L)])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _min_weight(weight):</span>
<span class="gi">+    return -weight</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _max_weight(weight):</span>
<span class="gi">+    return weight</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;attr&quot;: &quot;default&quot;})</span>
<span class="gi">+def branching_weight(G, attr=&quot;weight&quot;, default=1):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the total weight of a branching.

<span class="gu">@@ -55,12 +103,12 @@ def branching_weight(G, attr=&#39;weight&#39;, default=1):</span>
<span class="w"> </span>    11

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(edge[2].get(attr, default) for edge in G.edges(data=True))</span>


<span class="w"> </span>@py_random_state(4)
<span class="gd">-@nx._dispatchable(edge_attrs={&#39;attr&#39;: &#39;default&#39;}, returns_graph=True)</span>
<span class="gd">-def greedy_branching(G, attr=&#39;weight&#39;, default=1, kind=&#39;max&#39;, seed=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;attr&quot;: &quot;default&quot;}, returns_graph=True)</span>
<span class="gi">+def greedy_branching(G, attr=&quot;weight&quot;, default=1, kind=&quot;max&quot;, seed=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a branching obtained through a greedy algorithm.

<span class="gu">@@ -93,7 +141,50 @@ def greedy_branching(G, attr=&#39;weight&#39;, default=1, kind=&#39;max&#39;, seed=None):</span>
<span class="w"> </span>        The greedily obtained branching.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if kind not in KINDS:</span>
<span class="gi">+        raise nx.NetworkXException(&quot;Unknown value for `kind`.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if kind == &quot;min&quot;:</span>
<span class="gi">+        reverse = False</span>
<span class="gi">+    else:</span>
<span class="gi">+        reverse = True</span>
<span class="gi">+</span>
<span class="gi">+    if attr is None:</span>
<span class="gi">+        # Generate a random string the graph probably won&#39;t have.</span>
<span class="gi">+        attr = random_string(seed=seed)</span>
<span class="gi">+</span>
<span class="gi">+    edges = [(u, v, data.get(attr, default)) for (u, v, data) in G.edges(data=True)]</span>
<span class="gi">+</span>
<span class="gi">+    # We sort by weight, but also by nodes to normalize behavior across runs.</span>
<span class="gi">+    try:</span>
<span class="gi">+        edges.sort(key=itemgetter(2, 0, 1), reverse=reverse)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        # This will fail in Python 3.x if the nodes are of varying types.</span>
<span class="gi">+        # In that case, we use the arbitrary order.</span>
<span class="gi">+        edges.sort(key=itemgetter(2), reverse=reverse)</span>
<span class="gi">+</span>
<span class="gi">+    # The branching begins with a forest of no edges.</span>
<span class="gi">+    B = nx.DiGraph()</span>
<span class="gi">+    B.add_nodes_from(G)</span>
<span class="gi">+</span>
<span class="gi">+    # Now we add edges greedily so long we maintain the branching.</span>
<span class="gi">+    uf = nx.utils.UnionFind()</span>
<span class="gi">+    for i, (u, v, w) in enumerate(edges):</span>
<span class="gi">+        if uf[u] == uf[v]:</span>
<span class="gi">+            # Adding this edge would form a directed cycle.</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif B.in_degree(v) == 1:</span>
<span class="gi">+            # The edge would increase the degree to be greater than one.</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If attr was None, then don&#39;t insert weights...</span>
<span class="gi">+            data = {}</span>
<span class="gi">+            if attr is not None:</span>
<span class="gi">+                data[attr] = w</span>
<span class="gi">+            B.add_edge(u, v, **data)</span>
<span class="gi">+            uf.union(u, v)</span>
<span class="gi">+</span>
<span class="gi">+    return B</span>


<span class="w"> </span>class MultiDiGraph_EdgeKey(nx.MultiDiGraph):
<span class="gu">@@ -115,20 +206,60 @@ class MultiDiGraph_EdgeKey(nx.MultiDiGraph):</span>
<span class="w"> </span>    def __init__(self, incoming_graph_data=None, **attr):
<span class="w"> </span>        cls = super()
<span class="w"> </span>        cls.__init__(incoming_graph_data=incoming_graph_data, **attr)
<span class="gi">+</span>
<span class="w"> </span>        self._cls = cls
<span class="w"> </span>        self.edge_index = {}
<span class="gi">+</span>
<span class="w"> </span>        import warnings
<span class="gd">-        msg = (</span>
<span class="gd">-            &#39;MultiDiGraph_EdgeKey has been deprecated and will be removed in NetworkX 3.4.&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+</span>
<span class="gi">+        msg = &quot;MultiDiGraph_EdgeKey has been deprecated and will be removed in NetworkX 3.4.&quot;</span>
<span class="w"> </span>        warnings.warn(msg, DeprecationWarning)

<span class="gi">+    def remove_node(self, n):</span>
<span class="gi">+        keys = set()</span>
<span class="gi">+        for keydict in self.pred[n].values():</span>
<span class="gi">+            keys.update(keydict)</span>
<span class="gi">+        for keydict in self.succ[n].values():</span>
<span class="gi">+            keys.update(keydict)</span>
<span class="gi">+</span>
<span class="gi">+        for key in keys:</span>
<span class="gi">+            del self.edge_index[key]</span>
<span class="gi">+</span>
<span class="gi">+        self._cls.remove_node(n)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_nodes_from(self, nbunch):</span>
<span class="gi">+        for n in nbunch:</span>
<span class="gi">+            self.remove_node(n)</span>
<span class="gi">+</span>
<span class="w"> </span>    def add_edge(self, u_for_edge, v_for_edge, key_for_edge, **attr):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Key is now required.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        u, v, key = u_for_edge, v_for_edge, key_for_edge</span>
<span class="gi">+        if key in self.edge_index:</span>
<span class="gi">+            uu, vv, _ = self.edge_index[key]</span>
<span class="gi">+            if (u != uu) or (v != vv):</span>
<span class="gi">+                raise Exception(f&quot;Key {key!r} is already in use.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self._cls.add_edge(u, v, key, **attr)</span>
<span class="gi">+        self.edge_index[key] = (u, v, self.succ[u][v][key])</span>
<span class="gi">+</span>
<span class="gi">+    def add_edges_from(self, ebunch_to_add, **attr):</span>
<span class="gi">+        for u, v, k, d in ebunch_to_add:</span>
<span class="gi">+            self.add_edge(u, v, k, **d)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_edge_with_key(self, key):</span>
<span class="gi">+        try:</span>
<span class="gi">+            u, v, _ = self.edge_index[key]</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise KeyError(f&quot;Invalid edge key {key!r}&quot;) from err</span>
<span class="gi">+        else:</span>
<span class="gi">+            del self.edge_index[key]</span>
<span class="gi">+            self._cls.remove_edge(u, v, key)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_edges_from(self, ebunch):</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>def get_path(G, u, v):
<span class="gu">@@ -139,7 +270,20 @@ def get_path(G, u, v):</span>
<span class="w"> </span>    MultiDiGraph_EdgeKey.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodes = nx.shortest_path(G, u, v)</span>
<span class="gi">+</span>
<span class="gi">+    # We are guaranteed that there is only one edge connected every node</span>
<span class="gi">+    # in the shortest path.</span>
<span class="gi">+</span>
<span class="gi">+    def first_key(i, vv):</span>
<span class="gi">+        # Needed for 2.x/3.x compatibility</span>
<span class="gi">+        keys = G[nodes[i]][vv].keys()</span>
<span class="gi">+        # Normalize behavior</span>
<span class="gi">+        keys = list(keys)</span>
<span class="gi">+        return keys[0]</span>
<span class="gi">+</span>
<span class="gi">+    edges = [first_key(i, vv) for i, vv in enumerate(nodes[1:])]</span>
<span class="gi">+    return nodes, edges</span>


<span class="w"> </span>class Edmonds:
<span class="gu">@@ -166,17 +310,23 @@ class Edmonds:</span>

<span class="w"> </span>    def __init__(self, G, seed=None):
<span class="w"> </span>        self.G_original = G
<span class="gi">+</span>
<span class="gi">+        # Need to fix this. We need the whole tree.</span>
<span class="w"> </span>        self.store = True
<span class="gi">+</span>
<span class="gi">+        # The final answer.</span>
<span class="w"> </span>        self.edges = []
<span class="gd">-        self.template = random_string(seed=seed) + &#39;_{0}&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Since we will be creating graphs with new nodes, we need to make</span>
<span class="gi">+        # sure that our node names do not conflict with the real node names.</span>
<span class="gi">+        self.template = random_string(seed=seed) + &quot;_{0}&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>        import warnings
<span class="gd">-        msg = (</span>
<span class="gd">-            &#39;Edmonds has been deprecated and will be removed in NetworkX 3.4. Please use the appropriate minimum or maximum branching or arborescence function directly.&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+</span>
<span class="gi">+        msg = &quot;Edmonds has been deprecated and will be removed in NetworkX 3.4. Please use the appropriate minimum or maximum branching or arborescence function directly.&quot;</span>
<span class="w"> </span>        warnings.warn(msg, DeprecationWarning)

<span class="gd">-    def _init(self, attr, default, kind, style, preserve_attrs, seed, partition</span>
<span class="gd">-        ):</span>
<span class="gi">+    def _init(self, attr, default, kind, style, preserve_attrs, seed, partition):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        So we need the code in _init and find_optimum to successfully run edmonds algorithm.
<span class="w"> </span>        Responsibilities of the _init function:
<span class="gu">@@ -190,10 +340,93 @@ class Edmonds:</span>
<span class="w"> </span>          other edge attributes if we set preserve_attrs = True.
<span class="w"> </span>        - Setup the buckets and union find data structures required for the algorithm.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def find_optimum(self, attr=&#39;weight&#39;, default=1, kind=&#39;max&#39;, style=</span>
<span class="gd">-        &#39;branching&#39;, preserve_attrs=False, partition=None, seed=None):</span>
<span class="gi">+        if kind not in KINDS:</span>
<span class="gi">+            raise nx.NetworkXException(&quot;Unknown value for `kind`.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Store inputs.</span>
<span class="gi">+        self.attr = attr</span>
<span class="gi">+        self.default = default</span>
<span class="gi">+        self.kind = kind</span>
<span class="gi">+        self.style = style</span>
<span class="gi">+</span>
<span class="gi">+        # Determine how we are going to transform the weights.</span>
<span class="gi">+        if kind == &quot;min&quot;:</span>
<span class="gi">+            self.trans = trans = _min_weight</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.trans = trans = _max_weight</span>
<span class="gi">+</span>
<span class="gi">+        if attr is None:</span>
<span class="gi">+            # Generate a random attr the graph probably won&#39;t have.</span>
<span class="gi">+            attr = random_string(seed=seed)</span>
<span class="gi">+</span>
<span class="gi">+        # This is the actual attribute used by the algorithm.</span>
<span class="gi">+        self._attr = attr</span>
<span class="gi">+</span>
<span class="gi">+        # This attribute is used to store whether a particular edge is still</span>
<span class="gi">+        # a candidate. We generate a random attr to remove clashes with</span>
<span class="gi">+        # preserved edges</span>
<span class="gi">+        self.candidate_attr = &quot;candidate_&quot; + random_string(seed=seed)</span>
<span class="gi">+</span>
<span class="gi">+        # The object we manipulate at each step is a multidigraph.</span>
<span class="gi">+        self.G = G = MultiDiGraph_EdgeKey()</span>
<span class="gi">+        self.G.__networkx_cache__ = None  # Disable caching</span>
<span class="gi">+        for key, (u, v, data) in enumerate(self.G_original.edges(data=True)):</span>
<span class="gi">+            d = {attr: trans(data.get(attr, default))}</span>
<span class="gi">+</span>
<span class="gi">+            if data.get(partition) is not None:</span>
<span class="gi">+                d[partition] = data.get(partition)</span>
<span class="gi">+</span>
<span class="gi">+            if preserve_attrs:</span>
<span class="gi">+                for d_k, d_v in data.items():</span>
<span class="gi">+                    if d_k != attr:</span>
<span class="gi">+                        d[d_k] = d_v</span>
<span class="gi">+</span>
<span class="gi">+            G.add_edge(u, v, key, **d)</span>
<span class="gi">+</span>
<span class="gi">+        self.level = 0</span>
<span class="gi">+</span>
<span class="gi">+        # These are the &quot;buckets&quot; from the paper.</span>
<span class="gi">+        #</span>
<span class="gi">+        # As in the paper, G^i are modified versions of the original graph.</span>
<span class="gi">+        # D^i and E^i are nodes and edges of the maximal edges that are</span>
<span class="gi">+        # consistent with G^i. These are dashed edges in figures A-F of the</span>
<span class="gi">+        # paper. In this implementation, we store D^i and E^i together as a</span>
<span class="gi">+        # graph B^i. So we will have strictly more B^i than the paper does.</span>
<span class="gi">+        self.B = MultiDiGraph_EdgeKey()</span>
<span class="gi">+        self.B.edge_index = {}</span>
<span class="gi">+        self.graphs = []  # G^i</span>
<span class="gi">+        self.branchings = []  # B^i</span>
<span class="gi">+        self.uf = nx.utils.UnionFind()</span>
<span class="gi">+</span>
<span class="gi">+        # A list of lists of edge indexes. Each list is a circuit for graph G^i.</span>
<span class="gi">+        # Note the edge list will not, in general, be a circuit in graph G^0.</span>
<span class="gi">+        self.circuits = []</span>
<span class="gi">+        # Stores the index of the minimum edge in the circuit found in G^i</span>
<span class="gi">+        # and B^i. The ordering of the edges seems to preserve the weight</span>
<span class="gi">+        # ordering from G^0. So even if the circuit does not form a circuit</span>
<span class="gi">+        # in G^0, it is still true that the minimum edge of the circuit in</span>
<span class="gi">+        # G^i is still the minimum edge in circuit G^0 (despite their weights</span>
<span class="gi">+        # being different).</span>
<span class="gi">+        self.minedge_circuit = []</span>
<span class="gi">+</span>
<span class="gi">+    # TODO: separate each step into an inner function. Then the overall loop would become</span>
<span class="gi">+    # while True:</span>
<span class="gi">+    #     step_I1()</span>
<span class="gi">+    #     if cycle detected:</span>
<span class="gi">+    #         step_I2()</span>
<span class="gi">+    #     elif every node of G is in D and E is a branching</span>
<span class="gi">+    #         break</span>
<span class="gi">+</span>
<span class="gi">+    def find_optimum(</span>
<span class="gi">+        self,</span>
<span class="gi">+        attr=&quot;weight&quot;,</span>
<span class="gi">+        default=1,</span>
<span class="gi">+        kind=&quot;max&quot;,</span>
<span class="gi">+        style=&quot;branching&quot;,</span>
<span class="gi">+        preserve_attrs=False,</span>
<span class="gi">+        partition=None,</span>
<span class="gi">+        seed=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a branching from G.

<span class="gu">@@ -228,13 +461,741 @@ class Edmonds:</span>
<span class="w"> </span>            The branching.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._init(attr, default, kind, style, preserve_attrs, seed, partition)</span>
<span class="gi">+        uf = self.uf</span>
<span class="gi">+</span>
<span class="gi">+        # This enormous while loop could use some refactoring...</span>
<span class="gi">+</span>
<span class="gi">+        G, B = self.G, self.B</span>
<span class="gi">+        D = set()</span>
<span class="gi">+        nodes = iter(list(G.nodes()))</span>
<span class="gi">+        attr = self._attr</span>
<span class="gi">+</span>
<span class="gi">+        def desired_edge(v):</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Find the edge directed toward v with maximal weight.</span>
<span class="gi">+</span>
<span class="gi">+            If an edge partition exists in this graph, return the included edge</span>
<span class="gi">+            if it exists and no not return any excluded edges. There can only</span>
<span class="gi">+            be one included edge for each vertex otherwise the edge partition is</span>
<span class="gi">+            empty.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            edge = None</span>
<span class="gi">+            weight = -INF</span>
<span class="gi">+            for u, _, key, data in G.in_edges(v, data=True, keys=True):</span>
<span class="gi">+                # Skip excluded edges</span>
<span class="gi">+                if data.get(partition) == nx.EdgePartition.EXCLUDED:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                new_weight = data[attr]</span>
<span class="gi">+                # Return the included edge</span>
<span class="gi">+                if data.get(partition) == nx.EdgePartition.INCLUDED:</span>
<span class="gi">+                    weight = new_weight</span>
<span class="gi">+                    edge = (u, v, key, new_weight, data)</span>
<span class="gi">+                    return edge, weight</span>
<span class="gi">+                # Find the best open edge</span>
<span class="gi">+                if new_weight &gt; weight:</span>
<span class="gi">+                    weight = new_weight</span>
<span class="gi">+                    edge = (u, v, key, new_weight, data)</span>
<span class="gi">+</span>
<span class="gi">+            return edge, weight</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # (I1): Choose a node v in G^i not in D^i.</span>
<span class="gi">+            try:</span>
<span class="gi">+                v = next(nodes)</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                # If there are no more new nodes to consider, then we *should*</span>
<span class="gi">+                # meet the break condition (b) from the paper:</span>
<span class="gi">+                #   (b) every node of G^i is in D^i and E^i is a branching</span>
<span class="gi">+                # Construction guarantees that it&#39;s a branching.</span>
<span class="gi">+                assert len(G) == len(B)</span>
<span class="gi">+                if len(B):</span>
<span class="gi">+                    assert is_branching(B)</span>
<span class="gi">+</span>
<span class="gi">+                if self.store:</span>
<span class="gi">+                    self.graphs.append(G.copy())</span>
<span class="gi">+                    self.branchings.append(B.copy())</span>
<span class="gi">+</span>
<span class="gi">+                    # Add these to keep the lengths equal. Element i is the</span>
<span class="gi">+                    # circuit at level i that was merged to form branching i+1.</span>
<span class="gi">+                    # There is no circuit for the last level.</span>
<span class="gi">+                    self.circuits.append([])</span>
<span class="gi">+                    self.minedge_circuit.append(None)</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                if v in D:</span>
<span class="gi">+                    # print(&quot;v in D&quot;, v)</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            # Put v into bucket D^i.</span>
<span class="gi">+            # print(f&quot;Adding node {v}&quot;)</span>
<span class="gi">+            D.add(v)</span>
<span class="gi">+            B.add_node(v)</span>
<span class="gi">+            # End (I1)</span>
<span class="gi">+</span>
<span class="gi">+            # Start cycle detection</span>
<span class="gi">+            edge, weight = desired_edge(v)</span>
<span class="gi">+            # print(f&quot;Max edge is {edge!r}&quot;)</span>
<span class="gi">+            if edge is None:</span>
<span class="gi">+                # If there is no edge, continue with a new node at (I1).</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Determine if adding the edge to E^i would mean its no longer</span>
<span class="gi">+                # a branching. Presently, v has indegree 0 in B---it is a root.</span>
<span class="gi">+                u = edge[0]</span>
<span class="gi">+</span>
<span class="gi">+                if uf[u] == uf[v]:</span>
<span class="gi">+                    # Then adding the edge will create a circuit. Then B</span>
<span class="gi">+                    # contains a unique path P from v to u. So condition (a)</span>
<span class="gi">+                    # from the paper does hold. We need to store the circuit</span>
<span class="gi">+                    # for future reference.</span>
<span class="gi">+                    Q_nodes, Q_edges = get_path(B, v, u)</span>
<span class="gi">+                    Q_edges.append(edge[2])  # Edge key</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Then B with the edge is still a branching and condition</span>
<span class="gi">+                    # (a) from the paper does not hold.</span>
<span class="gi">+                    Q_nodes, Q_edges = None, None</span>
<span class="gi">+                # End cycle detection</span>
<span class="gi">+</span>
<span class="gi">+                # THIS WILL PROBABLY BE REMOVED? MAYBE A NEW ARG FOR THIS FEATURE?</span>
<span class="gi">+                # Conditions for adding the edge.</span>
<span class="gi">+                # If weight &lt; 0, then it cannot help in finding a maximum branching.</span>
<span class="gi">+                # This is the root of the problem with minimum branching.</span>
<span class="gi">+                if self.style == &quot;branching&quot; and weight &lt;= 0:</span>
<span class="gi">+                    acceptable = False</span>
<span class="gi">+                else:</span>
<span class="gi">+                    acceptable = True</span>
<span class="gi">+</span>
<span class="gi">+                # print(f&quot;Edge is acceptable: {acceptable}&quot;)</span>
<span class="gi">+                if acceptable:</span>
<span class="gi">+                    dd = {attr: weight}</span>
<span class="gi">+                    if edge[4].get(partition) is not None:</span>
<span class="gi">+                        dd[partition] = edge[4].get(partition)</span>
<span class="gi">+                    B.add_edge(u, v, edge[2], **dd)</span>
<span class="gi">+                    G[u][v][edge[2]][self.candidate_attr] = True</span>
<span class="gi">+                    uf.union(u, v)</span>
<span class="gi">+                    if Q_edges is not None:</span>
<span class="gi">+                        # print(&quot;Edge introduced a simple cycle:&quot;)</span>
<span class="gi">+                        # print(Q_nodes, Q_edges)</span>
<span class="gi">+</span>
<span class="gi">+                        # Move to method</span>
<span class="gi">+                        # Previous meaning of u and v is no longer important.</span>
<span class="gi">+</span>
<span class="gi">+                        # Apply (I2).</span>
<span class="gi">+                        # Get the edge in the cycle with the minimum weight.</span>
<span class="gi">+                        # Also, save the incoming weights for each node.</span>
<span class="gi">+                        minweight = INF</span>
<span class="gi">+                        minedge = None</span>
<span class="gi">+                        Q_incoming_weight = {}</span>
<span class="gi">+                        for edge_key in Q_edges:</span>
<span class="gi">+                            u, v, data = B.edge_index[edge_key]</span>
<span class="gi">+                            # We cannot remove an included edges, even if it is</span>
<span class="gi">+                            # the minimum edge in the circuit</span>
<span class="gi">+                            w = data[attr]</span>
<span class="gi">+                            Q_incoming_weight[v] = w</span>
<span class="gi">+                            if data.get(partition) == nx.EdgePartition.INCLUDED:</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            if w &lt; minweight:</span>
<span class="gi">+                                minweight = w</span>
<span class="gi">+                                minedge = edge_key</span>
<span class="gi">+</span>
<span class="gi">+                        self.circuits.append(Q_edges)</span>
<span class="gi">+                        self.minedge_circuit.append(minedge)</span>
<span class="gi">+</span>
<span class="gi">+                        if self.store:</span>
<span class="gi">+                            self.graphs.append(G.copy())</span>
<span class="gi">+                        # Always need the branching with circuits.</span>
<span class="gi">+                        self.branchings.append(B.copy())</span>
<span class="gi">+</span>
<span class="gi">+                        # Now we mutate it.</span>
<span class="gi">+                        new_node = self.template.format(self.level)</span>
<span class="gi">+</span>
<span class="gi">+                        # print(minweight, minedge, Q_incoming_weight)</span>
<span class="gi">+</span>
<span class="gi">+                        G.add_node(new_node)</span>
<span class="gi">+                        new_edges = []</span>
<span class="gi">+                        for u, v, key, data in G.edges(data=True, keys=True):</span>
<span class="gi">+                            if u in Q_incoming_weight:</span>
<span class="gi">+                                if v in Q_incoming_weight:</span>
<span class="gi">+                                    # Circuit edge, do nothing for now.</span>
<span class="gi">+                                    # Eventually delete it.</span>
<span class="gi">+                                    continue</span>
<span class="gi">+                                else:</span>
<span class="gi">+                                    # Outgoing edge. Make it from new node</span>
<span class="gi">+                                    dd = data.copy()</span>
<span class="gi">+                                    new_edges.append((new_node, v, key, dd))</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                if v in Q_incoming_weight:</span>
<span class="gi">+                                    # Incoming edge. Change its weight</span>
<span class="gi">+                                    w = data[attr]</span>
<span class="gi">+                                    w += minweight - Q_incoming_weight[v]</span>
<span class="gi">+                                    dd = data.copy()</span>
<span class="gi">+                                    dd[attr] = w</span>
<span class="gi">+                                    new_edges.append((u, new_node, key, dd))</span>
<span class="gi">+                                else:</span>
<span class="gi">+                                    # Outside edge. No modification necessary.</span>
<span class="gi">+                                    continue</span>
<span class="gi">+</span>
<span class="gi">+                        G.remove_nodes_from(Q_nodes)</span>
<span class="gi">+                        B.remove_nodes_from(Q_nodes)</span>
<span class="gi">+                        D.difference_update(set(Q_nodes))</span>
<span class="gi">+</span>
<span class="gi">+                        for u, v, key, data in new_edges:</span>
<span class="gi">+                            G.add_edge(u, v, key, **data)</span>
<span class="gi">+                            if self.candidate_attr in data:</span>
<span class="gi">+                                del data[self.candidate_attr]</span>
<span class="gi">+                                B.add_edge(u, v, key, **data)</span>
<span class="gi">+                                uf.union(u, v)</span>
<span class="gi">+</span>
<span class="gi">+                        nodes = iter(list(G.nodes()))</span>
<span class="gi">+                        self.level += 1</span>
<span class="gi">+                    # END STEP (I2)?</span>
<span class="gi">+</span>
<span class="gi">+        # (I3) Branch construction.</span>
<span class="gi">+        # print(self.level)</span>
<span class="gi">+        H = self.G_original.__class__()</span>
<span class="gi">+</span>
<span class="gi">+        def is_root(G, u, edgekeys):</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            Returns True if `u` is a root node in G.</span>
<span class="gi">+</span>
<span class="gi">+            Node `u` will be a root node if its in-degree, restricted to the</span>
<span class="gi">+            specified edges, is equal to 0.</span>
<span class="gi">+</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            if u not in G:</span>
<span class="gi">+                # print(G.nodes(), u)</span>
<span class="gi">+                raise Exception(f&quot;{u!r} not in G&quot;)</span>
<span class="gi">+            for v in G.pred[u]:</span>
<span class="gi">+                for edgekey in G.pred[u][v]:</span>
<span class="gi">+                    if edgekey in edgekeys:</span>
<span class="gi">+                        return False, edgekey</span>
<span class="gi">+            else:</span>
<span class="gi">+                return True, None</span>
<span class="gi">+</span>
<span class="gi">+        # Start with the branching edges in the last level.</span>
<span class="gi">+        edges = set(self.branchings[self.level].edge_index)</span>
<span class="gi">+        while self.level &gt; 0:</span>
<span class="gi">+            self.level -= 1</span>
<span class="gi">+</span>
<span class="gi">+            # The current level is i, and we start counting from 0.</span>
<span class="gi">+</span>
<span class="gi">+            # We need the node at level i+1 that results from merging a circuit</span>
<span class="gi">+            # at level i. randomname_0 is the first merged node and this</span>
<span class="gi">+            # happens at level 1. That is, randomname_0 is a node at level 1</span>
<span class="gi">+            # that results from merging a circuit at level 0.</span>
<span class="gi">+            merged_node = self.template.format(self.level)</span>
<span class="gi">+</span>
<span class="gi">+            # The circuit at level i that was merged as a node the graph</span>
<span class="gi">+            # at level i+1.</span>
<span class="gi">+            circuit = self.circuits[self.level]</span>
<span class="gi">+            # print</span>
<span class="gi">+            # print(merged_node, self.level, circuit)</span>
<span class="gi">+            # print(&quot;before&quot;, edges)</span>
<span class="gi">+            # Note, we ask if it is a root in the full graph, not the branching.</span>
<span class="gi">+            # The branching alone doesn&#39;t have all the edges.</span>
<span class="gi">+            isroot, edgekey = is_root(self.graphs[self.level + 1], merged_node, edges)</span>
<span class="gi">+            edges.update(circuit)</span>
<span class="gi">+            if isroot:</span>
<span class="gi">+                minedge = self.minedge_circuit[self.level]</span>
<span class="gi">+                if minedge is None:</span>
<span class="gi">+                    raise Exception</span>
<span class="gi">+</span>
<span class="gi">+                # Remove the edge in the cycle with minimum weight.</span>
<span class="gi">+                edges.remove(minedge)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # We have identified an edge at next higher level that</span>
<span class="gi">+                # transitions into the merged node at the level. That edge</span>
<span class="gi">+                # transitions to some corresponding node at the current level.</span>
<span class="gi">+                # We want to remove an edge from the cycle that transitions</span>
<span class="gi">+                # into the corresponding node.</span>
<span class="gi">+                # print(&quot;edgekey is: &quot;, edgekey)</span>
<span class="gi">+                # print(&quot;circuit is: &quot;, circuit)</span>
<span class="gi">+                # The branching at level i</span>
<span class="gi">+                G = self.graphs[self.level]</span>
<span class="gi">+                # print(G.edge_index)</span>
<span class="gi">+                target = G.edge_index[edgekey][1]</span>
<span class="gi">+                for edgekey in circuit:</span>
<span class="gi">+                    u, v, data = G.edge_index[edgekey]</span>
<span class="gi">+                    if v == target:</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise Exception(&quot;Couldn&#39;t find edge incoming to merged node.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                edges.remove(edgekey)</span>
<span class="gi">+</span>
<span class="gi">+        self.edges = edges</span>
<span class="gi">+</span>
<span class="gi">+        H.add_nodes_from(self.G_original)</span>
<span class="gi">+        for edgekey in edges:</span>
<span class="gi">+            u, v, d = self.graphs[0].edge_index[edgekey]</span>
<span class="gi">+            dd = {self.attr: self.trans(d[self.attr])}</span>
<span class="gi">+</span>
<span class="gi">+            # Optionally, preserve the other edge attributes of the original</span>
<span class="gi">+            # graph</span>
<span class="gi">+            if preserve_attrs:</span>
<span class="gi">+                for key, value in d.items():</span>
<span class="gi">+                    if key not in [self.attr, self.candidate_attr]:</span>
<span class="gi">+                        dd[key] = value</span>
<span class="gi">+</span>
<span class="gi">+            # TODO: make this preserve the key.</span>
<span class="gi">+            H.add_edge(u, v, **dd)</span>
<span class="gi">+</span>
<span class="gi">+        return H</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(preserve_edge_attrs=True, returns_graph=True)</span>
<span class="gi">+def maximum_branching(</span>
<span class="gi">+    G,</span>
<span class="gi">+    attr=&quot;weight&quot;,</span>
<span class="gi">+    default=1,</span>
<span class="gi">+    preserve_attrs=False,</span>
<span class="gi">+    partition=None,</span>
<span class="gi">+):</span>
<span class="gi">+    #######################################</span>
<span class="gi">+    ### Data Structure Helper Functions ###</span>
<span class="gi">+    #######################################</span>
<span class="gi">+</span>
<span class="gi">+    def edmonds_add_edge(G, edge_index, u, v, key, **d):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Adds an edge to `G` while also updating the edge index.</span>
<span class="gi">+</span>
<span class="gi">+        This algorithm requires the use of an external dictionary to track</span>
<span class="gi">+        the edge keys since it is possible that the source or destination</span>
<span class="gi">+        node of an edge will be changed and the default key-handling</span>
<span class="gi">+        capabilities of the MultiDiGraph class do not account for this.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        G : MultiDiGraph</span>
<span class="gi">+            The graph to insert an edge into.</span>
<span class="gi">+        edge_index : dict</span>
<span class="gi">+            A mapping from integers to the edges of the graph.</span>
<span class="gi">+        u : node</span>
<span class="gi">+            The source node of the new edge.</span>
<span class="gi">+        v : node</span>
<span class="gi">+            The destination node of the new edge.</span>
<span class="gi">+        key : int</span>
<span class="gi">+            The key to use from `edge_index`.</span>
<span class="gi">+        d : keyword arguments, optional</span>
<span class="gi">+            Other attributes to store on the new edge.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if key in edge_index:</span>
<span class="gi">+            uu, vv, _ = edge_index[key]</span>
<span class="gi">+            if (u != uu) or (v != vv):</span>
<span class="gi">+                raise Exception(f&quot;Key {key!r} is already in use.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        G.add_edge(u, v, key, **d)</span>
<span class="gi">+        edge_index[key] = (u, v, G.succ[u][v][key])</span>
<span class="gi">+</span>
<span class="gi">+    def edmonds_remove_node(G, edge_index, n):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Remove a node from the graph, updating the edge index to match.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        G : MultiDiGraph</span>
<span class="gi">+            The graph to remove an edge from.</span>
<span class="gi">+        edge_index : dict</span>
<span class="gi">+            A mapping from integers to the edges of the graph.</span>
<span class="gi">+        n : node</span>
<span class="gi">+            The node to remove from `G`.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        keys = set()</span>
<span class="gi">+        for keydict in G.pred[n].values():</span>
<span class="gi">+            keys.update(keydict)</span>
<span class="gi">+        for keydict in G.succ[n].values():</span>
<span class="gi">+            keys.update(keydict)</span>
<span class="gi">+</span>
<span class="gi">+        for key in keys:</span>
<span class="gi">+            del edge_index[key]</span>
<span class="gi">+</span>
<span class="gi">+        G.remove_node(n)</span>
<span class="gi">+</span>
<span class="gi">+    #######################</span>
<span class="gi">+    ### Algorithm Setup ###</span>
<span class="gi">+    #######################</span>
<span class="gi">+</span>
<span class="gi">+    # Pick an attribute name that the original graph is unlikly to have</span>
<span class="gi">+    candidate_attr = &quot;edmonds&#39; secret candidate attribute&quot;</span>
<span class="gi">+    new_node_base_name = &quot;edmonds new node base name &quot;</span>
<span class="gi">+</span>
<span class="gi">+    G_original = G</span>
<span class="gi">+    G = nx.MultiDiGraph()</span>
<span class="gi">+    G.__networkx_cache__ = None  # Disable caching</span>
<span class="gi">+</span>
<span class="gi">+    # A dict to reliably track mutations to the edges using the key of the edge.</span>
<span class="gi">+    G_edge_index = {}</span>
<span class="gi">+    # Each edge is given an arbitrary numerical key</span>
<span class="gi">+    for key, (u, v, data) in enumerate(G_original.edges(data=True)):</span>
<span class="gi">+        d = {attr: data.get(attr, default)}</span>
<span class="gi">+</span>
<span class="gi">+        if data.get(partition) is not None:</span>
<span class="gi">+            d[partition] = data.get(partition)</span>
<span class="gi">+</span>
<span class="gi">+        if preserve_attrs:</span>
<span class="gi">+            for d_k, d_v in data.items():</span>
<span class="gi">+                if d_k != attr:</span>
<span class="gi">+                    d[d_k] = d_v</span>
<span class="gi">+</span>
<span class="gi">+        edmonds_add_edge(G, G_edge_index, u, v, key, **d)</span>
<span class="gi">+</span>
<span class="gi">+    level = 0  # Stores the number of contracted nodes</span>
<span class="gi">+</span>
<span class="gi">+    # These are the buckets from the paper.</span>
<span class="gi">+    #</span>
<span class="gi">+    # In the paper, G^i are modified versions of the original graph.</span>
<span class="gi">+    # D^i and E^i are the nodes and edges of the maximal edges that are</span>
<span class="gi">+    # consistent with G^i. In this implementation, D^i and E^i are stored</span>
<span class="gi">+    # together as the graph B^i. We will have strictly more B^i then the</span>
<span class="gi">+    # paper will have.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Note that the data in graphs and branchings are tuples with the graph as</span>
<span class="gi">+    # the first element and the edge index as the second.</span>
<span class="gi">+    B = nx.MultiDiGraph()</span>
<span class="gi">+    B_edge_index = {}</span>
<span class="gi">+    graphs = []  # G^i list</span>
<span class="gi">+    branchings = []  # B^i list</span>
<span class="gi">+    selected_nodes = set()  # D^i bucket</span>
<span class="gi">+    uf = nx.utils.UnionFind()</span>
<span class="gi">+</span>
<span class="gi">+    # A list of lists of edge indices. Each list is a circuit for graph G^i.</span>
<span class="gi">+    # Note the edge list is not required to be a circuit in G^0.</span>
<span class="gi">+    circuits = []</span>
<span class="gi">+</span>
<span class="gi">+    # Stores the index of the minimum edge in the circuit found in G^i and B^i.</span>
<span class="gi">+    # The ordering of the edges seems to preserver the weight ordering from</span>
<span class="gi">+    # G^0. So even if the circuit does not form a circuit in G^0, it is still</span>
<span class="gi">+    # true that the minimum edges in circuit G^0 (despite their weights being</span>
<span class="gi">+    # different)</span>
<span class="gi">+    minedge_circuit = []</span>
<span class="gi">+</span>
<span class="gi">+    ###########################</span>
<span class="gi">+    ### Algorithm Structure ###</span>
<span class="gi">+    ###########################</span>
<span class="gi">+</span>
<span class="gi">+    # Each step listed in the algorithm is an inner function. Thus, the overall</span>
<span class="gi">+    # loop structure is:</span>
<span class="gi">+    #</span>
<span class="gi">+    # while True:</span>
<span class="gi">+    #     step_I1()</span>
<span class="gi">+    #     if cycle detected:</span>
<span class="gi">+    #         step_I2()</span>
<span class="gi">+    #     elif every node of G is in D and E is a branching:</span>
<span class="gi">+    #         break</span>
<span class="gi">+</span>
<span class="gi">+    ##################################</span>
<span class="gi">+    ### Algorithm Helper Functions ###</span>
<span class="gi">+    ##################################</span>
<span class="gi">+</span>
<span class="gi">+    def edmonds_find_desired_edge(v):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Find the edge directed towards v with maximal weight.</span>
<span class="gi">+</span>
<span class="gi">+        If an edge partition exists in this graph, return the included</span>
<span class="gi">+        edge if it exists and never return any excluded edge.</span>
<span class="gi">+</span>
<span class="gi">+        Note: There can only be one included edge for each vertex otherwise</span>
<span class="gi">+        the edge partition is empty.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        v : node</span>
<span class="gi">+            The node to search for the maximal weight incoming edge.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        edge = None</span>
<span class="gi">+        max_weight = -INF</span>
<span class="gi">+        for u, _, key, data in G.in_edges(v, data=True, keys=True):</span>
<span class="gi">+            # Skip excluded edges</span>
<span class="gi">+            if data.get(partition) == nx.EdgePartition.EXCLUDED:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            new_weight = data[attr]</span>
<span class="gi">+</span>
<span class="gi">+            # Return the included edge</span>
<span class="gi">+            if data.get(partition) == nx.EdgePartition.INCLUDED:</span>
<span class="gi">+                max_weight = new_weight</span>
<span class="gi">+                edge = (u, v, key, new_weight, data)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            # Find the best open edge</span>
<span class="gi">+            if new_weight &gt; max_weight:</span>
<span class="gi">+                max_weight = new_weight</span>
<span class="gi">+                edge = (u, v, key, new_weight, data)</span>
<span class="gi">+</span>
<span class="gi">+        return edge, max_weight</span>
<span class="gi">+</span>
<span class="gi">+    def edmonds_step_I2(v, desired_edge, level):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Perform step I2 from Edmonds&#39; paper</span>
<span class="gi">+</span>
<span class="gi">+        First, check if the last step I1 created a cycle. If it did not, do nothing.</span>
<span class="gi">+        If it did, store the cycle for later reference and contract it.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        v : node</span>
<span class="gi">+            The current node to consider</span>
<span class="gi">+        desired_edge : edge</span>
<span class="gi">+            The minimum desired edge to remove from the cycle.</span>
<span class="gi">+        level : int</span>
<span class="gi">+            The current level, i.e. the number of cycles that have already been removed.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        u = desired_edge[0]</span>
<span class="gi">+</span>
<span class="gi">+        Q_nodes = nx.shortest_path(B, v, u)</span>
<span class="gi">+        Q_edges = [</span>
<span class="gi">+            list(B[Q_nodes[i]][vv].keys())[0] for i, vv in enumerate(Q_nodes[1:])</span>
<span class="gi">+        ]</span>
<span class="gi">+        Q_edges.append(desired_edge[2])  # Add the new edge key to complete the circuit</span>
<span class="gi">+</span>
<span class="gi">+        # Get the edge in the circuit with the minimum weight.</span>
<span class="gi">+        # Also, save the incoming weights for each node.</span>
<span class="gi">+        minweight = INF</span>
<span class="gi">+        minedge = None</span>
<span class="gi">+        Q_incoming_weight = {}</span>
<span class="gi">+        for edge_key in Q_edges:</span>
<span class="gi">+            u, v, data = B_edge_index[edge_key]</span>
<span class="gi">+            w = data[attr]</span>
<span class="gi">+            # We cannot remove an included edge, even if it is the</span>
<span class="gi">+            # minimum edge in the circuit</span>
<span class="gi">+            Q_incoming_weight[v] = w</span>
<span class="gi">+            if data.get(partition) == nx.EdgePartition.INCLUDED:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if w &lt; minweight:</span>
<span class="gi">+                minweight = w</span>
<span class="gi">+                minedge = edge_key</span>
<span class="gi">+</span>
<span class="gi">+        circuits.append(Q_edges)</span>
<span class="gi">+        minedge_circuit.append(minedge)</span>
<span class="gi">+        graphs.append((G.copy(), G_edge_index.copy()))</span>
<span class="gi">+        branchings.append((B.copy(), B_edge_index.copy()))</span>
<span class="gi">+</span>
<span class="gi">+        # Mutate the graph to contract the circuit</span>
<span class="gi">+        new_node = new_node_base_name + str(level)</span>
<span class="gi">+        G.add_node(new_node)</span>
<span class="gi">+        new_edges = []</span>
<span class="gi">+        for u, v, key, data in G.edges(data=True, keys=True):</span>
<span class="gi">+            if u in Q_incoming_weight:</span>
<span class="gi">+                if v in Q_incoming_weight:</span>
<span class="gi">+                    # Circuit edge. For the moment do nothing,</span>
<span class="gi">+                    # eventually it will be removed.</span>
<span class="gi">+                    continue</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Outgoing edge from a node in the circuit.</span>
<span class="gi">+                    # Make it come from the new node instead</span>
<span class="gi">+                    dd = data.copy()</span>
<span class="gi">+                    new_edges.append((new_node, v, key, dd))</span>
<span class="gi">+            else:</span>
<span class="gi">+                if v in Q_incoming_weight:</span>
<span class="gi">+                    # Incoming edge to the circuit.</span>
<span class="gi">+                    # Update it&#39;s weight</span>
<span class="gi">+                    w = data[attr]</span>
<span class="gi">+                    w += minweight - Q_incoming_weight[v]</span>
<span class="gi">+                    dd = data.copy()</span>
<span class="gi">+                    dd[attr] = w</span>
<span class="gi">+                    new_edges.append((u, new_node, key, dd))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Outside edge. No modification needed</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+        for node in Q_nodes:</span>
<span class="gi">+            edmonds_remove_node(G, G_edge_index, node)</span>
<span class="gi">+            edmonds_remove_node(B, B_edge_index, node)</span>
<span class="gi">+</span>
<span class="gi">+        selected_nodes.difference_update(set(Q_nodes))</span>
<span class="gi">+</span>
<span class="gi">+        for u, v, key, data in new_edges:</span>
<span class="gi">+            edmonds_add_edge(G, G_edge_index, u, v, key, **data)</span>
<span class="gi">+            if candidate_attr in data:</span>
<span class="gi">+                del data[candidate_attr]</span>
<span class="gi">+                edmonds_add_edge(B, B_edge_index, u, v, key, **data)</span>
<span class="gi">+                uf.union(u, v)</span>
<span class="gi">+</span>
<span class="gi">+    def is_root(G, u, edgekeys):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Returns True if `u` is a root node in G.</span>
<span class="gi">+</span>
<span class="gi">+        Node `u` is a root node if its in-degree over the specified edges is zero.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        G : Graph</span>
<span class="gi">+            The current graph.</span>
<span class="gi">+        u : node</span>
<span class="gi">+            The node in `G` to check if it is a root.</span>
<span class="gi">+        edgekeys : iterable of edges</span>
<span class="gi">+            The edges for which to check if `u` is a root of.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if u not in G:</span>
<span class="gi">+            raise Exception(f&quot;{u!r} not in G&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for v in G.pred[u]:</span>
<span class="gi">+            for edgekey in G.pred[u][v]:</span>
<span class="gi">+                if edgekey in edgekeys:</span>
<span class="gi">+                    return False, edgekey</span>
<span class="gi">+        else:</span>
<span class="gi">+            return True, None</span>
<span class="gi">+</span>
<span class="gi">+    nodes = iter(list(G.nodes))</span>
<span class="gi">+    while True:</span>
<span class="gi">+        try:</span>
<span class="gi">+            v = next(nodes)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            # If there are no more new nodes to consider, then we should</span>
<span class="gi">+            # meet stopping condition (b) from the paper:</span>
<span class="gi">+            #   (b) every node of G^i is in D^i and E^i is a branching</span>
<span class="gi">+            assert len(G) == len(B)</span>
<span class="gi">+            if len(B):</span>
<span class="gi">+                assert is_branching(B)</span>
<span class="gi">+</span>
<span class="gi">+            graphs.append((G.copy(), G_edge_index.copy()))</span>
<span class="gi">+            branchings.append((B.copy(), B_edge_index.copy()))</span>
<span class="gi">+            circuits.append([])</span>
<span class="gi">+            minedge_circuit.append(None)</span>
<span class="gi">+</span>
<span class="gi">+            break</span>
<span class="gi">+        else:</span>
<span class="gi">+            #####################</span>
<span class="gi">+            ### BEGIN STEP I1 ###</span>
<span class="gi">+            #####################</span>
<span class="gi">+</span>
<span class="gi">+            # This is a very simple step, so I don&#39;t think it needs a method of it&#39;s own</span>
<span class="gi">+            if v in selected_nodes:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        selected_nodes.add(v)</span>
<span class="gi">+        B.add_node(v)</span>
<span class="gi">+        desired_edge, desired_edge_weight = edmonds_find_desired_edge(v)</span>
<span class="gi">+</span>
<span class="gi">+        # There might be no desired edge if all edges are excluded or</span>
<span class="gi">+        # v is the last node to be added to B, the ultimate root of the branching</span>
<span class="gi">+        if desired_edge is not None and desired_edge_weight &gt; 0:</span>
<span class="gi">+            u = desired_edge[0]</span>
<span class="gi">+            # Flag adding the edge will create a circuit before merging the two</span>
<span class="gi">+            # connected components of u and v in B</span>
<span class="gi">+            circuit = uf[u] == uf[v]</span>
<span class="gi">+            dd = {attr: desired_edge_weight}</span>
<span class="gi">+            if desired_edge[4].get(partition) is not None:</span>
<span class="gi">+                dd[partition] = desired_edge[4].get(partition)</span>
<span class="gi">+</span>
<span class="gi">+            edmonds_add_edge(B, B_edge_index, u, v, desired_edge[2], **dd)</span>
<span class="gi">+            G[u][v][desired_edge[2]][candidate_attr] = True</span>
<span class="gi">+            uf.union(u, v)</span>
<span class="gi">+</span>
<span class="gi">+            ###################</span>
<span class="gi">+            ### END STEP I1 ###</span>
<span class="gi">+            ###################</span>
<span class="gi">+</span>
<span class="gi">+            #####################</span>
<span class="gi">+            ### BEGIN STEP I2 ###</span>
<span class="gi">+            #####################</span>
<span class="gi">+</span>
<span class="gi">+            if circuit:</span>
<span class="gi">+                edmonds_step_I2(v, desired_edge, level)</span>
<span class="gi">+                nodes = iter(list(G.nodes()))</span>
<span class="gi">+                level += 1</span>
<span class="gi">+</span>
<span class="gi">+            ###################</span>
<span class="gi">+            ### END STEP I2 ###</span>
<span class="gi">+            ###################</span>
<span class="gi">+</span>
<span class="gi">+    #####################</span>
<span class="gi">+    ### BEGIN STEP I3 ###</span>
<span class="gi">+    #####################</span>
<span class="gi">+</span>
<span class="gi">+    # Create a new graph of the same class as the input graph</span>
<span class="gi">+    H = G_original.__class__()</span>
<span class="gi">+</span>
<span class="gi">+    # Start with the branching edges in the last level.</span>
<span class="gi">+    edges = set(branchings[level][1])</span>
<span class="gi">+    while level &gt; 0:</span>
<span class="gi">+        level -= 1</span>
<span class="gi">+</span>
<span class="gi">+        # The current level is i, and we start counting from 0.</span>
<span class="gi">+        #</span>
<span class="gi">+        # We need the node at level i+1 that results from merging a circuit</span>
<span class="gi">+        # at level i. basename_0 is the first merged node and this happens</span>
<span class="gi">+        # at level 1. That is basename_0 is a node at level 1 that results</span>
<span class="gi">+        # from merging a circuit at level 0.</span>
<span class="gi">+</span>
<span class="gi">+        merged_node = new_node_base_name + str(level)</span>
<span class="gi">+        circuit = circuits[level]</span>
<span class="gi">+        isroot, edgekey = is_root(graphs[level + 1][0], merged_node, edges)</span>
<span class="gi">+        edges.update(circuit)</span>
<span class="gi">+</span>
<span class="gi">+        if isroot:</span>
<span class="gi">+            minedge = minedge_circuit[level]</span>
<span class="gi">+            if minedge is None:</span>
<span class="gi">+                raise Exception</span>
<span class="gi">+</span>
<span class="gi">+            # Remove the edge in the cycle with minimum weight</span>
<span class="gi">+            edges.remove(minedge)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # We have identified an edge at the next higher level that</span>
<span class="gi">+            # transitions into the merged node at this level. That edge</span>
<span class="gi">+            # transitions to some corresponding node at the current level.</span>
<span class="gi">+            #</span>
<span class="gi">+            # We want to remove an edge from the cycle that transitions</span>
<span class="gi">+            # into the corresponding node, otherwise the result would not</span>
<span class="gi">+            # be a branching.</span>
<span class="gi">+</span>
<span class="gi">+            G, G_edge_index = graphs[level]</span>
<span class="gi">+            target = G_edge_index[edgekey][1]</span>
<span class="gi">+            for edgekey in circuit:</span>
<span class="gi">+                u, v, data = G_edge_index[edgekey]</span>
<span class="gi">+                if v == target:</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise Exception(&quot;Couldn&#39;t find edge incoming to merged node.&quot;)</span>

<span class="gi">+            edges.remove(edgekey)</span>

<span class="gd">-@nx._dispatchable(preserve_edge_attrs=True, mutates_input=True,</span>
<span class="gd">-    returns_graph=True)</span>
<span class="gd">-def minimal_branching(G, /, *, attr=&#39;weight&#39;, default=1, preserve_attrs=</span>
<span class="gd">-    False, partition=None):</span>
<span class="gi">+    H.add_nodes_from(G_original)</span>
<span class="gi">+    for edgekey in edges:</span>
<span class="gi">+        u, v, d = graphs[0][1][edgekey]</span>
<span class="gi">+        dd = {attr: d[attr]}</span>
<span class="gi">+</span>
<span class="gi">+        if preserve_attrs:</span>
<span class="gi">+            for key, value in d.items():</span>
<span class="gi">+                if key not in [attr, candidate_attr]:</span>
<span class="gi">+                    dd[key] = value</span>
<span class="gi">+</span>
<span class="gi">+        H.add_edge(u, v, **dd)</span>
<span class="gi">+</span>
<span class="gi">+    ###################</span>
<span class="gi">+    ### END STEP I3 ###</span>
<span class="gi">+    ###################</span>
<span class="gi">+</span>
<span class="gi">+    return H</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(preserve_edge_attrs=True, mutates_input=True, returns_graph=True)</span>
<span class="gi">+def minimum_branching(</span>
<span class="gi">+    G, attr=&quot;weight&quot;, default=1, preserve_attrs=False, partition=None</span>
<span class="gi">+):</span>
<span class="gi">+    for _, _, d in G.edges(data=True):</span>
<span class="gi">+        d[attr] = -d.get(attr, default)</span>
<span class="gi">+    nx._clear_cache(G)</span>
<span class="gi">+</span>
<span class="gi">+    B = maximum_branching(G, attr, default, preserve_attrs, partition)</span>
<span class="gi">+</span>
<span class="gi">+    for _, _, d in G.edges(data=True):</span>
<span class="gi">+        d[attr] = -d.get(attr, default)</span>
<span class="gi">+    nx._clear_cache(G)</span>
<span class="gi">+</span>
<span class="gi">+    for _, _, d in B.edges(data=True):</span>
<span class="gi">+        d[attr] = -d.get(attr, default)</span>
<span class="gi">+    nx._clear_cache(B)</span>
<span class="gi">+</span>
<span class="gi">+    return B</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(preserve_edge_attrs=True, mutates_input=True, returns_graph=True)</span>
<span class="gi">+def minimal_branching(</span>
<span class="gi">+    G, /, *, attr=&quot;weight&quot;, default=1, preserve_attrs=False, partition=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns a minimal branching from `G`.

<span class="gu">@@ -265,7 +1226,94 @@ def minimal_branching(G, /, *, attr=&#39;weight&#39;, default=1, preserve_attrs=</span>
<span class="w"> </span>    B : (multi)digraph-like
<span class="w"> </span>        A minimal branching.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    max_weight = -INF</span>
<span class="gi">+    min_weight = INF</span>
<span class="gi">+    for _, _, w in G.edges(data=attr, default=default):</span>
<span class="gi">+        if w &gt; max_weight:</span>
<span class="gi">+            max_weight = w</span>
<span class="gi">+        if w &lt; min_weight:</span>
<span class="gi">+            min_weight = w</span>
<span class="gi">+</span>
<span class="gi">+    for _, _, d in G.edges(data=True):</span>
<span class="gi">+        # Transform the weights so that the minimum weight is larger than</span>
<span class="gi">+        # the difference between the max and min weights. This is important</span>
<span class="gi">+        # in order to prevent the edge weights from becoming negative during</span>
<span class="gi">+        # computation</span>
<span class="gi">+        d[attr] = max_weight + 1 + (max_weight - min_weight) - d.get(attr, default)</span>
<span class="gi">+    nx._clear_cache(G)</span>
<span class="gi">+</span>
<span class="gi">+    B = maximum_branching(G, attr, default, preserve_attrs, partition)</span>
<span class="gi">+</span>
<span class="gi">+    # Reverse the weight transformations</span>
<span class="gi">+    for _, _, d in G.edges(data=True):</span>
<span class="gi">+        d[attr] = max_weight + 1 + (max_weight - min_weight) - d.get(attr, default)</span>
<span class="gi">+    nx._clear_cache(G)</span>
<span class="gi">+</span>
<span class="gi">+    for _, _, d in B.edges(data=True):</span>
<span class="gi">+        d[attr] = max_weight + 1 + (max_weight - min_weight) - d.get(attr, default)</span>
<span class="gi">+    nx._clear_cache(B)</span>
<span class="gi">+</span>
<span class="gi">+    return B</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(preserve_edge_attrs=True, mutates_input=True, returns_graph=True)</span>
<span class="gi">+def maximum_spanning_arborescence(</span>
<span class="gi">+    G, attr=&quot;weight&quot;, default=1, preserve_attrs=False, partition=None</span>
<span class="gi">+):</span>
<span class="gi">+    # In order to use the same algorithm is the maximum branching, we need to adjust</span>
<span class="gi">+    # the weights of the graph. The branching algorithm can choose to not include an</span>
<span class="gi">+    # edge if it doesn&#39;t help find a branching, mainly triggered by edges with negative</span>
<span class="gi">+    # weights.</span>
<span class="gi">+    #</span>
<span class="gi">+    # To prevent this from happening while trying to find a spanning arborescence, we</span>
<span class="gi">+    # just have to tweak the edge weights so that they are all positive and cannot</span>
<span class="gi">+    # become negative during the branching algorithm, find the maximum branching and</span>
<span class="gi">+    # then return them to their original values.</span>
<span class="gi">+</span>
<span class="gi">+    min_weight = INF</span>
<span class="gi">+    max_weight = -INF</span>
<span class="gi">+    for _, _, w in G.edges(data=attr, default=default):</span>
<span class="gi">+        if w &lt; min_weight:</span>
<span class="gi">+            min_weight = w</span>
<span class="gi">+        if w &gt; max_weight:</span>
<span class="gi">+            max_weight = w</span>
<span class="gi">+</span>
<span class="gi">+    for _, _, d in G.edges(data=True):</span>
<span class="gi">+        d[attr] = d.get(attr, default) - min_weight + 1 - (min_weight - max_weight)</span>
<span class="gi">+    nx._clear_cache(G)</span>
<span class="gi">+</span>
<span class="gi">+    B = maximum_branching(G, attr, default, preserve_attrs, partition)</span>
<span class="gi">+</span>
<span class="gi">+    for _, _, d in G.edges(data=True):</span>
<span class="gi">+        d[attr] = d.get(attr, default) + min_weight - 1 + (min_weight - max_weight)</span>
<span class="gi">+    nx._clear_cache(G)</span>
<span class="gi">+</span>
<span class="gi">+    for _, _, d in B.edges(data=True):</span>
<span class="gi">+        d[attr] = d.get(attr, default) + min_weight - 1 + (min_weight - max_weight)</span>
<span class="gi">+    nx._clear_cache(B)</span>
<span class="gi">+</span>
<span class="gi">+    if not is_arborescence(B):</span>
<span class="gi">+        raise nx.exception.NetworkXException(&quot;No maximum spanning arborescence in G.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return B</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(preserve_edge_attrs=True, mutates_input=True, returns_graph=True)</span>
<span class="gi">+def minimum_spanning_arborescence(</span>
<span class="gi">+    G, attr=&quot;weight&quot;, default=1, preserve_attrs=False, partition=None</span>
<span class="gi">+):</span>
<span class="gi">+    B = minimal_branching(</span>
<span class="gi">+        G,</span>
<span class="gi">+        attr=attr,</span>
<span class="gi">+        default=default,</span>
<span class="gi">+        preserve_attrs=preserve_attrs,</span>
<span class="gi">+        partition=partition,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if not is_arborescence(B):</span>
<span class="gi">+        raise nx.exception.NetworkXException(&quot;No minimum spanning arborescence in G.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return B</span>


<span class="w"> </span>docstring_branching = &quot;&quot;&quot;
<span class="gu">@@ -293,24 +1341,38 @@ Returns</span>
<span class="w"> </span>B : (multi)digraph-like
<span class="w"> </span>    A {kind} {style}.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-docstring_arborescence = docstring_branching + &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+docstring_arborescence = (</span>
<span class="gi">+    docstring_branching</span>
<span class="gi">+    + &quot;&quot;&quot;</span>
<span class="w"> </span>Raises
<span class="w"> </span>------
<span class="w"> </span>NetworkXException
<span class="w"> </span>    If the graph does not contain a {kind} {style}.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-maximum_branching.__doc__ = docstring_branching.format(kind=&#39;maximum&#39;,</span>
<span class="gd">-    style=&#39;branching&#39;)</span>
<span class="gd">-minimum_branching.__doc__ = docstring_branching.format(kind=&#39;minimum&#39;, style=&#39;branching&#39;) + &quot;&quot;&quot;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+maximum_branching.__doc__ = docstring_branching.format(</span>
<span class="gi">+    kind=&quot;maximum&quot;, style=&quot;branching&quot;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+minimum_branching.__doc__ = (</span>
<span class="gi">+    docstring_branching.format(kind=&quot;minimum&quot;, style=&quot;branching&quot;)</span>
<span class="gi">+    + &quot;&quot;&quot;</span>
<span class="w"> </span>See Also
<span class="w"> </span>--------
<span class="w"> </span>    minimal_branching
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-maximum_spanning_arborescence.__doc__ = docstring_arborescence.format(kind=</span>
<span class="gd">-    &#39;maximum&#39;, style=&#39;spanning arborescence&#39;)</span>
<span class="gd">-minimum_spanning_arborescence.__doc__ = docstring_arborescence.format(kind=</span>
<span class="gd">-    &#39;minimum&#39;, style=&#39;spanning arborescence&#39;)</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+maximum_spanning_arborescence.__doc__ = docstring_arborescence.format(</span>
<span class="gi">+    kind=&quot;maximum&quot;, style=&quot;spanning arborescence&quot;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+minimum_spanning_arborescence.__doc__ = docstring_arborescence.format(</span>
<span class="gi">+    kind=&quot;minimum&quot;, style=&quot;spanning arborescence&quot;</span>
<span class="gi">+)</span>


<span class="w"> </span>class ArborescenceIterator:
<span class="gu">@@ -334,7 +1396,6 @@ class ArborescenceIterator:</span>
<span class="w"> </span>           https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>    @dataclass(order=True)
<span class="w"> </span>    class Partition:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -342,14 +1403,16 @@ class ArborescenceIterator:</span>
<span class="w"> </span>        data and the weight of the minimum spanning arborescence of the
<span class="w"> </span>        partition dict.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        mst_weight: float
<span class="w"> </span>        partition_dict: dict = field(compare=False)

<span class="w"> </span>        def __copy__(self):
<span class="gd">-            return ArborescenceIterator.Partition(self.mst_weight, self.</span>
<span class="gd">-                partition_dict.copy())</span>
<span class="gi">+            return ArborescenceIterator.Partition(</span>
<span class="gi">+                self.mst_weight, self.partition_dict.copy()</span>
<span class="gi">+            )</span>

<span class="gd">-    def __init__(self, G, weight=&#39;weight&#39;, minimum=True, init_partition=None):</span>
<span class="gi">+    def __init__(self, G, weight=&quot;weight&quot;, minimum=True, init_partition=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Initialize the iterator

<span class="gu">@@ -375,18 +1438,20 @@ class ArborescenceIterator:</span>
<span class="w"> </span>        self.G = G.copy()
<span class="w"> </span>        self.weight = weight
<span class="w"> </span>        self.minimum = minimum
<span class="gd">-        self.method = (minimum_spanning_arborescence if minimum else</span>
<span class="gd">-            maximum_spanning_arborescence)</span>
<span class="gi">+        self.method = (</span>
<span class="gi">+            minimum_spanning_arborescence if minimum else maximum_spanning_arborescence</span>
<span class="gi">+        )</span>
<span class="gi">+        # Randomly create a key for an edge attribute to hold the partition data</span>
<span class="w"> </span>        self.partition_key = (
<span class="gd">-            &#39;ArborescenceIterators super secret partition attribute name&#39;)</span>
<span class="gi">+            &quot;ArborescenceIterators super secret partition attribute name&quot;</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if init_partition is not None:
<span class="w"> </span>            partition_dict = {}
<span class="w"> </span>            for e in init_partition[0]:
<span class="w"> </span>                partition_dict[e] = nx.EdgePartition.INCLUDED
<span class="w"> </span>            for e in init_partition[1]:
<span class="w"> </span>                partition_dict[e] = nx.EdgePartition.EXCLUDED
<span class="gd">-            self.init_partition = ArborescenceIterator.Partition(0,</span>
<span class="gd">-                partition_dict)</span>
<span class="gi">+            self.init_partition = ArborescenceIterator.Partition(0, partition_dict)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.init_partition = None

<span class="gu">@@ -399,13 +1464,27 @@ class ArborescenceIterator:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.partition_queue = PriorityQueue()
<span class="w"> </span>        self._clear_partition(self.G)
<span class="gi">+</span>
<span class="gi">+        # Write the initial partition if it exists.</span>
<span class="w"> </span>        if self.init_partition is not None:
<span class="w"> </span>            self._write_partition(self.init_partition)
<span class="gd">-        mst_weight = self.method(self.G, self.weight, partition=self.</span>
<span class="gd">-            partition_key, preserve_attrs=True).size(weight=self.weight)</span>
<span class="gd">-        self.partition_queue.put(self.Partition(mst_weight if self.minimum else</span>
<span class="gd">-            -mst_weight, {} if self.init_partition is None else self.</span>
<span class="gd">-            init_partition.partition_dict))</span>
<span class="gi">+</span>
<span class="gi">+        mst_weight = self.method(</span>
<span class="gi">+            self.G,</span>
<span class="gi">+            self.weight,</span>
<span class="gi">+            partition=self.partition_key,</span>
<span class="gi">+            preserve_attrs=True,</span>
<span class="gi">+        ).size(weight=self.weight)</span>
<span class="gi">+</span>
<span class="gi">+        self.partition_queue.put(</span>
<span class="gi">+            self.Partition(</span>
<span class="gi">+                mst_weight if self.minimum else -mst_weight,</span>
<span class="gi">+                {}</span>
<span class="gi">+                if self.init_partition is None</span>
<span class="gi">+                else self.init_partition.partition_dict,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        return self

<span class="w"> </span>    def __next__(self):
<span class="gu">@@ -419,11 +1498,17 @@ class ArborescenceIterator:</span>
<span class="w"> </span>        if self.partition_queue.empty():
<span class="w"> </span>            del self.G, self.partition_queue
<span class="w"> </span>            raise StopIteration
<span class="gi">+</span>
<span class="w"> </span>        partition = self.partition_queue.get()
<span class="w"> </span>        self._write_partition(partition)
<span class="gd">-        next_arborescence = self.method(self.G, self.weight, partition=self</span>
<span class="gd">-            .partition_key, preserve_attrs=True)</span>
<span class="gi">+        next_arborescence = self.method(</span>
<span class="gi">+            self.G,</span>
<span class="gi">+            self.weight,</span>
<span class="gi">+            partition=self.partition_key,</span>
<span class="gi">+            preserve_attrs=True,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._partition(partition, next_arborescence)
<span class="gi">+</span>
<span class="w"> </span>        self._clear_partition(next_arborescence)
<span class="w"> </span>        return next_arborescence

<span class="gu">@@ -440,7 +1525,32 @@ class ArborescenceIterator:</span>
<span class="w"> </span>        partition_arborescence : nx.Graph
<span class="w"> </span>            The minimum spanning arborescence of the input partition.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # create two new partitions with the data from the input partition dict</span>
<span class="gi">+        p1 = self.Partition(0, partition.partition_dict.copy())</span>
<span class="gi">+        p2 = self.Partition(0, partition.partition_dict.copy())</span>
<span class="gi">+        for e in partition_arborescence.edges:</span>
<span class="gi">+            # determine if the edge was open or included</span>
<span class="gi">+            if e not in partition.partition_dict:</span>
<span class="gi">+                # This is an open edge</span>
<span class="gi">+                p1.partition_dict[e] = nx.EdgePartition.EXCLUDED</span>
<span class="gi">+                p2.partition_dict[e] = nx.EdgePartition.INCLUDED</span>
<span class="gi">+</span>
<span class="gi">+                self._write_partition(p1)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    p1_mst = self.method(</span>
<span class="gi">+                        self.G,</span>
<span class="gi">+                        self.weight,</span>
<span class="gi">+                        partition=self.partition_key,</span>
<span class="gi">+                        preserve_attrs=True,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                    p1_mst_weight = p1_mst.size(weight=self.weight)</span>
<span class="gi">+                    p1.mst_weight = p1_mst_weight if self.minimum else -p1_mst_weight</span>
<span class="gi">+                    self.partition_queue.put(p1.__copy__())</span>
<span class="gi">+                except nx.NetworkXException:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+                p1.partition_dict = p2.partition_dict.copy()</span>

<span class="w"> </span>    def _write_partition(self, partition):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -455,10 +1565,33 @@ class ArborescenceIterator:</span>
<span class="w"> </span>            A Partition dataclass describing a partition on the edges of the
<span class="w"> </span>            graph.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for u, v, d in self.G.edges(data=True):</span>
<span class="gi">+            if (u, v) in partition.partition_dict:</span>
<span class="gi">+                d[self.partition_key] = partition.partition_dict[(u, v)]</span>
<span class="gi">+            else:</span>
<span class="gi">+                d[self.partition_key] = nx.EdgePartition.OPEN</span>
<span class="gi">+        nx._clear_cache(self.G)</span>
<span class="gi">+</span>
<span class="gi">+        for n in self.G:</span>
<span class="gi">+            included_count = 0</span>
<span class="gi">+            excluded_count = 0</span>
<span class="gi">+            for u, v, d in self.G.in_edges(nbunch=n, data=True):</span>
<span class="gi">+                if d.get(self.partition_key) == nx.EdgePartition.INCLUDED:</span>
<span class="gi">+                    included_count += 1</span>
<span class="gi">+                elif d.get(self.partition_key) == nx.EdgePartition.EXCLUDED:</span>
<span class="gi">+                    excluded_count += 1</span>
<span class="gi">+            # Check that if there is an included edges, all other incoming ones</span>
<span class="gi">+            # are excluded. If not fix it!</span>
<span class="gi">+            if included_count == 1 and excluded_count != self.G.in_degree(n) - 1:</span>
<span class="gi">+                for u, v, d in self.G.in_edges(nbunch=n, data=True):</span>
<span class="gi">+                    if d.get(self.partition_key) != nx.EdgePartition.INCLUDED:</span>
<span class="gi">+                        d[self.partition_key] = nx.EdgePartition.EXCLUDED</span>

<span class="w"> </span>    def _clear_partition(self, G):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Removes partition data from the graph
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for u, v, d in G.edges(data=True):</span>
<span class="gi">+            if self.partition_key in d:</span>
<span class="gi">+                del d[self.partition_key]</span>
<span class="gi">+        nx._clear_cache(self.G)</span>
<span class="gh">diff --git a/networkx/algorithms/tree/coding.py b/networkx/algorithms/tree/coding.py</span>
<span class="gh">index 5d4a402e2..8cec023c2 100644</span>
<span class="gd">--- a/networkx/algorithms/tree/coding.py</span>
<span class="gi">+++ b/networkx/algorithms/tree/coding.py</span>
<span class="gu">@@ -10,10 +10,17 @@ sequences to labeled trees.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections import Counter
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;from_nested_tuple&#39;, &#39;from_prufer_sequence&#39;, &#39;NotATree&#39;,</span>
<span class="gd">-    &#39;to_nested_tuple&#39;, &#39;to_prufer_sequence&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;from_nested_tuple&quot;,</span>
<span class="gi">+    &quot;from_prufer_sequence&quot;,</span>
<span class="gi">+    &quot;NotATree&quot;,</span>
<span class="gi">+    &quot;to_nested_tuple&quot;,</span>
<span class="gi">+    &quot;to_prufer_sequence&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class NotATree(nx.NetworkXException):
<span class="gu">@@ -24,8 +31,8 @@ class NotATree(nx.NetworkXException):</span>
<span class="w"> </span>    &quot;&quot;&quot;


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;T&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;T&quot;)</span>
<span class="w"> </span>def to_nested_tuple(T, root, canonical_form=False):
<span class="w"> </span>    &quot;&quot;&quot;Returns a nested tuple representation of the given tree.

<span class="gu">@@ -91,7 +98,34 @@ def to_nested_tuple(T, root, canonical_form=False):</span>
<span class="w"> </span>        ((((),),),)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _make_tuple(T, root, _parent):</span>
<span class="gi">+        &quot;&quot;&quot;Recursively compute the nested tuple representation of the</span>
<span class="gi">+        given rooted tree.</span>
<span class="gi">+</span>
<span class="gi">+        ``_parent`` is the parent node of ``root`` in the supertree in</span>
<span class="gi">+        which ``T`` is a subtree, or ``None`` if ``root`` is the root of</span>
<span class="gi">+        the supertree. This argument is used to determine which</span>
<span class="gi">+        neighbors of ``root`` are children and which is the parent.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Get the neighbors of `root` that are not the parent node. We</span>
<span class="gi">+        # are guaranteed that `root` is always in `T` by construction.</span>
<span class="gi">+        children = set(T[root]) - {_parent}</span>
<span class="gi">+        if len(children) == 0:</span>
<span class="gi">+            return ()</span>
<span class="gi">+        nested = (_make_tuple(T, v, root) for v in children)</span>
<span class="gi">+        if canonical_form:</span>
<span class="gi">+            nested = sorted(nested)</span>
<span class="gi">+        return tuple(nested)</span>
<span class="gi">+</span>
<span class="gi">+    # Do some sanity checks on the input.</span>
<span class="gi">+    if not nx.is_tree(T):</span>
<span class="gi">+        raise nx.NotATree(&quot;provided graph is not a tree&quot;)</span>
<span class="gi">+    if root not in T:</span>
<span class="gi">+        raise nx.NodeNotFound(f&quot;Graph {T} contains no node {root}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return _make_tuple(T, root, None)</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -144,13 +178,44 @@ def from_nested_tuple(sequence, sensible_relabeling=False):</span>
<span class="w"> </span>        True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(graphs=&#39;T&#39;)</span>
<span class="gi">+    def _make_tree(sequence):</span>
<span class="gi">+        &quot;&quot;&quot;Recursively creates a tree from the given sequence of nested</span>
<span class="gi">+        tuples.</span>
<span class="gi">+</span>
<span class="gi">+        This function employs the :func:`~networkx.tree.join` function</span>
<span class="gi">+        to recursively join subtrees into a larger tree.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # The empty sequence represents the empty tree, which is the</span>
<span class="gi">+        # (unique) graph with a single node. We mark the single node</span>
<span class="gi">+        # with an attribute that indicates that it is the root of the</span>
<span class="gi">+        # graph.</span>
<span class="gi">+        if len(sequence) == 0:</span>
<span class="gi">+            return nx.empty_graph(1)</span>
<span class="gi">+        # For a nonempty sequence, get the subtrees for each child</span>
<span class="gi">+        # sequence and join all the subtrees at their roots. After</span>
<span class="gi">+        # joining the subtrees, the root is node 0.</span>
<span class="gi">+        return nx.tree.join_trees([(_make_tree(child), 0) for child in sequence])</span>
<span class="gi">+</span>
<span class="gi">+    # Make the tree and remove the `is_root` node attribute added by the</span>
<span class="gi">+    # helper function.</span>
<span class="gi">+    T = _make_tree(sequence)</span>
<span class="gi">+    if sensible_relabeling:</span>
<span class="gi">+        # Relabel the nodes according to their breadth-first search</span>
<span class="gi">+        # order, starting from the root node (that is, the node 0).</span>
<span class="gi">+        bfs_nodes = chain([0], (v for u, v in nx.bfs_edges(T, 0)))</span>
<span class="gi">+        labels = {v: i for i, v in enumerate(bfs_nodes)}</span>
<span class="gi">+        # We would like to use `copy=False`, but `relabel_nodes` doesn&#39;t</span>
<span class="gi">+        # allow a relabel mapping that can&#39;t be topologically sorted.</span>
<span class="gi">+        T = nx.relabel_nodes(T, labels)</span>
<span class="gi">+    return T</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(graphs=&quot;T&quot;)</span>
<span class="w"> </span>def to_prufer_sequence(T):
<span class="gd">-    &quot;&quot;&quot;Returns the Prüfer sequence of the given tree.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Prüfer sequence of the given tree.</span>

<span class="w"> </span>    A *Prüfer sequence* is a list of *n* - 2 numbers between 0 and
<span class="w"> </span>    *n* - 1, inclusive. The tree corresponding to a given Prüfer
<span class="gu">@@ -221,12 +286,37 @@ def to_prufer_sequence(T):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Perform some sanity checks on the input.</span>
<span class="gi">+    n = len(T)</span>
<span class="gi">+    if n &lt; 2:</span>
<span class="gi">+        msg = &quot;Prüfer sequence undefined for trees with fewer than two nodes&quot;</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(msg)</span>
<span class="gi">+    if not nx.is_tree(T):</span>
<span class="gi">+        raise nx.NotATree(&quot;provided graph is not a tree&quot;)</span>
<span class="gi">+    if set(T) != set(range(n)):</span>
<span class="gi">+        raise KeyError(&quot;tree must have node labels {0, ..., n - 1}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    degree = dict(T.degree())</span>
<span class="gi">+</span>
<span class="gi">+    def parents(u):</span>
<span class="gi">+        return next(v for v in T[u] if degree[v] &gt; 1)</span>
<span class="gi">+</span>
<span class="gi">+    index = u = next(k for k in range(n) if degree[k] == 1)</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for i in range(n - 2):</span>
<span class="gi">+        v = parents(u)</span>
<span class="gi">+        result.append(v)</span>
<span class="gi">+        degree[v] -= 1</span>
<span class="gi">+        if v &lt; index and degree[v] == 1:</span>
<span class="gi">+            u = v</span>
<span class="gi">+        else:</span>
<span class="gi">+            index = u = next(k for k in range(index + 1, n) if degree[k] == 1)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def from_prufer_sequence(sequence):
<span class="gd">-    &quot;&quot;&quot;Returns the tree corresponding to the given Prüfer sequence.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the tree corresponding to the given Prüfer sequence.</span>

<span class="w"> </span>    A *Prüfer sequence* is a list of *n* - 2 numbers between 0 and
<span class="w"> </span>    *n* - 1, inclusive. The tree corresponding to a given Prüfer
<span class="gu">@@ -291,4 +381,32 @@ def from_prufer_sequence(sequence):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(sequence) + 2</span>
<span class="gi">+    # `degree` stores the remaining degree (plus one) for each node. The</span>
<span class="gi">+    # degree of a node in the decoded tree is one more than the number</span>
<span class="gi">+    # of times it appears in the code.</span>
<span class="gi">+    degree = Counter(chain(sequence, range(n)))</span>
<span class="gi">+    T = nx.empty_graph(n)</span>
<span class="gi">+    # `not_orphaned` is the set of nodes that have a parent in the</span>
<span class="gi">+    # tree. After the loop, there should be exactly two nodes that are</span>
<span class="gi">+    # not in this set.</span>
<span class="gi">+    not_orphaned = set()</span>
<span class="gi">+    index = u = next(k for k in range(n) if degree[k] == 1)</span>
<span class="gi">+    for v in sequence:</span>
<span class="gi">+        # check the validity of the prufer sequence</span>
<span class="gi">+        if v &lt; 0 or v &gt; n - 1:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;Invalid Prufer sequence: Values must be between 0 and {n-1}, got {v}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        T.add_edge(u, v)</span>
<span class="gi">+        not_orphaned.add(u)</span>
<span class="gi">+        degree[v] -= 1</span>
<span class="gi">+        if v &lt; index and degree[v] == 1:</span>
<span class="gi">+            u = v</span>
<span class="gi">+        else:</span>
<span class="gi">+            index = u = next(k for k in range(index + 1, n) if degree[k] == 1)</span>
<span class="gi">+    # At this point, there must be exactly two orphaned nodes; join them.</span>
<span class="gi">+    orphans = set(T) - not_orphaned</span>
<span class="gi">+    u, v = orphans</span>
<span class="gi">+    T.add_edge(u, v)</span>
<span class="gi">+    return T</span>
<span class="gh">diff --git a/networkx/algorithms/tree/decomposition.py b/networkx/algorithms/tree/decomposition.py</span>
<span class="gh">index e85654c9c..c8b8f2477 100644</span>
<span class="gd">--- a/networkx/algorithms/tree/decomposition.py</span>
<span class="gi">+++ b/networkx/algorithms/tree/decomposition.py</span>
<span class="gu">@@ -1,15 +1,18 @@</span>
<span class="gd">-&quot;&quot;&quot;Function for computing a junction tree of a graph.&quot;&quot;&quot;</span>
<span class="gi">+r&quot;&quot;&quot;Function for computing a junction tree of a graph.&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>from itertools import combinations
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.algorithms import chordal_graph_cliques, complete_to_chordal_graph, moral
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;junction_tree&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;junction_tree&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def junction_tree(G):
<span class="gd">-    &quot;&quot;&quot;Returns a junction tree of a given graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a junction tree of a given graph.</span>

<span class="w"> </span>    A junction tree (or clique tree) is constructed from a (un)directed graph G.
<span class="w"> </span>    The tree is constructed based on a moralized and triangulated version of G.
<span class="gu">@@ -57,4 +60,29 @@ def junction_tree(G):</span>
<span class="w"> </span>       conference on Uncertainty in artificial intelligence (UAI’94).
<span class="w"> </span>       Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 360–366.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    clique_graph = nx.Graph()</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        G = moral.moral_graph(G)</span>
<span class="gi">+    chordal_graph, _ = complete_to_chordal_graph(G)</span>
<span class="gi">+</span>
<span class="gi">+    cliques = [tuple(sorted(i)) for i in chordal_graph_cliques(chordal_graph)]</span>
<span class="gi">+    clique_graph.add_nodes_from(cliques, type=&quot;clique&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    for edge in combinations(cliques, 2):</span>
<span class="gi">+        set_edge_0 = set(edge[0])</span>
<span class="gi">+        set_edge_1 = set(edge[1])</span>
<span class="gi">+        if not set_edge_0.isdisjoint(set_edge_1):</span>
<span class="gi">+            sepset = tuple(sorted(set_edge_0.intersection(set_edge_1)))</span>
<span class="gi">+            clique_graph.add_edge(edge[0], edge[1], weight=len(sepset), sepset=sepset)</span>
<span class="gi">+</span>
<span class="gi">+    junction_tree = nx.maximum_spanning_tree(clique_graph)</span>
<span class="gi">+</span>
<span class="gi">+    for edge in list(junction_tree.edges(data=True)):</span>
<span class="gi">+        junction_tree.add_node(edge[2][&quot;sepset&quot;], type=&quot;sepset&quot;)</span>
<span class="gi">+        junction_tree.add_edge(edge[0], edge[2][&quot;sepset&quot;])</span>
<span class="gi">+        junction_tree.add_edge(edge[1], edge[2][&quot;sepset&quot;])</span>
<span class="gi">+        junction_tree.remove_edge(edge[0], edge[1])</span>
<span class="gi">+</span>
<span class="gi">+    return junction_tree</span>
<span class="gh">diff --git a/networkx/algorithms/tree/mst.py b/networkx/algorithms/tree/mst.py</span>
<span class="gh">index 50680f2fa..9e8ea3843 100644</span>
<span class="gd">--- a/networkx/algorithms/tree/mst.py</span>
<span class="gi">+++ b/networkx/algorithms/tree/mst.py</span>
<span class="gu">@@ -9,12 +9,21 @@ from itertools import count</span>
<span class="w"> </span>from math import isnan
<span class="w"> </span>from operator import itemgetter
<span class="w"> </span>from queue import PriorityQueue
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import UnionFind, not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;minimum_spanning_edges&#39;, &#39;maximum_spanning_edges&#39;,</span>
<span class="gd">-    &#39;minimum_spanning_tree&#39;, &#39;maximum_spanning_tree&#39;,</span>
<span class="gd">-    &#39;number_of_spanning_trees&#39;, &#39;random_spanning_tree&#39;,</span>
<span class="gd">-    &#39;partition_spanning_tree&#39;, &#39;EdgePartition&#39;, &#39;SpanningTreeIterator&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;minimum_spanning_edges&quot;,</span>
<span class="gi">+    &quot;maximum_spanning_edges&quot;,</span>
<span class="gi">+    &quot;minimum_spanning_tree&quot;,</span>
<span class="gi">+    &quot;maximum_spanning_tree&quot;,</span>
<span class="gi">+    &quot;number_of_spanning_trees&quot;,</span>
<span class="gi">+    &quot;random_spanning_tree&quot;,</span>
<span class="gi">+    &quot;partition_spanning_tree&quot;,</span>
<span class="gi">+    &quot;EdgePartition&quot;,</span>
<span class="gi">+    &quot;SpanningTreeIterator&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class EdgePartition(Enum):
<span class="gu">@@ -26,15 +35,17 @@ class EdgePartition(Enum):</span>
<span class="w"> </span>    - EdgePartition.INCLUDED
<span class="w"> </span>    - EdgePartition.EXCLUDED
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    OPEN = 0
<span class="w"> </span>    INCLUDED = 1
<span class="w"> </span>    EXCLUDED = 2


<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, preserve_edge_attrs=&#39;data&#39;)</span>
<span class="gd">-def boruvka_mst_edges(G, minimum=True, weight=&#39;weight&#39;, keys=False, data=</span>
<span class="gd">-    True, ignore_nan=False):</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, preserve_edge_attrs=&quot;data&quot;)</span>
<span class="gi">+def boruvka_mst_edges(</span>
<span class="gi">+    G, minimum=True, weight=&quot;weight&quot;, keys=False, data=True, ignore_nan=False</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over edges of a Borůvka&#39;s algorithm min/max spanning tree.

<span class="w"> </span>    Parameters
<span class="gu">@@ -64,13 +75,76 @@ def boruvka_mst_edges(G, minimum=True, weight=&#39;weight&#39;, keys=False, data=</span>
<span class="w"> </span>        If `ignore_nan is True` then that edge is ignored instead.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Initialize a forest, assuming initially that it is the discrete</span>
<span class="gi">+    # partition of the nodes of the graph.</span>
<span class="gi">+    forest = UnionFind(G)</span>

<span class="gi">+    def best_edge(component):</span>
<span class="gi">+        &quot;&quot;&quot;Returns the optimum (minimum or maximum) edge on the edge</span>
<span class="gi">+        boundary of the given set of nodes.</span>

<span class="gd">-@nx._dispatchable(edge_attrs={&#39;weight&#39;: None, &#39;partition&#39;: None},</span>
<span class="gd">-    preserve_edge_attrs=&#39;data&#39;)</span>
<span class="gd">-def kruskal_mst_edges(G, minimum, weight=&#39;weight&#39;, keys=True, data=True,</span>
<span class="gd">-    ignore_nan=False, partition=None):</span>
<span class="gi">+        A return value of ``None`` indicates an empty boundary.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        sign = 1 if minimum else -1</span>
<span class="gi">+        minwt = float(&quot;inf&quot;)</span>
<span class="gi">+        boundary = None</span>
<span class="gi">+        for e in nx.edge_boundary(G, component, data=True):</span>
<span class="gi">+            wt = e[-1].get(weight, 1) * sign</span>
<span class="gi">+            if isnan(wt):</span>
<span class="gi">+                if ignore_nan:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                msg = f&quot;NaN found as an edge weight. Edge {e}&quot;</span>
<span class="gi">+                raise ValueError(msg)</span>
<span class="gi">+            if wt &lt; minwt:</span>
<span class="gi">+                minwt = wt</span>
<span class="gi">+                boundary = e</span>
<span class="gi">+        return boundary</span>
<span class="gi">+</span>
<span class="gi">+    # Determine the optimum edge in the edge boundary of each component</span>
<span class="gi">+    # in the forest.</span>
<span class="gi">+    best_edges = (best_edge(component) for component in forest.to_sets())</span>
<span class="gi">+    best_edges = [edge for edge in best_edges if edge is not None]</span>
<span class="gi">+    # If each entry was ``None``, that means the graph was disconnected,</span>
<span class="gi">+    # so we are done generating the forest.</span>
<span class="gi">+    while best_edges:</span>
<span class="gi">+        # Determine the optimum edge in the edge boundary of each</span>
<span class="gi">+        # component in the forest.</span>
<span class="gi">+        #</span>
<span class="gi">+        # This must be a sequence, not an iterator. In this list, the</span>
<span class="gi">+        # same edge may appear twice, in different orientations (but</span>
<span class="gi">+        # that&#39;s okay, since a union operation will be called on the</span>
<span class="gi">+        # endpoints the first time it is seen, but not the second time).</span>
<span class="gi">+        #</span>
<span class="gi">+        # Any ``None`` indicates that the edge boundary for that</span>
<span class="gi">+        # component was empty, so that part of the forest has been</span>
<span class="gi">+        # completed.</span>
<span class="gi">+        #</span>
<span class="gi">+        # TODO This can be parallelized, both in the outer loop over</span>
<span class="gi">+        # each component in the forest and in the computation of the</span>
<span class="gi">+        # minimum. (Same goes for the identical lines outside the loop.)</span>
<span class="gi">+        best_edges = (best_edge(component) for component in forest.to_sets())</span>
<span class="gi">+        best_edges = [edge for edge in best_edges if edge is not None]</span>
<span class="gi">+        # Join trees in the forest using the best edges, and yield that</span>
<span class="gi">+        # edge, since it is part of the spanning tree.</span>
<span class="gi">+        #</span>
<span class="gi">+        # TODO This loop can be parallelized, to an extent (the union</span>
<span class="gi">+        # operation must be atomic).</span>
<span class="gi">+        for u, v, d in best_edges:</span>
<span class="gi">+            if forest[u] != forest[v]:</span>
<span class="gi">+                if data:</span>
<span class="gi">+                    yield u, v, d</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield u, v</span>
<span class="gi">+                forest.union(u, v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    edge_attrs={&quot;weight&quot;: None, &quot;partition&quot;: None}, preserve_edge_attrs=&quot;data&quot;</span>
<span class="gi">+)</span>
<span class="gi">+def kruskal_mst_edges(</span>
<span class="gi">+    G, minimum, weight=&quot;weight&quot;, keys=True, data=True, ignore_nan=False, partition=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Iterate over edge of a Kruskal&#39;s algorithm min/max spanning tree.

<span class="gu">@@ -111,12 +185,75 @@ def kruskal_mst_edges(G, minimum, weight=&#39;weight&#39;, keys=True, data=True,</span>
<span class="w"> </span>        take the following forms: `(u, v)`, `(u, v, d)` or `(u, v, k, d)`
<span class="w"> </span>        depending on the `key` and `data` parameters
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    subtrees = UnionFind()</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        edges = G.edges(keys=True, data=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = G.edges(data=True)</span>

<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    Sort the edges of the graph with respect to the partition data. </span>
<span class="gi">+    Edges are returned in the following order:</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, preserve_edge_attrs=&#39;data&#39;)</span>
<span class="gd">-def prim_mst_edges(G, minimum, weight=&#39;weight&#39;, keys=True, data=True,</span>
<span class="gd">-    ignore_nan=False):</span>
<span class="gi">+    * Included edges</span>
<span class="gi">+    * Open edges from smallest to largest weight</span>
<span class="gi">+    * Excluded edges</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    included_edges = []</span>
<span class="gi">+    open_edges = []</span>
<span class="gi">+    for e in edges:</span>
<span class="gi">+        d = e[-1]</span>
<span class="gi">+        wt = d.get(weight, 1)</span>
<span class="gi">+        if isnan(wt):</span>
<span class="gi">+            if ignore_nan:</span>
<span class="gi">+                continue</span>
<span class="gi">+            raise ValueError(f&quot;NaN found as an edge weight. Edge {e}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        edge = (wt,) + e</span>
<span class="gi">+        if d.get(partition) == EdgePartition.INCLUDED:</span>
<span class="gi">+            included_edges.append(edge)</span>
<span class="gi">+        elif d.get(partition) == EdgePartition.EXCLUDED:</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            open_edges.append(edge)</span>
<span class="gi">+</span>
<span class="gi">+    if minimum:</span>
<span class="gi">+        sorted_open_edges = sorted(open_edges, key=itemgetter(0))</span>
<span class="gi">+    else:</span>
<span class="gi">+        sorted_open_edges = sorted(open_edges, key=itemgetter(0), reverse=True)</span>
<span class="gi">+</span>
<span class="gi">+    # Condense the lists into one</span>
<span class="gi">+    included_edges.extend(sorted_open_edges)</span>
<span class="gi">+    sorted_edges = included_edges</span>
<span class="gi">+    del open_edges, sorted_open_edges, included_edges</span>
<span class="gi">+</span>
<span class="gi">+    # Multigraphs need to handle edge keys in addition to edge data.</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        for wt, u, v, k, d in sorted_edges:</span>
<span class="gi">+            if subtrees[u] != subtrees[v]:</span>
<span class="gi">+                if keys:</span>
<span class="gi">+                    if data:</span>
<span class="gi">+                        yield u, v, k, d</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield u, v, k</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if data:</span>
<span class="gi">+                        yield u, v, d</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield u, v</span>
<span class="gi">+                subtrees.union(u, v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for wt, u, v, d in sorted_edges:</span>
<span class="gi">+            if subtrees[u] != subtrees[v]:</span>
<span class="gi">+                if data:</span>
<span class="gi">+                    yield u, v, d</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield u, v</span>
<span class="gi">+                subtrees.union(u, v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, preserve_edge_attrs=&quot;data&quot;)</span>
<span class="gi">+def prim_mst_edges(G, minimum, weight=&quot;weight&quot;, keys=True, data=True, ignore_nan=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over edges of Prim&#39;s algorithm min/max spanning tree.

<span class="w"> </span>    Parameters
<span class="gu">@@ -144,17 +281,97 @@ def prim_mst_edges(G, minimum, weight=&#39;weight&#39;, keys=True, data=True,</span>
<span class="w"> </span>        If `ignore_nan is True` then that edge is ignored instead.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-ALGORITHMS = {&#39;boruvka&#39;: boruvka_mst_edges, &#39;borůvka&#39;: boruvka_mst_edges,</span>
<span class="gd">-    &#39;kruskal&#39;: kruskal_mst_edges, &#39;prim&#39;: prim_mst_edges}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, preserve_edge_attrs=&#39;data&#39;)</span>
<span class="gd">-def minimum_spanning_edges(G, algorithm=&#39;kruskal&#39;, weight=&#39;weight&#39;, keys=</span>
<span class="gd">-    True, data=True, ignore_nan=False):</span>
<span class="gi">+    is_multigraph = G.is_multigraph()</span>
<span class="gi">+    push = heappush</span>
<span class="gi">+    pop = heappop</span>
<span class="gi">+</span>
<span class="gi">+    nodes = set(G)</span>
<span class="gi">+    c = count()</span>
<span class="gi">+</span>
<span class="gi">+    sign = 1 if minimum else -1</span>
<span class="gi">+</span>
<span class="gi">+    while nodes:</span>
<span class="gi">+        u = nodes.pop()</span>
<span class="gi">+        frontier = []</span>
<span class="gi">+        visited = {u}</span>
<span class="gi">+        if is_multigraph:</span>
<span class="gi">+            for v, keydict in G.adj[u].items():</span>
<span class="gi">+                for k, d in keydict.items():</span>
<span class="gi">+                    wt = d.get(weight, 1) * sign</span>
<span class="gi">+                    if isnan(wt):</span>
<span class="gi">+                        if ignore_nan:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        msg = f&quot;NaN found as an edge weight. Edge {(u, v, k, d)}&quot;</span>
<span class="gi">+                        raise ValueError(msg)</span>
<span class="gi">+                    push(frontier, (wt, next(c), u, v, k, d))</span>
<span class="gi">+        else:</span>
<span class="gi">+            for v, d in G.adj[u].items():</span>
<span class="gi">+                wt = d.get(weight, 1) * sign</span>
<span class="gi">+                if isnan(wt):</span>
<span class="gi">+                    if ignore_nan:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    msg = f&quot;NaN found as an edge weight. Edge {(u, v, d)}&quot;</span>
<span class="gi">+                    raise ValueError(msg)</span>
<span class="gi">+                push(frontier, (wt, next(c), u, v, d))</span>
<span class="gi">+        while nodes and frontier:</span>
<span class="gi">+            if is_multigraph:</span>
<span class="gi">+                W, _, u, v, k, d = pop(frontier)</span>
<span class="gi">+            else:</span>
<span class="gi">+                W, _, u, v, d = pop(frontier)</span>
<span class="gi">+            if v in visited or v not in nodes:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Multigraphs need to handle edge keys in addition to edge data.</span>
<span class="gi">+            if is_multigraph and keys:</span>
<span class="gi">+                if data:</span>
<span class="gi">+                    yield u, v, k, d</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield u, v, k</span>
<span class="gi">+            else:</span>
<span class="gi">+                if data:</span>
<span class="gi">+                    yield u, v, d</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield u, v</span>
<span class="gi">+            # update frontier</span>
<span class="gi">+            visited.add(v)</span>
<span class="gi">+            nodes.discard(v)</span>
<span class="gi">+            if is_multigraph:</span>
<span class="gi">+                for w, keydict in G.adj[v].items():</span>
<span class="gi">+                    if w in visited:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    for k2, d2 in keydict.items():</span>
<span class="gi">+                        new_weight = d2.get(weight, 1) * sign</span>
<span class="gi">+                        if isnan(new_weight):</span>
<span class="gi">+                            if ignore_nan:</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            msg = f&quot;NaN found as an edge weight. Edge {(v, w, k2, d2)}&quot;</span>
<span class="gi">+                            raise ValueError(msg)</span>
<span class="gi">+                        push(frontier, (new_weight, next(c), v, w, k2, d2))</span>
<span class="gi">+            else:</span>
<span class="gi">+                for w, d2 in G.adj[v].items():</span>
<span class="gi">+                    if w in visited:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    new_weight = d2.get(weight, 1) * sign</span>
<span class="gi">+                    if isnan(new_weight):</span>
<span class="gi">+                        if ignore_nan:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        msg = f&quot;NaN found as an edge weight. Edge {(v, w, d2)}&quot;</span>
<span class="gi">+                        raise ValueError(msg)</span>
<span class="gi">+                    push(frontier, (new_weight, next(c), v, w, d2))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ALGORITHMS = {</span>
<span class="gi">+    &quot;boruvka&quot;: boruvka_mst_edges,</span>
<span class="gi">+    &quot;borůvka&quot;: boruvka_mst_edges,</span>
<span class="gi">+    &quot;kruskal&quot;: kruskal_mst_edges,</span>
<span class="gi">+    &quot;prim&quot;: prim_mst_edges,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, preserve_edge_attrs=&quot;data&quot;)</span>
<span class="gi">+def minimum_spanning_edges(</span>
<span class="gi">+    G, algorithm=&quot;kruskal&quot;, weight=&quot;weight&quot;, keys=True, data=True, ignore_nan=False</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate edges in a minimum spanning forest of an undirected
<span class="w"> </span>    weighted graph.

<span class="gu">@@ -234,13 +451,22 @@ def minimum_spanning_edges(G, algorithm=&#39;kruskal&#39;, weight=&#39;weight&#39;, keys=</span>
<span class="w"> </span>    http://www.ics.uci.edu/~eppstein/PADS/

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, preserve_edge_attrs=&#39;data&#39;)</span>
<span class="gd">-def maximum_spanning_edges(G, algorithm=&#39;kruskal&#39;, weight=&#39;weight&#39;, keys=</span>
<span class="gd">-    True, data=True, ignore_nan=False):</span>
<span class="gi">+    try:</span>
<span class="gi">+        algo = ALGORITHMS[algorithm]</span>
<span class="gi">+    except KeyError as err:</span>
<span class="gi">+        msg = f&quot;{algorithm} is not a valid choice for an algorithm.&quot;</span>
<span class="gi">+        raise ValueError(msg) from err</span>
<span class="gi">+</span>
<span class="gi">+    return algo(</span>
<span class="gi">+        G, minimum=True, weight=weight, keys=keys, data=data, ignore_nan=ignore_nan</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;, preserve_edge_attrs=&quot;data&quot;)</span>
<span class="gi">+def maximum_spanning_edges(</span>
<span class="gi">+    G, algorithm=&quot;kruskal&quot;, weight=&quot;weight&quot;, keys=True, data=True, ignore_nan=False</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate edges in a maximum spanning forest of an undirected
<span class="w"> </span>    weighted graph.

<span class="gu">@@ -319,12 +545,19 @@ def maximum_spanning_edges(G, algorithm=&#39;kruskal&#39;, weight=&#39;weight&#39;, keys=</span>
<span class="w"> </span>    Modified code from David Eppstein, April 2006
<span class="w"> </span>    http://www.ics.uci.edu/~eppstein/PADS/
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        algo = ALGORITHMS[algorithm]</span>
<span class="gi">+    except KeyError as err:</span>
<span class="gi">+        msg = f&quot;{algorithm} is not a valid choice for an algorithm.&quot;</span>
<span class="gi">+        raise ValueError(msg) from err</span>
<span class="gi">+</span>
<span class="gi">+    return algo(</span>
<span class="gi">+        G, minimum=False, weight=weight, keys=keys, data=data, ignore_nan=ignore_nan</span>
<span class="gi">+    )</span>


<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gd">-def minimum_spanning_tree(G, weight=&#39;weight&#39;, algorithm=&#39;kruskal&#39;,</span>
<span class="gd">-    ignore_nan=False):</span>
<span class="gi">+def minimum_spanning_tree(G, weight=&quot;weight&quot;, algorithm=&quot;kruskal&quot;, ignore_nan=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a minimum spanning tree or forest on an undirected graph `G`.

<span class="w"> </span>    Parameters
<span class="gu">@@ -373,12 +606,20 @@ def minimum_spanning_tree(G, weight=&#39;weight&#39;, algorithm=&#39;kruskal&#39;,</span>
<span class="w"> </span>    Isolated nodes with self-loops are in the tree as edgeless isolated nodes.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = minimum_spanning_edges(</span>
<span class="gi">+        G, algorithm, weight, keys=True, data=True, ignore_nan=ignore_nan</span>
<span class="gi">+    )</span>
<span class="gi">+    T = G.__class__()  # Same graph class as G</span>
<span class="gi">+    T.graph.update(G.graph)</span>
<span class="gi">+    T.add_nodes_from(G.nodes.items())</span>
<span class="gi">+    T.add_edges_from(edges)</span>
<span class="gi">+    return T</span>


<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gd">-def partition_spanning_tree(G, minimum=True, weight=&#39;weight&#39;, partition=</span>
<span class="gd">-    &#39;partition&#39;, ignore_nan=False):</span>
<span class="gi">+def partition_spanning_tree(</span>
<span class="gi">+    G, minimum=True, weight=&quot;weight&quot;, partition=&quot;partition&quot;, ignore_nan=False</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Find a spanning tree while respecting a partition of edges.

<span class="gu">@@ -423,12 +664,24 @@ def partition_spanning_tree(G, minimum=True, weight=&#39;weight&#39;, partition=</span>
<span class="w"> </span>           Vol. 25 (2), p. 219-229,
<span class="w"> </span>           https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = kruskal_mst_edges(</span>
<span class="gi">+        G,</span>
<span class="gi">+        minimum,</span>
<span class="gi">+        weight,</span>
<span class="gi">+        keys=True,</span>
<span class="gi">+        data=True,</span>
<span class="gi">+        ignore_nan=ignore_nan,</span>
<span class="gi">+        partition=partition,</span>
<span class="gi">+    )</span>
<span class="gi">+    T = G.__class__()  # Same graph class as G</span>
<span class="gi">+    T.graph.update(G.graph)</span>
<span class="gi">+    T.add_nodes_from(G.nodes.items())</span>
<span class="gi">+    T.add_edges_from(edges)</span>
<span class="gi">+    return T</span>


<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gd">-def maximum_spanning_tree(G, weight=&#39;weight&#39;, algorithm=&#39;kruskal&#39;,</span>
<span class="gd">-    ignore_nan=False):</span>
<span class="gi">+def maximum_spanning_tree(G, weight=&quot;weight&quot;, algorithm=&quot;kruskal&quot;, ignore_nan=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a maximum spanning tree or forest on an undirected graph `G`.

<span class="w"> </span>    Parameters
<span class="gu">@@ -479,7 +732,15 @@ def maximum_spanning_tree(G, weight=&#39;weight&#39;, algorithm=&#39;kruskal&#39;,</span>
<span class="w"> </span>    Isolated nodes with self-loops are in the tree as edgeless isolated nodes.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = maximum_spanning_edges(</span>
<span class="gi">+        G, algorithm, weight, keys=True, data=True, ignore_nan=ignore_nan</span>
<span class="gi">+    )</span>
<span class="gi">+    edges = list(edges)</span>
<span class="gi">+    T = G.__class__()  # Same graph class as G</span>
<span class="gi">+    T.graph.update(G.graph)</span>
<span class="gi">+    T.add_nodes_from(G.nodes.items())</span>
<span class="gi">+    T.add_edges_from(edges)</span>
<span class="gi">+    return T</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -527,7 +788,187 @@ def random_spanning_tree(G, weight=None, *, multiplicative=True, seed=None):</span>
<span class="w"> </span>    .. [1] V. Kulkarni, Generating random combinatorial objects, Journal of
<span class="w"> </span>       Algorithms, 11 (1990), pp. 185–207
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def find_node(merged_nodes, node):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        We can think of clusters of contracted nodes as having one</span>
<span class="gi">+        representative in the graph. Each node which is not in merged_nodes</span>
<span class="gi">+        is still its own representative. Since a representative can be later</span>
<span class="gi">+        contracted, we need to recursively search though the dict to find</span>
<span class="gi">+        the final representative, but once we know it we can use path</span>
<span class="gi">+        compression to speed up the access of the representative for next time.</span>
<span class="gi">+</span>
<span class="gi">+        This cannot be replaced by the standard NetworkX union_find since that</span>
<span class="gi">+        data structure will merge nodes with less representing nodes into the</span>
<span class="gi">+        one with more representing nodes but this function requires we merge</span>
<span class="gi">+        them using the order that contract_edges contracts using.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        merged_nodes : dict</span>
<span class="gi">+            The dict storing the mapping from node to representative</span>
<span class="gi">+        node</span>
<span class="gi">+            The node whose representative we seek</span>
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        The representative of the `node`</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if node not in merged_nodes:</span>
<span class="gi">+            return node</span>
<span class="gi">+        else:</span>
<span class="gi">+            rep = find_node(merged_nodes, merged_nodes[node])</span>
<span class="gi">+            merged_nodes[node] = rep</span>
<span class="gi">+            return rep</span>
<span class="gi">+</span>
<span class="gi">+    def prepare_graph():</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        For the graph `G`, remove all edges not in the set `V` and then</span>
<span class="gi">+        contract all edges in the set `U`.</span>
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        A copy of `G` which has had all edges not in `V` removed and all edges</span>
<span class="gi">+        in `U` contracted.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # The result is a MultiGraph version of G so that parallel edges are</span>
<span class="gi">+        # allowed during edge contraction</span>
<span class="gi">+        result = nx.MultiGraph(incoming_graph_data=G)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove all edges not in V</span>
<span class="gi">+        edges_to_remove = set(result.edges()).difference(V)</span>
<span class="gi">+        result.remove_edges_from(edges_to_remove)</span>
<span class="gi">+</span>
<span class="gi">+        # Contract all edges in U</span>
<span class="gi">+        #</span>
<span class="gi">+        # Imagine that you have two edges to contract and they share an</span>
<span class="gi">+        # endpoint like this:</span>
<span class="gi">+        #                        [0] ----- [1] ----- [2]</span>
<span class="gi">+        # If we contract (0, 1) first, the contraction function will always</span>
<span class="gi">+        # delete the second node it is passed so the resulting graph would be</span>
<span class="gi">+        #                             [0] ----- [2]</span>
<span class="gi">+        # and edge (1, 2) no longer exists but (0, 2) would need to be contracted</span>
<span class="gi">+        # in its place now. That is why I use the below dict as a merge-find</span>
<span class="gi">+        # data structure with path compression to track how the nodes are merged.</span>
<span class="gi">+        merged_nodes = {}</span>
<span class="gi">+</span>
<span class="gi">+        for u, v in U:</span>
<span class="gi">+            u_rep = find_node(merged_nodes, u)</span>
<span class="gi">+            v_rep = find_node(merged_nodes, v)</span>
<span class="gi">+            # We cannot contract a node with itself</span>
<span class="gi">+            if u_rep == v_rep:</span>
<span class="gi">+                continue</span>
<span class="gi">+            nx.contracted_nodes(result, u_rep, v_rep, self_loops=False, copy=False)</span>
<span class="gi">+            merged_nodes[v_rep] = u_rep</span>
<span class="gi">+</span>
<span class="gi">+        return merged_nodes, result</span>
<span class="gi">+</span>
<span class="gi">+    def spanning_tree_total_weight(G, weight):</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Find the sum of weights of the spanning trees of `G` using the</span>
<span class="gi">+        appropriate `method`.</span>
<span class="gi">+</span>
<span class="gi">+        This is easy if the chosen method is &#39;multiplicative&#39;, since we can</span>
<span class="gi">+        use Kirchhoff&#39;s Tree Matrix Theorem directly. However, with the</span>
<span class="gi">+        &#39;additive&#39; method, this process is slightly more complex and less</span>
<span class="gi">+        computationally efficient as we have to find the number of spanning</span>
<span class="gi">+        trees which contain each possible edge in the graph.</span>
<span class="gi">+</span>
<span class="gi">+        Parameters</span>
<span class="gi">+        ----------</span>
<span class="gi">+        G : NetworkX Graph</span>
<span class="gi">+            The graph to find the total weight of all spanning trees on.</span>
<span class="gi">+</span>
<span class="gi">+        weight : string</span>
<span class="gi">+            The key for the weight edge attribute of the graph.</span>
<span class="gi">+</span>
<span class="gi">+        Returns</span>
<span class="gi">+        -------</span>
<span class="gi">+        float</span>
<span class="gi">+            The sum of either the multiplicative or additive weight for all</span>
<span class="gi">+            spanning trees in the graph.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if multiplicative:</span>
<span class="gi">+            return nx.total_spanning_tree_weight(G, weight)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # There are two cases for the total spanning tree additive weight.</span>
<span class="gi">+            # 1. There is one edge in the graph. Then the only spanning tree is</span>
<span class="gi">+            #    that edge itself, which will have a total weight of that edge</span>
<span class="gi">+            #    itself.</span>
<span class="gi">+            if G.number_of_edges() == 1:</span>
<span class="gi">+                return G.edges(data=weight).__iter__().__next__()[2]</span>
<span class="gi">+            # 2. There are no edges or two or more edges in the graph. Then, we find the</span>
<span class="gi">+            #    total weight of the spanning trees using the formula in the</span>
<span class="gi">+            #    reference paper: take the weight of each edge and multiply it by</span>
<span class="gi">+            #    the number of spanning trees which include that edge. This</span>
<span class="gi">+            #    can be accomplished by contracting the edge and finding the</span>
<span class="gi">+            #    multiplicative total spanning tree weight if the weight of each edge</span>
<span class="gi">+            #    is assumed to be 1, which is conveniently built into networkx already,</span>
<span class="gi">+            #    by calling total_spanning_tree_weight with weight=None.</span>
<span class="gi">+            #    Note that with no edges the returned value is just zero.</span>
<span class="gi">+            else:</span>
<span class="gi">+                total = 0</span>
<span class="gi">+                for u, v, w in G.edges(data=weight):</span>
<span class="gi">+                    total += w * nx.total_spanning_tree_weight(</span>
<span class="gi">+                        nx.contracted_edge(G, edge=(u, v), self_loops=False), None</span>
<span class="gi">+                    )</span>
<span class="gi">+                return total</span>
<span class="gi">+</span>
<span class="gi">+    if G.number_of_nodes() &lt; 2:</span>
<span class="gi">+        # no edges in the spanning tree</span>
<span class="gi">+        return nx.empty_graph(G.nodes)</span>
<span class="gi">+</span>
<span class="gi">+    U = set()</span>
<span class="gi">+    st_cached_value = 0</span>
<span class="gi">+    V = set(G.edges())</span>
<span class="gi">+    shuffled_edges = list(G.edges())</span>
<span class="gi">+    seed.shuffle(shuffled_edges)</span>
<span class="gi">+</span>
<span class="gi">+    for u, v in shuffled_edges:</span>
<span class="gi">+        e_weight = G[u][v][weight] if weight is not None else 1</span>
<span class="gi">+        node_map, prepared_G = prepare_graph()</span>
<span class="gi">+        G_total_tree_weight = spanning_tree_total_weight(prepared_G, weight)</span>
<span class="gi">+        # Add the edge to U so that we can compute the total tree weight</span>
<span class="gi">+        # assuming we include that edge</span>
<span class="gi">+        # Now, if (u, v) cannot exist in G because it is fully contracted out</span>
<span class="gi">+        # of existence, then it by definition cannot influence G_e&#39;s Kirchhoff</span>
<span class="gi">+        # value. But, we also cannot pick it.</span>
<span class="gi">+        rep_edge = (find_node(node_map, u), find_node(node_map, v))</span>
<span class="gi">+        # Check to see if the &#39;representative edge&#39; for the current edge is</span>
<span class="gi">+        # in prepared_G. If so, then we can pick it.</span>
<span class="gi">+        if rep_edge in prepared_G.edges:</span>
<span class="gi">+            prepared_G_e = nx.contracted_edge(</span>
<span class="gi">+                prepared_G, edge=rep_edge, self_loops=False</span>
<span class="gi">+            )</span>
<span class="gi">+            G_e_total_tree_weight = spanning_tree_total_weight(prepared_G_e, weight)</span>
<span class="gi">+            if multiplicative:</span>
<span class="gi">+                threshold = e_weight * G_e_total_tree_weight / G_total_tree_weight</span>
<span class="gi">+            else:</span>
<span class="gi">+                numerator = (</span>
<span class="gi">+                    st_cached_value + e_weight</span>
<span class="gi">+                ) * nx.total_spanning_tree_weight(prepared_G_e) + G_e_total_tree_weight</span>
<span class="gi">+                denominator = (</span>
<span class="gi">+                    st_cached_value * nx.total_spanning_tree_weight(prepared_G)</span>
<span class="gi">+                    + G_total_tree_weight</span>
<span class="gi">+                )</span>
<span class="gi">+                threshold = numerator / denominator</span>
<span class="gi">+        else:</span>
<span class="gi">+            threshold = 0.0</span>
<span class="gi">+        z = seed.uniform(0.0, 1.0)</span>
<span class="gi">+        if z &gt; threshold:</span>
<span class="gi">+            # Remove the edge from V since we did not pick it.</span>
<span class="gi">+            V.remove((u, v))</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Add the edge to U since we picked it.</span>
<span class="gi">+            st_cached_value += e_weight</span>
<span class="gi">+            U.add((u, v))</span>
<span class="gi">+        # If we decide to keep an edge, it may complete the spanning tree.</span>
<span class="gi">+        if len(U) == G.number_of_nodes() - 1:</span>
<span class="gi">+            spanning_tree = nx.Graph()</span>
<span class="gi">+            spanning_tree.add_edges_from(U)</span>
<span class="gi">+            return spanning_tree</span>
<span class="gi">+    raise Exception(f&quot;Something went wrong! Only {len(U)} edges in the spanning tree!&quot;)</span>


<span class="w"> </span>class SpanningTreeIterator:
<span class="gu">@@ -550,21 +991,22 @@ class SpanningTreeIterator:</span>
<span class="w"> </span>           https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>    @dataclass(order=True)
<span class="w"> </span>    class Partition:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        This dataclass represents a partition and stores a dict with the edge
<span class="w"> </span>        data and the weight of the minimum spanning tree of the partition dict.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        mst_weight: float
<span class="w"> </span>        partition_dict: dict = field(compare=False)

<span class="w"> </span>        def __copy__(self):
<span class="gd">-            return SpanningTreeIterator.Partition(self.mst_weight, self.</span>
<span class="gd">-                partition_dict.copy())</span>
<span class="gi">+            return SpanningTreeIterator.Partition(</span>
<span class="gi">+                self.mst_weight, self.partition_dict.copy()</span>
<span class="gi">+            )</span>

<span class="gd">-    def __init__(self, G, weight=&#39;weight&#39;, minimum=True, ignore_nan=False):</span>
<span class="gi">+    def __init__(self, G, weight=&quot;weight&quot;, minimum=True, ignore_nan=False):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Initialize the iterator

<span class="gu">@@ -585,12 +1027,14 @@ class SpanningTreeIterator:</span>
<span class="w"> </span>            If `ignore_nan is True` then that edge is ignored instead.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.G = G.copy()
<span class="gd">-        self.G.__networkx_cache__ = None</span>
<span class="gi">+        self.G.__networkx_cache__ = None  # Disable caching</span>
<span class="w"> </span>        self.weight = weight
<span class="w"> </span>        self.minimum = minimum
<span class="w"> </span>        self.ignore_nan = ignore_nan
<span class="gi">+        # Randomly create a key for an edge attribute to hold the partition data</span>
<span class="w"> </span>        self.partition_key = (
<span class="gd">-            &#39;SpanningTreeIterators super secret partition attribute name&#39;)</span>
<span class="gi">+            &quot;SpanningTreeIterators super secret partition attribute name&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -601,11 +1045,14 @@ class SpanningTreeIterator:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self.partition_queue = PriorityQueue()
<span class="w"> </span>        self._clear_partition(self.G)
<span class="gd">-        mst_weight = partition_spanning_tree(self.G, self.minimum, self.</span>
<span class="gd">-            weight, self.partition_key, self.ignore_nan).size(weight=self.</span>
<span class="gd">-            weight)</span>
<span class="gd">-        self.partition_queue.put(self.Partition(mst_weight if self.minimum else</span>
<span class="gd">-            -mst_weight, {}))</span>
<span class="gi">+        mst_weight = partition_spanning_tree(</span>
<span class="gi">+            self.G, self.minimum, self.weight, self.partition_key, self.ignore_nan</span>
<span class="gi">+        ).size(weight=self.weight)</span>
<span class="gi">+</span>
<span class="gi">+        self.partition_queue.put(</span>
<span class="gi">+            self.Partition(mst_weight if self.minimum else -mst_weight, {})</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        return self

<span class="w"> </span>    def __next__(self):
<span class="gu">@@ -619,11 +1066,14 @@ class SpanningTreeIterator:</span>
<span class="w"> </span>        if self.partition_queue.empty():
<span class="w"> </span>            del self.G, self.partition_queue
<span class="w"> </span>            raise StopIteration
<span class="gi">+</span>
<span class="w"> </span>        partition = self.partition_queue.get()
<span class="w"> </span>        self._write_partition(partition)
<span class="gd">-        next_tree = partition_spanning_tree(self.G, self.minimum, self.</span>
<span class="gd">-            weight, self.partition_key, self.ignore_nan)</span>
<span class="gi">+        next_tree = partition_spanning_tree(</span>
<span class="gi">+            self.G, self.minimum, self.weight, self.partition_key, self.ignore_nan</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._partition(partition, next_tree)
<span class="gi">+</span>
<span class="w"> </span>        self._clear_partition(next_tree)
<span class="w"> </span>        return next_tree

<span class="gu">@@ -640,7 +1090,29 @@ class SpanningTreeIterator:</span>
<span class="w"> </span>        partition_tree : nx.Graph
<span class="w"> </span>            The minimum spanning tree of the input partition.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # create two new partitions with the data from the input partition dict</span>
<span class="gi">+        p1 = self.Partition(0, partition.partition_dict.copy())</span>
<span class="gi">+        p2 = self.Partition(0, partition.partition_dict.copy())</span>
<span class="gi">+        for e in partition_tree.edges:</span>
<span class="gi">+            # determine if the edge was open or included</span>
<span class="gi">+            if e not in partition.partition_dict:</span>
<span class="gi">+                # This is an open edge</span>
<span class="gi">+                p1.partition_dict[e] = EdgePartition.EXCLUDED</span>
<span class="gi">+                p2.partition_dict[e] = EdgePartition.INCLUDED</span>
<span class="gi">+</span>
<span class="gi">+                self._write_partition(p1)</span>
<span class="gi">+                p1_mst = partition_spanning_tree(</span>
<span class="gi">+                    self.G,</span>
<span class="gi">+                    self.minimum,</span>
<span class="gi">+                    self.weight,</span>
<span class="gi">+                    self.partition_key,</span>
<span class="gi">+                    self.ignore_nan,</span>
<span class="gi">+                )</span>
<span class="gi">+                p1_mst_weight = p1_mst.size(weight=self.weight)</span>
<span class="gi">+                if nx.is_connected(p1_mst):</span>
<span class="gi">+                    p1.mst_weight = p1_mst_weight if self.minimum else -p1_mst_weight</span>
<span class="gi">+                    self.partition_queue.put(p1.__copy__())</span>
<span class="gi">+                p1.partition_dict = p2.partition_dict.copy()</span>

<span class="w"> </span>    def _write_partition(self, partition):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -653,16 +1125,22 @@ class SpanningTreeIterator:</span>
<span class="w"> </span>            A Partition dataclass describing a partition on the edges of the
<span class="w"> </span>            graph.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for u, v, d in self.G.edges(data=True):</span>
<span class="gi">+            if (u, v) in partition.partition_dict:</span>
<span class="gi">+                d[self.partition_key] = partition.partition_dict[(u, v)]</span>
<span class="gi">+            else:</span>
<span class="gi">+                d[self.partition_key] = EdgePartition.OPEN</span>

<span class="w"> </span>    def _clear_partition(self, G):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Removes partition data from the graph
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for u, v, d in G.edges(data=True):</span>
<span class="gi">+            if self.partition_key in d:</span>
<span class="gi">+                del d[self.partition_key]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def number_of_spanning_trees(G, *, root=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the number of spanning trees in `G`.

<span class="gu">@@ -766,4 +1244,31 @@ def number_of_spanning_trees(G, *, root=None, weight=None):</span>
<span class="w"> </span>        &quot;Matrix-Tree Theorem for Directed Graphs&quot;
<span class="w"> </span>        https://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;Graph G must contain at least one node.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # undirected G</span>
<span class="gi">+    if not nx.is_directed(G):</span>
<span class="gi">+        if not nx.is_connected(G):</span>
<span class="gi">+            return 0</span>
<span class="gi">+        G_laplacian = nx.laplacian_matrix(G, weight=weight).toarray()</span>
<span class="gi">+        return float(np.linalg.det(G_laplacian[1:, 1:]))</span>
<span class="gi">+</span>
<span class="gi">+    # directed G</span>
<span class="gi">+    if root is None:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Input `root` must be provided when G is directed&quot;)</span>
<span class="gi">+    if root not in G:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;The node root is not in the graph G.&quot;)</span>
<span class="gi">+    if not nx.is_weakly_connected(G):</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    # Compute directed Laplacian matrix</span>
<span class="gi">+    nodelist = [root] + [n for n in G if n != root]</span>
<span class="gi">+    A = nx.adjacency_matrix(G, nodelist=nodelist, weight=weight)</span>
<span class="gi">+    D = np.diag(A.sum(axis=0))</span>
<span class="gi">+    G_laplacian = D - A</span>
<span class="gi">+</span>
<span class="gi">+    # Compute number of spanning trees</span>
<span class="gi">+    return float(np.linalg.det(G_laplacian[1:, 1:]))</span>
<span class="gh">diff --git a/networkx/algorithms/tree/operations.py b/networkx/algorithms/tree/operations.py</span>
<span class="gh">index 3f085fb29..f4368d6a3 100644</span>
<span class="gd">--- a/networkx/algorithms/tree/operations.py</span>
<span class="gi">+++ b/networkx/algorithms/tree/operations.py</span>
<span class="gu">@@ -1,8 +1,10 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Operations on trees.&quot;&quot;&quot;
<span class="w"> </span>from functools import partial
<span class="w"> </span>from itertools import accumulate, chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;join&#39;, &#39;join_trees&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;join&quot;, &quot;join_trees&quot;]</span>


<span class="w"> </span>def join(rooted_trees, label_attribute=None):
<span class="gu">@@ -17,9 +19,19 @@ def join(rooted_trees, label_attribute=None):</span>
<span class="w"> </span>       It has been renamed join_trees with the same syntax/interface.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;The function `join` is deprecated and is renamed `join_trees`.\n&quot;</span>
<span class="gi">+        &quot;The ``join`` function itself will be removed in v3.4&quot;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>

<span class="gi">+    return join_trees(rooted_trees, label_attribute=label_attribute)</span>

<span class="gi">+</span>
<span class="gi">+# Argument types don&#39;t match dispatching, but allow manual selection of backend</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def join_trees(rooted_trees, *, label_attribute=None, first_label=0):
<span class="w"> </span>    &quot;&quot;&quot;Returns a new rooted tree made by joining `rooted_trees`
<span class="gu">@@ -79,4 +91,38 @@ def join_trees(rooted_trees, *, label_attribute=None, first_label=0):</span>
<span class="w"> </span>        True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not rooted_trees:</span>
<span class="gi">+        return nx.empty_graph(1)</span>
<span class="gi">+</span>
<span class="gi">+    # Unzip the zipped list of (tree, root) pairs.</span>
<span class="gi">+    trees, roots = zip(*rooted_trees)</span>
<span class="gi">+</span>
<span class="gi">+    # The join of the trees has the same type as the type of the first tree.</span>
<span class="gi">+    R = type(trees[0])()</span>
<span class="gi">+</span>
<span class="gi">+    lengths = (len(tree) for tree in trees[:-1])</span>
<span class="gi">+    first_labels = list(accumulate(lengths, initial=first_label + 1))</span>
<span class="gi">+</span>
<span class="gi">+    new_roots = []</span>
<span class="gi">+    for tree, root, first_node in zip(trees, roots, first_labels):</span>
<span class="gi">+        new_root = first_node + list(tree.nodes()).index(root)</span>
<span class="gi">+        new_roots.append(new_root)</span>
<span class="gi">+</span>
<span class="gi">+    # Relabel the nodes so that their union is the integers starting at first_label.</span>
<span class="gi">+    relabel = partial(</span>
<span class="gi">+        nx.convert_node_labels_to_integers, label_attribute=label_attribute</span>
<span class="gi">+    )</span>
<span class="gi">+    new_trees = [</span>
<span class="gi">+        relabel(tree, first_label=first_label)</span>
<span class="gi">+        for tree, first_label in zip(trees, first_labels)</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    # Add all sets of nodes and edges, attributes</span>
<span class="gi">+    for tree in new_trees:</span>
<span class="gi">+        R.update(tree)</span>
<span class="gi">+</span>
<span class="gi">+    # Finally, join the subtrees at the root. We know first_label is unused by the way we relabeled the subtrees.</span>
<span class="gi">+    R.add_node(first_label)</span>
<span class="gi">+    R.add_edges_from((first_label, root) for root in new_roots)</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>
<span class="gh">diff --git a/networkx/algorithms/tree/recognition.py b/networkx/algorithms/tree/recognition.py</span>
<span class="gh">index 71add2188..a9eae9870 100644</span>
<span class="gd">--- a/networkx/algorithms/tree/recognition.py</span>
<span class="gi">+++ b/networkx/algorithms/tree/recognition.py</span>
<span class="gu">@@ -72,11 +72,13 @@ nodes from a larger graph, and it is in this context that the term &quot;spanning&quot;</span>
<span class="w"> </span>becomes a useful notion.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;is_arborescence&#39;, &#39;is_branching&#39;, &#39;is_forest&#39;, &#39;is_tree&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;is_arborescence&quot;, &quot;is_branching&quot;, &quot;is_forest&quot;, &quot;is_tree&quot;]</span>


<span class="gd">-@nx.utils.not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_arborescence(G):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -113,10 +115,10 @@ def is_arborescence(G):</span>
<span class="w"> </span>    is_tree

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return is_tree(G) and max(d for n, d in G.in_degree()) &lt;= 1</span>


<span class="gd">-@nx.utils.not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def is_branching(G):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -153,7 +155,7 @@ def is_branching(G):</span>
<span class="w"> </span>    is_forest

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return is_forest(G) and max(d for n, d in G.in_degree()) &lt;= 1</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -202,7 +204,15 @@ def is_forest(G):</span>
<span class="w"> </span>    is_branching

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.exception.NetworkXPointlessConcept(&quot;G has no nodes.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        components = (G.subgraph(c) for c in nx.weakly_connected_components(G))</span>
<span class="gi">+    else:</span>
<span class="gi">+        components = (G.subgraph(c) for c in nx.connected_components(G))</span>
<span class="gi">+</span>
<span class="gi">+    return all(len(c) - 1 == c.number_of_edges() for c in components)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -251,4 +261,13 @@ def is_tree(G):</span>
<span class="w"> </span>    is_arborescence

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.exception.NetworkXPointlessConcept(&quot;G has no nodes.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        is_connected = nx.is_weakly_connected</span>
<span class="gi">+    else:</span>
<span class="gi">+        is_connected = nx.is_connected</span>
<span class="gi">+</span>
<span class="gi">+    # A connected graph with no cycles has n-1 edges.</span>
<span class="gi">+    return len(G) - 1 == G.number_of_edges() and is_connected(G)</span>
<span class="gh">diff --git a/networkx/algorithms/triads.py b/networkx/algorithms/triads.py</span>
<span class="gh">index ab34e2910..1e67c1453 100644</span>
<span class="gd">--- a/networkx/algorithms/triads.py</span>
<span class="gi">+++ b/networkx/algorithms/triads.py</span>
<span class="gu">@@ -1,16 +1,118 @@</span>
<span class="gi">+# See https://github.com/networkx/networkx/pull/1474</span>
<span class="gi">+# Copyright 2011 Reya Group &lt;http://www.reyagroup.com&gt;</span>
<span class="gi">+# Copyright 2011 Alex Levenson &lt;alex@isnotinvain.com&gt;</span>
<span class="gi">+# Copyright 2011 Diederik van Liere &lt;diederik.vanliere@rotman.utoronto.ca&gt;</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for analyzing triads of a graph.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from itertools import combinations, permutations
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, py_random_state
<span class="gd">-__all__ = [&#39;triadic_census&#39;, &#39;is_triad&#39;, &#39;all_triplets&#39;, &#39;all_triads&#39;,</span>
<span class="gd">-    &#39;triads_by_type&#39;, &#39;triad_type&#39;, &#39;random_triad&#39;]</span>
<span class="gd">-TRICODES = (1, 2, 2, 3, 2, 4, 6, 8, 2, 6, 5, 7, 3, 8, 7, 11, 2, 6, 4, 8, 5,</span>
<span class="gd">-    9, 9, 13, 6, 10, 9, 14, 7, 14, 12, 15, 2, 5, 6, 7, 6, 9, 10, 14, 4, 9, </span>
<span class="gd">-    9, 12, 8, 13, 14, 15, 3, 7, 8, 11, 7, 12, 14, 15, 8, 14, 13, 15, 11, 15,</span>
<span class="gd">-    15, 16)</span>
<span class="gd">-TRIAD_NAMES = (&#39;003&#39;, &#39;012&#39;, &#39;102&#39;, &#39;021D&#39;, &#39;021U&#39;, &#39;021C&#39;, &#39;111D&#39;, &#39;111U&#39;,</span>
<span class="gd">-    &#39;030T&#39;, &#39;030C&#39;, &#39;201&#39;, &#39;120D&#39;, &#39;120U&#39;, &#39;120C&#39;, &#39;210&#39;, &#39;300&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;triadic_census&quot;,</span>
<span class="gi">+    &quot;is_triad&quot;,</span>
<span class="gi">+    &quot;all_triplets&quot;,</span>
<span class="gi">+    &quot;all_triads&quot;,</span>
<span class="gi">+    &quot;triads_by_type&quot;,</span>
<span class="gi">+    &quot;triad_type&quot;,</span>
<span class="gi">+    &quot;random_triad&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+#: The integer codes representing each type of triad.</span>
<span class="gi">+#:</span>
<span class="gi">+#: Triads that are the same up to symmetry have the same code.</span>
<span class="gi">+TRICODES = (</span>
<span class="gi">+    1,</span>
<span class="gi">+    2,</span>
<span class="gi">+    2,</span>
<span class="gi">+    3,</span>
<span class="gi">+    2,</span>
<span class="gi">+    4,</span>
<span class="gi">+    6,</span>
<span class="gi">+    8,</span>
<span class="gi">+    2,</span>
<span class="gi">+    6,</span>
<span class="gi">+    5,</span>
<span class="gi">+    7,</span>
<span class="gi">+    3,</span>
<span class="gi">+    8,</span>
<span class="gi">+    7,</span>
<span class="gi">+    11,</span>
<span class="gi">+    2,</span>
<span class="gi">+    6,</span>
<span class="gi">+    4,</span>
<span class="gi">+    8,</span>
<span class="gi">+    5,</span>
<span class="gi">+    9,</span>
<span class="gi">+    9,</span>
<span class="gi">+    13,</span>
<span class="gi">+    6,</span>
<span class="gi">+    10,</span>
<span class="gi">+    9,</span>
<span class="gi">+    14,</span>
<span class="gi">+    7,</span>
<span class="gi">+    14,</span>
<span class="gi">+    12,</span>
<span class="gi">+    15,</span>
<span class="gi">+    2,</span>
<span class="gi">+    5,</span>
<span class="gi">+    6,</span>
<span class="gi">+    7,</span>
<span class="gi">+    6,</span>
<span class="gi">+    9,</span>
<span class="gi">+    10,</span>
<span class="gi">+    14,</span>
<span class="gi">+    4,</span>
<span class="gi">+    9,</span>
<span class="gi">+    9,</span>
<span class="gi">+    12,</span>
<span class="gi">+    8,</span>
<span class="gi">+    13,</span>
<span class="gi">+    14,</span>
<span class="gi">+    15,</span>
<span class="gi">+    3,</span>
<span class="gi">+    7,</span>
<span class="gi">+    8,</span>
<span class="gi">+    11,</span>
<span class="gi">+    7,</span>
<span class="gi">+    12,</span>
<span class="gi">+    14,</span>
<span class="gi">+    15,</span>
<span class="gi">+    8,</span>
<span class="gi">+    14,</span>
<span class="gi">+    13,</span>
<span class="gi">+    15,</span>
<span class="gi">+    11,</span>
<span class="gi">+    15,</span>
<span class="gi">+    15,</span>
<span class="gi">+    16,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+#: The names of each type of triad. The order of the elements is</span>
<span class="gi">+#: important: it corresponds to the tricodes given in :data:`TRICODES`.</span>
<span class="gi">+TRIAD_NAMES = (</span>
<span class="gi">+    &quot;003&quot;,</span>
<span class="gi">+    &quot;012&quot;,</span>
<span class="gi">+    &quot;102&quot;,</span>
<span class="gi">+    &quot;021D&quot;,</span>
<span class="gi">+    &quot;021U&quot;,</span>
<span class="gi">+    &quot;021C&quot;,</span>
<span class="gi">+    &quot;111D&quot;,</span>
<span class="gi">+    &quot;111U&quot;,</span>
<span class="gi">+    &quot;030T&quot;,</span>
<span class="gi">+    &quot;030C&quot;,</span>
<span class="gi">+    &quot;201&quot;,</span>
<span class="gi">+    &quot;120D&quot;,</span>
<span class="gi">+    &quot;120U&quot;,</span>
<span class="gi">+    &quot;120C&quot;,</span>
<span class="gi">+    &quot;210&quot;,</span>
<span class="gi">+    &quot;300&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#: A dictionary mapping triad code to triad name.</span>
<span class="w"> </span>TRICODE_TO_NAME = {i: TRIAD_NAMES[code - 1] for i, code in enumerate(TRICODES)}


<span class="gu">@@ -22,10 +124,11 @@ def _tricode(G, v, u, w):</span>
<span class="w"> </span>    the binary representation of an integer.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    combos = ((v, u, 1), (u, v, 2), (v, w, 4), (w, v, 8), (u, w, 16), (w, u, 32))</span>
<span class="gi">+    return sum(x for u, v, x in combos if v in G[u])</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def triadic_census(G, nodelist=None):
<span class="w"> </span>    &quot;&quot;&quot;Determines the triadic census of a directed graph.
<span class="gu">@@ -97,7 +200,84 @@ def triadic_census(G, nodelist=None):</span>
<span class="w"> </span>        http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodeset = set(G.nbunch_iter(nodelist))</span>
<span class="gi">+    if nodelist is not None and len(nodelist) != len(nodeset):</span>
<span class="gi">+        raise ValueError(&quot;nodelist includes duplicate nodes or nodes not in G&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    N = len(G)</span>
<span class="gi">+    Nnot = N - len(nodeset)  # can signal special counting for subset of nodes</span>
<span class="gi">+</span>
<span class="gi">+    # create an ordering of nodes with nodeset nodes first</span>
<span class="gi">+    m = {n: i for i, n in enumerate(nodeset)}</span>
<span class="gi">+    if Nnot:</span>
<span class="gi">+        # add non-nodeset nodes later in the ordering</span>
<span class="gi">+        not_nodeset = G.nodes - nodeset</span>
<span class="gi">+        m.update((n, i + N) for i, n in enumerate(not_nodeset))</span>
<span class="gi">+</span>
<span class="gi">+    # build all_neighbor dicts for easy counting</span>
<span class="gi">+    # After Python 3.8 can leave off these keys(). Speedup also using G._pred</span>
<span class="gi">+    # nbrs = {n: G._pred[n].keys() | G._succ[n].keys() for n in G}</span>
<span class="gi">+    nbrs = {n: G.pred[n].keys() | G.succ[n].keys() for n in G}</span>
<span class="gi">+    dbl_nbrs = {n: G.pred[n].keys() &amp; G.succ[n].keys() for n in G}</span>
<span class="gi">+</span>
<span class="gi">+    if Nnot:</span>
<span class="gi">+        sgl_nbrs = {n: G.pred[n].keys() ^ G.succ[n].keys() for n in not_nodeset}</span>
<span class="gi">+        # find number of edges not incident to nodes in nodeset</span>
<span class="gi">+        sgl = sum(1 for n in not_nodeset for nbr in sgl_nbrs[n] if nbr not in nodeset)</span>
<span class="gi">+        sgl_edges_outside = sgl // 2</span>
<span class="gi">+        dbl = sum(1 for n in not_nodeset for nbr in dbl_nbrs[n] if nbr not in nodeset)</span>
<span class="gi">+        dbl_edges_outside = dbl // 2</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize the count for each triad to be zero.</span>
<span class="gi">+    census = {name: 0 for name in TRIAD_NAMES}</span>
<span class="gi">+    # Main loop over nodes</span>
<span class="gi">+    for v in nodeset:</span>
<span class="gi">+        vnbrs = nbrs[v]</span>
<span class="gi">+        dbl_vnbrs = dbl_nbrs[v]</span>
<span class="gi">+        if Nnot:</span>
<span class="gi">+            # set up counts of edges attached to v.</span>
<span class="gi">+            sgl_unbrs_bdy = sgl_unbrs_out = dbl_unbrs_bdy = dbl_unbrs_out = 0</span>
<span class="gi">+        for u in vnbrs:</span>
<span class="gi">+            if m[u] &lt;= m[v]:</span>
<span class="gi">+                continue</span>
<span class="gi">+            unbrs = nbrs[u]</span>
<span class="gi">+            neighbors = (vnbrs | unbrs) - {u, v}</span>
<span class="gi">+            # Count connected triads.</span>
<span class="gi">+            for w in neighbors:</span>
<span class="gi">+                if m[u] &lt; m[w] or (m[v] &lt; m[w] &lt; m[u] and v not in nbrs[w]):</span>
<span class="gi">+                    code = _tricode(G, v, u, w)</span>
<span class="gi">+                    census[TRICODE_TO_NAME[code]] += 1</span>
<span class="gi">+</span>
<span class="gi">+            # Use a formula for dyadic triads with edge incident to v</span>
<span class="gi">+            if u in dbl_vnbrs:</span>
<span class="gi">+                census[&quot;102&quot;] += N - len(neighbors) - 2</span>
<span class="gi">+            else:</span>
<span class="gi">+                census[&quot;012&quot;] += N - len(neighbors) - 2</span>
<span class="gi">+</span>
<span class="gi">+            # Count edges attached to v. Subtract later to get triads with v isolated</span>
<span class="gi">+            # _out are (u,unbr) for unbrs outside boundary of nodeset</span>
<span class="gi">+            # _bdy are (u,unbr) for unbrs on boundary of nodeset (get double counted)</span>
<span class="gi">+            if Nnot and u not in nodeset:</span>
<span class="gi">+                sgl_unbrs = sgl_nbrs[u]</span>
<span class="gi">+                sgl_unbrs_bdy += len(sgl_unbrs &amp; vnbrs - nodeset)</span>
<span class="gi">+                sgl_unbrs_out += len(sgl_unbrs - vnbrs - nodeset)</span>
<span class="gi">+                dbl_unbrs = dbl_nbrs[u]</span>
<span class="gi">+                dbl_unbrs_bdy += len(dbl_unbrs &amp; vnbrs - nodeset)</span>
<span class="gi">+                dbl_unbrs_out += len(dbl_unbrs - vnbrs - nodeset)</span>
<span class="gi">+        # if nodeset == G.nodes, skip this b/c we will find the edge later.</span>
<span class="gi">+        if Nnot:</span>
<span class="gi">+            # Count edges outside nodeset not connected with v (v isolated triads)</span>
<span class="gi">+            census[&quot;012&quot;] += sgl_edges_outside - (sgl_unbrs_out + sgl_unbrs_bdy // 2)</span>
<span class="gi">+            census[&quot;102&quot;] += dbl_edges_outside - (dbl_unbrs_out + dbl_unbrs_bdy // 2)</span>
<span class="gi">+</span>
<span class="gi">+    # calculate null triads: &quot;003&quot;</span>
<span class="gi">+    # null triads = total number of possible triads - all found triads</span>
<span class="gi">+    total_triangles = (N * (N - 1) * (N - 2)) // 6</span>
<span class="gi">+    triangles_without_nodeset = (Nnot * (Nnot - 1) * (Nnot - 2)) // 6</span>
<span class="gi">+    total_census = total_triangles - triangles_without_nodeset</span>
<span class="gi">+    census[&quot;003&quot;] = total_census - sum(census.values())</span>
<span class="gi">+</span>
<span class="gi">+    return census</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -123,10 +303,14 @@ def is_triad(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.is_triad(G)
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(G, nx.Graph):</span>
<span class="gi">+        if G.order() == 3 and nx.is_directed(G):</span>
<span class="gi">+            if not any((n, n) in G.edges() for n in G.nodes()):</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def all_triplets(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns a generator of all possible sets of 3 nodes in a DiGraph.
<span class="gu">@@ -155,10 +339,21 @@ def all_triplets(G):</span>
<span class="w"> </span>    [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>

<span class="gi">+    warnings.warn(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;\n\nall_triplets is deprecated and will be rmoved in v3.5.\n&quot;</span>
<span class="gi">+            &quot;Use `itertools.combinations(G, 3)` instead.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+        category=DeprecationWarning,</span>
<span class="gi">+        stacklevel=4,</span>
<span class="gi">+    )</span>
<span class="gi">+    triplets = combinations(G.nodes(), 3)</span>
<span class="gi">+    return triplets</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def all_triads(G):
<span class="w"> </span>    &quot;&quot;&quot;A generator of all possible triads in G.
<span class="gu">@@ -184,10 +379,12 @@ def all_triads(G):</span>
<span class="w"> </span>    [(2, 3), (3, 4), (4, 2)]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    triplets = combinations(G.nodes(), 3)</span>
<span class="gi">+    for triplet in triplets:</span>
<span class="gi">+        yield G.subgraph(triplet).copy()</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def triads_by_type(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns a list of all triads for each triad type in a directed graph.
<span class="gu">@@ -240,10 +437,17 @@ def triads_by_type(G):</span>
<span class="w"> </span>        Oxford.
<span class="w"> </span>        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # num_triads = o * (o - 1) * (o - 2) // 6</span>
<span class="gi">+    # if num_triads &gt; TRIAD_LIMIT: print(WARNING)</span>
<span class="gi">+    all_tri = all_triads(G)</span>
<span class="gi">+    tri_by_type = defaultdict(list)</span>
<span class="gi">+    for triad in all_tri:</span>
<span class="gi">+        name = triad_type(triad)</span>
<span class="gi">+        tri_by_type[name].append(triad)</span>
<span class="gi">+    return tri_by_type</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def triad_type(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the sociological triad type for a triad.
<span class="gu">@@ -294,10 +498,54 @@ def triad_type(G):</span>
<span class="w"> </span>        Oxford.
<span class="w"> </span>        https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+    if not is_triad(G):</span>
<span class="gi">+        raise nx.NetworkXAlgorithmError(&quot;G is not a triad (order-3 DiGraph)&quot;)</span>
<span class="gi">+    num_edges = len(G.edges())</span>
<span class="gi">+    if num_edges == 0:</span>
<span class="gi">+        return &quot;003&quot;</span>
<span class="gi">+    elif num_edges == 1:</span>
<span class="gi">+        return &quot;012&quot;</span>
<span class="gi">+    elif num_edges == 2:</span>
<span class="gi">+        e1, e2 = G.edges()</span>
<span class="gi">+        if set(e1) == set(e2):</span>
<span class="gi">+            return &quot;102&quot;</span>
<span class="gi">+        elif e1[0] == e2[0]:</span>
<span class="gi">+            return &quot;021D&quot;</span>
<span class="gi">+        elif e1[1] == e2[1]:</span>
<span class="gi">+            return &quot;021U&quot;</span>
<span class="gi">+        elif e1[1] == e2[0] or e2[1] == e1[0]:</span>
<span class="gi">+            return &quot;021C&quot;</span>
<span class="gi">+    elif num_edges == 3:</span>
<span class="gi">+        for e1, e2, e3 in permutations(G.edges(), 3):</span>
<span class="gi">+            if set(e1) == set(e2):</span>
<span class="gi">+                if e3[0] in e1:</span>
<span class="gi">+                    return &quot;111U&quot;</span>
<span class="gi">+                # e3[1] in e1:</span>
<span class="gi">+                return &quot;111D&quot;</span>
<span class="gi">+            elif set(e1).symmetric_difference(set(e2)) == set(e3):</span>
<span class="gi">+                if {e1[0], e2[0], e3[0]} == {e1[0], e2[0], e3[0]} == set(G.nodes()):</span>
<span class="gi">+                    return &quot;030C&quot;</span>
<span class="gi">+                # e3 == (e1[0], e2[1]) and e2 == (e1[1], e3[1]):</span>
<span class="gi">+                return &quot;030T&quot;</span>
<span class="gi">+    elif num_edges == 4:</span>
<span class="gi">+        for e1, e2, e3, e4 in permutations(G.edges(), 4):</span>
<span class="gi">+            if set(e1) == set(e2):</span>
<span class="gi">+                # identify pair of symmetric edges (which necessarily exists)</span>
<span class="gi">+                if set(e3) == set(e4):</span>
<span class="gi">+                    return &quot;201&quot;</span>
<span class="gi">+                if {e3[0]} == {e4[0]} == set(e3).intersection(set(e4)):</span>
<span class="gi">+                    return &quot;120D&quot;</span>
<span class="gi">+                if {e3[1]} == {e4[1]} == set(e3).intersection(set(e4)):</span>
<span class="gi">+                    return &quot;120U&quot;</span>
<span class="gi">+                if e3[1] == e4[0]:</span>
<span class="gi">+                    return &quot;120C&quot;</span>
<span class="gi">+    elif num_edges == 5:</span>
<span class="gi">+        return &quot;210&quot;</span>
<span class="gi">+    elif num_edges == 6:</span>
<span class="gi">+        return &quot;300&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>@py_random_state(1)
<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="w"> </span>def random_triad(G, seed=None):
<span class="gu">@@ -336,4 +584,21 @@ def random_triad(G, seed=None):</span>
<span class="w"> </span>    OutEdgeView([(1, 2)])

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;\n\nrandom_triad is deprecated and will be removed in NetworkX v3.5.\n&quot;</span>
<span class="gi">+            &quot;Use random.sample instead, e.g.::\n\n&quot;</span>
<span class="gi">+            &quot;\tG.subgraph(random.sample(list(G), 3))\n&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+        category=DeprecationWarning,</span>
<span class="gi">+        stacklevel=5,</span>
<span class="gi">+    )</span>
<span class="gi">+    if len(G) &lt; 3:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;G needs at least 3 nodes to form a triad; (it has {len(G)} nodes)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    nodes = seed.sample(list(G.nodes()), 3)</span>
<span class="gi">+    G2 = G.subgraph(nodes)</span>
<span class="gi">+    return G2</span>
<span class="gh">diff --git a/networkx/algorithms/vitality.py b/networkx/algorithms/vitality.py</span>
<span class="gh">index a54ae099b..29f98fd1b 100644</span>
<span class="gd">--- a/networkx/algorithms/vitality.py</span>
<span class="gi">+++ b/networkx/algorithms/vitality.py</span>
<span class="gu">@@ -2,11 +2,13 @@</span>
<span class="w"> </span>Vitality measures.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;closeness_vitality&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;closeness_vitality&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def closeness_vitality(G, node=None, weight=None, wiener_index=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the closeness vitality for nodes in the graph.

<span class="gu">@@ -64,4 +66,11 @@ def closeness_vitality(G, node=None, weight=None, wiener_index=None):</span>
<span class="w"> </span>           &lt;http://books.google.com/books?id=TTNhSm7HYrIC&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if wiener_index is None:</span>
<span class="gi">+        wiener_index = nx.wiener_index(G, weight=weight)</span>
<span class="gi">+    if node is not None:</span>
<span class="gi">+        after = nx.wiener_index(G.subgraph(set(G) - {node}), weight=weight)</span>
<span class="gi">+        return wiener_index - after</span>
<span class="gi">+    vitality = partial(closeness_vitality, G, weight=weight, wiener_index=wiener_index)</span>
<span class="gi">+    # TODO This can be trivially parallelized.</span>
<span class="gi">+    return {v: vitality(node=v) for v in G}</span>
<span class="gh">diff --git a/networkx/algorithms/voronoi.py b/networkx/algorithms/voronoi.py</span>
<span class="gh">index 913e63c6c..60c453323 100644</span>
<span class="gd">--- a/networkx/algorithms/voronoi.py</span>
<span class="gi">+++ b/networkx/algorithms/voronoi.py</span>
<span class="gu">@@ -1,11 +1,12 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for computing the Voronoi cells of a graph.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import groups
<span class="gd">-__all__ = [&#39;voronoi_cells&#39;]</span>

<span class="gi">+__all__ = [&quot;voronoi_cells&quot;]</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def voronoi_cells(G, center_nodes, weight=&#39;weight&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def voronoi_cells(G, center_nodes, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the Voronoi cells centered at `center_nodes` with respect
<span class="w"> </span>    to the shortest-path distance metric.

<span class="gu">@@ -67,4 +68,18 @@ def voronoi_cells(G, center_nodes, weight=&#39;weight&#39;):</span>
<span class="w"> </span>        https://doi.org/10.1002/1097-0037(200010)36:3&lt;156::AID-NET2&gt;3.0.CO;2-L

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Determine the shortest paths from any one of the center nodes to</span>
<span class="gi">+    # every node in the graph.</span>
<span class="gi">+    #</span>
<span class="gi">+    # This raises `ValueError` if `center_nodes` is an empty set.</span>
<span class="gi">+    paths = nx.multi_source_dijkstra_path(G, center_nodes, weight=weight)</span>
<span class="gi">+    # Determine the center node from which the shortest path originates.</span>
<span class="gi">+    nearest = {v: p[0] for v, p in paths.items()}</span>
<span class="gi">+    # Get the mapping from center node to all nodes closer to it than to</span>
<span class="gi">+    # any other center node.</span>
<span class="gi">+    cells = groups(nearest)</span>
<span class="gi">+    # We collect all unreachable nodes under a special key, if there are any.</span>
<span class="gi">+    unreachable = set(G) - set(nearest)</span>
<span class="gi">+    if unreachable:</span>
<span class="gi">+        cells[&quot;unreachable&quot;] = unreachable</span>
<span class="gi">+    return cells</span>
<span class="gh">diff --git a/networkx/algorithms/walks.py b/networkx/algorithms/walks.py</span>
<span class="gh">index 0727449a3..fe3417577 100644</span>
<span class="gd">--- a/networkx/algorithms/walks.py</span>
<span class="gi">+++ b/networkx/algorithms/walks.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Function for computing walks in a graph.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;number_of_walks&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;number_of_walks&quot;]</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -62,4 +64,17 @@ def number_of_walks(G, walk_length):</span>
<span class="w"> </span>    1

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if walk_length &lt; 0:</span>
<span class="gi">+        raise ValueError(f&quot;`walk_length` cannot be negative: {walk_length}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    A = nx.adjacency_matrix(G, weight=None)</span>
<span class="gi">+    # TODO: Use matrix_power from scipy.sparse when available</span>
<span class="gi">+    # power = sp.sparse.linalg.matrix_power(A, walk_length)</span>
<span class="gi">+    power = np.linalg.matrix_power(A.toarray(), walk_length)</span>
<span class="gi">+    result = {</span>
<span class="gi">+        u: {v: power.item(u_idx, v_idx) for v_idx, v in enumerate(G)}</span>
<span class="gi">+        for u_idx, u in enumerate(G)</span>
<span class="gi">+    }</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/networkx/algorithms/wiener.py b/networkx/algorithms/wiener.py</span>
<span class="gh">index 6ff78645d..cb55d609f 100644</span>
<span class="gd">--- a/networkx/algorithms/wiener.py</span>
<span class="gi">+++ b/networkx/algorithms/wiener.py</span>
<span class="gu">@@ -14,12 +14,15 @@ References</span>
<span class="w"> </span>       Croatica Chemica Acta, 71 (1998), 21-51.
<span class="w"> </span>       https://hrcak.srce.hr/132323
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import itertools as it
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;wiener_index&#39;, &#39;schultz_index&#39;, &#39;gutman_index&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;wiener_index&quot;, &quot;schultz_index&quot;, &quot;gutman_index&quot;]</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def wiener_index(G, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the Wiener index of the given graph.

<span class="gu">@@ -79,14 +82,21 @@ def wiener_index(G, weight=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] `Wikipedia: Wiener Index &lt;https://en.wikipedia.org/wiki/Wiener_index&gt;`_
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    connected = nx.is_strongly_connected(G) if G.is_directed() else nx.is_connected(G)</span>
<span class="gi">+    if not connected:</span>
<span class="gi">+        return float(&quot;inf&quot;)</span>

<span class="gi">+    spl = nx.shortest_path_length(G, weight=weight)</span>
<span class="gi">+    total = sum(it.chain.from_iterable(nbrs.values() for node, nbrs in spl))</span>
<span class="gi">+    # Need to account for double counting pairs of nodes in undirected graphs.</span>
<span class="gi">+    return total if G.is_directed() else total / 2</span>

<span class="gd">-@nx.utils.not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx.utils.not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def schultz_index(G, weight=None):
<span class="gd">-    &quot;&quot;&quot;Returns the Schultz Index (of the first kind) of `G`</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Schultz Index (of the first kind) of `G`</span>

<span class="w"> </span>    The *Schultz Index* [3]_ of a graph is the sum over all node pairs of
<span class="w"> </span>    distances times the sum of degrees. Consider an undirected graph `G`.
<span class="gu">@@ -142,14 +152,19 @@ def schultz_index(G, weight=None):</span>
<span class="w"> </span>           J. Chem. Inf. Comput. Sci. 29 (1989), 239–257.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        return float(&quot;inf&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    spl = nx.shortest_path_length(G, weight=weight)</span>
<span class="gi">+    d = dict(G.degree, weight=weight)</span>
<span class="gi">+    return sum(dist * (d[u] + d[v]) for u, info in spl for v, dist in info.items()) / 2</span>


<span class="gd">-@nx.utils.not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx.utils.not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def gutman_index(G, weight=None):
<span class="gd">-    &quot;&quot;&quot;Returns the Gutman Index for the graph `G`.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Gutman Index for the graph `G`.</span>

<span class="w"> </span>    The *Gutman Index* measures the topology of networks, especially for molecule
<span class="w"> </span>    networks of atoms connected by bonds [1]_. It is also called the Schultz Index
<span class="gu">@@ -203,4 +218,9 @@ def gutman_index(G, weight=None):</span>
<span class="w"> </span>           https://doi.org/10.1021/ci00021a009

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        return float(&quot;inf&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    spl = nx.shortest_path_length(G, weight=weight)</span>
<span class="gi">+    d = dict(G.degree, weight=weight)</span>
<span class="gi">+    return sum(dist * d[u] * d[v] for u, vinfo in spl for v, dist in vinfo.items()) / 2</span>
<span class="gh">diff --git a/networkx/classes/coreviews.py b/networkx/classes/coreviews.py</span>
<span class="gh">index d7c9ab0ce..f4b54c7b7 100644</span>
<span class="gd">--- a/networkx/classes/coreviews.py</span>
<span class="gi">+++ b/networkx/classes/coreviews.py</span>
<span class="gu">@@ -3,10 +3,20 @@ These ``Views`` often restrict element access, with either the entire view or</span>
<span class="w"> </span>layers of nested mappings being read-only.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections.abc import Mapping
<span class="gd">-__all__ = [&#39;AtlasView&#39;, &#39;AdjacencyView&#39;, &#39;MultiAdjacencyView&#39;, &#39;UnionAtlas&#39;,</span>
<span class="gd">-    &#39;UnionAdjacency&#39;, &#39;UnionMultiInner&#39;, &#39;UnionMultiAdjacency&#39;,</span>
<span class="gd">-    &#39;FilterAtlas&#39;, &#39;FilterAdjacency&#39;, &#39;FilterMultiInner&#39;,</span>
<span class="gd">-    &#39;FilterMultiAdjacency&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;AtlasView&quot;,</span>
<span class="gi">+    &quot;AdjacencyView&quot;,</span>
<span class="gi">+    &quot;MultiAdjacencyView&quot;,</span>
<span class="gi">+    &quot;UnionAtlas&quot;,</span>
<span class="gi">+    &quot;UnionAdjacency&quot;,</span>
<span class="gi">+    &quot;UnionMultiInner&quot;,</span>
<span class="gi">+    &quot;UnionMultiAdjacency&quot;,</span>
<span class="gi">+    &quot;FilterAtlas&quot;,</span>
<span class="gi">+    &quot;FilterAdjacency&quot;,</span>
<span class="gi">+    &quot;FilterMultiInner&quot;,</span>
<span class="gi">+    &quot;FilterMultiAdjacency&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class AtlasView(Mapping):
<span class="gu">@@ -21,13 +31,14 @@ class AtlasView(Mapping):</span>
<span class="w"> </span>    AdjacencyView: View into dict-of-dict-of-dict
<span class="w"> </span>    MultiAdjacencyView: View into dict-of-dict-of-dict-of-dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_atlas&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;_atlas&quot;,)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="gd">-        return {&#39;_atlas&#39;: self._atlas}</span>
<span class="gi">+        return {&quot;_atlas&quot;: self._atlas}</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="gd">-        self._atlas = state[&#39;_atlas&#39;]</span>
<span class="gi">+        self._atlas = state[&quot;_atlas&quot;]</span>

<span class="w"> </span>    def __init__(self, d):
<span class="w"> </span>        self._atlas = d
<span class="gu">@@ -41,11 +52,14 @@ class AtlasView(Mapping):</span>
<span class="w"> </span>    def __getitem__(self, key):
<span class="w"> </span>        return self._atlas[key]

<span class="gi">+    def copy(self):</span>
<span class="gi">+        return {n: self[n].copy() for n in self._atlas}</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="gd">-        return str(self._atlas)</span>
<span class="gi">+        return str(self._atlas)  # {nbr: self[nbr] for nbr in self})</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;{self.__class__.__name__}({self._atlas!r})&#39;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self._atlas!r})&quot;</span>


<span class="w"> </span>class AdjacencyView(AtlasView):
<span class="gu">@@ -60,11 +74,15 @@ class AdjacencyView(AtlasView):</span>
<span class="w"> </span>    AtlasView: View into dict-of-dict
<span class="w"> </span>    MultiAdjacencyView: View into dict-of-dict-of-dict-of-dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = ()</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = ()  # Still uses AtlasView slots names _atlas</span>

<span class="w"> </span>    def __getitem__(self, name):
<span class="w"> </span>        return AtlasView(self._atlas[name])

<span class="gi">+    def copy(self):</span>
<span class="gi">+        return {n: self[n].copy() for n in self._atlas}</span>
<span class="gi">+</span>

<span class="w"> </span>class MultiAdjacencyView(AdjacencyView):
<span class="w"> </span>    &quot;&quot;&quot;An MultiAdjacencyView is a Read-only Map of Maps of Maps of Maps.
<span class="gu">@@ -78,11 +96,15 @@ class MultiAdjacencyView(AdjacencyView):</span>
<span class="w"> </span>    AtlasView: View into dict-of-dict
<span class="w"> </span>    AdjacencyView: View into dict-of-dict-of-dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = ()</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = ()  # Still uses AtlasView slots names _atlas</span>

<span class="w"> </span>    def __getitem__(self, name):
<span class="w"> </span>        return AdjacencyView(self._atlas[name])

<span class="gi">+    def copy(self):</span>
<span class="gi">+        return {n: self[n].copy() for n in self._atlas}</span>
<span class="gi">+</span>

<span class="w"> </span>class UnionAtlas(Mapping):
<span class="w"> </span>    &quot;&quot;&quot;A read-only union of two atlases (dict-of-dict).
<span class="gu">@@ -97,14 +119,15 @@ class UnionAtlas(Mapping):</span>
<span class="w"> </span>    UnionAdjacency: View into dict-of-dict-of-dict
<span class="w"> </span>    UnionMultiAdjacency: View into dict-of-dict-of-dict-of-dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_succ&#39;, &#39;_pred&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;_succ&quot;, &quot;_pred&quot;)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="gd">-        return {&#39;_succ&#39;: self._succ, &#39;_pred&#39;: self._pred}</span>
<span class="gi">+        return {&quot;_succ&quot;: self._succ, &quot;_pred&quot;: self._pred}</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="gd">-        self._succ = state[&#39;_succ&#39;]</span>
<span class="gd">-        self._pred = state[&#39;_pred&#39;]</span>
<span class="gi">+        self._succ = state[&quot;_succ&quot;]</span>
<span class="gi">+        self._pred = state[&quot;_pred&quot;]</span>

<span class="w"> </span>    def __init__(self, succ, pred):
<span class="w"> </span>        self._succ = succ
<span class="gu">@@ -122,11 +145,20 @@ class UnionAtlas(Mapping):</span>
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            return self._pred[key]

<span class="gi">+    def copy(self):</span>
<span class="gi">+        result = {nbr: dd.copy() for nbr, dd in self._succ.items()}</span>
<span class="gi">+        for nbr, dd in self._pred.items():</span>
<span class="gi">+            if nbr in result:</span>
<span class="gi">+                result[nbr].update(dd)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result[nbr] = dd.copy()</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return str({nbr: self[nbr] for nbr in self})

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;{self.__class__.__name__}({self._succ!r}, {self._pred!r})&#39;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self._succ!r}, {self._pred!r})&quot;</span>


<span class="w"> </span>class UnionAdjacency(Mapping):
<span class="gu">@@ -146,22 +178,24 @@ class UnionAdjacency(Mapping):</span>
<span class="w"> </span>    UnionAtlas: View into dict-of-dict
<span class="w"> </span>    UnionMultiAdjacency: View into dict-of-dict-of-dict-of-dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_succ&#39;, &#39;_pred&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;_succ&quot;, &quot;_pred&quot;)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="gd">-        return {&#39;_succ&#39;: self._succ, &#39;_pred&#39;: self._pred}</span>
<span class="gi">+        return {&quot;_succ&quot;: self._succ, &quot;_pred&quot;: self._pred}</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="gd">-        self._succ = state[&#39;_succ&#39;]</span>
<span class="gd">-        self._pred = state[&#39;_pred&#39;]</span>
<span class="gi">+        self._succ = state[&quot;_succ&quot;]</span>
<span class="gi">+        self._pred = state[&quot;_pred&quot;]</span>

<span class="w"> </span>    def __init__(self, succ, pred):
<span class="gi">+        # keys must be the same for two input dicts</span>
<span class="w"> </span>        assert len(set(succ.keys()) ^ set(pred.keys())) == 0
<span class="w"> </span>        self._succ = succ
<span class="w"> </span>        self._pred = pred

<span class="w"> </span>    def __len__(self):
<span class="gd">-        return len(self._succ)</span>
<span class="gi">+        return len(self._succ)  # length of each dict should be the same</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        return iter(self._succ)
<span class="gu">@@ -169,11 +203,14 @@ class UnionAdjacency(Mapping):</span>
<span class="w"> </span>    def __getitem__(self, nbr):
<span class="w"> </span>        return UnionAtlas(self._succ[nbr], self._pred[nbr])

<span class="gi">+    def copy(self):</span>
<span class="gi">+        return {n: self[n].copy() for n in self._succ}</span>
<span class="gi">+</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return str({nbr: self[nbr] for nbr in self})

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;{self.__class__.__name__}({self._succ!r}, {self._pred!r})&#39;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self._succ!r}, {self._pred!r})&quot;</span>


<span class="w"> </span>class UnionMultiInner(UnionAtlas):
<span class="gu">@@ -190,7 +227,8 @@ class UnionMultiInner(UnionAtlas):</span>
<span class="w"> </span>    UnionAdjacency:  View into dict-of-dict-of-dict
<span class="w"> </span>    UnionMultiAdjacency:  View into dict-of-dict-of-dict-of-dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = ()</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = ()  # Still uses UnionAtlas slots names _succ, _pred</span>

<span class="w"> </span>    def __getitem__(self, node):
<span class="w"> </span>        in_succ = node in self._succ
<span class="gu">@@ -201,6 +239,10 @@ class UnionMultiInner(UnionAtlas):</span>
<span class="w"> </span>            return UnionAtlas(self._succ[node], {})
<span class="w"> </span>        return UnionAtlas({}, self._pred[node])

<span class="gi">+    def copy(self):</span>
<span class="gi">+        nodes = set(self._succ.keys()) | set(self._pred.keys())</span>
<span class="gi">+        return {n: self[n].copy() for n in nodes}</span>
<span class="gi">+</span>

<span class="w"> </span>class UnionMultiAdjacency(UnionAdjacency):
<span class="w"> </span>    &quot;&quot;&quot;A read-only union of two dict MultiAdjacencies.
<span class="gu">@@ -214,13 +256,14 @@ class UnionMultiAdjacency(UnionAdjacency):</span>
<span class="w"> </span>    UnionAtlas:  View into dict-of-dict
<span class="w"> </span>    UnionMultiInner:  View into dict-of-dict-of-dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = ()</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = ()  # Still uses UnionAdjacency slots names _succ, _pred</span>

<span class="w"> </span>    def __getitem__(self, node):
<span class="w"> </span>        return UnionMultiInner(self._succ[node], self._pred[node])


<span class="gd">-class FilterAtlas(Mapping):</span>
<span class="gi">+class FilterAtlas(Mapping):  # nodedict, nbrdict, keydict</span>
<span class="w"> </span>    &quot;&quot;&quot;A read-only Mapping of Mappings with filtering criteria for nodes.

<span class="w"> </span>    It is a view into a dict-of-dict data structure, and it selects only
<span class="gu">@@ -241,7 +284,7 @@ class FilterAtlas(Mapping):</span>
<span class="w"> </span>        return sum(1 for n in self)

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        try:</span>
<span class="gi">+        try:  # check that NODE_OK has attr &#39;nodes&#39;</span>
<span class="w"> </span>            node_ok_shorter = 2 * len(self.NODE_OK.nodes) &lt; len(self._atlas)
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            node_ok_shorter = False
<span class="gu">@@ -252,16 +295,16 @@ class FilterAtlas(Mapping):</span>
<span class="w"> </span>    def __getitem__(self, key):
<span class="w"> </span>        if key in self._atlas and self.NODE_OK(key):
<span class="w"> </span>            return self._atlas[key]
<span class="gd">-        raise KeyError(f&#39;Key {key} not found&#39;)</span>
<span class="gi">+        raise KeyError(f&quot;Key {key} not found&quot;)</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return str({nbr: self[nbr] for nbr in self})

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;{self.__class__.__name__}({self._atlas!r}, {self.NODE_OK!r})&#39;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({self._atlas!r}, {self.NODE_OK!r})&quot;</span>


<span class="gd">-class FilterAdjacency(Mapping):</span>
<span class="gi">+class FilterAdjacency(Mapping):  # edgedict</span>
<span class="w"> </span>    &quot;&quot;&quot;A read-only Mapping of Mappings with filtering criteria for nodes and edges.

<span class="w"> </span>    It is a view into a dict-of-dict-of-dict data structure, and it selects nodes
<span class="gu">@@ -284,7 +327,7 @@ class FilterAdjacency(Mapping):</span>
<span class="w"> </span>        return sum(1 for n in self)

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        try:</span>
<span class="gi">+        try:  # check that NODE_OK has attr &#39;nodes&#39;</span>
<span class="w"> </span>            node_ok_shorter = 2 * len(self.NODE_OK.nodes) &lt; len(self._atlas)
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            node_ok_shorter = False
<span class="gu">@@ -297,18 +340,19 @@ class FilterAdjacency(Mapping):</span>

<span class="w"> </span>            def new_node_ok(nbr):
<span class="w"> </span>                return self.NODE_OK(nbr) and self.EDGE_OK(node, nbr)
<span class="gi">+</span>
<span class="w"> </span>            return FilterAtlas(self._atlas[node], new_node_ok)
<span class="gd">-        raise KeyError(f&#39;Key {node} not found&#39;)</span>
<span class="gi">+        raise KeyError(f&quot;Key {node} not found&quot;)</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return str({nbr: self[nbr] for nbr in self})

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        name = self.__class__.__name__
<span class="gd">-        return f&#39;{name}({self._atlas!r}, {self.NODE_OK!r}, {self.EDGE_OK!r})&#39;</span>
<span class="gi">+        return f&quot;{name}({self._atlas!r}, {self.NODE_OK!r}, {self.EDGE_OK!r})&quot;</span>


<span class="gd">-class FilterMultiInner(FilterAdjacency):</span>
<span class="gi">+class FilterMultiInner(FilterAdjacency):  # muliedge_seconddict</span>
<span class="w"> </span>    &quot;&quot;&quot;A read-only Mapping of Mappings with filtering criteria for nodes and edges.

<span class="w"> </span>    It is a view into a dict-of-dict-of-dict-of-dict data structure, and it selects nodes
<span class="gu">@@ -322,7 +366,7 @@ class FilterMultiInner(FilterAdjacency):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        try:</span>
<span class="gi">+        try:  # check that NODE_OK has attr &#39;nodes&#39;</span>
<span class="w"> </span>            node_ok_shorter = 2 * len(self.NODE_OK.nodes) &lt; len(self._atlas)
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            node_ok_shorter = False
<span class="gu">@@ -344,11 +388,12 @@ class FilterMultiInner(FilterAdjacency):</span>

<span class="w"> </span>            def new_node_ok(key):
<span class="w"> </span>                return self.EDGE_OK(nbr, key)
<span class="gi">+</span>
<span class="w"> </span>            return FilterAtlas(self._atlas[nbr], new_node_ok)
<span class="gd">-        raise KeyError(f&#39;Key {nbr} not found&#39;)</span>
<span class="gi">+        raise KeyError(f&quot;Key {nbr} not found&quot;)</span>


<span class="gd">-class FilterMultiAdjacency(FilterAdjacency):</span>
<span class="gi">+class FilterMultiAdjacency(FilterAdjacency):  # multiedgedict</span>
<span class="w"> </span>    &quot;&quot;&quot;A read-only Mapping of Mappings with filtering criteria
<span class="w"> </span>    for nodes and edges.

<span class="gu">@@ -368,5 +413,6 @@ class FilterMultiAdjacency(FilterAdjacency):</span>

<span class="w"> </span>            def edge_ok(nbr, key):
<span class="w"> </span>                return self.NODE_OK(nbr) and self.EDGE_OK(node, nbr, key)
<span class="gi">+</span>
<span class="w"> </span>            return FilterMultiInner(self._atlas[node], self.NODE_OK, edge_ok)
<span class="gd">-        raise KeyError(f&#39;Key {node} not found&#39;)</span>
<span class="gi">+        raise KeyError(f&quot;Key {node} not found&quot;)</span>
<span class="gh">diff --git a/networkx/classes/digraph.py b/networkx/classes/digraph.py</span>
<span class="gh">index 923dbb853..fc2374a2b 100644</span>
<span class="gd">--- a/networkx/classes/digraph.py</span>
<span class="gi">+++ b/networkx/classes/digraph.py</span>
<span class="gu">@@ -1,13 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Base class for directed graphs.&quot;&quot;&quot;
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from functools import cached_property
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx import convert
<span class="w"> </span>from networkx.classes.coreviews import AdjacencyView
<span class="w"> </span>from networkx.classes.graph import Graph
<span class="gd">-from networkx.classes.reportviews import DiDegreeView, InDegreeView, InEdgeView, OutDegreeView, OutEdgeView</span>
<span class="gi">+from networkx.classes.reportviews import (</span>
<span class="gi">+    DiDegreeView,</span>
<span class="gi">+    InDegreeView,</span>
<span class="gi">+    InEdgeView,</span>
<span class="gi">+    OutDegreeView,</span>
<span class="gi">+    OutEdgeView,</span>
<span class="gi">+)</span>
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="gd">-__all__ = [&#39;DiGraph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;DiGraph&quot;]</span>


<span class="w"> </span>class _CachedPropertyResetterAdjAndSucc:
<span class="gu">@@ -28,12 +36,13 @@ class _CachedPropertyResetterAdjAndSucc:</span>

<span class="w"> </span>    def __set__(self, obj, value):
<span class="w"> </span>        od = obj.__dict__
<span class="gd">-        od[&#39;_adj&#39;] = value</span>
<span class="gd">-        od[&#39;_succ&#39;] = value</span>
<span class="gd">-        if &#39;adj&#39; in od:</span>
<span class="gd">-            del od[&#39;adj&#39;]</span>
<span class="gd">-        if &#39;succ&#39; in od:</span>
<span class="gd">-            del od[&#39;succ&#39;]</span>
<span class="gi">+        od[&quot;_adj&quot;] = value</span>
<span class="gi">+        od[&quot;_succ&quot;] = value</span>
<span class="gi">+        # reset cached properties</span>
<span class="gi">+        if &quot;adj&quot; in od:</span>
<span class="gi">+            del od[&quot;adj&quot;]</span>
<span class="gi">+        if &quot;succ&quot; in od:</span>
<span class="gi">+            del od[&quot;succ&quot;]</span>


<span class="w"> </span>class _CachedPropertyResetterPred:
<span class="gu">@@ -53,9 +62,9 @@ class _CachedPropertyResetterPred:</span>

<span class="w"> </span>    def __set__(self, obj, value):
<span class="w"> </span>        od = obj.__dict__
<span class="gd">-        od[&#39;_pred&#39;] = value</span>
<span class="gd">-        if &#39;pred&#39; in od:</span>
<span class="gd">-            del od[&#39;pred&#39;]</span>
<span class="gi">+        od[&quot;_pred&quot;] = value</span>
<span class="gi">+        if &quot;pred&quot; in od:</span>
<span class="gi">+            del od[&quot;pred&quot;]</span>


<span class="w"> </span>class DiGraph(Graph):
<span class="gu">@@ -299,8 +308,9 @@ class DiGraph(Graph):</span>
<span class="w"> </span>    &gt;&gt;&gt; G[2][1] is G[2][2]
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _adj = _CachedPropertyResetterAdjAndSucc()</span>
<span class="gd">-    _succ = _adj</span>
<span class="gi">+</span>
<span class="gi">+    _adj = _CachedPropertyResetterAdjAndSucc()  # type: ignore[assignment]</span>
<span class="gi">+    _succ = _adj  # type: ignore[has-type]</span>
<span class="w"> </span>    _pred = _CachedPropertyResetterPred()

<span class="w"> </span>    def __init__(self, incoming_graph_data=None, **attr):
<span class="gu">@@ -336,13 +346,20 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        {&#39;day&#39;: &#39;Friday&#39;}

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self.graph = self.graph_attr_dict_factory()</span>
<span class="gd">-        self._node = self.node_dict_factory()</span>
<span class="gd">-        self._adj = self.adjlist_outer_dict_factory()</span>
<span class="gd">-        self._pred = self.adjlist_outer_dict_factory()</span>
<span class="gi">+        self.graph = self.graph_attr_dict_factory()  # dictionary for graph attributes</span>
<span class="gi">+        self._node = self.node_dict_factory()  # dictionary for node attr</span>
<span class="gi">+        # We store two adjacency lists:</span>
<span class="gi">+        # the predecessors of node n are stored in the dict self._pred</span>
<span class="gi">+        # the successors of node n are stored in the dict self._succ=self._adj</span>
<span class="gi">+        self._adj = self.adjlist_outer_dict_factory()  # empty adjacency dict successor</span>
<span class="gi">+        self._pred = self.adjlist_outer_dict_factory()  # predecessor</span>
<span class="gi">+        # Note: self._succ = self._adj  # successor</span>
<span class="gi">+</span>
<span class="w"> </span>        self.__networkx_cache__ = {}
<span class="gi">+        # attempt to load graph with data</span>
<span class="w"> </span>        if incoming_graph_data is not None:
<span class="w"> </span>            convert.to_networkx_graph(incoming_graph_data, create_using=self)
<span class="gi">+        # load graph attributes (must be after convert)</span>
<span class="w"> </span>        self.graph.update(attr)

<span class="w"> </span>    @cached_property
<span class="gu">@@ -362,7 +379,7 @@ class DiGraph(Graph):</span>

<span class="w"> </span>        For directed graphs, `G.adj` holds outgoing (successor) info.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AdjacencyView(self._succ)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def succ(self):
<span class="gu">@@ -383,7 +400,7 @@ class DiGraph(Graph):</span>

<span class="w"> </span>        For directed graphs, `G.adj` is identical to `G.succ`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AdjacencyView(self._succ)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def pred(self):
<span class="gu">@@ -399,7 +416,7 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        by dicts also exists: `for nbr, foovalue in G.pred[node].data(&#39;foo&#39;):`
<span class="w"> </span>        A default can be set via a `default` argument to the `data` method.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AdjacencyView(self._pred)</span>

<span class="w"> </span>    def add_node(self, node_for_adding, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add a single node `node_for_adding` and update node attributes.
<span class="gu">@@ -440,7 +457,16 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        NetworkX Graphs, though one should be careful that the hash
<span class="w"> </span>        doesn&#39;t change on mutables.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node_for_adding not in self._succ:</span>
<span class="gi">+            if node_for_adding is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._succ[node_for_adding] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._pred[node_for_adding] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            attr_dict = self._node[node_for_adding] = self.node_attr_dict_factory()</span>
<span class="gi">+            attr_dict.update(attr)</span>
<span class="gi">+        else:  # update attr even if node already exists</span>
<span class="gi">+            self._node[node_for_adding].update(attr)</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def add_nodes_from(self, nodes_for_adding, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add multiple nodes.
<span class="gu">@@ -503,7 +529,23 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; # correct way
<span class="w"> </span>        &gt;&gt;&gt; G.add_nodes_from(list(n + 1 for n in G.nodes))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for n in nodes_for_adding:</span>
<span class="gi">+            try:</span>
<span class="gi">+                newnode = n not in self._node</span>
<span class="gi">+                newdict = attr</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                n, ndict = n</span>
<span class="gi">+                newnode = n not in self._node</span>
<span class="gi">+                newdict = attr.copy()</span>
<span class="gi">+                newdict.update(ndict)</span>
<span class="gi">+            if newnode:</span>
<span class="gi">+                if n is None:</span>
<span class="gi">+                    raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+                self._succ[n] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+                self._pred[n] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+                self._node[n] = self.node_attr_dict_factory()</span>
<span class="gi">+            self._node[n].update(newdict)</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_node(self, n):
<span class="w"> </span>        &quot;&quot;&quot;Remove node n.
<span class="gu">@@ -535,7 +577,18 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        []

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            nbrs = self._succ[n]</span>
<span class="gi">+            del self._node[n]</span>
<span class="gi">+        except KeyError as err:  # NetworkXError if n not in self</span>
<span class="gi">+            raise NetworkXError(f&quot;The node {n} is not in the digraph.&quot;) from err</span>
<span class="gi">+        for u in nbrs:</span>
<span class="gi">+            del self._pred[u][n]  # remove all edges n-u in digraph</span>
<span class="gi">+        del self._succ[n]  # remove node from succ</span>
<span class="gi">+        for u in self._pred[n]:</span>
<span class="gi">+            del self._succ[u][n]  # remove all edges n-u in digraph</span>
<span class="gi">+        del self._pred[n]  # remove node from pred</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_nodes_from(self, nodes):
<span class="w"> </span>        &quot;&quot;&quot;Remove multiple nodes.
<span class="gu">@@ -578,7 +631,19 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; # this command will work, since the dictionary underlying graph is not modified
<span class="w"> </span>        &gt;&gt;&gt; G.remove_nodes_from(list(n for n in G.nodes if n &lt; 2))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for n in nodes:</span>
<span class="gi">+            try:</span>
<span class="gi">+                succs = self._succ[n]</span>
<span class="gi">+                del self._node[n]</span>
<span class="gi">+                for u in succs:</span>
<span class="gi">+                    del self._pred[u][n]  # remove all edges n-u in digraph</span>
<span class="gi">+                del self._succ[n]  # now remove node</span>
<span class="gi">+                for u in self._pred[n]:</span>
<span class="gi">+                    del self._succ[u][n]  # remove all edges n-u in digraph</span>
<span class="gi">+                del self._pred[n]  # now remove node</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass  # silent failure on remove</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def add_edge(self, u_of_edge, v_of_edge, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add an edge between u and v.
<span class="gu">@@ -630,7 +695,26 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; G[1][2].update({0: 5})
<span class="w"> </span>        &gt;&gt;&gt; G.edges[1, 2].update({0: 5})
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        u, v = u_of_edge, v_of_edge</span>
<span class="gi">+        # add nodes</span>
<span class="gi">+        if u not in self._succ:</span>
<span class="gi">+            if u is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._succ[u] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._pred[u] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._node[u] = self.node_attr_dict_factory()</span>
<span class="gi">+        if v not in self._succ:</span>
<span class="gi">+            if v is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._succ[v] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._pred[v] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._node[v] = self.node_attr_dict_factory()</span>
<span class="gi">+        # add the edge</span>
<span class="gi">+        datadict = self._adj[u].get(v, self.edge_attr_dict_factory())</span>
<span class="gi">+        datadict.update(attr)</span>
<span class="gi">+        self._succ[u][v] = datadict</span>
<span class="gi">+        self._pred[v][u] = datadict</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def add_edges_from(self, ebunch_to_add, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add all the edges in ebunch_to_add.
<span class="gu">@@ -687,7 +771,33 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; # right way - note that there will be no self-edge for node 5
<span class="w"> </span>        &gt;&gt;&gt; G.add_edges_from(list((5, n) for n in G.nodes))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for e in ebunch_to_add:</span>
<span class="gi">+            ne = len(e)</span>
<span class="gi">+            if ne == 3:</span>
<span class="gi">+                u, v, dd = e</span>
<span class="gi">+            elif ne == 2:</span>
<span class="gi">+                u, v = e</span>
<span class="gi">+                dd = {}</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise NetworkXError(f&quot;Edge tuple {e} must be a 2-tuple or 3-tuple.&quot;)</span>
<span class="gi">+            if u not in self._succ:</span>
<span class="gi">+                if u is None:</span>
<span class="gi">+                    raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+                self._succ[u] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+                self._pred[u] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+                self._node[u] = self.node_attr_dict_factory()</span>
<span class="gi">+            if v not in self._succ:</span>
<span class="gi">+                if v is None:</span>
<span class="gi">+                    raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+                self._succ[v] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+                self._pred[v] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+                self._node[v] = self.node_attr_dict_factory()</span>
<span class="gi">+            datadict = self._adj[u].get(v, self.edge_attr_dict_factory())</span>
<span class="gi">+            datadict.update(attr)</span>
<span class="gi">+            datadict.update(dd)</span>
<span class="gi">+            self._succ[u][v] = datadict</span>
<span class="gi">+            self._pred[v][u] = datadict</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_edge(self, u, v):
<span class="w"> </span>        &quot;&quot;&quot;Remove the edge between u and v.
<span class="gu">@@ -716,7 +826,12 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; e = (2, 3, {&quot;weight&quot;: 7})  # an edge with attribute data
<span class="w"> </span>        &gt;&gt;&gt; G.remove_edge(*e[:2])  # select first part of edge tuple
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            del self._succ[u][v]</span>
<span class="gi">+            del self._pred[v][u]</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;The edge {u}-{v} not in graph.&quot;) from err</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_edges_from(self, ebunch):
<span class="w"> </span>        &quot;&quot;&quot;Remove all edges specified in ebunch.
<span class="gu">@@ -744,21 +859,26 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; ebunch = [(1, 2), (2, 3)]
<span class="w"> </span>        &gt;&gt;&gt; G.remove_edges_from(ebunch)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for e in ebunch:</span>
<span class="gi">+            u, v = e[:2]  # ignore edge data</span>
<span class="gi">+            if u in self._succ and v in self._succ[u]:</span>
<span class="gi">+                del self._succ[u][v]</span>
<span class="gi">+                del self._pred[v][u]</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def has_successor(self, u, v):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if node u has successor v.

<span class="w"> </span>        This is true if graph has the edge u-&gt;v.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return u in self._succ and v in self._succ[u]</span>

<span class="w"> </span>    def has_predecessor(self, u, v):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if node u has predecessor v.

<span class="w"> </span>        This is true if graph has the edge u&lt;-v.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return u in self._pred and v in self._pred[u]</span>

<span class="w"> </span>    def successors(self, n):
<span class="w"> </span>        &quot;&quot;&quot;Returns an iterator over successor nodes of n.
<span class="gu">@@ -784,7 +904,12 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        -----
<span class="w"> </span>        neighbors() and successors() are the same.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return iter(self._succ[n])</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;The node {n} is not in the digraph.&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    # digraph definitions</span>
<span class="w"> </span>    neighbors = successors

<span class="w"> </span>    def predecessors(self, n):
<span class="gu">@@ -807,7 +932,10 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        --------
<span class="w"> </span>        successors
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return iter(self._pred[n])</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;The node {n} is not in the digraph.&quot;) from err</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def edges(self):
<span class="gu">@@ -870,7 +998,13 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        OutEdgeDataView([(0, 1)])

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return OutEdgeView(self)</span>
<span class="gi">+</span>
<span class="gi">+    # alias out_edges to edges</span>
<span class="gi">+    @cached_property</span>
<span class="gi">+    def out_edges(self):</span>
<span class="gi">+        return OutEdgeView(self)</span>
<span class="gi">+</span>
<span class="w"> </span>    out_edges.__doc__ = edges.__doc__

<span class="w"> </span>    @cached_property
<span class="gu">@@ -911,7 +1045,7 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        --------
<span class="w"> </span>        edges
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return InEdgeView(self)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def degree(self):
<span class="gu">@@ -955,7 +1089,7 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        [(0, 1), (1, 2), (2, 2)]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return DiDegreeView(self)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def in_degree(self):
<span class="gu">@@ -1002,7 +1136,7 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        [(0, 0), (1, 1), (2, 1)]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return InDegreeView(self)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def out_degree(self):
<span class="gu">@@ -1049,7 +1183,7 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        [(0, 1), (1, 1), (2, 1)]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return OutDegreeView(self)</span>

<span class="w"> </span>    def clear(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove all nodes and edges from the graph.
<span class="gu">@@ -1066,7 +1200,11 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        []

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._succ.clear()</span>
<span class="gi">+        self._pred.clear()</span>
<span class="gi">+        self._node.clear()</span>
<span class="gi">+        self.graph.clear()</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def clear_edges(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove all edges from the graph without altering nodes.
<span class="gu">@@ -1081,15 +1219,19 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        []

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for predecessor_dict in self._pred.values():</span>
<span class="gi">+            predecessor_dict.clear()</span>
<span class="gi">+        for successor_dict in self._succ.values():</span>
<span class="gi">+            successor_dict.clear()</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def is_multigraph(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if graph is a multigraph, False otherwise.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def is_directed(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if graph is directed, False otherwise.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def to_undirected(self, reciprocal=False, as_view=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns an undirected representation of the digraph.
<span class="gu">@@ -1148,7 +1290,27 @@ class DiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; list(G2.edges)
<span class="w"> </span>        [(0, 1)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        graph_class = self.to_undirected_class()</span>
<span class="gi">+        if as_view is True:</span>
<span class="gi">+            return nx.graphviews.generic_graph_view(self, graph_class)</span>
<span class="gi">+        # deepcopy when not a view</span>
<span class="gi">+        G = graph_class()</span>
<span class="gi">+        G.graph.update(deepcopy(self.graph))</span>
<span class="gi">+        G.add_nodes_from((n, deepcopy(d)) for n, d in self._node.items())</span>
<span class="gi">+        if reciprocal is True:</span>
<span class="gi">+            G.add_edges_from(</span>
<span class="gi">+                (u, v, deepcopy(d))</span>
<span class="gi">+                for u, nbrs in self._adj.items()</span>
<span class="gi">+                for v, d in nbrs.items()</span>
<span class="gi">+                if v in self._pred[u]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            G.add_edges_from(</span>
<span class="gi">+                (u, v, deepcopy(d))</span>
<span class="gi">+                for u, nbrs in self._adj.items()</span>
<span class="gi">+                for v, d in nbrs.items()</span>
<span class="gi">+            )</span>
<span class="gi">+        return G</span>

<span class="w"> </span>    def reverse(self, copy=True):
<span class="w"> </span>        &quot;&quot;&quot;Returns the reverse of the graph.
<span class="gu">@@ -1163,4 +1325,10 @@ class DiGraph(Graph):</span>
<span class="w"> </span>            If False, the reverse graph is created using a view of
<span class="w"> </span>            the original graph.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if copy:</span>
<span class="gi">+            H = self.__class__()</span>
<span class="gi">+            H.graph.update(deepcopy(self.graph))</span>
<span class="gi">+            H.add_nodes_from((n, deepcopy(d)) for n, d in self.nodes.items())</span>
<span class="gi">+            H.add_edges_from((v, u, deepcopy(d)) for u, v, d in self.edges(data=True))</span>
<span class="gi">+            return H</span>
<span class="gi">+        return nx.reverse_view(self)</span>
<span class="gh">diff --git a/networkx/classes/filters.py b/networkx/classes/filters.py</span>
<span class="gh">index c012402dc..215aa375d 100644</span>
<span class="gd">--- a/networkx/classes/filters.py</span>
<span class="gi">+++ b/networkx/classes/filters.py</span>
<span class="gu">@@ -2,41 +2,57 @@</span>

<span class="w"> </span>These filters return the function used when creating `SubGraph`.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;no_filter&#39;, &#39;hide_nodes&#39;, &#39;hide_edges&#39;, &#39;hide_multiedges&#39;,</span>
<span class="gd">-    &#39;hide_diedges&#39;, &#39;hide_multidiedges&#39;, &#39;show_nodes&#39;, &#39;show_edges&#39;,</span>
<span class="gd">-    &#39;show_multiedges&#39;, &#39;show_diedges&#39;, &#39;show_multidiedges&#39;]</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;no_filter&quot;,</span>
<span class="gi">+    &quot;hide_nodes&quot;,</span>
<span class="gi">+    &quot;hide_edges&quot;,</span>
<span class="gi">+    &quot;hide_multiedges&quot;,</span>
<span class="gi">+    &quot;hide_diedges&quot;,</span>
<span class="gi">+    &quot;hide_multidiedges&quot;,</span>
<span class="gi">+    &quot;show_nodes&quot;,</span>
<span class="gi">+    &quot;show_edges&quot;,</span>
<span class="gi">+    &quot;show_multiedges&quot;,</span>
<span class="gi">+    &quot;show_diedges&quot;,</span>
<span class="gi">+    &quot;show_multidiedges&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def no_filter(*items):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that always evaluates to True.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def hide_nodes(nodes):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that hides specific nodes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodes = set(nodes)</span>
<span class="gi">+    return lambda node: node not in nodes</span>


<span class="w"> </span>def hide_diedges(edges):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that hides specific directed edges.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = {(u, v) for u, v in edges}</span>
<span class="gi">+    return lambda u, v: (u, v) not in edges</span>


<span class="w"> </span>def hide_edges(edges):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that hides specific undirected edges.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    alledges = set(edges) | {(v, u) for (u, v) in edges}</span>
<span class="gi">+    return lambda u, v: (u, v) not in alledges</span>


<span class="w"> </span>def hide_multidiedges(edges):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that hides specific multi-directed edges.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = {(u, v, k) for u, v, k in edges}</span>
<span class="gi">+    return lambda u, v, k: (u, v, k) not in edges</span>


<span class="w"> </span>def hide_multiedges(edges):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that hides specific multi-undirected edges.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    alledges = set(edges) | {(v, u, k) for (u, v, k) in edges}</span>
<span class="gi">+    return lambda u, v, k: (u, v, k) not in alledges</span>


<span class="gi">+# write show_nodes as a class to make SubGraph pickleable</span>
<span class="w"> </span>class show_nodes:
<span class="w"> </span>    &quot;&quot;&quot;Filter class to show specific nodes.&quot;&quot;&quot;

<span class="gu">@@ -49,19 +65,23 @@ class show_nodes:</span>

<span class="w"> </span>def show_diedges(edges):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that shows specific directed edges.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = {(u, v) for u, v in edges}</span>
<span class="gi">+    return lambda u, v: (u, v) in edges</span>


<span class="w"> </span>def show_edges(edges):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that shows specific undirected edges.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    alledges = set(edges) | {(v, u) for (u, v) in edges}</span>
<span class="gi">+    return lambda u, v: (u, v) in alledges</span>


<span class="w"> </span>def show_multidiedges(edges):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that shows specific multi-directed edges.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    edges = {(u, v, k) for u, v, k in edges}</span>
<span class="gi">+    return lambda u, v, k: (u, v, k) in edges</span>


<span class="w"> </span>def show_multiedges(edges):
<span class="w"> </span>    &quot;&quot;&quot;Returns a filter function that shows specific multi-undirected edges.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    alledges = set(edges) | {(v, u, k) for (u, v, k) in edges}</span>
<span class="gi">+    return lambda u, v, k: (u, v, k) in alledges</span>
<span class="gh">diff --git a/networkx/classes/function.py b/networkx/classes/function.py</span>
<span class="gh">index e7c4ca267..f87b7897f 100644</span>
<span class="gd">--- a/networkx/classes/function.py</span>
<span class="gi">+++ b/networkx/classes/function.py</span>
<span class="gu">@@ -1,18 +1,51 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Functional interface to graph methods and assorted utilities.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import Counter
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for, pairwise
<span class="gd">-__all__ = [&#39;nodes&#39;, &#39;edges&#39;, &#39;degree&#39;, &#39;degree_histogram&#39;, &#39;neighbors&#39;,</span>
<span class="gd">-    &#39;number_of_nodes&#39;, &#39;number_of_edges&#39;, &#39;density&#39;, &#39;is_directed&#39;,</span>
<span class="gd">-    &#39;freeze&#39;, &#39;is_frozen&#39;, &#39;subgraph&#39;, &#39;induced_subgraph&#39;, &#39;edge_subgraph&#39;,</span>
<span class="gd">-    &#39;restricted_view&#39;, &#39;to_directed&#39;, &#39;to_undirected&#39;, &#39;add_star&#39;,</span>
<span class="gd">-    &#39;add_path&#39;, &#39;add_cycle&#39;, &#39;create_empty_copy&#39;, &#39;set_node_attributes&#39;,</span>
<span class="gd">-    &#39;get_node_attributes&#39;, &#39;set_edge_attributes&#39;, &#39;get_edge_attributes&#39;,</span>
<span class="gd">-    &#39;all_neighbors&#39;, &#39;non_neighbors&#39;, &#39;non_edges&#39;, &#39;common_neighbors&#39;,</span>
<span class="gd">-    &#39;is_weighted&#39;, &#39;is_negatively_weighted&#39;, &#39;is_empty&#39;, &#39;selfloop_edges&#39;,</span>
<span class="gd">-    &#39;nodes_with_selfloops&#39;, &#39;number_of_selfloops&#39;, &#39;path_weight&#39;, &#39;is_path&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;nodes&quot;,</span>
<span class="gi">+    &quot;edges&quot;,</span>
<span class="gi">+    &quot;degree&quot;,</span>
<span class="gi">+    &quot;degree_histogram&quot;,</span>
<span class="gi">+    &quot;neighbors&quot;,</span>
<span class="gi">+    &quot;number_of_nodes&quot;,</span>
<span class="gi">+    &quot;number_of_edges&quot;,</span>
<span class="gi">+    &quot;density&quot;,</span>
<span class="gi">+    &quot;is_directed&quot;,</span>
<span class="gi">+    &quot;freeze&quot;,</span>
<span class="gi">+    &quot;is_frozen&quot;,</span>
<span class="gi">+    &quot;subgraph&quot;,</span>
<span class="gi">+    &quot;induced_subgraph&quot;,</span>
<span class="gi">+    &quot;edge_subgraph&quot;,</span>
<span class="gi">+    &quot;restricted_view&quot;,</span>
<span class="gi">+    &quot;to_directed&quot;,</span>
<span class="gi">+    &quot;to_undirected&quot;,</span>
<span class="gi">+    &quot;add_star&quot;,</span>
<span class="gi">+    &quot;add_path&quot;,</span>
<span class="gi">+    &quot;add_cycle&quot;,</span>
<span class="gi">+    &quot;create_empty_copy&quot;,</span>
<span class="gi">+    &quot;set_node_attributes&quot;,</span>
<span class="gi">+    &quot;get_node_attributes&quot;,</span>
<span class="gi">+    &quot;set_edge_attributes&quot;,</span>
<span class="gi">+    &quot;get_edge_attributes&quot;,</span>
<span class="gi">+    &quot;all_neighbors&quot;,</span>
<span class="gi">+    &quot;non_neighbors&quot;,</span>
<span class="gi">+    &quot;non_edges&quot;,</span>
<span class="gi">+    &quot;common_neighbors&quot;,</span>
<span class="gi">+    &quot;is_weighted&quot;,</span>
<span class="gi">+    &quot;is_negatively_weighted&quot;,</span>
<span class="gi">+    &quot;is_empty&quot;,</span>
<span class="gi">+    &quot;selfloop_edges&quot;,</span>
<span class="gi">+    &quot;nodes_with_selfloops&quot;,</span>
<span class="gi">+    &quot;number_of_selfloops&quot;,</span>
<span class="gi">+    &quot;path_weight&quot;,</span>
<span class="gi">+    &quot;is_path&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def nodes(G):
<span class="gu">@@ -20,7 +53,7 @@ def nodes(G):</span>

<span class="w"> </span>    This function wraps the :func:`G.nodes &lt;networkx.Graph.nodes&gt;` property.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.nodes()</span>


<span class="w"> </span>def edges(G, nbunch=None):
<span class="gu">@@ -32,7 +65,7 @@ def edges(G, nbunch=None):</span>

<span class="w"> </span>    This function wraps the :func:`G.edges &lt;networkx.Graph.edges&gt;` property.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.edges(nbunch)</span>


<span class="w"> </span>def degree(G, nbunch=None, weight=None):
<span class="gu">@@ -41,7 +74,7 @@ def degree(G, nbunch=None, weight=None):</span>

<span class="w"> </span>    This function wraps the :func:`G.degree &lt;networkx.Graph.degree&gt;` property.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.degree(nbunch, weight)</span>


<span class="w"> </span>def neighbors(G, n):
<span class="gu">@@ -49,7 +82,7 @@ def neighbors(G, n):</span>

<span class="w"> </span>    This function wraps the :func:`G.neighbors &lt;networkx.Graph.neighbors&gt;` function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.neighbors(n)</span>


<span class="w"> </span>def number_of_nodes(G):
<span class="gu">@@ -57,7 +90,7 @@ def number_of_nodes(G):</span>

<span class="w"> </span>    This function wraps the :func:`G.number_of_nodes &lt;networkx.Graph.number_of_nodes&gt;` function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.number_of_nodes()</span>


<span class="w"> </span>def number_of_edges(G):
<span class="gu">@@ -65,23 +98,23 @@ def number_of_edges(G):</span>

<span class="w"> </span>    This function wraps the :func:`G.number_of_edges &lt;networkx.Graph.number_of_edges&gt;` function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.number_of_edges()</span>


<span class="w"> </span>def density(G):
<span class="gd">-    &quot;&quot;&quot;Returns the density of a graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the density of a graph.</span>

<span class="w"> </span>    The density for undirected graphs is

<span class="w"> </span>    .. math::

<span class="gd">-       d = \\frac{2m}{n(n-1)},</span>
<span class="gi">+       d = \frac{2m}{n(n-1)},</span>

<span class="w"> </span>    and for directed graphs is

<span class="w"> </span>    .. math::

<span class="gd">-       d = \\frac{m}{n(n-1)},</span>
<span class="gi">+       d = \frac{m}{n(n-1)},</span>

<span class="w"> </span>    where `n` is the number of nodes and `m`  is the number of edges in `G`.

<span class="gu">@@ -93,7 +126,14 @@ def density(G):</span>
<span class="w"> </span>    Self loops are counted in the total number of edges so graphs with self
<span class="w"> </span>    loops can have density higher than 1.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = number_of_nodes(G)</span>
<span class="gi">+    m = number_of_edges(G)</span>
<span class="gi">+    if m == 0 or n &lt;= 1:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    d = m / (n * (n - 1))</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        d *= 2</span>
<span class="gi">+    return d</span>


<span class="w"> </span>def degree_histogram(G):
<span class="gu">@@ -115,17 +155,18 @@ def degree_histogram(G):</span>
<span class="w"> </span>    Note: the bins are width one, hence len(list) can be large
<span class="w"> </span>    (Order(number_of_edges))
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    counts = Counter(d for n, d in G.degree())</span>
<span class="gi">+    return [counts.get(i, 0) for i in range(max(counts) + 1 if counts else 0)]</span>


<span class="w"> </span>def is_directed(G):
<span class="w"> </span>    &quot;&quot;&quot;Return True if graph is directed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.is_directed()</span>


<span class="w"> </span>def frozen(*args, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Dummy method for raising errors when trying to modify frozen graphs&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    raise nx.NetworkXError(&quot;Frozen graph can&#39;t be modified&quot;)</span>


<span class="w"> </span>def freeze(G):
<span class="gu">@@ -163,7 +204,19 @@ def freeze(G):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    is_frozen
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G.add_node = frozen</span>
<span class="gi">+    G.add_nodes_from = frozen</span>
<span class="gi">+    G.remove_node = frozen</span>
<span class="gi">+    G.remove_nodes_from = frozen</span>
<span class="gi">+    G.add_edge = frozen</span>
<span class="gi">+    G.add_edges_from = frozen</span>
<span class="gi">+    G.add_weighted_edges_from = frozen</span>
<span class="gi">+    G.remove_edge = frozen</span>
<span class="gi">+    G.remove_edges_from = frozen</span>
<span class="gi">+    G.clear = frozen</span>
<span class="gi">+    G.clear_edges = frozen</span>
<span class="gi">+    G.frozen = True</span>
<span class="gi">+    return G</span>


<span class="w"> </span>def is_frozen(G):
<span class="gu">@@ -178,7 +231,10 @@ def is_frozen(G):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    freeze
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return G.frozen</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def add_star(G_to_add_to, nodes_for_star, **attr):
<span class="gu">@@ -206,7 +262,14 @@ def add_star(G_to_add_to, nodes_for_star, **attr):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.add_star(G, [0, 1, 2, 3])
<span class="w"> </span>    &gt;&gt;&gt; nx.add_star(G, [10, 11, 12], weight=2)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nlist = iter(nodes_for_star)</span>
<span class="gi">+    try:</span>
<span class="gi">+        v = next(nlist)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return</span>
<span class="gi">+    G_to_add_to.add_node(v)</span>
<span class="gi">+    edges = ((v, n) for n in nlist)</span>
<span class="gi">+    G_to_add_to.add_edges_from(edges, **attr)</span>


<span class="w"> </span>def add_path(G_to_add_to, nodes_for_path, **attr):
<span class="gu">@@ -232,7 +295,13 @@ def add_path(G_to_add_to, nodes_for_path, **attr):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.add_path(G, [0, 1, 2, 3])
<span class="w"> </span>    &gt;&gt;&gt; nx.add_path(G, [10, 11, 12], weight=7)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nlist = iter(nodes_for_path)</span>
<span class="gi">+    try:</span>
<span class="gi">+        first_node = next(nlist)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return</span>
<span class="gi">+    G_to_add_to.add_node(first_node)</span>
<span class="gi">+    G_to_add_to.add_edges_from(pairwise(chain((first_node,), nlist)), **attr)</span>


<span class="w"> </span>def add_cycle(G_to_add_to, nodes_for_cycle, **attr):
<span class="gu">@@ -258,7 +327,15 @@ def add_cycle(G_to_add_to, nodes_for_cycle, **attr):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.add_cycle(G, [0, 1, 2, 3])
<span class="w"> </span>    &gt;&gt;&gt; nx.add_cycle(G, [10, 11, 12], weight=7)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nlist = iter(nodes_for_cycle)</span>
<span class="gi">+    try:</span>
<span class="gi">+        first_node = next(nlist)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return</span>
<span class="gi">+    G_to_add_to.add_node(first_node)</span>
<span class="gi">+    G_to_add_to.add_edges_from(</span>
<span class="gi">+        pairwise(chain((first_node,), nlist), cyclic=True), **attr</span>
<span class="gi">+    )</span>


<span class="w"> </span>def subgraph(G, nbunch):
<span class="gu">@@ -281,7 +358,7 @@ def subgraph(G, nbunch):</span>
<span class="w"> </span>    -----
<span class="w"> </span>    subgraph(G) calls G.subgraph()
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return G.subgraph(nbunch)</span>


<span class="w"> </span>def induced_subgraph(G, nbunch):
<span class="gu">@@ -326,7 +403,8 @@ def induced_subgraph(G, nbunch):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(H.nodes)
<span class="w"> </span>    [0, 1, 3]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    induced_nodes = nx.filters.show_nodes(G.nbunch_iter(nbunch))</span>
<span class="gi">+    return nx.subgraph_view(G, filter_node=induced_nodes)</span>


<span class="w"> </span>def edge_subgraph(G, edges):
<span class="gu">@@ -369,7 +447,23 @@ def edge_subgraph(G, edges):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(H.edges)
<span class="w"> </span>    [(0, 1), (3, 4)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nxf = nx.filters</span>
<span class="gi">+    edges = set(edges)</span>
<span class="gi">+    nodes = set()</span>
<span class="gi">+    for e in edges:</span>
<span class="gi">+        nodes.update(e[:2])</span>
<span class="gi">+    induced_nodes = nxf.show_nodes(nodes)</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            induced_edges = nxf.show_multidiedges(edges)</span>
<span class="gi">+        else:</span>
<span class="gi">+            induced_edges = nxf.show_multiedges(edges)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            induced_edges = nxf.show_diedges(edges)</span>
<span class="gi">+        else:</span>
<span class="gi">+            induced_edges = nxf.show_edges(edges)</span>
<span class="gi">+    return nx.subgraph_view(G, filter_node=induced_nodes, filter_edge=induced_edges)</span>


<span class="w"> </span>def restricted_view(G, nodes, edges):
<span class="gu">@@ -413,7 +507,19 @@ def restricted_view(G, nodes, edges):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(H.edges)
<span class="w"> </span>    [(2, 3)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nxf = nx.filters</span>
<span class="gi">+    hide_nodes = nxf.hide_nodes(nodes)</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            hide_edges = nxf.hide_multidiedges(edges)</span>
<span class="gi">+        else:</span>
<span class="gi">+            hide_edges = nxf.hide_multiedges(edges)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            hide_edges = nxf.hide_diedges(edges)</span>
<span class="gi">+        else:</span>
<span class="gi">+            hide_edges = nxf.hide_edges(edges)</span>
<span class="gi">+    return nx.subgraph_view(G, filter_node=hide_nodes, filter_edge=hide_edges)</span>


<span class="w"> </span>def to_directed(graph):
<span class="gu">@@ -423,7 +529,7 @@ def to_directed(graph):</span>
<span class="w"> </span>    Note that graph.to_directed defaults to `as_view=False`
<span class="w"> </span>    while this function always provides a view.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return graph.to_directed(as_view=True)</span>


<span class="w"> </span>def to_undirected(graph):
<span class="gu">@@ -433,7 +539,7 @@ def to_undirected(graph):</span>
<span class="w"> </span>    Note that graph.to_undirected defaults to `as_view=False`
<span class="w"> </span>    while this function always provides a view.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return graph.to_undirected(as_view=True)</span>


<span class="w"> </span>def create_empty_copy(G, with_data=True):
<span class="gu">@@ -452,7 +558,11 @@ def create_empty_copy(G, with_data=True):</span>
<span class="w"> </span>    empty_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    H = G.__class__()</span>
<span class="gi">+    H.add_nodes_from(G.nodes(data=with_data))</span>
<span class="gi">+    if with_data:</span>
<span class="gi">+        H.graph.update(G.graph)</span>
<span class="gi">+    return H</span>


<span class="w"> </span>def set_node_attributes(G, values, name=None):
<span class="gu">@@ -536,7 +646,24 @@ def set_node_attributes(G, values, name=None):</span>
<span class="w"> </span>        False

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Set node attributes based on type of `values`</span>
<span class="gi">+    if name is not None:  # `values` must not be a dict of dict</span>
<span class="gi">+        try:  # `values` is a dict</span>
<span class="gi">+            for n, v in values.items():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    G.nodes[n][name] = values[n]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+        except AttributeError:  # `values` is a constant</span>
<span class="gi">+            for n in G:</span>
<span class="gi">+                G.nodes[n][name] = values</span>
<span class="gi">+    else:  # `values` must be dict of dict</span>
<span class="gi">+        for n, d in values.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                G.nodes[n].update(d)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    nx._clear_cache(G)</span>


<span class="w"> </span>def get_node_attributes(G, name, default=None):
<span class="gu">@@ -570,7 +697,9 @@ def get_node_attributes(G, name, default=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; color[4]
<span class="w"> </span>    &#39;yellow&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if default is not None:</span>
<span class="gi">+        return {n: d.get(name, default) for n, d in G.nodes.items()}</span>
<span class="gi">+    return {n: d[name] for n, d in G.nodes.items() if name in d}</span>


<span class="w"> </span>def set_edge_attributes(G, values, name=None):
<span class="gu">@@ -674,7 +803,41 @@ def set_edge_attributes(G, values, name=None):</span>
<span class="w"> </span>        {(0, 1): 7}

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name is not None:</span>
<span class="gi">+        # `values` does not contain attribute names</span>
<span class="gi">+        try:</span>
<span class="gi">+            # if `values` is a dict using `.items()` =&gt; {edge: value}</span>
<span class="gi">+            if G.is_multigraph():</span>
<span class="gi">+                for (u, v, key), value in values.items():</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        G._adj[u][v][key][name] = value</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                for (u, v), value in values.items():</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        G._adj[u][v][name] = value</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # treat `values` as a constant</span>
<span class="gi">+            for u, v, data in G.edges(data=True):</span>
<span class="gi">+                data[name] = values</span>
<span class="gi">+    else:</span>
<span class="gi">+        # `values` consists of doct-of-dict {edge: {attr: value}} shape</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            for (u, v, key), d in values.items():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    G._adj[u][v][key].update(d)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            for (u, v), d in values.items():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    G._adj[u][v].update(d)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+    nx._clear_cache(G)</span>


<span class="w"> </span>def get_edge_attributes(G, name, default=None):
<span class="gu">@@ -710,7 +873,13 @@ def get_edge_attributes(G, name, default=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; color[(3, 4)]
<span class="w"> </span>    &#39;yellow&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        edges = G.edges(keys=True, data=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = G.edges(data=True)</span>
<span class="gi">+    if default is not None:</span>
<span class="gi">+        return {x[:-1]: x[-1].get(name, default) for x in edges}</span>
<span class="gi">+    return {x[:-1]: x[-1][name] for x in edges if name in x[-1]}</span>


<span class="w"> </span>def all_neighbors(graph, node):
<span class="gu">@@ -731,7 +900,11 @@ def all_neighbors(graph, node):</span>
<span class="w"> </span>    neighbors : iterator
<span class="w"> </span>        Iterator of neighbors
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if graph.is_directed():</span>
<span class="gi">+        values = chain(graph.predecessors(node), graph.successors(node))</span>
<span class="gi">+    else:</span>
<span class="gi">+        values = graph.neighbors(node)</span>
<span class="gi">+    return values</span>


<span class="w"> </span>def non_neighbors(graph, node):
<span class="gu">@@ -750,7 +923,7 @@ def non_neighbors(graph, node):</span>
<span class="w"> </span>    non_neighbors : set
<span class="w"> </span>        Set of nodes in the graph that are not neighbors of the node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return graph._adj.keys() - graph._adj[node].keys() - {node}</span>


<span class="w"> </span>def non_edges(graph):
<span class="gu">@@ -766,10 +939,19 @@ def non_edges(graph):</span>
<span class="w"> </span>    non_edges : iterator
<span class="w"> </span>        Iterator of edges that are not in the graph.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    if graph.is_directed():</span>
<span class="gi">+        for u in graph:</span>
<span class="gi">+            for v in non_neighbors(graph, u):</span>
<span class="gi">+                yield (u, v)</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodes = set(graph)</span>
<span class="gi">+        while nodes:</span>
<span class="gi">+            u = nodes.pop()</span>
<span class="gi">+            for v in nodes - set(graph[u]):</span>
<span class="gi">+                yield (u, v)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>def common_neighbors(G, u, v):
<span class="w"> </span>    &quot;&quot;&quot;Returns the common neighbors of two nodes in a graph.

<span class="gu">@@ -797,10 +979,15 @@ def common_neighbors(G, u, v):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(nx.common_neighbors(G, 0, 1))
<span class="w"> </span>    [2, 3, 4]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if u not in G:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;u is not in the graph.&quot;)</span>
<span class="gi">+    if v not in G:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;v is not in the graph.&quot;)</span>

<span class="gi">+    return G._adj[u].keys() &amp; G._adj[v].keys() - {u, v}</span>

<span class="gd">-def is_weighted(G, edge=None, weight=&#39;weight&#39;):</span>
<span class="gi">+</span>
<span class="gi">+def is_weighted(G, edge=None, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns True if `G` has weighted edges.

<span class="w"> </span>    Parameters
<span class="gu">@@ -839,11 +1026,22 @@ def is_weighted(G, edge=None, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if edge is not None:</span>
<span class="gi">+        data = G.get_edge_data(*edge)</span>
<span class="gi">+        if data is None:</span>
<span class="gi">+            msg = f&quot;Edge {edge!r} does not exist.&quot;</span>
<span class="gi">+            raise nx.NetworkXError(msg)</span>
<span class="gi">+        return weight in data</span>
<span class="gi">+</span>
<span class="gi">+    if is_empty(G):</span>
<span class="gi">+        # Special handling required since: all([]) == True</span>
<span class="gi">+        return False</span>

<span class="gi">+    return all(weight in data for u, v, data in G.edges(data=True))</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def is_negatively_weighted(G, edge=None, weight=&#39;weight&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def is_negatively_weighted(G, edge=None, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns True if `G` has negatively weighted edges.

<span class="w"> </span>    Parameters
<span class="gu">@@ -886,7 +1084,14 @@ def is_negatively_weighted(G, edge=None, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if edge is not None:</span>
<span class="gi">+        data = G.get_edge_data(*edge)</span>
<span class="gi">+        if data is None:</span>
<span class="gi">+            msg = f&quot;Edge {edge!r} does not exist.&quot;</span>
<span class="gi">+            raise nx.NetworkXError(msg)</span>
<span class="gi">+        return weight in data and data[weight] &lt; 0</span>
<span class="gi">+</span>
<span class="gi">+    return any(weight in data and data[weight] &lt; 0 for u, v, data in G.edges(data=True))</span>


<span class="w"> </span>def is_empty(G):
<span class="gu">@@ -909,7 +1114,7 @@ def is_empty(G):</span>
<span class="w"> </span>    is the number of nodes in the graph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return not any(G._adj.values())</span>


<span class="w"> </span>def nodes_with_selfloops(G):
<span class="gu">@@ -936,7 +1141,7 @@ def nodes_with_selfloops(G):</span>
<span class="w"> </span>    [1]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (n for n, nbrs in G._adj.items() if n in nbrs)</span>


<span class="w"> </span>def selfloop_edges(G, data=False, keys=False, default=None):
<span class="gu">@@ -981,7 +1186,64 @@ def selfloop_edges(G, data=False, keys=False, default=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; list(nx.selfloop_edges(G, keys=True, data=True))
<span class="w"> </span>    [(1, 1, 0, {})]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data is True:</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            if keys is True:</span>
<span class="gi">+                return (</span>
<span class="gi">+                    (n, n, k, d)</span>
<span class="gi">+                    for n, nbrs in G._adj.items()</span>
<span class="gi">+                    if n in nbrs</span>
<span class="gi">+                    for k, d in nbrs[n].items()</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                return (</span>
<span class="gi">+                    (n, n, d)</span>
<span class="gi">+                    for n, nbrs in G._adj.items()</span>
<span class="gi">+                    if n in nbrs</span>
<span class="gi">+                    for d in nbrs[n].values()</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ((n, n, nbrs[n]) for n, nbrs in G._adj.items() if n in nbrs)</span>
<span class="gi">+    elif data is not False:</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            if keys is True:</span>
<span class="gi">+                return (</span>
<span class="gi">+                    (n, n, k, d.get(data, default))</span>
<span class="gi">+                    for n, nbrs in G._adj.items()</span>
<span class="gi">+                    if n in nbrs</span>
<span class="gi">+                    for k, d in nbrs[n].items()</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                return (</span>
<span class="gi">+                    (n, n, d.get(data, default))</span>
<span class="gi">+                    for n, nbrs in G._adj.items()</span>
<span class="gi">+                    if n in nbrs</span>
<span class="gi">+                    for d in nbrs[n].values()</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (</span>
<span class="gi">+                (n, n, nbrs[n].get(data, default))</span>
<span class="gi">+                for n, nbrs in G._adj.items()</span>
<span class="gi">+                if n in nbrs</span>
<span class="gi">+            )</span>
<span class="gi">+    else:</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            if keys is True:</span>
<span class="gi">+                return (</span>
<span class="gi">+                    (n, n, k)</span>
<span class="gi">+                    for n, nbrs in G._adj.items()</span>
<span class="gi">+                    if n in nbrs</span>
<span class="gi">+                    for k in nbrs[n]</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                return (</span>
<span class="gi">+                    (n, n)</span>
<span class="gi">+                    for n, nbrs in G._adj.items()</span>
<span class="gi">+                    if n in nbrs</span>
<span class="gi">+                    for i in range(len(nbrs[n]))  # for easy edge removal (#4068)</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ((n, n) for n, nbrs in G._adj.items() if n in nbrs)</span>


<span class="w"> </span>def number_of_selfloops(G):
<span class="gu">@@ -1006,7 +1268,7 @@ def number_of_selfloops(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.number_of_selfloops(G)
<span class="w"> </span>    1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(1 for _ in nx.selfloop_edges(G))</span>


<span class="w"> </span>def is_path(G, path):
<span class="gu">@@ -1029,7 +1291,10 @@ def is_path(G, path):</span>
<span class="w"> </span>        True if `path` is a valid path in `G`

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return all(nbr in G._adj[node] for node, nbr in nx.utils.pairwise(path))</span>
<span class="gi">+    except (KeyError, TypeError):</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def path_weight(G, path, weight):
<span class="gu">@@ -1057,4 +1322,14 @@ def path_weight(G, path, weight):</span>
<span class="w"> </span>    NetworkXNoPath
<span class="w"> </span>        If the specified edge does not exist.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    multigraph = G.is_multigraph()</span>
<span class="gi">+    cost = 0</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_path(G, path):</span>
<span class="gi">+        raise nx.NetworkXNoPath(&quot;path does not exist&quot;)</span>
<span class="gi">+    for node, nbr in nx.utils.pairwise(path):</span>
<span class="gi">+        if multigraph:</span>
<span class="gi">+            cost += min(v[weight] for v in G._adj[node][nbr].values())</span>
<span class="gi">+        else:</span>
<span class="gi">+            cost += G._adj[node][nbr][weight]</span>
<span class="gi">+    return cost</span>
<span class="gh">diff --git a/networkx/classes/graph.py b/networkx/classes/graph.py</span>
<span class="gh">index e41c191f7..bf628ed62 100644</span>
<span class="gd">--- a/networkx/classes/graph.py</span>
<span class="gi">+++ b/networkx/classes/graph.py</span>
<span class="gu">@@ -9,12 +9,14 @@ For directed graphs see DiGraph and MultiDiGraph.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from functools import cached_property
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx import convert
<span class="w"> </span>from networkx.classes.coreviews import AdjacencyView
<span class="w"> </span>from networkx.classes.reportviews import DegreeView, EdgeView, NodeView
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="gd">-__all__ = [&#39;Graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;Graph&quot;]</span>


<span class="w"> </span>class _CachedPropertyResetterAdj:
<span class="gu">@@ -34,9 +36,9 @@ class _CachedPropertyResetterAdj:</span>

<span class="w"> </span>    def __set__(self, obj, value):
<span class="w"> </span>        od = obj.__dict__
<span class="gd">-        od[&#39;_adj&#39;] = value</span>
<span class="gd">-        if &#39;adj&#39; in od:</span>
<span class="gd">-            del od[&#39;adj&#39;]</span>
<span class="gi">+        od[&quot;_adj&quot;] = value</span>
<span class="gi">+        if &quot;adj&quot; in od:</span>
<span class="gi">+            del od[&quot;adj&quot;]</span>


<span class="w"> </span>class _CachedPropertyResetterNode:
<span class="gu">@@ -56,9 +58,9 @@ class _CachedPropertyResetterNode:</span>

<span class="w"> </span>    def __set__(self, obj, value):
<span class="w"> </span>        od = obj.__dict__
<span class="gd">-        od[&#39;_node&#39;] = value</span>
<span class="gd">-        if &#39;nodes&#39; in od:</span>
<span class="gd">-            del od[&#39;nodes&#39;]</span>
<span class="gi">+        od[&quot;_node&quot;] = value</span>
<span class="gi">+        if &quot;nodes&quot; in od:</span>
<span class="gi">+            del od[&quot;nodes&quot;]</span>


<span class="w"> </span>class Graph:
<span class="gu">@@ -300,8 +302,10 @@ class Graph:</span>
<span class="w"> </span>    &gt;&gt;&gt; G[2][1] is G[2][2]
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _adj = _CachedPropertyResetterAdj()
<span class="w"> </span>    _node = _CachedPropertyResetterNode()
<span class="gi">+</span>
<span class="w"> </span>    node_dict_factory = dict
<span class="w"> </span>    node_attr_dict_factory = dict
<span class="w"> </span>    adjlist_outer_dict_factory = dict
<span class="gu">@@ -315,7 +319,7 @@ class Graph:</span>
<span class="w"> </span>        If you subclass the base classes, use this to designate
<span class="w"> </span>        what directed class to use for `to_directed()` copies.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return nx.DiGraph</span>

<span class="w"> </span>    def to_undirected_class(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the class to use for empty undirected copies.
<span class="gu">@@ -323,7 +327,7 @@ class Graph:</span>
<span class="w"> </span>        If you subclass the base classes, use this to designate
<span class="w"> </span>        what directed class to use for `to_directed()` copies.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Graph</span>

<span class="w"> </span>    def __init__(self, incoming_graph_data=None, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Initialize a graph with edges, name, or graph attributes.
<span class="gu">@@ -358,12 +362,14 @@ class Graph:</span>
<span class="w"> </span>        {&#39;day&#39;: &#39;Friday&#39;}

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self.graph = self.graph_attr_dict_factory()</span>
<span class="gd">-        self._node = self.node_dict_factory()</span>
<span class="gd">-        self._adj = self.adjlist_outer_dict_factory()</span>
<span class="gi">+        self.graph = self.graph_attr_dict_factory()  # dictionary for graph attributes</span>
<span class="gi">+        self._node = self.node_dict_factory()  # empty node attribute dict</span>
<span class="gi">+        self._adj = self.adjlist_outer_dict_factory()  # empty adjacency dict</span>
<span class="w"> </span>        self.__networkx_cache__ = {}
<span class="gi">+        # attempt to load graph with data</span>
<span class="w"> </span>        if incoming_graph_data is not None:
<span class="w"> </span>            convert.to_networkx_graph(incoming_graph_data, create_using=self)
<span class="gi">+        # load graph attributes (must be after convert)</span>
<span class="w"> </span>        self.graph.update(attr)

<span class="w"> </span>    @cached_property
<span class="gu">@@ -383,7 +389,7 @@ class Graph:</span>

<span class="w"> </span>        For directed graphs, `G.adj` holds outgoing (successor) info.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return AdjacencyView(self._adj)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def name(self):
<span class="gu">@@ -393,7 +399,12 @@ class Graph:</span>
<span class="w"> </span>        keyed by the string `&quot;name&quot;`. as well as an attribute (technically
<span class="w"> </span>        a property) `G.name`. This is entirely user controlled.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.graph.get(&quot;name&quot;, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, s):</span>
<span class="gi">+        self.graph[&quot;name&quot;] = s</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns a short summary of the graph.
<span class="gu">@@ -415,10 +426,13 @@ class Graph:</span>
<span class="w"> </span>        &#39;Graph with 3 nodes and 2 edges&#39;

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return &#39;&#39;.join([type(self).__name__, f&#39; named {self.name!r}&#39; if</span>
<span class="gd">-            self.name else &#39;&#39;,</span>
<span class="gd">-            f&#39; with {self.number_of_nodes()} nodes and {self.number_of_edges()} edges&#39;</span>
<span class="gd">-            ])</span>
<span class="gi">+        return &quot;&quot;.join(</span>
<span class="gi">+            [</span>
<span class="gi">+                type(self).__name__,</span>
<span class="gi">+                f&quot; named {self.name!r}&quot; if self.name else &quot;&quot;,</span>
<span class="gi">+                f&quot; with {self.number_of_nodes()} nodes and {self.number_of_edges()} edges&quot;,</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        &quot;&quot;&quot;Iterate over the nodes. Use: &#39;for n in G&#39;.
<span class="gu">@@ -539,7 +553,15 @@ class Graph:</span>
<span class="w"> </span>        NetworkX Graphs, though one should be careful that the hash
<span class="w"> </span>        doesn&#39;t change on mutables.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node_for_adding not in self._node:</span>
<span class="gi">+            if node_for_adding is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._adj[node_for_adding] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            attr_dict = self._node[node_for_adding] = self.node_attr_dict_factory()</span>
<span class="gi">+            attr_dict.update(attr)</span>
<span class="gi">+        else:  # update attr even if node already exists</span>
<span class="gi">+            self._node[node_for_adding].update(attr)</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def add_nodes_from(self, nodes_for_adding, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add multiple nodes.
<span class="gu">@@ -602,7 +624,22 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; # correct way
<span class="w"> </span>        &gt;&gt;&gt; G.add_nodes_from(list(n + 1 for n in G.nodes))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for n in nodes_for_adding:</span>
<span class="gi">+            try:</span>
<span class="gi">+                newnode = n not in self._node</span>
<span class="gi">+                newdict = attr</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                n, ndict = n</span>
<span class="gi">+                newnode = n not in self._node</span>
<span class="gi">+                newdict = attr.copy()</span>
<span class="gi">+                newdict.update(ndict)</span>
<span class="gi">+            if newnode:</span>
<span class="gi">+                if n is None:</span>
<span class="gi">+                    raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+                self._adj[n] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+                self._node[n] = self.node_attr_dict_factory()</span>
<span class="gi">+            self._node[n].update(newdict)</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_node(self, n):
<span class="w"> </span>        &quot;&quot;&quot;Remove node n.
<span class="gu">@@ -634,7 +671,16 @@ class Graph:</span>
<span class="w"> </span>        []

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        adj = self._adj</span>
<span class="gi">+        try:</span>
<span class="gi">+            nbrs = list(adj[n])  # list handles self-loops (allows mutation)</span>
<span class="gi">+            del self._node[n]</span>
<span class="gi">+        except KeyError as err:  # NetworkXError if n not in self</span>
<span class="gi">+            raise NetworkXError(f&quot;The node {n} is not in the graph.&quot;) from err</span>
<span class="gi">+        for u in nbrs:</span>
<span class="gi">+            del adj[u][n]  # remove all edges n-u in graph</span>
<span class="gi">+        del adj[n]  # now remove node</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_nodes_from(self, nodes):
<span class="w"> </span>        &quot;&quot;&quot;Remove multiple nodes.
<span class="gu">@@ -678,7 +724,16 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; # this command will work, since the dictionary underlying graph is not modified
<span class="w"> </span>        &gt;&gt;&gt; G.remove_nodes_from(list(n for n in G.nodes if n &lt; 2))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        adj = self._adj</span>
<span class="gi">+        for n in nodes:</span>
<span class="gi">+            try:</span>
<span class="gi">+                del self._node[n]</span>
<span class="gi">+                for u in list(adj[n]):  # list handles self-loops</span>
<span class="gi">+                    del adj[u][n]  # (allows mutation of dict in loop)</span>
<span class="gi">+                del adj[n]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def nodes(self):
<span class="gu">@@ -771,7 +826,7 @@ class Graph:</span>
<span class="w"> </span>            {0: 1, 1: 2, 2: 3}

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return NodeView(self)</span>

<span class="w"> </span>    def number_of_nodes(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of nodes in the graph.
<span class="gu">@@ -792,7 +847,7 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; G.number_of_nodes()
<span class="w"> </span>        3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self._node)</span>

<span class="w"> </span>    def order(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of nodes in the graph.
<span class="gu">@@ -813,7 +868,7 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; G.order()
<span class="w"> </span>        3
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self._node)</span>

<span class="w"> </span>    def has_node(self, n):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if the graph contains the node n.
<span class="gu">@@ -836,7 +891,10 @@ class Graph:</span>
<span class="w"> </span>        True

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return n in self._node</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    def add_edge(self, u_of_edge, v_of_edge, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add an edge between u and v.
<span class="gu">@@ -888,7 +946,24 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; G[1][2].update({0: 5})
<span class="w"> </span>        &gt;&gt;&gt; G.edges[1, 2].update({0: 5})
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        u, v = u_of_edge, v_of_edge</span>
<span class="gi">+        # add nodes</span>
<span class="gi">+        if u not in self._node:</span>
<span class="gi">+            if u is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._adj[u] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._node[u] = self.node_attr_dict_factory()</span>
<span class="gi">+        if v not in self._node:</span>
<span class="gi">+            if v is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._adj[v] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._node[v] = self.node_attr_dict_factory()</span>
<span class="gi">+        # add the edge</span>
<span class="gi">+        datadict = self._adj[u].get(v, self.edge_attr_dict_factory())</span>
<span class="gi">+        datadict.update(attr)</span>
<span class="gi">+        self._adj[u][v] = datadict</span>
<span class="gi">+        self._adj[v][u] = datadict</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def add_edges_from(self, ebunch_to_add, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add all the edges in ebunch_to_add.
<span class="gu">@@ -945,9 +1020,33 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; # correct way - note that there will be no self-edge for node 5
<span class="w"> </span>        &gt;&gt;&gt; G.add_edges_from(list((5, n) for n in G.nodes))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_weighted_edges_from(self, ebunch_to_add, weight=&#39;weight&#39;, **attr):</span>
<span class="gi">+        for e in ebunch_to_add:</span>
<span class="gi">+            ne = len(e)</span>
<span class="gi">+            if ne == 3:</span>
<span class="gi">+                u, v, dd = e</span>
<span class="gi">+            elif ne == 2:</span>
<span class="gi">+                u, v = e</span>
<span class="gi">+                dd = {}  # doesn&#39;t need edge_attr_dict_factory</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise NetworkXError(f&quot;Edge tuple {e} must be a 2-tuple or 3-tuple.&quot;)</span>
<span class="gi">+            if u not in self._node:</span>
<span class="gi">+                if u is None:</span>
<span class="gi">+                    raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+                self._adj[u] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+                self._node[u] = self.node_attr_dict_factory()</span>
<span class="gi">+            if v not in self._node:</span>
<span class="gi">+                if v is None:</span>
<span class="gi">+                    raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+                self._adj[v] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+                self._node[v] = self.node_attr_dict_factory()</span>
<span class="gi">+            datadict = self._adj[u].get(v, self.edge_attr_dict_factory())</span>
<span class="gi">+            datadict.update(attr)</span>
<span class="gi">+            datadict.update(dd)</span>
<span class="gi">+            self._adj[u][v] = datadict</span>
<span class="gi">+            self._adj[v][u] = datadict</span>
<span class="gi">+        nx._clear_cache(self)</span>
<span class="gi">+</span>
<span class="gi">+    def add_weighted_edges_from(self, ebunch_to_add, weight=&quot;weight&quot;, **attr):</span>
<span class="w"> </span>        &quot;&quot;&quot;Add weighted edges in `ebunch_to_add` with specified weight attr

<span class="w"> </span>        Parameters
<span class="gu">@@ -995,7 +1094,8 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; # correct way - note that there will be no self-edge for node 5
<span class="w"> </span>        &gt;&gt;&gt; G.add_weighted_edges_from(list((5, n, weight) for n in G.nodes))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.add_edges_from(((u, v, {weight: d}) for u, v, d in ebunch_to_add), **attr)</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_edge(self, u, v):
<span class="w"> </span>        &quot;&quot;&quot;Remove the edge between u and v.
<span class="gu">@@ -1023,7 +1123,13 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; e = (2, 3, {&quot;weight&quot;: 7})  # an edge with attribute data
<span class="w"> </span>        &gt;&gt;&gt; G.remove_edge(*e[:2])  # select first part of edge tuple
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            del self._adj[u][v]</span>
<span class="gi">+            if u != v:  # self-loop needs only one entry removed</span>
<span class="gi">+                del self._adj[v][u]</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;The edge {u}-{v} is not in the graph&quot;) from err</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_edges_from(self, ebunch):
<span class="w"> </span>        &quot;&quot;&quot;Remove all edges specified in ebunch.
<span class="gu">@@ -1051,7 +1157,14 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; ebunch = [(1, 2), (2, 3)]
<span class="w"> </span>        &gt;&gt;&gt; G.remove_edges_from(ebunch)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        adj = self._adj</span>
<span class="gi">+        for e in ebunch:</span>
<span class="gi">+            u, v = e[:2]  # ignore edge data if present</span>
<span class="gi">+            if u in adj and v in adj[u]:</span>
<span class="gi">+                del adj[u][v]</span>
<span class="gi">+                if u != v:  # self loop needs only one entry removed</span>
<span class="gi">+                    del adj[v][u]</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def update(self, edges=None, nodes=None):
<span class="w"> </span>        &quot;&quot;&quot;Update the graph using nodes/edges/graphs as input.
<span class="gu">@@ -1140,7 +1253,26 @@ class Graph:</span>
<span class="w"> </span>        add_edges_from: add multiple edges to a graph
<span class="w"> </span>        add_nodes_from: add multiple nodes to a graph
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if edges is not None:</span>
<span class="gi">+            if nodes is not None:</span>
<span class="gi">+                self.add_nodes_from(nodes)</span>
<span class="gi">+                self.add_edges_from(edges)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # check if edges is a Graph object</span>
<span class="gi">+                try:</span>
<span class="gi">+                    graph_nodes = edges.nodes</span>
<span class="gi">+                    graph_edges = edges.edges</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    # edge not Graph-like</span>
<span class="gi">+                    self.add_edges_from(edges)</span>
<span class="gi">+                else:  # edges is Graph-like</span>
<span class="gi">+                    self.add_nodes_from(graph_nodes.data())</span>
<span class="gi">+                    self.add_edges_from(graph_edges.data())</span>
<span class="gi">+                    self.graph.update(edges.graph)</span>
<span class="gi">+        elif nodes is not None:</span>
<span class="gi">+            self.add_nodes_from(nodes)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise NetworkXError(&quot;update needs nodes or edges input&quot;)</span>

<span class="w"> </span>    def has_edge(self, u, v):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if the edge (u, v) is in the graph.
<span class="gu">@@ -1178,7 +1310,10 @@ class Graph:</span>
<span class="w"> </span>        True

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return v in self._adj[u]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    def neighbors(self, n):
<span class="w"> </span>        &quot;&quot;&quot;Returns an iterator over all neighbors of node n.
<span class="gu">@@ -1218,7 +1353,10 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; [n for n in G[0]]
<span class="w"> </span>        [1]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return iter(self._adj[n])</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;The node {n} is not in the graph.&quot;) from err</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def edges(self):
<span class="gu">@@ -1275,7 +1413,7 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; G.edges(0)  # only edges from node 0
<span class="w"> </span>        EdgeDataView([(0, 1)])
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return EdgeView(self)</span>

<span class="w"> </span>    def get_edge_data(self, u, v, default=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns the attribute dictionary associated with edge (u, v).
<span class="gu">@@ -1318,7 +1456,10 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; G.get_edge_data(&quot;a&quot;, &quot;b&quot;, default=0)  # edge not in graph, return 0
<span class="w"> </span>        0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._adj[u][v]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return default</span>

<span class="w"> </span>    def adjacency(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns an iterator over (node, adjacency dict) tuples for all nodes.
<span class="gu">@@ -1338,7 +1479,7 @@ class Graph:</span>
<span class="w"> </span>        [(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return iter(self._adj.items())</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def degree(self):
<span class="gu">@@ -1376,7 +1517,7 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; list(G.degree([0, 1, 2]))
<span class="w"> </span>        [(0, 1), (1, 2), (2, 2)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return DegreeView(self)</span>

<span class="w"> </span>    def clear(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove all nodes and edges from the graph.
<span class="gu">@@ -1393,7 +1534,10 @@ class Graph:</span>
<span class="w"> </span>        []

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._adj.clear()</span>
<span class="gi">+        self._node.clear()</span>
<span class="gi">+        self.graph.clear()</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def clear_edges(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove all edges from the graph without altering nodes.
<span class="gu">@@ -1407,15 +1551,17 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; list(G.edges)
<span class="w"> </span>        []
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for nbr_dict in self._adj.values():</span>
<span class="gi">+            nbr_dict.clear()</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def is_multigraph(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if graph is a multigraph, False otherwise.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def is_directed(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if graph is directed, False otherwise.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def copy(self, as_view=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns a copy of the graph.
<span class="gu">@@ -1494,7 +1640,17 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; H = G.copy()

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if as_view is True:</span>
<span class="gi">+            return nx.graphviews.generic_graph_view(self)</span>
<span class="gi">+        G = self.__class__()</span>
<span class="gi">+        G.graph.update(self.graph)</span>
<span class="gi">+        G.add_nodes_from((n, d.copy()) for n, d in self._node.items())</span>
<span class="gi">+        G.add_edges_from(</span>
<span class="gi">+            (u, v, datadict.copy())</span>
<span class="gi">+            for u, nbrs in self._adj.items()</span>
<span class="gi">+            for v, datadict in nbrs.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        return G</span>

<span class="w"> </span>    def to_directed(self, as_view=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns a directed representation of the graph.
<span class="gu">@@ -1538,7 +1694,19 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; list(H.edges)
<span class="w"> </span>        [(0, 1)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        graph_class = self.to_directed_class()</span>
<span class="gi">+        if as_view is True:</span>
<span class="gi">+            return nx.graphviews.generic_graph_view(self, graph_class)</span>
<span class="gi">+        # deepcopy when not a view</span>
<span class="gi">+        G = graph_class()</span>
<span class="gi">+        G.graph.update(deepcopy(self.graph))</span>
<span class="gi">+        G.add_nodes_from((n, deepcopy(d)) for n, d in self._node.items())</span>
<span class="gi">+        G.add_edges_from(</span>
<span class="gi">+            (u, v, deepcopy(data))</span>
<span class="gi">+            for u, nbrs in self._adj.items()</span>
<span class="gi">+            for v, data in nbrs.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        return G</span>

<span class="w"> </span>    def to_undirected(self, as_view=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns an undirected copy of the graph.
<span class="gu">@@ -1583,7 +1751,19 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; list(G2.edges)
<span class="w"> </span>        [(0, 1)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        graph_class = self.to_undirected_class()</span>
<span class="gi">+        if as_view is True:</span>
<span class="gi">+            return nx.graphviews.generic_graph_view(self, graph_class)</span>
<span class="gi">+        # deepcopy when not a view</span>
<span class="gi">+        G = graph_class()</span>
<span class="gi">+        G.graph.update(deepcopy(self.graph))</span>
<span class="gi">+        G.add_nodes_from((n, deepcopy(d)) for n, d in self._node.items())</span>
<span class="gi">+        G.add_edges_from(</span>
<span class="gi">+            (u, v, deepcopy(d))</span>
<span class="gi">+            for u, nbrs in self._adj.items()</span>
<span class="gi">+            for v, d in nbrs.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        return G</span>

<span class="w"> </span>    def subgraph(self, nodes):
<span class="w"> </span>        &quot;&quot;&quot;Returns a SubGraph view of the subgraph induced on `nodes`.
<span class="gu">@@ -1650,7 +1830,14 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; list(H.edges)
<span class="w"> </span>        [(0, 1), (1, 2)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        induced_nodes = nx.filters.show_nodes(self.nbunch_iter(nodes))</span>
<span class="gi">+        # if already a subgraph, don&#39;t make a chain</span>
<span class="gi">+        subgraph = nx.subgraph_view</span>
<span class="gi">+        if hasattr(self, &quot;_NODE_OK&quot;):</span>
<span class="gi">+            return subgraph(</span>
<span class="gi">+                self._graph, filter_node=induced_nodes, filter_edge=self._EDGE_OK</span>
<span class="gi">+            )</span>
<span class="gi">+        return subgraph(self, filter_node=induced_nodes)</span>

<span class="w"> </span>    def edge_subgraph(self, edges):
<span class="w"> </span>        &quot;&quot;&quot;Returns the subgraph induced by the specified edges.
<span class="gu">@@ -1690,7 +1877,7 @@ class Graph:</span>
<span class="w"> </span>        [(0, 1), (3, 4)]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return nx.edge_subgraph(self, edges)</span>

<span class="w"> </span>    def size(self, weight=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of edges or total of all edge weights.
<span class="gu">@@ -1728,7 +1915,12 @@ class Graph:</span>
<span class="w"> </span>        &gt;&gt;&gt; G.size(weight=&quot;weight&quot;)
<span class="w"> </span>        6.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = sum(d for v, d in self.degree(weight=weight))</span>
<span class="gi">+        # If `weight` is None, the sum of the degrees is guaranteed to be</span>
<span class="gi">+        # even, so we can perform integer division and hence return an</span>
<span class="gi">+        # integer. Otherwise, the sum of the weighted degrees is not</span>
<span class="gi">+        # guaranteed to be an integer, so we perform &quot;real&quot; division.</span>
<span class="gi">+        return s // 2 if weight is None else s / 2</span>

<span class="w"> </span>    def number_of_edges(self, u=None, v=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of edges between two nodes.
<span class="gu">@@ -1776,7 +1968,11 @@ class Graph:</span>
<span class="w"> </span>        1

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if u is None:</span>
<span class="gi">+            return int(self.size())</span>
<span class="gi">+        if v in self._adj[u]:</span>
<span class="gi">+            return 1</span>
<span class="gi">+        return 0</span>

<span class="w"> </span>    def nbunch_iter(self, nbunch=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns an iterator over nodes contained in nbunch that are
<span class="gu">@@ -1818,4 +2014,30 @@ class Graph:</span>
<span class="w"> </span>        or None, a :exc:`NetworkXError` is raised.  Also, if any object in
<span class="w"> </span>        nbunch is not hashable, a :exc:`NetworkXError` is raised.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if nbunch is None:  # include all nodes via iterator</span>
<span class="gi">+            bunch = iter(self._adj)</span>
<span class="gi">+        elif nbunch in self:  # if nbunch is a single node</span>
<span class="gi">+            bunch = iter([nbunch])</span>
<span class="gi">+        else:  # if nbunch is a sequence of nodes</span>
<span class="gi">+</span>
<span class="gi">+            def bunch_iter(nlist, adj):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    for n in nlist:</span>
<span class="gi">+                        if n in adj:</span>
<span class="gi">+                            yield n</span>
<span class="gi">+                except TypeError as err:</span>
<span class="gi">+                    exc, message = err, err.args[0]</span>
<span class="gi">+                    # capture error for non-sequence/iterator nbunch.</span>
<span class="gi">+                    if &quot;iter&quot; in message:</span>
<span class="gi">+                        exc = NetworkXError(</span>
<span class="gi">+                            &quot;nbunch is not a node or a sequence of nodes.&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    # capture error for unhashable node.</span>
<span class="gi">+                    if &quot;hashable&quot; in message:</span>
<span class="gi">+                        exc = NetworkXError(</span>
<span class="gi">+                            f&quot;Node {n} in sequence nbunch is not a valid node.&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    raise exc</span>
<span class="gi">+</span>
<span class="gi">+            bunch = bunch_iter(nbunch, self._adj)</span>
<span class="gi">+        return bunch</span>
<span class="gh">diff --git a/networkx/classes/graphviews.py b/networkx/classes/graphviews.py</span>
<span class="gh">index d47d41c1b..275bbd71c 100644</span>
<span class="gd">--- a/networkx/classes/graphviews.py</span>
<span class="gi">+++ b/networkx/classes/graphviews.py</span>
<span class="gu">@@ -24,11 +24,18 @@ with induced subgraphs.</span>
<span class="w"> </span>Often it is easiest to use .copy() to avoid chains.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.classes.coreviews import FilterAdjacency, FilterAtlas, FilterMultiAdjacency, UnionAdjacency, UnionMultiAdjacency</span>
<span class="gi">+from networkx.classes.coreviews import (</span>
<span class="gi">+    FilterAdjacency,</span>
<span class="gi">+    FilterAtlas,</span>
<span class="gi">+    FilterMultiAdjacency,</span>
<span class="gi">+    UnionAdjacency,</span>
<span class="gi">+    UnionMultiAdjacency,</span>
<span class="gi">+)</span>
<span class="w"> </span>from networkx.classes.filters import no_filter
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.utils import deprecate_positional_args, not_implemented_for
<span class="gd">-__all__ = [&#39;generic_graph_view&#39;, &#39;subgraph_view&#39;, &#39;reverse_view&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;generic_graph_view&quot;, &quot;subgraph_view&quot;, &quot;reverse_view&quot;]</span>


<span class="w"> </span>def generic_graph_view(G, create_using=None):
<span class="gu">@@ -93,10 +100,39 @@ def generic_graph_view(G, create_using=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; type(viewDG)
<span class="w"> </span>    &lt;class &#39;networkx.classes.digraph.DiGraph&#39;&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@deprecate_positional_args(version=&#39;3.4&#39;)</span>
<span class="gi">+    if create_using is None:</span>
<span class="gi">+        newG = G.__class__()</span>
<span class="gi">+    else:</span>
<span class="gi">+        newG = nx.empty_graph(0, create_using)</span>
<span class="gi">+    if G.is_multigraph() != newG.is_multigraph():</span>
<span class="gi">+        raise NetworkXError(&quot;Multigraph for G must agree with create_using&quot;)</span>
<span class="gi">+    newG = nx.freeze(newG)</span>
<span class="gi">+</span>
<span class="gi">+    # create view by assigning attributes from G</span>
<span class="gi">+    newG._graph = G</span>
<span class="gi">+    newG.graph = G.graph</span>
<span class="gi">+</span>
<span class="gi">+    newG._node = G._node</span>
<span class="gi">+    if newG.is_directed():</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            newG._succ = G._succ</span>
<span class="gi">+            newG._pred = G._pred</span>
<span class="gi">+            # newG._adj is synced with _succ</span>
<span class="gi">+        else:</span>
<span class="gi">+            newG._succ = G._adj</span>
<span class="gi">+            newG._pred = G._adj</span>
<span class="gi">+            # newG._adj is synced with _succ</span>
<span class="gi">+    elif G.is_directed():</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            newG._adj = UnionMultiAdjacency(G._succ, G._pred)</span>
<span class="gi">+        else:</span>
<span class="gi">+            newG._adj = UnionAdjacency(G._succ, G._pred)</span>
<span class="gi">+    else:</span>
<span class="gi">+        newG._adj = G._adj</span>
<span class="gi">+    return newG</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@deprecate_positional_args(version=&quot;3.4&quot;)</span>
<span class="w"> </span>def subgraph_view(G, *, filter_node=no_filter, filter_edge=no_filter):
<span class="w"> </span>    &quot;&quot;&quot;View of `G` applying a filter on nodes and edges.

<span class="gu">@@ -168,10 +204,37 @@ def subgraph_view(G, *, filter_node=no_filter, filter_edge=no_filter):</span>
<span class="w"> </span>    &gt;&gt;&gt; view.edges()
<span class="w"> </span>    EdgeView([(0, 1), (1, 2), (2, 3)])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    newG = nx.freeze(G.__class__())</span>
<span class="gi">+    newG._NODE_OK = filter_node</span>
<span class="gi">+    newG._EDGE_OK = filter_edge</span>
<span class="gi">+</span>
<span class="gi">+    # create view by assigning attributes from G</span>
<span class="gi">+    newG._graph = G</span>
<span class="gi">+    newG.graph = G.graph</span>
<span class="gi">+</span>
<span class="gi">+    newG._node = FilterAtlas(G._node, filter_node)</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        Adj = FilterMultiAdjacency</span>
<span class="gi">+</span>
<span class="gi">+        def reverse_edge(u, v, k=None):</span>
<span class="gi">+            return filter_edge(v, u, k)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        Adj = FilterAdjacency</span>
<span class="gi">+</span>
<span class="gi">+        def reverse_edge(u, v, k=None):</span>
<span class="gi">+            return filter_edge(v, u)</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        newG._succ = Adj(G._succ, filter_node, filter_edge)</span>
<span class="gi">+        newG._pred = Adj(G._pred, filter_node, reverse_edge)</span>
<span class="gi">+        # newG._adj is synced with _succ</span>
<span class="gi">+    else:</span>
<span class="gi">+        newG._adj = Adj(G._adj, filter_node, filter_edge)</span>
<span class="gi">+    return newG</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="w"> </span>def reverse_view(G):
<span class="w"> </span>    &quot;&quot;&quot;View of `G` with edge directions reversed

<span class="gu">@@ -200,4 +263,7 @@ def reverse_view(G):</span>
<span class="w"> </span>    &gt;&gt;&gt; view.edges()
<span class="w"> </span>    OutEdgeView([(2, 1), (3, 2)])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    newG = generic_graph_view(G)</span>
<span class="gi">+    newG._succ, newG._pred = G._pred, G._succ</span>
<span class="gi">+    # newG._adj is synced with _succ</span>
<span class="gi">+    return newG</span>
<span class="gh">diff --git a/networkx/classes/multidigraph.py b/networkx/classes/multidigraph.py</span>
<span class="gh">index 3ae6b64bc..ad048cd5a 100644</span>
<span class="gd">--- a/networkx/classes/multidigraph.py</span>
<span class="gi">+++ b/networkx/classes/multidigraph.py</span>
<span class="gu">@@ -1,14 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Base class for MultiDiGraph.&quot;&quot;&quot;
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from functools import cached_property
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx import convert
<span class="w"> </span>from networkx.classes.coreviews import MultiAdjacencyView
<span class="w"> </span>from networkx.classes.digraph import DiGraph
<span class="w"> </span>from networkx.classes.multigraph import MultiGraph
<span class="gd">-from networkx.classes.reportviews import DiMultiDegreeView, InMultiDegreeView, InMultiEdgeView, OutMultiDegreeView, OutMultiEdgeView</span>
<span class="gi">+from networkx.classes.reportviews import (</span>
<span class="gi">+    DiMultiDegreeView,</span>
<span class="gi">+    InMultiDegreeView,</span>
<span class="gi">+    InMultiEdgeView,</span>
<span class="gi">+    OutMultiDegreeView,</span>
<span class="gi">+    OutMultiEdgeView,</span>
<span class="gi">+)</span>
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="gd">-__all__ = [&#39;MultiDiGraph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;MultiDiGraph&quot;]</span>


<span class="w"> </span>class MultiDiGraph(MultiGraph, DiGraph):
<span class="gu">@@ -283,10 +291,14 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>    &gt;&gt;&gt; G[2][1] is G[2][2]
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # node_dict_factory = dict    # already assigned in Graph</span>
<span class="gi">+    # adjlist_outer_dict_factory = dict</span>
<span class="gi">+    # adjlist_inner_dict_factory = dict</span>
<span class="w"> </span>    edge_key_dict_factory = dict
<span class="gi">+    # edge_attr_dict_factory = dict</span>

<span class="gd">-    def __init__(self, incoming_graph_data=None, multigraph_input=None, **attr</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init__(self, incoming_graph_data=None, multigraph_input=None, **attr):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a graph with edges, name, or graph attributes.

<span class="w"> </span>        Parameters
<span class="gu">@@ -332,19 +344,19 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        {&#39;day&#39;: &#39;Friday&#39;}

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        if isinstance(incoming_graph_data, dict</span>
<span class="gd">-            ) and multigraph_input is not False:</span>
<span class="gi">+        # multigraph_input can be None/True/False. So check &quot;is not False&quot;</span>
<span class="gi">+        if isinstance(incoming_graph_data, dict) and multigraph_input is not False:</span>
<span class="w"> </span>            DiGraph.__init__(self)
<span class="w"> </span>            try:
<span class="gd">-                convert.from_dict_of_dicts(incoming_graph_data,</span>
<span class="gd">-                    create_using=self, multigraph_input=True)</span>
<span class="gi">+                convert.from_dict_of_dicts(</span>
<span class="gi">+                    incoming_graph_data, create_using=self, multigraph_input=True</span>
<span class="gi">+                )</span>
<span class="w"> </span>                self.graph.update(attr)
<span class="w"> </span>            except Exception as err:
<span class="w"> </span>                if multigraph_input is True:
<span class="w"> </span>                    raise nx.NetworkXError(
<span class="gd">-                        f&quot;&quot;&quot;converting multigraph_input raised:</span>
<span class="gd">-{type(err)}: {err}&quot;&quot;&quot;</span>
<span class="gd">-                        )</span>
<span class="gi">+                        f&quot;converting multigraph_input raised:\n{type(err)}: {err}&quot;</span>
<span class="gi">+                    )</span>
<span class="w"> </span>                DiGraph.__init__(self, incoming_graph_data, **attr)
<span class="w"> </span>        else:
<span class="w"> </span>            DiGraph.__init__(self, incoming_graph_data, **attr)
<span class="gu">@@ -366,7 +378,7 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>

<span class="w"> </span>        For directed graphs, `G.adj` holds outgoing (successor) info.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return MultiAdjacencyView(self._succ)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def succ(self):
<span class="gu">@@ -385,7 +397,7 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>

<span class="w"> </span>        For directed graphs, `G.succ` is identical to `G.adj`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return MultiAdjacencyView(self._succ)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def pred(self):
<span class="gu">@@ -399,7 +411,7 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        Iterating over G.adj behaves like a dict. Useful idioms include
<span class="w"> </span>        `for nbr, datadict in G.adj[n].items():`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return MultiAdjacencyView(self._pred)</span>

<span class="w"> </span>    def add_edge(self, u_for_edge, v_for_edge, key=None, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add an edge between u and v.
<span class="gu">@@ -467,7 +479,37 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        &gt;&gt;&gt; G[1][2][0].update({0: 5})
<span class="w"> </span>        &gt;&gt;&gt; G.edges[1, 2, 0].update({0: 5})
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        u, v = u_for_edge, v_for_edge</span>
<span class="gi">+        # add nodes</span>
<span class="gi">+        if u not in self._succ:</span>
<span class="gi">+            if u is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._succ[u] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._pred[u] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._node[u] = self.node_attr_dict_factory()</span>
<span class="gi">+        if v not in self._succ:</span>
<span class="gi">+            if v is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._succ[v] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._pred[v] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._node[v] = self.node_attr_dict_factory()</span>
<span class="gi">+        if key is None:</span>
<span class="gi">+            key = self.new_edge_key(u, v)</span>
<span class="gi">+        if v in self._succ[u]:</span>
<span class="gi">+            keydict = self._adj[u][v]</span>
<span class="gi">+            datadict = keydict.get(key, self.edge_attr_dict_factory())</span>
<span class="gi">+            datadict.update(attr)</span>
<span class="gi">+            keydict[key] = datadict</span>
<span class="gi">+        else:</span>
<span class="gi">+            # selfloops work this way without special treatment</span>
<span class="gi">+            datadict = self.edge_attr_dict_factory()</span>
<span class="gi">+            datadict.update(attr)</span>
<span class="gi">+            keydict = self.edge_key_dict_factory()</span>
<span class="gi">+            keydict[key] = datadict</span>
<span class="gi">+            self._succ[u][v] = keydict</span>
<span class="gi">+            self._pred[v][u] = keydict</span>
<span class="gi">+        nx._clear_cache(self)</span>
<span class="gi">+        return key</span>

<span class="w"> </span>    def remove_edge(self, u, v, key=None):
<span class="w"> </span>        &quot;&quot;&quot;Remove an edge between u and v.
<span class="gu">@@ -525,7 +567,24 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        OutMultiEdgeView([(1, 2, &#39;second&#39;)])

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            d = self._adj[u][v]</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;The edge {u}-{v} is not in the graph.&quot;) from err</span>
<span class="gi">+        # remove the edge with specified data</span>
<span class="gi">+        if key is None:</span>
<span class="gi">+            d.popitem()</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                del d[key]</span>
<span class="gi">+            except KeyError as err:</span>
<span class="gi">+                msg = f&quot;The edge {u}-{v} with key {key} is not in the graph.&quot;</span>
<span class="gi">+                raise NetworkXError(msg) from err</span>
<span class="gi">+        if len(d) == 0:</span>
<span class="gi">+            # remove the key entries if last edge</span>
<span class="gi">+            del self._succ[u][v]</span>
<span class="gi">+            del self._pred[v][u]</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def edges(self):
<span class="gu">@@ -606,7 +665,13 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        --------
<span class="w"> </span>        in_edges, out_edges
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return OutMultiEdgeView(self)</span>
<span class="gi">+</span>
<span class="gi">+    # alias out_edges to edges</span>
<span class="gi">+    @cached_property</span>
<span class="gi">+    def out_edges(self):</span>
<span class="gi">+        return OutMultiEdgeView(self)</span>
<span class="gi">+</span>
<span class="w"> </span>    out_edges.__doc__ = edges.__doc__

<span class="w"> </span>    @cached_property
<span class="gu">@@ -641,7 +706,7 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        --------
<span class="w"> </span>        edges
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return InMultiEdgeView(self)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def degree(self):
<span class="gu">@@ -689,7 +754,7 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        [(0, 2), (1, 3), (2, 2)]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return DiMultiDegreeView(self)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def in_degree(self):
<span class="gu">@@ -740,7 +805,7 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        [(0, 0), (1, 2), (2, 1)]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return InMultiDegreeView(self)</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def out_degree(self):
<span class="gu">@@ -790,15 +855,15 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        [(0, 2), (1, 1), (2, 1)]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return OutMultiDegreeView(self)</span>

<span class="w"> </span>    def is_multigraph(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if graph is a multigraph, False otherwise.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def is_directed(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if graph is directed, False otherwise.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def to_undirected(self, reciprocal=False, as_view=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns an undirected representation of the digraph.
<span class="gu">@@ -851,7 +916,29 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>        &gt;&gt;&gt; list(G2.edges)
<span class="w"> </span>        [(0, 1)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        graph_class = self.to_undirected_class()</span>
<span class="gi">+        if as_view is True:</span>
<span class="gi">+            return nx.graphviews.generic_graph_view(self, graph_class)</span>
<span class="gi">+        # deepcopy when not a view</span>
<span class="gi">+        G = graph_class()</span>
<span class="gi">+        G.graph.update(deepcopy(self.graph))</span>
<span class="gi">+        G.add_nodes_from((n, deepcopy(d)) for n, d in self._node.items())</span>
<span class="gi">+        if reciprocal is True:</span>
<span class="gi">+            G.add_edges_from(</span>
<span class="gi">+                (u, v, key, deepcopy(data))</span>
<span class="gi">+                for u, nbrs in self._adj.items()</span>
<span class="gi">+                for v, keydict in nbrs.items()</span>
<span class="gi">+                for key, data in keydict.items()</span>
<span class="gi">+                if v in self._pred[u] and key in self._pred[u][v]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            G.add_edges_from(</span>
<span class="gi">+                (u, v, key, deepcopy(data))</span>
<span class="gi">+                for u, nbrs in self._adj.items()</span>
<span class="gi">+                for v, keydict in nbrs.items()</span>
<span class="gi">+                for key, data in keydict.items()</span>
<span class="gi">+            )</span>
<span class="gi">+        return G</span>

<span class="w"> </span>    def reverse(self, copy=True):
<span class="w"> </span>        &quot;&quot;&quot;Returns the reverse of the graph.
<span class="gu">@@ -866,4 +953,13 @@ class MultiDiGraph(MultiGraph, DiGraph):</span>
<span class="w"> </span>            If False, the reverse graph is created using a view of
<span class="w"> </span>            the original graph.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if copy:</span>
<span class="gi">+            H = self.__class__()</span>
<span class="gi">+            H.graph.update(deepcopy(self.graph))</span>
<span class="gi">+            H.add_nodes_from((n, deepcopy(d)) for n, d in self._node.items())</span>
<span class="gi">+            H.add_edges_from(</span>
<span class="gi">+                (v, u, k, deepcopy(d))</span>
<span class="gi">+                for u, v, k, d in self.edges(keys=True, data=True)</span>
<span class="gi">+            )</span>
<span class="gi">+            return H</span>
<span class="gi">+        return nx.reverse_view(self)</span>
<span class="gh">diff --git a/networkx/classes/multigraph.py b/networkx/classes/multigraph.py</span>
<span class="gh">index 5fe16870d..d1b263265 100644</span>
<span class="gd">--- a/networkx/classes/multigraph.py</span>
<span class="gi">+++ b/networkx/classes/multigraph.py</span>
<span class="gu">@@ -1,12 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Base class for MultiGraph.&quot;&quot;&quot;
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from functools import cached_property
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx import NetworkXError, convert
<span class="w"> </span>from networkx.classes.coreviews import MultiAdjacencyView
<span class="w"> </span>from networkx.classes.graph import Graph
<span class="w"> </span>from networkx.classes.reportviews import MultiDegreeView, MultiEdgeView
<span class="gd">-__all__ = [&#39;MultiGraph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;MultiGraph&quot;]</span>


<span class="w"> </span>class MultiGraph(Graph):
<span class="gu">@@ -281,7 +283,12 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>    &gt;&gt;&gt; G[2][1] is G[2][2]
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # node_dict_factory = dict    # already assigned in Graph</span>
<span class="gi">+    # adjlist_outer_dict_factory = dict</span>
<span class="gi">+    # adjlist_inner_dict_factory = dict</span>
<span class="w"> </span>    edge_key_dict_factory = dict
<span class="gi">+    # edge_attr_dict_factory = dict</span>

<span class="w"> </span>    def to_directed_class(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the class to use for empty directed copies.
<span class="gu">@@ -289,7 +296,7 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        If you subclass the base classes, use this to designate
<span class="w"> </span>        what directed class to use for `to_directed()` copies.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return nx.MultiDiGraph</span>

<span class="w"> </span>    def to_undirected_class(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the class to use for empty undirected copies.
<span class="gu">@@ -297,10 +304,9 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        If you subclass the base classes, use this to designate
<span class="w"> </span>        what directed class to use for `to_directed()` copies.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return MultiGraph</span>

<span class="gd">-    def __init__(self, incoming_graph_data=None, multigraph_input=None, **attr</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init__(self, incoming_graph_data=None, multigraph_input=None, **attr):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize a graph with edges, name, or graph attributes.

<span class="w"> </span>        Parameters
<span class="gu">@@ -346,19 +352,19 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        {&#39;day&#39;: &#39;Friday&#39;}

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        if isinstance(incoming_graph_data, dict</span>
<span class="gd">-            ) and multigraph_input is not False:</span>
<span class="gi">+        # multigraph_input can be None/True/False. So check &quot;is not False&quot;</span>
<span class="gi">+        if isinstance(incoming_graph_data, dict) and multigraph_input is not False:</span>
<span class="w"> </span>            Graph.__init__(self)
<span class="w"> </span>            try:
<span class="gd">-                convert.from_dict_of_dicts(incoming_graph_data,</span>
<span class="gd">-                    create_using=self, multigraph_input=True)</span>
<span class="gi">+                convert.from_dict_of_dicts(</span>
<span class="gi">+                    incoming_graph_data, create_using=self, multigraph_input=True</span>
<span class="gi">+                )</span>
<span class="w"> </span>                self.graph.update(attr)
<span class="w"> </span>            except Exception as err:
<span class="w"> </span>                if multigraph_input is True:
<span class="w"> </span>                    raise nx.NetworkXError(
<span class="gd">-                        f&quot;&quot;&quot;converting multigraph_input raised:</span>
<span class="gd">-{type(err)}: {err}&quot;&quot;&quot;</span>
<span class="gd">-                        )</span>
<span class="gi">+                        f&quot;converting multigraph_input raised:\n{type(err)}: {err}&quot;</span>
<span class="gi">+                    )</span>
<span class="w"> </span>                Graph.__init__(self, incoming_graph_data, **attr)
<span class="w"> </span>        else:
<span class="w"> </span>            Graph.__init__(self, incoming_graph_data, **attr)
<span class="gu">@@ -390,7 +396,7 @@ class MultiGraph(Graph):</span>

<span class="w"> </span>        For directed graphs, `G.adj` holds outgoing (successor) info.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return MultiAdjacencyView(self._adj)</span>

<span class="w"> </span>    def new_edge_key(self, u, v):
<span class="w"> </span>        &quot;&quot;&quot;Returns an unused key for edges between nodes `u` and `v`.
<span class="gu">@@ -412,7 +418,14 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        -------
<span class="w"> </span>        key : int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            keydict = self._adj[u][v]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        key = len(keydict)</span>
<span class="gi">+        while key in keydict:</span>
<span class="gi">+            key += 1</span>
<span class="gi">+        return key</span>

<span class="w"> </span>    def add_edge(self, u_for_edge, v_for_edge, key=None, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add an edge between u and v.
<span class="gu">@@ -480,7 +493,35 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; G[1][2][0].update({0: 5})
<span class="w"> </span>        &gt;&gt;&gt; G.edges[1, 2, 0].update({0: 5})
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        u, v = u_for_edge, v_for_edge</span>
<span class="gi">+        # add nodes</span>
<span class="gi">+        if u not in self._adj:</span>
<span class="gi">+            if u is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._adj[u] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._node[u] = self.node_attr_dict_factory()</span>
<span class="gi">+        if v not in self._adj:</span>
<span class="gi">+            if v is None:</span>
<span class="gi">+                raise ValueError(&quot;None cannot be a node&quot;)</span>
<span class="gi">+            self._adj[v] = self.adjlist_inner_dict_factory()</span>
<span class="gi">+            self._node[v] = self.node_attr_dict_factory()</span>
<span class="gi">+        if key is None:</span>
<span class="gi">+            key = self.new_edge_key(u, v)</span>
<span class="gi">+        if v in self._adj[u]:</span>
<span class="gi">+            keydict = self._adj[u][v]</span>
<span class="gi">+            datadict = keydict.get(key, self.edge_attr_dict_factory())</span>
<span class="gi">+            datadict.update(attr)</span>
<span class="gi">+            keydict[key] = datadict</span>
<span class="gi">+        else:</span>
<span class="gi">+            # selfloops work this way without special treatment</span>
<span class="gi">+            datadict = self.edge_attr_dict_factory()</span>
<span class="gi">+            datadict.update(attr)</span>
<span class="gi">+            keydict = self.edge_key_dict_factory()</span>
<span class="gi">+            keydict[key] = datadict</span>
<span class="gi">+            self._adj[u][v] = keydict</span>
<span class="gi">+            self._adj[v][u] = keydict</span>
<span class="gi">+        nx._clear_cache(self)</span>
<span class="gi">+        return key</span>

<span class="w"> </span>    def add_edges_from(self, ebunch_to_add, **attr):
<span class="w"> </span>        &quot;&quot;&quot;Add all the edges in ebunch_to_add.
<span class="gu">@@ -550,7 +591,34 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; # right way - note that there will be no self-edge for node 5
<span class="w"> </span>        &gt;&gt;&gt; assigned_keys = G.add_edges_from(list((5, n) for n in G.nodes))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        keylist = []</span>
<span class="gi">+        for e in ebunch_to_add:</span>
<span class="gi">+            ne = len(e)</span>
<span class="gi">+            if ne == 4:</span>
<span class="gi">+                u, v, key, dd = e</span>
<span class="gi">+            elif ne == 3:</span>
<span class="gi">+                u, v, dd = e</span>
<span class="gi">+                key = None</span>
<span class="gi">+            elif ne == 2:</span>
<span class="gi">+                u, v = e</span>
<span class="gi">+                dd = {}</span>
<span class="gi">+                key = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = f&quot;Edge tuple {e} must be a 2-tuple, 3-tuple or 4-tuple.&quot;</span>
<span class="gi">+                raise NetworkXError(msg)</span>
<span class="gi">+            ddd = {}</span>
<span class="gi">+            ddd.update(attr)</span>
<span class="gi">+            try:</span>
<span class="gi">+                ddd.update(dd)</span>
<span class="gi">+            except (TypeError, ValueError):</span>
<span class="gi">+                if ne != 3:</span>
<span class="gi">+                    raise</span>
<span class="gi">+                key = dd  # ne == 3 with 3rd value not dict, must be a key</span>
<span class="gi">+            key = self.add_edge(u, v, key)</span>
<span class="gi">+            self[u][v][key].update(ddd)</span>
<span class="gi">+            keylist.append(key)</span>
<span class="gi">+        nx._clear_cache(self)</span>
<span class="gi">+        return keylist</span>

<span class="w"> </span>    def remove_edge(self, u, v, key=None):
<span class="w"> </span>        &quot;&quot;&quot;Remove an edge between u and v.
<span class="gu">@@ -611,7 +679,25 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        MultiEdgeView([(1, 2, &#39;second&#39;)])

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            d = self._adj[u][v]</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;The edge {u}-{v} is not in the graph.&quot;) from err</span>
<span class="gi">+        # remove the edge with specified data</span>
<span class="gi">+        if key is None:</span>
<span class="gi">+            d.popitem()</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                del d[key]</span>
<span class="gi">+            except KeyError as err:</span>
<span class="gi">+                msg = f&quot;The edge {u}-{v} with key {key} is not in the graph.&quot;</span>
<span class="gi">+                raise NetworkXError(msg) from err</span>
<span class="gi">+        if len(d) == 0:</span>
<span class="gi">+            # remove the key entries if last edge</span>
<span class="gi">+            del self._adj[u][v]</span>
<span class="gi">+            if u != v:  # check for selfloop</span>
<span class="gi">+                del self._adj[v][u]</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def remove_edges_from(self, ebunch):
<span class="w"> </span>        &quot;&quot;&quot;Remove all edges specified in ebunch.
<span class="gu">@@ -665,7 +751,12 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        MultiEdgeView([(0, 1, &#39;x&#39;), (0, 1, &#39;y&#39;)])

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for e in ebunch:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.remove_edge(*e[:3])</span>
<span class="gi">+            except NetworkXError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        nx._clear_cache(self)</span>

<span class="w"> </span>    def has_edge(self, u, v, key=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if the graph has an edge between nodes u and v.
<span class="gu">@@ -719,7 +810,13 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        True

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            if key is None:</span>
<span class="gi">+                return v in self._adj[u]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return key in self._adj[u][v]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def edges(self):
<span class="gu">@@ -795,7 +892,7 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; G.edges(0)
<span class="w"> </span>        MultiEdgeDataView([(0, 1)])
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return MultiEdgeView(self)</span>

<span class="w"> </span>    def get_edge_data(self, u, v, key=None, default=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns the attribute dictionary associated with edge (u, v,
<span class="gu">@@ -866,7 +963,13 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; G.get_edge_data(1, 0, 0)  # specific key gives back
<span class="w"> </span>        {&#39;weight&#39;: 5}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            if key is None:</span>
<span class="gi">+                return self._adj[u][v]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self._adj[u][v][key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return default</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    def degree(self):
<span class="gu">@@ -906,15 +1009,15 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        [(0, 1), (1, 2)]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return MultiDegreeView(self)</span>

<span class="w"> </span>    def is_multigraph(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if graph is a multigraph, False otherwise.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def is_directed(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if graph is directed, False otherwise.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def copy(self, as_view=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns a copy of the graph.
<span class="gu">@@ -993,7 +1096,18 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; H = G.copy()

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if as_view is True:</span>
<span class="gi">+            return nx.graphviews.generic_graph_view(self)</span>
<span class="gi">+        G = self.__class__()</span>
<span class="gi">+        G.graph.update(self.graph)</span>
<span class="gi">+        G.add_nodes_from((n, d.copy()) for n, d in self._node.items())</span>
<span class="gi">+        G.add_edges_from(</span>
<span class="gi">+            (u, v, key, datadict.copy())</span>
<span class="gi">+            for u, nbrs in self._adj.items()</span>
<span class="gi">+            for v, keydict in nbrs.items()</span>
<span class="gi">+            for key, datadict in keydict.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        return G</span>

<span class="w"> </span>    def to_directed(self, as_view=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns a directed representation of the graph.
<span class="gu">@@ -1041,7 +1155,20 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; list(H.edges)
<span class="w"> </span>        [(0, 1, 0)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        graph_class = self.to_directed_class()</span>
<span class="gi">+        if as_view is True:</span>
<span class="gi">+            return nx.graphviews.generic_graph_view(self, graph_class)</span>
<span class="gi">+        # deepcopy when not a view</span>
<span class="gi">+        G = graph_class()</span>
<span class="gi">+        G.graph.update(deepcopy(self.graph))</span>
<span class="gi">+        G.add_nodes_from((n, deepcopy(d)) for n, d in self._node.items())</span>
<span class="gi">+        G.add_edges_from(</span>
<span class="gi">+            (u, v, key, deepcopy(datadict))</span>
<span class="gi">+            for u, nbrs in self.adj.items()</span>
<span class="gi">+            for v, keydict in nbrs.items()</span>
<span class="gi">+            for key, datadict in keydict.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        return G</span>

<span class="w"> </span>    def to_undirected(self, as_view=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns an undirected copy of the graph.
<span class="gu">@@ -1081,7 +1208,20 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>        &gt;&gt;&gt; list(G2.edges)
<span class="w"> </span>        [(0, 1, 0), (0, 1, 1), (1, 2, 0)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        graph_class = self.to_undirected_class()</span>
<span class="gi">+        if as_view is True:</span>
<span class="gi">+            return nx.graphviews.generic_graph_view(self, graph_class)</span>
<span class="gi">+        # deepcopy when not a view</span>
<span class="gi">+        G = graph_class()</span>
<span class="gi">+        G.graph.update(deepcopy(self.graph))</span>
<span class="gi">+        G.add_nodes_from((n, deepcopy(d)) for n, d in self._node.items())</span>
<span class="gi">+        G.add_edges_from(</span>
<span class="gi">+            (u, v, key, deepcopy(datadict))</span>
<span class="gi">+            for u, nbrs in self._adj.items()</span>
<span class="gi">+            for v, keydict in nbrs.items()</span>
<span class="gi">+            for key, datadict in keydict.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        return G</span>

<span class="w"> </span>    def number_of_edges(self, u=None, v=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of edges between two nodes.
<span class="gu">@@ -1133,4 +1273,10 @@ class MultiGraph(Graph):</span>
<span class="w"> </span>            1

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if u is None:</span>
<span class="gi">+            return self.size()</span>
<span class="gi">+        try:</span>
<span class="gi">+            edgedata = self._adj[u][v]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return 0  # no such edge</span>
<span class="gi">+        return len(edgedata)</span>
<span class="gh">diff --git a/networkx/classes/reportviews.py b/networkx/classes/reportviews.py</span>
<span class="gh">index 0ef60f043..5f9397f82 100644</span>
<span class="gd">--- a/networkx/classes/reportviews.py</span>
<span class="gi">+++ b/networkx/classes/reportviews.py</span>
<span class="gu">@@ -83,16 +83,36 @@ EdgeDataView</span>
<span class="w"> </span>    The argument `nbunch` restricts edges to those incident to nodes in nbunch.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections.abc import Mapping, Set
<span class="gd">-import networkx as nx</span>
<span class="gd">-__all__ = [&#39;NodeView&#39;, &#39;NodeDataView&#39;, &#39;EdgeView&#39;, &#39;OutEdgeView&#39;,</span>
<span class="gd">-    &#39;InEdgeView&#39;, &#39;EdgeDataView&#39;, &#39;OutEdgeDataView&#39;, &#39;InEdgeDataView&#39;,</span>
<span class="gd">-    &#39;MultiEdgeView&#39;, &#39;OutMultiEdgeView&#39;, &#39;InMultiEdgeView&#39;,</span>
<span class="gd">-    &#39;MultiEdgeDataView&#39;, &#39;OutMultiEdgeDataView&#39;, &#39;InMultiEdgeDataView&#39;,</span>
<span class="gd">-    &#39;DegreeView&#39;, &#39;DiDegreeView&#39;, &#39;InDegreeView&#39;, &#39;OutDegreeView&#39;,</span>
<span class="gd">-    &#39;MultiDegreeView&#39;, &#39;DiMultiDegreeView&#39;, &#39;InMultiDegreeView&#39;,</span>
<span class="gd">-    &#39;OutMultiDegreeView&#39;]</span>

<span class="gi">+import networkx as nx</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;NodeView&quot;,</span>
<span class="gi">+    &quot;NodeDataView&quot;,</span>
<span class="gi">+    &quot;EdgeView&quot;,</span>
<span class="gi">+    &quot;OutEdgeView&quot;,</span>
<span class="gi">+    &quot;InEdgeView&quot;,</span>
<span class="gi">+    &quot;EdgeDataView&quot;,</span>
<span class="gi">+    &quot;OutEdgeDataView&quot;,</span>
<span class="gi">+    &quot;InEdgeDataView&quot;,</span>
<span class="gi">+    &quot;MultiEdgeView&quot;,</span>
<span class="gi">+    &quot;OutMultiEdgeView&quot;,</span>
<span class="gi">+    &quot;InMultiEdgeView&quot;,</span>
<span class="gi">+    &quot;MultiEdgeDataView&quot;,</span>
<span class="gi">+    &quot;OutMultiEdgeDataView&quot;,</span>
<span class="gi">+    &quot;InMultiEdgeDataView&quot;,</span>
<span class="gi">+    &quot;DegreeView&quot;,</span>
<span class="gi">+    &quot;DiDegreeView&quot;,</span>
<span class="gi">+    &quot;InDegreeView&quot;,</span>
<span class="gi">+    &quot;OutDegreeView&quot;,</span>
<span class="gi">+    &quot;MultiDegreeView&quot;,</span>
<span class="gi">+    &quot;DiMultiDegreeView&quot;,</span>
<span class="gi">+    &quot;InMultiDegreeView&quot;,</span>
<span class="gi">+    &quot;OutMultiDegreeView&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# NodeViews</span>
<span class="w"> </span>class NodeView(Mapping, Set):
<span class="w"> </span>    &quot;&quot;&quot;A NodeView class to act as G.nodes for a NetworkX Graph

<span class="gu">@@ -146,17 +166,19 @@ class NodeView(Mapping, Set):</span>
<span class="w"> </span>    &gt;&gt;&gt; NVdata[2] == NV[2]  # NVdata gets &#39;color&#39;, NV gets datadict
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_nodes&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;_nodes&quot;,)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="gd">-        return {&#39;_nodes&#39;: self._nodes}</span>
<span class="gi">+        return {&quot;_nodes&quot;: self._nodes}</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="gd">-        self._nodes = state[&#39;_nodes&#39;]</span>
<span class="gi">+        self._nodes = state[&quot;_nodes&quot;]</span>

<span class="w"> </span>    def __init__(self, graph):
<span class="w"> </span>        self._nodes = graph._node

<span class="gi">+    # Mapping methods</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self._nodes)

<span class="gu">@@ -166,13 +188,20 @@ class NodeView(Mapping, Set):</span>
<span class="w"> </span>    def __getitem__(self, n):
<span class="w"> </span>        if isinstance(n, slice):
<span class="w"> </span>            raise nx.NetworkXError(
<span class="gd">-                f&#39;{type(self).__name__} does not support slicing, try list(G.nodes)[{n.start}:{n.stop}:{n.step}]&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;{type(self).__name__} does not support slicing, &quot;</span>
<span class="gi">+                f&quot;try list(G.nodes)[{n.start}:{n.stop}:{n.step}]&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        return self._nodes[n]

<span class="gi">+    # Set methods</span>
<span class="w"> </span>    def __contains__(self, n):
<span class="w"> </span>        return n in self._nodes

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _from_iterable(cls, it):</span>
<span class="gi">+        return set(it)</span>
<span class="gi">+</span>
<span class="gi">+    # DataView method</span>
<span class="w"> </span>    def __call__(self, data=False, default=None):
<span class="w"> </span>        if data is False:
<span class="w"> </span>            return self
<span class="gu">@@ -242,13 +271,15 @@ class NodeView(Mapping, Set):</span>
<span class="w"> </span>        &gt;&gt;&gt; G.nodes.data(&quot;height&quot;)
<span class="w"> </span>        NodeDataView({0: None, 1: None, 2: None}, data=&#39;height&#39;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if data is False:</span>
<span class="gi">+            return self</span>
<span class="gi">+        return NodeDataView(self._nodes, data, default)</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return str(list(self))

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;{self.__class__.__name__}({tuple(self)})&#39;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({tuple(self)})&quot;</span>


<span class="w"> </span>class NodeDataView(Set):
<span class="gu">@@ -268,22 +299,32 @@ class NodeDataView(Set):</span>
<span class="w"> </span>    data : bool or string (default=False)
<span class="w"> </span>    default : object (default=None)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_nodes&#39;, &#39;_data&#39;, &#39;_default&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;_nodes&quot;, &quot;_data&quot;, &quot;_default&quot;)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="gd">-        return {&#39;_nodes&#39;: self._nodes, &#39;_data&#39;: self._data, &#39;_default&#39;:</span>
<span class="gd">-            self._default}</span>
<span class="gi">+        return {&quot;_nodes&quot;: self._nodes, &quot;_data&quot;: self._data, &quot;_default&quot;: self._default}</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="gd">-        self._nodes = state[&#39;_nodes&#39;]</span>
<span class="gd">-        self._data = state[&#39;_data&#39;]</span>
<span class="gd">-        self._default = state[&#39;_default&#39;]</span>
<span class="gi">+        self._nodes = state[&quot;_nodes&quot;]</span>
<span class="gi">+        self._data = state[&quot;_data&quot;]</span>
<span class="gi">+        self._default = state[&quot;_default&quot;]</span>

<span class="w"> </span>    def __init__(self, nodedict, data=False, default=None):
<span class="w"> </span>        self._nodes = nodedict
<span class="w"> </span>        self._data = data
<span class="w"> </span>        self._default = default

<span class="gi">+    @classmethod</span>
<span class="gi">+    def _from_iterable(cls, it):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return set(it)</span>
<span class="gi">+        except TypeError as err:</span>
<span class="gi">+            if &quot;unhashable&quot; in str(err):</span>
<span class="gi">+                msg = &quot; : Could be b/c data=True or your values are unhashable&quot;</span>
<span class="gi">+                raise TypeError(str(err) + msg) from err</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self._nodes)

<span class="gu">@@ -293,8 +334,10 @@ class NodeDataView(Set):</span>
<span class="w"> </span>            return iter(self._nodes)
<span class="w"> </span>        if data is True:
<span class="w"> </span>            return iter(self._nodes.items())
<span class="gd">-        return ((n, dd[data] if data in dd else self._default) for n, dd in</span>
<span class="gd">-            self._nodes.items())</span>
<span class="gi">+        return (</span>
<span class="gi">+            (n, dd[data] if data in dd else self._default)</span>
<span class="gi">+            for n, dd in self._nodes.items()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __contains__(self, n):
<span class="w"> </span>        try:
<span class="gu">@@ -313,8 +356,9 @@ class NodeDataView(Set):</span>
<span class="w"> </span>    def __getitem__(self, n):
<span class="w"> </span>        if isinstance(n, slice):
<span class="w"> </span>            raise nx.NetworkXError(
<span class="gd">-                f&#39;{type(self).__name__} does not support slicing, try list(G.nodes.data())[{n.start}:{n.stop}:{n.step}]&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;{type(self).__name__} does not support slicing, &quot;</span>
<span class="gi">+                f&quot;try list(G.nodes.data())[{n.start}:{n.stop}:{n.step}]&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        ddict = self._nodes[n]
<span class="w"> </span>        data = self._data
<span class="w"> </span>        if data is False or data is True:
<span class="gu">@@ -327,12 +371,13 @@ class NodeDataView(Set):</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        name = self.__class__.__name__
<span class="w"> </span>        if self._data is False:
<span class="gd">-            return f&#39;{name}({tuple(self)})&#39;</span>
<span class="gi">+            return f&quot;{name}({tuple(self)})&quot;</span>
<span class="w"> </span>        if self._data is True:
<span class="gd">-            return f&#39;{name}({dict(self)})&#39;</span>
<span class="gd">-        return f&#39;{name}({dict(self)}, data={self._data!r})&#39;</span>
<span class="gi">+            return f&quot;{name}({dict(self)})&quot;</span>
<span class="gi">+        return f&quot;{name}({dict(self)}, data={self._data!r})&quot;</span>


<span class="gi">+# DegreeViews</span>
<span class="w"> </span>class DiDegreeView:
<span class="w"> </span>    &quot;&quot;&quot;A View class for degree of nodes in a NetworkX Graph

<span class="gu">@@ -373,10 +418,9 @@ class DiDegreeView:</span>

<span class="w"> </span>    def __init__(self, G, nbunch=None, weight=None):
<span class="w"> </span>        self._graph = G
<span class="gd">-        self._succ = G._succ if hasattr(G, &#39;_succ&#39;) else G._adj</span>
<span class="gd">-        self._pred = G._pred if hasattr(G, &#39;_pred&#39;) else G._adj</span>
<span class="gd">-        self._nodes = self._succ if nbunch is None else list(G.nbunch_iter(</span>
<span class="gd">-            nbunch))</span>
<span class="gi">+        self._succ = G._succ if hasattr(G, &quot;_succ&quot;) else G._adj</span>
<span class="gi">+        self._pred = G._pred if hasattr(G, &quot;_pred&quot;) else G._adj</span>
<span class="gi">+        self._nodes = self._succ if nbunch is None else list(G.nbunch_iter(nbunch))</span>
<span class="w"> </span>        self._weight = weight

<span class="w"> </span>    def __call__(self, nbunch=None, weight=None):
<span class="gu">@@ -399,8 +443,9 @@ class DiDegreeView:</span>
<span class="w"> </span>        preds = self._pred[n]
<span class="w"> </span>        if weight is None:
<span class="w"> </span>            return len(succs) + len(preds)
<span class="gd">-        return sum(dd.get(weight, 1) for dd in succs.values()) + sum(dd.get</span>
<span class="gd">-            (weight, 1) for dd in preds.values())</span>
<span class="gi">+        return sum(dd.get(weight, 1) for dd in succs.values()) + sum(</span>
<span class="gi">+            dd.get(weight, 1) for dd in preds.values()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        weight = self._weight
<span class="gu">@@ -408,14 +453,15 @@ class DiDegreeView:</span>
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                succs = self._succ[n]
<span class="w"> </span>                preds = self._pred[n]
<span class="gd">-                yield n, len(succs) + len(preds)</span>
<span class="gi">+                yield (n, len(succs) + len(preds))</span>
<span class="w"> </span>        else:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                succs = self._succ[n]
<span class="w"> </span>                preds = self._pred[n]
<span class="w"> </span>                deg = sum(dd.get(weight, 1) for dd in succs.values()) + sum(
<span class="gd">-                    dd.get(weight, 1) for dd in preds.values())</span>
<span class="gd">-                yield n, deg</span>
<span class="gi">+                    dd.get(weight, 1) for dd in preds.values()</span>
<span class="gi">+                )</span>
<span class="gi">+                yield (n, deg)</span>

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self._nodes)
<span class="gu">@@ -424,7 +470,7 @@ class DiDegreeView:</span>
<span class="w"> </span>        return str(list(self))

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;{self.__class__.__name__}({dict(self)})&#39;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({dict(self)})&quot;</span>


<span class="w"> </span>class DegreeView(DiDegreeView):
<span class="gu">@@ -476,21 +522,23 @@ class DegreeView(DiDegreeView):</span>
<span class="w"> </span>        nbrs = self._succ[n]
<span class="w"> </span>        if weight is None:
<span class="w"> </span>            return len(nbrs) + (n in nbrs)
<span class="gd">-        return sum(dd.get(weight, 1) for dd in nbrs.values()) + (n in nbrs and</span>
<span class="gd">-            nbrs[n].get(weight, 1))</span>
<span class="gi">+        return sum(dd.get(weight, 1) for dd in nbrs.values()) + (</span>
<span class="gi">+            n in nbrs and nbrs[n].get(weight, 1)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        weight = self._weight
<span class="w"> </span>        if weight is None:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                nbrs = self._succ[n]
<span class="gd">-                yield n, len(nbrs) + (n in nbrs)</span>
<span class="gi">+                yield (n, len(nbrs) + (n in nbrs))</span>
<span class="w"> </span>        else:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                nbrs = self._succ[n]
<span class="gd">-                deg = sum(dd.get(weight, 1) for dd in nbrs.values()) + (n in</span>
<span class="gd">-                    nbrs and nbrs[n].get(weight, 1))</span>
<span class="gd">-                yield n, deg</span>
<span class="gi">+                deg = sum(dd.get(weight, 1) for dd in nbrs.values()) + (</span>
<span class="gi">+                    n in nbrs and nbrs[n].get(weight, 1)</span>
<span class="gi">+                )</span>
<span class="gi">+                yield (n, deg)</span>


<span class="w"> </span>class OutDegreeView(DiDegreeView):
<span class="gu">@@ -508,12 +556,12 @@ class OutDegreeView(DiDegreeView):</span>
<span class="w"> </span>        if weight is None:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                succs = self._succ[n]
<span class="gd">-                yield n, len(succs)</span>
<span class="gi">+                yield (n, len(succs))</span>
<span class="w"> </span>        else:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                succs = self._succ[n]
<span class="w"> </span>                deg = sum(dd.get(weight, 1) for dd in succs.values())
<span class="gd">-                yield n, deg</span>
<span class="gi">+                yield (n, deg)</span>


<span class="w"> </span>class InDegreeView(DiDegreeView):
<span class="gu">@@ -531,12 +579,12 @@ class InDegreeView(DiDegreeView):</span>
<span class="w"> </span>        if weight is None:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                preds = self._pred[n]
<span class="gd">-                yield n, len(preds)</span>
<span class="gi">+                yield (n, len(preds))</span>
<span class="w"> </span>        else:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                preds = self._pred[n]
<span class="w"> </span>                deg = sum(dd.get(weight, 1) for dd in preds.values())
<span class="gd">-                yield n, deg</span>
<span class="gi">+                yield (n, deg)</span>


<span class="w"> </span>class MultiDegreeView(DiDegreeView):
<span class="gu">@@ -546,10 +594,13 @@ class MultiDegreeView(DiDegreeView):</span>
<span class="w"> </span>        weight = self._weight
<span class="w"> </span>        nbrs = self._succ[n]
<span class="w"> </span>        if weight is None:
<span class="gd">-            return sum(len(keys) for keys in nbrs.values()) + (n in nbrs and</span>
<span class="gd">-                len(nbrs[n]))</span>
<span class="gd">-        deg = sum(d.get(weight, 1) for key_dict in nbrs.values() for d in</span>
<span class="gd">-            key_dict.values())</span>
<span class="gi">+            return sum(len(keys) for keys in nbrs.values()) + (</span>
<span class="gi">+                n in nbrs and len(nbrs[n])</span>
<span class="gi">+            )</span>
<span class="gi">+        # edge weighted graph - degree is sum of nbr edge weights</span>
<span class="gi">+        deg = sum(</span>
<span class="gi">+            d.get(weight, 1) for key_dict in nbrs.values() for d in key_dict.values()</span>
<span class="gi">+        )</span>
<span class="w"> </span>        if n in nbrs:
<span class="w"> </span>            deg += sum(d.get(weight, 1) for d in nbrs[n].values())
<span class="w"> </span>        return deg
<span class="gu">@@ -559,17 +610,21 @@ class MultiDegreeView(DiDegreeView):</span>
<span class="w"> </span>        if weight is None:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                nbrs = self._succ[n]
<span class="gd">-                deg = sum(len(keys) for keys in nbrs.values()) + (n in nbrs and</span>
<span class="gd">-                    len(nbrs[n]))</span>
<span class="gd">-                yield n, deg</span>
<span class="gi">+                deg = sum(len(keys) for keys in nbrs.values()) + (</span>
<span class="gi">+                    n in nbrs and len(nbrs[n])</span>
<span class="gi">+                )</span>
<span class="gi">+                yield (n, deg)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                nbrs = self._succ[n]
<span class="gd">-                deg = sum(d.get(weight, 1) for key_dict in nbrs.values() for</span>
<span class="gd">-                    d in key_dict.values())</span>
<span class="gi">+                deg = sum(</span>
<span class="gi">+                    d.get(weight, 1)</span>
<span class="gi">+                    for key_dict in nbrs.values()</span>
<span class="gi">+                    for d in key_dict.values()</span>
<span class="gi">+                )</span>
<span class="w"> </span>                if n in nbrs:
<span class="w"> </span>                    deg += sum(d.get(weight, 1) for d in nbrs[n].values())
<span class="gd">-                yield n, deg</span>
<span class="gi">+                yield (n, deg)</span>


<span class="w"> </span>class DiMultiDegreeView(DiDegreeView):
<span class="gu">@@ -580,11 +635,15 @@ class DiMultiDegreeView(DiDegreeView):</span>
<span class="w"> </span>        succs = self._succ[n]
<span class="w"> </span>        preds = self._pred[n]
<span class="w"> </span>        if weight is None:
<span class="gd">-            return sum(len(keys) for keys in succs.values()) + sum(len(keys</span>
<span class="gd">-                ) for keys in preds.values())</span>
<span class="gd">-        deg = sum(d.get(weight, 1) for key_dict in succs.values() for d in</span>
<span class="gd">-            key_dict.values()) + sum(d.get(weight, 1) for key_dict in preds</span>
<span class="gd">-            .values() for d in key_dict.values())</span>
<span class="gi">+            return sum(len(keys) for keys in succs.values()) + sum(</span>
<span class="gi">+                len(keys) for keys in preds.values()</span>
<span class="gi">+            )</span>
<span class="gi">+        # edge weighted graph - degree is sum of nbr edge weights</span>
<span class="gi">+        deg = sum(</span>
<span class="gi">+            d.get(weight, 1) for key_dict in succs.values() for d in key_dict.values()</span>
<span class="gi">+        ) + sum(</span>
<span class="gi">+            d.get(weight, 1) for key_dict in preds.values() for d in key_dict.values()</span>
<span class="gi">+        )</span>
<span class="w"> </span>        return deg

<span class="w"> </span>    def __iter__(self):
<span class="gu">@@ -593,17 +652,24 @@ class DiMultiDegreeView(DiDegreeView):</span>
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                succs = self._succ[n]
<span class="w"> </span>                preds = self._pred[n]
<span class="gd">-                deg = sum(len(keys) for keys in succs.values()) + sum(len(</span>
<span class="gd">-                    keys) for keys in preds.values())</span>
<span class="gd">-                yield n, deg</span>
<span class="gi">+                deg = sum(len(keys) for keys in succs.values()) + sum(</span>
<span class="gi">+                    len(keys) for keys in preds.values()</span>
<span class="gi">+                )</span>
<span class="gi">+                yield (n, deg)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                succs = self._succ[n]
<span class="w"> </span>                preds = self._pred[n]
<span class="gd">-                deg = sum(d.get(weight, 1) for key_dict in succs.values() for</span>
<span class="gd">-                    d in key_dict.values()) + sum(d.get(weight, 1) for</span>
<span class="gd">-                    key_dict in preds.values() for d in key_dict.values())</span>
<span class="gd">-                yield n, deg</span>
<span class="gi">+                deg = sum(</span>
<span class="gi">+                    d.get(weight, 1)</span>
<span class="gi">+                    for key_dict in succs.values()</span>
<span class="gi">+                    for d in key_dict.values()</span>
<span class="gi">+                ) + sum(</span>
<span class="gi">+                    d.get(weight, 1)</span>
<span class="gi">+                    for key_dict in preds.values()</span>
<span class="gi">+                    for d in key_dict.values()</span>
<span class="gi">+                )</span>
<span class="gi">+                yield (n, deg)</span>


<span class="w"> </span>class InMultiDegreeView(DiDegreeView):
<span class="gu">@@ -614,8 +680,10 @@ class InMultiDegreeView(DiDegreeView):</span>
<span class="w"> </span>        nbrs = self._pred[n]
<span class="w"> </span>        if weight is None:
<span class="w"> </span>            return sum(len(data) for data in nbrs.values())
<span class="gd">-        return sum(d.get(weight, 1) for key_dict in nbrs.values() for d in</span>
<span class="gd">-            key_dict.values())</span>
<span class="gi">+        # edge weighted graph - degree is sum of nbr edge weights</span>
<span class="gi">+        return sum(</span>
<span class="gi">+            d.get(weight, 1) for key_dict in nbrs.values() for d in key_dict.values()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        weight = self._weight
<span class="gu">@@ -623,13 +691,16 @@ class InMultiDegreeView(DiDegreeView):</span>
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                nbrs = self._pred[n]
<span class="w"> </span>                deg = sum(len(data) for data in nbrs.values())
<span class="gd">-                yield n, deg</span>
<span class="gi">+                yield (n, deg)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                nbrs = self._pred[n]
<span class="gd">-                deg = sum(d.get(weight, 1) for key_dict in nbrs.values() for</span>
<span class="gd">-                    d in key_dict.values())</span>
<span class="gd">-                yield n, deg</span>
<span class="gi">+                deg = sum(</span>
<span class="gi">+                    d.get(weight, 1)</span>
<span class="gi">+                    for key_dict in nbrs.values()</span>
<span class="gi">+                    for d in key_dict.values()</span>
<span class="gi">+                )</span>
<span class="gi">+                yield (n, deg)</span>


<span class="w"> </span>class OutMultiDegreeView(DiDegreeView):
<span class="gu">@@ -640,8 +711,10 @@ class OutMultiDegreeView(DiDegreeView):</span>
<span class="w"> </span>        nbrs = self._succ[n]
<span class="w"> </span>        if weight is None:
<span class="w"> </span>            return sum(len(data) for data in nbrs.values())
<span class="gd">-        return sum(d.get(weight, 1) for key_dict in nbrs.values() for d in</span>
<span class="gd">-            key_dict.values())</span>
<span class="gi">+        # edge weighted graph - degree is sum of nbr edge weights</span>
<span class="gi">+        return sum(</span>
<span class="gi">+            d.get(weight, 1) for key_dict in nbrs.values() for d in key_dict.values()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        weight = self._weight
<span class="gu">@@ -649,23 +722,39 @@ class OutMultiDegreeView(DiDegreeView):</span>
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                nbrs = self._succ[n]
<span class="w"> </span>                deg = sum(len(data) for data in nbrs.values())
<span class="gd">-                yield n, deg</span>
<span class="gi">+                yield (n, deg)</span>
<span class="w"> </span>        else:
<span class="w"> </span>            for n in self._nodes:
<span class="w"> </span>                nbrs = self._succ[n]
<span class="gd">-                deg = sum(d.get(weight, 1) for key_dict in nbrs.values() for</span>
<span class="gd">-                    d in key_dict.values())</span>
<span class="gd">-                yield n, deg</span>
<span class="gi">+                deg = sum(</span>
<span class="gi">+                    d.get(weight, 1)</span>
<span class="gi">+                    for key_dict in nbrs.values()</span>
<span class="gi">+                    for d in key_dict.values()</span>
<span class="gi">+                )</span>
<span class="gi">+                yield (n, deg)</span>


<span class="gi">+# EdgeDataViews</span>
<span class="w"> </span>class OutEdgeDataView:
<span class="w"> </span>    &quot;&quot;&quot;EdgeDataView for outward edges of DiGraph; See EdgeDataView&quot;&quot;&quot;
<span class="gd">-    __slots__ = (&#39;_viewer&#39;, &#39;_nbunch&#39;, &#39;_data&#39;, &#39;_default&#39;, &#39;_adjdict&#39;,</span>
<span class="gd">-        &#39;_nodes_nbrs&#39;, &#39;_report&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &quot;_viewer&quot;,</span>
<span class="gi">+        &quot;_nbunch&quot;,</span>
<span class="gi">+        &quot;_data&quot;,</span>
<span class="gi">+        &quot;_default&quot;,</span>
<span class="gi">+        &quot;_adjdict&quot;,</span>
<span class="gi">+        &quot;_nodes_nbrs&quot;,</span>
<span class="gi">+        &quot;_report&quot;,</span>
<span class="gi">+    )</span>

<span class="w"> </span>    def __getstate__(self):
<span class="gd">-        return {&#39;viewer&#39;: self._viewer, &#39;nbunch&#39;: self._nbunch, &#39;data&#39;:</span>
<span class="gd">-            self._data, &#39;default&#39;: self._default}</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;viewer&quot;: self._viewer,</span>
<span class="gi">+            &quot;nbunch&quot;: self._nbunch,</span>
<span class="gi">+            &quot;data&quot;: self._data,</span>
<span class="gi">+            &quot;default&quot;: self._default,</span>
<span class="gi">+        }</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="w"> </span>        self.__init__(**state)
<span class="gu">@@ -676,30 +765,38 @@ class OutEdgeDataView:</span>
<span class="w"> </span>        if nbunch is None:
<span class="w"> </span>            self._nodes_nbrs = adjdict.items
<span class="w"> </span>        else:
<span class="gi">+            # dict retains order of nodes but acts like a set</span>
<span class="w"> </span>            nbunch = dict.fromkeys(viewer._graph.nbunch_iter(nbunch))
<span class="gd">-            self._nodes_nbrs = lambda : [(n, adjdict[n]) for n in nbunch]</span>
<span class="gi">+            self._nodes_nbrs = lambda: [(n, adjdict[n]) for n in nbunch]</span>
<span class="w"> </span>        self._nbunch = nbunch
<span class="w"> </span>        self._data = data
<span class="w"> </span>        self._default = default
<span class="gi">+        # Set _report based on data and default</span>
<span class="w"> </span>        if data is True:
<span class="w"> </span>            self._report = lambda n, nbr, dd: (n, nbr, dd)
<span class="w"> </span>        elif data is False:
<span class="w"> </span>            self._report = lambda n, nbr, dd: (n, nbr)
<span class="gd">-        else:</span>
<span class="gd">-            self._report = lambda n, nbr, dd: (n, nbr, dd[data]</span>
<span class="gd">-                ) if data in dd else (n, nbr, default)</span>
<span class="gi">+        else:  # data is attribute name</span>
<span class="gi">+            self._report = (</span>
<span class="gi">+                lambda n, nbr, dd: (n, nbr, dd[data])</span>
<span class="gi">+                if data in dd</span>
<span class="gi">+                else (n, nbr, default)</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return sum(len(nbrs) for n, nbrs in self._nodes_nbrs())

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        return (self._report(n, nbr, dd) for n, nbrs in self._nodes_nbrs() for</span>
<span class="gd">-            nbr, dd in nbrs.items())</span>
<span class="gi">+        return (</span>
<span class="gi">+            self._report(n, nbr, dd)</span>
<span class="gi">+            for n, nbrs in self._nodes_nbrs()</span>
<span class="gi">+            for nbr, dd in nbrs.items()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        u, v = e[:2]
<span class="w"> </span>        if self._nbunch is not None and u not in self._nbunch:
<span class="gd">-            return False</span>
<span class="gi">+            return False  # this edge doesn&#39;t start in nbunch</span>
<span class="w"> </span>        try:
<span class="w"> </span>            ddict = self._adjdict[u][v]
<span class="w"> </span>        except KeyError:
<span class="gu">@@ -710,7 +807,7 @@ class OutEdgeDataView:</span>
<span class="w"> </span>        return str(list(self))

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;{self.__class__.__name__}({list(self)})&#39;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({list(self)})&quot;</span>


<span class="w"> </span>class EdgeDataView(OutEdgeDataView):
<span class="gu">@@ -741,6 +838,7 @@ class EdgeDataView(OutEdgeDataView):</span>
<span class="w"> </span>    [(0, 1, &#39;biz&#39;), (1, 2, &#39;bar&#39;)]
<span class="w"> </span>    &gt;&gt;&gt; assert (0, 1, &quot;biz&quot;) in G.edges(data=&quot;foo&quot;, default=&quot;biz&quot;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    def __len__(self):
<span class="gu">@@ -757,9 +855,8 @@ class EdgeDataView(OutEdgeDataView):</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        u, v = e[:2]
<span class="gd">-        if (self._nbunch is not None and u not in self._nbunch and v not in</span>
<span class="gd">-            self._nbunch):</span>
<span class="gd">-            return False</span>
<span class="gi">+        if self._nbunch is not None and u not in self._nbunch and v not in self._nbunch:</span>
<span class="gi">+            return False  # this edge doesn&#39;t start and it doesn&#39;t end in nbunch</span>
<span class="w"> </span>        try:
<span class="w"> </span>            ddict = self._adjdict[u][v]
<span class="w"> </span>        except KeyError:
<span class="gu">@@ -769,16 +866,20 @@ class EdgeDataView(OutEdgeDataView):</span>

<span class="w"> </span>class InEdgeDataView(OutEdgeDataView):
<span class="w"> </span>    &quot;&quot;&quot;An EdgeDataView class for outward edges of DiGraph; See EdgeDataView&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        return (self._report(nbr, n, dd) for n, nbrs in self._nodes_nbrs() for</span>
<span class="gd">-            nbr, dd in nbrs.items())</span>
<span class="gi">+        return (</span>
<span class="gi">+            self._report(nbr, n, dd)</span>
<span class="gi">+            for n, nbrs in self._nodes_nbrs()</span>
<span class="gi">+            for nbr, dd in nbrs.items()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        u, v = e[:2]
<span class="w"> </span>        if self._nbunch is not None and v not in self._nbunch:
<span class="gd">-            return False</span>
<span class="gi">+            return False  # this edge doesn&#39;t end in nbunch</span>
<span class="w"> </span>        try:
<span class="w"> </span>            ddict = self._adjdict[v][u]
<span class="w"> </span>        except KeyError:
<span class="gu">@@ -788,28 +889,35 @@ class InEdgeDataView(OutEdgeDataView):</span>

<span class="w"> </span>class OutMultiEdgeDataView(OutEdgeDataView):
<span class="w"> </span>    &quot;&quot;&quot;An EdgeDataView for outward edges of MultiDiGraph; See EdgeDataView&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;keys&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;keys&quot;,)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="gd">-        return {&#39;viewer&#39;: self._viewer, &#39;nbunch&#39;: self._nbunch, &#39;keys&#39;:</span>
<span class="gd">-            self.keys, &#39;data&#39;: self._data, &#39;default&#39;: self._default}</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;viewer&quot;: self._viewer,</span>
<span class="gi">+            &quot;nbunch&quot;: self._nbunch,</span>
<span class="gi">+            &quot;keys&quot;: self.keys,</span>
<span class="gi">+            &quot;data&quot;: self._data,</span>
<span class="gi">+            &quot;default&quot;: self._default,</span>
<span class="gi">+        }</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="w"> </span>        self.__init__(**state)

<span class="gd">-    def __init__(self, viewer, nbunch=None, data=False, *, default=None,</span>
<span class="gd">-        keys=False):</span>
<span class="gi">+    def __init__(self, viewer, nbunch=None, data=False, *, default=None, keys=False):</span>
<span class="w"> </span>        self._viewer = viewer
<span class="w"> </span>        adjdict = self._adjdict = viewer._adjdict
<span class="w"> </span>        self.keys = keys
<span class="w"> </span>        if nbunch is None:
<span class="w"> </span>            self._nodes_nbrs = adjdict.items
<span class="w"> </span>        else:
<span class="gi">+            # dict retains order of nodes but acts like a set</span>
<span class="w"> </span>            nbunch = dict.fromkeys(viewer._graph.nbunch_iter(nbunch))
<span class="gd">-            self._nodes_nbrs = lambda : [(n, adjdict[n]) for n in nbunch]</span>
<span class="gi">+            self._nodes_nbrs = lambda: [(n, adjdict[n]) for n in nbunch]</span>
<span class="w"> </span>        self._nbunch = nbunch
<span class="w"> </span>        self._data = data
<span class="w"> </span>        self._default = default
<span class="gi">+        # Set _report based on data and default</span>
<span class="w"> </span>        if data is True:
<span class="w"> </span>            if keys is True:
<span class="w"> </span>                self._report = lambda n, nbr, k, dd: (n, nbr, k, dd)
<span class="gu">@@ -820,24 +928,35 @@ class OutMultiEdgeDataView(OutEdgeDataView):</span>
<span class="w"> </span>                self._report = lambda n, nbr, k, dd: (n, nbr, k)
<span class="w"> </span>            else:
<span class="w"> </span>                self._report = lambda n, nbr, k, dd: (n, nbr)
<span class="gd">-        elif keys is True:</span>
<span class="gd">-            self._report = lambda n, nbr, k, dd: (n, nbr, k, dd[data]</span>
<span class="gd">-                ) if data in dd else (n, nbr, k, default)</span>
<span class="gd">-        else:</span>
<span class="gd">-            self._report = lambda n, nbr, k, dd: (n, nbr, dd[data]</span>
<span class="gd">-                ) if data in dd else (n, nbr, default)</span>
<span class="gi">+        else:  # data is attribute name</span>
<span class="gi">+            if keys is True:</span>
<span class="gi">+                self._report = (</span>
<span class="gi">+                    lambda n, nbr, k, dd: (n, nbr, k, dd[data])</span>
<span class="gi">+                    if data in dd</span>
<span class="gi">+                    else (n, nbr, k, default)</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._report = (</span>
<span class="gi">+                    lambda n, nbr, k, dd: (n, nbr, dd[data])</span>
<span class="gi">+                    if data in dd</span>
<span class="gi">+                    else (n, nbr, default)</span>
<span class="gi">+                )</span>

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return sum(1 for e in self)

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        return (self._report(n, nbr, k, dd) for n, nbrs in self._nodes_nbrs</span>
<span class="gd">-            () for nbr, kd in nbrs.items() for k, dd in kd.items())</span>
<span class="gi">+        return (</span>
<span class="gi">+            self._report(n, nbr, k, dd)</span>
<span class="gi">+            for n, nbrs in self._nodes_nbrs()</span>
<span class="gi">+            for nbr, kd in nbrs.items()</span>
<span class="gi">+            for k, dd in kd.items()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        u, v = e[:2]
<span class="w"> </span>        if self._nbunch is not None and u not in self._nbunch:
<span class="gd">-            return False</span>
<span class="gi">+            return False  # this edge doesn&#39;t start in nbunch</span>
<span class="w"> </span>        try:
<span class="w"> </span>            kdict = self._adjdict[u][v]
<span class="w"> </span>        except KeyError:
<span class="gu">@@ -854,6 +973,7 @@ class OutMultiEdgeDataView(OutEdgeDataView):</span>

<span class="w"> </span>class MultiEdgeDataView(OutMultiEdgeDataView):
<span class="w"> </span>    &quot;&quot;&quot;An EdgeDataView class for edges of MultiGraph; See EdgeDataView&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    def __iter__(self):
<span class="gu">@@ -868,9 +988,8 @@ class MultiEdgeDataView(OutMultiEdgeDataView):</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        u, v = e[:2]
<span class="gd">-        if (self._nbunch is not None and u not in self._nbunch and v not in</span>
<span class="gd">-            self._nbunch):</span>
<span class="gd">-            return False</span>
<span class="gi">+        if self._nbunch is not None and u not in self._nbunch and v not in self._nbunch:</span>
<span class="gi">+            return False  # this edge doesn&#39;t start and doesn&#39;t end in nbunch</span>
<span class="w"> </span>        try:
<span class="w"> </span>            kdict = self._adjdict[u][v]
<span class="w"> </span>        except KeyError:
<span class="gu">@@ -890,16 +1009,21 @@ class MultiEdgeDataView(OutMultiEdgeDataView):</span>

<span class="w"> </span>class InMultiEdgeDataView(OutMultiEdgeDataView):
<span class="w"> </span>    &quot;&quot;&quot;An EdgeDataView for inward edges of MultiDiGraph; See EdgeDataView&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        return (self._report(nbr, n, k, dd) for n, nbrs in self._nodes_nbrs</span>
<span class="gd">-            () for nbr, kd in nbrs.items() for k, dd in kd.items())</span>
<span class="gi">+        return (</span>
<span class="gi">+            self._report(nbr, n, k, dd)</span>
<span class="gi">+            for n, nbrs in self._nodes_nbrs()</span>
<span class="gi">+            for nbr, kd in nbrs.items()</span>
<span class="gi">+            for k, dd in kd.items()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        u, v = e[:2]
<span class="w"> </span>        if self._nbunch is not None and v not in self._nbunch:
<span class="gd">-            return False</span>
<span class="gi">+            return False  # this edge doesn&#39;t end in nbunch</span>
<span class="w"> </span>        try:
<span class="w"> </span>            kdict = self._adjdict[v][u]
<span class="w"> </span>        except KeyError:
<span class="gu">@@ -911,31 +1035,39 @@ class InMultiEdgeDataView(OutMultiEdgeDataView):</span>
<span class="w"> </span>        return any(e == self._report(u, v, k, dd) for k, dd in kdict.items())


<span class="gi">+# EdgeViews    have set operations and no data reported</span>
<span class="w"> </span>class OutEdgeView(Set, Mapping):
<span class="w"> </span>    &quot;&quot;&quot;A EdgeView class for outward edges of a DiGraph&quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_adjdict&#39;, &#39;_graph&#39;, &#39;_nodes_nbrs&#39;</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = (&quot;_adjdict&quot;, &quot;_graph&quot;, &quot;_nodes_nbrs&quot;)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="gd">-        return {&#39;_graph&#39;: self._graph, &#39;_adjdict&#39;: self._adjdict}</span>
<span class="gi">+        return {&quot;_graph&quot;: self._graph, &quot;_adjdict&quot;: self._adjdict}</span>

<span class="w"> </span>    def __setstate__(self, state):
<span class="gd">-        self._graph = state[&#39;_graph&#39;]</span>
<span class="gd">-        self._adjdict = state[&#39;_adjdict&#39;]</span>
<span class="gi">+        self._graph = state[&quot;_graph&quot;]</span>
<span class="gi">+        self._adjdict = state[&quot;_adjdict&quot;]</span>
<span class="w"> </span>        self._nodes_nbrs = self._adjdict.items
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _from_iterable(cls, it):</span>
<span class="gi">+        return set(it)</span>
<span class="gi">+</span>
<span class="w"> </span>    dataview = OutEdgeDataView

<span class="w"> </span>    def __init__(self, G):
<span class="w"> </span>        self._graph = G
<span class="gd">-        self._adjdict = G._succ if hasattr(G, &#39;succ&#39;) else G._adj</span>
<span class="gi">+        self._adjdict = G._succ if hasattr(G, &quot;succ&quot;) else G._adj</span>
<span class="w"> </span>        self._nodes_nbrs = self._adjdict.items

<span class="gi">+    # Set methods</span>
<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return sum(len(nbrs) for n, nbrs in self._nodes_nbrs())

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        for n, nbrs in self._nodes_nbrs():
<span class="w"> </span>            for nbr in nbrs:
<span class="gd">-                yield n, nbr</span>
<span class="gi">+                yield (n, nbr)</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        try:
<span class="gu">@@ -944,17 +1076,20 @@ class OutEdgeView(Set, Mapping):</span>
<span class="w"> </span>        except KeyError:
<span class="w"> </span>            return False

<span class="gi">+    # Mapping Methods</span>
<span class="w"> </span>    def __getitem__(self, e):
<span class="w"> </span>        if isinstance(e, slice):
<span class="w"> </span>            raise nx.NetworkXError(
<span class="gd">-                f&#39;{type(self).__name__} does not support slicing, try list(G.edges)[{e.start}:{e.stop}:{e.step}]&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;{type(self).__name__} does not support slicing, &quot;</span>
<span class="gi">+                f&quot;try list(G.edges)[{e.start}:{e.stop}:{e.step}]&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        u, v = e
<span class="w"> </span>        try:
<span class="w"> </span>            return self._adjdict[u][v]
<span class="gd">-        except KeyError as ex:</span>
<span class="gd">-            raise KeyError(f&#39;The edge {e} is not in the graph.&#39;)</span>
<span class="gi">+        except KeyError as ex:  # Customize msg to indicate exception origin</span>
<span class="gi">+            raise KeyError(f&quot;The edge {e} is not in the graph.&quot;)</span>

<span class="gi">+    # EdgeDataView methods</span>
<span class="w"> </span>    def __call__(self, nbunch=None, data=False, *, default=None):
<span class="w"> </span>        if nbunch is None and data is False:
<span class="w"> </span>            return self
<span class="gu">@@ -1036,13 +1171,16 @@ class OutEdgeView(Set, Mapping):</span>
<span class="w"> </span>        &gt;&gt;&gt; G.edges.data(&quot;speed&quot;)
<span class="w"> </span>        EdgeDataView([(0, 1, None), (0, 2, None), (1, 2, None)])
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if nbunch is None and data is False:</span>
<span class="gi">+            return self</span>
<span class="gi">+        return self.dataview(self, nbunch, data, default=default)</span>

<span class="gi">+    # String Methods</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return str(list(self))

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;{self.__class__.__name__}({list(self)})&#39;</span>
<span class="gi">+        return f&quot;{self.__class__.__name__}({list(self)})&quot;</span>


<span class="w"> </span>class EdgeView(OutEdgeView):
<span class="gu">@@ -1115,7 +1253,9 @@ class EdgeView(OutEdgeView):</span>
<span class="w"> </span>    (2, 3, 0)
<span class="w"> </span>    (2, 3, 1)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()
<span class="gi">+</span>
<span class="w"> </span>    dataview = EdgeDataView

<span class="w"> </span>    def __len__(self):
<span class="gu">@@ -1127,7 +1267,7 @@ class EdgeView(OutEdgeView):</span>
<span class="w"> </span>        for n, nbrs in self._nodes_nbrs():
<span class="w"> </span>            for nbr in list(nbrs):
<span class="w"> </span>                if nbr not in seen:
<span class="gd">-                    yield n, nbr</span>
<span class="gi">+                    yield (n, nbr)</span>
<span class="w"> </span>            seen[n] = 1
<span class="w"> </span>        del seen

<span class="gu">@@ -1141,23 +1281,25 @@ class EdgeView(OutEdgeView):</span>

<span class="w"> </span>class InEdgeView(OutEdgeView):
<span class="w"> </span>    &quot;&quot;&quot;A EdgeView class for inward edges of a DiGraph&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    def __setstate__(self, state):
<span class="gd">-        self._graph = state[&#39;_graph&#39;]</span>
<span class="gd">-        self._adjdict = state[&#39;_adjdict&#39;]</span>
<span class="gi">+        self._graph = state[&quot;_graph&quot;]</span>
<span class="gi">+        self._adjdict = state[&quot;_adjdict&quot;]</span>
<span class="w"> </span>        self._nodes_nbrs = self._adjdict.items
<span class="gi">+</span>
<span class="w"> </span>    dataview = InEdgeDataView

<span class="w"> </span>    def __init__(self, G):
<span class="w"> </span>        self._graph = G
<span class="gd">-        self._adjdict = G._pred if hasattr(G, &#39;pred&#39;) else G._adj</span>
<span class="gi">+        self._adjdict = G._pred if hasattr(G, &quot;pred&quot;) else G._adj</span>
<span class="w"> </span>        self._nodes_nbrs = self._adjdict.items

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        for n, nbrs in self._nodes_nbrs():
<span class="w"> </span>            for nbr in nbrs:
<span class="gd">-                yield nbr, n</span>
<span class="gi">+                yield (nbr, n)</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        try:
<span class="gu">@@ -1169,26 +1311,30 @@ class InEdgeView(OutEdgeView):</span>
<span class="w"> </span>    def __getitem__(self, e):
<span class="w"> </span>        if isinstance(e, slice):
<span class="w"> </span>            raise nx.NetworkXError(
<span class="gd">-                f&#39;{type(self).__name__} does not support slicing, try list(G.in_edges)[{e.start}:{e.stop}:{e.step}]&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;{type(self).__name__} does not support slicing, &quot;</span>
<span class="gi">+                f&quot;try list(G.in_edges)[{e.start}:{e.stop}:{e.step}]&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        u, v = e
<span class="w"> </span>        return self._adjdict[v][u]


<span class="w"> </span>class OutMultiEdgeView(OutEdgeView):
<span class="w"> </span>    &quot;&quot;&quot;A EdgeView class for outward edges of a MultiDiGraph&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()
<span class="gi">+</span>
<span class="w"> </span>    dataview = OutMultiEdgeDataView

<span class="w"> </span>    def __len__(self):
<span class="gd">-        return sum(len(kdict) for n, nbrs in self._nodes_nbrs() for nbr,</span>
<span class="gd">-            kdict in nbrs.items())</span>
<span class="gi">+        return sum(</span>
<span class="gi">+            len(kdict) for n, nbrs in self._nodes_nbrs() for nbr, kdict in nbrs.items()</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        for n, nbrs in self._nodes_nbrs():
<span class="w"> </span>            for nbr, kdict in nbrs.items():
<span class="w"> </span>                for key in kdict:
<span class="gd">-                    yield n, nbr, key</span>
<span class="gi">+                    yield (n, nbr, key)</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        N = len(e)
<span class="gu">@@ -1198,7 +1344,7 @@ class OutMultiEdgeView(OutEdgeView):</span>
<span class="w"> </span>            u, v = e
<span class="w"> </span>            k = 0
<span class="w"> </span>        else:
<span class="gd">-            raise ValueError(&#39;MultiEdge must have length 2 or 3&#39;)</span>
<span class="gi">+            raise ValueError(&quot;MultiEdge must have length 2 or 3&quot;)</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return k in self._adjdict[u][v]
<span class="w"> </span>        except KeyError:
<span class="gu">@@ -1207,8 +1353,9 @@ class OutMultiEdgeView(OutEdgeView):</span>
<span class="w"> </span>    def __getitem__(self, e):
<span class="w"> </span>        if isinstance(e, slice):
<span class="w"> </span>            raise nx.NetworkXError(
<span class="gd">-                f&#39;{type(self).__name__} does not support slicing, try list(G.edges)[{e.start}:{e.stop}:{e.step}]&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;{type(self).__name__} does not support slicing, &quot;</span>
<span class="gi">+                f&quot;try list(G.edges)[{e.start}:{e.stop}:{e.step}]&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        u, v, k = e
<span class="w"> </span>        return self._adjdict[u][v][k]

<span class="gu">@@ -1217,10 +1364,17 @@ class OutMultiEdgeView(OutEdgeView):</span>
<span class="w"> </span>            return self
<span class="w"> </span>        return self.dataview(self, nbunch, data, default=default, keys=keys)

<span class="gi">+    def data(self, data=True, default=None, nbunch=None, keys=False):</span>
<span class="gi">+        if nbunch is None and data is False and keys is True:</span>
<span class="gi">+            return self</span>
<span class="gi">+        return self.dataview(self, nbunch, data, default=default, keys=keys)</span>
<span class="gi">+</span>

<span class="w"> </span>class MultiEdgeView(OutMultiEdgeView):
<span class="w"> </span>    &quot;&quot;&quot;A EdgeView class for edges of a MultiGraph&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()
<span class="gi">+</span>
<span class="w"> </span>    dataview = MultiEdgeDataView

<span class="w"> </span>    def __len__(self):
<span class="gu">@@ -1232,31 +1386,33 @@ class MultiEdgeView(OutMultiEdgeView):</span>
<span class="w"> </span>            for nbr, kd in nbrs.items():
<span class="w"> </span>                if nbr not in seen:
<span class="w"> </span>                    for k, dd in kd.items():
<span class="gd">-                        yield n, nbr, k</span>
<span class="gi">+                        yield (n, nbr, k)</span>
<span class="w"> </span>            seen[n] = 1
<span class="w"> </span>        del seen


<span class="w"> </span>class InMultiEdgeView(OutMultiEdgeView):
<span class="w"> </span>    &quot;&quot;&quot;A EdgeView class for inward edges of a MultiDiGraph&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    def __setstate__(self, state):
<span class="gd">-        self._graph = state[&#39;_graph&#39;]</span>
<span class="gd">-        self._adjdict = state[&#39;_adjdict&#39;]</span>
<span class="gi">+        self._graph = state[&quot;_graph&quot;]</span>
<span class="gi">+        self._adjdict = state[&quot;_adjdict&quot;]</span>
<span class="w"> </span>        self._nodes_nbrs = self._adjdict.items
<span class="gi">+</span>
<span class="w"> </span>    dataview = InMultiEdgeDataView

<span class="w"> </span>    def __init__(self, G):
<span class="w"> </span>        self._graph = G
<span class="gd">-        self._adjdict = G._pred if hasattr(G, &#39;pred&#39;) else G._adj</span>
<span class="gi">+        self._adjdict = G._pred if hasattr(G, &quot;pred&quot;) else G._adj</span>
<span class="w"> </span>        self._nodes_nbrs = self._adjdict.items

<span class="w"> </span>    def __iter__(self):
<span class="w"> </span>        for n, nbrs in self._nodes_nbrs():
<span class="w"> </span>            for nbr, kdict in nbrs.items():
<span class="w"> </span>                for key in kdict:
<span class="gd">-                    yield nbr, n, key</span>
<span class="gi">+                    yield (nbr, n, key)</span>

<span class="w"> </span>    def __contains__(self, e):
<span class="w"> </span>        N = len(e)
<span class="gu">@@ -1266,7 +1422,7 @@ class InMultiEdgeView(OutMultiEdgeView):</span>
<span class="w"> </span>            u, v = e
<span class="w"> </span>            k = 0
<span class="w"> </span>        else:
<span class="gd">-            raise ValueError(&#39;MultiEdge must have length 2 or 3&#39;)</span>
<span class="gi">+            raise ValueError(&quot;MultiEdge must have length 2 or 3&quot;)</span>
<span class="w"> </span>        try:
<span class="w"> </span>            return k in self._adjdict[v][u]
<span class="w"> </span>        except KeyError:
<span class="gu">@@ -1275,7 +1431,8 @@ class InMultiEdgeView(OutMultiEdgeView):</span>
<span class="w"> </span>    def __getitem__(self, e):
<span class="w"> </span>        if isinstance(e, slice):
<span class="w"> </span>            raise nx.NetworkXError(
<span class="gd">-                f&#39;{type(self).__name__} does not support slicing, try list(G.in_edges)[{e.start}:{e.stop}:{e.step}]&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;{type(self).__name__} does not support slicing, &quot;</span>
<span class="gi">+                f&quot;try list(G.in_edges)[{e.start}:{e.stop}:{e.step}]&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>        u, v, k = e
<span class="w"> </span>        return self._adjdict[v][u][k]
<span class="gh">diff --git a/networkx/convert.py b/networkx/convert.py</span>
<span class="gh">index 9d6a1aa8a..7cc8fe401 100644</span>
<span class="gd">--- a/networkx/convert.py</span>
<span class="gi">+++ b/networkx/convert.py</span>
<span class="gu">@@ -17,9 +17,18 @@ nx_agraph, nx_pydot</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import warnings
<span class="w"> </span>from collections.abc import Collection, Generator, Iterator
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;to_networkx_graph&#39;, &#39;from_dict_of_dicts&#39;, &#39;to_dict_of_dicts&#39;,</span>
<span class="gd">-    &#39;from_dict_of_lists&#39;, &#39;to_dict_of_lists&#39;, &#39;from_edgelist&#39;, &#39;to_edgelist&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;to_networkx_graph&quot;,</span>
<span class="gi">+    &quot;from_dict_of_dicts&quot;,</span>
<span class="gi">+    &quot;to_dict_of_dicts&quot;,</span>
<span class="gi">+    &quot;from_dict_of_lists&quot;,</span>
<span class="gi">+    &quot;to_dict_of_lists&quot;,</span>
<span class="gi">+    &quot;from_edgelist&quot;,</span>
<span class="gi">+    &quot;to_edgelist&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def to_networkx_graph(data, create_using=None, multigraph_input=False):
<span class="gu">@@ -61,7 +70,110 @@ def to_networkx_graph(data, create_using=None, multigraph_input=False):</span>
<span class="w"> </span>        a multigraph from a multigraph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # NX graph</span>
<span class="gi">+    if hasattr(data, &quot;adj&quot;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = from_dict_of_dicts(</span>
<span class="gi">+                data.adj,</span>
<span class="gi">+                create_using=create_using,</span>
<span class="gi">+                multigraph_input=data.is_multigraph(),</span>
<span class="gi">+            )</span>
<span class="gi">+            # data.graph should be dict-like</span>
<span class="gi">+            result.graph.update(data.graph)</span>
<span class="gi">+            # data.nodes should be dict-like</span>
<span class="gi">+            # result.add_node_from(data.nodes.items()) possible but</span>
<span class="gi">+            # for custom node_attr_dict_factory which may be hashable</span>
<span class="gi">+            # will be unexpected behavior</span>
<span class="gi">+            for n, dd in data.nodes.items():</span>
<span class="gi">+                result._node[n].update(dd)</span>
<span class="gi">+            return result</span>
<span class="gi">+        except Exception as err:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Input is not a correct NetworkX graph.&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    # pygraphviz  agraph</span>
<span class="gi">+    if hasattr(data, &quot;is_strict&quot;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return nx.nx_agraph.from_agraph(data, create_using=create_using)</span>
<span class="gi">+        except Exception as err:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Input is not a correct pygraphviz graph.&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    # dict of dicts/lists</span>
<span class="gi">+    if isinstance(data, dict):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return from_dict_of_dicts(</span>
<span class="gi">+                data, create_using=create_using, multigraph_input=multigraph_input</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception as err1:</span>
<span class="gi">+            if multigraph_input is True:</span>
<span class="gi">+                raise nx.NetworkXError(</span>
<span class="gi">+                    f&quot;converting multigraph_input raised:\n{type(err1)}: {err1}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            try:</span>
<span class="gi">+                return from_dict_of_lists(data, create_using=create_using)</span>
<span class="gi">+            except Exception as err2:</span>
<span class="gi">+                raise TypeError(&quot;Input is not known type.&quot;) from err2</span>
<span class="gi">+</span>
<span class="gi">+    # Pandas DataFrame</span>
<span class="gi">+    try:</span>
<span class="gi">+        import pandas as pd</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(data, pd.DataFrame):</span>
<span class="gi">+            if data.shape[0] == data.shape[1]:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return nx.from_pandas_adjacency(data, create_using=create_using)</span>
<span class="gi">+                except Exception as err:</span>
<span class="gi">+                    msg = &quot;Input is not a correct Pandas DataFrame adjacency matrix.&quot;</span>
<span class="gi">+                    raise nx.NetworkXError(msg) from err</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return nx.from_pandas_edgelist(</span>
<span class="gi">+                        data, edge_attr=True, create_using=create_using</span>
<span class="gi">+                    )</span>
<span class="gi">+                except Exception as err:</span>
<span class="gi">+                    msg = &quot;Input is not a correct Pandas DataFrame edge-list.&quot;</span>
<span class="gi">+                    raise nx.NetworkXError(msg) from err</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        warnings.warn(&quot;pandas not found, skipping conversion test.&quot;, ImportWarning)</span>
<span class="gi">+</span>
<span class="gi">+    # numpy array</span>
<span class="gi">+    try:</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(data, np.ndarray):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return nx.from_numpy_array(data, create_using=create_using)</span>
<span class="gi">+            except Exception as err:</span>
<span class="gi">+                raise nx.NetworkXError(</span>
<span class="gi">+                    f&quot;Failed to interpret array as an adjacency matrix.&quot;</span>
<span class="gi">+                ) from err</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        warnings.warn(&quot;numpy not found, skipping conversion test.&quot;, ImportWarning)</span>
<span class="gi">+</span>
<span class="gi">+    # scipy sparse array - any format</span>
<span class="gi">+    try:</span>
<span class="gi">+        import scipy</span>
<span class="gi">+</span>
<span class="gi">+        if hasattr(data, &quot;format&quot;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return nx.from_scipy_sparse_array(data, create_using=create_using)</span>
<span class="gi">+            except Exception as err:</span>
<span class="gi">+                raise nx.NetworkXError(</span>
<span class="gi">+                    &quot;Input is not a correct scipy sparse array type.&quot;</span>
<span class="gi">+                ) from err</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        warnings.warn(&quot;scipy not found, skipping conversion test.&quot;, ImportWarning)</span>
<span class="gi">+</span>
<span class="gi">+    # Note: most general check - should remain last in order of execution</span>
<span class="gi">+    # Includes containers (e.g. list, set, dict, etc.), generators, and</span>
<span class="gi">+    # iterators (e.g. itertools.chain) of edges</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(data, Collection | Generator | Iterator):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return from_edgelist(data, create_using=create_using)</span>
<span class="gi">+        except Exception as err:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Input is not a valid edge list&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    raise nx.NetworkXError(&quot;Input is not a known data type for conversion.&quot;)</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -81,7 +193,13 @@ def to_dict_of_lists(G, nodelist=None):</span>
<span class="w"> </span>    Completely ignores edge data for MultiGraph and MultiDiGraph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = G</span>
<span class="gi">+</span>
<span class="gi">+    d = {}</span>
<span class="gi">+    for n in nodelist:</span>
<span class="gi">+        d[n] = [nbr for nbr in G.neighbors(n) if nbr in nodelist]</span>
<span class="gi">+    return d</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -106,7 +224,23 @@ def from_dict_of_lists(d, create_using=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.Graph(dol)  # use Graph constructor

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    G.add_nodes_from(d)</span>
<span class="gi">+    if G.is_multigraph() and not G.is_directed():</span>
<span class="gi">+        # a dict_of_lists can&#39;t show multiedges.  BUT for undirected graphs,</span>
<span class="gi">+        # each edge shows up twice in the dict_of_lists.</span>
<span class="gi">+        # So we need to treat this case separately.</span>
<span class="gi">+        seen = {}</span>
<span class="gi">+        for node, nbrlist in d.items():</span>
<span class="gi">+            for nbr in nbrlist:</span>
<span class="gi">+                if nbr not in seen:</span>
<span class="gi">+                    G.add_edge(node, nbr)</span>
<span class="gi">+            seen[node] = 1  # don&#39;t allow reverse edge to show up</span>
<span class="gi">+    else:</span>
<span class="gi">+        G.add_edges_from(</span>
<span class="gi">+            ((node, nbr) for node, nbrlist in d.items() for nbr in nbrlist)</span>
<span class="gi">+        )</span>
<span class="gi">+    return G</span>


<span class="w"> </span>def to_dict_of_dicts(G, nodelist=None, edge_data=None):
<span class="gu">@@ -206,7 +340,26 @@ def to_dict_of_dicts(G, nodelist=None, edge_data=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; d
<span class="w"> </span>    {0: {1: 10}, 1: {0: 10}}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dod = {}</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        if edge_data is None:</span>
<span class="gi">+            for u, nbrdict in G.adjacency():</span>
<span class="gi">+                dod[u] = nbrdict.copy()</span>
<span class="gi">+        else:  # edge_data is not None</span>
<span class="gi">+            for u, nbrdict in G.adjacency():</span>
<span class="gi">+                dod[u] = dod.fromkeys(nbrdict, edge_data)</span>
<span class="gi">+    else:  # nodelist is not None</span>
<span class="gi">+        if edge_data is None:</span>
<span class="gi">+            for u in nodelist:</span>
<span class="gi">+                dod[u] = {}</span>
<span class="gi">+                for v, data in ((v, data) for v, data in G[u].items() if v in nodelist):</span>
<span class="gi">+                    dod[u][v] = data</span>
<span class="gi">+        else:  # nodelist and edge_data are not None</span>
<span class="gi">+            for u in nodelist:</span>
<span class="gi">+                dod[u] = {}</span>
<span class="gi">+                for v in (v for v in G[u] if v in nodelist):</span>
<span class="gi">+                    dod[u][v] = edge_data</span>
<span class="gi">+    return dod</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -238,7 +391,62 @@ def from_dict_of_dicts(d, create_using=None, multigraph_input=False):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.Graph(dod)  # use Graph constructor

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    G.add_nodes_from(d)</span>
<span class="gi">+    # does dict d represent a MultiGraph or MultiDiGraph?</span>
<span class="gi">+    if multigraph_input:</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            if G.is_multigraph():</span>
<span class="gi">+                G.add_edges_from(</span>
<span class="gi">+                    (u, v, key, data)</span>
<span class="gi">+                    for u, nbrs in d.items()</span>
<span class="gi">+                    for v, datadict in nbrs.items()</span>
<span class="gi">+                    for key, data in datadict.items()</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                G.add_edges_from(</span>
<span class="gi">+                    (u, v, data)</span>
<span class="gi">+                    for u, nbrs in d.items()</span>
<span class="gi">+                    for v, datadict in nbrs.items()</span>
<span class="gi">+                    for key, data in datadict.items()</span>
<span class="gi">+                )</span>
<span class="gi">+        else:  # Undirected</span>
<span class="gi">+            if G.is_multigraph():</span>
<span class="gi">+                seen = set()  # don&#39;t add both directions of undirected graph</span>
<span class="gi">+                for u, nbrs in d.items():</span>
<span class="gi">+                    for v, datadict in nbrs.items():</span>
<span class="gi">+                        if (u, v) not in seen:</span>
<span class="gi">+                            G.add_edges_from(</span>
<span class="gi">+                                (u, v, key, data) for key, data in datadict.items()</span>
<span class="gi">+                            )</span>
<span class="gi">+                            seen.add((v, u))</span>
<span class="gi">+            else:</span>
<span class="gi">+                seen = set()  # don&#39;t add both directions of undirected graph</span>
<span class="gi">+                for u, nbrs in d.items():</span>
<span class="gi">+                    for v, datadict in nbrs.items():</span>
<span class="gi">+                        if (u, v) not in seen:</span>
<span class="gi">+                            G.add_edges_from(</span>
<span class="gi">+                                (u, v, data) for key, data in datadict.items()</span>
<span class="gi">+                            )</span>
<span class="gi">+                            seen.add((v, u))</span>
<span class="gi">+</span>
<span class="gi">+    else:  # not a multigraph to multigraph transfer</span>
<span class="gi">+        if G.is_multigraph() and not G.is_directed():</span>
<span class="gi">+            # d can have both representations u-v, v-u in dict.  Only add one.</span>
<span class="gi">+            # We don&#39;t need this check for digraphs since we add both directions,</span>
<span class="gi">+            # or for Graph() since it is done implicitly (parallel edges not allowed)</span>
<span class="gi">+            seen = set()</span>
<span class="gi">+            for u, nbrs in d.items():</span>
<span class="gi">+                for v, data in nbrs.items():</span>
<span class="gi">+                    if (u, v) not in seen:</span>
<span class="gi">+                        G.add_edge(u, v, key=0)</span>
<span class="gi">+                        G[u][v][0].update(data)</span>
<span class="gi">+                    seen.add((v, u))</span>
<span class="gi">+        else:</span>
<span class="gi">+            G.add_edges_from(</span>
<span class="gi">+                ((u, v, data) for u, nbrs in d.items() for v, data in nbrs.items())</span>
<span class="gi">+            )</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(preserve_edge_attrs=True)
<span class="gu">@@ -254,7 +462,9 @@ def to_edgelist(G, nodelist=None):</span>
<span class="w"> </span>       Use only nodes specified in nodelist

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        return G.edges(data=True)</span>
<span class="gi">+    return G.edges(nodelist, data=True)</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -279,4 +489,6 @@ def from_edgelist(edgelist, create_using=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.Graph(edgelist)  # use Graph constructor

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    G.add_edges_from(edgelist)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/convert_matrix.py b/networkx/convert_matrix.py</span>
<span class="gh">index a3278bf21..6165ac18e 100644</span>
<span class="gd">--- a/networkx/convert_matrix.py</span>
<span class="gi">+++ b/networkx/convert_matrix.py</span>
<span class="gu">@@ -24,18 +24,35 @@ See Also</span>
<span class="w"> </span>--------
<span class="w"> </span>nx_agraph, nx_pydot
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;from_pandas_adjacency&#39;, &#39;to_pandas_adjacency&#39;,</span>
<span class="gd">-    &#39;from_pandas_edgelist&#39;, &#39;to_pandas_edgelist&#39;, &#39;from_scipy_sparse_array&#39;,</span>
<span class="gd">-    &#39;to_scipy_sparse_array&#39;, &#39;from_numpy_array&#39;, &#39;to_numpy_array&#39;]</span>
<span class="gd">-</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def to_pandas_adjacency(G, nodelist=None, dtype=None, order=None,</span>
<span class="gd">-    multigraph_weight=sum, weight=&#39;weight&#39;, nonedge=0.0):</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;from_pandas_adjacency&quot;,</span>
<span class="gi">+    &quot;to_pandas_adjacency&quot;,</span>
<span class="gi">+    &quot;from_pandas_edgelist&quot;,</span>
<span class="gi">+    &quot;to_pandas_edgelist&quot;,</span>
<span class="gi">+    &quot;from_scipy_sparse_array&quot;,</span>
<span class="gi">+    &quot;to_scipy_sparse_array&quot;,</span>
<span class="gi">+    &quot;from_numpy_array&quot;,</span>
<span class="gi">+    &quot;to_numpy_array&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def to_pandas_adjacency(</span>
<span class="gi">+    G,</span>
<span class="gi">+    nodelist=None,</span>
<span class="gi">+    dtype=None,</span>
<span class="gi">+    order=None,</span>
<span class="gi">+    multigraph_weight=sum,</span>
<span class="gi">+    weight=&quot;weight&quot;,</span>
<span class="gi">+    nonedge=0.0,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the graph adjacency matrix as a Pandas DataFrame.

<span class="w"> </span>    Parameters
<span class="gu">@@ -118,12 +135,25 @@ def to_pandas_adjacency(G, nodelist=None, dtype=None, order=None,</span>
<span class="w"> </span>    2  0  0  4

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import pandas as pd</span>
<span class="gi">+</span>
<span class="gi">+    M = to_numpy_array(</span>
<span class="gi">+        G,</span>
<span class="gi">+        nodelist=nodelist,</span>
<span class="gi">+        dtype=dtype,</span>
<span class="gi">+        order=order,</span>
<span class="gi">+        multigraph_weight=multigraph_weight,</span>
<span class="gi">+        weight=weight,</span>
<span class="gi">+        nonedge=nonedge,</span>
<span class="gi">+    )</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+    return pd.DataFrame(data=M, index=nodelist, columns=nodelist)</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def from_pandas_adjacency(df, create_using=None):
<span class="gd">-    &quot;&quot;&quot;Returns a graph from Pandas DataFrame.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a graph from Pandas DataFrame.</span>

<span class="w"> </span>    The Pandas DataFrame is interpreted as an adjacency matrix for the graph.

<span class="gu">@@ -175,12 +205,30 @@ def from_pandas_adjacency(df, create_using=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; print(G)
<span class="w"> </span>    Graph named &#39;Graph from pandas adjacency matrix&#39; with 2 nodes and 3 edges
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        df = df[df.index]</span>
<span class="gi">+    except Exception as err:</span>
<span class="gi">+        missing = list(set(df.index).difference(set(df.columns)))</span>
<span class="gi">+        msg = f&quot;{missing} not in columns&quot;</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Columns must match Indices.&quot;, msg) from err</span>
<span class="gi">+</span>
<span class="gi">+    A = df.values</span>
<span class="gi">+    G = from_numpy_array(A, create_using=create_using)</span>
<span class="gi">+</span>
<span class="gi">+    nx.relabel.relabel_nodes(G, dict(enumerate(df.columns)), copy=False)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(preserve_edge_attrs=True)
<span class="gd">-def to_pandas_edgelist(G, source=&#39;source&#39;, target=&#39;target&#39;, nodelist=None,</span>
<span class="gd">-    dtype=None, edge_key=None):</span>
<span class="gi">+def to_pandas_edgelist(</span>
<span class="gi">+    G,</span>
<span class="gi">+    source=&quot;source&quot;,</span>
<span class="gi">+    target=&quot;target&quot;,</span>
<span class="gi">+    nodelist=None,</span>
<span class="gi">+    dtype=None,</span>
<span class="gi">+    edge_key=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the graph edge list as a Pandas DataFrame.

<span class="w"> </span>    Parameters
<span class="gu">@@ -234,12 +282,45 @@ def to_pandas_edgelist(G, source=&#39;source&#39;, target=&#39;target&#39;, nodelist=None,</span>
<span class="w"> </span>    1      A      B     9     1

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import pandas as pd</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        edgelist = G.edges(data=True)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edgelist = G.edges(nodelist, data=True)</span>
<span class="gi">+    source_nodes = [s for s, _, _ in edgelist]</span>
<span class="gi">+    target_nodes = [t for _, t, _ in edgelist]</span>
<span class="gi">+</span>
<span class="gi">+    all_attrs = set().union(*(d.keys() for _, _, d in edgelist))</span>
<span class="gi">+    if source in all_attrs:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Source name {source!r} is an edge attr name&quot;)</span>
<span class="gi">+    if target in all_attrs:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Target name {target!r} is an edge attr name&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    nan = float(&quot;nan&quot;)</span>
<span class="gi">+    edge_attr = {k: [d.get(k, nan) for _, _, d in edgelist] for k in all_attrs}</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph() and edge_key is not None:</span>
<span class="gi">+        if edge_key in all_attrs:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;Edge key name {edge_key!r} is an edge attr name&quot;)</span>
<span class="gi">+        edge_keys = [k for _, _, k in G.edges(keys=True)]</span>
<span class="gi">+        edgelistdict = {source: source_nodes, target: target_nodes, edge_key: edge_keys}</span>
<span class="gi">+    else:</span>
<span class="gi">+        edgelistdict = {source: source_nodes, target: target_nodes}</span>
<span class="gi">+</span>
<span class="gi">+    edgelistdict.update(edge_attr)</span>
<span class="gi">+    return pd.DataFrame(edgelistdict, dtype=dtype)</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def from_pandas_edgelist(df, source=&#39;source&#39;, target=&#39;target&#39;, edge_attr=</span>
<span class="gd">-    None, create_using=None, edge_key=None):</span>
<span class="gi">+def from_pandas_edgelist(</span>
<span class="gi">+    df,</span>
<span class="gi">+    source=&quot;source&quot;,</span>
<span class="gi">+    target=&quot;target&quot;,</span>
<span class="gi">+    edge_attr=None,</span>
<span class="gi">+    create_using=None,</span>
<span class="gi">+    edge_key=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a graph from Pandas DataFrame containing an edge list.

<span class="w"> </span>    The Pandas DataFrame should contain at least two columns of node names and
<span class="gu">@@ -349,12 +430,62 @@ def from_pandas_edgelist(df, source=&#39;source&#39;, target=&#39;target&#39;, edge_attr=</span>


<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def to_scipy_sparse_array(G, nodelist=None, dtype=None, weight=&#39;weight&#39;,</span>
<span class="gd">-    format=&#39;csr&#39;):</span>
<span class="gi">+    g = nx.empty_graph(0, create_using)</span>
<span class="gi">+</span>
<span class="gi">+    if edge_attr is None:</span>
<span class="gi">+        g.add_edges_from(zip(df[source], df[target]))</span>
<span class="gi">+        return g</span>
<span class="gi">+</span>
<span class="gi">+    reserved_columns = [source, target]</span>
<span class="gi">+</span>
<span class="gi">+    # Additional columns requested</span>
<span class="gi">+    attr_col_headings = []</span>
<span class="gi">+    attribute_data = []</span>
<span class="gi">+    if edge_attr is True:</span>
<span class="gi">+        attr_col_headings = [c for c in df.columns if c not in reserved_columns]</span>
<span class="gi">+    elif isinstance(edge_attr, list | tuple):</span>
<span class="gi">+        attr_col_headings = edge_attr</span>
<span class="gi">+    else:</span>
<span class="gi">+        attr_col_headings = [edge_attr]</span>
<span class="gi">+    if len(attr_col_headings) == 0:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;Invalid edge_attr argument: No columns found with name: {attr_col_headings}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        attribute_data = zip(*[df[col] for col in attr_col_headings])</span>
<span class="gi">+    except (KeyError, TypeError) as err:</span>
<span class="gi">+        msg = f&quot;Invalid edge_attr argument: {edge_attr}&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg) from err</span>
<span class="gi">+</span>
<span class="gi">+    if g.is_multigraph():</span>
<span class="gi">+        # =&gt; append the edge keys from the df to the bundled data</span>
<span class="gi">+        if edge_key is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                multigraph_edge_keys = df[edge_key]</span>
<span class="gi">+                attribute_data = zip(attribute_data, multigraph_edge_keys)</span>
<span class="gi">+            except (KeyError, TypeError) as err:</span>
<span class="gi">+                msg = f&quot;Invalid edge_key argument: {edge_key}&quot;</span>
<span class="gi">+                raise nx.NetworkXError(msg) from err</span>
<span class="gi">+</span>
<span class="gi">+        for s, t, attrs in zip(df[source], df[target], attribute_data):</span>
<span class="gi">+            if edge_key is not None:</span>
<span class="gi">+                attrs, multigraph_edge_key = attrs</span>
<span class="gi">+                key = g.add_edge(s, t, key=multigraph_edge_key)</span>
<span class="gi">+            else:</span>
<span class="gi">+                key = g.add_edge(s, t)</span>
<span class="gi">+</span>
<span class="gi">+            g[s][t][key].update(zip(attr_col_headings, attrs))</span>
<span class="gi">+    else:</span>
<span class="gi">+        for s, t, attrs in zip(df[source], df[target], attribute_data):</span>
<span class="gi">+            g.add_edge(s, t)</span>
<span class="gi">+            g[s][t].update(zip(attr_col_headings, attrs))</span>
<span class="gi">+</span>
<span class="gi">+    return g</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def to_scipy_sparse_array(G, nodelist=None, dtype=None, weight=&quot;weight&quot;, format=&quot;csr&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the graph adjacency matrix as a SciPy sparse array.

<span class="w"> </span>    Parameters
<span class="gu">@@ -434,7 +565,57 @@ def to_scipy_sparse_array(G, nodelist=None, dtype=None, weight=&#39;weight&#39;,</span>
<span class="w"> </span>    .. [1] Scipy Dev. References, &quot;Sparse Matrices&quot;,
<span class="w"> </span>       https://docs.scipy.org/doc/scipy/reference/sparse.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Graph has no nodes or edges&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+        nlen = len(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        nlen = len(nodelist)</span>
<span class="gi">+        if nlen == 0:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;nodelist has no nodes&quot;)</span>
<span class="gi">+        nodeset = set(G.nbunch_iter(nodelist))</span>
<span class="gi">+        if nlen != len(nodeset):</span>
<span class="gi">+            for n in nodelist:</span>
<span class="gi">+                if n not in G:</span>
<span class="gi">+                    raise nx.NetworkXError(f&quot;Node {n} in nodelist is not in G&quot;)</span>
<span class="gi">+            raise nx.NetworkXError(&quot;nodelist contains duplicates.&quot;)</span>
<span class="gi">+        if nlen &lt; len(G):</span>
<span class="gi">+            G = G.subgraph(nodelist)</span>
<span class="gi">+</span>
<span class="gi">+    index = dict(zip(nodelist, range(nlen)))</span>
<span class="gi">+    coefficients = zip(</span>
<span class="gi">+        *((index[u], index[v], wt) for u, v, wt in G.edges(data=weight, default=1))</span>
<span class="gi">+    )</span>
<span class="gi">+    try:</span>
<span class="gi">+        row, col, data = coefficients</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # there is no edge in the subgraph</span>
<span class="gi">+        row, col, data = [], [], []</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        A = sp.sparse.coo_array((data, (row, col)), shape=(nlen, nlen), dtype=dtype)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # symmetrize matrix</span>
<span class="gi">+        d = data + data</span>
<span class="gi">+        r = row + col</span>
<span class="gi">+        c = col + row</span>
<span class="gi">+        # selfloop entries get double counted when symmetrizing</span>
<span class="gi">+        # so we subtract the data on the diagonal</span>
<span class="gi">+        selfloops = list(nx.selfloop_edges(G, data=weight, default=1))</span>
<span class="gi">+        if selfloops:</span>
<span class="gi">+            diag_index, diag_data = zip(*((index[u], -wt) for u, v, wt in selfloops))</span>
<span class="gi">+            d += diag_data</span>
<span class="gi">+            r += diag_index</span>
<span class="gi">+            c += diag_index</span>
<span class="gi">+        A = sp.sparse.coo_array((d, (r, c)), shape=(nlen, nlen), dtype=dtype)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return A.asformat(format)</span>
<span class="gi">+    except ValueError as err:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Unknown sparse matrix format: {format}&quot;) from err</span>


<span class="w"> </span>def _csr_gen_triples(A):
<span class="gu">@@ -442,7 +623,12 @@ def _csr_gen_triples(A):</span>
<span class="w"> </span>    an iterable of weighted edge triples.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nrows = A.shape[0]</span>
<span class="gi">+    indptr, dst_indices, data = A.indptr, A.indices, A.data</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    src_indices = np.repeat(np.arange(nrows), np.diff(indptr))</span>
<span class="gi">+    return zip(src_indices.tolist(), dst_indices.tolist(), A.data.tolist())</span>


<span class="w"> </span>def _csc_gen_triples(A):
<span class="gu">@@ -450,7 +636,12 @@ def _csc_gen_triples(A):</span>
<span class="w"> </span>    an iterable of weighted edge triples.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ncols = A.shape[1]</span>
<span class="gi">+    indptr, src_indices, data = A.indptr, A.indices, A.data</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    dst_indices = np.repeat(np.arange(ncols), np.diff(indptr))</span>
<span class="gi">+    return zip(src_indices.tolist(), dst_indices.tolist(), A.data.tolist())</span>


<span class="w"> </span>def _coo_gen_triples(A):
<span class="gu">@@ -458,7 +649,7 @@ def _coo_gen_triples(A):</span>
<span class="w"> </span>    of weighted edge triples.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return zip(A.row.tolist(), A.col.tolist(), A.data.tolist())</span>


<span class="w"> </span>def _dok_gen_triples(A):
<span class="gu">@@ -466,7 +657,9 @@ def _dok_gen_triples(A):</span>
<span class="w"> </span>    iterable of weighted edge triples.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for (r, c), v in A.items():</span>
<span class="gi">+        # Use `v.item()` to convert a NumPy scalar to the appropriate Python scalar</span>
<span class="gi">+        yield int(r), int(c), v.item()</span>


<span class="w"> </span>def _generate_weighted_edges(A):
<span class="gu">@@ -476,12 +669,20 @@ def _generate_weighted_edges(A):</span>
<span class="w"> </span>    `A` is a SciPy sparse array (in any format).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if A.format == &quot;csr&quot;:</span>
<span class="gi">+        return _csr_gen_triples(A)</span>
<span class="gi">+    if A.format == &quot;csc&quot;:</span>
<span class="gi">+        return _csc_gen_triples(A)</span>
<span class="gi">+    if A.format == &quot;dok&quot;:</span>
<span class="gi">+        return _dok_gen_triples(A)</span>
<span class="gi">+    # If A is in any other format (including COO), convert it to COO format.</span>
<span class="gi">+    return _coo_gen_triples(A.tocoo())</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def from_scipy_sparse_array(A, parallel_edges=False, create_using=None,</span>
<span class="gd">-    edge_attribute=&#39;weight&#39;):</span>
<span class="gi">+def from_scipy_sparse_array(</span>
<span class="gi">+    A, parallel_edges=False, create_using=None, edge_attribute=&quot;weight&quot;</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Creates a new graph from an adjacency matrix given as a SciPy sparse
<span class="w"> </span>    array.

<span class="gu">@@ -544,12 +745,53 @@ def from_scipy_sparse_array(A, parallel_edges=False, create_using=None,</span>
<span class="w"> </span>    AtlasView({0: {&#39;weight&#39;: 1}, 1: {&#39;weight&#39;: 1}})

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def to_numpy_array(G, nodelist=None, dtype=None, order=None,</span>
<span class="gd">-    multigraph_weight=sum, weight=&#39;weight&#39;, nonedge=0.0):</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    n, m = A.shape</span>
<span class="gi">+    if n != m:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Adjacency matrix not square: nx,ny={A.shape}&quot;)</span>
<span class="gi">+    # Make sure we get even the isolated nodes of the graph.</span>
<span class="gi">+    G.add_nodes_from(range(n))</span>
<span class="gi">+    # Create an iterable over (u, v, w) triples and for each triple, add an</span>
<span class="gi">+    # edge from u to v with weight w.</span>
<span class="gi">+    triples = _generate_weighted_edges(A)</span>
<span class="gi">+    # If the entries in the adjacency matrix are integers, the graph is a</span>
<span class="gi">+    # multigraph, and parallel_edges is True, then create parallel edges, each</span>
<span class="gi">+    # with weight 1, for each entry in the adjacency matrix. Otherwise, create</span>
<span class="gi">+    # one edge for each positive entry in the adjacency matrix and set the</span>
<span class="gi">+    # weight of that edge to be the entry in the matrix.</span>
<span class="gi">+    if A.dtype.kind in (&quot;i&quot;, &quot;u&quot;) and G.is_multigraph() and parallel_edges:</span>
<span class="gi">+        chain = itertools.chain.from_iterable</span>
<span class="gi">+        # The following line is equivalent to:</span>
<span class="gi">+        #</span>
<span class="gi">+        #     for (u, v) in edges:</span>
<span class="gi">+        #         for d in range(A[u, v]):</span>
<span class="gi">+        #             G.add_edge(u, v, weight=1)</span>
<span class="gi">+        #</span>
<span class="gi">+        triples = chain(((u, v, 1) for d in range(w)) for (u, v, w) in triples)</span>
<span class="gi">+    # If we are creating an undirected multigraph, only add the edges from the</span>
<span class="gi">+    # upper triangle of the matrix. Otherwise, add all the edges. This relies</span>
<span class="gi">+    # on the fact that the vertices created in the</span>
<span class="gi">+    # `_generated_weighted_edges()` function are actually the row/column</span>
<span class="gi">+    # indices for the matrix `A`.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Without this check, we run into a problem where each edge is added twice</span>
<span class="gi">+    # when `G.add_weighted_edges_from()` is invoked below.</span>
<span class="gi">+    if G.is_multigraph() and not G.is_directed():</span>
<span class="gi">+        triples = ((u, v, d) for u, v, d in triples if u &lt;= v)</span>
<span class="gi">+    G.add_weighted_edges_from(triples, weight=edge_attribute)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)  # edge attrs may also be obtained from `dtype`</span>
<span class="gi">+def to_numpy_array(</span>
<span class="gi">+    G,</span>
<span class="gi">+    nodelist=None,</span>
<span class="gi">+    dtype=None,</span>
<span class="gi">+    order=None,</span>
<span class="gi">+    multigraph_weight=sum,</span>
<span class="gi">+    weight=&quot;weight&quot;,</span>
<span class="gi">+    nonedge=0.0,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the graph adjacency matrix as a NumPy array.

<span class="w"> </span>    Parameters
<span class="gu">@@ -700,12 +942,87 @@ def to_numpy_array(G, nodelist=None, dtype=None, order=None,</span>
<span class="w"> </span>           [-1.,  0., -1.,  0.],
<span class="w"> </span>           [ 1., -1.,  0., -1.]])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+    nlen = len(nodelist)</span>
<span class="gi">+</span>
<span class="gi">+    # Input validation</span>
<span class="gi">+    nodeset = set(nodelist)</span>
<span class="gi">+    if nodeset - set(G):</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Nodes {nodeset - set(G)} in nodelist is not in G&quot;)</span>
<span class="gi">+    if len(nodeset) &lt; nlen:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;nodelist contains duplicates.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    A = np.full((nlen, nlen), fill_value=nonedge, dtype=dtype, order=order)</span>
<span class="gi">+</span>
<span class="gi">+    # Corner cases: empty nodelist or graph without any edges</span>
<span class="gi">+    if nlen == 0 or G.number_of_edges() == 0:</span>
<span class="gi">+        return A</span>
<span class="gi">+</span>
<span class="gi">+    # If dtype is structured and weight is None, use dtype field names as</span>
<span class="gi">+    # edge attributes</span>
<span class="gi">+    edge_attrs = None  # Only single edge attribute by default</span>
<span class="gi">+    if A.dtype.names:</span>
<span class="gi">+        if weight is None:</span>
<span class="gi">+            edge_attrs = dtype.names</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;Specifying `weight` not supported for structured dtypes\n.&quot;</span>
<span class="gi">+                &quot;To create adjacency matrices from structured dtypes, use `weight=None`.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # Map nodes to row/col in matrix</span>
<span class="gi">+    idx = dict(zip(nodelist, range(nlen)))</span>
<span class="gi">+    if len(nodelist) &lt; len(G):</span>
<span class="gi">+        G = G.subgraph(nodelist).copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Collect all edge weights and reduce with `multigraph_weights`</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        if edge_attrs:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;Structured arrays are not supported for MultiGraphs&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        d = defaultdict(list)</span>
<span class="gi">+        for u, v, wt in G.edges(data=weight, default=1.0):</span>
<span class="gi">+            d[(idx[u], idx[v])].append(wt)</span>
<span class="gi">+        i, j = np.array(list(d.keys())).T  # indices</span>
<span class="gi">+        wts = [multigraph_weight(ws) for ws in d.values()]  # reduced weights</span>
<span class="gi">+    else:</span>
<span class="gi">+        i, j, wts = [], [], []</span>
<span class="gi">+</span>
<span class="gi">+        # Special branch: multi-attr adjacency from structured dtypes</span>
<span class="gi">+        if edge_attrs:</span>
<span class="gi">+            # Extract edges with all data</span>
<span class="gi">+            for u, v, data in G.edges(data=True):</span>
<span class="gi">+                i.append(idx[u])</span>
<span class="gi">+                j.append(idx[v])</span>
<span class="gi">+                wts.append(data)</span>
<span class="gi">+            # Map each attribute to the appropriate named field in the</span>
<span class="gi">+            # structured dtype</span>
<span class="gi">+            for attr in edge_attrs:</span>
<span class="gi">+                attr_data = [wt.get(attr, 1.0) for wt in wts]</span>
<span class="gi">+                A[attr][i, j] = attr_data</span>
<span class="gi">+                if not G.is_directed():</span>
<span class="gi">+                    A[attr][j, i] = attr_data</span>
<span class="gi">+            return A</span>
<span class="gi">+</span>
<span class="gi">+        for u, v, wt in G.edges(data=weight, default=1.0):</span>
<span class="gi">+            i.append(idx[u])</span>
<span class="gi">+            j.append(idx[v])</span>
<span class="gi">+            wts.append(wt)</span>
<span class="gi">+</span>
<span class="gi">+    # Set array values with advanced indexing</span>
<span class="gi">+    A[i, j] = wts</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        A[j, i] = wts</span>
<span class="gi">+</span>
<span class="gi">+    return A</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def from_numpy_array(A, parallel_edges=False, create_using=None, edge_attr=</span>
<span class="gd">-    &#39;weight&#39;):</span>
<span class="gi">+def from_numpy_array(A, parallel_edges=False, create_using=None, edge_attr=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a graph from a 2D NumPy array.

<span class="w"> </span>    The 2D NumPy array is interpreted as an adjacency matrix for the graph.
<span class="gu">@@ -801,4 +1118,85 @@ def from_numpy_array(A, parallel_edges=False, create_using=None, edge_attr=</span>
<span class="w"> </span>    1.0

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    kind_to_python_type = {</span>
<span class="gi">+        &quot;f&quot;: float,</span>
<span class="gi">+        &quot;i&quot;: int,</span>
<span class="gi">+        &quot;u&quot;: int,</span>
<span class="gi">+        &quot;b&quot;: bool,</span>
<span class="gi">+        &quot;c&quot;: complex,</span>
<span class="gi">+        &quot;S&quot;: str,</span>
<span class="gi">+        &quot;U&quot;: str,</span>
<span class="gi">+        &quot;V&quot;: &quot;void&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    if A.ndim != 2:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Input array must be 2D, not {A.ndim}&quot;)</span>
<span class="gi">+    n, m = A.shape</span>
<span class="gi">+    if n != m:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Adjacency matrix not square: nx,ny={A.shape}&quot;)</span>
<span class="gi">+    dt = A.dtype</span>
<span class="gi">+    try:</span>
<span class="gi">+        python_type = kind_to_python_type[dt.kind]</span>
<span class="gi">+    except Exception as err:</span>
<span class="gi">+        raise TypeError(f&quot;Unknown numpy data type: {dt}&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    # Make sure we get even the isolated nodes of the graph.</span>
<span class="gi">+    G.add_nodes_from(range(n))</span>
<span class="gi">+    # Get a list of all the entries in the array with nonzero entries. These</span>
<span class="gi">+    # coordinates become edges in the graph. (convert to int from np.int64)</span>
<span class="gi">+    edges = ((int(e[0]), int(e[1])) for e in zip(*A.nonzero()))</span>
<span class="gi">+    # handle numpy constructed data type</span>
<span class="gi">+    if python_type == &quot;void&quot;:</span>
<span class="gi">+        # Sort the fields by their offset, then by dtype, then by name.</span>
<span class="gi">+        fields = sorted(</span>
<span class="gi">+            (offset, dtype, name) for name, (dtype, offset) in A.dtype.fields.items()</span>
<span class="gi">+        )</span>
<span class="gi">+        triples = (</span>
<span class="gi">+            (</span>
<span class="gi">+                u,</span>
<span class="gi">+                v,</span>
<span class="gi">+                {}</span>
<span class="gi">+                if edge_attr in [False, None]</span>
<span class="gi">+                else {</span>
<span class="gi">+                    name: kind_to_python_type[dtype.kind](val)</span>
<span class="gi">+                    for (_, dtype, name), val in zip(fields, A[u, v])</span>
<span class="gi">+                },</span>
<span class="gi">+            )</span>
<span class="gi">+            for u, v in edges</span>
<span class="gi">+        )</span>
<span class="gi">+    # If the entries in the adjacency matrix are integers, the graph is a</span>
<span class="gi">+    # multigraph, and parallel_edges is True, then create parallel edges, each</span>
<span class="gi">+    # with weight 1, for each entry in the adjacency matrix. Otherwise, create</span>
<span class="gi">+    # one edge for each positive entry in the adjacency matrix and set the</span>
<span class="gi">+    # weight of that edge to be the entry in the matrix.</span>
<span class="gi">+    elif python_type is int and G.is_multigraph() and parallel_edges:</span>
<span class="gi">+        chain = itertools.chain.from_iterable</span>
<span class="gi">+        # The following line is equivalent to:</span>
<span class="gi">+        #</span>
<span class="gi">+        #     for (u, v) in edges:</span>
<span class="gi">+        #         for d in range(A[u, v]):</span>
<span class="gi">+        #             G.add_edge(u, v, weight=1)</span>
<span class="gi">+        #</span>
<span class="gi">+        if edge_attr in [False, None]:</span>
<span class="gi">+            triples = chain(((u, v, {}) for d in range(A[u, v])) for (u, v) in edges)</span>
<span class="gi">+        else:</span>
<span class="gi">+            triples = chain(</span>
<span class="gi">+                ((u, v, {edge_attr: 1}) for d in range(A[u, v])) for (u, v) in edges</span>
<span class="gi">+            )</span>
<span class="gi">+    else:  # basic data type</span>
<span class="gi">+        if edge_attr in [False, None]:</span>
<span class="gi">+            triples = ((u, v, {}) for u, v in edges)</span>
<span class="gi">+        else:</span>
<span class="gi">+            triples = ((u, v, {edge_attr: python_type(A[u, v])}) for u, v in edges)</span>
<span class="gi">+    # If we are creating an undirected multigraph, only add the edges from the</span>
<span class="gi">+    # upper triangle of the matrix. Otherwise, add all the edges. This relies</span>
<span class="gi">+    # on the fact that the vertices created in the</span>
<span class="gi">+    # `_generated_weighted_edges()` function are actually the row/column</span>
<span class="gi">+    # indices for the matrix `A`.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Without this check, we run into a problem where each edge is added twice</span>
<span class="gi">+    # when `G.add_edges_from()` is invoked below.</span>
<span class="gi">+    if G.is_multigraph() and not G.is_directed():</span>
<span class="gi">+        triples = ((u, v, d) for u, v, d in triples if u &lt;= v)</span>
<span class="gi">+    G.add_edges_from(triples)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/drawing/layout.py b/networkx/drawing/layout.py</span>
<span class="gh">index 0979963e3..abded7a67 100644</span>
<span class="gd">--- a/networkx/drawing/layout.py</span>
<span class="gi">+++ b/networkx/drawing/layout.py</span>
<span class="gu">@@ -17,11 +17,45 @@ Warning: Most layout routines have only been tested in 2-dimensions.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import np_random_state
<span class="gd">-__all__ = [&#39;bipartite_layout&#39;, &#39;circular_layout&#39;, &#39;kamada_kawai_layout&#39;,</span>
<span class="gd">-    &#39;random_layout&#39;, &#39;rescale_layout&#39;, &#39;rescale_layout_dict&#39;,</span>
<span class="gd">-    &#39;shell_layout&#39;, &#39;spring_layout&#39;, &#39;spectral_layout&#39;, &#39;planar_layout&#39;,</span>
<span class="gd">-    &#39;fruchterman_reingold_layout&#39;, &#39;spiral_layout&#39;, &#39;multipartite_layout&#39;,</span>
<span class="gd">-    &#39;bfs_layout&#39;, &#39;arf_layout&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;bipartite_layout&quot;,</span>
<span class="gi">+    &quot;circular_layout&quot;,</span>
<span class="gi">+    &quot;kamada_kawai_layout&quot;,</span>
<span class="gi">+    &quot;random_layout&quot;,</span>
<span class="gi">+    &quot;rescale_layout&quot;,</span>
<span class="gi">+    &quot;rescale_layout_dict&quot;,</span>
<span class="gi">+    &quot;shell_layout&quot;,</span>
<span class="gi">+    &quot;spring_layout&quot;,</span>
<span class="gi">+    &quot;spectral_layout&quot;,</span>
<span class="gi">+    &quot;planar_layout&quot;,</span>
<span class="gi">+    &quot;fruchterman_reingold_layout&quot;,</span>
<span class="gi">+    &quot;spiral_layout&quot;,</span>
<span class="gi">+    &quot;multipartite_layout&quot;,</span>
<span class="gi">+    &quot;bfs_layout&quot;,</span>
<span class="gi">+    &quot;arf_layout&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _process_params(G, center, dim):</span>
<span class="gi">+    # Some boilerplate code.</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(G, nx.Graph):</span>
<span class="gi">+        empty_graph = nx.Graph()</span>
<span class="gi">+        empty_graph.add_nodes_from(G)</span>
<span class="gi">+        G = empty_graph</span>
<span class="gi">+</span>
<span class="gi">+    if center is None:</span>
<span class="gi">+        center = np.zeros(dim)</span>
<span class="gi">+    else:</span>
<span class="gi">+        center = np.asarray(center)</span>
<span class="gi">+</span>
<span class="gi">+    if len(center) != dim:</span>
<span class="gi">+        msg = &quot;length of center coordinates must match dimension of layout&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    return G, center</span>


<span class="w"> </span>@np_random_state(3)
<span class="gu">@@ -63,10 +97,18 @@ def random_layout(G, center=None, dim=2, seed=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; pos = nx.random_layout(G)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center, dim)</span>
<span class="gi">+    pos = seed.rand(len(G), dim) + center</span>
<span class="gi">+    pos = pos.astype(np.float32)</span>
<span class="gi">+    pos = dict(zip(G, pos))</span>
<span class="gi">+</span>
<span class="gi">+    return pos</span>


<span class="w"> </span>def circular_layout(G, scale=1, center=None, dim=2):
<span class="gi">+    # dim=2 only</span>
<span class="w"> </span>    &quot;&quot;&quot;Position nodes on a circle.

<span class="w"> </span>    Parameters
<span class="gu">@@ -107,7 +149,30 @@ def circular_layout(G, scale=1, center=None, dim=2):</span>
<span class="w"> </span>    try to minimize edge crossings.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if dim &lt; 2:</span>
<span class="gi">+        raise ValueError(&quot;cannot handle dimensions &lt; 2&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center, dim)</span>
<span class="gi">+</span>
<span class="gi">+    paddims = max(0, (dim - 2))</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        pos = {}</span>
<span class="gi">+    elif len(G) == 1:</span>
<span class="gi">+        pos = {nx.utils.arbitrary_element(G): center}</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Discard the extra angle since it matches 0 radians.</span>
<span class="gi">+        theta = np.linspace(0, 1, len(G) + 1)[:-1] * 2 * np.pi</span>
<span class="gi">+        theta = theta.astype(np.float32)</span>
<span class="gi">+        pos = np.column_stack(</span>
<span class="gi">+            [np.cos(theta), np.sin(theta), np.zeros((len(G), paddims))]</span>
<span class="gi">+        )</span>
<span class="gi">+        pos = rescale_layout(pos, scale=scale) + center</span>
<span class="gi">+        pos = dict(zip(G, pos))</span>
<span class="gi">+</span>
<span class="gi">+    return pos</span>


<span class="w"> </span>def shell_layout(G, nlist=None, rotate=None, scale=1, center=None, dim=2):
<span class="gu">@@ -158,11 +223,52 @@ def shell_layout(G, nlist=None, rotate=None, scale=1, center=None, dim=2):</span>
<span class="w"> </span>    try to minimize edge crossings.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def bipartite_layout(G, nodes, align=&#39;vertical&#39;, scale=1, center=None,</span>
<span class="gd">-    aspect_ratio=4 / 3):</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if dim != 2:</span>
<span class="gi">+        raise ValueError(&quot;can only handle 2 dimensions&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center, dim)</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+    if len(G) == 1:</span>
<span class="gi">+        return {nx.utils.arbitrary_element(G): center}</span>
<span class="gi">+</span>
<span class="gi">+    if nlist is None:</span>
<span class="gi">+        # draw the whole graph in one shell</span>
<span class="gi">+        nlist = [list(G)]</span>
<span class="gi">+</span>
<span class="gi">+    radius_bump = scale / len(nlist)</span>
<span class="gi">+</span>
<span class="gi">+    if len(nlist[0]) == 1:</span>
<span class="gi">+        # single node at center</span>
<span class="gi">+        radius = 0.0</span>
<span class="gi">+    else:</span>
<span class="gi">+        # else start at r=1</span>
<span class="gi">+        radius = radius_bump</span>
<span class="gi">+</span>
<span class="gi">+    if rotate is None:</span>
<span class="gi">+        rotate = np.pi / len(nlist)</span>
<span class="gi">+    first_theta = rotate</span>
<span class="gi">+    npos = {}</span>
<span class="gi">+    for nodes in nlist:</span>
<span class="gi">+        # Discard the last angle (endpoint=False) since 2*pi matches 0 radians</span>
<span class="gi">+        theta = (</span>
<span class="gi">+            np.linspace(0, 2 * np.pi, len(nodes), endpoint=False, dtype=np.float32)</span>
<span class="gi">+            + first_theta</span>
<span class="gi">+        )</span>
<span class="gi">+        pos = radius * np.column_stack([np.cos(theta), np.sin(theta)]) + center</span>
<span class="gi">+        npos.update(zip(nodes, pos))</span>
<span class="gi">+        radius += radius_bump</span>
<span class="gi">+        first_theta += rotate</span>
<span class="gi">+</span>
<span class="gi">+    return npos</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def bipartite_layout(</span>
<span class="gi">+    G, nodes, align=&quot;vertical&quot;, scale=1, center=None, aspect_ratio=4 / 3</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Position nodes in two straight lines.

<span class="w"> </span>    Parameters
<span class="gu">@@ -203,12 +309,55 @@ def bipartite_layout(G, nodes, align=&#39;vertical&#39;, scale=1, center=None,</span>
<span class="w"> </span>    try to minimize edge crossings.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if align not in (&quot;vertical&quot;, &quot;horizontal&quot;):</span>
<span class="gi">+        msg = &quot;align must be either vertical or horizontal.&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center=center, dim=2)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    height = 1</span>
<span class="gi">+    width = aspect_ratio * height</span>
<span class="gi">+    offset = (width / 2, height / 2)</span>
<span class="gi">+</span>
<span class="gi">+    top = dict.fromkeys(nodes)</span>
<span class="gi">+    bottom = [v for v in G if v not in top]</span>
<span class="gi">+    nodes = list(top) + bottom</span>
<span class="gi">+</span>
<span class="gi">+    left_xs = np.repeat(0, len(top))</span>
<span class="gi">+    right_xs = np.repeat(width, len(bottom))</span>
<span class="gi">+    left_ys = np.linspace(0, height, len(top))</span>
<span class="gi">+    right_ys = np.linspace(0, height, len(bottom))</span>
<span class="gi">+</span>
<span class="gi">+    top_pos = np.column_stack([left_xs, left_ys]) - offset</span>
<span class="gi">+    bottom_pos = np.column_stack([right_xs, right_ys]) - offset</span>
<span class="gi">+</span>
<span class="gi">+    pos = np.concatenate([top_pos, bottom_pos])</span>
<span class="gi">+    pos = rescale_layout(pos, scale=scale) + center</span>
<span class="gi">+    if align == &quot;horizontal&quot;:</span>
<span class="gi">+        pos = pos[:, ::-1]  # swap x and y coords</span>
<span class="gi">+    pos = dict(zip(nodes, pos))</span>
<span class="gi">+    return pos</span>


<span class="w"> </span>@np_random_state(10)
<span class="gd">-def spring_layout(G, k=None, pos=None, fixed=None, iterations=50, threshold</span>
<span class="gd">-    =0.0001, weight=&#39;weight&#39;, scale=1, center=None, dim=2, seed=None):</span>
<span class="gi">+def spring_layout(</span>
<span class="gi">+    G,</span>
<span class="gi">+    k=None,</span>
<span class="gi">+    pos=None,</span>
<span class="gi">+    fixed=None,</span>
<span class="gi">+    iterations=50,</span>
<span class="gi">+    threshold=1e-4,</span>
<span class="gi">+    weight=&quot;weight&quot;,</span>
<span class="gi">+    scale=1,</span>
<span class="gi">+    center=None,</span>
<span class="gi">+    dim=2,</span>
<span class="gi">+    seed=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Position nodes using Fruchterman-Reingold force-directed algorithm.

<span class="w"> </span>    The algorithm simulates a force-directed representation of the network
<span class="gu">@@ -290,14 +439,206 @@ def spring_layout(G, k=None, pos=None, fixed=None, iterations=50, threshold</span>
<span class="w"> </span>    # The same using longer but equivalent function name
<span class="w"> </span>    &gt;&gt;&gt; pos = nx.fruchterman_reingold_layout(G)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center, dim)</span>
<span class="gi">+</span>
<span class="gi">+    if fixed is not None:</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            raise ValueError(&quot;nodes are fixed without positions given&quot;)</span>
<span class="gi">+        for node in fixed:</span>
<span class="gi">+            if node not in pos:</span>
<span class="gi">+                raise ValueError(&quot;nodes are fixed without positions given&quot;)</span>
<span class="gi">+        nfixed = {node: i for i, node in enumerate(G)}</span>
<span class="gi">+        fixed = np.asarray([nfixed[node] for node in fixed if node in nfixed])</span>
<span class="gi">+</span>
<span class="gi">+    if pos is not None:</span>
<span class="gi">+        # Determine size of existing domain to adjust initial positions</span>
<span class="gi">+        dom_size = max(coord for pos_tup in pos.values() for coord in pos_tup)</span>
<span class="gi">+        if dom_size == 0:</span>
<span class="gi">+            dom_size = 1</span>
<span class="gi">+        pos_arr = seed.rand(len(G), dim) * dom_size + center</span>
<span class="gi">+</span>
<span class="gi">+        for i, n in enumerate(G):</span>
<span class="gi">+            if n in pos:</span>
<span class="gi">+                pos_arr[i] = np.asarray(pos[n])</span>
<span class="gi">+    else:</span>
<span class="gi">+        pos_arr = None</span>
<span class="gi">+        dom_size = 1</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+    if len(G) == 1:</span>
<span class="gi">+        return {nx.utils.arbitrary_element(G.nodes()): center}</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Sparse matrix</span>
<span class="gi">+        if len(G) &lt; 500:  # sparse solver for large graphs</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+        A = nx.to_scipy_sparse_array(G, weight=weight, dtype=&quot;f&quot;)</span>
<span class="gi">+        if k is None and fixed is not None:</span>
<span class="gi">+            # We must adjust k by domain size for layouts not near 1x1</span>
<span class="gi">+            nnodes, _ = A.shape</span>
<span class="gi">+            k = dom_size / np.sqrt(nnodes)</span>
<span class="gi">+        pos = _sparse_fruchterman_reingold(</span>
<span class="gi">+            A, k, pos_arr, fixed, iterations, threshold, dim, seed</span>
<span class="gi">+        )</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        A = nx.to_numpy_array(G, weight=weight)</span>
<span class="gi">+        if k is None and fixed is not None:</span>
<span class="gi">+            # We must adjust k by domain size for layouts not near 1x1</span>
<span class="gi">+            nnodes, _ = A.shape</span>
<span class="gi">+            k = dom_size / np.sqrt(nnodes)</span>
<span class="gi">+        pos = _fruchterman_reingold(</span>
<span class="gi">+            A, k, pos_arr, fixed, iterations, threshold, dim, seed</span>
<span class="gi">+        )</span>
<span class="gi">+    if fixed is None and scale is not None:</span>
<span class="gi">+        pos = rescale_layout(pos, scale=scale) + center</span>
<span class="gi">+    pos = dict(zip(G, pos))</span>
<span class="gi">+    return pos</span>


<span class="w"> </span>fruchterman_reingold_layout = spring_layout


<span class="gd">-def kamada_kawai_layout(G, dist=None, pos=None, weight=&#39;weight&#39;, scale=1,</span>
<span class="gd">-    center=None, dim=2):</span>
<span class="gi">+@np_random_state(7)</span>
<span class="gi">+def _fruchterman_reingold(</span>
<span class="gi">+    A, k=None, pos=None, fixed=None, iterations=50, threshold=1e-4, dim=2, seed=None</span>
<span class="gi">+):</span>
<span class="gi">+    # Position nodes in adjacency matrix A using Fruchterman-Reingold</span>
<span class="gi">+    # Entry point for NetworkX graph is fruchterman_reingold_layout()</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        nnodes, _ = A.shape</span>
<span class="gi">+    except AttributeError as err:</span>
<span class="gi">+        msg = &quot;fruchterman_reingold() takes an adjacency matrix as input&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg) from err</span>
<span class="gi">+</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        # random initial positions</span>
<span class="gi">+        pos = np.asarray(seed.rand(nnodes, dim), dtype=A.dtype)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # make sure positions are of same type as matrix</span>
<span class="gi">+        pos = pos.astype(A.dtype)</span>
<span class="gi">+</span>
<span class="gi">+    # optimal distance between nodes</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        k = np.sqrt(1.0 / nnodes)</span>
<span class="gi">+    # the initial &quot;temperature&quot;  is about .1 of domain area (=1x1)</span>
<span class="gi">+    # this is the largest step allowed in the dynamics.</span>
<span class="gi">+    # We need to calculate this in case our fixed positions force our domain</span>
<span class="gi">+    # to be much bigger than 1x1</span>
<span class="gi">+    t = max(max(pos.T[0]) - min(pos.T[0]), max(pos.T[1]) - min(pos.T[1])) * 0.1</span>
<span class="gi">+    # simple cooling scheme.</span>
<span class="gi">+    # linearly step down by dt on each iteration so last iteration is size dt.</span>
<span class="gi">+    dt = t / (iterations + 1)</span>
<span class="gi">+    delta = np.zeros((pos.shape[0], pos.shape[0], pos.shape[1]), dtype=A.dtype)</span>
<span class="gi">+    # the inscrutable (but fast) version</span>
<span class="gi">+    # this is still O(V^2)</span>
<span class="gi">+    # could use multilevel methods to speed this up significantly</span>
<span class="gi">+    for iteration in range(iterations):</span>
<span class="gi">+        # matrix of difference between points</span>
<span class="gi">+        delta = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]</span>
<span class="gi">+        # distance between points</span>
<span class="gi">+        distance = np.linalg.norm(delta, axis=-1)</span>
<span class="gi">+        # enforce minimum distance of 0.01</span>
<span class="gi">+        np.clip(distance, 0.01, None, out=distance)</span>
<span class="gi">+        # displacement &quot;force&quot;</span>
<span class="gi">+        displacement = np.einsum(</span>
<span class="gi">+            &quot;ijk,ij-&gt;ik&quot;, delta, (k * k / distance**2 - A * distance / k)</span>
<span class="gi">+        )</span>
<span class="gi">+        # update positions</span>
<span class="gi">+        length = np.linalg.norm(displacement, axis=-1)</span>
<span class="gi">+        length = np.where(length &lt; 0.01, 0.1, length)</span>
<span class="gi">+        delta_pos = np.einsum(&quot;ij,i-&gt;ij&quot;, displacement, t / length)</span>
<span class="gi">+        if fixed is not None:</span>
<span class="gi">+            # don&#39;t change positions of fixed nodes</span>
<span class="gi">+            delta_pos[fixed] = 0.0</span>
<span class="gi">+        pos += delta_pos</span>
<span class="gi">+        # cool temperature</span>
<span class="gi">+        t -= dt</span>
<span class="gi">+        if (np.linalg.norm(delta_pos) / nnodes) &lt; threshold:</span>
<span class="gi">+            break</span>
<span class="gi">+    return pos</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@np_random_state(7)</span>
<span class="gi">+def _sparse_fruchterman_reingold(</span>
<span class="gi">+    A, k=None, pos=None, fixed=None, iterations=50, threshold=1e-4, dim=2, seed=None</span>
<span class="gi">+):</span>
<span class="gi">+    # Position nodes in adjacency matrix A using Fruchterman-Reingold</span>
<span class="gi">+    # Entry point for NetworkX graph is fruchterman_reingold_layout()</span>
<span class="gi">+    # Sparse version</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        nnodes, _ = A.shape</span>
<span class="gi">+    except AttributeError as err:</span>
<span class="gi">+        msg = &quot;fruchterman_reingold() takes an adjacency matrix as input&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg) from err</span>
<span class="gi">+    # make sure we have a LIst of Lists representation</span>
<span class="gi">+    try:</span>
<span class="gi">+        A = A.tolil()</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        A = (sp.sparse.coo_array(A)).tolil()</span>
<span class="gi">+</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        # random initial positions</span>
<span class="gi">+        pos = np.asarray(seed.rand(nnodes, dim), dtype=A.dtype)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # make sure positions are of same type as matrix</span>
<span class="gi">+        pos = pos.astype(A.dtype)</span>
<span class="gi">+</span>
<span class="gi">+    # no fixed nodes</span>
<span class="gi">+    if fixed is None:</span>
<span class="gi">+        fixed = []</span>
<span class="gi">+</span>
<span class="gi">+    # optimal distance between nodes</span>
<span class="gi">+    if k is None:</span>
<span class="gi">+        k = np.sqrt(1.0 / nnodes)</span>
<span class="gi">+    # the initial &quot;temperature&quot;  is about .1 of domain area (=1x1)</span>
<span class="gi">+    # this is the largest step allowed in the dynamics.</span>
<span class="gi">+    t = max(max(pos.T[0]) - min(pos.T[0]), max(pos.T[1]) - min(pos.T[1])) * 0.1</span>
<span class="gi">+    # simple cooling scheme.</span>
<span class="gi">+    # linearly step down by dt on each iteration so last iteration is size dt.</span>
<span class="gi">+    dt = t / (iterations + 1)</span>
<span class="gi">+</span>
<span class="gi">+    displacement = np.zeros((dim, nnodes))</span>
<span class="gi">+    for iteration in range(iterations):</span>
<span class="gi">+        displacement *= 0</span>
<span class="gi">+        # loop over rows</span>
<span class="gi">+        for i in range(A.shape[0]):</span>
<span class="gi">+            if i in fixed:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # difference between this row&#39;s node position and all others</span>
<span class="gi">+            delta = (pos[i] - pos).T</span>
<span class="gi">+            # distance between points</span>
<span class="gi">+            distance = np.sqrt((delta**2).sum(axis=0))</span>
<span class="gi">+            # enforce minimum distance of 0.01</span>
<span class="gi">+            distance = np.where(distance &lt; 0.01, 0.01, distance)</span>
<span class="gi">+            # the adjacency matrix row</span>
<span class="gi">+            Ai = A.getrowview(i).toarray()  # TODO: revisit w/ sparse 1D container</span>
<span class="gi">+            # displacement &quot;force&quot;</span>
<span class="gi">+            displacement[:, i] += (</span>
<span class="gi">+                delta * (k * k / distance**2 - Ai * distance / k)</span>
<span class="gi">+            ).sum(axis=1)</span>
<span class="gi">+        # update positions</span>
<span class="gi">+        length = np.sqrt((displacement**2).sum(axis=0))</span>
<span class="gi">+        length = np.where(length &lt; 0.01, 0.1, length)</span>
<span class="gi">+        delta_pos = (displacement * t / length).T</span>
<span class="gi">+        pos += delta_pos</span>
<span class="gi">+        # cool temperature</span>
<span class="gi">+        t -= dt</span>
<span class="gi">+        if (np.linalg.norm(delta_pos) / nnodes) &lt; threshold:</span>
<span class="gi">+            break</span>
<span class="gi">+    return pos</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def kamada_kawai_layout(</span>
<span class="gi">+    G, dist=None, pos=None, weight=&quot;weight&quot;, scale=1, center=None, dim=2</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Position nodes using Kamada-Kawai path-length cost-function.

<span class="w"> </span>    Parameters
<span class="gu">@@ -338,10 +679,88 @@ def kamada_kawai_layout(G, dist=None, pos=None, weight=&#39;weight&#39;, scale=1,</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.path_graph(4)
<span class="w"> </span>    &gt;&gt;&gt; pos = nx.kamada_kawai_layout(G)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center, dim)</span>
<span class="gi">+    nNodes = len(G)</span>
<span class="gi">+    if nNodes == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    if dist is None:</span>
<span class="gi">+        dist = dict(nx.shortest_path_length(G, weight=weight))</span>
<span class="gi">+    dist_mtx = 1e6 * np.ones((nNodes, nNodes))</span>
<span class="gi">+    for row, nr in enumerate(G):</span>
<span class="gi">+        if nr not in dist:</span>
<span class="gi">+            continue</span>
<span class="gi">+        rdist = dist[nr]</span>
<span class="gi">+        for col, nc in enumerate(G):</span>
<span class="gi">+            if nc not in rdist:</span>
<span class="gi">+                continue</span>
<span class="gi">+            dist_mtx[row][col] = rdist[nc]</span>
<span class="gi">+</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        if dim &gt;= 3:</span>
<span class="gi">+            pos = random_layout(G, dim=dim)</span>
<span class="gi">+        elif dim == 2:</span>
<span class="gi">+            pos = circular_layout(G, dim=dim)</span>
<span class="gi">+        else:</span>
<span class="gi">+            pos = dict(zip(G, np.linspace(0, 1, len(G))))</span>
<span class="gi">+    pos_arr = np.array([pos[n] for n in G])</span>
<span class="gi">+</span>
<span class="gi">+    pos = _kamada_kawai_solve(dist_mtx, pos_arr, dim)</span>
<span class="gi">+</span>
<span class="gi">+    pos = rescale_layout(pos, scale=scale) + center</span>
<span class="gi">+    return dict(zip(G, pos))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _kamada_kawai_solve(dist_mtx, pos_arr, dim):</span>
<span class="gi">+    # Anneal node locations based on the Kamada-Kawai cost-function,</span>
<span class="gi">+    # using the supplied matrix of preferred inter-node distances,</span>
<span class="gi">+    # and starting locations.</span>
<span class="gi">+</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    meanwt = 1e-3</span>
<span class="gi">+    costargs = (np, 1 / (dist_mtx + np.eye(dist_mtx.shape[0]) * 1e-3), meanwt, dim)</span>
<span class="gi">+</span>
<span class="gi">+    optresult = sp.optimize.minimize(</span>
<span class="gi">+        _kamada_kawai_costfn,</span>
<span class="gi">+        pos_arr.ravel(),</span>
<span class="gi">+        method=&quot;L-BFGS-B&quot;,</span>
<span class="gi">+        args=costargs,</span>
<span class="gi">+        jac=True,</span>
<span class="gi">+    )</span>

<span class="gi">+    return optresult.x.reshape((-1, dim))</span>

<span class="gd">-def spectral_layout(G, weight=&#39;weight&#39;, scale=1, center=None, dim=2):</span>
<span class="gi">+</span>
<span class="gi">+def _kamada_kawai_costfn(pos_vec, np, invdist, meanweight, dim):</span>
<span class="gi">+    # Cost-function and gradient for Kamada-Kawai layout algorithm</span>
<span class="gi">+    nNodes = invdist.shape[0]</span>
<span class="gi">+    pos_arr = pos_vec.reshape((nNodes, dim))</span>
<span class="gi">+</span>
<span class="gi">+    delta = pos_arr[:, np.newaxis, :] - pos_arr[np.newaxis, :, :]</span>
<span class="gi">+    nodesep = np.linalg.norm(delta, axis=-1)</span>
<span class="gi">+    direction = np.einsum(&quot;ijk,ij-&gt;ijk&quot;, delta, 1 / (nodesep + np.eye(nNodes) * 1e-3))</span>
<span class="gi">+</span>
<span class="gi">+    offset = nodesep * invdist - 1.0</span>
<span class="gi">+    offset[np.diag_indices(nNodes)] = 0</span>
<span class="gi">+</span>
<span class="gi">+    cost = 0.5 * np.sum(offset**2)</span>
<span class="gi">+    grad = np.einsum(&quot;ij,ij,ijk-&gt;ik&quot;, invdist, offset, direction) - np.einsum(</span>
<span class="gi">+        &quot;ij,ij,ijk-&gt;jk&quot;, invdist, offset, direction</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Additional parabolic term to encourage mean position to be near origin:</span>
<span class="gi">+    sumpos = np.sum(pos_arr, axis=0)</span>
<span class="gi">+    cost += 0.5 * meanweight * np.sum(sumpos**2)</span>
<span class="gi">+    grad += meanweight * sumpos</span>
<span class="gi">+</span>
<span class="gi">+    return (cost, grad.ravel())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def spectral_layout(G, weight=&quot;weight&quot;, scale=1, center=None, dim=2):</span>
<span class="w"> </span>    &quot;&quot;&quot;Position nodes using the eigenvectors of the graph Laplacian.

<span class="w"> </span>    Using the unnormalized Laplacian, the layout shows possible clusters of
<span class="gu">@@ -385,7 +804,87 @@ def spectral_layout(G, weight=&#39;weight&#39;, scale=1, center=None, dim=2):</span>
<span class="w"> </span>    For larger graphs (&gt;500 nodes) this will use the SciPy sparse
<span class="w"> </span>    eigenvalue solver (ARPACK).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # handle some special cases that break the eigensolvers</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center, dim)</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) &lt;= 2:</span>
<span class="gi">+        if len(G) == 0:</span>
<span class="gi">+            pos = np.array([])</span>
<span class="gi">+        elif len(G) == 1:</span>
<span class="gi">+            pos = np.array([center])</span>
<span class="gi">+        else:</span>
<span class="gi">+            pos = np.array([np.zeros(dim), np.array(center) * 2.0])</span>
<span class="gi">+        return dict(zip(G, pos))</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Sparse matrix</span>
<span class="gi">+        if len(G) &lt; 500:  # dense solver is faster for small graphs</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+        A = nx.to_scipy_sparse_array(G, weight=weight, dtype=&quot;d&quot;)</span>
<span class="gi">+        # Symmetrize directed graphs</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            A = A + np.transpose(A)</span>
<span class="gi">+        pos = _sparse_spectral(A, dim)</span>
<span class="gi">+    except (ImportError, ValueError):</span>
<span class="gi">+        # Dense matrix</span>
<span class="gi">+        A = nx.to_numpy_array(G, weight=weight)</span>
<span class="gi">+        # Symmetrize directed graphs</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            A += A.T</span>
<span class="gi">+        pos = _spectral(A, dim)</span>
<span class="gi">+</span>
<span class="gi">+    pos = rescale_layout(pos, scale=scale) + center</span>
<span class="gi">+    pos = dict(zip(G, pos))</span>
<span class="gi">+    return pos</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _spectral(A, dim=2):</span>
<span class="gi">+    # Input adjacency matrix A</span>
<span class="gi">+    # Uses dense eigenvalue solver from numpy</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        nnodes, _ = A.shape</span>
<span class="gi">+    except AttributeError as err:</span>
<span class="gi">+        msg = &quot;spectral() takes an adjacency matrix as input&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg) from err</span>
<span class="gi">+</span>
<span class="gi">+    # form Laplacian matrix where D is diagonal of degrees</span>
<span class="gi">+    D = np.identity(nnodes, dtype=A.dtype) * np.sum(A, axis=1)</span>
<span class="gi">+    L = D - A</span>
<span class="gi">+</span>
<span class="gi">+    eigenvalues, eigenvectors = np.linalg.eig(L)</span>
<span class="gi">+    # sort and keep smallest nonzero</span>
<span class="gi">+    index = np.argsort(eigenvalues)[1 : dim + 1]  # 0 index is zero eigenvalue</span>
<span class="gi">+    return np.real(eigenvectors[:, index])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _sparse_spectral(A, dim=2):</span>
<span class="gi">+    # Input adjacency matrix A</span>
<span class="gi">+    # Uses sparse eigenvalue solver from scipy</span>
<span class="gi">+    # Could use multilevel methods here, see Koren &quot;On spectral graph drawing&quot;</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        nnodes, _ = A.shape</span>
<span class="gi">+    except AttributeError as err:</span>
<span class="gi">+        msg = &quot;sparse_spectral() takes an adjacency matrix as input&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg) from err</span>
<span class="gi">+</span>
<span class="gi">+    # form Laplacian matrix</span>
<span class="gi">+    # TODO: Rm csr_array wrapper in favor of spdiags array constructor when available</span>
<span class="gi">+    D = sp.sparse.csr_array(sp.sparse.spdiags(A.sum(axis=1), 0, nnodes, nnodes))</span>
<span class="gi">+    L = D - A</span>
<span class="gi">+</span>
<span class="gi">+    k = dim + 1</span>
<span class="gi">+    # number of Lanczos vectors for ARPACK solver.What is the right scaling?</span>
<span class="gi">+    ncv = max(2 * k + 1, int(np.sqrt(nnodes)))</span>
<span class="gi">+    # return smallest k eigenvalues and eigenvectors</span>
<span class="gi">+    eigenvalues, eigenvectors = sp.sparse.linalg.eigsh(L, k, which=&quot;SM&quot;, ncv=ncv)</span>
<span class="gi">+    index = np.argsort(eigenvalues)[1:k]  # 0 index is zero eigenvalue</span>
<span class="gi">+    return np.real(eigenvectors[:, index])</span>


<span class="w"> </span>def planar_layout(G, scale=1, center=None, dim=2):
<span class="gu">@@ -421,11 +920,31 @@ def planar_layout(G, scale=1, center=None, dim=2):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.path_graph(4)
<span class="w"> </span>    &gt;&gt;&gt; pos = nx.planar_layout(G)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if dim != 2:</span>
<span class="gi">+        raise ValueError(&quot;can only handle 2 dimensions&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center, dim)</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>

<span class="gi">+    if isinstance(G, nx.PlanarEmbedding):</span>
<span class="gi">+        embedding = G</span>
<span class="gi">+    else:</span>
<span class="gi">+        is_planar, embedding = nx.check_planarity(G)</span>
<span class="gi">+        if not is_planar:</span>
<span class="gi">+            raise nx.NetworkXException(&quot;G is not planar.&quot;)</span>
<span class="gi">+    pos = nx.combinatorial_embedding_to_pos(embedding)</span>
<span class="gi">+    node_list = list(embedding)</span>
<span class="gi">+    pos = np.vstack([pos[x] for x in node_list])</span>
<span class="gi">+    pos = pos.astype(np.float64)</span>
<span class="gi">+    pos = rescale_layout(pos, scale=scale) + center</span>
<span class="gi">+    return dict(zip(node_list, pos))</span>

<span class="gd">-def spiral_layout(G, scale=1, center=None, dim=2, resolution=0.35,</span>
<span class="gd">-    equidistant=False):</span>
<span class="gi">+</span>
<span class="gi">+def spiral_layout(G, scale=1, center=None, dim=2, resolution=0.35, equidistant=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Position nodes in a spiral layout.

<span class="w"> </span>    Parameters
<span class="gu">@@ -469,11 +988,42 @@ def spiral_layout(G, scale=1, center=None, dim=2, resolution=0.35,</span>
<span class="w"> </span>    This algorithm currently only works in two dimensions.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if dim != 2:</span>
<span class="gi">+        raise ValueError(&quot;can only handle 2 dimensions&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center, dim)</span>

<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+    if len(G) == 1:</span>
<span class="gi">+        return {nx.utils.arbitrary_element(G): center}</span>

<span class="gd">-def multipartite_layout(G, subset_key=&#39;subset&#39;, align=&#39;vertical&#39;, scale=1,</span>
<span class="gd">-    center=None):</span>
<span class="gi">+    pos = []</span>
<span class="gi">+    if equidistant:</span>
<span class="gi">+        chord = 1</span>
<span class="gi">+        step = 0.5</span>
<span class="gi">+        theta = resolution</span>
<span class="gi">+        theta += chord / (step * theta)</span>
<span class="gi">+        for _ in range(len(G)):</span>
<span class="gi">+            r = step * theta</span>
<span class="gi">+            theta += chord / r</span>
<span class="gi">+            pos.append([np.cos(theta) * r, np.sin(theta) * r])</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        dist = np.arange(len(G), dtype=float)</span>
<span class="gi">+        angle = resolution * dist</span>
<span class="gi">+        pos = np.transpose(dist * np.array([np.cos(angle), np.sin(angle)]))</span>
<span class="gi">+</span>
<span class="gi">+    pos = rescale_layout(np.array(pos), scale=scale) + center</span>
<span class="gi">+</span>
<span class="gi">+    pos = dict(zip(G, pos))</span>
<span class="gi">+</span>
<span class="gi">+    return pos</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def multipartite_layout(G, subset_key=&quot;subset&quot;, align=&quot;vertical&quot;, scale=1, center=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Position nodes in layers of straight lines.

<span class="w"> </span>    Parameters
<span class="gu">@@ -519,11 +1069,67 @@ def multipartite_layout(G, subset_key=&#39;subset&#39;, align=&#39;vertical&#39;, scale=1,</span>
<span class="w"> </span>    have subset_key data, they will be placed in the corresponding layers.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def arf_layout(G, pos=None, scaling=1, a=1.1, etol=1e-06, dt=0.001,</span>
<span class="gd">-    max_iter=1000):</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if align not in (&quot;vertical&quot;, &quot;horizontal&quot;):</span>
<span class="gi">+        msg = &quot;align must be either vertical or horizontal.&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    G, center = _process_params(G, center=center, dim=2)</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # check if subset_key is dict-like</span>
<span class="gi">+        if len(G) != sum(len(nodes) for nodes in subset_key.values()):</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;all nodes must be in one subset of `subset_key` dict&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        # subset_key is not a dict, hence a string</span>
<span class="gi">+        node_to_subset = nx.get_node_attributes(G, subset_key)</span>
<span class="gi">+        if len(node_to_subset) != len(G):</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;all nodes need a subset_key attribute: {subset_key}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        subset_key = nx.utils.groups(node_to_subset)</span>
<span class="gi">+</span>
<span class="gi">+    # Sort by layer, if possible</span>
<span class="gi">+    try:</span>
<span class="gi">+        layers = dict(sorted(subset_key.items()))</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        layers = subset_key</span>
<span class="gi">+</span>
<span class="gi">+    pos = None</span>
<span class="gi">+    nodes = []</span>
<span class="gi">+    width = len(layers)</span>
<span class="gi">+    for i, layer in enumerate(layers.values()):</span>
<span class="gi">+        height = len(layer)</span>
<span class="gi">+        xs = np.repeat(i, height)</span>
<span class="gi">+        ys = np.arange(0, height, dtype=float)</span>
<span class="gi">+        offset = ((width - 1) / 2, (height - 1) / 2)</span>
<span class="gi">+        layer_pos = np.column_stack([xs, ys]) - offset</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            pos = layer_pos</span>
<span class="gi">+        else:</span>
<span class="gi">+            pos = np.concatenate([pos, layer_pos])</span>
<span class="gi">+        nodes.extend(layer)</span>
<span class="gi">+    pos = rescale_layout(pos, scale=scale) + center</span>
<span class="gi">+    if align == &quot;horizontal&quot;:</span>
<span class="gi">+        pos = pos[:, ::-1]  # swap x and y coords</span>
<span class="gi">+    pos = dict(zip(nodes, pos))</span>
<span class="gi">+    return pos</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def arf_layout(</span>
<span class="gi">+    G,</span>
<span class="gi">+    pos=None,</span>
<span class="gi">+    scaling=1,</span>
<span class="gi">+    a=1.1,</span>
<span class="gi">+    etol=1e-6,</span>
<span class="gi">+    dt=1e-3,</span>
<span class="gi">+    max_iter=1000,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Arf layout for networkx

<span class="w"> </span>    The attractive and repulsive forces (arf) layout [1]
<span class="gu">@@ -569,7 +1175,62 @@ def arf_layout(G, pos=None, scaling=1, a=1.1, etol=1e-06, dt=0.001,</span>
<span class="w"> </span>    &gt;&gt;&gt; pos = nx.arf_layout(G)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if a &lt;= 1:</span>
<span class="gi">+        msg = &quot;The parameter a should be larger than 1&quot;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    pos_tmp = nx.random_layout(G)</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = pos_tmp</span>
<span class="gi">+    else:</span>
<span class="gi">+        for node in G.nodes():</span>
<span class="gi">+            if node not in pos:</span>
<span class="gi">+                pos[node] = pos_tmp[node].copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize spring constant matrix</span>
<span class="gi">+    N = len(G)</span>
<span class="gi">+    # No nodes no computation</span>
<span class="gi">+    if N == 0:</span>
<span class="gi">+        return pos</span>
<span class="gi">+</span>
<span class="gi">+    # init force of springs</span>
<span class="gi">+    K = np.ones((N, N)) - np.eye(N)</span>
<span class="gi">+    node_order = {node: i for i, node in enumerate(G)}</span>
<span class="gi">+    for x, y in G.edges():</span>
<span class="gi">+        if x != y:</span>
<span class="gi">+            idx, jdx = (node_order[i] for i in (x, y))</span>
<span class="gi">+            K[idx, jdx] = a</span>
<span class="gi">+</span>
<span class="gi">+    # vectorize values</span>
<span class="gi">+    p = np.asarray(list(pos.values()))</span>
<span class="gi">+</span>
<span class="gi">+    # equation 10 in [1]</span>
<span class="gi">+    rho = scaling * np.sqrt(N)</span>
<span class="gi">+</span>
<span class="gi">+    # looping variables</span>
<span class="gi">+    error = etol + 1</span>
<span class="gi">+    n_iter = 0</span>
<span class="gi">+    while error &gt; etol:</span>
<span class="gi">+        diff = p[:, np.newaxis] - p[np.newaxis]</span>
<span class="gi">+        A = np.linalg.norm(diff, axis=-1)[..., np.newaxis]</span>
<span class="gi">+        # attraction_force - repulsions force</span>
<span class="gi">+        # suppress nans due to division; caused by diagonal set to zero.</span>
<span class="gi">+        # Does not affect the computation due to nansum</span>
<span class="gi">+        with warnings.catch_warnings():</span>
<span class="gi">+            warnings.simplefilter(&quot;ignore&quot;)</span>
<span class="gi">+            change = K[..., np.newaxis] * diff - rho / A * diff</span>
<span class="gi">+        change = np.nansum(change, axis=0)</span>
<span class="gi">+        p += change * dt</span>
<span class="gi">+</span>
<span class="gi">+        error = np.linalg.norm(change, axis=-1).sum()</span>
<span class="gi">+        if n_iter &gt; max_iter:</span>
<span class="gi">+            break</span>
<span class="gi">+        n_iter += 1</span>
<span class="gi">+    return dict(zip(G.nodes(), p))</span>


<span class="w"> </span>def rescale_layout(pos, scale=1):
<span class="gu">@@ -601,7 +1262,15 @@ def rescale_layout(pos, scale=1):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    rescale_layout_dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    # Find max length over all dimensions</span>
<span class="gi">+    pos -= pos.mean(axis=0)</span>
<span class="gi">+    lim = np.abs(pos).max()  # max coordinate for all axes</span>
<span class="gi">+    # rescale to (-scale, scale) in all directions, preserves aspect</span>
<span class="gi">+    if lim &gt; 0:</span>
<span class="gi">+        pos *= scale / lim</span>
<span class="gi">+    return pos</span>


<span class="w"> </span>def rescale_layout_dict(pos, scale=1):
<span class="gu">@@ -633,10 +1302,16 @@ def rescale_layout_dict(pos, scale=1):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    rescale_layout
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if not pos:  # empty_graph</span>
<span class="gi">+        return {}</span>
<span class="gi">+    pos_v = np.array(list(pos.values()))</span>
<span class="gi">+    pos_v = rescale_layout(pos_v, scale=scale)</span>
<span class="gi">+    return dict(zip(pos, pos_v))</span>


<span class="gd">-def bfs_layout(G, start, *, align=&#39;vertical&#39;, scale=1, center=None):</span>
<span class="gi">+def bfs_layout(G, start, *, align=&quot;vertical&quot;, scale=1, center=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Position nodes according to breadth-first search algorithm.

<span class="w"> </span>    Parameters
<span class="gu">@@ -666,4 +1341,18 @@ def bfs_layout(G, start, *, align=&#39;vertical&#39;, scale=1, center=None):</span>
<span class="w"> </span>    try to minimize edge crossings.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G, center = _process_params(G, center, 2)</span>
<span class="gi">+</span>
<span class="gi">+    # Compute layers with BFS</span>
<span class="gi">+    layers = dict(enumerate(nx.bfs_layers(G, start)))</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) != sum(len(nodes) for nodes in layers.values()):</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;bfs_layout didn&#39;t include all nodes. Perhaps use input graph:\n&quot;</span>
<span class="gi">+            &quot;        G.subgraph(nx.node_connected_component(G, start))&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Compute node positions with multipartite_layout</span>
<span class="gi">+    return multipartite_layout(</span>
<span class="gi">+        G, subset_key=layers, align=align, scale=scale, center=center</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/networkx/drawing/nx_agraph.py b/networkx/drawing/nx_agraph.py</span>
<span class="gh">index b2be34698..f91031fca 100644</span>
<span class="gd">--- a/networkx/drawing/nx_agraph.py</span>
<span class="gi">+++ b/networkx/drawing/nx_agraph.py</span>
<span class="gu">@@ -19,9 +19,18 @@ See Also</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import os
<span class="w"> </span>import tempfile
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;from_agraph&#39;, &#39;to_agraph&#39;, &#39;write_dot&#39;, &#39;read_dot&#39;,</span>
<span class="gd">-    &#39;graphviz_layout&#39;, &#39;pygraphviz_layout&#39;, &#39;view_pygraphviz&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;from_agraph&quot;,</span>
<span class="gi">+    &quot;to_agraph&quot;,</span>
<span class="gi">+    &quot;write_dot&quot;,</span>
<span class="gi">+    &quot;read_dot&quot;,</span>
<span class="gi">+    &quot;graphviz_layout&quot;,</span>
<span class="gi">+    &quot;pygraphviz_layout&quot;,</span>
<span class="gi">+    &quot;view_pygraphviz&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -56,7 +65,49 @@ def from_agraph(A, create_using=None):</span>
<span class="w"> </span>    attribute or the value 1 if no edge weight attribute is found.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if create_using is None:</span>
<span class="gi">+        if A.is_directed():</span>
<span class="gi">+            if A.is_strict():</span>
<span class="gi">+                create_using = nx.DiGraph</span>
<span class="gi">+            else:</span>
<span class="gi">+                create_using = nx.MultiDiGraph</span>
<span class="gi">+        else:</span>
<span class="gi">+            if A.is_strict():</span>
<span class="gi">+                create_using = nx.Graph</span>
<span class="gi">+            else:</span>
<span class="gi">+                create_using = nx.MultiGraph</span>
<span class="gi">+</span>
<span class="gi">+    # assign defaults</span>
<span class="gi">+    N = nx.empty_graph(0, create_using)</span>
<span class="gi">+    if A.name is not None:</span>
<span class="gi">+        N.name = A.name</span>
<span class="gi">+</span>
<span class="gi">+    # add graph attributes</span>
<span class="gi">+    N.graph.update(A.graph_attr)</span>
<span class="gi">+</span>
<span class="gi">+    # add nodes, attributes to N.node_attr</span>
<span class="gi">+    for n in A.nodes():</span>
<span class="gi">+        str_attr = {str(k): v for k, v in n.attr.items()}</span>
<span class="gi">+        N.add_node(str(n), **str_attr)</span>
<span class="gi">+</span>
<span class="gi">+    # add edges, assign edge data as dictionary of attributes</span>
<span class="gi">+    for e in A.edges():</span>
<span class="gi">+        u, v = str(e[0]), str(e[1])</span>
<span class="gi">+        attr = dict(e.attr)</span>
<span class="gi">+        str_attr = {str(k): v for k, v in attr.items()}</span>
<span class="gi">+        if not N.is_multigraph():</span>
<span class="gi">+            if e.name is not None:</span>
<span class="gi">+                str_attr[&quot;key&quot;] = e.name</span>
<span class="gi">+            N.add_edge(u, v, **str_attr)</span>
<span class="gi">+        else:</span>
<span class="gi">+            N.add_edge(u, v, key=e.name, **str_attr)</span>
<span class="gi">+</span>
<span class="gi">+    # add default attributes for graph, nodes, and edges</span>
<span class="gi">+    # hang them on N.graph_attr</span>
<span class="gi">+    N.graph[&quot;graph&quot;] = dict(A.graph_attr)</span>
<span class="gi">+    N.graph[&quot;node&quot;] = dict(A.node_attr)</span>
<span class="gi">+    N.graph[&quot;edge&quot;] = dict(A.edge_attr)</span>
<span class="gi">+    return N</span>


<span class="w"> </span>def to_agraph(N):
<span class="gu">@@ -79,7 +130,55 @@ def to_agraph(N):</span>
<span class="w"> </span>    and then updated with the calling arguments if any.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        import pygraphviz</span>
<span class="gi">+    except ImportError as err:</span>
<span class="gi">+        raise ImportError(&quot;requires pygraphviz http://pygraphviz.github.io/&quot;) from err</span>
<span class="gi">+    directed = N.is_directed()</span>
<span class="gi">+    strict = nx.number_of_selfloops(N) == 0 and not N.is_multigraph()</span>
<span class="gi">+</span>
<span class="gi">+    for node in N:</span>
<span class="gi">+        if &quot;pos&quot; in N.nodes[node]:</span>
<span class="gi">+            N.nodes[node][&quot;pos&quot;] = &quot;{},{}!&quot;.format(</span>
<span class="gi">+                N.nodes[node][&quot;pos&quot;][0], N.nodes[node][&quot;pos&quot;][1]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    A = pygraphviz.AGraph(name=N.name, strict=strict, directed=directed)</span>
<span class="gi">+</span>
<span class="gi">+    # default graph attributes</span>
<span class="gi">+    A.graph_attr.update(N.graph.get(&quot;graph&quot;, {}))</span>
<span class="gi">+    A.node_attr.update(N.graph.get(&quot;node&quot;, {}))</span>
<span class="gi">+    A.edge_attr.update(N.graph.get(&quot;edge&quot;, {}))</span>
<span class="gi">+</span>
<span class="gi">+    A.graph_attr.update(</span>
<span class="gi">+        (k, v) for k, v in N.graph.items() if k not in (&quot;graph&quot;, &quot;node&quot;, &quot;edge&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # add nodes</span>
<span class="gi">+    for n, nodedata in N.nodes(data=True):</span>
<span class="gi">+        A.add_node(n)</span>
<span class="gi">+        # Add node data</span>
<span class="gi">+        a = A.get_node(n)</span>
<span class="gi">+        a.attr.update({k: str(v) for k, v in nodedata.items()})</span>
<span class="gi">+</span>
<span class="gi">+    # loop over edges</span>
<span class="gi">+    if N.is_multigraph():</span>
<span class="gi">+        for u, v, key, edgedata in N.edges(data=True, keys=True):</span>
<span class="gi">+            str_edgedata = {k: str(v) for k, v in edgedata.items() if k != &quot;key&quot;}</span>
<span class="gi">+            A.add_edge(u, v, key=str(key))</span>
<span class="gi">+            # Add edge data</span>
<span class="gi">+            a = A.get_edge(u, v)</span>
<span class="gi">+            a.attr.update(str_edgedata)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u, v, edgedata in N.edges(data=True):</span>
<span class="gi">+            str_edgedata = {k: str(v) for k, v in edgedata.items()}</span>
<span class="gi">+            A.add_edge(u, v)</span>
<span class="gi">+            # Add edge data</span>
<span class="gi">+            a = A.get_edge(u, v)</span>
<span class="gi">+            a.attr.update(str_edgedata)</span>
<span class="gi">+</span>
<span class="gi">+    return A</span>


<span class="w"> </span>def write_dot(G, path):
<span class="gu">@@ -98,10 +197,13 @@ def write_dot(G, path):</span>
<span class="w"> </span>    Note that some graphviz layouts are not guaranteed to be deterministic,
<span class="w"> </span>    see https://gitlab.com/graphviz/graphviz/-/issues/1767 for more info.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    A = to_agraph(G)</span>
<span class="gi">+    A.write(path)</span>
<span class="gi">+    A.clear()</span>
<span class="gi">+    return</span>


<span class="gd">-@nx._dispatchable(name=&#39;agraph_read_dot&#39;, graphs=None, returns_graph=True)</span>
<span class="gi">+@nx._dispatchable(name=&quot;agraph_read_dot&quot;, graphs=None, returns_graph=True)</span>
<span class="w"> </span>def read_dot(path):
<span class="w"> </span>    &quot;&quot;&quot;Returns a NetworkX graph from a dot file on path.

<span class="gu">@@ -110,10 +212,19 @@ def read_dot(path):</span>
<span class="w"> </span>    path : file or string
<span class="w"> </span>       File name or file handle to read.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def graphviz_layout(G, prog=&#39;neato&#39;, root=None, args=&#39;&#39;):</span>
<span class="gi">+    try:</span>
<span class="gi">+        import pygraphviz</span>
<span class="gi">+    except ImportError as err:</span>
<span class="gi">+        raise ImportError(</span>
<span class="gi">+            &quot;read_dot() requires pygraphviz http://pygraphviz.github.io/&quot;</span>
<span class="gi">+        ) from err</span>
<span class="gi">+    A = pygraphviz.AGraph(file=path)</span>
<span class="gi">+    gr = from_agraph(A)</span>
<span class="gi">+    A.clear()</span>
<span class="gi">+    return gr</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def graphviz_layout(G, prog=&quot;neato&quot;, root=None, args=&quot;&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create node positions for G using Graphviz.

<span class="w"> </span>    Parameters
<span class="gu">@@ -144,10 +255,10 @@ def graphviz_layout(G, prog=&#39;neato&#39;, root=None, args=&#39;&#39;):</span>
<span class="w"> </span>    Note that some graphviz layouts are not guaranteed to be deterministic,
<span class="w"> </span>    see https://gitlab.com/graphviz/graphviz/-/issues/1767 for more info.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return pygraphviz_layout(G, prog=prog, root=root, args=args)</span>


<span class="gd">-def pygraphviz_layout(G, prog=&#39;neato&#39;, root=None, args=&#39;&#39;):</span>
<span class="gi">+def pygraphviz_layout(G, prog=&quot;neato&quot;, root=None, args=&quot;&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create node positions for G using Graphviz.

<span class="w"> </span>    Parameters
<span class="gu">@@ -187,12 +298,30 @@ def pygraphviz_layout(G, prog=&#39;neato&#39;, root=None, args=&#39;&#39;):</span>
<span class="w"> </span>    Note that some graphviz layouts are not guaranteed to be deterministic,
<span class="w"> </span>    see https://gitlab.com/graphviz/graphviz/-/issues/1767 for more info.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx.utils.open_file(5, &#39;w+b&#39;)</span>
<span class="gd">-def view_pygraphviz(G, edgelabel=None, prog=&#39;dot&#39;, args=&#39;&#39;, suffix=&#39;&#39;, path</span>
<span class="gd">-    =None, show=True):</span>
<span class="gi">+    try:</span>
<span class="gi">+        import pygraphviz</span>
<span class="gi">+    except ImportError as err:</span>
<span class="gi">+        raise ImportError(&quot;requires pygraphviz http://pygraphviz.github.io/&quot;) from err</span>
<span class="gi">+    if root is not None:</span>
<span class="gi">+        args += f&quot;-Groot={root}&quot;</span>
<span class="gi">+    A = to_agraph(G)</span>
<span class="gi">+    A.layout(prog=prog, args=args)</span>
<span class="gi">+    node_pos = {}</span>
<span class="gi">+    for n in G:</span>
<span class="gi">+        node = pygraphviz.Node(A, n)</span>
<span class="gi">+        try:</span>
<span class="gi">+            xs = node.attr[&quot;pos&quot;].split(&quot;,&quot;)</span>
<span class="gi">+            node_pos[n] = tuple(float(x) for x in xs)</span>
<span class="gi">+        except:</span>
<span class="gi">+            print(&quot;no position for node&quot;, n)</span>
<span class="gi">+            node_pos[n] = (0.0, 0.0)</span>
<span class="gi">+    return node_pos</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.open_file(5, &quot;w+b&quot;)</span>
<span class="gi">+def view_pygraphviz(</span>
<span class="gi">+    G, edgelabel=None, prog=&quot;dot&quot;, args=&quot;&quot;, suffix=&quot;&quot;, path=None, show=True</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Views the graph G using the specified layout algorithm.

<span class="w"> </span>    Parameters
<span class="gu">@@ -237,4 +366,100 @@ def view_pygraphviz(G, edgelabel=None, prog=&#39;dot&#39;, args=&#39;&#39;, suffix=&#39;&#39;, path</span>
<span class="w"> </span>    see https://gitlab.com/graphviz/graphviz/-/issues/1767 for more info.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not len(G):</span>
<span class="gi">+        raise nx.NetworkXException(&quot;An empty graph cannot be drawn.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # If we are providing default values for graphviz, these must be set</span>
<span class="gi">+    # before any nodes or edges are added to the PyGraphviz graph object.</span>
<span class="gi">+    # The reason for this is that default values only affect incoming objects.</span>
<span class="gi">+    # If you change the default values after the objects have been added,</span>
<span class="gi">+    # then they inherit no value and are set only if explicitly set.</span>
<span class="gi">+</span>
<span class="gi">+    # to_agraph() uses these values.</span>
<span class="gi">+    attrs = [&quot;edge&quot;, &quot;node&quot;, &quot;graph&quot;]</span>
<span class="gi">+    for attr in attrs:</span>
<span class="gi">+        if attr not in G.graph:</span>
<span class="gi">+            G.graph[attr] = {}</span>
<span class="gi">+</span>
<span class="gi">+    # These are the default values.</span>
<span class="gi">+    edge_attrs = {&quot;fontsize&quot;: &quot;10&quot;}</span>
<span class="gi">+    node_attrs = {</span>
<span class="gi">+        &quot;style&quot;: &quot;filled&quot;,</span>
<span class="gi">+        &quot;fillcolor&quot;: &quot;#0000FF40&quot;,</span>
<span class="gi">+        &quot;height&quot;: &quot;0.75&quot;,</span>
<span class="gi">+        &quot;width&quot;: &quot;0.75&quot;,</span>
<span class="gi">+        &quot;shape&quot;: &quot;circle&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    graph_attrs = {}</span>
<span class="gi">+</span>
<span class="gi">+    def update_attrs(which, attrs):</span>
<span class="gi">+        # Update graph attributes. Return list of those which were added.</span>
<span class="gi">+        added = []</span>
<span class="gi">+        for k, v in attrs.items():</span>
<span class="gi">+            if k not in G.graph[which]:</span>
<span class="gi">+                G.graph[which][k] = v</span>
<span class="gi">+                added.append(k)</span>
<span class="gi">+</span>
<span class="gi">+    def clean_attrs(which, added):</span>
<span class="gi">+        # Remove added attributes</span>
<span class="gi">+        for attr in added:</span>
<span class="gi">+            del G.graph[which][attr]</span>
<span class="gi">+        if not G.graph[which]:</span>
<span class="gi">+            del G.graph[which]</span>
<span class="gi">+</span>
<span class="gi">+    # Update all default values</span>
<span class="gi">+    update_attrs(&quot;edge&quot;, edge_attrs)</span>
<span class="gi">+    update_attrs(&quot;node&quot;, node_attrs)</span>
<span class="gi">+    update_attrs(&quot;graph&quot;, graph_attrs)</span>
<span class="gi">+</span>
<span class="gi">+    # Convert to agraph, so we inherit default values</span>
<span class="gi">+    A = to_agraph(G)</span>
<span class="gi">+</span>
<span class="gi">+    # Remove the default values we added to the original graph.</span>
<span class="gi">+    clean_attrs(&quot;edge&quot;, edge_attrs)</span>
<span class="gi">+    clean_attrs(&quot;node&quot;, node_attrs)</span>
<span class="gi">+    clean_attrs(&quot;graph&quot;, graph_attrs)</span>
<span class="gi">+</span>
<span class="gi">+    # If the user passed in an edgelabel, we update the labels for all edges.</span>
<span class="gi">+    if edgelabel is not None:</span>
<span class="gi">+        if not callable(edgelabel):</span>
<span class="gi">+</span>
<span class="gi">+            def func(data):</span>
<span class="gi">+                return &quot;&quot;.join([&quot;  &quot;, str(data[edgelabel]), &quot;  &quot;])</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            func = edgelabel</span>
<span class="gi">+</span>
<span class="gi">+        # update all the edge labels</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            for u, v, key, data in G.edges(keys=True, data=True):</span>
<span class="gi">+                # PyGraphviz doesn&#39;t convert the key to a string. See #339</span>
<span class="gi">+                edge = A.get_edge(u, v, str(key))</span>
<span class="gi">+                edge.attr[&quot;label&quot;] = str(func(data))</span>
<span class="gi">+        else:</span>
<span class="gi">+            for u, v, data in G.edges(data=True):</span>
<span class="gi">+                edge = A.get_edge(u, v)</span>
<span class="gi">+                edge.attr[&quot;label&quot;] = str(func(data))</span>
<span class="gi">+</span>
<span class="gi">+    if path is None:</span>
<span class="gi">+        ext = &quot;png&quot;</span>
<span class="gi">+        if suffix:</span>
<span class="gi">+            suffix = f&quot;_{suffix}.{ext}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            suffix = f&quot;.{ext}&quot;</span>
<span class="gi">+        path = tempfile.NamedTemporaryFile(suffix=suffix, delete=False)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Assume the decorator worked and it is a file-object.</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Write graph to file</span>
<span class="gi">+    A.draw(path=path, format=None, prog=prog, args=args)</span>
<span class="gi">+    path.close()</span>
<span class="gi">+</span>
<span class="gi">+    # Show graph in a new window (depends on platform configuration)</span>
<span class="gi">+    if show:</span>
<span class="gi">+        from PIL import Image</span>
<span class="gi">+</span>
<span class="gi">+        Image.open(path.name).show()</span>
<span class="gi">+</span>
<span class="gi">+    return path.name, A</span>
<span class="gh">diff --git a/networkx/drawing/nx_latex.py b/networkx/drawing/nx_latex.py</span>
<span class="gh">index fc0638643..8bc6ba219 100644</span>
<span class="gd">--- a/networkx/drawing/nx_latex.py</span>
<span class="gi">+++ b/networkx/drawing/nx_latex.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+r&quot;&quot;&quot;</span>
<span class="w"> </span>*****
<span class="w"> </span>LaTeX
<span class="w"> </span>*****
<span class="gu">@@ -14,7 +14,7 @@ To construct a figure with subfigures for each graph to be shown, provide</span>
<span class="w"> </span>``to_latex`` or ``write_latex`` a list of graphs, a list of subcaptions,
<span class="w"> </span>and a number of rows of subfigures inside the figure.

<span class="gd">-To be able to refer to the figures or subfigures in latex using ``\\\\ref``,</span>
<span class="gi">+To be able to refer to the figures or subfigures in latex using ``\\ref``,</span>
<span class="w"> </span>the keyword ``latex_label`` is available for figures and `sub_labels` for
<span class="w"> </span>a list of labels, one for each subfigure.

<span class="gu">@@ -84,14 +84,14 @@ If you want **subfigures** each containing one graph, you can input a list of gr</span>
<span class="w"> </span>&gt;&gt;&gt; pos = nx.circular_layout(H3)
<span class="w"> </span>&gt;&gt;&gt; latex_code = nx.to_latex(H3, pos, node_options=node_color, edge_options=edge_width)
<span class="w"> </span>&gt;&gt;&gt; print(latex_code)
<span class="gd">-\\documentclass{report}</span>
<span class="gd">-\\usepackage{tikz}</span>
<span class="gd">-\\usepackage{subcaption}</span>
<span class="gi">+\documentclass{report}</span>
<span class="gi">+\usepackage{tikz}</span>
<span class="gi">+\usepackage{subcaption}</span>
<span class="w"> </span>&lt;BLANKLINE&gt;
<span class="gd">-\\begin{document}</span>
<span class="gd">-\\begin{figure}</span>
<span class="gd">-  \\begin{tikzpicture}</span>
<span class="gd">-      \\draw</span>
<span class="gi">+\begin{document}</span>
<span class="gi">+\begin{figure}</span>
<span class="gi">+  \begin{tikzpicture}</span>
<span class="gi">+      \draw</span>
<span class="w"> </span>        (1.0, 0.0) node[red] (0){0}
<span class="w"> </span>        (0.707, 0.707) node[orange] (1){1}
<span class="w"> </span>        (-0.0, 1.0) node[blue] (2){2}
<span class="gu">@@ -100,18 +100,18 @@ If you want **subfigures** each containing one graph, you can input a list of gr</span>
<span class="w"> </span>        (-0.707, -0.707) node (5){5}
<span class="w"> </span>        (0.0, -1.0) node (6){6}
<span class="w"> </span>        (0.707, -0.707) node (7){7};
<span class="gd">-      \\begin{scope}[-]</span>
<span class="gd">-        \\draw[line width=1.5] (0) to (1);</span>
<span class="gd">-        \\draw[line width=1.5] (1) to (2);</span>
<span class="gd">-        \\draw[line width=1.5] (2) to (3);</span>
<span class="gd">-        \\draw[line width=1.5] (3) to (4);</span>
<span class="gd">-        \\draw[line width=1.5] (4) to (5);</span>
<span class="gd">-        \\draw[line width=1.5] (5) to (6);</span>
<span class="gd">-        \\draw[line width=1.5] (6) to (7);</span>
<span class="gd">-      \\end{scope}</span>
<span class="gd">-    \\end{tikzpicture}</span>
<span class="gd">-\\end{figure}</span>
<span class="gd">-\\end{document}</span>
<span class="gi">+      \begin{scope}[-]</span>
<span class="gi">+        \draw[line width=1.5] (0) to (1);</span>
<span class="gi">+        \draw[line width=1.5] (1) to (2);</span>
<span class="gi">+        \draw[line width=1.5] (2) to (3);</span>
<span class="gi">+        \draw[line width=1.5] (3) to (4);</span>
<span class="gi">+        \draw[line width=1.5] (4) to (5);</span>
<span class="gi">+        \draw[line width=1.5] (5) to (6);</span>
<span class="gi">+        \draw[line width=1.5] (6) to (7);</span>
<span class="gi">+      \end{scope}</span>
<span class="gi">+    \end{tikzpicture}</span>
<span class="gi">+\end{figure}</span>
<span class="gi">+\end{document}</span>

<span class="w"> </span>Notes
<span class="w"> </span>-----
<span class="gu">@@ -128,15 +128,29 @@ TikZ options details:   https://tikz.dev/tikz-actions</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import numbers
<span class="w"> </span>import os
<span class="gd">-import networkx as nx</span>
<span class="gd">-__all__ = [&#39;to_latex_raw&#39;, &#39;to_latex&#39;, &#39;write_latex&#39;]</span>

<span class="gi">+import networkx as nx</span>

<span class="gd">-@nx.utils.not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-def to_latex_raw(G, pos=&#39;pos&#39;, tikz_options=&#39;&#39;, default_node_options=&#39;&#39;,</span>
<span class="gd">-    node_options=&#39;node_options&#39;, node_label=&#39;label&#39;, default_edge_options=</span>
<span class="gd">-    &#39;&#39;, edge_options=&#39;edge_options&#39;, edge_label=&#39;label&#39;, edge_label_options</span>
<span class="gd">-    =&#39;edge_label_options&#39;):</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;to_latex_raw&quot;,</span>
<span class="gi">+    &quot;to_latex&quot;,</span>
<span class="gi">+    &quot;write_latex&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+def to_latex_raw(</span>
<span class="gi">+    G,</span>
<span class="gi">+    pos=&quot;pos&quot;,</span>
<span class="gi">+    tikz_options=&quot;&quot;,</span>
<span class="gi">+    default_node_options=&quot;&quot;,</span>
<span class="gi">+    node_options=&quot;node_options&quot;,</span>
<span class="gi">+    node_label=&quot;label&quot;,</span>
<span class="gi">+    default_edge_options=&quot;&quot;,</span>
<span class="gi">+    edge_options=&quot;edge_options&quot;,</span>
<span class="gi">+    edge_label=&quot;label&quot;,</span>
<span class="gi">+    edge_label_options=&quot;edge_label_options&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a string of the LaTeX/TikZ code to draw `G`

<span class="w"> </span>    This function produces just the code for the tikzpicture
<span class="gu">@@ -195,31 +209,127 @@ def to_latex_raw(G, pos=&#39;pos&#39;, tikz_options=&#39;&#39;, default_node_options=&#39;&#39;,</span>
<span class="w"> </span>    to_latex
<span class="w"> </span>    write_latex
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    i4 = &quot;\n    &quot;</span>
<span class="gi">+    i8 = &quot;\n        &quot;</span>
<span class="gi">+</span>
<span class="gi">+    # set up position dict</span>
<span class="gi">+    # TODO allow pos to be None and use a nice TikZ default</span>
<span class="gi">+    if not isinstance(pos, dict):</span>
<span class="gi">+        pos = nx.get_node_attributes(G, pos)</span>
<span class="gi">+    if not pos:</span>
<span class="gi">+        # circular layout with radius 2</span>
<span class="gi">+        pos = {n: f&quot;({round(360.0 * i / len(G), 3)}:2)&quot; for i, n in enumerate(G)}</span>
<span class="gi">+    for node in G:</span>
<span class="gi">+        if node not in pos:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;node {node} has no specified pos {pos}&quot;)</span>
<span class="gi">+        posnode = pos[node]</span>
<span class="gi">+        if not isinstance(posnode, str):</span>
<span class="gi">+            try:</span>
<span class="gi">+                posx, posy = posnode</span>
<span class="gi">+                pos[node] = f&quot;({round(posx, 3)}, {round(posy, 3)})&quot;</span>
<span class="gi">+            except (TypeError, ValueError):</span>
<span class="gi">+                msg = f&quot;position pos[{node}] is not 2-tuple or a string: {posnode}&quot;</span>
<span class="gi">+                raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # set up all the dicts</span>
<span class="gi">+    if not isinstance(node_options, dict):</span>
<span class="gi">+        node_options = nx.get_node_attributes(G, node_options)</span>
<span class="gi">+    if not isinstance(node_label, dict):</span>
<span class="gi">+        node_label = nx.get_node_attributes(G, node_label)</span>
<span class="gi">+    if not isinstance(edge_options, dict):</span>
<span class="gi">+        edge_options = nx.get_edge_attributes(G, edge_options)</span>
<span class="gi">+    if not isinstance(edge_label, dict):</span>
<span class="gi">+        edge_label = nx.get_edge_attributes(G, edge_label)</span>
<span class="gi">+    if not isinstance(edge_label_options, dict):</span>
<span class="gi">+        edge_label_options = nx.get_edge_attributes(G, edge_label_options)</span>
<span class="gi">+</span>
<span class="gi">+    # process default options (add brackets or not)</span>
<span class="gi">+    topts = &quot;&quot; if tikz_options == &quot;&quot; else f&quot;[{tikz_options.strip(&#39;[]&#39;)}]&quot;</span>
<span class="gi">+    defn = &quot;&quot; if default_node_options == &quot;&quot; else f&quot;[{default_node_options.strip(&#39;[]&#39;)}]&quot;</span>
<span class="gi">+    linestyle = f&quot;{&#39;-&gt;&#39; if G.is_directed() else &#39;-&#39;}&quot;</span>
<span class="gi">+    if default_edge_options == &quot;&quot;:</span>
<span class="gi">+        defe = &quot;[&quot; + linestyle + &quot;]&quot;</span>
<span class="gi">+    elif &quot;-&quot; in default_edge_options:</span>
<span class="gi">+        defe = default_edge_options</span>
<span class="gi">+    else:</span>
<span class="gi">+        defe = f&quot;[{linestyle},{default_edge_options.strip(&#39;[]&#39;)}]&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Construct the string line by line</span>
<span class="gi">+    result = &quot;  \\begin{tikzpicture}&quot; + topts</span>
<span class="gi">+    result += i4 + &quot;  \\draw&quot; + defn</span>
<span class="gi">+    # load the nodes</span>
<span class="gi">+    for n in G:</span>
<span class="gi">+        # node options goes inside square brackets</span>
<span class="gi">+        nopts = f&quot;[{node_options[n].strip(&#39;[]&#39;)}]&quot; if n in node_options else &quot;&quot;</span>
<span class="gi">+        # node text goes inside curly brackets {}</span>
<span class="gi">+        ntext = f&quot;{{{node_label[n]}}}&quot; if n in node_label else f&quot;{{{n}}}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        result += i8 + f&quot;{pos[n]} node{nopts} ({n}){ntext}&quot;</span>
<span class="gi">+    result += &quot;;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # load the edges</span>
<span class="gi">+    result += &quot;      \\begin{scope}&quot; + defe</span>
<span class="gi">+    for edge in G.edges:</span>
<span class="gi">+        u, v = edge[:2]</span>
<span class="gi">+        e_opts = f&quot;{edge_options[edge]}&quot;.strip(&quot;[]&quot;) if edge in edge_options else &quot;&quot;</span>
<span class="gi">+        # add loop options for selfloops if not present</span>
<span class="gi">+        if u == v and &quot;loop&quot; not in e_opts:</span>
<span class="gi">+            e_opts = &quot;loop,&quot; + e_opts</span>
<span class="gi">+        e_opts = f&quot;[{e_opts}]&quot; if e_opts != &quot;&quot; else &quot;&quot;</span>
<span class="gi">+        # TODO -- handle bending of multiedges</span>
<span class="gi">+</span>
<span class="gi">+        els = edge_label_options[edge] if edge in edge_label_options else &quot;&quot;</span>
<span class="gi">+        # edge label options goes inside square brackets []</span>
<span class="gi">+        els = f&quot;[{els.strip(&#39;[]&#39;)}]&quot;</span>
<span class="gi">+        # edge text is drawn using the TikZ node command inside curly brackets {}</span>
<span class="gi">+        e_label = f&quot; node{els} {{{edge_label[edge]}}}&quot; if edge in edge_label else &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        result += i8 + f&quot;\\draw{e_opts} ({u}) to{e_label} ({v});&quot;</span>
<span class="gi">+</span>
<span class="gi">+    result += &quot;\n      \\end{scope}\n    \\end{tikzpicture}\n&quot;</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_DOC_WRAPPER_TIKZ = r&quot;&quot;&quot;\documentclass{{report}}</span>
<span class="gi">+\usepackage{{tikz}}</span>
<span class="gi">+\usepackage{{subcaption}}</span>
<span class="gi">+</span>
<span class="gi">+\begin{{document}}</span>
<span class="gi">+{content}</span>
<span class="gi">+\end{{document}}&quot;&quot;&quot;</span>

<span class="gd">-_DOC_WRAPPER_TIKZ = &quot;&quot;&quot;\\documentclass{{report}}</span>
<span class="gd">-\\usepackage{{tikz}}</span>
<span class="gd">-\\usepackage{{subcaption}}</span>

<span class="gd">-\\begin{{document}}</span>
<span class="gd">-{content}</span>
<span class="gd">-\\end{{document}}&quot;&quot;&quot;</span>
<span class="gd">-_FIG_WRAPPER = &quot;&quot;&quot;\\begin{{figure}}</span>
<span class="gd">-{content}{caption}{label}</span>
<span class="gd">-\\end{{figure}}&quot;&quot;&quot;</span>
<span class="gd">-_SUBFIG_WRAPPER = &quot;&quot;&quot;  \\begin{{subfigure}}{{{size}\\textwidth}}</span>
<span class="gi">+_FIG_WRAPPER = r&quot;&quot;&quot;\begin{{figure}}</span>
<span class="w"> </span>{content}{caption}{label}
<span class="gd">-  \\end{{subfigure}}&quot;&quot;&quot;</span>
<span class="gi">+\end{{figure}}&quot;&quot;&quot;</span>


<span class="gd">-def to_latex(Gbunch, pos=&#39;pos&#39;, tikz_options=&#39;&#39;, default_node_options=&#39;&#39;,</span>
<span class="gd">-    node_options=&#39;node_options&#39;, node_label=&#39;node_label&#39;,</span>
<span class="gd">-    default_edge_options=&#39;&#39;, edge_options=&#39;edge_options&#39;, edge_label=</span>
<span class="gd">-    &#39;edge_label&#39;, edge_label_options=&#39;edge_label_options&#39;, caption=&#39;&#39;,</span>
<span class="gd">-    latex_label=&#39;&#39;, sub_captions=None, sub_labels=None, n_rows=1,</span>
<span class="gd">-    as_document=True, document_wrapper=_DOC_WRAPPER_TIKZ, figure_wrapper=</span>
<span class="gd">-    _FIG_WRAPPER, subfigure_wrapper=_SUBFIG_WRAPPER):</span>
<span class="gi">+_SUBFIG_WRAPPER = r&quot;&quot;&quot;  \begin{{subfigure}}{{{size}\textwidth}}</span>
<span class="gi">+{content}{caption}{label}</span>
<span class="gi">+  \end{{subfigure}}&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_latex(</span>
<span class="gi">+    Gbunch,</span>
<span class="gi">+    pos=&quot;pos&quot;,</span>
<span class="gi">+    tikz_options=&quot;&quot;,</span>
<span class="gi">+    default_node_options=&quot;&quot;,</span>
<span class="gi">+    node_options=&quot;node_options&quot;,</span>
<span class="gi">+    node_label=&quot;node_label&quot;,</span>
<span class="gi">+    default_edge_options=&quot;&quot;,</span>
<span class="gi">+    edge_options=&quot;edge_options&quot;,</span>
<span class="gi">+    edge_label=&quot;edge_label&quot;,</span>
<span class="gi">+    edge_label_options=&quot;edge_label_options&quot;,</span>
<span class="gi">+    caption=&quot;&quot;,</span>
<span class="gi">+    latex_label=&quot;&quot;,</span>
<span class="gi">+    sub_captions=None,</span>
<span class="gi">+    sub_labels=None,</span>
<span class="gi">+    n_rows=1,</span>
<span class="gi">+    as_document=True,</span>
<span class="gi">+    document_wrapper=_DOC_WRAPPER_TIKZ,</span>
<span class="gi">+    figure_wrapper=_FIG_WRAPPER,</span>
<span class="gi">+    subfigure_wrapper=_SUBFIG_WRAPPER,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return latex code to draw the graph(s) in `Gbunch`

<span class="w"> </span>    The TikZ drawing utility in LaTeX is used to draw the graph(s).
<span class="gu">@@ -311,10 +421,65 @@ def to_latex(Gbunch, pos=&#39;pos&#39;, tikz_options=&#39;&#39;, default_node_options=&#39;&#39;,</span>
<span class="w"> </span>    write_latex
<span class="w"> </span>    to_latex_raw
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx.utils.open_file(1, mode=&#39;w&#39;)</span>
<span class="gi">+    if hasattr(Gbunch, &quot;adj&quot;):</span>
<span class="gi">+        raw = to_latex_raw(</span>
<span class="gi">+            Gbunch,</span>
<span class="gi">+            pos,</span>
<span class="gi">+            tikz_options,</span>
<span class="gi">+            default_node_options,</span>
<span class="gi">+            node_options,</span>
<span class="gi">+            node_label,</span>
<span class="gi">+            default_edge_options,</span>
<span class="gi">+            edge_options,</span>
<span class="gi">+            edge_label,</span>
<span class="gi">+            edge_label_options,</span>
<span class="gi">+        )</span>
<span class="gi">+    else:  # iterator of graphs</span>
<span class="gi">+        sbf = subfigure_wrapper</span>
<span class="gi">+        size = 1 / n_rows</span>
<span class="gi">+</span>
<span class="gi">+        N = len(Gbunch)</span>
<span class="gi">+        if isinstance(pos, str | dict):</span>
<span class="gi">+            pos = [pos] * N</span>
<span class="gi">+        if sub_captions is None:</span>
<span class="gi">+            sub_captions = [&quot;&quot;] * N</span>
<span class="gi">+        if sub_labels is None:</span>
<span class="gi">+            sub_labels = [&quot;&quot;] * N</span>
<span class="gi">+        if not (len(Gbunch) == len(pos) == len(sub_captions) == len(sub_labels)):</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;length of Gbunch, sub_captions and sub_figures must agree&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        raw = &quot;&quot;</span>
<span class="gi">+        for G, pos, subcap, sublbl in zip(Gbunch, pos, sub_captions, sub_labels):</span>
<span class="gi">+            subraw = to_latex_raw(</span>
<span class="gi">+                G,</span>
<span class="gi">+                pos,</span>
<span class="gi">+                tikz_options,</span>
<span class="gi">+                default_node_options,</span>
<span class="gi">+                node_options,</span>
<span class="gi">+                node_label,</span>
<span class="gi">+                default_edge_options,</span>
<span class="gi">+                edge_options,</span>
<span class="gi">+                edge_label,</span>
<span class="gi">+                edge_label_options,</span>
<span class="gi">+            )</span>
<span class="gi">+            cap = f&quot;    \\caption{{{subcap}}}&quot; if subcap else &quot;&quot;</span>
<span class="gi">+            lbl = f&quot;\\label{{{sublbl}}}&quot; if sublbl else &quot;&quot;</span>
<span class="gi">+            raw += sbf.format(size=size, content=subraw, caption=cap, label=lbl)</span>
<span class="gi">+            raw += &quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # put raw latex code into a figure environment and optionally into a document</span>
<span class="gi">+    raw = raw[:-1]</span>
<span class="gi">+    cap = f&quot;\n  \\caption{{{caption}}}&quot; if caption else &quot;&quot;</span>
<span class="gi">+    lbl = f&quot;\\label{{{latex_label}}}&quot; if latex_label else &quot;&quot;</span>
<span class="gi">+    fig = figure_wrapper.format(content=raw, caption=cap, label=lbl)</span>
<span class="gi">+    if as_document:</span>
<span class="gi">+        return document_wrapper.format(content=fig)</span>
<span class="gi">+    return fig</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.open_file(1, mode=&quot;w&quot;)</span>
<span class="w"> </span>def write_latex(Gbunch, path, **options):
<span class="w"> </span>    &quot;&quot;&quot;Write the latex code to draw the graph(s) onto `path`.

<span class="gu">@@ -403,4 +568,4 @@ def write_latex(Gbunch, path, **options):</span>
<span class="w"> </span>    ========
<span class="w"> </span>    to_latex
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path.write(to_latex(Gbunch, **options))</span>
<span class="gh">diff --git a/networkx/drawing/nx_pydot.py b/networkx/drawing/nx_pydot.py</span>
<span class="gh">index ff51cde9c..92c5f333e 100644</span>
<span class="gd">--- a/networkx/drawing/nx_pydot.py</span>
<span class="gi">+++ b/networkx/drawing/nx_pydot.py</span>
<span class="gu">@@ -20,23 +20,33 @@ See Also</span>
<span class="w"> </span> - DOT Language:  http://www.graphviz.org/doc/info/lang.html
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from locale import getpreferredencoding
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import open_file
<span class="gd">-__all__ = [&#39;write_dot&#39;, &#39;read_dot&#39;, &#39;graphviz_layout&#39;, &#39;pydot_layout&#39;,</span>
<span class="gd">-    &#39;to_pydot&#39;, &#39;from_pydot&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;write_dot&quot;,</span>
<span class="gi">+    &quot;read_dot&quot;,</span>
<span class="gi">+    &quot;graphviz_layout&quot;,</span>
<span class="gi">+    &quot;pydot_layout&quot;,</span>
<span class="gi">+    &quot;to_pydot&quot;,</span>
<span class="gi">+    &quot;from_pydot&quot;,</span>
<span class="gi">+]</span>


<span class="gd">-@open_file(1, mode=&#39;w&#39;)</span>
<span class="gi">+@open_file(1, mode=&quot;w&quot;)</span>
<span class="w"> </span>def write_dot(G, path):
<span class="w"> </span>    &quot;&quot;&quot;Write NetworkX graph G to Graphviz dot format on path.

<span class="w"> </span>    Path can be a string or a file handle.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    P = to_pydot(G)</span>
<span class="gi">+    path.write(P.to_string())</span>
<span class="gi">+    return</span>


<span class="gd">-@open_file(0, mode=&#39;r&#39;)</span>
<span class="gd">-@nx._dispatchable(name=&#39;pydot_read_dot&#39;, graphs=None, returns_graph=True)</span>
<span class="gi">+@open_file(0, mode=&quot;r&quot;)</span>
<span class="gi">+@nx._dispatchable(name=&quot;pydot_read_dot&quot;, graphs=None, returns_graph=True)</span>
<span class="w"> </span>def read_dot(path):
<span class="w"> </span>    &quot;&quot;&quot;Returns a NetworkX :class:`MultiGraph` or :class:`MultiDiGraph` from the
<span class="w"> </span>    dot file with the passed path.
<span class="gu">@@ -59,7 +69,15 @@ def read_dot(path):</span>
<span class="w"> </span>    Use `G = nx.Graph(nx.nx_pydot.read_dot(path))` to return a :class:`Graph` instead of a
<span class="w"> </span>    :class:`MultiGraph`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import pydot</span>
<span class="gi">+</span>
<span class="gi">+    data = path.read()</span>
<span class="gi">+</span>
<span class="gi">+    # List of one or more &quot;pydot.Dot&quot; instances deserialized from this file.</span>
<span class="gi">+    P_list = pydot.graph_from_dot_data(data)</span>
<span class="gi">+</span>
<span class="gi">+    # Convert only the first such instance into a NetworkX graph.</span>
<span class="gi">+    return from_pydot(P_list[0])</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -86,7 +104,79 @@ def from_pydot(P):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.Graph(nx.nx_pydot.from_pydot(A))

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if P.get_strict(None):  # pydot bug: get_strict() shouldn&#39;t take argument</span>
<span class="gi">+        multiedges = False</span>
<span class="gi">+    else:</span>
<span class="gi">+        multiedges = True</span>
<span class="gi">+</span>
<span class="gi">+    if P.get_type() == &quot;graph&quot;:  # undirected</span>
<span class="gi">+        if multiedges:</span>
<span class="gi">+            N = nx.MultiGraph()</span>
<span class="gi">+        else:</span>
<span class="gi">+            N = nx.Graph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        if multiedges:</span>
<span class="gi">+            N = nx.MultiDiGraph()</span>
<span class="gi">+        else:</span>
<span class="gi">+            N = nx.DiGraph()</span>
<span class="gi">+</span>
<span class="gi">+    # assign defaults</span>
<span class="gi">+    name = P.get_name().strip(&#39;&quot;&#39;)</span>
<span class="gi">+    if name != &quot;&quot;:</span>
<span class="gi">+        N.name = name</span>
<span class="gi">+</span>
<span class="gi">+    # add nodes, attributes to N.node_attr</span>
<span class="gi">+    for p in P.get_node_list():</span>
<span class="gi">+        n = p.get_name().strip(&#39;&quot;&#39;)</span>
<span class="gi">+        if n in (&quot;node&quot;, &quot;graph&quot;, &quot;edge&quot;):</span>
<span class="gi">+            continue</span>
<span class="gi">+        N.add_node(n, **p.get_attributes())</span>
<span class="gi">+</span>
<span class="gi">+    # add edges</span>
<span class="gi">+    for e in P.get_edge_list():</span>
<span class="gi">+        u = e.get_source()</span>
<span class="gi">+        v = e.get_destination()</span>
<span class="gi">+        attr = e.get_attributes()</span>
<span class="gi">+        s = []</span>
<span class="gi">+        d = []</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(u, str):</span>
<span class="gi">+            s.append(u.strip(&#39;&quot;&#39;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            for unodes in u[&quot;nodes&quot;]:</span>
<span class="gi">+                s.append(unodes.strip(&#39;&quot;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(v, str):</span>
<span class="gi">+            d.append(v.strip(&#39;&quot;&#39;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            for vnodes in v[&quot;nodes&quot;]:</span>
<span class="gi">+                d.append(vnodes.strip(&#39;&quot;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        for source_node in s:</span>
<span class="gi">+            for destination_node in d:</span>
<span class="gi">+                N.add_edge(source_node, destination_node, **attr)</span>
<span class="gi">+</span>
<span class="gi">+    # add default attributes for graph, nodes, edges</span>
<span class="gi">+    pattr = P.get_attributes()</span>
<span class="gi">+    if pattr:</span>
<span class="gi">+        N.graph[&quot;graph&quot;] = pattr</span>
<span class="gi">+    try:</span>
<span class="gi">+        N.graph[&quot;node&quot;] = P.get_node_defaults()[0]</span>
<span class="gi">+    except (IndexError, TypeError):</span>
<span class="gi">+        pass  # N.graph[&#39;node&#39;]={}</span>
<span class="gi">+    try:</span>
<span class="gi">+        N.graph[&quot;edge&quot;] = P.get_edge_defaults()[0]</span>
<span class="gi">+    except (IndexError, TypeError):</span>
<span class="gi">+        pass  # N.graph[&#39;edge&#39;]={}</span>
<span class="gi">+    return N</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_colon_quotes(s):</span>
<span class="gi">+    # A quick helper function to check if a string has a colon in it</span>
<span class="gi">+    # and if it is quoted properly with double quotes.</span>
<span class="gi">+    # refer https://github.com/pydot/pydot/issues/258</span>
<span class="gi">+    return &quot;:&quot; in s and (s[0] != &#39;&quot;&#39; or s[-1] != &#39;&quot;&#39;)</span>


<span class="w"> </span>def to_pydot(N):
<span class="gu">@@ -106,10 +196,100 @@ def to_pydot(N):</span>
<span class="w"> </span>    -----

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def graphviz_layout(G, prog=&#39;neato&#39;, root=None):</span>
<span class="gi">+    import pydot</span>
<span class="gi">+</span>
<span class="gi">+    # set Graphviz graph type</span>
<span class="gi">+    if N.is_directed():</span>
<span class="gi">+        graph_type = &quot;digraph&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        graph_type = &quot;graph&quot;</span>
<span class="gi">+    strict = nx.number_of_selfloops(N) == 0 and not N.is_multigraph()</span>
<span class="gi">+</span>
<span class="gi">+    name = N.name</span>
<span class="gi">+    graph_defaults = N.graph.get(&quot;graph&quot;, {})</span>
<span class="gi">+    if name == &quot;&quot;:</span>
<span class="gi">+        P = pydot.Dot(&quot;&quot;, graph_type=graph_type, strict=strict, **graph_defaults)</span>
<span class="gi">+    else:</span>
<span class="gi">+        P = pydot.Dot(</span>
<span class="gi">+            f&#39;&quot;{name}&quot;&#39;, graph_type=graph_type, strict=strict, **graph_defaults</span>
<span class="gi">+        )</span>
<span class="gi">+    try:</span>
<span class="gi">+        P.set_node_defaults(**N.graph[&quot;node&quot;])</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        P.set_edge_defaults(**N.graph[&quot;edge&quot;])</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    for n, nodedata in N.nodes(data=True):</span>
<span class="gi">+        str_nodedata = {str(k): str(v) for k, v in nodedata.items()}</span>
<span class="gi">+        # Explicitly catch nodes with &quot;:&quot; in node names or nodedata.</span>
<span class="gi">+        n = str(n)</span>
<span class="gi">+        raise_error = _check_colon_quotes(n) or (</span>
<span class="gi">+            any(</span>
<span class="gi">+                (_check_colon_quotes(k) or _check_colon_quotes(v))</span>
<span class="gi">+                for k, v in str_nodedata.items()</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        if raise_error:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&#39;Node names and attributes should not contain &quot;:&quot; unless they are quoted with &quot;&quot;.\</span>
<span class="gi">+                For example the string \&#39;attribute:data1\&#39; should be written as \&#39;&quot;attribute:data1&quot;\&#39;.\</span>
<span class="gi">+                Please refer https://github.com/pydot/pydot/issues/258&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        p = pydot.Node(n, **str_nodedata)</span>
<span class="gi">+        P.add_node(p)</span>
<span class="gi">+</span>
<span class="gi">+    if N.is_multigraph():</span>
<span class="gi">+        for u, v, key, edgedata in N.edges(data=True, keys=True):</span>
<span class="gi">+            str_edgedata = {str(k): str(v) for k, v in edgedata.items() if k != &quot;key&quot;}</span>
<span class="gi">+            u, v = str(u), str(v)</span>
<span class="gi">+            raise_error = (</span>
<span class="gi">+                _check_colon_quotes(u)</span>
<span class="gi">+                or _check_colon_quotes(v)</span>
<span class="gi">+                or (</span>
<span class="gi">+                    any(</span>
<span class="gi">+                        (_check_colon_quotes(k) or _check_colon_quotes(val))</span>
<span class="gi">+                        for k, val in str_edgedata.items()</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            if raise_error:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&#39;Node names and attributes should not contain &quot;:&quot; unless they are quoted with &quot;&quot;.\</span>
<span class="gi">+                    For example the string \&#39;attribute:data1\&#39; should be written as \&#39;&quot;attribute:data1&quot;\&#39;.\</span>
<span class="gi">+                    Please refer https://github.com/pydot/pydot/issues/258&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            edge = pydot.Edge(u, v, key=str(key), **str_edgedata)</span>
<span class="gi">+            P.add_edge(edge)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u, v, edgedata in N.edges(data=True):</span>
<span class="gi">+            str_edgedata = {str(k): str(v) for k, v in edgedata.items()}</span>
<span class="gi">+            u, v = str(u), str(v)</span>
<span class="gi">+            raise_error = (</span>
<span class="gi">+                _check_colon_quotes(u)</span>
<span class="gi">+                or _check_colon_quotes(v)</span>
<span class="gi">+                or (</span>
<span class="gi">+                    any(</span>
<span class="gi">+                        (_check_colon_quotes(k) or _check_colon_quotes(val))</span>
<span class="gi">+                        for k, val in str_edgedata.items()</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            if raise_error:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&#39;Node names and attributes should not contain &quot;:&quot; unless they are quoted with &quot;&quot;.\</span>
<span class="gi">+                    For example the string \&#39;attribute:data1\&#39; should be written as \&#39;&quot;attribute:data1&quot;\&#39;.\</span>
<span class="gi">+                    Please refer https://github.com/pydot/pydot/issues/258&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+            edge = pydot.Edge(u, v, **str_edgedata)</span>
<span class="gi">+            P.add_edge(edge)</span>
<span class="gi">+    return P</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def graphviz_layout(G, prog=&quot;neato&quot;, root=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create node positions using Pydot and Graphviz.

<span class="w"> </span>    Returns a dictionary of positions keyed by node.
<span class="gu">@@ -139,10 +319,10 @@ def graphviz_layout(G, prog=&#39;neato&#39;, root=None):</span>
<span class="w"> </span>    -----
<span class="w"> </span>    This is a wrapper for pydot_layout.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return pydot_layout(G=G, prog=prog, root=root)</span>


<span class="gd">-def pydot_layout(G, prog=&#39;neato&#39;, root=None):</span>
<span class="gi">+def pydot_layout(G, prog=&quot;neato&quot;, root=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Create node positions using :mod:`pydot` and Graphviz.

<span class="w"> </span>    Parameters
<span class="gu">@@ -180,4 +360,52 @@ def pydot_layout(G, prog=&#39;neato&#39;, root=None):</span>
<span class="w"> </span>        G_layout = {H.nodes[n][&quot;node_label&quot;]: p for n, p in H_layout.items()}

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import pydot</span>
<span class="gi">+</span>
<span class="gi">+    P = to_pydot(G)</span>
<span class="gi">+    if root is not None:</span>
<span class="gi">+        P.set(&quot;root&quot;, str(root))</span>
<span class="gi">+</span>
<span class="gi">+    # List of low-level bytes comprising a string in the dot language converted</span>
<span class="gi">+    # from the passed graph with the passed external GraphViz command.</span>
<span class="gi">+    D_bytes = P.create_dot(prog=prog)</span>
<span class="gi">+</span>
<span class="gi">+    # Unique string decoded from these bytes with the preferred locale encoding</span>
<span class="gi">+    D = str(D_bytes, encoding=getpreferredencoding())</span>
<span class="gi">+</span>
<span class="gi">+    if D == &quot;&quot;:  # no data returned</span>
<span class="gi">+        print(f&quot;Graphviz layout with {prog} failed&quot;)</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(&quot;To debug what happened try:&quot;)</span>
<span class="gi">+        print(&quot;P = nx.nx_pydot.to_pydot(G)&quot;)</span>
<span class="gi">+        print(&#39;P.write_dot(&quot;file.dot&quot;)&#39;)</span>
<span class="gi">+        print(f&quot;And then run {prog} on file.dot&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # List of one or more &quot;pydot.Dot&quot; instances deserialized from this string.</span>
<span class="gi">+    Q_list = pydot.graph_from_dot_data(D)</span>
<span class="gi">+    assert len(Q_list) == 1</span>
<span class="gi">+</span>
<span class="gi">+    # The first and only such instance, as guaranteed by the above assertion.</span>
<span class="gi">+    Q = Q_list[0]</span>
<span class="gi">+</span>
<span class="gi">+    node_pos = {}</span>
<span class="gi">+    for n in G.nodes():</span>
<span class="gi">+        str_n = str(n)</span>
<span class="gi">+        # Explicitly catch nodes with &quot;:&quot; in node names or nodedata.</span>
<span class="gi">+        if _check_colon_quotes(str_n):</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                f&#39;Node names and node attributes should not contain &quot;:&quot; unless they are quoted with &quot;&quot;.\</span>
<span class="gi">+                For example the string \&#39;attribute:data1\&#39; should be written as \&#39;&quot;attribute:data1&quot;\&#39;.\</span>
<span class="gi">+                Please refer https://github.com/pydot/pydot/issues/258&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        pydot_node = pydot.Node(str_n).get_name()</span>
<span class="gi">+        node = Q.get_node(pydot_node)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node, list):</span>
<span class="gi">+            node = node[0]</span>
<span class="gi">+        pos = node.get_pos()[1:-1]  # strip leading and trailing double quotes</span>
<span class="gi">+        if pos is not None:</span>
<span class="gi">+            xx, yy = pos.split(&quot;,&quot;)</span>
<span class="gi">+            node_pos[n] = (float(xx), float(yy))</span>
<span class="gi">+    return node_pos</span>
<span class="gh">diff --git a/networkx/drawing/nx_pylab.py b/networkx/drawing/nx_pylab.py</span>
<span class="gh">index 6f49522e0..7c25f63bf 100644</span>
<span class="gd">--- a/networkx/drawing/nx_pylab.py</span>
<span class="gi">+++ b/networkx/drawing/nx_pylab.py</span>
<span class="gu">@@ -19,12 +19,33 @@ See Also</span>
<span class="w"> </span>import collections
<span class="w"> </span>import itertools
<span class="w"> </span>from numbers import Number
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.drawing.layout import circular_layout, kamada_kawai_layout, planar_layout, random_layout, shell_layout, spectral_layout, spring_layout</span>
<span class="gd">-__all__ = [&#39;draw&#39;, &#39;draw_networkx&#39;, &#39;draw_networkx_nodes&#39;,</span>
<span class="gd">-    &#39;draw_networkx_edges&#39;, &#39;draw_networkx_labels&#39;,</span>
<span class="gd">-    &#39;draw_networkx_edge_labels&#39;, &#39;draw_circular&#39;, &#39;draw_kamada_kawai&#39;,</span>
<span class="gd">-    &#39;draw_random&#39;, &#39;draw_spectral&#39;, &#39;draw_spring&#39;, &#39;draw_planar&#39;, &#39;draw_shell&#39;]</span>
<span class="gi">+from networkx.drawing.layout import (</span>
<span class="gi">+    circular_layout,</span>
<span class="gi">+    kamada_kawai_layout,</span>
<span class="gi">+    planar_layout,</span>
<span class="gi">+    random_layout,</span>
<span class="gi">+    shell_layout,</span>
<span class="gi">+    spectral_layout,</span>
<span class="gi">+    spring_layout,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;draw&quot;,</span>
<span class="gi">+    &quot;draw_networkx&quot;,</span>
<span class="gi">+    &quot;draw_networkx_nodes&quot;,</span>
<span class="gi">+    &quot;draw_networkx_edges&quot;,</span>
<span class="gi">+    &quot;draw_networkx_labels&quot;,</span>
<span class="gi">+    &quot;draw_networkx_edge_labels&quot;,</span>
<span class="gi">+    &quot;draw_circular&quot;,</span>
<span class="gi">+    &quot;draw_kamada_kawai&quot;,</span>
<span class="gi">+    &quot;draw_random&quot;,</span>
<span class="gi">+    &quot;draw_spectral&quot;,</span>
<span class="gi">+    &quot;draw_spring&quot;,</span>
<span class="gi">+    &quot;draw_planar&quot;,</span>
<span class="gi">+    &quot;draw_shell&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def draw(G, pos=None, ax=None, **kwds):
<span class="gu">@@ -83,11 +104,30 @@ def draw(G, pos=None, ax=None, **kwds):</span>
<span class="w"> </span>    Also see the NetworkX drawing examples at
<span class="w"> </span>    https://networkx.org/documentation/latest/auto_examples/index.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import matplotlib.pyplot as plt</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        cf = plt.gcf()</span>
<span class="gi">+    else:</span>
<span class="gi">+        cf = ax.get_figure()</span>
<span class="gi">+    cf.set_facecolor(&quot;w&quot;)</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        if cf.axes:</span>
<span class="gi">+            ax = cf.gca()</span>
<span class="gi">+        else:</span>
<span class="gi">+            ax = cf.add_axes((0, 0, 1, 1))</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;with_labels&quot; not in kwds:</span>
<span class="gi">+        kwds[&quot;with_labels&quot;] = &quot;labels&quot; in kwds</span>
<span class="gi">+</span>
<span class="gi">+    draw_networkx(G, pos=pos, ax=ax, **kwds)</span>
<span class="gi">+    ax.set_axis_off()</span>
<span class="gi">+    plt.draw_if_interactive()</span>
<span class="gi">+    return</span>


<span class="w"> </span>def draw_networkx(G, pos=None, arrows=None, with_labels=True, **kwds):
<span class="gd">-    &quot;&quot;&quot;Draw the graph G using Matplotlib.</span>
<span class="gi">+    r&quot;&quot;&quot;Draw the graph G using Matplotlib.</span>

<span class="w"> </span>    Draw the graph with Matplotlib with options for node positions,
<span class="w"> </span>    labeling, titles, and many other drawing features.
<span class="gu">@@ -113,7 +153,7 @@ def draw_networkx(G, pos=None, arrows=None, with_labels=True, **kwds):</span>
<span class="w"> </span>        For directed graphs, if True draw arrowheads.
<span class="w"> </span>        Note: Arrows will be the same color as edges.

<span class="gd">-    arrowstyle : str (default=&#39;-\\|&gt;&#39; for directed graphs)</span>
<span class="gi">+    arrowstyle : str (default=&#39;-\|&gt;&#39; for directed graphs)</span>
<span class="w"> </span>        For directed graphs, choose the style of the arrowsheads.
<span class="w"> </span>        For undirected graphs default to &#39;-&#39;

<span class="gu">@@ -237,13 +277,62 @@ def draw_networkx(G, pos=None, arrows=None, with_labels=True, **kwds):</span>
<span class="w"> </span>    draw_networkx_labels
<span class="w"> </span>    draw_networkx_edge_labels
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def draw_networkx_nodes(G, pos, nodelist=None, node_size=300, node_color=</span>
<span class="gd">-    &#39;#1f78b4&#39;, node_shape=&#39;o&#39;, alpha=None, cmap=None, vmin=None, vmax=None,</span>
<span class="gd">-    ax=None, linewidths=None, edgecolors=None, label=None, margins=None,</span>
<span class="gd">-    hide_ticks=True):</span>
<span class="gi">+    from inspect import signature</span>
<span class="gi">+</span>
<span class="gi">+    import matplotlib.pyplot as plt</span>
<span class="gi">+</span>
<span class="gi">+    # Get all valid keywords by inspecting the signatures of draw_networkx_nodes,</span>
<span class="gi">+    # draw_networkx_edges, draw_networkx_labels</span>
<span class="gi">+</span>
<span class="gi">+    valid_node_kwds = signature(draw_networkx_nodes).parameters.keys()</span>
<span class="gi">+    valid_edge_kwds = signature(draw_networkx_edges).parameters.keys()</span>
<span class="gi">+    valid_label_kwds = signature(draw_networkx_labels).parameters.keys()</span>
<span class="gi">+</span>
<span class="gi">+    # Create a set with all valid keywords across the three functions and</span>
<span class="gi">+    # remove the arguments of this function (draw_networkx)</span>
<span class="gi">+    valid_kwds = (valid_node_kwds | valid_edge_kwds | valid_label_kwds) - {</span>
<span class="gi">+        &quot;G&quot;,</span>
<span class="gi">+        &quot;pos&quot;,</span>
<span class="gi">+        &quot;arrows&quot;,</span>
<span class="gi">+        &quot;with_labels&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    if any(k not in valid_kwds for k in kwds):</span>
<span class="gi">+        invalid_args = &quot;, &quot;.join([k for k in kwds if k not in valid_kwds])</span>
<span class="gi">+        raise ValueError(f&quot;Received invalid argument(s): {invalid_args}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    node_kwds = {k: v for k, v in kwds.items() if k in valid_node_kwds}</span>
<span class="gi">+    edge_kwds = {k: v for k, v in kwds.items() if k in valid_edge_kwds}</span>
<span class="gi">+    label_kwds = {k: v for k, v in kwds.items() if k in valid_label_kwds}</span>
<span class="gi">+</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = nx.drawing.spring_layout(G)  # default to spring layout</span>
<span class="gi">+</span>
<span class="gi">+    draw_networkx_nodes(G, pos, **node_kwds)</span>
<span class="gi">+    draw_networkx_edges(G, pos, arrows=arrows, **edge_kwds)</span>
<span class="gi">+    if with_labels:</span>
<span class="gi">+        draw_networkx_labels(G, pos, **label_kwds)</span>
<span class="gi">+    plt.draw_if_interactive()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def draw_networkx_nodes(</span>
<span class="gi">+    G,</span>
<span class="gi">+    pos,</span>
<span class="gi">+    nodelist=None,</span>
<span class="gi">+    node_size=300,</span>
<span class="gi">+    node_color=&quot;#1f78b4&quot;,</span>
<span class="gi">+    node_shape=&quot;o&quot;,</span>
<span class="gi">+    alpha=None,</span>
<span class="gi">+    cmap=None,</span>
<span class="gi">+    vmin=None,</span>
<span class="gi">+    vmax=None,</span>
<span class="gi">+    ax=None,</span>
<span class="gi">+    linewidths=None,</span>
<span class="gi">+    edgecolors=None,</span>
<span class="gi">+    label=None,</span>
<span class="gi">+    margins=None,</span>
<span class="gi">+    hide_ticks=True,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Draw the nodes of the graph G.

<span class="w"> </span>    This draws only the nodes of the graph G.
<span class="gu">@@ -333,44 +422,157 @@ def draw_networkx_nodes(G, pos, nodelist=None, node_size=300, node_color=</span>
<span class="w"> </span>    draw_networkx_labels
<span class="w"> </span>    draw_networkx_edge_labels
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from collections.abc import Iterable</span>
<span class="gi">+</span>
<span class="gi">+    import matplotlib as mpl</span>
<span class="gi">+    import matplotlib.collections  # call as mpl.collections</span>
<span class="gi">+    import matplotlib.pyplot as plt</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+</span>
<span class="gi">+    if len(nodelist) == 0:  # empty nodelist, no drawing</span>
<span class="gi">+        return mpl.collections.PathCollection(None)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        xy = np.asarray([pos[v] for v in nodelist])</span>
<span class="gi">+    except KeyError as err:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Node {err} has no position.&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(alpha, Iterable):</span>
<span class="gi">+        node_color = apply_alpha(node_color, alpha, nodelist, cmap, vmin, vmax)</span>
<span class="gi">+        alpha = None</span>
<span class="gi">+</span>
<span class="gi">+    node_collection = ax.scatter(</span>
<span class="gi">+        xy[:, 0],</span>
<span class="gi">+        xy[:, 1],</span>
<span class="gi">+        s=node_size,</span>
<span class="gi">+        c=node_color,</span>
<span class="gi">+        marker=node_shape,</span>
<span class="gi">+        cmap=cmap,</span>
<span class="gi">+        vmin=vmin,</span>
<span class="gi">+        vmax=vmax,</span>
<span class="gi">+        alpha=alpha,</span>
<span class="gi">+        linewidths=linewidths,</span>
<span class="gi">+        edgecolors=edgecolors,</span>
<span class="gi">+        label=label,</span>
<span class="gi">+    )</span>
<span class="gi">+    if hide_ticks:</span>
<span class="gi">+        ax.tick_params(</span>
<span class="gi">+            axis=&quot;both&quot;,</span>
<span class="gi">+            which=&quot;both&quot;,</span>
<span class="gi">+            bottom=False,</span>
<span class="gi">+            left=False,</span>
<span class="gi">+            labelbottom=False,</span>
<span class="gi">+            labelleft=False,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if margins is not None:</span>
<span class="gi">+        if isinstance(margins, Iterable):</span>
<span class="gi">+            ax.margins(*margins)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ax.margins(margins)</span>
<span class="gi">+</span>
<span class="gi">+    node_collection.set_zorder(2)</span>
<span class="gi">+    return node_collection</span>


<span class="w"> </span>class FancyArrowFactory:
<span class="w"> </span>    &quot;&quot;&quot;Draw arrows with `matplotlib.patches.FancyarrowPatch`&quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>    class ConnectionStyleFactory:
<span class="gd">-</span>
<span class="w"> </span>        def __init__(self, connectionstyles, selfloop_height, ax=None):
<span class="w"> </span>            import matplotlib as mpl
<span class="gd">-            import matplotlib.path</span>
<span class="gi">+            import matplotlib.path  # call as mpl.path</span>
<span class="w"> </span>            import numpy as np
<span class="gi">+</span>
<span class="w"> </span>            self.ax = ax
<span class="w"> </span>            self.mpl = mpl
<span class="w"> </span>            self.np = np
<span class="gd">-            self.base_connection_styles = [mpl.patches.ConnectionStyle(cs) for</span>
<span class="gd">-                cs in connectionstyles]</span>
<span class="gi">+            self.base_connection_styles = [</span>
<span class="gi">+                mpl.patches.ConnectionStyle(cs) for cs in connectionstyles</span>
<span class="gi">+            ]</span>
<span class="w"> </span>            self.n = len(self.base_connection_styles)
<span class="w"> </span>            self.selfloop_height = selfloop_height

<span class="gd">-    def __init__(self, edge_pos, edgelist, nodelist, edge_indices,</span>
<span class="gd">-        node_size, selfloop_height, connectionstyle=&#39;arc3&#39;, node_shape=&#39;o&#39;,</span>
<span class="gd">-        arrowstyle=&#39;-&#39;, arrowsize=10, edge_color=&#39;k&#39;, alpha=None, linewidth</span>
<span class="gd">-        =1.0, style=&#39;solid&#39;, min_source_margin=0, min_target_margin=0, ax=None</span>
<span class="gd">-        ):</span>
<span class="gi">+        def curved(self, edge_index):</span>
<span class="gi">+            return self.base_connection_styles[edge_index % self.n]</span>
<span class="gi">+</span>
<span class="gi">+        def self_loop(self, edge_index):</span>
<span class="gi">+            def self_loop_connection(posA, posB, *args, **kwargs):</span>
<span class="gi">+                if not self.np.all(posA == posB):</span>
<span class="gi">+                    raise nx.NetworkXError(</span>
<span class="gi">+                        &quot;`self_loop` connection style method&quot;</span>
<span class="gi">+                        &quot;is only to be used for self-loops&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                # this is called with _screen space_ values</span>
<span class="gi">+                # so convert back to data space</span>
<span class="gi">+                data_loc = self.ax.transData.inverted().transform(posA)</span>
<span class="gi">+                v_shift = 0.1 * self.selfloop_height</span>
<span class="gi">+                h_shift = v_shift * 0.5</span>
<span class="gi">+                # put the top of the loop first so arrow is not hidden by node</span>
<span class="gi">+                path = self.np.asarray(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        # 1</span>
<span class="gi">+                        [0, v_shift],</span>
<span class="gi">+                        # 4 4 4</span>
<span class="gi">+                        [h_shift, v_shift],</span>
<span class="gi">+                        [h_shift, 0],</span>
<span class="gi">+                        [0, 0],</span>
<span class="gi">+                        # 4 4 4</span>
<span class="gi">+                        [-h_shift, 0],</span>
<span class="gi">+                        [-h_shift, v_shift],</span>
<span class="gi">+                        [0, v_shift],</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="gi">+                # Rotate self loop 90 deg. if more than 1</span>
<span class="gi">+                # This will allow for maximum of 4 visible self loops</span>
<span class="gi">+                if edge_index % 4:</span>
<span class="gi">+                    x, y = path.T</span>
<span class="gi">+                    for _ in range(edge_index % 4):</span>
<span class="gi">+                        x, y = y, -x</span>
<span class="gi">+                    path = self.np.array([x, y]).T</span>
<span class="gi">+                return self.mpl.path.Path(</span>
<span class="gi">+                    self.ax.transData.transform(data_loc + path), [1, 4, 4, 4, 4, 4, 4]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            return self_loop_connection</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        edge_pos,</span>
<span class="gi">+        edgelist,</span>
<span class="gi">+        nodelist,</span>
<span class="gi">+        edge_indices,</span>
<span class="gi">+        node_size,</span>
<span class="gi">+        selfloop_height,</span>
<span class="gi">+        connectionstyle=&quot;arc3&quot;,</span>
<span class="gi">+        node_shape=&quot;o&quot;,</span>
<span class="gi">+        arrowstyle=&quot;-&quot;,</span>
<span class="gi">+        arrowsize=10,</span>
<span class="gi">+        edge_color=&quot;k&quot;,</span>
<span class="gi">+        alpha=None,</span>
<span class="gi">+        linewidth=1.0,</span>
<span class="gi">+        style=&quot;solid&quot;,</span>
<span class="gi">+        min_source_margin=0,</span>
<span class="gi">+        min_target_margin=0,</span>
<span class="gi">+        ax=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        import matplotlib as mpl
<span class="gd">-        import matplotlib.patches</span>
<span class="gi">+        import matplotlib.patches  # call as mpl.patches</span>
<span class="w"> </span>        import matplotlib.pyplot as plt
<span class="w"> </span>        import numpy as np
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(connectionstyle, str):
<span class="w"> </span>            connectionstyle = [connectionstyle]
<span class="w"> </span>        elif np.iterable(connectionstyle):
<span class="w"> </span>            connectionstyle = list(connectionstyle)
<span class="w"> </span>        else:
<span class="gd">-            msg = (</span>
<span class="gd">-                &#39;ConnectionStyleFactory arg `connectionstyle` must be str or iterable&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            msg = &quot;ConnectionStyleFactory arg `connectionstyle` must be str or iterable&quot;</span>
<span class="w"> </span>            raise nx.NetworkXError(msg)
<span class="w"> </span>        self.ax = ax
<span class="w"> </span>        self.mpl = mpl
<span class="gu">@@ -384,45 +586,45 @@ class FancyArrowFactory:</span>
<span class="w"> </span>        self.edge_indices = edge_indices
<span class="w"> </span>        self.node_size = node_size
<span class="w"> </span>        self.connectionstyle_factory = self.ConnectionStyleFactory(
<span class="gd">-            connectionstyle, selfloop_height, ax)</span>
<span class="gi">+            connectionstyle, selfloop_height, ax</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.arrowstyle = arrowstyle
<span class="w"> </span>        self.arrowsize = arrowsize
<span class="gd">-        self.arrow_colors = mpl.colors.colorConverter.to_rgba_array(edge_color,</span>
<span class="gd">-            alpha)</span>
<span class="gi">+        self.arrow_colors = mpl.colors.colorConverter.to_rgba_array(edge_color, alpha)</span>
<span class="w"> </span>        self.linewidth = linewidth
<span class="w"> </span>        self.style = style
<span class="w"> </span>        if isinstance(arrowsize, list) and len(arrowsize) != len(edge_pos):
<span class="gd">-            raise ValueError(</span>
<span class="gd">-                &#39;arrowsize should have the same length as edgelist&#39;)</span>
<span class="gi">+            raise ValueError(&quot;arrowsize should have the same length as edgelist&quot;)</span>

<span class="w"> </span>    def __call__(self, i):
<span class="w"> </span>        (x1, y1), (x2, y2) = self.edge_pos[i]
<span class="gd">-        shrink_source = 0</span>
<span class="gd">-        shrink_target = 0</span>
<span class="gd">-        if self.np.iterable(self.node_size):</span>
<span class="gi">+        shrink_source = 0  # space from source to tail</span>
<span class="gi">+        shrink_target = 0  # space from  head to target</span>
<span class="gi">+        if self.np.iterable(self.node_size):  # many node sizes</span>
<span class="w"> </span>            source, target = self.edgelist[i][:2]
<span class="w"> </span>            source_node_size = self.node_size[self.nodelist.index(source)]
<span class="w"> </span>            target_node_size = self.node_size[self.nodelist.index(target)]
<span class="gd">-            shrink_source = self.to_marker_edge(source_node_size, self.</span>
<span class="gd">-                node_shape)</span>
<span class="gd">-            shrink_target = self.to_marker_edge(target_node_size, self.</span>
<span class="gd">-                node_shape)</span>
<span class="gi">+            shrink_source = self.to_marker_edge(source_node_size, self.node_shape)</span>
<span class="gi">+            shrink_target = self.to_marker_edge(target_node_size, self.node_shape)</span>
<span class="w"> </span>        else:
<span class="gd">-            shrink_source = self.to_marker_edge(self.node_size, self.node_shape</span>
<span class="gd">-                )</span>
<span class="gi">+            shrink_source = self.to_marker_edge(self.node_size, self.node_shape)</span>
<span class="w"> </span>            shrink_target = shrink_source
<span class="w"> </span>        shrink_source = max(shrink_source, self.min_source_margin)
<span class="w"> </span>        shrink_target = max(shrink_target, self.min_target_margin)
<span class="gi">+</span>
<span class="gi">+        # scale factor of arrow head</span>
<span class="w"> </span>        if isinstance(self.arrowsize, list):
<span class="w"> </span>            mutation_scale = self.arrowsize[i]
<span class="w"> </span>        else:
<span class="w"> </span>            mutation_scale = self.arrowsize
<span class="gi">+</span>
<span class="w"> </span>        if len(self.arrow_colors) &gt; i:
<span class="w"> </span>            arrow_color = self.arrow_colors[i]
<span class="w"> </span>        elif len(self.arrow_colors) == 1:
<span class="w"> </span>            arrow_color = self.arrow_colors[0]
<span class="gd">-        else:</span>
<span class="gi">+        else:  # Cycle through colors</span>
<span class="w"> </span>            arrow_color = self.arrow_colors[i % len(self.arrow_colors)]
<span class="gi">+</span>
<span class="w"> </span>        if self.np.iterable(self.linewidth):
<span class="w"> </span>            if len(self.linewidth) &gt; i:
<span class="w"> </span>                linewidth = self.linewidth[i]
<span class="gu">@@ -430,33 +632,71 @@ class FancyArrowFactory:</span>
<span class="w"> </span>                linewidth = self.linewidth[i % len(self.linewidth)]
<span class="w"> </span>        else:
<span class="w"> </span>            linewidth = self.linewidth
<span class="gd">-        if self.np.iterable(self.style) and not isinstance(self.style, str</span>
<span class="gd">-            ) and not isinstance(self.style, tuple):</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            self.np.iterable(self.style)</span>
<span class="gi">+            and not isinstance(self.style, str)</span>
<span class="gi">+            and not isinstance(self.style, tuple)</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            if len(self.style) &gt; i:
<span class="w"> </span>                linestyle = self.style[i]
<span class="gd">-            else:</span>
<span class="gi">+            else:  # Cycle through styles</span>
<span class="w"> </span>                linestyle = self.style[i % len(self.style)]
<span class="w"> </span>        else:
<span class="w"> </span>            linestyle = self.style
<span class="gi">+</span>
<span class="w"> </span>        if x1 == x2 and y1 == y2:
<span class="gd">-            connectionstyle = self.connectionstyle_factory.self_loop(self.</span>
<span class="gd">-                edge_indices[i])</span>
<span class="gi">+            connectionstyle = self.connectionstyle_factory.self_loop(</span>
<span class="gi">+                self.edge_indices[i]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            connectionstyle = self.connectionstyle_factory.curved(self.edge_indices[i])</span>
<span class="gi">+        return self.mpl.patches.FancyArrowPatch(</span>
<span class="gi">+            (x1, y1),</span>
<span class="gi">+            (x2, y2),</span>
<span class="gi">+            arrowstyle=self.arrowstyle,</span>
<span class="gi">+            shrinkA=shrink_source,</span>
<span class="gi">+            shrinkB=shrink_target,</span>
<span class="gi">+            mutation_scale=mutation_scale,</span>
<span class="gi">+            color=arrow_color,</span>
<span class="gi">+            linewidth=linewidth,</span>
<span class="gi">+            connectionstyle=connectionstyle,</span>
<span class="gi">+            linestyle=linestyle,</span>
<span class="gi">+            zorder=1,  # arrows go behind nodes</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def to_marker_edge(self, marker_size, marker):</span>
<span class="gi">+        if marker in &quot;s^&gt;v&lt;d&quot;:  # `large` markers need extra space</span>
<span class="gi">+            return self.np.sqrt(2 * marker_size) / 2</span>
<span class="w"> </span>        else:
<span class="gd">-            connectionstyle = self.connectionstyle_factory.curved(self.</span>
<span class="gd">-                edge_indices[i])</span>
<span class="gd">-        return self.mpl.patches.FancyArrowPatch((x1, y1), (x2, y2),</span>
<span class="gd">-            arrowstyle=self.arrowstyle, shrinkA=shrink_source, shrinkB=</span>
<span class="gd">-            shrink_target, mutation_scale=mutation_scale, color=arrow_color,</span>
<span class="gd">-            linewidth=linewidth, connectionstyle=connectionstyle, linestyle</span>
<span class="gd">-            =linestyle, zorder=1)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def draw_networkx_edges(G, pos, edgelist=None, width=1.0, edge_color=&#39;k&#39;,</span>
<span class="gd">-    style=&#39;solid&#39;, alpha=None, arrowstyle=None, arrowsize=10, edge_cmap=</span>
<span class="gd">-    None, edge_vmin=None, edge_vmax=None, ax=None, arrows=None, label=None,</span>
<span class="gd">-    node_size=300, nodelist=None, node_shape=&#39;o&#39;, connectionstyle=&#39;arc3&#39;,</span>
<span class="gd">-    min_source_margin=0, min_target_margin=0, hide_ticks=True):</span>
<span class="gd">-    &quot;&quot;&quot;Draw the edges of the graph G.</span>
<span class="gi">+            return self.np.sqrt(marker_size) / 2</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def draw_networkx_edges(</span>
<span class="gi">+    G,</span>
<span class="gi">+    pos,</span>
<span class="gi">+    edgelist=None,</span>
<span class="gi">+    width=1.0,</span>
<span class="gi">+    edge_color=&quot;k&quot;,</span>
<span class="gi">+    style=&quot;solid&quot;,</span>
<span class="gi">+    alpha=None,</span>
<span class="gi">+    arrowstyle=None,</span>
<span class="gi">+    arrowsize=10,</span>
<span class="gi">+    edge_cmap=None,</span>
<span class="gi">+    edge_vmin=None,</span>
<span class="gi">+    edge_vmax=None,</span>
<span class="gi">+    ax=None,</span>
<span class="gi">+    arrows=None,</span>
<span class="gi">+    label=None,</span>
<span class="gi">+    node_size=300,</span>
<span class="gi">+    nodelist=None,</span>
<span class="gi">+    node_shape=&quot;o&quot;,</span>
<span class="gi">+    connectionstyle=&quot;arc3&quot;,</span>
<span class="gi">+    min_source_margin=0,</span>
<span class="gi">+    min_target_margin=0,</span>
<span class="gi">+    hide_ticks=True,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Draw the edges of the graph G.</span>

<span class="w"> </span>    This draws only the edges of the graph G.

<span class="gu">@@ -516,8 +756,8 @@ def draw_networkx_edges(G, pos, edgelist=None, width=1.0, edge_color=&#39;k&#39;,</span>

<span class="w"> </span>        Note: Arrowheads will be the same color as edges.

<span class="gd">-    arrowstyle : str (default=&#39;-\\|&gt;&#39; for directed graphs)</span>
<span class="gd">-        For directed graphs and `arrows==True` defaults to &#39;-\\|&gt;&#39;,</span>
<span class="gi">+    arrowstyle : str (default=&#39;-\|&gt;&#39; for directed graphs)</span>
<span class="gi">+        For directed graphs and `arrows==True` defaults to &#39;-\|&gt;&#39;,</span>
<span class="w"> </span>        For undirected graphs default to &#39;-&#39;.

<span class="w"> </span>        See `matplotlib.patches.ArrowStyle` for more options.
<span class="gu">@@ -617,13 +857,210 @@ def draw_networkx_edges(G, pos, edgelist=None, width=1.0, edge_color=&#39;k&#39;,</span>
<span class="w"> </span>    draw_networkx_edge_labels

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def draw_networkx_labels(G, pos, labels=None, font_size=12, font_color=&#39;k&#39;,</span>
<span class="gd">-    font_family=&#39;sans-serif&#39;, font_weight=&#39;normal&#39;, alpha=None, bbox=None,</span>
<span class="gd">-    horizontalalignment=&#39;center&#39;, verticalalignment=&#39;center&#39;, ax=None,</span>
<span class="gd">-    clip_on=True, hide_ticks=True):</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    import matplotlib as mpl</span>
<span class="gi">+    import matplotlib.collections  # call as mpl.collections</span>
<span class="gi">+    import matplotlib.colors  # call as mpl.colors</span>
<span class="gi">+    import matplotlib.pyplot as plt</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    # The default behavior is to use LineCollection to draw edges for</span>
<span class="gi">+    # undirected graphs (for performance reasons) and use FancyArrowPatches</span>
<span class="gi">+    # for directed graphs.</span>
<span class="gi">+    # The `arrows` keyword can be used to override the default behavior</span>
<span class="gi">+    if arrows is None:</span>
<span class="gi">+        use_linecollection = not (G.is_directed() or G.is_multigraph())</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not isinstance(arrows, bool):</span>
<span class="gi">+            raise TypeError(&quot;Argument `arrows` must be of type bool or None&quot;)</span>
<span class="gi">+        use_linecollection = not arrows</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(connectionstyle, str):</span>
<span class="gi">+        connectionstyle = [connectionstyle]</span>
<span class="gi">+    elif np.iterable(connectionstyle):</span>
<span class="gi">+        connectionstyle = list(connectionstyle)</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = &quot;draw_networkx_edges arg `connectionstyle` must be str or iterable&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # Some kwargs only apply to FancyArrowPatches. Warn users when they use</span>
<span class="gi">+    # non-default values for these kwargs when LineCollection is being used</span>
<span class="gi">+    # instead of silently ignoring the specified option</span>
<span class="gi">+    if use_linecollection:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;\n\nThe {0} keyword argument is not applicable when drawing edges\n&quot;</span>
<span class="gi">+            &quot;with LineCollection.\n\n&quot;</span>
<span class="gi">+            &quot;To make this warning go away, either specify `arrows=True` to\n&quot;</span>
<span class="gi">+            &quot;force FancyArrowPatches or use the default values.\n&quot;</span>
<span class="gi">+            &quot;Note that using FancyArrowPatches may be slow for large graphs.\n&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        if arrowstyle is not None:</span>
<span class="gi">+            warnings.warn(msg.format(&quot;arrowstyle&quot;), category=UserWarning, stacklevel=2)</span>
<span class="gi">+        if arrowsize != 10:</span>
<span class="gi">+            warnings.warn(msg.format(&quot;arrowsize&quot;), category=UserWarning, stacklevel=2)</span>
<span class="gi">+        if min_source_margin != 0:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                msg.format(&quot;min_source_margin&quot;), category=UserWarning, stacklevel=2</span>
<span class="gi">+            )</span>
<span class="gi">+        if min_target_margin != 0:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                msg.format(&quot;min_target_margin&quot;), category=UserWarning, stacklevel=2</span>
<span class="gi">+            )</span>
<span class="gi">+        if any(cs != &quot;arc3&quot; for cs in connectionstyle):</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                msg.format(&quot;connectionstyle&quot;), category=UserWarning, stacklevel=2</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # NOTE: Arrowstyle modification must occur after the warnings section</span>
<span class="gi">+    if arrowstyle is None:</span>
<span class="gi">+        arrowstyle = &quot;-|&gt;&quot; if G.is_directed() else &quot;-&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if edgelist is None:</span>
<span class="gi">+        edgelist = list(G.edges)  # (u, v, k) for multigraph (u, v) otherwise</span>
<span class="gi">+</span>
<span class="gi">+    if len(edgelist):</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            key_count = collections.defaultdict(lambda: itertools.count(0))</span>
<span class="gi">+            edge_indices = [next(key_count[tuple(e[:2])]) for e in edgelist]</span>
<span class="gi">+        else:</span>
<span class="gi">+            edge_indices = [0] * len(edgelist)</span>
<span class="gi">+    else:  # no edges!</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G.nodes())</span>
<span class="gi">+</span>
<span class="gi">+    # FancyArrowPatch handles color=None different from LineCollection</span>
<span class="gi">+    if edge_color is None:</span>
<span class="gi">+        edge_color = &quot;k&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # set edge positions</span>
<span class="gi">+    edge_pos = np.asarray([(pos[e[0]], pos[e[1]]) for e in edgelist])</span>
<span class="gi">+</span>
<span class="gi">+    # Check if edge_color is an array of floats and map to edge_cmap.</span>
<span class="gi">+    # This is the only case handled differently from matplotlib</span>
<span class="gi">+    if (</span>
<span class="gi">+        np.iterable(edge_color)</span>
<span class="gi">+        and (len(edge_color) == len(edge_pos))</span>
<span class="gi">+        and np.all([isinstance(c, Number) for c in edge_color])</span>
<span class="gi">+    ):</span>
<span class="gi">+        if edge_cmap is not None:</span>
<span class="gi">+            assert isinstance(edge_cmap, mpl.colors.Colormap)</span>
<span class="gi">+        else:</span>
<span class="gi">+            edge_cmap = plt.get_cmap()</span>
<span class="gi">+        if edge_vmin is None:</span>
<span class="gi">+            edge_vmin = min(edge_color)</span>
<span class="gi">+        if edge_vmax is None:</span>
<span class="gi">+            edge_vmax = max(edge_color)</span>
<span class="gi">+        color_normal = mpl.colors.Normalize(vmin=edge_vmin, vmax=edge_vmax)</span>
<span class="gi">+        edge_color = [edge_cmap(color_normal(e)) for e in edge_color]</span>
<span class="gi">+</span>
<span class="gi">+    # compute initial view</span>
<span class="gi">+    minx = np.amin(np.ravel(edge_pos[:, :, 0]))</span>
<span class="gi">+    maxx = np.amax(np.ravel(edge_pos[:, :, 0]))</span>
<span class="gi">+    miny = np.amin(np.ravel(edge_pos[:, :, 1]))</span>
<span class="gi">+    maxy = np.amax(np.ravel(edge_pos[:, :, 1]))</span>
<span class="gi">+    w = maxx - minx</span>
<span class="gi">+    h = maxy - miny</span>
<span class="gi">+</span>
<span class="gi">+    # Self-loops are scaled by view extent, except in cases the extent</span>
<span class="gi">+    # is 0, e.g. for a single node. In this case, fall back to scaling</span>
<span class="gi">+    # by the maximum node size</span>
<span class="gi">+    selfloop_height = h if h != 0 else 0.005 * np.array(node_size).max()</span>
<span class="gi">+    fancy_arrow_factory = FancyArrowFactory(</span>
<span class="gi">+        edge_pos,</span>
<span class="gi">+        edgelist,</span>
<span class="gi">+        nodelist,</span>
<span class="gi">+        edge_indices,</span>
<span class="gi">+        node_size,</span>
<span class="gi">+        selfloop_height,</span>
<span class="gi">+        connectionstyle,</span>
<span class="gi">+        node_shape,</span>
<span class="gi">+        arrowstyle,</span>
<span class="gi">+        arrowsize,</span>
<span class="gi">+        edge_color,</span>
<span class="gi">+        alpha,</span>
<span class="gi">+        width,</span>
<span class="gi">+        style,</span>
<span class="gi">+        min_source_margin,</span>
<span class="gi">+        min_target_margin,</span>
<span class="gi">+        ax=ax,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Draw the edges</span>
<span class="gi">+    if use_linecollection:</span>
<span class="gi">+        edge_collection = mpl.collections.LineCollection(</span>
<span class="gi">+            edge_pos,</span>
<span class="gi">+            colors=edge_color,</span>
<span class="gi">+            linewidths=width,</span>
<span class="gi">+            antialiaseds=(1,),</span>
<span class="gi">+            linestyle=style,</span>
<span class="gi">+            alpha=alpha,</span>
<span class="gi">+        )</span>
<span class="gi">+        edge_collection.set_cmap(edge_cmap)</span>
<span class="gi">+        edge_collection.set_clim(edge_vmin, edge_vmax)</span>
<span class="gi">+        edge_collection.set_zorder(1)  # edges go behind nodes</span>
<span class="gi">+        edge_collection.set_label(label)</span>
<span class="gi">+        ax.add_collection(edge_collection)</span>
<span class="gi">+        edge_viz_obj = edge_collection</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure selfloop edges are also drawn</span>
<span class="gi">+        # ---------------------------------------</span>
<span class="gi">+        selfloops_to_draw = [loop for loop in nx.selfloop_edges(G) if loop in edgelist]</span>
<span class="gi">+        if selfloops_to_draw:</span>
<span class="gi">+            edgelist_tuple = list(map(tuple, edgelist))</span>
<span class="gi">+            arrow_collection = []</span>
<span class="gi">+            for loop in selfloops_to_draw:</span>
<span class="gi">+                i = edgelist_tuple.index(loop)</span>
<span class="gi">+                arrow = fancy_arrow_factory(i)</span>
<span class="gi">+                arrow_collection.append(arrow)</span>
<span class="gi">+                ax.add_patch(arrow)</span>
<span class="gi">+    else:</span>
<span class="gi">+        edge_viz_obj = []</span>
<span class="gi">+        for i in range(len(edgelist)):</span>
<span class="gi">+            arrow = fancy_arrow_factory(i)</span>
<span class="gi">+            ax.add_patch(arrow)</span>
<span class="gi">+            edge_viz_obj.append(arrow)</span>
<span class="gi">+</span>
<span class="gi">+    # update view after drawing</span>
<span class="gi">+    padx, pady = 0.05 * w, 0.05 * h</span>
<span class="gi">+    corners = (minx - padx, miny - pady), (maxx + padx, maxy + pady)</span>
<span class="gi">+    ax.update_datalim(corners)</span>
<span class="gi">+    ax.autoscale_view()</span>
<span class="gi">+</span>
<span class="gi">+    if hide_ticks:</span>
<span class="gi">+        ax.tick_params(</span>
<span class="gi">+            axis=&quot;both&quot;,</span>
<span class="gi">+            which=&quot;both&quot;,</span>
<span class="gi">+            bottom=False,</span>
<span class="gi">+            left=False,</span>
<span class="gi">+            labelbottom=False,</span>
<span class="gi">+            labelleft=False,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return edge_viz_obj</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def draw_networkx_labels(</span>
<span class="gi">+    G,</span>
<span class="gi">+    pos,</span>
<span class="gi">+    labels=None,</span>
<span class="gi">+    font_size=12,</span>
<span class="gi">+    font_color=&quot;k&quot;,</span>
<span class="gi">+    font_family=&quot;sans-serif&quot;,</span>
<span class="gi">+    font_weight=&quot;normal&quot;,</span>
<span class="gi">+    alpha=None,</span>
<span class="gi">+    bbox=None,</span>
<span class="gi">+    horizontalalignment=&quot;center&quot;,</span>
<span class="gi">+    verticalalignment=&quot;center&quot;,</span>
<span class="gi">+    ax=None,</span>
<span class="gi">+    clip_on=True,</span>
<span class="gi">+    hide_ticks=True,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Draw node labels on the graph G.

<span class="w"> </span>    Parameters
<span class="gu">@@ -697,14 +1134,70 @@ def draw_networkx_labels(G, pos, labels=None, font_size=12, font_color=&#39;k&#39;,</span>
<span class="w"> </span>    draw_networkx_edges
<span class="w"> </span>    draw_networkx_edge_labels
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def draw_networkx_edge_labels(G, pos, edge_labels=None, label_pos=0.5,</span>
<span class="gd">-    font_size=10, font_color=&#39;k&#39;, font_family=&#39;sans-serif&#39;, font_weight=</span>
<span class="gd">-    &#39;normal&#39;, alpha=None, bbox=None, horizontalalignment=&#39;center&#39;,</span>
<span class="gd">-    verticalalignment=&#39;center&#39;, ax=None, rotate=True, clip_on=True,</span>
<span class="gd">-    node_size=300, nodelist=None, connectionstyle=&#39;arc3&#39;, hide_ticks=True):</span>
<span class="gi">+    import matplotlib.pyplot as plt</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if labels is None:</span>
<span class="gi">+        labels = {n: n for n in G.nodes()}</span>
<span class="gi">+</span>
<span class="gi">+    text_items = {}  # there is no text collection so we&#39;ll fake one</span>
<span class="gi">+    for n, label in labels.items():</span>
<span class="gi">+        (x, y) = pos[n]</span>
<span class="gi">+        if not isinstance(label, str):</span>
<span class="gi">+            label = str(label)  # this makes &quot;1&quot; and 1 labeled the same</span>
<span class="gi">+        t = ax.text(</span>
<span class="gi">+            x,</span>
<span class="gi">+            y,</span>
<span class="gi">+            label,</span>
<span class="gi">+            size=font_size,</span>
<span class="gi">+            color=font_color,</span>
<span class="gi">+            family=font_family,</span>
<span class="gi">+            weight=font_weight,</span>
<span class="gi">+            alpha=alpha,</span>
<span class="gi">+            horizontalalignment=horizontalalignment,</span>
<span class="gi">+            verticalalignment=verticalalignment,</span>
<span class="gi">+            transform=ax.transData,</span>
<span class="gi">+            bbox=bbox,</span>
<span class="gi">+            clip_on=clip_on,</span>
<span class="gi">+        )</span>
<span class="gi">+        text_items[n] = t</span>
<span class="gi">+</span>
<span class="gi">+    if hide_ticks:</span>
<span class="gi">+        ax.tick_params(</span>
<span class="gi">+            axis=&quot;both&quot;,</span>
<span class="gi">+            which=&quot;both&quot;,</span>
<span class="gi">+            bottom=False,</span>
<span class="gi">+            left=False,</span>
<span class="gi">+            labelbottom=False,</span>
<span class="gi">+            labelleft=False,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return text_items</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def draw_networkx_edge_labels(</span>
<span class="gi">+    G,</span>
<span class="gi">+    pos,</span>
<span class="gi">+    edge_labels=None,</span>
<span class="gi">+    label_pos=0.5,</span>
<span class="gi">+    font_size=10,</span>
<span class="gi">+    font_color=&quot;k&quot;,</span>
<span class="gi">+    font_family=&quot;sans-serif&quot;,</span>
<span class="gi">+    font_weight=&quot;normal&quot;,</span>
<span class="gi">+    alpha=None,</span>
<span class="gi">+    bbox=None,</span>
<span class="gi">+    horizontalalignment=&quot;center&quot;,</span>
<span class="gi">+    verticalalignment=&quot;center&quot;,</span>
<span class="gi">+    ax=None,</span>
<span class="gi">+    rotate=True,</span>
<span class="gi">+    clip_on=True,</span>
<span class="gi">+    node_size=300,</span>
<span class="gi">+    nodelist=None,</span>
<span class="gi">+    connectionstyle=&quot;arc3&quot;,</span>
<span class="gi">+    hide_ticks=True,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Draw edge labels.

<span class="w"> </span>    Parameters
<span class="gu">@@ -797,7 +1290,216 @@ def draw_networkx_edge_labels(G, pos, edge_labels=None, label_pos=0.5,</span>
<span class="w"> </span>    draw_networkx_edges
<span class="w"> </span>    draw_networkx_labels
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import matplotlib as mpl</span>
<span class="gi">+    import matplotlib.pyplot as plt</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    class CurvedArrowText(mpl.text.Text):</span>
<span class="gi">+        def __init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            arrow,</span>
<span class="gi">+            *args,</span>
<span class="gi">+            label_pos=0.5,</span>
<span class="gi">+            labels_horizontal=False,</span>
<span class="gi">+            ax=None,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Bind to FancyArrowPatch</span>
<span class="gi">+            self.arrow = arrow</span>
<span class="gi">+            # how far along the text should be on the curve,</span>
<span class="gi">+            # 0 is at start, 1 is at end etc.</span>
<span class="gi">+            self.label_pos = label_pos</span>
<span class="gi">+            self.labels_horizontal = labels_horizontal</span>
<span class="gi">+            if ax is None:</span>
<span class="gi">+                ax = plt.gca()</span>
<span class="gi">+            self.ax = ax</span>
<span class="gi">+            self.x, self.y, self.angle = self._update_text_pos_angle(arrow)</span>
<span class="gi">+</span>
<span class="gi">+            # Create text object</span>
<span class="gi">+            super().__init__(self.x, self.y, *args, rotation=self.angle, **kwargs)</span>
<span class="gi">+            # Bind to axis</span>
<span class="gi">+            self.ax.add_artist(self)</span>
<span class="gi">+</span>
<span class="gi">+        def _get_arrow_path_disp(self, arrow):</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            This is part of FancyArrowPatch._get_path_in_displaycoord</span>
<span class="gi">+            It omits the second part of the method where path is converted</span>
<span class="gi">+                to polygon based on width</span>
<span class="gi">+            The transform is taken from ax, not the object, as the object</span>
<span class="gi">+                has not been added yet, and doesn&#39;t have transform</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            dpi_cor = arrow._dpi_cor</span>
<span class="gi">+            # trans_data = arrow.get_transform()</span>
<span class="gi">+            trans_data = self.ax.transData</span>
<span class="gi">+            if arrow._posA_posB is not None:</span>
<span class="gi">+                posA = arrow._convert_xy_units(arrow._posA_posB[0])</span>
<span class="gi">+                posB = arrow._convert_xy_units(arrow._posA_posB[1])</span>
<span class="gi">+                (posA, posB) = trans_data.transform((posA, posB))</span>
<span class="gi">+                _path = arrow.get_connectionstyle()(</span>
<span class="gi">+                    posA,</span>
<span class="gi">+                    posB,</span>
<span class="gi">+                    patchA=arrow.patchA,</span>
<span class="gi">+                    patchB=arrow.patchB,</span>
<span class="gi">+                    shrinkA=arrow.shrinkA * dpi_cor,</span>
<span class="gi">+                    shrinkB=arrow.shrinkB * dpi_cor,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                _path = trans_data.transform_path(arrow._path_original)</span>
<span class="gi">+            # Return is in display coordinates</span>
<span class="gi">+            return _path</span>
<span class="gi">+</span>
<span class="gi">+        def _update_text_pos_angle(self, arrow):</span>
<span class="gi">+            # Fractional label position</span>
<span class="gi">+            path_disp = self._get_arrow_path_disp(arrow)</span>
<span class="gi">+            (x1, y1), (cx, cy), (x2, y2) = path_disp.vertices</span>
<span class="gi">+            # Text position at a proportion t along the line in display coords</span>
<span class="gi">+            # default is 0.5 so text appears at the halfway point</span>
<span class="gi">+            t = self.label_pos</span>
<span class="gi">+            tt = 1 - t</span>
<span class="gi">+            x = tt**2 * x1 + 2 * t * tt * cx + t**2 * x2</span>
<span class="gi">+            y = tt**2 * y1 + 2 * t * tt * cy + t**2 * y2</span>
<span class="gi">+            if self.labels_horizontal:</span>
<span class="gi">+                # Horizontal text labels</span>
<span class="gi">+                angle = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Labels parallel to curve</span>
<span class="gi">+                change_x = 2 * tt * (cx - x1) + 2 * t * (x2 - cx)</span>
<span class="gi">+                change_y = 2 * tt * (cy - y1) + 2 * t * (y2 - cy)</span>
<span class="gi">+                angle = (np.arctan2(change_y, change_x) / (2 * np.pi)) * 360</span>
<span class="gi">+                # Text is &quot;right way up&quot;</span>
<span class="gi">+                if angle &gt; 90:</span>
<span class="gi">+                    angle -= 180</span>
<span class="gi">+                if angle &lt; -90:</span>
<span class="gi">+                    angle += 180</span>
<span class="gi">+            (x, y) = self.ax.transData.inverted().transform((x, y))</span>
<span class="gi">+            return x, y, angle</span>
<span class="gi">+</span>
<span class="gi">+        def draw(self, renderer):</span>
<span class="gi">+            # recalculate the text position and angle</span>
<span class="gi">+            self.x, self.y, self.angle = self._update_text_pos_angle(self.arrow)</span>
<span class="gi">+            self.set_position((self.x, self.y))</span>
<span class="gi">+            self.set_rotation(self.angle)</span>
<span class="gi">+            # redraw text</span>
<span class="gi">+            super().draw(renderer)</span>
<span class="gi">+</span>
<span class="gi">+    # use default box of white with white border</span>
<span class="gi">+    if bbox is None:</span>
<span class="gi">+        bbox = {&quot;boxstyle&quot;: &quot;round&quot;, &quot;ec&quot;: (1.0, 1.0, 1.0), &quot;fc&quot;: (1.0, 1.0, 1.0)}</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(connectionstyle, str):</span>
<span class="gi">+        connectionstyle = [connectionstyle]</span>
<span class="gi">+    elif np.iterable(connectionstyle):</span>
<span class="gi">+        connectionstyle = list(connectionstyle)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;draw_networkx_edges arg `connectionstyle` must be&quot;</span>
<span class="gi">+            &quot;string or iterable of strings&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if ax is None:</span>
<span class="gi">+        ax = plt.gca()</span>
<span class="gi">+</span>
<span class="gi">+    if edge_labels is None:</span>
<span class="gi">+        kwds = {&quot;keys&quot;: True} if G.is_multigraph() else {}</span>
<span class="gi">+        edge_labels = {tuple(edge): d for *edge, d in G.edges(data=True, **kwds)}</span>
<span class="gi">+    # NOTHING TO PLOT</span>
<span class="gi">+    if not edge_labels:</span>
<span class="gi">+        return {}</span>
<span class="gi">+    edgelist, labels = zip(*edge_labels.items())</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G.nodes())</span>
<span class="gi">+</span>
<span class="gi">+    # set edge positions</span>
<span class="gi">+    edge_pos = np.asarray([(pos[e[0]], pos[e[1]]) for e in edgelist])</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        key_count = collections.defaultdict(lambda: itertools.count(0))</span>
<span class="gi">+        edge_indices = [next(key_count[tuple(e[:2])]) for e in edgelist]</span>
<span class="gi">+    else:</span>
<span class="gi">+        edge_indices = [0] * len(edgelist)</span>
<span class="gi">+</span>
<span class="gi">+    # Used to determine self loop mid-point</span>
<span class="gi">+    # Note, that this will not be accurate,</span>
<span class="gi">+    #   if not drawing edge_labels for all edges drawn</span>
<span class="gi">+    h = 0</span>
<span class="gi">+    if edge_labels:</span>
<span class="gi">+        miny = np.amin(np.ravel(edge_pos[:, :, 1]))</span>
<span class="gi">+        maxy = np.amax(np.ravel(edge_pos[:, :, 1]))</span>
<span class="gi">+        h = maxy - miny</span>
<span class="gi">+    selfloop_height = h if h != 0 else 0.005 * np.array(node_size).max()</span>
<span class="gi">+    fancy_arrow_factory = FancyArrowFactory(</span>
<span class="gi">+        edge_pos,</span>
<span class="gi">+        edgelist,</span>
<span class="gi">+        nodelist,</span>
<span class="gi">+        edge_indices,</span>
<span class="gi">+        node_size,</span>
<span class="gi">+        selfloop_height,</span>
<span class="gi">+        connectionstyle,</span>
<span class="gi">+        ax=ax,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    text_items = {}</span>
<span class="gi">+    for i, (edge, label) in enumerate(zip(edgelist, labels)):</span>
<span class="gi">+        if not isinstance(label, str):</span>
<span class="gi">+            label = str(label)  # this makes &quot;1&quot; and 1 labeled the same</span>
<span class="gi">+</span>
<span class="gi">+        n1, n2 = edge[:2]</span>
<span class="gi">+        arrow = fancy_arrow_factory(i)</span>
<span class="gi">+        if n1 == n2:</span>
<span class="gi">+            connectionstyle_obj = arrow.get_connectionstyle()</span>
<span class="gi">+            posA = ax.transData.transform(pos[n1])</span>
<span class="gi">+            path_disp = connectionstyle_obj(posA, posA)</span>
<span class="gi">+            path_data = ax.transData.inverted().transform_path(path_disp)</span>
<span class="gi">+            x, y = path_data.vertices[0]</span>
<span class="gi">+            text_items[edge] = ax.text(</span>
<span class="gi">+                x,</span>
<span class="gi">+                y,</span>
<span class="gi">+                label,</span>
<span class="gi">+                size=font_size,</span>
<span class="gi">+                color=font_color,</span>
<span class="gi">+                family=font_family,</span>
<span class="gi">+                weight=font_weight,</span>
<span class="gi">+                alpha=alpha,</span>
<span class="gi">+                horizontalalignment=horizontalalignment,</span>
<span class="gi">+                verticalalignment=verticalalignment,</span>
<span class="gi">+                rotation=0,</span>
<span class="gi">+                transform=ax.transData,</span>
<span class="gi">+                bbox=bbox,</span>
<span class="gi">+                zorder=1,</span>
<span class="gi">+                clip_on=clip_on,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            text_items[edge] = CurvedArrowText(</span>
<span class="gi">+                arrow,</span>
<span class="gi">+                label,</span>
<span class="gi">+                size=font_size,</span>
<span class="gi">+                color=font_color,</span>
<span class="gi">+                family=font_family,</span>
<span class="gi">+                weight=font_weight,</span>
<span class="gi">+                alpha=alpha,</span>
<span class="gi">+                horizontalalignment=horizontalalignment,</span>
<span class="gi">+                verticalalignment=verticalalignment,</span>
<span class="gi">+                transform=ax.transData,</span>
<span class="gi">+                bbox=bbox,</span>
<span class="gi">+                zorder=1,</span>
<span class="gi">+                clip_on=clip_on,</span>
<span class="gi">+                label_pos=label_pos,</span>
<span class="gi">+                labels_horizontal=not rotate,</span>
<span class="gi">+                ax=ax,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    if hide_ticks:</span>
<span class="gi">+        ax.tick_params(</span>
<span class="gi">+            axis=&quot;both&quot;,</span>
<span class="gi">+            which=&quot;both&quot;,</span>
<span class="gi">+            bottom=False,</span>
<span class="gi">+            left=False,</span>
<span class="gi">+            labelbottom=False,</span>
<span class="gi">+            labelleft=False,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return text_items</span>


<span class="w"> </span>def draw_circular(G, **kwargs):
<span class="gu">@@ -836,7 +1538,7 @@ def draw_circular(G, **kwargs):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    :func:`~networkx.drawing.layout.circular_layout`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    draw(G, circular_layout(G), **kwargs)</span>


<span class="w"> </span>def draw_kamada_kawai(G, **kwargs):
<span class="gu">@@ -876,7 +1578,7 @@ def draw_kamada_kawai(G, **kwargs):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    :func:`~networkx.drawing.layout.kamada_kawai_layout`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    draw(G, kamada_kawai_layout(G), **kwargs)</span>


<span class="w"> </span>def draw_random(G, **kwargs):
<span class="gu">@@ -915,7 +1617,7 @@ def draw_random(G, **kwargs):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    :func:`~networkx.drawing.layout.random_layout`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    draw(G, random_layout(G), **kwargs)</span>


<span class="w"> </span>def draw_spectral(G, **kwargs):
<span class="gu">@@ -957,7 +1659,7 @@ def draw_spectral(G, **kwargs):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    :func:`~networkx.drawing.layout.spectral_layout`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    draw(G, spectral_layout(G), **kwargs)</span>


<span class="w"> </span>def draw_spring(G, **kwargs):
<span class="gu">@@ -1000,7 +1702,7 @@ def draw_spring(G, **kwargs):</span>
<span class="w"> </span>    draw
<span class="w"> </span>    :func:`~networkx.drawing.layout.spring_layout`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    draw(G, spring_layout(G), **kwargs)</span>


<span class="w"> </span>def draw_shell(G, nlist=None, **kwargs):
<span class="gu">@@ -1045,7 +1747,7 @@ def draw_shell(G, nlist=None, **kwargs):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    :func:`~networkx.drawing.layout.shell_layout`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    draw(G, shell_layout(G, nlist=nlist), **kwargs)</span>


<span class="w"> </span>def draw_planar(G, **kwargs):
<span class="gu">@@ -1089,7 +1791,7 @@ def draw_planar(G, **kwargs):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    :func:`~networkx.drawing.layout.planar_layout`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    draw(G, planar_layout(G), **kwargs)</span>


<span class="w"> </span>def apply_alpha(colors, alpha, elem_list, cmap=None, vmin=None, vmax=None):
<span class="gu">@@ -1129,4 +1831,41 @@ def apply_alpha(colors, alpha, elem_list, cmap=None, vmin=None, vmax=None):</span>
<span class="w"> </span>        Array containing RGBA format values for each of the node colours.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from itertools import cycle, islice</span>
<span class="gi">+</span>
<span class="gi">+    import matplotlib as mpl</span>
<span class="gi">+    import matplotlib.cm  # call as mpl.cm</span>
<span class="gi">+    import matplotlib.colors  # call as mpl.colors</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    # If we have been provided with a list of numbers as long as elem_list,</span>
<span class="gi">+    # apply the color mapping.</span>
<span class="gi">+    if len(colors) == len(elem_list) and isinstance(colors[0], Number):</span>
<span class="gi">+        mapper = mpl.cm.ScalarMappable(cmap=cmap)</span>
<span class="gi">+        mapper.set_clim(vmin, vmax)</span>
<span class="gi">+        rgba_colors = mapper.to_rgba(colors)</span>
<span class="gi">+    # Otherwise, convert colors to matplotlib&#39;s RGB using the colorConverter</span>
<span class="gi">+    # object.  These are converted to numpy ndarrays to be consistent with the</span>
<span class="gi">+    # to_rgba method of ScalarMappable.</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            rgba_colors = np.array([mpl.colors.colorConverter.to_rgba(colors)])</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            rgba_colors = np.array(</span>
<span class="gi">+                [mpl.colors.colorConverter.to_rgba(color) for color in colors]</span>
<span class="gi">+            )</span>
<span class="gi">+    # Set the final column of the rgba_colors to have the relevant alpha values</span>
<span class="gi">+    try:</span>
<span class="gi">+        # If alpha is longer than the number of colors, resize to the number of</span>
<span class="gi">+        # elements.  Also, if rgba_colors.size (the number of elements of</span>
<span class="gi">+        # rgba_colors) is the same as the number of elements, resize the array,</span>
<span class="gi">+        # to avoid it being interpreted as a colormap by scatter()</span>
<span class="gi">+        if len(alpha) &gt; len(rgba_colors) or rgba_colors.size == len(elem_list):</span>
<span class="gi">+            rgba_colors = np.resize(rgba_colors, (len(elem_list), 4))</span>
<span class="gi">+            rgba_colors[1:, 0] = rgba_colors[0, 0]</span>
<span class="gi">+            rgba_colors[1:, 1] = rgba_colors[0, 1]</span>
<span class="gi">+            rgba_colors[1:, 2] = rgba_colors[0, 2]</span>
<span class="gi">+        rgba_colors[:, 3] = list(islice(cycle(alpha), len(rgba_colors)))</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        rgba_colors[:, -1] = alpha</span>
<span class="gi">+    return rgba_colors</span>
<span class="gh">diff --git a/networkx/exception.py b/networkx/exception.py</span>
<span class="gh">index adf73034e..96694cc32 100644</span>
<span class="gd">--- a/networkx/exception.py</span>
<span class="gi">+++ b/networkx/exception.py</span>
<span class="gu">@@ -5,11 +5,23 @@ Exceptions</span>

<span class="w"> </span>Base exceptions and errors for NetworkX.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;HasACycle&#39;, &#39;NodeNotFound&#39;, &#39;PowerIterationFailedConvergence&#39;,</span>
<span class="gd">-    &#39;ExceededMaxIterations&#39;, &#39;AmbiguousSolution&#39;, &#39;NetworkXAlgorithmError&#39;,</span>
<span class="gd">-    &#39;NetworkXException&#39;, &#39;NetworkXError&#39;, &#39;NetworkXNoCycle&#39;,</span>
<span class="gd">-    &#39;NetworkXNoPath&#39;, &#39;NetworkXNotImplemented&#39;, &#39;NetworkXPointlessConcept&#39;,</span>
<span class="gd">-    &#39;NetworkXUnbounded&#39;, &#39;NetworkXUnfeasible&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;HasACycle&quot;,</span>
<span class="gi">+    &quot;NodeNotFound&quot;,</span>
<span class="gi">+    &quot;PowerIterationFailedConvergence&quot;,</span>
<span class="gi">+    &quot;ExceededMaxIterations&quot;,</span>
<span class="gi">+    &quot;AmbiguousSolution&quot;,</span>
<span class="gi">+    &quot;NetworkXAlgorithmError&quot;,</span>
<span class="gi">+    &quot;NetworkXException&quot;,</span>
<span class="gi">+    &quot;NetworkXError&quot;,</span>
<span class="gi">+    &quot;NetworkXNoCycle&quot;,</span>
<span class="gi">+    &quot;NetworkXNoPath&quot;,</span>
<span class="gi">+    &quot;NetworkXNotImplemented&quot;,</span>
<span class="gi">+    &quot;NetworkXPointlessConcept&quot;,</span>
<span class="gi">+    &quot;NetworkXUnbounded&quot;,</span>
<span class="gi">+    &quot;NetworkXUnfeasible&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class NetworkXException(Exception):
<span class="gu">@@ -107,9 +119,7 @@ class PowerIterationFailedConvergence(ExceededMaxIterations):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, num_iterations, *args, **kw):
<span class="gd">-        msg = (</span>
<span class="gd">-            f&#39;power iteration failed to converge within {num_iterations} iterations&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        msg = f&quot;power iteration failed to converge within {num_iterations} iterations&quot;</span>
<span class="w"> </span>        exception_message = msg
<span class="w"> </span>        superinit = super().__init__
<span class="w"> </span>        superinit(self, exception_message, *args, **kw)
<span class="gh">diff --git a/networkx/generators/atlas.py b/networkx/generators/atlas.py</span>
<span class="gh">index 708531538..262443628 100644</span>
<span class="gd">--- a/networkx/generators/atlas.py</span>
<span class="gi">+++ b/networkx/generators/atlas.py</span>
<span class="gu">@@ -6,10 +6,52 @@ import importlib.resources</span>
<span class="w"> </span>import os
<span class="w"> </span>import os.path
<span class="w"> </span>from itertools import islice
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;graph_atlas&#39;, &#39;graph_atlas_g&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;graph_atlas&quot;, &quot;graph_atlas_g&quot;]</span>
<span class="gi">+</span>
<span class="gi">+#: The total number of graphs in the atlas.</span>
<span class="gi">+#:</span>
<span class="gi">+#: The graphs are labeled starting from 0 and extending to (but not</span>
<span class="gi">+#: including) this number.</span>
<span class="w"> </span>NUM_GRAPHS = 1253
<span class="gd">-ATLAS_FILE = importlib.resources.files(&#39;networkx.generators&#39;) / &#39;atlas.dat.gz&#39;</span>
<span class="gi">+</span>
<span class="gi">+#: The path to the data file containing the graph edge lists.</span>
<span class="gi">+#:</span>
<span class="gi">+#: This is the absolute path of the gzipped text file containing the</span>
<span class="gi">+#: edge list for each graph in the atlas. The file contains one entry</span>
<span class="gi">+#: per graph in the atlas, in sequential order, starting from graph</span>
<span class="gi">+#: number 0 and extending through graph number 1252 (see</span>
<span class="gi">+#: :data:`NUM_GRAPHS`). Each entry looks like</span>
<span class="gi">+#:</span>
<span class="gi">+#: .. sourcecode:: text</span>
<span class="gi">+#:</span>
<span class="gi">+#:    GRAPH 6</span>
<span class="gi">+#:    NODES 3</span>
<span class="gi">+#:    0 1</span>
<span class="gi">+#:    0 2</span>
<span class="gi">+#:</span>
<span class="gi">+#: where the first two lines are the graph&#39;s index in the atlas and the</span>
<span class="gi">+#: number of nodes in the graph, and the remaining lines are the edge</span>
<span class="gi">+#: list.</span>
<span class="gi">+#:</span>
<span class="gi">+#: This file was generated from a Python list of graphs via code like</span>
<span class="gi">+#: the following::</span>
<span class="gi">+#:</span>
<span class="gi">+#:     import gzip</span>
<span class="gi">+#:     from networkx.generators.atlas import graph_atlas_g</span>
<span class="gi">+#:     from networkx.readwrite.edgelist import write_edgelist</span>
<span class="gi">+#:</span>
<span class="gi">+#:     with gzip.open(&#39;atlas.dat.gz&#39;, &#39;wb&#39;) as f:</span>
<span class="gi">+#:         for i, G in enumerate(graph_atlas_g()):</span>
<span class="gi">+#:             f.write(bytes(f&#39;GRAPH {i}\n&#39;, encoding=&#39;utf-8&#39;))</span>
<span class="gi">+#:             f.write(bytes(f&#39;NODES {len(G)}\n&#39;, encoding=&#39;utf-8&#39;))</span>
<span class="gi">+#:             write_edgelist(G, f, data=False)</span>
<span class="gi">+#:</span>
<span class="gi">+</span>
<span class="gi">+# Path to the atlas file</span>
<span class="gi">+ATLAS_FILE = importlib.resources.files(&quot;networkx.generators&quot;) / &quot;atlas.dat.gz&quot;</span>


<span class="w"> </span>def _generate_graphs():
<span class="gu">@@ -19,7 +61,31 @@ def _generate_graphs():</span>
<span class="w"> </span>    This function reads the file given in :data:`.ATLAS_FILE`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with gzip.open(ATLAS_FILE, &quot;rb&quot;) as f:</span>
<span class="gi">+        line = f.readline()</span>
<span class="gi">+        while line and line.startswith(b&quot;GRAPH&quot;):</span>
<span class="gi">+            # The first two lines of each entry tell us the index of the</span>
<span class="gi">+            # graph in the list and the number of nodes in the graph.</span>
<span class="gi">+            # They look like this:</span>
<span class="gi">+            #</span>
<span class="gi">+            #     GRAPH 3</span>
<span class="gi">+            #     NODES 2</span>
<span class="gi">+            #</span>
<span class="gi">+            graph_index = int(line[6:].rstrip())</span>
<span class="gi">+            line = f.readline()</span>
<span class="gi">+            num_nodes = int(line[6:].rstrip())</span>
<span class="gi">+            # The remaining lines contain the edge list, until the next</span>
<span class="gi">+            # GRAPH line (or until the end of the file).</span>
<span class="gi">+            edgelist = []</span>
<span class="gi">+            line = f.readline()</span>
<span class="gi">+            while line and not line.startswith(b&quot;GRAPH&quot;):</span>
<span class="gi">+                edgelist.append(line.rstrip())</span>
<span class="gi">+                line = f.readline()</span>
<span class="gi">+            G = nx.Graph()</span>
<span class="gi">+            G.name = f&quot;G{graph_index}&quot;</span>
<span class="gi">+            G.add_nodes_from(range(num_nodes))</span>
<span class="gi">+            G.add_edges_from(tuple(map(int, e.split())) for e in edgelist)</span>
<span class="gi">+            yield G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -56,7 +122,9 @@ def graph_atlas(i):</span>
<span class="w"> </span>           Oxford University Press, 1998.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not (0 &lt;= i &lt; NUM_GRAPHS):</span>
<span class="gi">+        raise ValueError(f&quot;index must be between 0 and {NUM_GRAPHS}&quot;)</span>
<span class="gi">+    return next(islice(_generate_graphs(), i, None))</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -108,4 +176,4 @@ def graph_atlas_g():</span>
<span class="w"> </span>               Oxford University Press, 1998.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(_generate_graphs())</span>
<span class="gh">diff --git a/networkx/generators/classic.py b/networkx/generators/classic.py</span>
<span class="gh">index 7ebfc0fb5..4278a338d 100644</span>
<span class="gd">--- a/networkx/generators/classic.py</span>
<span class="gi">+++ b/networkx/generators/classic.py</span>
<span class="gu">@@ -9,19 +9,61 @@ as a simple graph. Except for `empty_graph`, all the functions</span>
<span class="w"> </span>in this module return a Graph class (i.e. a simple, undirected graph).

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>import numbers
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.classes import Graph
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.utils import nodes_or_number, pairwise
<span class="gd">-__all__ = [&#39;balanced_tree&#39;, &#39;barbell_graph&#39;, &#39;binomial_tree&#39;,</span>
<span class="gd">-    &#39;complete_graph&#39;, &#39;complete_multipartite_graph&#39;,</span>
<span class="gd">-    &#39;circular_ladder_graph&#39;, &#39;circulant_graph&#39;, &#39;cycle_graph&#39;,</span>
<span class="gd">-    &#39;dorogovtsev_goltsev_mendes_graph&#39;, &#39;empty_graph&#39;, &#39;full_rary_tree&#39;,</span>
<span class="gd">-    &#39;kneser_graph&#39;, &#39;ladder_graph&#39;, &#39;lollipop_graph&#39;, &#39;null_graph&#39;,</span>
<span class="gd">-    &#39;path_graph&#39;, &#39;star_graph&#39;, &#39;tadpole_graph&#39;, &#39;trivial_graph&#39;,</span>
<span class="gd">-    &#39;turan_graph&#39;, &#39;wheel_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;balanced_tree&quot;,</span>
<span class="gi">+    &quot;barbell_graph&quot;,</span>
<span class="gi">+    &quot;binomial_tree&quot;,</span>
<span class="gi">+    &quot;complete_graph&quot;,</span>
<span class="gi">+    &quot;complete_multipartite_graph&quot;,</span>
<span class="gi">+    &quot;circular_ladder_graph&quot;,</span>
<span class="gi">+    &quot;circulant_graph&quot;,</span>
<span class="gi">+    &quot;cycle_graph&quot;,</span>
<span class="gi">+    &quot;dorogovtsev_goltsev_mendes_graph&quot;,</span>
<span class="gi">+    &quot;empty_graph&quot;,</span>
<span class="gi">+    &quot;full_rary_tree&quot;,</span>
<span class="gi">+    &quot;kneser_graph&quot;,</span>
<span class="gi">+    &quot;ladder_graph&quot;,</span>
<span class="gi">+    &quot;lollipop_graph&quot;,</span>
<span class="gi">+    &quot;null_graph&quot;,</span>
<span class="gi">+    &quot;path_graph&quot;,</span>
<span class="gi">+    &quot;star_graph&quot;,</span>
<span class="gi">+    &quot;tadpole_graph&quot;,</span>
<span class="gi">+    &quot;trivial_graph&quot;,</span>
<span class="gi">+    &quot;turan_graph&quot;,</span>
<span class="gi">+    &quot;wheel_graph&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# -------------------------------------------------------------------</span>
<span class="gi">+#   Some Classic Graphs</span>
<span class="gi">+# -------------------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _tree_edges(n, r):</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        return</span>
<span class="gi">+    # helper function for trees</span>
<span class="gi">+    # yields edges in rooted tree at 0 with n nodes and branching ratio r</span>
<span class="gi">+    nodes = iter(range(n))</span>
<span class="gi">+    parents = [next(nodes)]  # stack of max length r</span>
<span class="gi">+    while parents:</span>
<span class="gi">+        source = parents.pop(0)</span>
<span class="gi">+        for i in range(r):</span>
<span class="gi">+            try:</span>
<span class="gi">+                target = next(nodes)</span>
<span class="gi">+                parents.append(target)</span>
<span class="gi">+                yield source, target</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                break</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -57,7 +99,9 @@ def full_rary_tree(r, n, create_using=None):</span>
<span class="w"> </span>    .. [1] An introduction to data structures and algorithms,
<span class="w"> </span>           James Andrew Storer,  Birkhauser Boston 2001, (page 225).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(n, create_using)</span>
<span class="gi">+    G.add_edges_from(_tree_edges(n, r))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -89,7 +133,22 @@ def kneser_graph(n, k):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.is_isomorphic(G, nx.petersen_graph())
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt;= 0:</span>
<span class="gi">+        raise NetworkXError(&quot;n should be greater than zero&quot;)</span>
<span class="gi">+    if k &lt;= 0 or k &gt; n:</span>
<span class="gi">+        raise NetworkXError(&quot;k should be greater than zero and smaller than n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    # Create all k-subsets of [0, 1, ..., n-1]</span>
<span class="gi">+    subsets = list(itertools.combinations(range(n), k))</span>
<span class="gi">+</span>
<span class="gi">+    if 2 * k &gt; n:</span>
<span class="gi">+        G.add_nodes_from(subsets)</span>
<span class="gi">+</span>
<span class="gi">+    universe = set(range(n))</span>
<span class="gi">+    comb = itertools.combinations  # only to make it all fit on one line</span>
<span class="gi">+    G.add_edges_from((s, t) for s in subsets for t in comb(universe - set(s), k))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -128,7 +187,18 @@ def balanced_tree(r, h, create_using=None):</span>
<span class="w"> </span>    A balanced tree is also known as a *complete r-ary tree*.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The number of nodes in the balanced tree is `1 + r + ... + r^h`,</span>
<span class="gi">+    # which is computed by using the closed-form formula for a geometric</span>
<span class="gi">+    # sum with ratio `r`. In the special case that `r` is 1, the number</span>
<span class="gi">+    # of nodes is simply `h + 1` (since the tree is actually a path</span>
<span class="gi">+    # graph).</span>
<span class="gi">+    if r == 1:</span>
<span class="gi">+        n = h + 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        # This must be an integer if both `r` and `h` are integers. If</span>
<span class="gi">+        # they are not, we force integer division anyway.</span>
<span class="gi">+        n = (1 - r ** (h + 1)) // (1 - r)</span>
<span class="gi">+    return full_rary_tree(r, n, create_using=create_using)</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -176,7 +246,32 @@ def barbell_graph(m1, m2, create_using=None):</span>
<span class="w"> </span>    and Jim Fill&#39;s e-text on Random Walks on Graphs.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if m1 &lt; 2:</span>
<span class="gi">+        raise NetworkXError(&quot;Invalid graph description, m1 should be &gt;=2&quot;)</span>
<span class="gi">+    if m2 &lt; 0:</span>
<span class="gi">+        raise NetworkXError(&quot;Invalid graph description, m2 should be &gt;=0&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # left barbell</span>
<span class="gi">+    G = complete_graph(m1, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # connecting path</span>
<span class="gi">+    G.add_nodes_from(range(m1, m1 + m2 - 1))</span>
<span class="gi">+    if m2 &gt; 1:</span>
<span class="gi">+        G.add_edges_from(pairwise(range(m1, m1 + m2)))</span>
<span class="gi">+</span>
<span class="gi">+    # right barbell</span>
<span class="gi">+    G.add_edges_from(</span>
<span class="gi">+        (u, v) for u in range(m1 + m2, 2 * m1 + m2) for v in range(u + 1, 2 * m1 + m2)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # connect it up</span>
<span class="gi">+    G.add_edge(m1 - 1, m1)</span>
<span class="gi">+    if m2 &gt; 0:</span>
<span class="gi">+        G.add_edge(m1 + m2 - 1, m1 + m2)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -205,7 +300,16 @@ def binomial_tree(n, create_using=None):</span>
<span class="w"> </span>        A binomial tree of $2^n$ nodes and $2^n - 1$ edges.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(1, create_using)</span>
<span class="gi">+</span>
<span class="gi">+    N = 1</span>
<span class="gi">+    for i in range(n):</span>
<span class="gi">+        # Use G.edges() to ensure 2-tuples. G.edges is 3-tuple for MultiGraph</span>
<span class="gi">+        edges = [(u + N, v + N) for (u, v) in G.edges()]</span>
<span class="gi">+        G.add_edges_from(edges)</span>
<span class="gi">+        G.add_edge(0, N)</span>
<span class="gi">+        N *= 2</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -245,7 +349,15 @@ def complete_graph(n, create_using=None):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _, nodes = n</span>
<span class="gi">+    G = empty_graph(nodes, create_using)</span>
<span class="gi">+    if len(nodes) &gt; 1:</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            edges = itertools.permutations(nodes, 2)</span>
<span class="gi">+        else:</span>
<span class="gi">+            edges = itertools.combinations(nodes, 2)</span>
<span class="gi">+        G.add_edges_from(edges)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -262,15 +374,18 @@ def circular_ladder_graph(n, create_using=None):</span>
<span class="w"> </span>        &gt;&gt;&gt; nx.draw(nx.circular_ladder_graph(5))

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = ladder_graph(n, create_using)</span>
<span class="gi">+    G.add_edge(0, n - 1)</span>
<span class="gi">+    G.add_edge(n, 2 * n - 1)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def circulant_graph(n, offsets, create_using=None):
<span class="gd">-    &quot;&quot;&quot;Returns the circulant graph $Ci_n(x_1, x_2, ..., x_m)$ with $n$ nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the circulant graph $Ci_n(x_1, x_2, ..., x_m)$ with $n$ nodes.</span>

<span class="w"> </span>    The circulant graph $Ci_n(x_1, ..., x_m)$ consists of $n$ nodes $0, ..., n-1$
<span class="gd">-    such that node $i$ is connected to nodes $(i + x) \\mod n$ and $(i - x) \\mod n$</span>
<span class="gi">+    such that node $i$ is connected to nodes $(i + x) \mod n$ and $(i - x) \mod n$</span>
<span class="w"> </span>    for all $x$ in $x_1, ..., x_m$. Thus $Ci_n(1)$ is a cycle graph.

<span class="w"> </span>    .. plot::
<span class="gu">@@ -332,7 +447,12 @@ def circulant_graph(n, offsets, create_using=None):</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(n, create_using)</span>
<span class="gi">+    for i in range(n):</span>
<span class="gi">+        for j in offsets:</span>
<span class="gi">+            G.add_edge(i, (i - j) % n)</span>
<span class="gi">+            G.add_edge(i, (i + j) % n)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -361,7 +481,10 @@ def cycle_graph(n, create_using=None):</span>
<span class="w"> </span>    If create_using is directed, the direction is in increasing order.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _, nodes = n</span>
<span class="gi">+    G = empty_graph(nodes, create_using)</span>
<span class="gi">+    G.add_edges_from(pairwise(nodes, cyclic=True))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -406,7 +529,24 @@ def dorogovtsev_goltsev_mendes_graph(n, create_using=None):</span>
<span class="w"> </span>        &quot;Pseudofractal scale-free web&quot;, Physical Review E 65, 066122, 2002.
<span class="w"> </span>        https://arxiv.org/pdf/cond-mat/0112143.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(0, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        raise NetworkXError(&quot;Multigraph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G.add_edge(0, 1)</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+    new_node = 2  # next node to be added</span>
<span class="gi">+    for i in range(1, n + 1):  # iterate over number of generations.</span>
<span class="gi">+        last_generation_edges = list(G.edges())</span>
<span class="gi">+        number_of_edges_in_last_generation = len(last_generation_edges)</span>
<span class="gi">+        for j in range(number_of_edges_in_last_generation):</span>
<span class="gi">+            G.add_edge(new_node, last_generation_edges[j][0])</span>
<span class="gi">+            G.add_edge(new_node, last_generation_edges[j][1])</span>
<span class="gi">+            new_node += 1</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -492,7 +632,20 @@ def empty_graph(n=0, create_using=None, default=Graph):</span>
<span class="w"> </span>    See also create_empty_copy(G).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if create_using is None:</span>
<span class="gi">+        G = default()</span>
<span class="gi">+    elif isinstance(create_using, type):</span>
<span class="gi">+        G = create_using()</span>
<span class="gi">+    elif not hasattr(create_using, &quot;adj&quot;):</span>
<span class="gi">+        raise TypeError(&quot;create_using is not a valid NetworkX graph type or instance&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # create_using is a NetworkX style Graph</span>
<span class="gi">+        create_using.clear()</span>
<span class="gi">+        G = create_using</span>
<span class="gi">+</span>
<span class="gi">+    _, nodes = n</span>
<span class="gi">+    G.add_nodes_from(nodes)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -509,7 +662,13 @@ def ladder_graph(n, create_using=None):</span>
<span class="w"> </span>        &gt;&gt;&gt; nx.draw(nx.ladder_graph(5))

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(2 * n, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+    G.add_edges_from(pairwise(range(n)))</span>
<span class="gi">+    G.add_edges_from(pairwise(range(n, 2 * n)))</span>
<span class="gi">+    G.add_edges_from((v, v + n) for v in range(n))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -550,7 +709,33 @@ def lollipop_graph(m, n, create_using=None):</span>
<span class="w"> </span>    Fill&#39;s etext on Random Walks on Graphs.)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    m, m_nodes = m</span>
<span class="gi">+    M = len(m_nodes)</span>
<span class="gi">+    if M &lt; 2:</span>
<span class="gi">+        raise NetworkXError(&quot;Invalid description: m should indicate at least 2 nodes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    n, n_nodes = n</span>
<span class="gi">+    if isinstance(m, numbers.Integral) and isinstance(n, numbers.Integral):</span>
<span class="gi">+        n_nodes = list(range(M, M + n))</span>
<span class="gi">+    N = len(n_nodes)</span>
<span class="gi">+</span>
<span class="gi">+    # the ball</span>
<span class="gi">+    G = complete_graph(m_nodes, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # the stick</span>
<span class="gi">+    G.add_nodes_from(n_nodes)</span>
<span class="gi">+    if N &gt; 1:</span>
<span class="gi">+        G.add_edges_from(pairwise(n_nodes))</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) != M + N:</span>
<span class="gi">+        raise NetworkXError(&quot;Nodes must be distinct in containers m and n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # connect ball to stick</span>
<span class="gi">+    if M &gt; 0 and N &gt; 0:</span>
<span class="gi">+        G.add_edge(m_nodes[-1], n_nodes[0])</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -560,7 +745,8 @@ def null_graph(create_using=None):</span>
<span class="w"> </span>    See empty_graph for the use of create_using.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(0, create_using)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -583,7 +769,10 @@ def path_graph(n, create_using=None):</span>
<span class="w"> </span>       Graph type to create. If graph instance, then cleared before populated.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _, nodes = n</span>
<span class="gi">+    G = empty_graph(nodes, create_using)</span>
<span class="gi">+    G.add_edges_from(pairwise(nodes))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -612,7 +801,17 @@ def star_graph(n, create_using=None):</span>
<span class="w"> </span>    The graph has n+1 nodes for integer n.
<span class="w"> </span>    So star_graph(3) is the same as star_graph(range(4)).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n, nodes = n</span>
<span class="gi">+    if isinstance(n, numbers.Integral):</span>
<span class="gi">+        nodes.append(int(n))  # there should be n+1 nodes</span>
<span class="gi">+    G = empty_graph(nodes, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if len(nodes) &gt; 1:</span>
<span class="gi">+        hub, *spokes = nodes</span>
<span class="gi">+        G.add_edges_from((hub, node) for node in spokes)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -657,7 +856,24 @@ def tadpole_graph(m, n, create_using=None):</span>
<span class="w"> </span>    `m` and/or `n` can be a container of nodes instead of an integer.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    m, m_nodes = m</span>
<span class="gi">+    M = len(m_nodes)</span>
<span class="gi">+    if M &lt; 2:</span>
<span class="gi">+        raise NetworkXError(&quot;Invalid description: m should indicate at least 2 nodes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    n, n_nodes = n</span>
<span class="gi">+    if isinstance(m, numbers.Integral) and isinstance(n, numbers.Integral):</span>
<span class="gi">+        n_nodes = list(range(M, M + n))</span>
<span class="gi">+</span>
<span class="gi">+    # the circle</span>
<span class="gi">+    G = cycle_graph(m_nodes, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # the stick</span>
<span class="gi">+    nx.add_path(G, [m_nodes[-1]] + list(n_nodes))</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -669,20 +885,21 @@ def trivial_graph(create_using=None):</span>
<span class="w"> </span>        &gt;&gt;&gt; nx.draw(nx.trivial_graph(), with_labels=True)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(1, create_using)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def turan_graph(n, r):
<span class="gd">-    &quot;&quot;&quot;Return the Turan Graph</span>
<span class="gi">+    r&quot;&quot;&quot;Return the Turan Graph</span>

<span class="w"> </span>    The Turan Graph is a complete multipartite graph on $n$ nodes
<span class="w"> </span>    with $r$ disjoint subsets. That is, edges connect each node to
<span class="w"> </span>    every node not in its subset.

<span class="w"> </span>    Given $n$ and $r$, we create a complete multipartite graph with
<span class="gd">-    $r-(n \\mod r)$ partitions of size $n/r$, rounded down, and</span>
<span class="gd">-    $n \\mod r$ partitions of size $n/r+1$, rounded down.</span>
<span class="gi">+    $r-(n \mod r)$ partitions of size $n/r$, rounded down, and</span>
<span class="gi">+    $n \mod r$ partitions of size $n/r+1$, rounded down.</span>

<span class="w"> </span>    .. plot::

<span class="gu">@@ -701,7 +918,13 @@ def turan_graph(n, r):</span>
<span class="w"> </span>    Must satisfy $1 &lt;= r &lt;= n$.
<span class="w"> </span>    The graph has $(r-1)(n^2)/(2r)$ edges, rounded down.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if not 1 &lt;= r &lt;= n:</span>
<span class="gi">+        raise NetworkXError(&quot;Must satisfy 1 &lt;= r &lt;= n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    partitions = [n // r] * (r - (n % r)) + [n // r + 1] * (n % r)</span>
<span class="gi">+    G = complete_multipartite_graph(*partitions)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -727,7 +950,17 @@ def wheel_graph(n, create_using=None):</span>

<span class="w"> </span>    Node labels are the integers 0 to n - 1.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    _, nodes = n</span>
<span class="gi">+    G = empty_graph(nodes, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if len(nodes) &gt; 1:</span>
<span class="gi">+        hub, *rim = nodes</span>
<span class="gi">+        G.add_edges_from((hub, node) for node in rim)</span>
<span class="gi">+        if len(rim) &gt; 1:</span>
<span class="gi">+            G.add_edges_from(pairwise(rim, cyclic=True))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -790,4 +1023,32 @@ def complete_multipartite_graph(*subset_sizes):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    complete_bipartite_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The complete multipartite graph is an undirected simple graph.</span>
<span class="gi">+    G = Graph()</span>
<span class="gi">+</span>
<span class="gi">+    if len(subset_sizes) == 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    # set up subsets of nodes</span>
<span class="gi">+    try:</span>
<span class="gi">+        extents = pairwise(itertools.accumulate((0,) + subset_sizes))</span>
<span class="gi">+        subsets = [range(start, end) for start, end in extents]</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        subsets = subset_sizes</span>
<span class="gi">+    else:</span>
<span class="gi">+        if any(size &lt; 0 for size in subset_sizes):</span>
<span class="gi">+            raise NetworkXError(f&quot;Negative number of nodes not valid: {subset_sizes}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # add nodes with subset attribute</span>
<span class="gi">+    # while checking that ints are not mixed with iterables</span>
<span class="gi">+    try:</span>
<span class="gi">+        for i, subset in enumerate(subsets):</span>
<span class="gi">+            G.add_nodes_from(subset, subset=i)</span>
<span class="gi">+    except TypeError as err:</span>
<span class="gi">+        raise NetworkXError(&quot;Arguments must be all ints or all iterables&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    # Across subsets, all nodes should be adjacent.</span>
<span class="gi">+    # We can use itertools.combinations() because undirected.</span>
<span class="gi">+    for subset1, subset2 in itertools.combinations(subsets, 2):</span>
<span class="gi">+        G.add_edges_from(itertools.product(subset1, subset2))</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/cographs.py b/networkx/generators/cographs.py</span>
<span class="gh">index 89ce0f377..388a42ac5 100644</span>
<span class="gd">--- a/networkx/generators/cographs.py</span>
<span class="gi">+++ b/networkx/generators/cographs.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;Generators for cographs</span>
<span class="gi">+r&quot;&quot;&quot;Generators for cographs</span>

<span class="w"> </span>A cograph is a graph containing no path on four vertices.
<span class="w"> </span>Cographs or $P_4$-free graphs can be obtained from a single vertex
<span class="gu">@@ -13,13 +13,14 @@ References</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;random_cograph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;random_cograph&quot;]</span>


<span class="w"> </span>@py_random_state(1)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_cograph(n, seed=None):
<span class="gd">-    &quot;&quot;&quot;Returns a random cograph with $2 ^ n$ nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a random cograph with $2 ^ n$ nodes.</span>

<span class="w"> </span>    A cograph is a graph containing no path on four vertices.
<span class="w"> </span>    Cographs or $P_4$-free graphs can be obtained from a single vertex
<span class="gu">@@ -53,4 +54,14 @@ def random_cograph(n, seed=None):</span>
<span class="w"> </span>       Discrete Applied Mathematics, Volume 3, Issue 3, 1981, Pages 163-174,
<span class="w"> </span>       ISSN 0166-218X.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    R = nx.empty_graph(1)</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(n):</span>
<span class="gi">+        RR = nx.relabel_nodes(R.copy(), lambda x: x + len(R))</span>
<span class="gi">+</span>
<span class="gi">+        if seed.randint(0, 1) == 0:</span>
<span class="gi">+            R = nx.full_join(R, RR)</span>
<span class="gi">+        else:</span>
<span class="gi">+            R = nx.disjoint_union(R, RR)</span>
<span class="gi">+</span>
<span class="gi">+    return R</span>
<span class="gh">diff --git a/networkx/generators/community.py b/networkx/generators/community.py</span>
<span class="gh">index f40ed2569..5076d7288 100644</span>
<span class="gd">--- a/networkx/generators/community.py</span>
<span class="gi">+++ b/networkx/generators/community.py</span>
<span class="gu">@@ -1,13 +1,22 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Generators for classes of graphs used in studying social networks.&quot;&quot;&quot;
<span class="w"> </span>import itertools
<span class="w"> </span>import math
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;caveman_graph&#39;, &#39;connected_caveman_graph&#39;,</span>
<span class="gd">-    &#39;relaxed_caveman_graph&#39;, &#39;random_partition_graph&#39;,</span>
<span class="gd">-    &#39;planted_partition_graph&#39;, &#39;gaussian_random_partition_graph&#39;,</span>
<span class="gd">-    &#39;ring_of_cliques&#39;, &#39;windmill_graph&#39;, &#39;stochastic_block_model&#39;,</span>
<span class="gd">-    &#39;LFR_benchmark_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;caveman_graph&quot;,</span>
<span class="gi">+    &quot;connected_caveman_graph&quot;,</span>
<span class="gi">+    &quot;relaxed_caveman_graph&quot;,</span>
<span class="gi">+    &quot;random_partition_graph&quot;,</span>
<span class="gi">+    &quot;planted_partition_graph&quot;,</span>
<span class="gi">+    &quot;gaussian_random_partition_graph&quot;,</span>
<span class="gi">+    &quot;ring_of_cliques&quot;,</span>
<span class="gi">+    &quot;windmill_graph&quot;,</span>
<span class="gi">+    &quot;stochastic_block_model&quot;,</span>
<span class="gi">+    &quot;LFR_benchmark_graph&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -48,7 +57,13 @@ def caveman_graph(l, k):</span>
<span class="w"> </span>    .. [1] Watts, D. J. &#39;Networks, Dynamics, and the Small-World Phenomenon.&#39;
<span class="w"> </span>       Amer. J. Soc. 105, 493-527, 1999.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # l disjoint cliques of size k</span>
<span class="gi">+    G = nx.empty_graph(l * k)</span>
<span class="gi">+    if k &gt; 1:</span>
<span class="gi">+        for start in range(0, l * k, k):</span>
<span class="gi">+            edges = itertools.combinations(range(start, start + k), 2)</span>
<span class="gi">+            G.add_edges_from(edges)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -93,7 +108,16 @@ def connected_caveman_graph(l, k):</span>
<span class="w"> </span>    .. [1] Watts, D. J. &#39;Networks, Dynamics, and the Small-World Phenomenon.&#39;
<span class="w"> </span>       Amer. J. Soc. 105, 493-527, 1999.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if k &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;The size of cliques in a connected caveman graph must be at least 2.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.caveman_graph(l, k)</span>
<span class="gi">+    for start in range(0, l * k, k):</span>
<span class="gi">+        G.remove_edge(start, start + 1)</span>
<span class="gi">+        G.add_edge(start, (start - 1) % (l * k))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -136,7 +160,16 @@ def relaxed_caveman_graph(l, k, p, seed=None):</span>
<span class="w"> </span>       Physics Reports Volume 486, Issues 3-5, February 2010, Pages 75-174.
<span class="w"> </span>       https://arxiv.org/abs/0906.0612
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.caveman_graph(l, k)</span>
<span class="gi">+    nodes = list(G)</span>
<span class="gi">+    for u, v in G.edges():</span>
<span class="gi">+        if seed.random() &lt; p:  # rewire the edge</span>
<span class="gi">+            x = seed.choice(nodes)</span>
<span class="gi">+            if G.has_edge(u, x):</span>
<span class="gi">+                continue</span>
<span class="gi">+            G.remove_edge(u, v)</span>
<span class="gi">+            G.add_edge(u, x)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -194,7 +227,28 @@ def random_partition_graph(sizes, p_in, p_out, seed=None, directed=False):</span>
<span class="w"> </span>    .. [1] Santo Fortunato &#39;Community Detection in Graphs&#39; Physical Reports
<span class="w"> </span>       Volume 486, Issue 3-5 p. 75-174. https://arxiv.org/abs/0906.0612
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Use geometric method for O(n+m) complexity algorithm</span>
<span class="gi">+    # partition = nx.community_sets(nx.get_node_attributes(G, &#39;affiliation&#39;))</span>
<span class="gi">+    if not 0.0 &lt;= p_in &lt;= 1.0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;p_in must be in [0,1]&quot;)</span>
<span class="gi">+    if not 0.0 &lt;= p_out &lt;= 1.0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;p_out must be in [0,1]&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # create connection matrix</span>
<span class="gi">+    num_blocks = len(sizes)</span>
<span class="gi">+    p = [[p_out for s in range(num_blocks)] for r in range(num_blocks)]</span>
<span class="gi">+    for r in range(num_blocks):</span>
<span class="gi">+        p[r][r] = p_in</span>
<span class="gi">+</span>
<span class="gi">+    return stochastic_block_model(</span>
<span class="gi">+        sizes,</span>
<span class="gi">+        p,</span>
<span class="gi">+        nodelist=None,</span>
<span class="gi">+        seed=seed,</span>
<span class="gi">+        directed=directed,</span>
<span class="gi">+        selfloops=False,</span>
<span class="gi">+        sparse=True,</span>
<span class="gi">+    )</span>


<span class="w"> </span>@py_random_state(4)
<span class="gu">@@ -250,13 +304,12 @@ def planted_partition_graph(l, k, p_in, p_out, seed=None, directed=False):</span>
<span class="w"> </span>    .. [2] Santo Fortunato &#39;Community Detection in Graphs&#39; Physical Reports
<span class="w"> </span>       Volume 486, Issue 3-5 p. 75-174. https://arxiv.org/abs/0906.0612
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return random_partition_graph([k] * l, p_in, p_out, seed=seed, directed=directed)</span>


<span class="w"> </span>@py_random_state(6)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def gaussian_random_partition_graph(n, s, v, p_in, p_out, directed=False,</span>
<span class="gd">-    seed=None):</span>
<span class="gi">+def gaussian_random_partition_graph(n, s, v, p_in, p_out, directed=False, seed=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a Gaussian random partition graph.

<span class="w"> </span>    A Gaussian random partition graph is created by creating k partitions
<span class="gu">@@ -315,7 +368,20 @@ def gaussian_random_partition_graph(n, s, v, p_in, p_out, directed=False,</span>
<span class="w"> </span>       Experiments on Graph Clustering Algorithms,
<span class="w"> </span>       In the proceedings of the 11th Europ. Symp. Algorithms, 2003.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if s &gt; n:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;s must be &lt;= n&quot;)</span>
<span class="gi">+    assigned = 0</span>
<span class="gi">+    sizes = []</span>
<span class="gi">+    while True:</span>
<span class="gi">+        size = int(seed.gauss(s, s / v + 0.5))</span>
<span class="gi">+        if size &lt; 1:  # how to handle 0 or negative sizes?</span>
<span class="gi">+            continue</span>
<span class="gi">+        if assigned + size &gt;= n:</span>
<span class="gi">+            sizes.append(n - assigned)</span>
<span class="gi">+            break</span>
<span class="gi">+        assigned += size</span>
<span class="gi">+        sizes.append(size)</span>
<span class="gi">+    return random_partition_graph(sizes, p_in, p_out, seed=seed, directed=directed)</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -357,7 +423,21 @@ def ring_of_cliques(num_cliques, clique_size):</span>
<span class="w"> </span>    connect it with the next clique. Instead, the `ring_of_cliques` graph
<span class="w"> </span>    simply adds the link without removing any link from the cliques.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if num_cliques &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;A ring of cliques must have at least two cliques&quot;)</span>
<span class="gi">+    if clique_size &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;The cliques must have at least two nodes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    for i in range(num_cliques):</span>
<span class="gi">+        edges = itertools.combinations(</span>
<span class="gi">+            range(i * clique_size, i * clique_size + clique_size), 2</span>
<span class="gi">+        )</span>
<span class="gi">+        G.add_edges_from(edges)</span>
<span class="gi">+        G.add_edge(</span>
<span class="gi">+            i * clique_size + 1, (i + 1) * clique_size % (num_cliques * clique_size)</span>
<span class="gi">+        )</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -398,13 +478,26 @@ def windmill_graph(n, k):</span>
<span class="w"> </span>    Note that windmill graphs are usually denoted `Wd(k,n)`, so the parameters
<span class="w"> </span>    are in the opposite order as the parameters of this method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt; 2:</span>
<span class="gi">+        msg = &quot;A windmill graph must have at least two cliques&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    if k &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;The cliques must have at least two nodes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.disjoint_union_all(</span>
<span class="gi">+        itertools.chain(</span>
<span class="gi">+            [nx.complete_graph(k)], (nx.complete_graph(k - 1) for _ in range(n - 1))</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    G.add_edges_from((0, i) for i in range(k, G.number_of_nodes()))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def stochastic_block_model(sizes, p, nodelist=None, seed=None, directed=</span>
<span class="gd">-    False, selfloops=False, sparse=True):</span>
<span class="gi">+def stochastic_block_model(</span>
<span class="gi">+    sizes, p, nodelist=None, seed=None, directed=False, selfloops=False, sparse=True</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a stochastic block model graph.

<span class="w"> </span>    This model partitions the nodes in blocks of arbitrary sizes, and places
<span class="gu">@@ -480,7 +573,92 @@ def stochastic_block_model(sizes, p, nodelist=None, seed=None, directed=</span>
<span class="w"> </span>           &quot;Stochastic blockmodels: First steps&quot;,
<span class="w"> </span>           Social networks, 5(2), 109-137, 1983.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check if dimensions match</span>
<span class="gi">+    if len(sizes) != len(p):</span>
<span class="gi">+        raise nx.NetworkXException(&quot;&#39;sizes&#39; and &#39;p&#39; do not match.&quot;)</span>
<span class="gi">+    # Check for probability symmetry (undirected) and shape (directed)</span>
<span class="gi">+    for row in p:</span>
<span class="gi">+        if len(p) != len(row):</span>
<span class="gi">+            raise nx.NetworkXException(&quot;&#39;p&#39; must be a square matrix.&quot;)</span>
<span class="gi">+    if not directed:</span>
<span class="gi">+        p_transpose = [list(i) for i in zip(*p)]</span>
<span class="gi">+        for i in zip(p, p_transpose):</span>
<span class="gi">+            for j in zip(i[0], i[1]):</span>
<span class="gi">+                if abs(j[0] - j[1]) &gt; 1e-08:</span>
<span class="gi">+                    raise nx.NetworkXException(&quot;&#39;p&#39; must be symmetric.&quot;)</span>
<span class="gi">+    # Check for probability range</span>
<span class="gi">+    for row in p:</span>
<span class="gi">+        for prob in row:</span>
<span class="gi">+            if prob &lt; 0 or prob &gt; 1:</span>
<span class="gi">+                raise nx.NetworkXException(&quot;Entries of &#39;p&#39; not in [0,1].&quot;)</span>
<span class="gi">+    # Check for nodelist consistency</span>
<span class="gi">+    if nodelist is not None:</span>
<span class="gi">+        if len(nodelist) != sum(sizes):</span>
<span class="gi">+            raise nx.NetworkXException(&quot;&#39;nodelist&#39; and &#39;sizes&#39; do not match.&quot;)</span>
<span class="gi">+        if len(nodelist) != len(set(nodelist)):</span>
<span class="gi">+            raise nx.NetworkXException(&quot;nodelist contains duplicate.&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        nodelist = range(sum(sizes))</span>
<span class="gi">+</span>
<span class="gi">+    # Setup the graph conditionally to the directed switch.</span>
<span class="gi">+    block_range = range(len(sizes))</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        g = nx.DiGraph()</span>
<span class="gi">+        block_iter = itertools.product(block_range, block_range)</span>
<span class="gi">+    else:</span>
<span class="gi">+        g = nx.Graph()</span>
<span class="gi">+        block_iter = itertools.combinations_with_replacement(block_range, 2)</span>
<span class="gi">+    # Split nodelist in a partition (list of sets).</span>
<span class="gi">+    size_cumsum = [sum(sizes[0:x]) for x in range(len(sizes) + 1)]</span>
<span class="gi">+    g.graph[&quot;partition&quot;] = [</span>
<span class="gi">+        set(nodelist[size_cumsum[x] : size_cumsum[x + 1]])</span>
<span class="gi">+        for x in range(len(size_cumsum) - 1)</span>
<span class="gi">+    ]</span>
<span class="gi">+    # Setup nodes and graph name</span>
<span class="gi">+    for block_id, nodes in enumerate(g.graph[&quot;partition&quot;]):</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            g.add_node(node, block=block_id)</span>
<span class="gi">+</span>
<span class="gi">+    g.name = &quot;stochastic_block_model&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Test for edge existence</span>
<span class="gi">+    parts = g.graph[&quot;partition&quot;]</span>
<span class="gi">+    for i, j in block_iter:</span>
<span class="gi">+        if i == j:</span>
<span class="gi">+            if directed:</span>
<span class="gi">+                if selfloops:</span>
<span class="gi">+                    edges = itertools.product(parts[i], parts[i])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    edges = itertools.permutations(parts[i], 2)</span>
<span class="gi">+            else:</span>
<span class="gi">+                edges = itertools.combinations(parts[i], 2)</span>
<span class="gi">+                if selfloops:</span>
<span class="gi">+                    edges = itertools.chain(edges, zip(parts[i], parts[i]))</span>
<span class="gi">+            for e in edges:</span>
<span class="gi">+                if seed.random() &lt; p[i][j]:</span>
<span class="gi">+                    g.add_edge(*e)</span>
<span class="gi">+        else:</span>
<span class="gi">+            edges = itertools.product(parts[i], parts[j])</span>
<span class="gi">+        if sparse:</span>
<span class="gi">+            if p[i][j] == 1:  # Test edges cases p_ij = 0 or 1</span>
<span class="gi">+                for e in edges:</span>
<span class="gi">+                    g.add_edge(*e)</span>
<span class="gi">+            elif p[i][j] &gt; 0:</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        logrand = math.log(seed.random())</span>
<span class="gi">+                        skip = math.floor(logrand / math.log(1 - p[i][j]))</span>
<span class="gi">+                        # consume &quot;skip&quot; edges</span>
<span class="gi">+                        next(itertools.islice(edges, skip, skip), None)</span>
<span class="gi">+                        e = next(edges)</span>
<span class="gi">+                        g.add_edge(*e)  # __safe</span>
<span class="gi">+                    except StopIteration:</span>
<span class="gi">+                        break</span>
<span class="gi">+        else:</span>
<span class="gi">+            for e in edges:</span>
<span class="gi">+                if seed.random() &lt; p[i][j]:</span>
<span class="gi">+                    g.add_edge(*e)  # __safe</span>
<span class="gi">+    return g</span>


<span class="w"> </span>def _zipf_rv_below(gamma, xmin, threshold, seed):
<span class="gu">@@ -489,7 +667,10 @@ def _zipf_rv_below(gamma, xmin, threshold, seed):</span>
<span class="w"> </span>    Repeatedly draws values from the Zipf distribution until the
<span class="w"> </span>    threshold is met, then returns that value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = nx.utils.zipf_rv(gamma, xmin, seed)</span>
<span class="gi">+    while result &gt; threshold:</span>
<span class="gi">+        result = nx.utils.zipf_rv(gamma, xmin, seed)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def _powerlaw_sequence(gamma, low, high, condition, length, max_iters, seed):
<span class="gu">@@ -514,7 +695,13 @@ def _powerlaw_sequence(gamma, low, high, condition, length, max_iters, seed):</span>
<span class="w"> </span>        Indicator of random number generation state.
<span class="w"> </span>        See :ref:`Randomness&lt;randomness&gt;`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for i in range(max_iters):</span>
<span class="gi">+        seq = []</span>
<span class="gi">+        while not length(seq):</span>
<span class="gi">+            seq.append(_zipf_rv_below(gamma, low, high, seed))</span>
<span class="gi">+        if condition(seq):</span>
<span class="gi">+            return seq</span>
<span class="gi">+    raise nx.ExceededMaxIterations(&quot;Could not create power law sequence&quot;)</span>


<span class="w"> </span>def _hurwitz_zeta(x, q, tolerance):
<span class="gu">@@ -525,13 +712,46 @@ def _hurwitz_zeta(x, q, tolerance):</span>
<span class="w"> </span>    This function repeatedly computes subsequent partial sums until
<span class="w"> </span>    convergence, as decided by ``tolerance``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    z = 0</span>
<span class="gi">+    z_prev = -float(&quot;inf&quot;)</span>
<span class="gi">+    k = 0</span>
<span class="gi">+    while abs(z - z_prev) &gt; tolerance:</span>
<span class="gi">+        z_prev = z</span>
<span class="gi">+        z += 1 / ((k + q) ** x)</span>
<span class="gi">+        k += 1</span>
<span class="gi">+    return z</span>


<span class="gd">-def _generate_min_degree(gamma, average_degree, max_degree, tolerance,</span>
<span class="gd">-    max_iters):</span>
<span class="gi">+def _generate_min_degree(gamma, average_degree, max_degree, tolerance, max_iters):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a minimum degree from the given average degree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Defines zeta function whether or not Scipy is available</span>
<span class="gi">+    try:</span>
<span class="gi">+        from scipy.special import zeta</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+</span>
<span class="gi">+        def zeta(x, q):</span>
<span class="gi">+            return _hurwitz_zeta(x, q, tolerance)</span>
<span class="gi">+</span>
<span class="gi">+    min_deg_top = max_degree</span>
<span class="gi">+    min_deg_bot = 1</span>
<span class="gi">+    min_deg_mid = (min_deg_top - min_deg_bot) / 2 + min_deg_bot</span>
<span class="gi">+    itrs = 0</span>
<span class="gi">+    mid_avg_deg = 0</span>
<span class="gi">+    while abs(mid_avg_deg - average_degree) &gt; tolerance:</span>
<span class="gi">+        if itrs &gt; max_iters:</span>
<span class="gi">+            raise nx.ExceededMaxIterations(&quot;Could not match average_degree&quot;)</span>
<span class="gi">+        mid_avg_deg = 0</span>
<span class="gi">+        for x in range(int(min_deg_mid), max_degree + 1):</span>
<span class="gi">+            mid_avg_deg += (x ** (-gamma + 1)) / zeta(gamma, min_deg_mid)</span>
<span class="gi">+        if mid_avg_deg &gt; average_degree:</span>
<span class="gi">+            min_deg_top = min_deg_mid</span>
<span class="gi">+            min_deg_mid = (min_deg_top - min_deg_bot) / 2 + min_deg_bot</span>
<span class="gi">+        else:</span>
<span class="gi">+            min_deg_bot = min_deg_mid</span>
<span class="gi">+            min_deg_mid = (min_deg_top - min_deg_bot) / 2 + min_deg_bot</span>
<span class="gi">+        itrs += 1</span>
<span class="gi">+    # return int(min_deg_mid + 0.5)</span>
<span class="gi">+    return round(min_deg_mid)</span>


<span class="w"> </span>def _generate_communities(degree_seq, community_sizes, mu, max_iters, seed):
<span class="gu">@@ -560,15 +780,48 @@ def _generate_communities(degree_seq, community_sizes, mu, max_iters, seed):</span>
<span class="w"> </span>    ..., *n* - 1}, where *n* is the length of ``degree_seq``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This assumes the nodes in the graph will be natural numbers.</span>
<span class="gi">+    result = [set() for _ in community_sizes]</span>
<span class="gi">+    n = len(degree_seq)</span>
<span class="gi">+    free = list(range(n))</span>
<span class="gi">+    for i in range(max_iters):</span>
<span class="gi">+        v = free.pop()</span>
<span class="gi">+        c = seed.choice(range(len(community_sizes)))</span>
<span class="gi">+        # s = int(degree_seq[v] * (1 - mu) + 0.5)</span>
<span class="gi">+        s = round(degree_seq[v] * (1 - mu))</span>
<span class="gi">+        # If the community is large enough, add the node to the chosen</span>
<span class="gi">+        # community. Otherwise, return it to the list of unaffiliated</span>
<span class="gi">+        # nodes.</span>
<span class="gi">+        if s &lt; community_sizes[c]:</span>
<span class="gi">+            result[c].add(v)</span>
<span class="gi">+        else:</span>
<span class="gi">+            free.append(v)</span>
<span class="gi">+        # If the community is too big, remove a node from it.</span>
<span class="gi">+        if len(result[c]) &gt; community_sizes[c]:</span>
<span class="gi">+            free.append(result[c].pop())</span>
<span class="gi">+        if not free:</span>
<span class="gi">+            return result</span>
<span class="gi">+    msg = &quot;Could not assign communities; try increasing min_community&quot;</span>
<span class="gi">+    raise nx.ExceededMaxIterations(msg)</span>


<span class="w"> </span>@py_random_state(11)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def LFR_benchmark_graph(n, tau1, tau2, mu, average_degree=None, min_degree=</span>
<span class="gd">-    None, max_degree=None, min_community=None, max_community=None, tol=</span>
<span class="gd">-    1e-07, max_iters=500, seed=None):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the LFR benchmark graph.</span>
<span class="gi">+def LFR_benchmark_graph(</span>
<span class="gi">+    n,</span>
<span class="gi">+    tau1,</span>
<span class="gi">+    tau2,</span>
<span class="gi">+    mu,</span>
<span class="gi">+    average_degree=None,</span>
<span class="gi">+    min_degree=None,</span>
<span class="gi">+    max_degree=None,</span>
<span class="gi">+    min_community=None,</span>
<span class="gi">+    max_community=None,</span>
<span class="gi">+    tol=1.0e-7,</span>
<span class="gi">+    max_iters=500,</span>
<span class="gi">+    seed=None,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the LFR benchmark graph.</span>

<span class="w"> </span>    This algorithm proceeds as follows:

<span class="gu">@@ -581,9 +834,9 @@ def LFR_benchmark_graph(n, tau1, tau2, mu, average_degree=None, min_degree=</span>
<span class="w"> </span>          case a suitable minimum degree will be found.

<span class="w"> </span>       ``max_degree`` can also be specified, otherwise it will be set to
<span class="gd">-       ``n``. Each node *u* will have $\\mu \\mathrm{deg}(u)$ edges</span>
<span class="gi">+       ``n``. Each node *u* will have $\mu \mathrm{deg}(u)$ edges</span>
<span class="w"> </span>       joining it to nodes in communities other than its own and $(1 -
<span class="gd">-       \\mu) \\mathrm{deg}(u)$ edges joining it to nodes in its own</span>
<span class="gi">+       \mu) \mathrm{deg}(u)$ edges joining it to nodes in its own</span>
<span class="w"> </span>       community.
<span class="w"> </span>    2) Generate community sizes according to a power law distribution
<span class="w"> </span>       with exponent ``tau2``. If ``min_community`` and
<span class="gu">@@ -592,12 +845,12 @@ def LFR_benchmark_graph(n, tau1, tau2, mu, average_degree=None, min_degree=</span>
<span class="w"> </span>       are generated until the sum of their sizes equals ``n``.
<span class="w"> </span>    3) Each node will be randomly assigned a community with the
<span class="w"> </span>       condition that the community is large enough for the node&#39;s
<span class="gd">-       intra-community degree, $(1 - \\mu) \\mathrm{deg}(u)$ as</span>
<span class="gi">+       intra-community degree, $(1 - \mu) \mathrm{deg}(u)$ as</span>
<span class="w"> </span>       described in step 2. If a community grows too large, a random node
<span class="w"> </span>       will be selected for reassignment to a new community, until all
<span class="w"> </span>       nodes have been assigned a community.
<span class="gd">-    4) Each node *u* then adds $(1 - \\mu) \\mathrm{deg}(u)$</span>
<span class="gd">-       intra-community edges and $\\mu \\mathrm{deg}(u)$ inter-community</span>
<span class="gi">+    4) Each node *u* then adds $(1 - \mu) \mathrm{deg}(u)$</span>
<span class="gi">+       intra-community edges and $\mu \mathrm{deg}(u)$ inter-community</span>
<span class="w"> </span>       edges.

<span class="w"> </span>    Parameters
<span class="gu">@@ -736,4 +989,81 @@ def LFR_benchmark_graph(n, tau1, tau2, mu, average_degree=None, min_degree=</span>
<span class="w"> </span>    .. [2] https://www.santofortunato.net/resources

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Perform some basic parameter validation.</span>
<span class="gi">+    if not tau1 &gt; 1:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;tau1 must be greater than one&quot;)</span>
<span class="gi">+    if not tau2 &gt; 1:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;tau2 must be greater than one&quot;)</span>
<span class="gi">+    if not 0 &lt;= mu &lt;= 1:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;mu must be in the interval [0, 1]&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Validate parameters for generating the degree sequence.</span>
<span class="gi">+    if max_degree is None:</span>
<span class="gi">+        max_degree = n</span>
<span class="gi">+    elif not 0 &lt; max_degree &lt;= n:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;max_degree must be in the interval (0, n]&quot;)</span>
<span class="gi">+    if not ((min_degree is None) ^ (average_degree is None)):</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;Must assign exactly one of min_degree and average_degree&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if min_degree is None:</span>
<span class="gi">+        min_degree = _generate_min_degree(</span>
<span class="gi">+            tau1, average_degree, max_degree, tol, max_iters</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Generate a degree sequence with a power law distribution.</span>
<span class="gi">+    low, high = min_degree, max_degree</span>
<span class="gi">+</span>
<span class="gi">+    def condition(seq):</span>
<span class="gi">+        return sum(seq) % 2 == 0</span>
<span class="gi">+</span>
<span class="gi">+    def length(seq):</span>
<span class="gi">+        return len(seq) &gt;= n</span>
<span class="gi">+</span>
<span class="gi">+    deg_seq = _powerlaw_sequence(tau1, low, high, condition, length, max_iters, seed)</span>
<span class="gi">+</span>
<span class="gi">+    # Validate parameters for generating the community size sequence.</span>
<span class="gi">+    if min_community is None:</span>
<span class="gi">+        min_community = min(deg_seq)</span>
<span class="gi">+    if max_community is None:</span>
<span class="gi">+        max_community = max(deg_seq)</span>
<span class="gi">+</span>
<span class="gi">+    # Generate a community size sequence with a power law distribution.</span>
<span class="gi">+    #</span>
<span class="gi">+    # TODO The original code incremented the number of iterations each</span>
<span class="gi">+    # time a new Zipf random value was drawn from the distribution. This</span>
<span class="gi">+    # differed from the way the number of iterations was incremented in</span>
<span class="gi">+    # `_powerlaw_degree_sequence`, so this code was changed to match</span>
<span class="gi">+    # that one. As a result, this code is allowed many more chances to</span>
<span class="gi">+    # generate a valid community size sequence.</span>
<span class="gi">+    low, high = min_community, max_community</span>
<span class="gi">+</span>
<span class="gi">+    def condition(seq):</span>
<span class="gi">+        return sum(seq) == n</span>
<span class="gi">+</span>
<span class="gi">+    def length(seq):</span>
<span class="gi">+        return sum(seq) &gt;= n</span>
<span class="gi">+</span>
<span class="gi">+    comms = _powerlaw_sequence(tau2, low, high, condition, length, max_iters, seed)</span>
<span class="gi">+</span>
<span class="gi">+    # Generate the communities based on the given degree sequence and</span>
<span class="gi">+    # community sizes.</span>
<span class="gi">+    max_iters *= 10 * n</span>
<span class="gi">+    communities = _generate_communities(deg_seq, comms, mu, max_iters, seed)</span>
<span class="gi">+</span>
<span class="gi">+    # Finally, generate the benchmark graph based on the given</span>
<span class="gi">+    # communities, joining nodes according to the intra- and</span>
<span class="gi">+    # inter-community degrees.</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    G.add_nodes_from(range(n))</span>
<span class="gi">+    for c in communities:</span>
<span class="gi">+        for u in c:</span>
<span class="gi">+            while G.degree(u) &lt; round(deg_seq[u] * (1 - mu)):</span>
<span class="gi">+                v = seed.choice(list(c))</span>
<span class="gi">+                G.add_edge(u, v)</span>
<span class="gi">+            while G.degree(u) &lt; deg_seq[u]:</span>
<span class="gi">+                v = seed.choice(range(n))</span>
<span class="gi">+                if v not in c:</span>
<span class="gi">+                    G.add_edge(u, v)</span>
<span class="gi">+            G.nodes[u][&quot;community&quot;] = c</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/degree_seq.py b/networkx/generators/degree_seq.py</span>
<span class="gh">index eefee8b01..6bc85e2be 100644</span>
<span class="gd">--- a/networkx/generators/degree_seq.py</span>
<span class="gi">+++ b/networkx/generators/degree_seq.py</span>
<span class="gu">@@ -1,15 +1,24 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Generate graphs with a given degree sequence or expected degree sequence.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import heapq
<span class="w"> </span>import math
<span class="w"> </span>from itertools import chain, combinations, zip_longest
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state, random_weighted_sample
<span class="gd">-__all__ = [&#39;configuration_model&#39;, &#39;directed_configuration_model&#39;,</span>
<span class="gd">-    &#39;expected_degree_graph&#39;, &#39;havel_hakimi_graph&#39;,</span>
<span class="gd">-    &#39;directed_havel_hakimi_graph&#39;, &#39;degree_sequence_tree&#39;,</span>
<span class="gd">-    &#39;random_degree_sequence_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;configuration_model&quot;,</span>
<span class="gi">+    &quot;directed_configuration_model&quot;,</span>
<span class="gi">+    &quot;expected_degree_graph&quot;,</span>
<span class="gi">+    &quot;havel_hakimi_graph&quot;,</span>
<span class="gi">+    &quot;directed_havel_hakimi_graph&quot;,</span>
<span class="gi">+    &quot;degree_sequence_tree&quot;,</span>
<span class="gi">+    &quot;random_degree_sequence_graph&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>chaini = chain.from_iterable


<span class="gu">@@ -42,11 +51,12 @@ def _to_stublist(degree_sequence):</span>
<span class="w"> </span>    [0, 0, 2]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return list(chaini([n] * d for n, d in enumerate(degree_sequence)))</span>


<span class="gd">-def _configuration_model(deg_sequence, create_using, directed=False,</span>
<span class="gd">-    in_deg_sequence=None, seed=None):</span>
<span class="gi">+def _configuration_model(</span>
<span class="gi">+    deg_sequence, create_using, directed=False, in_deg_sequence=None, seed=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Helper function for generating either undirected or directed
<span class="w"> </span>    configuration model graphs.

<span class="gu">@@ -78,7 +88,39 @@ def _configuration_model(deg_sequence, create_using, directed=False,</span>
<span class="w"> </span>    functions.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(deg_sequence)</span>
<span class="gi">+    G = nx.empty_graph(n, create_using)</span>
<span class="gi">+    # If empty, return the null graph immediately.</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+    # Build a list of available degree-repeated nodes.  For example,</span>
<span class="gi">+    # for degree sequence [3, 2, 1, 1, 1], the &quot;stub list&quot; is</span>
<span class="gi">+    # initially [0, 0, 0, 1, 1, 2, 3, 4], that is, node 0 has degree</span>
<span class="gi">+    # 3 and thus is repeated 3 times, etc.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Also, shuffle the stub list in order to get a random sequence of</span>
<span class="gi">+    # node pairs.</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        pairs = zip_longest(deg_sequence, in_deg_sequence, fillvalue=0)</span>
<span class="gi">+        # Unzip the list of pairs into a pair of lists.</span>
<span class="gi">+        out_deg, in_deg = zip(*pairs)</span>
<span class="gi">+</span>
<span class="gi">+        out_stublist = _to_stublist(out_deg)</span>
<span class="gi">+        in_stublist = _to_stublist(in_deg)</span>
<span class="gi">+</span>
<span class="gi">+        seed.shuffle(out_stublist)</span>
<span class="gi">+        seed.shuffle(in_stublist)</span>
<span class="gi">+    else:</span>
<span class="gi">+        stublist = _to_stublist(deg_sequence)</span>
<span class="gi">+        # Choose a random balanced bipartition of the stublist, which</span>
<span class="gi">+        # gives a random pairing of nodes. In this implementation, we</span>
<span class="gi">+        # shuffle the list and then split it in half.</span>
<span class="gi">+        n = len(stublist)</span>
<span class="gi">+        half = n // 2</span>
<span class="gi">+        seed.shuffle(stublist)</span>
<span class="gi">+        out_stublist, in_stublist = stublist[:half], stublist[half:]</span>
<span class="gi">+    G.add_edges_from(zip(out_stublist, in_stublist))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -171,13 +213,24 @@ def configuration_model(deg_sequence, create_using=None, seed=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; G.remove_edges_from(nx.selfloop_edges(G))

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sum(deg_sequence) % 2 != 0:</span>
<span class="gi">+        msg = &quot;Invalid degree sequence: sum of degrees must be even, not odd&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXNotImplemented(&quot;not implemented for directed graphs&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G = _configuration_model(deg_sequence, G, seed=seed)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def directed_configuration_model(in_degree_sequence, out_degree_sequence,</span>
<span class="gd">-    create_using=None, seed=None):</span>
<span class="gi">+def directed_configuration_model(</span>
<span class="gi">+    in_degree_sequence, out_degree_sequence, create_using=None, seed=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a directed_random graph with the given degree sequences.

<span class="w"> </span>    The configuration model generates a random directed pseudograph
<span class="gu">@@ -257,21 +310,37 @@ def directed_configuration_model(in_degree_sequence, out_degree_sequence,</span>
<span class="w"> </span>    &gt;&gt;&gt; D.remove_edges_from(nx.selfloop_edges(D))

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sum(in_degree_sequence) != sum(out_degree_sequence):</span>
<span class="gi">+        msg = &quot;Invalid degree sequences: sequences must have equal sums&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    if create_using is None:</span>
<span class="gi">+        create_using = nx.MultiDiGraph</span>
<span class="gi">+</span>
<span class="gi">+    G = _configuration_model(</span>
<span class="gi">+        out_degree_sequence,</span>
<span class="gi">+        create_using,</span>
<span class="gi">+        directed=True,</span>
<span class="gi">+        in_deg_sequence=in_degree_sequence,</span>
<span class="gi">+        seed=seed,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;directed configuration_model {} nodes {} edges&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(1)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def expected_degree_graph(w, seed=None, selfloops=True):
<span class="gd">-    &quot;&quot;&quot;Returns a random graph with given expected degrees.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a random graph with given expected degrees.</span>

<span class="gd">-    Given a sequence of expected degrees $W=(w_0,w_1,\\ldots,w_{n-1})$</span>
<span class="gi">+    Given a sequence of expected degrees $W=(w_0,w_1,\ldots,w_{n-1})$</span>
<span class="w"> </span>    of length $n$ this algorithm assigns an edge between node $u$ and
<span class="w"> </span>    node $v$ with probability

<span class="w"> </span>    .. math::

<span class="gd">-       p_{uv} = \\frac{w_u w_v}{\\sum_k w_k} .</span>
<span class="gi">+       p_{uv} = \frac{w_u w_v}{\sum_k w_k} .</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -297,7 +366,7 @@ def expected_degree_graph(w, seed=None, selfloops=True):</span>
<span class="w"> </span>    The nodes have integer labels corresponding to index of expected degrees
<span class="w"> </span>    input sequence.

<span class="gd">-    The complexity of this algorithm is $\\mathcal{O}(n+m)$ where $n$ is the</span>
<span class="gi">+    The complexity of this algorithm is $\mathcal{O}(n+m)$ where $n$ is the</span>
<span class="w"> </span>    number of nodes and $m$ is the expected number of edges.

<span class="w"> </span>    The model in [1]_ includes the possibility of self-loop edges.
<span class="gu">@@ -311,8 +380,8 @@ def expected_degree_graph(w, seed=None, selfloops=True):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       E[deg(u)] = \\sum_{v \\ne u} p_{uv}</span>
<span class="gd">-                = w_u \\left( 1 - \\frac{w_u}{\\sum_k w_k} \\right) .</span>
<span class="gi">+       E[deg(u)] = \sum_{v \ne u} p_{uv}</span>
<span class="gi">+                = w_u \left( 1 - \frac{w_u}{\sum_k w_k} \right) .</span>


<span class="w"> </span>    NetworkX uses the standard convention that a self-loop edge counts 2
<span class="gu">@@ -320,8 +389,8 @@ def expected_degree_graph(w, seed=None, selfloops=True):</span>

<span class="w"> </span>    .. math::

<span class="gd">-       E[deg(u)] =  \\sum_{v \\ne u} p_{uv}  + 2 p_{uu}</span>
<span class="gd">-                = w_u \\left( 1 + \\frac{w_u}{\\sum_k w_k} \\right) .</span>
<span class="gi">+       E[deg(u)] =  \sum_{v \ne u} p_{uv}  + 2 p_{uu}</span>
<span class="gi">+                = w_u \left( 1 + \frac{w_u}{\sum_k w_k} \right) .</span>

<span class="w"> </span>    References
<span class="w"> </span>    ----------
<span class="gu">@@ -334,7 +403,40 @@ def expected_degree_graph(w, seed=None, selfloops=True):</span>
<span class="w"> </span>       Alan Frieze, Paul Horn, and Paweł Prałat (Eds), LNCS 6732,
<span class="w"> </span>       pp. 115-126, 2011.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(w)</span>
<span class="gi">+    G = nx.empty_graph(n)</span>
<span class="gi">+</span>
<span class="gi">+    # If there are no nodes are no edges in the graph, return the empty graph.</span>
<span class="gi">+    if n == 0 or max(w) == 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    rho = 1 / sum(w)</span>
<span class="gi">+    # Sort the weights in decreasing order. The original order of the</span>
<span class="gi">+    # weights dictates the order of the (integer) node labels, so we</span>
<span class="gi">+    # need to remember the permutation applied in the sorting.</span>
<span class="gi">+    order = sorted(enumerate(w), key=itemgetter(1), reverse=True)</span>
<span class="gi">+    mapping = {c: u for c, (u, v) in enumerate(order)}</span>
<span class="gi">+    seq = [v for u, v in order]</span>
<span class="gi">+    last = n</span>
<span class="gi">+    if not selfloops:</span>
<span class="gi">+        last -= 1</span>
<span class="gi">+    for u in range(last):</span>
<span class="gi">+        v = u</span>
<span class="gi">+        if not selfloops:</span>
<span class="gi">+            v += 1</span>
<span class="gi">+        factor = seq[u] * rho</span>
<span class="gi">+        p = min(seq[v] * factor, 1)</span>
<span class="gi">+        while v &lt; n and p &gt; 0:</span>
<span class="gi">+            if p != 1:</span>
<span class="gi">+                r = seed.random()</span>
<span class="gi">+                v += math.floor(math.log(r, 1 - p))</span>
<span class="gi">+            if v &lt; n:</span>
<span class="gi">+                q = min(seq[v] * factor, 1)</span>
<span class="gi">+                if seed.random() &lt; q / p:</span>
<span class="gi">+                    G.add_edge(mapping[u], mapping[v])</span>
<span class="gi">+                v += 1</span>
<span class="gi">+                p = q</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -377,12 +479,61 @@ def havel_hakimi_graph(deg_sequence, create_using=None):</span>
<span class="w"> </span>       Algorithms for Constructing Graphs and Digraphs with Given Valences
<span class="w"> </span>       and Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not nx.is_graphical(deg_sequence):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Invalid degree sequence&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    p = len(deg_sequence)</span>
<span class="gi">+    G = nx.empty_graph(p, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed graphs are not supported&quot;)</span>
<span class="gi">+    num_degs = [[] for i in range(p)]</span>
<span class="gi">+    dmax, dsum, n = 0, 0, 0</span>
<span class="gi">+    for d in deg_sequence:</span>
<span class="gi">+        # Process only the non-zero integers</span>
<span class="gi">+        if d &gt; 0:</span>
<span class="gi">+            num_degs[d].append(n)</span>
<span class="gi">+            dmax, dsum, n = max(dmax, d), dsum + d, n + 1</span>
<span class="gi">+    # Return graph if no edges</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    modstubs = [(0, 0)] * (dmax + 1)</span>
<span class="gi">+    # Successively reduce degree sequence by removing the maximum degree</span>
<span class="gi">+    while n &gt; 0:</span>
<span class="gi">+        # Retrieve the maximum degree in the sequence</span>
<span class="gi">+        while len(num_degs[dmax]) == 0:</span>
<span class="gi">+            dmax -= 1</span>
<span class="gi">+        # If there are not enough stubs to connect to, then the sequence is</span>
<span class="gi">+        # not graphical</span>
<span class="gi">+        if dmax &gt; n - 1:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Non-graphical integer sequence&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove largest stub in list</span>
<span class="gi">+        source = num_degs[dmax].pop()</span>
<span class="gi">+        n -= 1</span>
<span class="gi">+        # Reduce the next dmax largest stubs</span>
<span class="gi">+        mslen = 0</span>
<span class="gi">+        k = dmax</span>
<span class="gi">+        for i in range(dmax):</span>
<span class="gi">+            while len(num_degs[k]) == 0:</span>
<span class="gi">+                k -= 1</span>
<span class="gi">+            target = num_degs[k].pop()</span>
<span class="gi">+            G.add_edge(source, target)</span>
<span class="gi">+            n -= 1</span>
<span class="gi">+            if k &gt; 1:</span>
<span class="gi">+                modstubs[mslen] = (k - 1, target)</span>
<span class="gi">+                mslen += 1</span>
<span class="gi">+        # Add back to the list any nonzero stubs that were removed</span>
<span class="gi">+        for i in range(mslen):</span>
<span class="gi">+            (stubval, stubtarget) = modstubs[i]</span>
<span class="gi">+            num_degs[stubval].append(stubtarget)</span>
<span class="gi">+            n += 1</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence,</span>
<span class="gd">-    create_using=None):</span>
<span class="gi">+def directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence, create_using=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a directed graph with the given degree sequences.

<span class="w"> </span>    Parameters
<span class="gu">@@ -420,7 +571,77 @@ def directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence,</span>
<span class="w"> </span>       Algorithms for Constructing Graphs and Digraphs with Given Valences
<span class="w"> </span>       and Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    in_deg_sequence = nx.utils.make_list_of_ints(in_deg_sequence)</span>
<span class="gi">+    out_deg_sequence = nx.utils.make_list_of_ints(out_deg_sequence)</span>
<span class="gi">+</span>
<span class="gi">+    # Process the sequences and form two heaps to store degree pairs with</span>
<span class="gi">+    # either zero or nonzero out degrees</span>
<span class="gi">+    sumin, sumout = 0, 0</span>
<span class="gi">+    nin, nout = len(in_deg_sequence), len(out_deg_sequence)</span>
<span class="gi">+    maxn = max(nin, nout)</span>
<span class="gi">+    G = nx.empty_graph(maxn, create_using, default=nx.DiGraph)</span>
<span class="gi">+    if maxn == 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+    maxin = 0</span>
<span class="gi">+    stubheap, zeroheap = [], []</span>
<span class="gi">+    for n in range(maxn):</span>
<span class="gi">+        in_deg, out_deg = 0, 0</span>
<span class="gi">+        if n &lt; nout:</span>
<span class="gi">+            out_deg = out_deg_sequence[n]</span>
<span class="gi">+        if n &lt; nin:</span>
<span class="gi">+            in_deg = in_deg_sequence[n]</span>
<span class="gi">+        if in_deg &lt; 0 or out_deg &lt; 0:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;Invalid degree sequences. Sequence values must be positive.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        sumin, sumout, maxin = sumin + in_deg, sumout + out_deg, max(maxin, in_deg)</span>
<span class="gi">+        if in_deg &gt; 0:</span>
<span class="gi">+            stubheap.append((-1 * out_deg, -1 * in_deg, n))</span>
<span class="gi">+        elif out_deg &gt; 0:</span>
<span class="gi">+            zeroheap.append((-1 * out_deg, n))</span>
<span class="gi">+    if sumin != sumout:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;Invalid degree sequences. Sequences must have equal sums.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    heapq.heapify(stubheap)</span>
<span class="gi">+    heapq.heapify(zeroheap)</span>
<span class="gi">+</span>
<span class="gi">+    modstubs = [(0, 0, 0)] * (maxin + 1)</span>
<span class="gi">+    # Successively reduce degree sequence by removing the maximum</span>
<span class="gi">+    while stubheap:</span>
<span class="gi">+        # Remove first value in the sequence with a non-zero in degree</span>
<span class="gi">+        (freeout, freein, target) = heapq.heappop(stubheap)</span>
<span class="gi">+        freein *= -1</span>
<span class="gi">+        if freein &gt; len(stubheap) + len(zeroheap):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Non-digraphical integer sequence&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Attach arcs from the nodes with the most stubs</span>
<span class="gi">+        mslen = 0</span>
<span class="gi">+        for i in range(freein):</span>
<span class="gi">+            if zeroheap and (not stubheap or stubheap[0][0] &gt; zeroheap[0][0]):</span>
<span class="gi">+                (stubout, stubsource) = heapq.heappop(zeroheap)</span>
<span class="gi">+                stubin = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                (stubout, stubin, stubsource) = heapq.heappop(stubheap)</span>
<span class="gi">+            if stubout == 0:</span>
<span class="gi">+                raise nx.NetworkXError(&quot;Non-digraphical integer sequence&quot;)</span>
<span class="gi">+            G.add_edge(stubsource, target)</span>
<span class="gi">+            # Check if source is now totally connected</span>
<span class="gi">+            if stubout + 1 &lt; 0 or stubin &lt; 0:</span>
<span class="gi">+                modstubs[mslen] = (stubout + 1, stubin, stubsource)</span>
<span class="gi">+                mslen += 1</span>
<span class="gi">+</span>
<span class="gi">+        # Add the nodes back to the heaps that still have available stubs</span>
<span class="gi">+        for i in range(mslen):</span>
<span class="gi">+            stub = modstubs[i]</span>
<span class="gi">+            if stub[1] &lt; 0:</span>
<span class="gi">+                heapq.heappush(stubheap, stub)</span>
<span class="gi">+            else:</span>
<span class="gi">+                heapq.heappush(zeroheap, (stub[0], stub[2]))</span>
<span class="gi">+        if freeout &lt; 0:</span>
<span class="gi">+            heapq.heappush(zeroheap, (freeout, target))</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -431,13 +652,48 @@ def degree_sequence_tree(deg_sequence, create_using=None):</span>
<span class="w"> </span>    the degree sequence must have
<span class="w"> </span>    len(deg_sequence)-sum(deg_sequence)/2=1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The sum of the degree sequence must be even (for any undirected graph).</span>
<span class="gi">+    degree_sum = sum(deg_sequence)</span>
<span class="gi">+    if degree_sum % 2 != 0:</span>
<span class="gi">+        msg = &quot;Invalid degree sequence: sum of degrees must be even, not odd&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    if len(deg_sequence) - degree_sum // 2 != 1:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Invalid degree sequence: tree must have number of nodes equal&quot;</span>
<span class="gi">+            &quot; to one less than the number of edges&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Sort all degrees greater than 1 in decreasing order.</span>
<span class="gi">+    #</span>
<span class="gi">+    # TODO Does this need to be sorted in reverse order?</span>
<span class="gi">+    deg = sorted((s for s in deg_sequence if s &gt; 1), reverse=True)</span>
<span class="gi">+</span>
<span class="gi">+    # make path graph as backbone</span>
<span class="gi">+    n = len(deg) + 2</span>
<span class="gi">+    nx.add_path(G, range(n))</span>
<span class="gi">+    last = n</span>
<span class="gi">+</span>
<span class="gi">+    # add the leaves</span>
<span class="gi">+    for source in range(1, n - 1):</span>
<span class="gi">+        nedges = deg.pop() - 2</span>
<span class="gi">+        for target in range(last, last + nedges):</span>
<span class="gi">+            G.add_edge(source, target)</span>
<span class="gi">+        last += nedges</span>
<span class="gi">+</span>
<span class="gi">+    # in case we added one too many</span>
<span class="gi">+    if len(G) &gt; len(deg_sequence):</span>
<span class="gi">+        G.remove_node(0)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(1)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_degree_sequence_graph(sequence, seed=None, tries=10):
<span class="gd">-    &quot;&quot;&quot;Returns a simple random graph with the given degree sequence.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a simple random graph with the given degree sequence.</span>

<span class="w"> </span>    If the maximum degree $d_m$ in the sequence is $O(m^{1/4})$ then the
<span class="w"> </span>    algorithm produces almost uniform random graphs in $O(m d_m)$ time
<span class="gu">@@ -489,25 +745,124 @@ def random_degree_sequence_graph(sequence, seed=None, tries=10):</span>
<span class="w"> </span>    &gt;&gt;&gt; sorted(d for n, d in G.degree())
<span class="w"> </span>    [1, 2, 2, 3]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    DSRG = DegreeSequenceRandomGraph(sequence, seed)</span>
<span class="gi">+    for try_n in range(tries):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return DSRG.generate()</span>
<span class="gi">+        except nx.NetworkXUnfeasible:</span>
<span class="gi">+            pass</span>
<span class="gi">+    raise nx.NetworkXError(f&quot;failed to generate graph in {tries} tries&quot;)</span>


<span class="w"> </span>class DegreeSequenceRandomGraph:
<span class="gd">-</span>
<span class="gi">+    # class to generate random graphs with a given degree sequence</span>
<span class="gi">+    # use random_degree_sequence_graph()</span>
<span class="w"> </span>    def __init__(self, degree, rng):
<span class="w"> </span>        if not nx.is_graphical(degree):
<span class="gd">-            raise nx.NetworkXUnfeasible(&#39;degree sequence is not graphical&#39;)</span>
<span class="gi">+            raise nx.NetworkXUnfeasible(&quot;degree sequence is not graphical&quot;)</span>
<span class="w"> </span>        self.rng = rng
<span class="w"> </span>        self.degree = list(degree)
<span class="gd">-        self.m = sum(self.degree) / 2.0</span>
<span class="gi">+        # node labels are integers 0,...,n-1</span>
<span class="gi">+        self.m = sum(self.degree) / 2.0  # number of edges</span>
<span class="w"> </span>        try:
<span class="gd">-            self.dmax = max(self.degree)</span>
<span class="gi">+            self.dmax = max(self.degree)  # maximum degree</span>
<span class="w"> </span>        except ValueError:
<span class="w"> </span>            self.dmax = 0

<span class="gi">+    def generate(self):</span>
<span class="gi">+        # remaining_degree is mapping from int-&gt;remaining degree</span>
<span class="gi">+        self.remaining_degree = dict(enumerate(self.degree))</span>
<span class="gi">+        # add all nodes to make sure we get isolated nodes</span>
<span class="gi">+        self.graph = nx.Graph()</span>
<span class="gi">+        self.graph.add_nodes_from(self.remaining_degree)</span>
<span class="gi">+        # remove zero degree nodes</span>
<span class="gi">+        for n, d in list(self.remaining_degree.items()):</span>
<span class="gi">+            if d == 0:</span>
<span class="gi">+                del self.remaining_degree[n]</span>
<span class="gi">+        if len(self.remaining_degree) &gt; 0:</span>
<span class="gi">+            # build graph in three phases according to how many unmatched edges</span>
<span class="gi">+            self.phase1()</span>
<span class="gi">+            self.phase2()</span>
<span class="gi">+            self.phase3()</span>
<span class="gi">+        return self.graph</span>
<span class="gi">+</span>
<span class="gi">+    def update_remaining(self, u, v, aux_graph=None):</span>
<span class="gi">+        # decrement remaining nodes, modify auxiliary graph if in phase3</span>
<span class="gi">+        if aux_graph is not None:</span>
<span class="gi">+            # remove edges from auxiliary graph</span>
<span class="gi">+            aux_graph.remove_edge(u, v)</span>
<span class="gi">+        if self.remaining_degree[u] == 1:</span>
<span class="gi">+            del self.remaining_degree[u]</span>
<span class="gi">+            if aux_graph is not None:</span>
<span class="gi">+                aux_graph.remove_node(u)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.remaining_degree[u] -= 1</span>
<span class="gi">+        if self.remaining_degree[v] == 1:</span>
<span class="gi">+            del self.remaining_degree[v]</span>
<span class="gi">+            if aux_graph is not None:</span>
<span class="gi">+                aux_graph.remove_node(v)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.remaining_degree[v] -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def p(self, u, v):</span>
<span class="gi">+        # degree probability</span>
<span class="gi">+        return 1 - self.degree[u] * self.degree[v] / (4.0 * self.m)</span>
<span class="gi">+</span>
<span class="gi">+    def q(self, u, v):</span>
<span class="gi">+        # remaining degree probability</span>
<span class="gi">+        norm = max(self.remaining_degree.values()) ** 2</span>
<span class="gi">+        return self.remaining_degree[u] * self.remaining_degree[v] / norm</span>
<span class="gi">+</span>
<span class="w"> </span>    def suitable_edge(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if and only if an arbitrary remaining node can
<span class="w"> </span>        potentially be joined with some other remaining node.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        nodes = iter(self.remaining_degree)</span>
<span class="gi">+        u = next(nodes)</span>
<span class="gi">+        return any(v not in self.graph[u] for v in nodes)</span>
<span class="gi">+</span>
<span class="gi">+    def phase1(self):</span>
<span class="gi">+        # choose node pairs from (degree) weighted distribution</span>
<span class="gi">+        rem_deg = self.remaining_degree</span>
<span class="gi">+        while sum(rem_deg.values()) &gt;= 2 * self.dmax**2:</span>
<span class="gi">+            u, v = sorted(random_weighted_sample(rem_deg, 2, self.rng))</span>
<span class="gi">+            if self.graph.has_edge(u, v):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if self.rng.random() &lt; self.p(u, v):  # accept edge</span>
<span class="gi">+                self.graph.add_edge(u, v)</span>
<span class="gi">+                self.update_remaining(u, v)</span>
<span class="gi">+</span>
<span class="gi">+    def phase2(self):</span>
<span class="gi">+        # choose remaining nodes uniformly at random and use rejection sampling</span>
<span class="gi">+        remaining_deg = self.remaining_degree</span>
<span class="gi">+        rng = self.rng</span>
<span class="gi">+        while len(remaining_deg) &gt;= 2 * self.dmax:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                u, v = sorted(rng.sample(list(remaining_deg.keys()), 2))</span>
<span class="gi">+                if self.graph.has_edge(u, v):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if rng.random() &lt; self.q(u, v):</span>
<span class="gi">+                    break</span>
<span class="gi">+            if rng.random() &lt; self.p(u, v):  # accept edge</span>
<span class="gi">+                self.graph.add_edge(u, v)</span>
<span class="gi">+                self.update_remaining(u, v)</span>
<span class="gi">+</span>
<span class="gi">+    def phase3(self):</span>
<span class="gi">+        # build potential remaining edges and choose with rejection sampling</span>
<span class="gi">+        potential_edges = combinations(self.remaining_degree, 2)</span>
<span class="gi">+        # build auxiliary graph of potential edges not already in graph</span>
<span class="gi">+        H = nx.Graph(</span>
<span class="gi">+            [(u, v) for (u, v) in potential_edges if not self.graph.has_edge(u, v)]</span>
<span class="gi">+        )</span>
<span class="gi">+        rng = self.rng</span>
<span class="gi">+        while self.remaining_degree:</span>
<span class="gi">+            if not self.suitable_edge():</span>
<span class="gi">+                raise nx.NetworkXUnfeasible(&quot;no suitable edges left&quot;)</span>
<span class="gi">+            while True:</span>
<span class="gi">+                u, v = sorted(rng.choice(list(H.edges())))</span>
<span class="gi">+                if rng.random() &lt; self.q(u, v):</span>
<span class="gi">+                    break</span>
<span class="gi">+            if rng.random() &lt; self.p(u, v):  # accept edge</span>
<span class="gi">+                self.graph.add_edge(u, v)</span>
<span class="gi">+                self.update_remaining(u, v, aux_graph=H)</span>
<span class="gh">diff --git a/networkx/generators/directed.py b/networkx/generators/directed.py</span>
<span class="gh">index bfafe5557..4548726b9 100644</span>
<span class="gd">--- a/networkx/generators/directed.py</span>
<span class="gi">+++ b/networkx/generators/directed.py</span>
<span class="gu">@@ -3,13 +3,21 @@ Generators for some directed graphs, including growing network (GN) graphs and</span>
<span class="w"> </span>scale-free graphs.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import numbers
<span class="w"> </span>from collections import Counter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.generators.classic import empty_graph
<span class="w"> </span>from networkx.utils import discrete_sequence, py_random_state, weighted_choice
<span class="gd">-__all__ = [&#39;gn_graph&#39;, &#39;gnc_graph&#39;, &#39;gnr_graph&#39;, &#39;random_k_out_graph&#39;,</span>
<span class="gd">-    &#39;scale_free_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;gn_graph&quot;,</span>
<span class="gi">+    &quot;gnc_graph&quot;,</span>
<span class="gi">+    &quot;gnr_graph&quot;,</span>
<span class="gi">+    &quot;random_k_out_graph&quot;,</span>
<span class="gi">+    &quot;scale_free_graph&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -54,7 +62,30 @@ def gn_graph(n, kernel=None, create_using=None, seed=None):</span>
<span class="w"> </span>           Organization of Growing Random Networks,
<span class="w"> </span>           Phys. Rev. E, 63, 066123, 2001.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(1, create_using, default=nx.DiGraph)</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;create_using must indicate a Directed Graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if kernel is None:</span>
<span class="gi">+</span>
<span class="gi">+        def kernel(x):</span>
<span class="gi">+            return x</span>
<span class="gi">+</span>
<span class="gi">+    if n == 1:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    G.add_edge(1, 0)  # get started</span>
<span class="gi">+    ds = [1, 1]  # degree sequence</span>
<span class="gi">+</span>
<span class="gi">+    for source in range(2, n):</span>
<span class="gi">+        # compute distribution from kernel and degree</span>
<span class="gi">+        dist = [kernel(d) for d in ds]</span>
<span class="gi">+        # choose target from discrete distribution</span>
<span class="gi">+        target = discrete_sequence(1, distribution=dist, seed=seed)[0]</span>
<span class="gi">+        G.add_edge(source, target)</span>
<span class="gi">+        ds.append(1)  # the source has only one link (degree one)</span>
<span class="gi">+        ds[target] += 1  # add one to the target link degree</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -96,7 +127,19 @@ def gnr_graph(n, p, create_using=None, seed=None):</span>
<span class="w"> </span>           Organization of Growing Random Networks,
<span class="w"> </span>           Phys. Rev. E, 63, 066123, 2001.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(1, create_using, default=nx.DiGraph)</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;create_using must indicate a Directed Graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if n == 1:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    for source in range(1, n):</span>
<span class="gi">+        target = seed.randrange(0, source)</span>
<span class="gi">+        if seed.random() &lt; p and target != 0:</span>
<span class="gi">+            target = next(G.successors(target))</span>
<span class="gi">+        G.add_edge(source, target)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -124,13 +167,33 @@ def gnc_graph(n, create_using=None, seed=None):</span>
<span class="w"> </span>           Network Growth by Copying,
<span class="w"> </span>           Phys. Rev. E, 71, 036118, 2005k.},
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(1, create_using, default=nx.DiGraph)</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;create_using must indicate a Directed Graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if n == 1:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    for source in range(1, n):</span>
<span class="gi">+        target = seed.randrange(0, source)</span>
<span class="gi">+        for succ in G.successors(target):</span>
<span class="gi">+            G.add_edge(source, succ)</span>
<span class="gi">+        G.add_edge(source, target)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(6)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def scale_free_graph(n, alpha=0.41, beta=0.54, gamma=0.05, delta_in=0.2,</span>
<span class="gd">-    delta_out=0, seed=None, initial_graph=None):</span>
<span class="gi">+def scale_free_graph(</span>
<span class="gi">+    n,</span>
<span class="gi">+    alpha=0.41,</span>
<span class="gi">+    beta=0.54,</span>
<span class="gi">+    gamma=0.05,</span>
<span class="gi">+    delta_in=0.2,</span>
<span class="gi">+    delta_out=0,</span>
<span class="gi">+    seed=None,</span>
<span class="gi">+    initial_graph=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a scale-free directed graph.

<span class="w"> </span>    Parameters
<span class="gu">@@ -180,13 +243,99 @@ def scale_free_graph(n, alpha=0.41, beta=0.54, gamma=0.05, delta_in=0.2,</span>
<span class="w"> </span>           Proceedings of the fourteenth annual ACM-SIAM Symposium on
<span class="w"> </span>           Discrete Algorithms, 132--139, 2003.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _choose_node(candidates, node_list, delta):</span>
<span class="gi">+        if delta &gt; 0:</span>
<span class="gi">+            bias_sum = len(node_list) * delta</span>
<span class="gi">+            p_delta = bias_sum / (bias_sum + len(candidates))</span>
<span class="gi">+            if seed.random() &lt; p_delta:</span>
<span class="gi">+                return seed.choice(node_list)</span>
<span class="gi">+        return seed.choice(candidates)</span>
<span class="gi">+</span>
<span class="gi">+    if initial_graph is not None and hasattr(initial_graph, &quot;_adj&quot;):</span>
<span class="gi">+        if not isinstance(initial_graph, nx.MultiDiGraph):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;initial_graph must be a MultiDiGraph.&quot;)</span>
<span class="gi">+        G = initial_graph</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Start with 3-cycle</span>
<span class="gi">+        G = nx.MultiDiGraph([(0, 1), (1, 2), (2, 0)])</span>
<span class="gi">+</span>
<span class="gi">+    if alpha &lt;= 0:</span>
<span class="gi">+        raise ValueError(&quot;alpha must be &gt; 0.&quot;)</span>
<span class="gi">+    if beta &lt;= 0:</span>
<span class="gi">+        raise ValueError(&quot;beta must be &gt; 0.&quot;)</span>
<span class="gi">+    if gamma &lt;= 0:</span>
<span class="gi">+        raise ValueError(&quot;gamma must be &gt; 0.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if abs(alpha + beta + gamma - 1.0) &gt;= 1e-9:</span>
<span class="gi">+        raise ValueError(&quot;alpha+beta+gamma must equal 1.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if delta_in &lt; 0:</span>
<span class="gi">+        raise ValueError(&quot;delta_in must be &gt;= 0.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if delta_out &lt; 0:</span>
<span class="gi">+        raise ValueError(&quot;delta_out must be &gt;= 0.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # pre-populate degree states</span>
<span class="gi">+    vs = sum((count * [idx] for idx, count in G.out_degree()), [])</span>
<span class="gi">+    ws = sum((count * [idx] for idx, count in G.in_degree()), [])</span>
<span class="gi">+</span>
<span class="gi">+    # pre-populate node state</span>
<span class="gi">+    node_list = list(G.nodes())</span>
<span class="gi">+</span>
<span class="gi">+    # see if there already are number-based nodes</span>
<span class="gi">+    numeric_nodes = [n for n in node_list if isinstance(n, numbers.Number)]</span>
<span class="gi">+    if len(numeric_nodes) &gt; 0:</span>
<span class="gi">+        # set cursor for new nodes appropriately</span>
<span class="gi">+        cursor = max(int(n.real) for n in numeric_nodes) + 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        # or start at zero</span>
<span class="gi">+        cursor = 0</span>
<span class="gi">+</span>
<span class="gi">+    while len(G) &lt; n:</span>
<span class="gi">+        r = seed.random()</span>
<span class="gi">+</span>
<span class="gi">+        # random choice in alpha,beta,gamma ranges</span>
<span class="gi">+        if r &lt; alpha:</span>
<span class="gi">+            # alpha</span>
<span class="gi">+            # add new node v</span>
<span class="gi">+            v = cursor</span>
<span class="gi">+            cursor += 1</span>
<span class="gi">+            # also add to node state</span>
<span class="gi">+            node_list.append(v)</span>
<span class="gi">+            # choose w according to in-degree and delta_in</span>
<span class="gi">+            w = _choose_node(ws, node_list, delta_in)</span>
<span class="gi">+</span>
<span class="gi">+        elif r &lt; alpha + beta:</span>
<span class="gi">+            # beta</span>
<span class="gi">+            # choose v according to out-degree and delta_out</span>
<span class="gi">+            v = _choose_node(vs, node_list, delta_out)</span>
<span class="gi">+            # choose w according to in-degree and delta_in</span>
<span class="gi">+            w = _choose_node(ws, node_list, delta_in)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # gamma</span>
<span class="gi">+            # choose v according to out-degree and delta_out</span>
<span class="gi">+            v = _choose_node(vs, node_list, delta_out)</span>
<span class="gi">+            # add new node w</span>
<span class="gi">+            w = cursor</span>
<span class="gi">+            cursor += 1</span>
<span class="gi">+            # also add to node state</span>
<span class="gi">+            node_list.append(w)</span>
<span class="gi">+</span>
<span class="gi">+        # add edge to graph</span>
<span class="gi">+        G.add_edge(v, w)</span>
<span class="gi">+</span>
<span class="gi">+        # update degree states</span>
<span class="gi">+        vs.append(v)</span>
<span class="gi">+        ws.append(w)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(4)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def random_uniform_k_out_graph(n, k, self_loops=True, with_replacement=True,</span>
<span class="gd">-    seed=None):</span>
<span class="gi">+def random_uniform_k_out_graph(n, k, self_loops=True, with_replacement=True, seed=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a random `k`-out graph with uniform attachment.

<span class="w"> </span>    A random `k`-out graph with uniform attachment is a multidigraph
<span class="gu">@@ -242,7 +391,27 @@ def random_uniform_k_out_graph(n, k, self_loops=True, with_replacement=True,</span>
<span class="w"> </span>    set to positive infinity.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if with_replacement:</span>
<span class="gi">+        create_using = nx.MultiDiGraph()</span>
<span class="gi">+</span>
<span class="gi">+        def sample(v, nodes):</span>
<span class="gi">+            if not self_loops:</span>
<span class="gi">+                nodes = nodes - {v}</span>
<span class="gi">+            return (seed.choice(list(nodes)) for i in range(k))</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        create_using = nx.DiGraph()</span>
<span class="gi">+</span>
<span class="gi">+        def sample(v, nodes):</span>
<span class="gi">+            if not self_loops:</span>
<span class="gi">+                nodes = nodes - {v}</span>
<span class="gi">+            return seed.sample(list(nodes), k)</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.empty_graph(n, create_using)</span>
<span class="gi">+    nodes = set(G)</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        G.add_edges_from((u, v) for v in sample(u, nodes))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(4)
<span class="gu">@@ -314,4 +483,19 @@ def random_k_out_graph(n, k, alpha, self_loops=True, seed=None):</span>
<span class="w"> </span>         &lt;https://arxiv.org/abs/1311.5961&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if alpha &lt; 0:</span>
<span class="gi">+        raise ValueError(&quot;alpha must be positive&quot;)</span>
<span class="gi">+    G = nx.empty_graph(n, create_using=nx.MultiDiGraph)</span>
<span class="gi">+    weights = Counter({v: alpha for v in G})</span>
<span class="gi">+    for i in range(k * n):</span>
<span class="gi">+        u = seed.choice([v for v, d in G.out_degree() if d &lt; k])</span>
<span class="gi">+        # If self-loops are not allowed, make the source node `u` have</span>
<span class="gi">+        # weight zero.</span>
<span class="gi">+        if not self_loops:</span>
<span class="gi">+            adjustment = Counter({u: weights[u]})</span>
<span class="gi">+        else:</span>
<span class="gi">+            adjustment = Counter()</span>
<span class="gi">+        v = weighted_choice(weights - adjustment, seed=seed)</span>
<span class="gi">+        G.add_edge(u, v)</span>
<span class="gi">+        weights[v] += 1</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/duplication.py b/networkx/generators/duplication.py</span>
<span class="gh">index dbf086a76..ad8262382 100644</span>
<span class="gd">--- a/networkx/generators/duplication.py</span>
<span class="gi">+++ b/networkx/generators/duplication.py</span>
<span class="gu">@@ -8,7 +8,8 @@ generally inspired by biological networks.</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;partial_duplication_graph&#39;, &#39;duplication_divergence_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;partial_duplication_graph&quot;, &quot;duplication_divergence_graph&quot;]</span>


<span class="w"> </span>@py_random_state(4)
<span class="gu">@@ -60,7 +61,30 @@ def partial_duplication_graph(N, n, p, q, seed=None):</span>
<span class="w"> </span>           &lt;https://doi.org/10.1155/2008/190836&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if p &lt; 0 or p &gt; 1 or q &lt; 0 or q &gt; 1:</span>
<span class="gi">+        msg = &quot;partial duplication graph must have 0 &lt;= p, q &lt;= 1.&quot;</span>
<span class="gi">+        raise NetworkXError(msg)</span>
<span class="gi">+    if n &gt; N:</span>
<span class="gi">+        raise NetworkXError(&quot;partial duplication graph must have n &lt;= N.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.complete_graph(n)</span>
<span class="gi">+    for new_node in range(n, N):</span>
<span class="gi">+        # Pick a random vertex, u, already in the graph.</span>
<span class="gi">+        src_node = seed.randint(0, new_node - 1)</span>
<span class="gi">+</span>
<span class="gi">+        # Add a new vertex, v, to the graph.</span>
<span class="gi">+        G.add_node(new_node)</span>
<span class="gi">+</span>
<span class="gi">+        # For each neighbor of u...</span>
<span class="gi">+        for nbr_node in list(nx.all_neighbors(G, src_node)):</span>
<span class="gi">+            # Add the neighbor to v with probability p.</span>
<span class="gi">+            if seed.random() &lt; p:</span>
<span class="gi">+                G.add_edge(new_node, nbr_node)</span>
<span class="gi">+</span>
<span class="gi">+        # Join v and u with probability q.</span>
<span class="gi">+        if seed.random() &lt; q:</span>
<span class="gi">+            G.add_edge(new_node, src_node)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -106,4 +130,34 @@ def duplication_divergence_graph(n, p, seed=None):</span>
<span class="w"> </span>       Phys. Rev. E, 71, 061911, 2005.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if p &gt; 1 or p &lt; 0:</span>
<span class="gi">+        msg = f&quot;NetworkXError p={p} is not in [0,1].&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    if n &lt; 2:</span>
<span class="gi">+        msg = &quot;n must be greater than or equal to 2&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize the graph with two connected nodes.</span>
<span class="gi">+    G.add_edge(0, 1)</span>
<span class="gi">+    i = 2</span>
<span class="gi">+    while i &lt; n:</span>
<span class="gi">+        # Choose a random node from current graph to duplicate.</span>
<span class="gi">+        random_node = seed.choice(list(G))</span>
<span class="gi">+        # Make the replica.</span>
<span class="gi">+        G.add_node(i)</span>
<span class="gi">+        # flag indicates whether at least one edge is connected on the replica.</span>
<span class="gi">+        flag = False</span>
<span class="gi">+        for nbr in G.neighbors(random_node):</span>
<span class="gi">+            if seed.random() &lt; p:</span>
<span class="gi">+                # Link retention step.</span>
<span class="gi">+                G.add_edge(i, nbr)</span>
<span class="gi">+                flag = True</span>
<span class="gi">+        if not flag:</span>
<span class="gi">+            # Delete replica if no edges retained.</span>
<span class="gi">+            G.remove_node(i)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Successful duplication.</span>
<span class="gi">+            i += 1</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/ego.py b/networkx/generators/ego.py</span>
<span class="gh">index c20cbfe2d..d959a1bd1 100644</span>
<span class="gd">--- a/networkx/generators/ego.py</span>
<span class="gi">+++ b/networkx/generators/ego.py</span>
<span class="gu">@@ -1,7 +1,8 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Ego graph.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;ego_graph&#39;]</span>
<span class="gi">+__all__ = [&quot;ego_graph&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx


<span class="gu">@@ -41,4 +42,24 @@ def ego_graph(G, n, radius=1, center=True, undirected=False, distance=None):</span>

<span class="w"> </span>    Node, edge, and graph attributes are copied to the returned subgraph.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if undirected:</span>
<span class="gi">+        if distance is not None:</span>
<span class="gi">+            sp, _ = nx.single_source_dijkstra(</span>
<span class="gi">+                G.to_undirected(), n, cutoff=radius, weight=distance</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            sp = dict(</span>
<span class="gi">+                nx.single_source_shortest_path_length(</span>
<span class="gi">+                    G.to_undirected(), n, cutoff=radius</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+    else:</span>
<span class="gi">+        if distance is not None:</span>
<span class="gi">+            sp, _ = nx.single_source_dijkstra(G, n, cutoff=radius, weight=distance)</span>
<span class="gi">+        else:</span>
<span class="gi">+            sp = dict(nx.single_source_shortest_path_length(G, n, cutoff=radius))</span>
<span class="gi">+</span>
<span class="gi">+    H = G.subgraph(sp).copy()</span>
<span class="gi">+    if not center:</span>
<span class="gi">+        H.remove_node(n)</span>
<span class="gi">+    return H</span>
<span class="gh">diff --git a/networkx/generators/expanders.py b/networkx/generators/expanders.py</span>
<span class="gh">index a7dc6c848..69043fb57 100644</span>
<span class="gd">--- a/networkx/generators/expanders.py</span>
<span class="gi">+++ b/networkx/generators/expanders.py</span>
<span class="gu">@@ -2,19 +2,58 @@</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import itertools
<span class="gd">-import networkx as nx</span>
<span class="gd">-__all__ = [&#39;margulis_gabber_galil_graph&#39;, &#39;chordal_cycle_graph&#39;,</span>
<span class="gd">-    &#39;paley_graph&#39;, &#39;maybe_regular_expander&#39;, &#39;is_regular_expander&#39;,</span>
<span class="gd">-    &#39;random_regular_expander_graph&#39;]</span>

<span class="gi">+import networkx as nx</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;margulis_gabber_galil_graph&quot;,</span>
<span class="gi">+    &quot;chordal_cycle_graph&quot;,</span>
<span class="gi">+    &quot;paley_graph&quot;,</span>
<span class="gi">+    &quot;maybe_regular_expander&quot;,</span>
<span class="gi">+    &quot;is_regular_expander&quot;,</span>
<span class="gi">+    &quot;random_regular_expander_graph&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Other discrete torus expanders can be constructed by using the following edge</span>
<span class="gi">+# sets. For more information, see Chapter 4, &quot;Expander Graphs&quot;, in</span>
<span class="gi">+# &quot;Pseudorandomness&quot;, by Salil Vadhan.</span>
<span class="gi">+#</span>
<span class="gi">+# For a directed expander, add edges from (x, y) to:</span>
<span class="gi">+#</span>
<span class="gi">+#     (x, y),</span>
<span class="gi">+#     ((x + 1) % n, y),</span>
<span class="gi">+#     (x, (y + 1) % n),</span>
<span class="gi">+#     (x, (x + y) % n),</span>
<span class="gi">+#     (-y % n, x)</span>
<span class="gi">+#</span>
<span class="gi">+# For an undirected expander, add the reverse edges.</span>
<span class="gi">+#</span>
<span class="gi">+# Also appearing in the paper of Gabber and Galil:</span>
<span class="gi">+#</span>
<span class="gi">+#     (x, y),</span>
<span class="gi">+#     (x, (x + y) % n),</span>
<span class="gi">+#     (x, (x + y + 1) % n),</span>
<span class="gi">+#     ((x + y) % n, y),</span>
<span class="gi">+#     ((x + y + 1) % n, y)</span>
<span class="gi">+#</span>
<span class="gi">+# and:</span>
<span class="gi">+#</span>
<span class="gi">+#     (x, y),</span>
<span class="gi">+#     ((x + 2*y) % n, y),</span>
<span class="gi">+#     ((x + (2*y + 1)) % n, y),</span>
<span class="gi">+#     ((x + (2*y + 2)) % n, y),</span>
<span class="gi">+#     (x, (y + 2*x) % n),</span>
<span class="gi">+#     (x, (y + (2*x + 1)) % n),</span>
<span class="gi">+#     (x, (y + (2*x + 2)) % n),</span>
<span class="gi">+#</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def margulis_gabber_galil_graph(n, create_using=None):
<span class="gd">-    &quot;&quot;&quot;Returns the Margulis-Gabber-Galil undirected MultiGraph on `n^2` nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Margulis-Gabber-Galil undirected MultiGraph on `n^2` nodes.</span>

<span class="w"> </span>    The undirected MultiGraph is regular with degree `8`. Nodes are integer
<span class="w"> </span>    pairs. The second-largest eigenvalue of the adjacency matrix of the graph
<span class="gd">-    is at most `5 \\sqrt{2}`, regardless of `n`.</span>
<span class="gi">+    is at most `5 \sqrt{2}`, regardless of `n`.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -34,7 +73,21 @@ def margulis_gabber_galil_graph(n, create_using=None):</span>
<span class="w"> </span>        If the graph is directed or not a multigraph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)</span>
<span class="gi">+    if G.is_directed() or not G.is_multigraph():</span>
<span class="gi">+        msg = &quot;`create_using` must be an undirected multigraph.&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    for x, y in itertools.product(range(n), repeat=2):</span>
<span class="gi">+        for u, v in (</span>
<span class="gi">+            ((x + 2 * y) % n, y),</span>
<span class="gi">+            ((x + (2 * y + 1)) % n, y),</span>
<span class="gi">+            (x, (y + 2 * x) % n),</span>
<span class="gi">+            (x, (y + (2 * x + 1)) % n),</span>
<span class="gi">+        ):</span>
<span class="gi">+            G.add_edge((x, y), (u, v))</span>
<span class="gi">+    G.graph[&quot;name&quot;] = f&quot;margulis_gabber_galil_graph({n})&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -76,24 +129,46 @@ def chordal_cycle_graph(p, create_using=None):</span>
<span class="w"> </span>           Birkhäuser Verlag, Basel, 1994.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)</span>
<span class="gi">+    if G.is_directed() or not G.is_multigraph():</span>
<span class="gi">+        msg = &quot;`create_using` must be an undirected multigraph.&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    for x in range(p):</span>
<span class="gi">+        left = (x - 1) % p</span>
<span class="gi">+        right = (x + 1) % p</span>
<span class="gi">+        # Here we apply Fermat&#39;s Little Theorem to compute the multiplicative</span>
<span class="gi">+        # inverse of x in Z/pZ. By Fermat&#39;s Little Theorem,</span>
<span class="gi">+        #</span>
<span class="gi">+        #     x^p = x (mod p)</span>
<span class="gi">+        #</span>
<span class="gi">+        # Therefore,</span>
<span class="gi">+        #</span>
<span class="gi">+        #     x * x^(p - 2) = 1 (mod p)</span>
<span class="gi">+        #</span>
<span class="gi">+        # The number 0 is a special case: we just let its inverse be itself.</span>
<span class="gi">+        chord = pow(x, p - 2, p) if x &gt; 0 else 0</span>
<span class="gi">+        for y in (left, right, chord):</span>
<span class="gi">+            G.add_edge(x, y)</span>
<span class="gi">+    G.graph[&quot;name&quot;] = f&quot;chordal_cycle_graph({p})&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def paley_graph(p, create_using=None):
<span class="gd">-    &quot;&quot;&quot;Returns the Paley $\\frac{(p-1)}{2}$ -regular graph on $p$ nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Paley $\frac{(p-1)}{2}$ -regular graph on $p$ nodes.</span>

<span class="gd">-    The returned graph is a graph on $\\mathbb{Z}/p\\mathbb{Z}$ with edges between $x$ and $y$</span>
<span class="gd">-    if and only if $x-y$ is a nonzero square in $\\mathbb{Z}/p\\mathbb{Z}$.</span>
<span class="gi">+    The returned graph is a graph on $\mathbb{Z}/p\mathbb{Z}$ with edges between $x$ and $y$</span>
<span class="gi">+    if and only if $x-y$ is a nonzero square in $\mathbb{Z}/p\mathbb{Z}$.</span>

<span class="gd">-    If $p \\equiv 1  \\pmod 4$, $-1$ is a square in $\\mathbb{Z}/p\\mathbb{Z}$ and therefore $x-y$ is a square if and</span>
<span class="gi">+    If $p \equiv 1  \pmod 4$, $-1$ is a square in $\mathbb{Z}/p\mathbb{Z}$ and therefore $x-y$ is a square if and</span>
<span class="w"> </span>    only if $y-x$ is also a square, i.e the edges in the Paley graph are symmetric.

<span class="gd">-    If $p \\equiv 3 \\pmod 4$, $-1$ is not a square in $\\mathbb{Z}/p\\mathbb{Z}$ and therefore either $x-y$ or $y-x$</span>
<span class="gd">-    is a square in $\\mathbb{Z}/p\\mathbb{Z}$ but not both.</span>
<span class="gi">+    If $p \equiv 3 \pmod 4$, $-1$ is not a square in $\mathbb{Z}/p\mathbb{Z}$ and therefore either $x-y$ or $y-x$</span>
<span class="gi">+    is a square in $\mathbb{Z}/p\mathbb{Z}$ but not both.</span>

<span class="w"> </span>    Note that a more general definition of Paley graphs extends this construction
<span class="gd">-    to graphs over $q=p^n$ vertices, by using the finite field $F_q$ instead of $\\mathbb{Z}/p\\mathbb{Z}$.</span>
<span class="gi">+    to graphs over $q=p^n$ vertices, by using the finite field $F_q$ instead of $\mathbb{Z}/p\mathbb{Z}$.</span>
<span class="w"> </span>    This construction requires to compute squares in general finite fields and is
<span class="w"> </span>    not what is implemented here (i.e `paley_graph(25)` does not return the true
<span class="w"> </span>    Paley graph associated with $5^2$).
<span class="gu">@@ -121,14 +196,27 @@ def paley_graph(p, create_using=None):</span>
<span class="w"> </span>    Cambridge Studies in Advanced Mathematics, 73.
<span class="w"> </span>    Cambridge University Press, Cambridge (2001).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(0, create_using, default=nx.DiGraph)</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        msg = &quot;`create_using` cannot be a multigraph.&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # Compute the squares in Z/pZ.</span>
<span class="gi">+    # Make it a set to uniquify (there are exactly (p-1)/2 squares in Z/pZ</span>
<span class="gi">+    # when is prime).</span>
<span class="gi">+    square_set = {(x**2) % p for x in range(1, p) if (x**2) % p != 0}</span>

<span class="gi">+    for x in range(p):</span>
<span class="gi">+        for x2 in square_set:</span>
<span class="gi">+            G.add_edge(x, (x + x2) % p)</span>
<span class="gi">+    G.graph[&quot;name&quot;] = f&quot;paley({p})&quot;</span>
<span class="gi">+    return G</span>

<span class="gd">-@nx.utils.decorators.np_random_state(&#39;seed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.decorators.np_random_state(&quot;seed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def maybe_regular_expander(n, d, *, create_using=None, max_tries=100, seed=None</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;Utility for creating a random regular expander.</span>
<span class="gi">+def maybe_regular_expander(n, d, *, create_using=None, max_tries=100, seed=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Utility for creating a random regular expander.</span>

<span class="w"> </span>    Returns a random $d$-regular graph on $n$ nodes which is an expander
<span class="w"> </span>    graph with very good probability.
<span class="gu">@@ -157,7 +245,7 @@ def maybe_regular_expander(n, d, *, create_using=None, max_tries=100, seed=None</span>

<span class="w"> </span>    Joel Friedman proved that in this model the resulting
<span class="w"> </span>    graph is an expander with probability
<span class="gd">-    $1 - O(n^{-\\tau})$ where $\\tau = \\lceil (\\sqrt{d - 1}) / 2 \\rceil - 1$. [1]_</span>
<span class="gi">+    $1 - O(n^{-\tau})$ where $\tau = \lceil (\sqrt{d - 1}) / 2 \rceil - 1$. [1]_</span>

<span class="w"> </span>    Examples
<span class="w"> </span>    --------
<span class="gu">@@ -187,23 +275,75 @@ def maybe_regular_expander(n, d, *, create_using=None, max_tries=100, seed=None</span>
<span class="w"> </span>       https://arxiv.org/abs/cs/0405020

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if n &lt; 1:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;n must be a positive integer&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not (d &gt;= 2):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;d must be greater than or equal to 2&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not (d % 2 == 0):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;d must be even&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not (n - 1 &gt;= d):</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;Need n-1&gt;= d to have room for {d//2} independent cycles with {n} nodes&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.empty_graph(n, create_using)</span>
<span class="gi">+</span>
<span class="gi">+    if n &lt; 2:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    cycles = []</span>
<span class="gi">+    edges = set()</span>
<span class="gi">+</span>
<span class="gi">+    # Create d / 2 cycles</span>
<span class="gi">+    for i in range(d // 2):</span>
<span class="gi">+        iterations = max_tries</span>
<span class="gi">+        # Make sure the cycles are independent to have a regular graph</span>
<span class="gi">+        while len(edges) != (i + 1) * n:</span>
<span class="gi">+            iterations -= 1</span>
<span class="gi">+            # Faster than random.permutation(n) since there are only</span>
<span class="gi">+            # (n-1)! distinct cycles against n! permutations of size n</span>
<span class="gi">+            cycle = seed.permutation(n - 1).tolist()</span>
<span class="gi">+            cycle.append(n - 1)</span>

<span class="gd">-@nx.utils.not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@nx.utils.not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(preserve_edge_attrs={&#39;G&#39;: {&#39;weight&#39;: 1}})</span>
<span class="gi">+            new_edges = {</span>
<span class="gi">+                (u, v)</span>
<span class="gi">+                for u, v in nx.utils.pairwise(cycle, cyclic=True)</span>
<span class="gi">+                if (u, v) not in edges and (v, u) not in edges</span>
<span class="gi">+            }</span>
<span class="gi">+            # If the new cycle has no edges in common with previous cycles</span>
<span class="gi">+            # then add it to the list otherwise try again</span>
<span class="gi">+            if len(new_edges) == n:</span>
<span class="gi">+                cycles.append(cycle)</span>
<span class="gi">+                edges.update(new_edges)</span>
<span class="gi">+</span>
<span class="gi">+            if iterations == 0:</span>
<span class="gi">+                raise nx.NetworkXError(&quot;Too many iterations in maybe_regular_expander&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G.add_edges_from(edges)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@nx.utils.not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(preserve_edge_attrs={&quot;G&quot;: {&quot;weight&quot;: 1}})</span>
<span class="w"> </span>def is_regular_expander(G, *, epsilon=0):
<span class="gd">-    &quot;&quot;&quot;Determines whether the graph G is a regular expander. [1]_</span>
<span class="gi">+    r&quot;&quot;&quot;Determines whether the graph G is a regular expander. [1]_</span>

<span class="w"> </span>    An expander graph is a sparse graph with strong connectivity properties.

<span class="w"> </span>    More precisely, this helper checks whether the graph is a
<span class="gd">-    regular $(n, d, \\lambda)$-expander with $\\lambda$ close to</span>
<span class="gi">+    regular $(n, d, \lambda)$-expander with $\lambda$ close to</span>
<span class="w"> </span>    the Alon-Boppana bound and given by
<span class="gd">-    $\\lambda = 2 \\sqrt{d - 1} + \\epsilon$. [2]_</span>
<span class="gi">+    $\lambda = 2 \sqrt{d - 1} + \epsilon$. [2]_</span>

<span class="gd">-    In the case where $\\epsilon = 0$ then if the graph successfully passes the test</span>
<span class="gi">+    In the case where $\epsilon = 0$ then if the graph successfully passes the test</span>
<span class="w"> </span>    it is a Ramanujan graph. [3]_

<span class="w"> </span>    A Ramanujan graph has spectral gap almost as large as possible, which makes them
<span class="gu">@@ -217,8 +357,8 @@ def is_regular_expander(G, *, epsilon=0):</span>
<span class="w"> </span>    Returns
<span class="w"> </span>    -------
<span class="w"> </span>    bool
<span class="gd">-        Whether the given graph is a regular $(n, d, \\lambda)$-expander</span>
<span class="gd">-        where $\\lambda = 2 \\sqrt{d - 1} + \\epsilon$.</span>
<span class="gi">+        Whether the given graph is a regular $(n, d, \lambda)$-expander</span>
<span class="gi">+        where $\lambda = 2 \sqrt{d - 1} + \epsilon$.</span>

<span class="w"> </span>    Examples
<span class="w"> </span>    --------
<span class="gu">@@ -238,21 +378,41 @@ def is_regular_expander(G, *, epsilon=0):</span>
<span class="w"> </span>    .. [3] Ramanujan graphs, https://en.wikipedia.org/wiki/Ramanujan_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    from scipy.sparse.linalg import eigsh</span>
<span class="gi">+</span>
<span class="gi">+    if epsilon &lt; 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;epsilon must be non negative&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not nx.is_regular(G):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    _, d = nx.utils.arbitrary_element(G.degree)</span>
<span class="gi">+</span>
<span class="gi">+    A = nx.adjacency_matrix(G, dtype=float)</span>
<span class="gi">+    lams = eigsh(A, which=&quot;LM&quot;, k=2, return_eigenvectors=False)</span>
<span class="gi">+</span>
<span class="gi">+    # lambda2 is the second biggest eigenvalue</span>
<span class="gi">+    lambda2 = min(lams)</span>
<span class="gi">+</span>
<span class="gi">+    # Use bool() to convert numpy scalar to Python Boolean</span>
<span class="gi">+    return bool(abs(lambda2) &lt; 2 ** np.sqrt(d - 1) + epsilon)</span>


<span class="gd">-@nx.utils.decorators.np_random_state(&#39;seed&#39;)</span>
<span class="gi">+@nx.utils.decorators.np_random_state(&quot;seed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def random_regular_expander_graph(n, d, *, epsilon=0, create_using=None,</span>
<span class="gd">-    max_tries=100, seed=None):</span>
<span class="gd">-    &quot;&quot;&quot;Returns a random regular expander graph on $n$ nodes with degree $d$.</span>
<span class="gi">+def random_regular_expander_graph(</span>
<span class="gi">+    n, d, *, epsilon=0, create_using=None, max_tries=100, seed=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a random regular expander graph on $n$ nodes with degree $d$.</span>

<span class="w"> </span>    An expander graph is a sparse graph with strong connectivity properties. [1]_

<span class="gd">-    More precisely the returned graph is a $(n, d, \\lambda)$-expander with</span>
<span class="gd">-    $\\lambda = 2 \\sqrt{d - 1} + \\epsilon$, close to the Alon-Boppana bound. [2]_</span>
<span class="gi">+    More precisely the returned graph is a $(n, d, \lambda)$-expander with</span>
<span class="gi">+    $\lambda = 2 \sqrt{d - 1} + \epsilon$, close to the Alon-Boppana bound. [2]_</span>

<span class="gd">-    In the case where $\\epsilon = 0$ it returns a Ramanujan graph.</span>
<span class="gi">+    In the case where $\epsilon = 0$ it returns a Ramanujan graph.</span>
<span class="w"> </span>    A Ramanujan graph has spectral gap almost as large as possible,
<span class="w"> </span>    which makes them excellent expanders. [3]_

<span class="gu">@@ -282,7 +442,7 @@ def random_regular_expander_graph(n, d, *, epsilon=0, create_using=None,</span>
<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="w"> </span>    This loops over `maybe_regular_expander` and can be slow when
<span class="gd">-    $n$ is too big or $\\epsilon$ too small.</span>
<span class="gi">+    $n$ is too big or $\epsilon$ too small.</span>

<span class="w"> </span>    See Also
<span class="w"> </span>    --------
<span class="gu">@@ -296,4 +456,20 @@ def random_regular_expander_graph(n, d, *, epsilon=0, create_using=None,</span>
<span class="w"> </span>    .. [3] Ramanujan graphs, https://en.wikipedia.org/wiki/Ramanujan_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = maybe_regular_expander(</span>
<span class="gi">+        n, d, create_using=create_using, max_tries=max_tries, seed=seed</span>
<span class="gi">+    )</span>
<span class="gi">+    iterations = max_tries</span>
<span class="gi">+</span>
<span class="gi">+    while not is_regular_expander(G, epsilon=epsilon):</span>
<span class="gi">+        iterations -= 1</span>
<span class="gi">+        G = maybe_regular_expander(</span>
<span class="gi">+            n=n, d=d, create_using=create_using, max_tries=max_tries, seed=seed</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if iterations == 0:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;Too many iterations in random_regular_expander_graph&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/geometric.py b/networkx/generators/geometric.py</span>
<span class="gh">index 5cfd11642..bb7fbd76d 100644</span>
<span class="gd">--- a/networkx/generators/geometric.py</span>
<span class="gi">+++ b/networkx/generators/geometric.py</span>
<span class="gu">@@ -1,18 +1,27 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Generators for geometric graphs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="w"> </span>from bisect import bisect_left
<span class="w"> </span>from itertools import accumulate, combinations, product
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;geometric_edges&#39;, &#39;geographical_threshold_graph&#39;,</span>
<span class="gd">-    &#39;navigable_small_world_graph&#39;, &#39;random_geometric_graph&#39;,</span>
<span class="gd">-    &#39;soft_random_geometric_graph&#39;, &#39;thresholded_random_geometric_graph&#39;,</span>
<span class="gd">-    &#39;waxman_graph&#39;, &#39;geometric_soft_configuration_graph&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;geometric_edges&quot;,</span>
<span class="gi">+    &quot;geographical_threshold_graph&quot;,</span>
<span class="gi">+    &quot;navigable_small_world_graph&quot;,</span>
<span class="gi">+    &quot;random_geometric_graph&quot;,</span>
<span class="gi">+    &quot;soft_random_geometric_graph&quot;,</span>
<span class="gi">+    &quot;thresholded_random_geometric_graph&quot;,</span>
<span class="gi">+    &quot;waxman_graph&quot;,</span>
<span class="gi">+    &quot;geometric_soft_configuration_graph&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@nx._dispatchable(node_attrs=&#39;pos_name&#39;)</span>
<span class="gd">-def geometric_edges(G, radius, p=2, *, pos_name=&#39;pos&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(node_attrs=&quot;pos_name&quot;)</span>
<span class="gi">+def geometric_edges(G, radius, p=2, *, pos_name=&quot;pos&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns edge list of node pairs within `radius` of each other.

<span class="w"> </span>    Parameters
<span class="gu">@@ -64,7 +73,18 @@ def geometric_edges(G, radius, p=2, *, pos_name=&#39;pos&#39;):</span>
<span class="w"> </span>    &gt;&gt;&gt; nx.geometric_edges(G, radius=9)
<span class="w"> </span>    [(0, 1), (0, 2), (1, 2)]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Input validation - every node must have a &quot;pos&quot; attribute</span>
<span class="gi">+    for n, pos in G.nodes(data=pos_name):</span>
<span class="gi">+        if pos is None:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;Node {n} (and all nodes) must have a &#39;{pos_name}&#39; attribute.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # NOTE: See _geometric_edges for the actual implementation. The reason this</span>
<span class="gi">+    # is split into two functions is to avoid the overhead of input validation</span>
<span class="gi">+    # every time the function is called internally in one of the other</span>
<span class="gi">+    # geometric generators</span>
<span class="gi">+    return _geometric_edges(G, radius, p, pos_name)</span>


<span class="w"> </span>def _geometric_edges(G, radius, p, pos_name):
<span class="gu">@@ -72,13 +92,31 @@ def _geometric_edges(G, radius, p, pos_name):</span>
<span class="w"> </span>    Implements `geometric_edges` without input validation. See `geometric_edges`
<span class="w"> </span>    for complete docstring.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nodes_pos = G.nodes(data=pos_name)</span>
<span class="gi">+    try:</span>
<span class="gi">+        import scipy as sp</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        # no scipy KDTree so compute by for-loop</span>
<span class="gi">+        radius_p = radius**p</span>
<span class="gi">+        edges = [</span>
<span class="gi">+            (u, v)</span>
<span class="gi">+            for (u, pu), (v, pv) in combinations(nodes_pos, 2)</span>
<span class="gi">+            if sum(abs(a - b) ** p for a, b in zip(pu, pv)) &lt;= radius_p</span>
<span class="gi">+        ]</span>
<span class="gi">+        return edges</span>
<span class="gi">+    # scipy KDTree is available</span>
<span class="gi">+    nodes, coords = list(zip(*nodes_pos))</span>
<span class="gi">+    kdtree = sp.spatial.cKDTree(coords)  # Cannot provide generator.</span>
<span class="gi">+    edge_indexes = kdtree.query_pairs(radius, p)</span>
<span class="gi">+    edges = [(nodes[u], nodes[v]) for u, v in sorted(edge_indexes)]</span>
<span class="gi">+    return edges</span>


<span class="w"> </span>@py_random_state(5)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def random_geometric_graph(n, radius, dim=2, pos=None, p=2, seed=None, *,</span>
<span class="gd">-    pos_name=&#39;pos&#39;):</span>
<span class="gi">+def random_geometric_graph(</span>
<span class="gi">+    n, radius, dim=2, pos=None, p=2, seed=None, *, pos_name=&quot;pos&quot;</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a random geometric graph in the unit cube of dimensions `dim`.

<span class="w"> </span>    The random geometric graph model places `n` nodes uniformly at
<span class="gu">@@ -150,14 +188,30 @@ def random_geometric_graph(n, radius, dim=2, pos=None, p=2, seed=None, *,</span>
<span class="w"> </span>           Oxford Studies in Probability, 5, 2003.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # TODO Is this function just a special case of the geographical</span>
<span class="gi">+    # threshold graph?</span>
<span class="gi">+    #</span>
<span class="gi">+    #     half_radius = {v: radius / 2 for v in n}</span>
<span class="gi">+    #     return geographical_threshold_graph(nodes, theta=1, alpha=1,</span>
<span class="gi">+    #                                         weight=half_radius)</span>
<span class="gi">+    #</span>
<span class="gi">+    G = nx.empty_graph(n)</span>
<span class="gi">+    # If no positions are provided, choose uniformly random vectors in</span>
<span class="gi">+    # Euclidean space of the specified dimension.</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = {v: [seed.random() for i in range(dim)] for v in G}</span>
<span class="gi">+    nx.set_node_attributes(G, pos, pos_name)</span>
<span class="gi">+</span>
<span class="gi">+    G.add_edges_from(_geometric_edges(G, radius, p, pos_name))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(6)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def soft_random_geometric_graph(n, radius, dim=2, pos=None, p=2, p_dist=</span>
<span class="gd">-    None, seed=None, *, pos_name=&#39;pos&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Returns a soft random geometric graph in the unit cube.</span>
<span class="gi">+def soft_random_geometric_graph(</span>
<span class="gi">+    n, radius, dim=2, pos=None, p=2, p_dist=None, seed=None, *, pos_name=&quot;pos&quot;</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a soft random geometric graph in the unit cube.</span>

<span class="w"> </span>    The soft random geometric graph [1] model places `n` nodes uniformly at
<span class="w"> </span>    random in the unit cube in dimension `dim`. Two nodes of distance, `dist`,
<span class="gu">@@ -198,7 +252,7 @@ def soft_random_geometric_graph(n, radius, dim=2, pos=None, p=2, p_dist=</span>
<span class="w"> </span>        tools for custom probability distribution definitions [2], and passing
<span class="w"> </span>        the .pdf method of scipy.stats distributions can be used here.  If the
<span class="w"> </span>        probability function, `p_dist`, is not supplied, the default function
<span class="gd">-        is an exponential distribution with rate parameter :math:`\\lambda=1`.</span>
<span class="gi">+        is an exponential distribution with rate parameter :math:`\lambda=1`.</span>
<span class="w"> </span>    seed : integer, random_state, or None (default)
<span class="w"> </span>        Indicator of random number generation state.
<span class="w"> </span>        See :ref:`Randomness&lt;randomness&gt;`.
<span class="gu">@@ -225,7 +279,7 @@ def soft_random_geometric_graph(n, radius, dim=2, pos=None, p=2, p_dist=</span>

<span class="w"> </span>    Create a soft random geometric graph on 100 uniformly distributed nodes
<span class="w"> </span>    where nodes are joined by an edge with probability computed from an
<span class="gd">-    exponential distribution with rate parameter :math:`\\lambda=1` if their</span>
<span class="gi">+    exponential distribution with rate parameter :math:`\lambda=1` if their</span>
<span class="w"> </span>    Euclidean distance is at most 0.2.

<span class="w"> </span>    Notes
<span class="gu">@@ -258,15 +312,46 @@ def soft_random_geometric_graph(n, radius, dim=2, pos=None, p=2, p_dist=</span>
<span class="w"> </span>           https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(n)</span>
<span class="gi">+    G.name = f&quot;soft_random_geometric_graph({n}, {radius}, {dim})&quot;</span>
<span class="gi">+    # If no positions are provided, choose uniformly random vectors in</span>
<span class="gi">+    # Euclidean space of the specified dimension.</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = {v: [seed.random() for i in range(dim)] for v in G}</span>
<span class="gi">+    nx.set_node_attributes(G, pos, pos_name)</span>
<span class="gi">+</span>
<span class="gi">+    # if p_dist function not supplied the default function is an exponential</span>
<span class="gi">+    # distribution with rate parameter :math:`\lambda=1`.</span>
<span class="gi">+    if p_dist is None:</span>
<span class="gi">+</span>
<span class="gi">+        def p_dist(dist):</span>
<span class="gi">+            return math.exp(-dist)</span>
<span class="gi">+</span>
<span class="gi">+    def should_join(edge):</span>
<span class="gi">+        u, v = edge</span>
<span class="gi">+        dist = (sum(abs(a - b) ** p for a, b in zip(pos[u], pos[v]))) ** (1 / p)</span>
<span class="gi">+        return seed.random() &lt; p_dist(dist)</span>
<span class="gi">+</span>
<span class="gi">+    G.add_edges_from(filter(should_join, _geometric_edges(G, radius, p, pos_name)))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(7)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def geographical_threshold_graph(n, theta, dim=2, pos=None, weight=None,</span>
<span class="gd">-    metric=None, p_dist=None, seed=None, *, pos_name=&#39;pos&#39;, weight_name=</span>
<span class="gd">-    &#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Returns a geographical threshold graph.</span>
<span class="gi">+def geographical_threshold_graph(</span>
<span class="gi">+    n,</span>
<span class="gi">+    theta,</span>
<span class="gi">+    dim=2,</span>
<span class="gi">+    pos=None,</span>
<span class="gi">+    weight=None,</span>
<span class="gi">+    metric=None,</span>
<span class="gi">+    p_dist=None,</span>
<span class="gi">+    seed=None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    pos_name=&quot;pos&quot;,</span>
<span class="gi">+    weight_name=&quot;weight&quot;,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a geographical threshold graph.</span>

<span class="w"> </span>    The geographical threshold graph model places $n$ nodes uniformly at
<span class="w"> </span>    random in a rectangular domain.  Each node $u$ is assigned a weight
<span class="gu">@@ -274,10 +359,10 @@ def geographical_threshold_graph(n, theta, dim=2, pos=None, weight=None,</span>

<span class="w"> </span>    .. math::

<span class="gd">-       (w_u + w_v)p_{dist}(r) \\ge \\theta</span>
<span class="gi">+       (w_u + w_v)p_{dist}(r) \ge \theta</span>

<span class="w"> </span>    where `r` is the distance between `u` and `v`, `p_dist` is any function of
<span class="gd">-    `r`, and :math:`\\theta` as the threshold parameter. `p_dist` is used to</span>
<span class="gi">+    `r`, and :math:`\theta` as the threshold parameter. `p_dist` is used to</span>
<span class="w"> </span>    give weight to the distance between nodes when deciding whether or not
<span class="w"> </span>    they should be connected. The larger `p_dist` is, the more prone nodes
<span class="w"> </span>    separated by `r` are to be connected, and vice versa.
<span class="gu">@@ -302,10 +387,10 @@ def geographical_threshold_graph(n, theta, dim=2, pos=None, weight=None,</span>
<span class="w"> </span>        Specifically, if $d$ is the function and $x$, $y$,
<span class="w"> </span>        and $z$ are vectors in the graph, then $d$ must satisfy

<span class="gd">-        1. $d(x, y) \\ge 0$,</span>
<span class="gi">+        1. $d(x, y) \ge 0$,</span>
<span class="w"> </span>        2. $d(x, y) = 0$ if and only if $x = y$,
<span class="w"> </span>        3. $d(x, y) = d(y, x)$,
<span class="gd">-        4. $d(x, z) \\le d(x, y) + d(y, z)$.</span>
<span class="gi">+        4. $d(x, z) \le d(x, y) + d(y, z)$.</span>

<span class="w"> </span>        If this argument is not specified, the Euclidean distance metric is
<span class="w"> </span>        used.
<span class="gu">@@ -361,7 +446,7 @@ def geographical_threshold_graph(n, theta, dim=2, pos=None, weight=None,</span>
<span class="w"> </span>    Notes
<span class="w"> </span>    -----
<span class="w"> </span>    If weights are not specified they are assigned to nodes by drawing randomly
<span class="gd">-    from the exponential distribution with rate parameter $\\lambda=1$.</span>
<span class="gi">+    from the exponential distribution with rate parameter $\lambda=1$.</span>
<span class="w"> </span>    To specify weights from a different distribution, use the `weight` keyword
<span class="w"> </span>    argument::

<span class="gu">@@ -384,21 +469,61 @@ def geographical_threshold_graph(n, theta, dim=2, pos=None, weight=None,</span>
<span class="w"> </span>       in Algorithms and Models for the Web-Graph (WAW 2007),
<span class="w"> </span>       Antony Bonato and Fan Chung (Eds), pp. 209--216, 2007
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(n)</span>
<span class="gi">+    # If no weights are provided, choose them from an exponential</span>
<span class="gi">+    # distribution.</span>
<span class="gi">+    if weight is None:</span>
<span class="gi">+        weight = {v: seed.expovariate(1) for v in G}</span>
<span class="gi">+    # If no positions are provided, choose uniformly random vectors in</span>
<span class="gi">+    # Euclidean space of the specified dimension.</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = {v: [seed.random() for i in range(dim)] for v in G}</span>
<span class="gi">+    # If no distance metric is provided, use Euclidean distance.</span>
<span class="gi">+    if metric is None:</span>
<span class="gi">+        metric = math.dist</span>
<span class="gi">+    nx.set_node_attributes(G, weight, weight_name)</span>
<span class="gi">+    nx.set_node_attributes(G, pos, pos_name)</span>
<span class="gi">+</span>
<span class="gi">+    # if p_dist is not supplied, use default r^-2</span>
<span class="gi">+    if p_dist is None:</span>
<span class="gi">+</span>
<span class="gi">+        def p_dist(r):</span>
<span class="gi">+            return r**-2</span>
<span class="gi">+</span>
<span class="gi">+    # Returns ``True`` if and only if the nodes whose attributes are</span>
<span class="gi">+    # ``du`` and ``dv`` should be joined, according to the threshold</span>
<span class="gi">+    # condition.</span>
<span class="gi">+    def should_join(pair):</span>
<span class="gi">+        u, v = pair</span>
<span class="gi">+        u_pos, v_pos = pos[u], pos[v]</span>
<span class="gi">+        u_weight, v_weight = weight[u], weight[v]</span>
<span class="gi">+        return (u_weight + v_weight) * p_dist(metric(u_pos, v_pos)) &gt;= theta</span>
<span class="gi">+</span>
<span class="gi">+    G.add_edges_from(filter(should_join, combinations(G, 2)))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(6)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def waxman_graph(n, beta=0.4, alpha=0.1, L=None, domain=(0, 0, 1, 1),</span>
<span class="gd">-    metric=None, seed=None, *, pos_name=&#39;pos&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Returns a Waxman random graph.</span>
<span class="gi">+def waxman_graph(</span>
<span class="gi">+    n,</span>
<span class="gi">+    beta=0.4,</span>
<span class="gi">+    alpha=0.1,</span>
<span class="gi">+    L=None,</span>
<span class="gi">+    domain=(0, 0, 1, 1),</span>
<span class="gi">+    metric=None,</span>
<span class="gi">+    seed=None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    pos_name=&quot;pos&quot;,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a Waxman random graph.</span>

<span class="w"> </span>    The Waxman random graph model places `n` nodes uniformly at random
<span class="w"> </span>    in a rectangular domain. Each pair of nodes at distance `d` is
<span class="w"> </span>    joined by an edge with probability

<span class="w"> </span>    .. math::
<span class="gd">-            p = \\beta \\exp(-d / \\alpha L).</span>
<span class="gi">+            p = \beta \exp(-d / \alpha L).</span>

<span class="w"> </span>    This function implements both Waxman models, using the `L` keyword
<span class="w"> </span>    argument.
<span class="gu">@@ -430,10 +555,10 @@ def waxman_graph(n, beta=0.4, alpha=0.1, L=None, domain=(0, 0, 1, 1),</span>
<span class="w"> </span>        Specifically, if $d$ is the function and $x$, $y$,
<span class="w"> </span>        and $z$ are vectors in the graph, then $d$ must satisfy

<span class="gd">-        1. $d(x, y) \\ge 0$,</span>
<span class="gi">+        1. $d(x, y) \ge 0$,</span>
<span class="w"> </span>        2. $d(x, y) = 0$ if and only if $x = y$,
<span class="w"> </span>        3. $d(x, y) = d(y, x)$,
<span class="gd">-        4. $d(x, z) \\le d(x, y) + d(y, z)$.</span>
<span class="gi">+        4. $d(x, z) \le d(x, y) + d(y, z)$.</span>

<span class="w"> </span>        If this argument is not specified, the Euclidean distance metric is
<span class="w"> </span>        used.
<span class="gu">@@ -478,20 +603,50 @@ def waxman_graph(n, beta=0.4, alpha=0.1, L=None, domain=(0, 0, 1, 1),</span>
<span class="w"> </span>    .. [1]  B. M. Waxman, *Routing of multipoint connections*.
<span class="w"> </span>       IEEE J. Select. Areas Commun. 6(9),(1988) 1617--1622.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(n)</span>
<span class="gi">+    (xmin, ymin, xmax, ymax) = domain</span>
<span class="gi">+    # Each node gets a uniformly random position in the given rectangle.</span>
<span class="gi">+    pos = {v: (seed.uniform(xmin, xmax), seed.uniform(ymin, ymax)) for v in G}</span>
<span class="gi">+    nx.set_node_attributes(G, pos, pos_name)</span>
<span class="gi">+    # If no distance metric is provided, use Euclidean distance.</span>
<span class="gi">+    if metric is None:</span>
<span class="gi">+        metric = math.dist</span>
<span class="gi">+    # If the maximum distance L is not specified (that is, we are in the</span>
<span class="gi">+    # Waxman-1 model), then find the maximum distance between any pair</span>
<span class="gi">+    # of nodes.</span>
<span class="gi">+    #</span>
<span class="gi">+    # In the Waxman-1 model, join nodes randomly based on distance. In</span>
<span class="gi">+    # the Waxman-2 model, join randomly based on random l.</span>
<span class="gi">+    if L is None:</span>
<span class="gi">+        L = max(metric(x, y) for x, y in combinations(pos.values(), 2))</span>
<span class="gi">+</span>
<span class="gi">+        def dist(u, v):</span>
<span class="gi">+            return metric(pos[u], pos[v])</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def dist(u, v):</span>
<span class="gi">+            return seed.random() * L</span>
<span class="gi">+</span>
<span class="gi">+    # `pair` is the pair of nodes to decide whether to join.</span>
<span class="gi">+    def should_join(pair):</span>
<span class="gi">+        return seed.random() &lt; beta * math.exp(-dist(*pair) / (alpha * L))</span>
<span class="gi">+</span>
<span class="gi">+    G.add_edges_from(filter(should_join, combinations(G, 2)))</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(5)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def navigable_small_world_graph(n, p=1, q=1, r=2, dim=2, seed=None):
<span class="gd">-    &quot;&quot;&quot;Returns a navigable small-world graph.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a navigable small-world graph.</span>

<span class="w"> </span>    A navigable small-world graph is a directed grid with additional long-range
<span class="w"> </span>    connections that are chosen randomly.

<span class="w"> </span>      [...] we begin with a set of nodes [...] that are identified with the set
<span class="gd">-      of lattice points in an $n \\times n$ square,</span>
<span class="gd">-      $\\{(i, j): i \\in \\{1, 2, \\ldots, n\\}, j \\in \\{1, 2, \\ldots, n\\}\\}$,</span>
<span class="gi">+      of lattice points in an $n \times n$ square,</span>
<span class="gi">+      $\{(i, j): i \in \{1, 2, \ldots, n\}, j \in \{1, 2, \ldots, n\}\}$,</span>
<span class="w"> </span>      and we define the *lattice distance* between two nodes $(i, j)$ and
<span class="w"> </span>      $(k, l)$ to be the number of &quot;lattice steps&quot; separating them:
<span class="w"> </span>      $d((i, j), (k, l)) = |k - i| + |l - j|$.
<span class="gu">@@ -529,14 +684,47 @@ def navigable_small_world_graph(n, p=1, q=1, r=2, dim=2, seed=None):</span>
<span class="w"> </span>    .. [1] J. Kleinberg. The small-world phenomenon: An algorithmic
<span class="w"> </span>       perspective. Proc. 32nd ACM Symposium on Theory of Computing, 2000.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if p &lt; 1:</span>
<span class="gi">+        raise nx.NetworkXException(&quot;p must be &gt;= 1&quot;)</span>
<span class="gi">+    if q &lt; 0:</span>
<span class="gi">+        raise nx.NetworkXException(&quot;q must be &gt;= 0&quot;)</span>
<span class="gi">+    if r &lt; 0:</span>
<span class="gi">+        raise nx.NetworkXException(&quot;r must be &gt;= 0&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.DiGraph()</span>
<span class="gi">+    nodes = list(product(range(n), repeat=dim))</span>
<span class="gi">+    for p1 in nodes:</span>
<span class="gi">+        probs = [0]</span>
<span class="gi">+        for p2 in nodes:</span>
<span class="gi">+            if p1 == p2:</span>
<span class="gi">+                continue</span>
<span class="gi">+            d = sum((abs(b - a) for a, b in zip(p1, p2)))</span>
<span class="gi">+            if d &lt;= p:</span>
<span class="gi">+                G.add_edge(p1, p2)</span>
<span class="gi">+            probs.append(d**-r)</span>
<span class="gi">+        cdf = list(accumulate(probs))</span>
<span class="gi">+        for _ in range(q):</span>
<span class="gi">+            target = nodes[bisect_left(cdf, seed.uniform(0, cdf[-1]))]</span>
<span class="gi">+            G.add_edge(p1, target)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(7)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def thresholded_random_geometric_graph(n, radius, theta, dim=2, pos=None,</span>
<span class="gd">-    weight=None, p=2, seed=None, *, pos_name=&#39;pos&#39;, weight_name=&#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Returns a thresholded random geometric graph in the unit cube.</span>
<span class="gi">+def thresholded_random_geometric_graph(</span>
<span class="gi">+    n,</span>
<span class="gi">+    radius,</span>
<span class="gi">+    theta,</span>
<span class="gi">+    dim=2,</span>
<span class="gi">+    pos=None,</span>
<span class="gi">+    weight=None,</span>
<span class="gi">+    p=2,</span>
<span class="gi">+    seed=None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    pos_name=&quot;pos&quot;,</span>
<span class="gi">+    weight_name=&quot;weight&quot;,</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a thresholded random geometric graph in the unit cube.</span>

<span class="w"> </span>    The thresholded random geometric graph [1] model places `n` nodes
<span class="w"> </span>    uniformly at random in the unit cube of dimensions `dim`. Each node
<span class="gu">@@ -620,7 +808,7 @@ def thresholded_random_geometric_graph(n, radius, theta, dim=2, pos=None,</span>
<span class="w"> </span>    (0, 0) and standard deviation 2

<span class="w"> </span>    If weights are not specified they are assigned to nodes by drawing randomly
<span class="gd">-    from the exponential distribution with rate parameter :math:`\\lambda=1`.</span>
<span class="gi">+    from the exponential distribution with rate parameter :math:`\lambda=1`.</span>
<span class="w"> </span>    To specify weights from a different distribution, use the `weight` keyword
<span class="w"> </span>    argument::

<span class="gu">@@ -638,27 +826,48 @@ def thresholded_random_geometric_graph(n, radius, theta, dim=2, pos=None,</span>
<span class="w"> </span>    .. [1] http://cole-maclean.github.io/blog/files/thesis.pdf

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(n)</span>
<span class="gi">+    G.name = f&quot;thresholded_random_geometric_graph({n}, {radius}, {theta}, {dim})&quot;</span>
<span class="gi">+    # If no weights are provided, choose them from an exponential</span>
<span class="gi">+    # distribution.</span>
<span class="gi">+    if weight is None:</span>
<span class="gi">+        weight = {v: seed.expovariate(1) for v in G}</span>
<span class="gi">+    # If no positions are provided, choose uniformly random vectors in</span>
<span class="gi">+    # Euclidean space of the specified dimension.</span>
<span class="gi">+    if pos is None:</span>
<span class="gi">+        pos = {v: [seed.random() for i in range(dim)] for v in G}</span>
<span class="gi">+    # If no distance metric is provided, use Euclidean distance.</span>
<span class="gi">+    nx.set_node_attributes(G, weight, weight_name)</span>
<span class="gi">+    nx.set_node_attributes(G, pos, pos_name)</span>
<span class="gi">+</span>
<span class="gi">+    edges = (</span>
<span class="gi">+        (u, v)</span>
<span class="gi">+        for u, v in _geometric_edges(G, radius, p, pos_name)</span>
<span class="gi">+        if weight[u] + weight[v] &gt;= theta</span>
<span class="gi">+    )</span>
<span class="gi">+    G.add_edges_from(edges)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(5)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def geometric_soft_configuration_graph(*, beta, n=None, gamma=None,</span>
<span class="gd">-    mean_degree=None, kappas=None, seed=None):</span>
<span class="gd">-    &quot;&quot;&quot;Returns a random graph from the geometric soft configuration model.</span>
<span class="gi">+def geometric_soft_configuration_graph(</span>
<span class="gi">+    *, beta, n=None, gamma=None, mean_degree=None, kappas=None, seed=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a random graph from the geometric soft configuration model.</span>

<span class="gd">-    The $\\mathbb{S}^1$ model [1]_ is the geometric soft configuration model</span>
<span class="gi">+    The $\mathbb{S}^1$ model [1]_ is the geometric soft configuration model</span>
<span class="w"> </span>    which is able to explain many fundamental features of real networks such as
<span class="w"> </span>    small-world property, heteregenous degree distributions, high level of
<span class="w"> </span>    clustering, and self-similarity.

<span class="w"> </span>    In the geometric soft configuration model, a node $i$ is assigned two hidden
<span class="gd">-    variables: a hidden degree $\\kappa_i$, quantifying its popularity, influence,</span>
<span class="gd">-    or importance, and an angular position $\\theta_i$ in a circle abstracting the</span>
<span class="gi">+    variables: a hidden degree $\kappa_i$, quantifying its popularity, influence,</span>
<span class="gi">+    or importance, and an angular position $\theta_i$ in a circle abstracting the</span>
<span class="w"> </span>    similarity space, where angular distances between nodes are a proxy for their
<span class="w"> </span>    similarity. Focusing on the angular position, this model is often called
<span class="gd">-    the $\\mathbb{S}^1$ model (a one-dimensional sphere). The circle&#39;s radius is</span>
<span class="gd">-    adjusted to $R = N/2\\pi$, where $N$ is the number of nodes, so that the density</span>
<span class="gi">+    the $\mathbb{S}^1$ model (a one-dimensional sphere). The circle&#39;s radius is</span>
<span class="gi">+    adjusted to $R = N/2\pi$, where $N$ is the number of nodes, so that the density</span>
<span class="w"> </span>    is set to 1 without loss of generality.

<span class="w"> </span>    The connection probability between any pair of nodes increases with
<span class="gu">@@ -666,40 +875,40 @@ def geometric_soft_configuration_graph(*, beta, n=None, gamma=None,</span>
<span class="w"> </span>    and decreases with the angular distance between the two nodes.
<span class="w"> </span>    Specifically, nodes $i$ and $j$ are connected with the probability

<span class="gd">-    $p_{ij} = \\frac{1}{1 + \\frac{d_{ij}^\\beta}{\\left(\\mu \\kappa_i \\kappa_j\\right)^{\\max(1, \\beta)}}}$</span>
<span class="gi">+    $p_{ij} = \frac{1}{1 + \frac{d_{ij}^\beta}{\left(\mu \kappa_i \kappa_j\right)^{\max(1, \beta)}}}$</span>

<span class="gd">-    where $d_{ij} = R\\Delta\\theta_{ij}$ is the arc length of the circle between</span>
<span class="gd">-    nodes $i$ and $j$ separated by an angular distance $\\Delta\\theta_{ij}$.</span>
<span class="gd">-    Parameters $\\mu$ and $\\beta$ (also called inverse temperature) control the</span>
<span class="gi">+    where $d_{ij} = R\Delta\theta_{ij}$ is the arc length of the circle between</span>
<span class="gi">+    nodes $i$ and $j$ separated by an angular distance $\Delta\theta_{ij}$.</span>
<span class="gi">+    Parameters $\mu$ and $\beta$ (also called inverse temperature) control the</span>
<span class="w"> </span>    average degree and the clustering coefficient, respectively.

<span class="w"> </span>    It can be shown [2]_ that the model undergoes a structural phase transition
<span class="gd">-    at $\\beta=1$ so that for $\\beta&lt;1$ networks are unclustered in the thermodynamic</span>
<span class="gd">-    limit (when $N\\to \\infty$) whereas for $\\beta&gt;1$ the ensemble generates</span>
<span class="gi">+    at $\beta=1$ so that for $\beta&lt;1$ networks are unclustered in the thermodynamic</span>
<span class="gi">+    limit (when $N\to \infty$) whereas for $\beta&gt;1$ the ensemble generates</span>
<span class="w"> </span>    networks with finite clustering coefficient.

<span class="gd">-    The $\\mathbb{S}^1$ model can be expressed as a purely geometric model</span>
<span class="gd">-    $\\mathbb{H}^2$ in the hyperbolic plane [3]_ by mapping the hidden degree of</span>
<span class="gi">+    The $\mathbb{S}^1$ model can be expressed as a purely geometric model</span>
<span class="gi">+    $\mathbb{H}^2$ in the hyperbolic plane [3]_ by mapping the hidden degree of</span>
<span class="w"> </span>    each node into a radial coordinate as

<span class="gd">-    $r_i = \\hat{R} - \\frac{2 \\max(1, \\beta)}{\\beta \\zeta} \\ln \\left(\\frac{\\kappa_i}{\\kappa_0}\\right)$</span>
<span class="gi">+    $r_i = \hat{R} - \frac{2 \max(1, \beta)}{\beta \zeta} \ln \left(\frac{\kappa_i}{\kappa_0}\right)$</span>

<span class="gd">-    where $\\hat{R}$ is the radius of the hyperbolic disk and $\\zeta$ is the curvature,</span>
<span class="gi">+    where $\hat{R}$ is the radius of the hyperbolic disk and $\zeta$ is the curvature,</span>

<span class="gd">-    $\\hat{R} = \\frac{2}{\\zeta} \\ln \\left(\\frac{N}{\\pi}\\right)</span>
<span class="gd">-    - \\frac{2\\max(1, \\beta)}{\\beta \\zeta} \\ln (\\mu \\kappa_0^2)$</span>
<span class="gi">+    $\hat{R} = \frac{2}{\zeta} \ln \left(\frac{N}{\pi}\right)</span>
<span class="gi">+    - \frac{2\max(1, \beta)}{\beta \zeta} \ln (\mu \kappa_0^2)$</span>

<span class="w"> </span>    The connection probability then reads

<span class="gd">-    $p_{ij} = \\frac{1}{1 + \\exp\\left({\\frac{\\beta\\zeta}{2} (x_{ij} - \\hat{R})}\\right)}$</span>
<span class="gi">+    $p_{ij} = \frac{1}{1 + \exp\left({\frac{\beta\zeta}{2} (x_{ij} - \hat{R})}\right)}$</span>

<span class="w"> </span>    where

<span class="gd">-    $x_{ij} = r_i + r_j + \\frac{2}{\\zeta} \\ln \\frac{\\Delta\\theta_{ij}}{2}$</span>
<span class="gi">+    $x_{ij} = r_i + r_j + \frac{2}{\zeta} \ln \frac{\Delta\theta_{ij}}{2}$</span>

<span class="w"> </span>    is a good approximation of the hyperbolic distance between two nodes separated
<span class="gd">-    by an angular distance $\\Delta\\theta_{ij}$ with radial coordinates $r_i$ and $r_j$.</span>
<span class="gd">-    For $\\beta &gt; 1$, the curvature $\\zeta = 1$, for $\\beta &lt; 1$, $\\zeta = \\beta^{-1}$.</span>
<span class="gi">+    by an angular distance $\Delta\theta_{ij}$ with radial coordinates $r_i$ and $r_j$.</span>
<span class="gi">+    For $\beta &gt; 1$, the curvature $\zeta = 1$, for $\beta &lt; 1$, $\zeta = \beta^{-1}$.</span>


<span class="w"> </span>    Parameters
<span class="gu">@@ -735,7 +944,7 @@ def geometric_soft_configuration_graph(*, beta, n=None, gamma=None,</span>

<span class="w"> </span>        - ``kappa`` that represents the hidden degree.

<span class="gd">-        - ``theta`` the position in the similarity space ($\\mathbb{S}^1$) which is</span>
<span class="gi">+        - ``theta`` the position in the similarity space ($\mathbb{S}^1$) which is</span>
<span class="w"> </span>          also the angular position in the hyperbolic plane.

<span class="w"> </span>        - ``radius`` the radial position in the hyperbolic plane
<span class="gu">@@ -748,7 +957,7 @@ def geometric_soft_configuration_graph(*, beta, n=None, gamma=None,</span>

<span class="w"> </span>    &gt;&gt;&gt; G = nx.geometric_soft_configuration_graph(beta=1.5, n=100, gamma=2.7, mean_degree=5)

<span class="gd">-    Create a geometric soft configuration graph with 100 nodes. The $\\beta$ parameter</span>
<span class="gi">+    Create a geometric soft configuration graph with 100 nodes. The $\beta$ parameter</span>
<span class="w"> </span>    is set to 1.5 and the exponent of the powerlaw distribution of the hidden
<span class="w"> </span>    degrees is 2.7 with mean value of 5.

<span class="gu">@@ -757,8 +966,8 @@ def geometric_soft_configuration_graph(*, beta, n=None, gamma=None,</span>
<span class="w"> </span>    &gt;&gt;&gt; kappas = {i: 10 for i in range(100)}
<span class="w"> </span>    &gt;&gt;&gt; G = nx.geometric_soft_configuration_graph(beta=2.5, kappas=kappas)

<span class="gd">-    Create a geometric soft configuration graph with 100 nodes. The $\\beta$ parameter</span>
<span class="gd">-    is set to 2.5 and all nodes with hidden degree $\\kappa=10$.</span>
<span class="gi">+    Create a geometric soft configuration graph with 100 nodes. The $\beta$ parameter</span>
<span class="gi">+    is set to 2.5 and all nodes with hidden degree $\kappa=10$.</span>


<span class="w"> </span>    References
<span class="gu">@@ -773,4 +982,66 @@ def geometric_soft_configuration_graph(*, beta, n=None, gamma=None,</span>
<span class="w"> </span>       Hyperbolic geometry of complex networks. Physical Review E, 82(3), 036106.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if beta &lt;= 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;The parameter beta cannot be smaller or equal to 0.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if kappas is not None:</span>
<span class="gi">+        if not all((n is None, gamma is None, mean_degree is None)):</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;When kappas is input, n, gamma and mean_degree must not be.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        n = len(kappas)</span>
<span class="gi">+        mean_degree = sum(kappas) / len(kappas)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if any((n is None, gamma is None, mean_degree is None)):</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                &quot;Please provide either kappas, or all 3 of: n, gamma and mean_degree.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Generate `n` hidden degrees from a powerlaw distribution</span>
<span class="gi">+        # with given exponent `gamma` and mean value `mean_degree`</span>
<span class="gi">+        gam_ratio = (gamma - 2) / (gamma - 1)</span>
<span class="gi">+        kappa_0 = mean_degree * gam_ratio * (1 - 1 / n) / (1 - 1 / n**gam_ratio)</span>
<span class="gi">+        base = 1 - 1 / n</span>
<span class="gi">+        power = 1 / (1 - gamma)</span>
<span class="gi">+        kappas = {i: kappa_0 * (1 - seed.random() * base) ** power for i in range(n)}</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    R = n / (2 * math.pi)</span>
<span class="gi">+</span>
<span class="gi">+    # Approximate values for mu in the thermodynamic limit (when n -&gt; infinity)</span>
<span class="gi">+    if beta &gt; 1:</span>
<span class="gi">+        mu = beta * math.sin(math.pi / beta) / (2 * math.pi * mean_degree)</span>
<span class="gi">+    elif beta == 1:</span>
<span class="gi">+        mu = 1 / (2 * mean_degree * math.log(n))</span>
<span class="gi">+    else:</span>
<span class="gi">+        mu = (1 - beta) / (2**beta * mean_degree * n ** (1 - beta))</span>
<span class="gi">+</span>
<span class="gi">+    # Generate random positions on a circle</span>
<span class="gi">+    thetas = {k: seed.uniform(0, 2 * math.pi) for k in kappas}</span>
<span class="gi">+</span>
<span class="gi">+    for u in kappas:</span>
<span class="gi">+        for v in list(G):</span>
<span class="gi">+            angle = math.pi - math.fabs(math.pi - math.fabs(thetas[u] - thetas[v]))</span>
<span class="gi">+            dij = math.pow(R * angle, beta)</span>
<span class="gi">+            mu_kappas = math.pow(mu * kappas[u] * kappas[v], max(1, beta))</span>
<span class="gi">+            p_ij = 1 / (1 + dij / mu_kappas)</span>
<span class="gi">+</span>
<span class="gi">+            # Create an edge with a certain connection probability</span>
<span class="gi">+            if seed.random() &lt; p_ij:</span>
<span class="gi">+                G.add_edge(u, v)</span>
<span class="gi">+        G.add_node(u)</span>
<span class="gi">+</span>
<span class="gi">+    nx.set_node_attributes(G, thetas, &quot;theta&quot;)</span>
<span class="gi">+    nx.set_node_attributes(G, kappas, &quot;kappa&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Map hidden degrees into the radial coordiantes</span>
<span class="gi">+    zeta = 1 if beta &gt; 1 else 1 / beta</span>
<span class="gi">+    kappa_min = min(kappas.values())</span>
<span class="gi">+    R_c = 2 * max(1, beta) / (beta * zeta)</span>
<span class="gi">+    R_hat = (2 / zeta) * math.log(n / math.pi) - R_c * math.log(mu * kappa_min)</span>
<span class="gi">+    radii = {node: R_hat - R_c * math.log(kappa) for node, kappa in kappas.items()}</span>
<span class="gi">+    nx.set_node_attributes(G, radii, &quot;radius&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/harary_graph.py b/networkx/generators/harary_graph.py</span>
<span class="gh">index f7a527567..591587d3a 100644</span>
<span class="gd">--- a/networkx/generators/harary_graph.py</span>
<span class="gi">+++ b/networkx/generators/harary_graph.py</span>
<span class="gu">@@ -14,9 +14,11 @@ References</span>
<span class="w"> </span>       Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="gd">-__all__ = [&#39;hnm_harary_graph&#39;, &#39;hkn_harary_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;hnm_harary_graph&quot;, &quot;hkn_harary_graph&quot;]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -63,7 +65,52 @@ def hnm_harary_graph(n, m, create_using=None):</span>
<span class="w"> </span>    .. [2] Harary, F. &quot;The Maximum Connectivity of a Graph.&quot;
<span class="w"> </span>       Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if n &lt; 1:</span>
<span class="gi">+        raise NetworkXError(&quot;The number of nodes must be &gt;= 1!&quot;)</span>
<span class="gi">+    if m &lt; n - 1:</span>
<span class="gi">+        raise NetworkXError(&quot;The number of edges must be &gt;= n - 1 !&quot;)</span>
<span class="gi">+    if m &gt; n * (n - 1) // 2:</span>
<span class="gi">+        raise NetworkXError(&quot;The number of edges must be &lt;= n(n-1)/2&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Construct an empty graph with n nodes first</span>
<span class="gi">+    H = nx.empty_graph(n, create_using)</span>
<span class="gi">+    # Get the floor of average node degree</span>
<span class="gi">+    d = 2 * m // n</span>
<span class="gi">+</span>
<span class="gi">+    # Test the parity of n and d</span>
<span class="gi">+    if (n % 2 == 0) or (d % 2 == 0):</span>
<span class="gi">+        # Start with a regular graph of d degrees</span>
<span class="gi">+        offset = d // 2</span>
<span class="gi">+        for i in range(n):</span>
<span class="gi">+            for j in range(1, offset + 1):</span>
<span class="gi">+                H.add_edge(i, (i - j) % n)</span>
<span class="gi">+                H.add_edge(i, (i + j) % n)</span>
<span class="gi">+        if d &amp; 1:</span>
<span class="gi">+            # in case d is odd; n must be even in this case</span>
<span class="gi">+            half = n // 2</span>
<span class="gi">+            for i in range(half):</span>
<span class="gi">+                # add edges diagonally</span>
<span class="gi">+                H.add_edge(i, i + half)</span>
<span class="gi">+        # Get the remainder of 2*m modulo n</span>
<span class="gi">+        r = 2 * m % n</span>
<span class="gi">+        if r &gt; 0:</span>
<span class="gi">+            # add remaining edges at offset+1</span>
<span class="gi">+            for i in range(r // 2):</span>
<span class="gi">+                H.add_edge(i, i + offset + 1)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Start with a regular graph of (d - 1) degrees</span>
<span class="gi">+        offset = (d - 1) // 2</span>
<span class="gi">+        for i in range(n):</span>
<span class="gi">+            for j in range(1, offset + 1):</span>
<span class="gi">+                H.add_edge(i, (i - j) % n)</span>
<span class="gi">+                H.add_edge(i, (i + j) % n)</span>
<span class="gi">+        half = n // 2</span>
<span class="gi">+        for i in range(m - n * offset):</span>
<span class="gi">+            # add the remaining m - n*offset edges between i and i+half</span>
<span class="gi">+            H.add_edge(i, (i + half) % n)</span>
<span class="gi">+</span>
<span class="gi">+    return H</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -109,4 +156,44 @@ def hkn_harary_graph(k, n, create_using=None):</span>
<span class="w"> </span>    .. [2] Harary, F. &quot;The Maximum Connectivity of a Graph.&quot;
<span class="w"> </span>      Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if k &lt; 1:</span>
<span class="gi">+        raise NetworkXError(&quot;The node connectivity must be &gt;= 1!&quot;)</span>
<span class="gi">+    if n &lt; k + 1:</span>
<span class="gi">+        raise NetworkXError(&quot;The number of nodes must be &gt;= k+1 !&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # in case of connectivity 1, simply return the path graph</span>
<span class="gi">+    if k == 1:</span>
<span class="gi">+        H = nx.path_graph(n, create_using)</span>
<span class="gi">+        return H</span>
<span class="gi">+</span>
<span class="gi">+    # Construct an empty graph with n nodes first</span>
<span class="gi">+    H = nx.empty_graph(n, create_using)</span>
<span class="gi">+</span>
<span class="gi">+    # Test the parity of k and n</span>
<span class="gi">+    if (k % 2 == 0) or (n % 2 == 0):</span>
<span class="gi">+        # Construct a regular graph with k degrees</span>
<span class="gi">+        offset = k // 2</span>
<span class="gi">+        for i in range(n):</span>
<span class="gi">+            for j in range(1, offset + 1):</span>
<span class="gi">+                H.add_edge(i, (i - j) % n)</span>
<span class="gi">+                H.add_edge(i, (i + j) % n)</span>
<span class="gi">+        if k &amp; 1:</span>
<span class="gi">+            # odd degree; n must be even in this case</span>
<span class="gi">+            half = n // 2</span>
<span class="gi">+            for i in range(half):</span>
<span class="gi">+                # add edges diagonally</span>
<span class="gi">+                H.add_edge(i, i + half)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Construct a regular graph with (k - 1) degrees</span>
<span class="gi">+        offset = (k - 1) // 2</span>
<span class="gi">+        for i in range(n):</span>
<span class="gi">+            for j in range(1, offset + 1):</span>
<span class="gi">+                H.add_edge(i, (i - j) % n)</span>
<span class="gi">+                H.add_edge(i, (i + j) % n)</span>
<span class="gi">+        half = n // 2</span>
<span class="gi">+        for i in range(half + 1):</span>
<span class="gi">+            # add half+1 edges between i and i+half</span>
<span class="gi">+            H.add_edge(i, (i + half) % n)</span>
<span class="gi">+</span>
<span class="gi">+    return H</span>
<span class="gh">diff --git a/networkx/generators/internet_as_graphs.py b/networkx/generators/internet_as_graphs.py</span>
<span class="gh">index 00d4a0144..449d54376 100644</span>
<span class="gd">--- a/networkx/generators/internet_as_graphs.py</span>
<span class="gi">+++ b/networkx/generators/internet_as_graphs.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Generates graphs resembling the Internet Autonomous System network&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;random_internet_as_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;random_internet_as_graph&quot;]</span>


<span class="w"> </span>def uniform_int_from_avg(a, m, seed):
<span class="gu">@@ -17,7 +19,18 @@ def uniform_int_from_avg(a, m, seed):</span>
<span class="w"> </span>    X = X1 + X2; X1~U(a,floor(b)), X2~B(p)
<span class="w"> </span>    E[X] = E[X1] + E[X2] = (floor(b)+a)/2 + (b-floor(b))/2 = (b+a)/2 = m
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    from math import floor</span>
<span class="gi">+</span>
<span class="gi">+    assert m &gt;= a</span>
<span class="gi">+    b = 2 * m - a</span>
<span class="gi">+    p = (b - floor(b)) / 2</span>
<span class="gi">+    X1 = round(seed.random() * (floor(b) - a) + a)</span>
<span class="gi">+    if seed.random() &lt; p:</span>
<span class="gi">+        X2 = 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        X2 = 0</span>
<span class="gi">+    return X1 + X2</span>


<span class="w"> </span>def choose_pref_attach(degs, seed):
<span class="gu">@@ -38,7 +51,21 @@ def choose_pref_attach(degs, seed):</span>
<span class="w"> </span>    v: object
<span class="w"> </span>        A key of degs or None if degs is empty
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if len(degs) == 0:</span>
<span class="gi">+        return None</span>
<span class="gi">+    s = sum(degs.values())</span>
<span class="gi">+    if s == 0:</span>
<span class="gi">+        return seed.choice(list(degs.keys()))</span>
<span class="gi">+    v = seed.random() * s</span>
<span class="gi">+</span>
<span class="gi">+    nodes = list(degs.keys())</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    acc = degs[nodes[i]]</span>
<span class="gi">+    while v &gt; acc:</span>
<span class="gi">+        i += 1</span>
<span class="gi">+        acc += degs[nodes[i]]</span>
<span class="gi">+    return nodes[i]</span>


<span class="w"> </span>class AS_graph_generator:
<span class="gu">@@ -65,20 +92,24 @@ class AS_graph_generator:</span>
<span class="w"> </span>        BGP: The Role of Topology Growth,&quot; in IEEE Journal on Selected Areas
<span class="w"> </span>        in Communications, vol. 28, no. 8, pp. 1250-1261, October 2010.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.seed = seed
<span class="gd">-        self.n_t = min(n, round(self.seed.random() * 2 + 4))</span>
<span class="gd">-        self.n_m = round(0.15 * n)</span>
<span class="gd">-        self.n_cp = round(0.05 * n)</span>
<span class="gd">-        self.n_c = max(0, n - self.n_t - self.n_m - self.n_cp)</span>
<span class="gd">-        self.d_m = 2 + 2.5 * n / 10000</span>
<span class="gd">-        self.d_cp = 2 + 1.5 * n / 10000</span>
<span class="gd">-        self.d_c = 1 + 5 * n / 100000</span>
<span class="gd">-        self.p_m_m = 1 + 2 * n / 10000</span>
<span class="gd">-        self.p_cp_m = 0.2 + 2 * n / 10000</span>
<span class="gd">-        self.p_cp_cp = 0.05 + 2 * n / 100000</span>
<span class="gd">-        self.t_m = 0.375</span>
<span class="gd">-        self.t_cp = 0.375</span>
<span class="gd">-        self.t_c = 0.125</span>
<span class="gi">+        self.n_t = min(n, round(self.seed.random() * 2 + 4))  # num of T nodes</span>
<span class="gi">+        self.n_m = round(0.15 * n)  # number of M nodes</span>
<span class="gi">+        self.n_cp = round(0.05 * n)  # number of CP nodes</span>
<span class="gi">+        self.n_c = max(0, n - self.n_t - self.n_m - self.n_cp)  # number of C nodes</span>
<span class="gi">+</span>
<span class="gi">+        self.d_m = 2 + (2.5 * n) / 10000  # average multihoming degree for M nodes</span>
<span class="gi">+        self.d_cp = 2 + (1.5 * n) / 10000  # avg multihoming degree for CP nodes</span>
<span class="gi">+        self.d_c = 1 + (5 * n) / 100000  # average multihoming degree for C nodes</span>
<span class="gi">+</span>
<span class="gi">+        self.p_m_m = 1 + (2 * n) / 10000  # avg num of peer edges between M and M</span>
<span class="gi">+        self.p_cp_m = 0.2 + (2 * n) / 10000  # avg num of peer edges between CP, M</span>
<span class="gi">+        self.p_cp_cp = 0.05 + (2 * n) / 100000  # avg num of peer edges btwn CP, CP</span>
<span class="gi">+</span>
<span class="gi">+        self.t_m = 0.375  # probability M&#39;s provider is T</span>
<span class="gi">+        self.t_cp = 0.375  # probability CP&#39;s provider is T</span>
<span class="gi">+        self.t_c = 0.125  # probability C&#39;s provider is T</span>

<span class="w"> </span>    def t_graph(self):
<span class="w"> </span>        &quot;&quot;&quot;Generates the core mesh network of tier one nodes of a AS graph.
<span class="gu">@@ -88,7 +119,25 @@ class AS_graph_generator:</span>
<span class="w"> </span>        G: Networkx Graph
<span class="w"> </span>            Core network
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.G = nx.Graph()</span>
<span class="gi">+        for i in range(self.n_t):</span>
<span class="gi">+            self.G.add_node(i, type=&quot;T&quot;)</span>
<span class="gi">+            for r in self.regions:</span>
<span class="gi">+                self.regions[r].add(i)</span>
<span class="gi">+            for j in self.G.nodes():</span>
<span class="gi">+                if i != j:</span>
<span class="gi">+                    self.add_edge(i, j, &quot;peer&quot;)</span>
<span class="gi">+            self.customers[i] = set()</span>
<span class="gi">+            self.providers[i] = set()</span>
<span class="gi">+        return self.G</span>
<span class="gi">+</span>
<span class="gi">+    def add_edge(self, i, j, kind):</span>
<span class="gi">+        if kind == &quot;transit&quot;:</span>
<span class="gi">+            customer = str(i)</span>
<span class="gi">+        else:</span>
<span class="gi">+            customer = &quot;none&quot;</span>
<span class="gi">+        self.G.add_edge(i, j, type=kind, customer=customer)</span>

<span class="w"> </span>    def choose_peer_pref_attach(self, node_list):
<span class="w"> </span>        &quot;&quot;&quot;Pick a node with a probability weighted by its peer degree.
<span class="gu">@@ -96,7 +145,11 @@ class AS_graph_generator:</span>
<span class="w"> </span>        Pick a node from node_list with preferential attachment
<span class="w"> </span>        computed only on their peer degree
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        d = {}</span>
<span class="gi">+        for n in node_list:</span>
<span class="gi">+            d[n] = self.G.nodes[n][&quot;peers&quot;]</span>
<span class="gi">+        return choose_pref_attach(d, self.seed)</span>

<span class="w"> </span>    def choose_node_pref_attach(self, node_list):
<span class="w"> </span>        &quot;&quot;&quot;Pick a node with a probability weighted by its degree.
<span class="gu">@@ -104,11 +157,18 @@ class AS_graph_generator:</span>
<span class="w"> </span>        Pick a node from node_list with preferential attachment
<span class="w"> </span>        computed on their degree
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        degs = dict(self.G.degree(node_list))</span>
<span class="gi">+        return choose_pref_attach(degs, self.seed)</span>

<span class="w"> </span>    def add_customer(self, i, j):
<span class="w"> </span>        &quot;&quot;&quot;Keep the dictionaries &#39;customers&#39; and &#39;providers&#39; consistent.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.customers[j].add(i)</span>
<span class="gi">+        self.providers[i].add(j)</span>
<span class="gi">+        for z in self.providers[j]:</span>
<span class="gi">+            self.customers[z].add(i)</span>
<span class="gi">+            self.providers[i].add(z)</span>

<span class="w"> </span>    def add_node(self, i, kind, reg2prob, avg_deg, t_edge_prob):
<span class="w"> </span>        &quot;&quot;&quot;Add a node and its customer transit edges to the graph.
<span class="gu">@@ -133,7 +193,41 @@ class AS_graph_generator:</span>
<span class="w"> </span>        i: object
<span class="w"> </span>            Identifier of the new node
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        regs = 1  # regions in which node resides</span>
<span class="gi">+        if self.seed.random() &lt; reg2prob:  # node is in two regions</span>
<span class="gi">+            regs = 2</span>
<span class="gi">+        node_options = set()</span>
<span class="gi">+</span>
<span class="gi">+        self.G.add_node(i, type=kind, peers=0)</span>
<span class="gi">+        self.customers[i] = set()</span>
<span class="gi">+        self.providers[i] = set()</span>
<span class="gi">+        self.nodes[kind].add(i)</span>
<span class="gi">+        for r in self.seed.sample(list(self.regions), regs):</span>
<span class="gi">+            node_options = node_options.union(self.regions[r])</span>
<span class="gi">+            self.regions[r].add(i)</span>
<span class="gi">+</span>
<span class="gi">+        edge_num = uniform_int_from_avg(1, avg_deg, self.seed)</span>
<span class="gi">+</span>
<span class="gi">+        t_options = node_options.intersection(self.nodes[&quot;T&quot;])</span>
<span class="gi">+        m_options = node_options.intersection(self.nodes[&quot;M&quot;])</span>
<span class="gi">+        if i in m_options:</span>
<span class="gi">+            m_options.remove(i)</span>
<span class="gi">+        d = 0</span>
<span class="gi">+        while d &lt; edge_num and (len(t_options) &gt; 0 or len(m_options) &gt; 0):</span>
<span class="gi">+            if len(m_options) == 0 or (</span>
<span class="gi">+                len(t_options) &gt; 0 and self.seed.random() &lt; t_edge_prob</span>
<span class="gi">+            ):  # add edge to a T node</span>
<span class="gi">+                j = self.choose_node_pref_attach(t_options)</span>
<span class="gi">+                t_options.remove(j)</span>
<span class="gi">+            else:</span>
<span class="gi">+                j = self.choose_node_pref_attach(m_options)</span>
<span class="gi">+                m_options.remove(j)</span>
<span class="gi">+            self.add_edge(i, j, &quot;transit&quot;)</span>
<span class="gi">+            self.add_customer(i, j)</span>
<span class="gi">+            d += 1</span>
<span class="gi">+</span>
<span class="gi">+        return i</span>

<span class="w"> </span>    def add_m_peering_link(self, m, to_kind):
<span class="w"> </span>        &quot;&quot;&quot;Add a peering link between two middle tier (M) nodes.
<span class="gu">@@ -152,7 +246,28 @@ class AS_graph_generator:</span>
<span class="w"> </span>        -------
<span class="w"> </span>        success: boolean
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # candidates are of type &#39;M&#39; and are not customers of m</span>
<span class="gi">+        node_options = self.nodes[&quot;M&quot;].difference(self.customers[m])</span>
<span class="gi">+        # candidates are not providers of m</span>
<span class="gi">+        node_options = node_options.difference(self.providers[m])</span>
<span class="gi">+        # remove self</span>
<span class="gi">+        if m in node_options:</span>
<span class="gi">+            node_options.remove(m)</span>
<span class="gi">+</span>
<span class="gi">+        # remove candidates we are already connected to</span>
<span class="gi">+        for j in self.G.neighbors(m):</span>
<span class="gi">+            if j in node_options:</span>
<span class="gi">+                node_options.remove(j)</span>
<span class="gi">+</span>
<span class="gi">+        if len(node_options) &gt; 0:</span>
<span class="gi">+            j = self.choose_peer_pref_attach(node_options)</span>
<span class="gi">+            self.add_edge(m, j, &quot;peer&quot;)</span>
<span class="gi">+            self.G.nodes[m][&quot;peers&quot;] += 1</span>
<span class="gi">+            self.G.nodes[j][&quot;peers&quot;] += 1</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    def add_cp_peering_link(self, cp, to_kind):
<span class="w"> </span>        &quot;&quot;&quot;Add a peering link to a content provider (CP) node.
<span class="gu">@@ -171,7 +286,35 @@ class AS_graph_generator:</span>
<span class="w"> </span>        -------
<span class="w"> </span>        success: boolean
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        node_options = set()</span>
<span class="gi">+        for r in self.regions:  # options include nodes in the same region(s)</span>
<span class="gi">+            if cp in self.regions[r]:</span>
<span class="gi">+                node_options = node_options.union(self.regions[r])</span>
<span class="gi">+</span>
<span class="gi">+        # options are restricted to the indicated kind (&#39;M&#39; or &#39;CP&#39;)</span>
<span class="gi">+        node_options = self.nodes[to_kind].intersection(node_options)</span>
<span class="gi">+</span>
<span class="gi">+        # remove self</span>
<span class="gi">+        if cp in node_options:</span>
<span class="gi">+            node_options.remove(cp)</span>
<span class="gi">+</span>
<span class="gi">+        # remove nodes that are cp&#39;s providers</span>
<span class="gi">+        node_options = node_options.difference(self.providers[cp])</span>
<span class="gi">+</span>
<span class="gi">+        # remove nodes we are already connected to</span>
<span class="gi">+        for j in self.G.neighbors(cp):</span>
<span class="gi">+            if j in node_options:</span>
<span class="gi">+                node_options.remove(j)</span>
<span class="gi">+</span>
<span class="gi">+        if len(node_options) &gt; 0:</span>
<span class="gi">+            j = self.seed.sample(list(node_options), 1)[0]</span>
<span class="gi">+            self.add_edge(cp, j, &quot;peer&quot;)</span>
<span class="gi">+            self.G.nodes[cp][&quot;peers&quot;] += 1</span>
<span class="gi">+            self.G.nodes[j][&quot;peers&quot;] += 1</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False</span>

<span class="w"> </span>    def graph_regions(self, rn):
<span class="w"> </span>        &quot;&quot;&quot;Initializes AS network regions.
<span class="gu">@@ -181,11 +324,28 @@ class AS_graph_generator:</span>
<span class="w"> </span>        rn: integer
<span class="w"> </span>            Number of regions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.regions = {}</span>
<span class="gi">+        for i in range(rn):</span>
<span class="gi">+            self.regions[&quot;REG&quot; + str(i)] = set()</span>

<span class="w"> </span>    def add_peering_links(self, from_kind, to_kind):
<span class="w"> </span>        &quot;&quot;&quot;Utility function to add peering links among node groups.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        peer_link_method = None</span>
<span class="gi">+        if from_kind == &quot;M&quot;:</span>
<span class="gi">+            peer_link_method = self.add_m_peering_link</span>
<span class="gi">+            m = self.p_m_m</span>
<span class="gi">+        if from_kind == &quot;CP&quot;:</span>
<span class="gi">+            peer_link_method = self.add_cp_peering_link</span>
<span class="gi">+            if to_kind == &quot;M&quot;:</span>
<span class="gi">+                m = self.p_cp_m</span>
<span class="gi">+            else:</span>
<span class="gi">+                m = self.p_cp_cp</span>
<span class="gi">+</span>
<span class="gi">+        for i in self.nodes[from_kind]:</span>
<span class="gi">+            num = uniform_int_from_avg(0, m, self.seed)</span>
<span class="gi">+            for _ in range(num):</span>
<span class="gi">+                peer_link_method(i, to_kind)</span>

<span class="w"> </span>    def generate(self):
<span class="w"> </span>        &quot;&quot;&quot;Generates a random AS network graph as described in [1].
<span class="gu">@@ -209,7 +369,31 @@ class AS_graph_generator:</span>
<span class="w"> </span>        BGP: The Role of Topology Growth,&quot; in IEEE Journal on Selected Areas
<span class="w"> </span>        in Communications, vol. 28, no. 8, pp. 1250-1261, October 2010.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.graph_regions(5)</span>
<span class="gi">+        self.customers = {}</span>
<span class="gi">+        self.providers = {}</span>
<span class="gi">+        self.nodes = {&quot;T&quot;: set(), &quot;M&quot;: set(), &quot;CP&quot;: set(), &quot;C&quot;: set()}</span>
<span class="gi">+</span>
<span class="gi">+        self.t_graph()</span>
<span class="gi">+        self.nodes[&quot;T&quot;] = set(self.G.nodes())</span>
<span class="gi">+</span>
<span class="gi">+        i = len(self.nodes[&quot;T&quot;])</span>
<span class="gi">+        for _ in range(self.n_m):</span>
<span class="gi">+            self.nodes[&quot;M&quot;].add(self.add_node(i, &quot;M&quot;, 0.2, self.d_m, self.t_m))</span>
<span class="gi">+            i += 1</span>
<span class="gi">+        for _ in range(self.n_cp):</span>
<span class="gi">+            self.nodes[&quot;CP&quot;].add(self.add_node(i, &quot;CP&quot;, 0.05, self.d_cp, self.t_cp))</span>
<span class="gi">+            i += 1</span>
<span class="gi">+        for _ in range(self.n_c):</span>
<span class="gi">+            self.nodes[&quot;C&quot;].add(self.add_node(i, &quot;C&quot;, 0, self.d_c, self.t_c))</span>
<span class="gi">+            i += 1</span>
<span class="gi">+</span>
<span class="gi">+        self.add_peering_links(&quot;M&quot;, &quot;M&quot;)</span>
<span class="gi">+        self.add_peering_links(&quot;CP&quot;, &quot;M&quot;)</span>
<span class="gi">+        self.add_peering_links(&quot;CP&quot;, &quot;CP&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return self.G</span>


<span class="w"> </span>@py_random_state(1)
<span class="gu">@@ -251,4 +435,7 @@ def random_internet_as_graph(n, seed=None):</span>
<span class="w"> </span>       BGP: The Role of Topology Growth,&quot; in IEEE Journal on Selected Areas
<span class="w"> </span>       in Communications, vol. 28, no. 8, pp. 1250-1261, October 2010.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    GG = AS_graph_generator(n, seed)</span>
<span class="gi">+    G = GG.generate()</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/intersection.py b/networkx/generators/intersection.py</span>
<span class="gh">index 9cab57581..2ed3a5fa3 100644</span>
<span class="gd">--- a/networkx/generators/intersection.py</span>
<span class="gi">+++ b/networkx/generators/intersection.py</span>
<span class="gu">@@ -3,8 +3,12 @@ Generators for random intersection graphs.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;uniform_random_intersection_graph&#39;,</span>
<span class="gd">-    &#39;k_random_intersection_graph&#39;, &#39;general_random_intersection_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;uniform_random_intersection_graph&quot;,</span>
<span class="gi">+    &quot;k_random_intersection_graph&quot;,</span>
<span class="gi">+    &quot;general_random_intersection_graph&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -37,7 +41,10 @@ def uniform_random_intersection_graph(n, m, p, seed=None):</span>
<span class="w"> </span>       An equivalence theorem relating the evolution of the g(n, m, p)
<span class="w"> </span>       and g(n, p) models. Random Struct. Algorithms 16, 2 (2000), 156–176.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from networkx.algorithms import bipartite</span>
<span class="gi">+</span>
<span class="gi">+    G = bipartite.random_graph(n, m, p, seed)</span>
<span class="gi">+    return nx.projected_graph(G, range(n))</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -68,7 +75,12 @@ def k_random_intersection_graph(n, m, k, seed=None):</span>
<span class="w"> </span>       Two models of random intersection graphs and their applications.
<span class="w"> </span>       Electronic Notes in Discrete Mathematics 10 (2001), 129--132.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(n + m)</span>
<span class="gi">+    mset = range(n, n + m)</span>
<span class="gi">+    for v in range(n):</span>
<span class="gi">+        targets = seed.sample(mset, k)</span>
<span class="gi">+        G.add_edges_from(zip([v] * len(targets), targets))</span>
<span class="gi">+    return nx.projected_graph(G, range(n))</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -101,4 +113,12 @@ def general_random_intersection_graph(n, m, p, seed=None):</span>
<span class="w"> </span>       J. Karhum¨aki, A. Lepist¨o, and D. Sannella, Eds., vol. 3142
<span class="w"> </span>       of Lecture Notes in Computer Science, Springer, pp. 1029–1040.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(p) != m:</span>
<span class="gi">+        raise ValueError(&quot;Probability list p must have m elements.&quot;)</span>
<span class="gi">+    G = nx.empty_graph(n + m)</span>
<span class="gi">+    mset = range(n, n + m)</span>
<span class="gi">+    for u in range(n):</span>
<span class="gi">+        for v, q in zip(mset, p):</span>
<span class="gi">+            if seed.random() &lt; q:</span>
<span class="gi">+                G.add_edge(u, v)</span>
<span class="gi">+    return nx.projected_graph(G, range(n))</span>
<span class="gh">diff --git a/networkx/generators/interval_graph.py b/networkx/generators/interval_graph.py</span>
<span class="gh">index 19bfd1716..2a3d76090 100644</span>
<span class="gd">--- a/networkx/generators/interval_graph.py</span>
<span class="gi">+++ b/networkx/generators/interval_graph.py</span>
<span class="gu">@@ -2,8 +2,10 @@</span>
<span class="w"> </span>Generators for interval graph.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections.abc import Sequence
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;interval_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;interval_graph&quot;]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -43,4 +45,25 @@ def interval_graph(intervals):</span>
<span class="w"> </span>        if `intervals` contains an interval such that min1 &gt; max1
<span class="w"> </span>        where min1,max1 = interval
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    intervals = list(intervals)</span>
<span class="gi">+    for interval in intervals:</span>
<span class="gi">+        if not (isinstance(interval, Sequence) and len(interval) == 2):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Each interval must have length 2, and be a &quot;</span>
<span class="gi">+                &quot;collections.abc.Sequence such as tuple or list.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        if interval[0] &gt; interval[1]:</span>
<span class="gi">+            raise ValueError(f&quot;Interval must have lower value first. Got {interval}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    graph = nx.Graph()</span>
<span class="gi">+</span>
<span class="gi">+    tupled_intervals = [tuple(interval) for interval in intervals]</span>
<span class="gi">+    graph.add_nodes_from(tupled_intervals)</span>
<span class="gi">+</span>
<span class="gi">+    while tupled_intervals:</span>
<span class="gi">+        min1, max1 = interval1 = tupled_intervals.pop()</span>
<span class="gi">+        for interval2 in tupled_intervals:</span>
<span class="gi">+            min2, max2 = interval2</span>
<span class="gi">+            if max1 &gt;= min2 and max2 &gt;= min1:</span>
<span class="gi">+                graph.add_edge(interval1, interval2)</span>
<span class="gi">+    return graph</span>
<span class="gh">diff --git a/networkx/generators/joint_degree_seq.py b/networkx/generators/joint_degree_seq.py</span>
<span class="gh">index 28dd40509..c426df944 100644</span>
<span class="gd">--- a/networkx/generators/joint_degree_seq.py</span>
<span class="gi">+++ b/networkx/generators/joint_degree_seq.py</span>
<span class="gu">@@ -1,8 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Generate graphs with a given joint degree and directed joint degree&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;is_valid_joint_degree&#39;, &#39;is_valid_directed_joint_degree&#39;,</span>
<span class="gd">-    &#39;joint_degree_graph&#39;, &#39;directed_joint_degree_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;is_valid_joint_degree&quot;,</span>
<span class="gi">+    &quot;is_valid_directed_joint_degree&quot;,</span>
<span class="gi">+    &quot;joint_degree_graph&quot;,</span>
<span class="gi">+    &quot;directed_joint_degree_graph&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None)
<span class="gu">@@ -45,7 +51,31 @@ def is_valid_joint_degree(joint_degrees):</span>
<span class="w"> </span>       prescribed joint degree distribution&quot;, Journal of Experimental
<span class="w"> </span>       Algorithmics, 2012.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    degree_count = {}</span>
<span class="gi">+    for k in joint_degrees:</span>
<span class="gi">+        if k &gt; 0:</span>
<span class="gi">+            k_size = sum(joint_degrees[k].values()) / k</span>
<span class="gi">+            if not k_size.is_integer():</span>
<span class="gi">+                return False</span>
<span class="gi">+            degree_count[k] = k_size</span>
<span class="gi">+</span>
<span class="gi">+    for k in joint_degrees:</span>
<span class="gi">+        for l in joint_degrees[k]:</span>
<span class="gi">+            if not float(joint_degrees[k][l]).is_integer():</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            if (k != l) and (joint_degrees[k][l] &gt; degree_count[k] * degree_count[l]):</span>
<span class="gi">+                return False</span>
<span class="gi">+            elif k == l:</span>
<span class="gi">+                if joint_degrees[k][k] &gt; degree_count[k] * (degree_count[k] - 1):</span>
<span class="gi">+                    return False</span>
<span class="gi">+                if joint_degrees[k][k] % 2 != 0:</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+    # if all above conditions have been satisfied then the input</span>
<span class="gi">+    # joint degree is realizable as a simple graph.</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def _neighbor_switch(G, w, unsat, h_node_residual, avoid_node_id=None):
<span class="gu">@@ -77,7 +107,38 @@ def _neighbor_switch(G, w, unsat, h_node_residual, avoid_node_id=None):</span>
<span class="w"> </span>    .. [1] M. Gjoka, B. Tillman, A. Markopoulou, &quot;Construction of Simple
<span class="w"> </span>       Graphs with a Target Joint Degree Matrix and Beyond&quot;, IEEE Infocom, &#39;15
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if (avoid_node_id is None) or (h_node_residual[avoid_node_id] &gt; 1):</span>
<span class="gi">+        # select unsaturated node w_prime that has the same degree as w</span>
<span class="gi">+        w_prime = next(iter(unsat))</span>
<span class="gi">+    else:</span>
<span class="gi">+        # assume that the node pair (v,w) has been selected for connection. if</span>
<span class="gi">+        # - neighbor_switch is called for node w,</span>
<span class="gi">+        # - nodes v and w have the same degree,</span>
<span class="gi">+        # - node v=avoid_node_id has only one stub left,</span>
<span class="gi">+        # then prevent v=avoid_node_id from being selected as w_prime.</span>
<span class="gi">+</span>
<span class="gi">+        iter_var = iter(unsat)</span>
<span class="gi">+        while True:</span>
<span class="gi">+            w_prime = next(iter_var)</span>
<span class="gi">+            if w_prime != avoid_node_id:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    # select switch_node, a neighbor of w, that is not connected to w_prime</span>
<span class="gi">+    w_prime_neighbs = G[w_prime]  # slightly faster declaring this variable</span>
<span class="gi">+    for v in G[w]:</span>
<span class="gi">+        if (v not in w_prime_neighbs) and (v != w_prime):</span>
<span class="gi">+            switch_node = v</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    # remove edge (w,switch_node), add edge (w_prime,switch_node) and update</span>
<span class="gi">+    # data structures</span>
<span class="gi">+    G.remove_edge(w, switch_node)</span>
<span class="gi">+    G.add_edge(w_prime, switch_node)</span>
<span class="gi">+    h_node_residual[w] += 1</span>
<span class="gi">+    h_node_residual[w_prime] -= 1</span>
<span class="gi">+    if h_node_residual[w_prime] == 0:</span>
<span class="gi">+        unsat.remove(w_prime)</span>


<span class="w"> </span>@py_random_state(1)
<span class="gu">@@ -138,7 +199,90 @@ def joint_degree_graph(joint_degrees, seed=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.joint_degree_graph(joint_degrees)
<span class="w"> </span>    &gt;&gt;&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if not is_valid_joint_degree(joint_degrees):</span>
<span class="gi">+        msg = &quot;Input joint degree dict not realizable as a simple graph&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # compute degree count from joint_degrees</span>
<span class="gi">+    degree_count = {k: sum(l.values()) // k for k, l in joint_degrees.items() if k &gt; 0}</span>
<span class="gi">+</span>
<span class="gi">+    # start with empty N-node graph</span>
<span class="gi">+    N = sum(degree_count.values())</span>
<span class="gi">+    G = nx.empty_graph(N)</span>
<span class="gi">+</span>
<span class="gi">+    # for a given degree group, keep the list of all node ids</span>
<span class="gi">+    h_degree_nodelist = {}</span>
<span class="gi">+</span>
<span class="gi">+    # for a given node, keep track of the remaining stubs</span>
<span class="gi">+    h_node_residual = {}</span>
<span class="gi">+</span>
<span class="gi">+    # populate h_degree_nodelist and h_node_residual</span>
<span class="gi">+    nodeid = 0</span>
<span class="gi">+    for degree, num_nodes in degree_count.items():</span>
<span class="gi">+        h_degree_nodelist[degree] = range(nodeid, nodeid + num_nodes)</span>
<span class="gi">+        for v in h_degree_nodelist[degree]:</span>
<span class="gi">+            h_node_residual[v] = degree</span>
<span class="gi">+        nodeid += int(num_nodes)</span>
<span class="gi">+</span>
<span class="gi">+    # iterate over every degree pair (k,l) and add the number of edges given</span>
<span class="gi">+    # for each pair</span>
<span class="gi">+    for k in joint_degrees:</span>
<span class="gi">+        for l in joint_degrees[k]:</span>
<span class="gi">+            # n_edges_add is the number of edges to add for the</span>
<span class="gi">+            # degree pair (k,l)</span>
<span class="gi">+            n_edges_add = joint_degrees[k][l]</span>
<span class="gi">+</span>
<span class="gi">+            if (n_edges_add &gt; 0) and (k &gt;= l):</span>
<span class="gi">+                # number of nodes with degree k and l</span>
<span class="gi">+                k_size = degree_count[k]</span>
<span class="gi">+                l_size = degree_count[l]</span>
<span class="gi">+</span>
<span class="gi">+                # k_nodes and l_nodes consist of all nodes of degree k and l</span>
<span class="gi">+                k_nodes = h_degree_nodelist[k]</span>
<span class="gi">+                l_nodes = h_degree_nodelist[l]</span>
<span class="gi">+</span>
<span class="gi">+                # k_unsat and l_unsat consist of nodes of degree k and l that</span>
<span class="gi">+                # are unsaturated (nodes that have at least 1 available stub)</span>
<span class="gi">+                k_unsat = {v for v in k_nodes if h_node_residual[v] &gt; 0}</span>
<span class="gi">+</span>
<span class="gi">+                if k != l:</span>
<span class="gi">+                    l_unsat = {w for w in l_nodes if h_node_residual[w] &gt; 0}</span>
<span class="gi">+                else:</span>
<span class="gi">+                    l_unsat = k_unsat</span>
<span class="gi">+                    n_edges_add = joint_degrees[k][l] // 2</span>
<span class="gi">+</span>
<span class="gi">+                while n_edges_add &gt; 0:</span>
<span class="gi">+                    # randomly pick nodes v and w that have degrees k and l</span>
<span class="gi">+                    v = k_nodes[seed.randrange(k_size)]</span>
<span class="gi">+                    w = l_nodes[seed.randrange(l_size)]</span>
<span class="gi">+</span>
<span class="gi">+                    # if nodes v and w are disconnected then attempt to connect</span>
<span class="gi">+                    if not G.has_edge(v, w) and (v != w):</span>
<span class="gi">+                        # if node v has no free stubs then do neighbor switch</span>
<span class="gi">+                        if h_node_residual[v] == 0:</span>
<span class="gi">+                            _neighbor_switch(G, v, k_unsat, h_node_residual)</span>
<span class="gi">+</span>
<span class="gi">+                        # if node w has no free stubs then do neighbor switch</span>
<span class="gi">+                        if h_node_residual[w] == 0:</span>
<span class="gi">+                            if k != l:</span>
<span class="gi">+                                _neighbor_switch(G, w, l_unsat, h_node_residual)</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                _neighbor_switch(</span>
<span class="gi">+                                    G, w, l_unsat, h_node_residual, avoid_node_id=v</span>
<span class="gi">+                                )</span>
<span class="gi">+</span>
<span class="gi">+                        # add edge (v, w) and update data structures</span>
<span class="gi">+                        G.add_edge(v, w)</span>
<span class="gi">+                        h_node_residual[v] -= 1</span>
<span class="gi">+                        h_node_residual[w] -= 1</span>
<span class="gi">+                        n_edges_add -= 1</span>
<span class="gi">+</span>
<span class="gi">+                        if h_node_residual[v] == 0:</span>
<span class="gi">+                            k_unsat.discard(v)</span>
<span class="gi">+                        if h_node_residual[w] == 0:</span>
<span class="gi">+                            l_unsat.discard(w)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None)
<span class="gu">@@ -179,11 +323,39 @@ def is_valid_directed_joint_degree(in_degrees, out_degrees, nkk):</span>
<span class="w"> </span>    [1] B. Tillman, A. Markopoulou, C. T. Butts &amp; M. Gjoka,
<span class="w"> </span>        &quot;Construction of Directed 2K Graphs&quot;. In Proc. of KDD 2017.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _directed_neighbor_switch(G, w, unsat, h_node_residual_out, chords,</span>
<span class="gd">-    h_partition_in, partition):</span>
<span class="gi">+    V = {}  # number of nodes with in/out degree.</span>
<span class="gi">+    forbidden = {}</span>
<span class="gi">+    if len(in_degrees) != len(out_degrees):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    for idx in range(len(in_degrees)):</span>
<span class="gi">+        i = in_degrees[idx]</span>
<span class="gi">+        o = out_degrees[idx]</span>
<span class="gi">+        V[(i, 0)] = V.get((i, 0), 0) + 1</span>
<span class="gi">+        V[(o, 1)] = V.get((o, 1), 0) + 1</span>
<span class="gi">+</span>
<span class="gi">+        forbidden[(o, i)] = forbidden.get((o, i), 0) + 1</span>
<span class="gi">+</span>
<span class="gi">+    S = {}  # number of edges going from in/out degree nodes.</span>
<span class="gi">+    for k in nkk:</span>
<span class="gi">+        for l in nkk[k]:</span>
<span class="gi">+            val = nkk[k][l]</span>
<span class="gi">+            if not float(val).is_integer():  # condition 1</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            if val &gt; 0:</span>
<span class="gi">+                S[(k, 1)] = S.get((k, 1), 0) + val</span>
<span class="gi">+                S[(l, 0)] = S.get((l, 0), 0) + val</span>
<span class="gi">+                # condition 3</span>
<span class="gi">+                if val + forbidden.get((k, l), 0) &gt; V[(k, 1)] * V[(l, 0)]:</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+    return all(S[s] / s[0] == V[s] for s in S)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _directed_neighbor_switch(</span>
<span class="gi">+    G, w, unsat, h_node_residual_out, chords, h_partition_in, partition</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Releases one free stub for node w, while preserving joint degree in G.

<span class="w"> </span>    Parameters
<span class="gu">@@ -217,11 +389,36 @@ def _directed_neighbor_switch(G, w, unsat, h_node_residual_out, chords,</span>
<span class="w"> </span>    [1] B. Tillman, A. Markopoulou, C. T. Butts &amp; M. Gjoka,
<span class="w"> </span>        &quot;Construction of Directed 2K Graphs&quot;. In Proc. of KDD 2017.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _directed_neighbor_switch_rev(G, w, unsat, h_node_residual_in, chords,</span>
<span class="gd">-    h_partition_out, partition):</span>
<span class="gi">+    w_prime = unsat.pop()</span>
<span class="gi">+    unsat.add(w_prime)</span>
<span class="gi">+    # select node t, a neighbor of w, that is not connected to w_prime</span>
<span class="gi">+    w_neighbs = list(G.successors(w))</span>
<span class="gi">+    # slightly faster declaring this variable</span>
<span class="gi">+    w_prime_neighbs = list(G.successors(w_prime))</span>
<span class="gi">+</span>
<span class="gi">+    for v in w_neighbs:</span>
<span class="gi">+        if (v not in w_prime_neighbs) and w_prime != v:</span>
<span class="gi">+            # removes (w,v), add (w_prime,v)  and update data structures</span>
<span class="gi">+            G.remove_edge(w, v)</span>
<span class="gi">+            G.add_edge(w_prime, v)</span>
<span class="gi">+</span>
<span class="gi">+            if h_partition_in[v] == partition:</span>
<span class="gi">+                chords.add((w, v))</span>
<span class="gi">+                chords.discard((w_prime, v))</span>
<span class="gi">+</span>
<span class="gi">+            h_node_residual_out[w] += 1</span>
<span class="gi">+            h_node_residual_out[w_prime] -= 1</span>
<span class="gi">+            if h_node_residual_out[w_prime] == 0:</span>
<span class="gi">+                unsat.remove(w_prime)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    # If neighbor switch didn&#39;t work, use unsaturated node</span>
<span class="gi">+    return w_prime</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _directed_neighbor_switch_rev(</span>
<span class="gi">+    G, w, unsat, h_node_residual_in, chords, h_partition_out, partition</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;The reverse of directed_neighbor_switch.

<span class="w"> </span>    Parameters
<span class="gu">@@ -246,7 +443,29 @@ def _directed_neighbor_switch_rev(G, w, unsat, h_node_residual_in, chords,</span>
<span class="w"> </span>    Same operation as directed_neighbor_switch except it handles this operation
<span class="w"> </span>    for incoming edges instead of outgoing.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    w_prime = unsat.pop()</span>
<span class="gi">+    unsat.add(w_prime)</span>
<span class="gi">+    # slightly faster declaring these as variables.</span>
<span class="gi">+    w_neighbs = list(G.predecessors(w))</span>
<span class="gi">+    w_prime_neighbs = list(G.predecessors(w_prime))</span>
<span class="gi">+    # select node v, a neighbor of w, that is not connected to w_prime.</span>
<span class="gi">+    for v in w_neighbs:</span>
<span class="gi">+        if (v not in w_prime_neighbs) and w_prime != v:</span>
<span class="gi">+            # removes (v,w), add (v,w_prime) and update data structures.</span>
<span class="gi">+            G.remove_edge(v, w)</span>
<span class="gi">+            G.add_edge(v, w_prime)</span>
<span class="gi">+            if h_partition_out[v] == partition:</span>
<span class="gi">+                chords.add((v, w))</span>
<span class="gi">+                chords.discard((v, w_prime))</span>
<span class="gi">+</span>
<span class="gi">+            h_node_residual_in[w] += 1</span>
<span class="gi">+            h_node_residual_in[w_prime] -= 1</span>
<span class="gi">+            if h_node_residual_in[w_prime] == 0:</span>
<span class="gi">+                unsat.remove(w_prime)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    # If neighbor switch didn&#39;t work, use the unsaturated node.</span>
<span class="gi">+    return w_prime</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -315,4 +534,131 @@ def directed_joint_degree_graph(in_degrees, out_degrees, nkk, seed=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.directed_joint_degree_graph(in_degrees, out_degrees, nkk)
<span class="w"> </span>    &gt;&gt;&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not is_valid_directed_joint_degree(in_degrees, out_degrees, nkk):</span>
<span class="gi">+        msg = &quot;Input is not realizable as a simple graph&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # start with an empty directed graph.</span>
<span class="gi">+    G = nx.DiGraph()</span>
<span class="gi">+</span>
<span class="gi">+    # for a given group, keep the list of all node ids.</span>
<span class="gi">+    h_degree_nodelist_in = {}</span>
<span class="gi">+    h_degree_nodelist_out = {}</span>
<span class="gi">+    # for a given group, keep the list of all unsaturated node ids.</span>
<span class="gi">+    h_degree_nodelist_in_unsat = {}</span>
<span class="gi">+    h_degree_nodelist_out_unsat = {}</span>
<span class="gi">+    # for a given node, keep track of the remaining stubs to be added.</span>
<span class="gi">+    h_node_residual_out = {}</span>
<span class="gi">+    h_node_residual_in = {}</span>
<span class="gi">+    # for a given node, keep track of the partition id.</span>
<span class="gi">+    h_partition_out = {}</span>
<span class="gi">+    h_partition_in = {}</span>
<span class="gi">+    # keep track of non-chords between pairs of partition ids.</span>
<span class="gi">+    non_chords = {}</span>
<span class="gi">+</span>
<span class="gi">+    # populate data structures</span>
<span class="gi">+    for idx, i in enumerate(in_degrees):</span>
<span class="gi">+        idx = int(idx)</span>
<span class="gi">+        if i &gt; 0:</span>
<span class="gi">+            h_degree_nodelist_in.setdefault(i, [])</span>
<span class="gi">+            h_degree_nodelist_in_unsat.setdefault(i, set())</span>
<span class="gi">+            h_degree_nodelist_in[i].append(idx)</span>
<span class="gi">+            h_degree_nodelist_in_unsat[i].add(idx)</span>
<span class="gi">+            h_node_residual_in[idx] = i</span>
<span class="gi">+            h_partition_in[idx] = i</span>
<span class="gi">+</span>
<span class="gi">+    for idx, o in enumerate(out_degrees):</span>
<span class="gi">+        o = out_degrees[idx]</span>
<span class="gi">+        non_chords[(o, in_degrees[idx])] = non_chords.get((o, in_degrees[idx]), 0) + 1</span>
<span class="gi">+        idx = int(idx)</span>
<span class="gi">+        if o &gt; 0:</span>
<span class="gi">+            h_degree_nodelist_out.setdefault(o, [])</span>
<span class="gi">+            h_degree_nodelist_out_unsat.setdefault(o, set())</span>
<span class="gi">+            h_degree_nodelist_out[o].append(idx)</span>
<span class="gi">+            h_degree_nodelist_out_unsat[o].add(idx)</span>
<span class="gi">+            h_node_residual_out[idx] = o</span>
<span class="gi">+            h_partition_out[idx] = o</span>
<span class="gi">+</span>
<span class="gi">+        G.add_node(idx)</span>
<span class="gi">+</span>
<span class="gi">+    nk_in = {}</span>
<span class="gi">+    nk_out = {}</span>
<span class="gi">+    for p in h_degree_nodelist_in:</span>
<span class="gi">+        nk_in[p] = len(h_degree_nodelist_in[p])</span>
<span class="gi">+    for p in h_degree_nodelist_out:</span>
<span class="gi">+        nk_out[p] = len(h_degree_nodelist_out[p])</span>
<span class="gi">+</span>
<span class="gi">+    # iterate over every degree pair (k,l) and add the number of edges given</span>
<span class="gi">+    # for each pair.</span>
<span class="gi">+    for k in nkk:</span>
<span class="gi">+        for l in nkk[k]:</span>
<span class="gi">+            n_edges_add = nkk[k][l]</span>
<span class="gi">+</span>
<span class="gi">+            if n_edges_add &gt; 0:</span>
<span class="gi">+                # chords contains a random set of potential edges.</span>
<span class="gi">+                chords = set()</span>
<span class="gi">+</span>
<span class="gi">+                k_len = nk_out[k]</span>
<span class="gi">+                l_len = nk_in[l]</span>
<span class="gi">+                chords_sample = seed.sample(</span>
<span class="gi">+                    range(k_len * l_len), n_edges_add + non_chords.get((k, l), 0)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                num = 0</span>
<span class="gi">+                while len(chords) &lt; n_edges_add:</span>
<span class="gi">+                    i = h_degree_nodelist_out[k][chords_sample[num] % k_len]</span>
<span class="gi">+                    j = h_degree_nodelist_in[l][chords_sample[num] // k_len]</span>
<span class="gi">+                    num += 1</span>
<span class="gi">+                    if i != j:</span>
<span class="gi">+                        chords.add((i, j))</span>
<span class="gi">+</span>
<span class="gi">+                # k_unsat and l_unsat consist of nodes of in/out degree k and l</span>
<span class="gi">+                # that are unsaturated i.e. those nodes that have at least one</span>
<span class="gi">+                # available stub</span>
<span class="gi">+                k_unsat = h_degree_nodelist_out_unsat[k]</span>
<span class="gi">+                l_unsat = h_degree_nodelist_in_unsat[l]</span>
<span class="gi">+</span>
<span class="gi">+                while n_edges_add &gt; 0:</span>
<span class="gi">+                    v, w = chords.pop()</span>
<span class="gi">+                    chords.add((v, w))</span>
<span class="gi">+</span>
<span class="gi">+                    # if node v has no free stubs then do neighbor switch.</span>
<span class="gi">+                    if h_node_residual_out[v] == 0:</span>
<span class="gi">+                        _v = _directed_neighbor_switch(</span>
<span class="gi">+                            G,</span>
<span class="gi">+                            v,</span>
<span class="gi">+                            k_unsat,</span>
<span class="gi">+                            h_node_residual_out,</span>
<span class="gi">+                            chords,</span>
<span class="gi">+                            h_partition_in,</span>
<span class="gi">+                            l,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if _v is not None:</span>
<span class="gi">+                            v = _v</span>
<span class="gi">+</span>
<span class="gi">+                    # if node w has no free stubs then do neighbor switch.</span>
<span class="gi">+                    if h_node_residual_in[w] == 0:</span>
<span class="gi">+                        _w = _directed_neighbor_switch_rev(</span>
<span class="gi">+                            G,</span>
<span class="gi">+                            w,</span>
<span class="gi">+                            l_unsat,</span>
<span class="gi">+                            h_node_residual_in,</span>
<span class="gi">+                            chords,</span>
<span class="gi">+                            h_partition_out,</span>
<span class="gi">+                            k,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        if _w is not None:</span>
<span class="gi">+                            w = _w</span>
<span class="gi">+</span>
<span class="gi">+                    # add edge (v,w) and update data structures.</span>
<span class="gi">+                    G.add_edge(v, w)</span>
<span class="gi">+                    h_node_residual_out[v] -= 1</span>
<span class="gi">+                    h_node_residual_in[w] -= 1</span>
<span class="gi">+                    n_edges_add -= 1</span>
<span class="gi">+                    chords.discard((v, w))</span>
<span class="gi">+</span>
<span class="gi">+                    if h_node_residual_out[v] == 0:</span>
<span class="gi">+                        k_unsat.discard(v)</span>
<span class="gi">+                    if h_node_residual_in[w] == 0:</span>
<span class="gi">+                        l_unsat.discard(w)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/lattice.py b/networkx/generators/lattice.py</span>
<span class="gh">index c84792c4c..95e520d2c 100644</span>
<span class="gd">--- a/networkx/generators/lattice.py</span>
<span class="gi">+++ b/networkx/generators/lattice.py</span>
<span class="gu">@@ -12,16 +12,24 @@ be found about `Triangular Tiling`_, and `Square, Hex and Triangle Grids`_</span>
<span class="w"> </span>.. _Triangular Tiling: https://en.wikipedia.org/wiki/Triangular_tiling

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from itertools import repeat
<span class="w"> </span>from math import sqrt
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.classes import set_node_attributes
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.generators.classic import cycle_graph, empty_graph, path_graph
<span class="w"> </span>from networkx.relabel import relabel_nodes
<span class="w"> </span>from networkx.utils import flatten, nodes_or_number, pairwise
<span class="gd">-__all__ = [&#39;grid_2d_graph&#39;, &#39;grid_graph&#39;, &#39;hypercube_graph&#39;,</span>
<span class="gd">-    &#39;triangular_lattice_graph&#39;, &#39;hexagonal_lattice_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;grid_2d_graph&quot;,</span>
<span class="gi">+    &quot;grid_graph&quot;,</span>
<span class="gi">+    &quot;hypercube_graph&quot;,</span>
<span class="gi">+    &quot;triangular_lattice_graph&quot;,</span>
<span class="gi">+    &quot;hexagonal_lattice_graph&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -52,7 +60,30 @@ def grid_2d_graph(m, n, periodic=False, create_using=None):</span>
<span class="w"> </span>        The (possibly periodic) grid graph of the specified dimensions.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(0, create_using)</span>
<span class="gi">+    row_name, rows = m</span>
<span class="gi">+    col_name, cols = n</span>
<span class="gi">+    G.add_nodes_from((i, j) for i in rows for j in cols)</span>
<span class="gi">+    G.add_edges_from(((i, j), (pi, j)) for pi, i in pairwise(rows) for j in cols)</span>
<span class="gi">+    G.add_edges_from(((i, j), (i, pj)) for i in rows for pj, j in pairwise(cols))</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        periodic_r, periodic_c = periodic</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        periodic_r = periodic_c = periodic</span>
<span class="gi">+</span>
<span class="gi">+    if periodic_r and len(rows) &gt; 2:</span>
<span class="gi">+        first = rows[0]</span>
<span class="gi">+        last = rows[-1]</span>
<span class="gi">+        G.add_edges_from(((first, j), (last, j)) for j in cols)</span>
<span class="gi">+    if periodic_c and len(cols) &gt; 2:</span>
<span class="gi">+        first = cols[0]</span>
<span class="gi">+        last = cols[-1]</span>
<span class="gi">+        G.add_edges_from(((i, first), (i, last)) for i in rows)</span>
<span class="gi">+    # both directions for directed</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        G.add_edges_from((v, u) for u, v in G.edges())</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -93,7 +124,23 @@ def grid_graph(dim, periodic=False):</span>
<span class="w"> </span>    &gt;&gt;&gt; len(G)
<span class="w"> </span>    6
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from networkx.algorithms.operators.product import cartesian_product</span>
<span class="gi">+</span>
<span class="gi">+    if not dim:</span>
<span class="gi">+        return empty_graph(0)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        func = (cycle_graph if p else path_graph for p in periodic)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        func = repeat(cycle_graph if periodic else path_graph)</span>
<span class="gi">+</span>
<span class="gi">+    G = next(func)(dim[0])</span>
<span class="gi">+    for current_dim in dim[1:]:</span>
<span class="gi">+        Gnew = next(func)(current_dim)</span>
<span class="gi">+        G = cartesian_product(Gnew, G)</span>
<span class="gi">+    # graph G is done but has labels of the form (1, (2, (3, 1))) so relabel</span>
<span class="gi">+    H = relabel_nodes(G, flatten)</span>
<span class="gi">+    return H</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -118,13 +165,16 @@ def hypercube_graph(n):</span>
<span class="w"> </span>    NetworkX graph
<span class="w"> </span>        The hypercube graph of dimension *n*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dim = n * [2]</span>
<span class="gi">+    G = grid_graph(dim)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def triangular_lattice_graph(m, n, periodic=False, with_positions=True,</span>
<span class="gd">-    create_using=None):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the $m$ by $n$ triangular lattice graph.</span>
<span class="gi">+def triangular_lattice_graph(</span>
<span class="gi">+    m, n, periodic=False, with_positions=True, create_using=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the $m$ by $n$ triangular lattice graph.</span>

<span class="w"> </span>    The `triangular lattice graph`_ is a two-dimensional `grid graph`_ in
<span class="w"> </span>    which each square unit has a diagonal edge (each grid unit has a chord).
<span class="gu">@@ -141,7 +191,7 @@ def triangular_lattice_graph(m, n, periodic=False, with_positions=True,</span>
<span class="w"> </span>    Positions of nodes are computed by default or `with_positions is True`.
<span class="w"> </span>    The position of each node (embedded in a euclidean plane) is stored in
<span class="w"> </span>    the graph using equilateral triangles with sidelength 1.
<span class="gd">-    The height between rows of nodes is thus $\\sqrt(3)/2$.</span>
<span class="gi">+    The height between rows of nodes is thus $\sqrt(3)/2$.</span>
<span class="w"> </span>    Nodes lie in the first quadrant with the node $(0, 0)$ at the origin.

<span class="w"> </span>    .. _triangular lattice graph: http://mathworld.wolfram.com/TriangularGrid.html
<span class="gu">@@ -177,12 +227,54 @@ def triangular_lattice_graph(m, n, periodic=False, with_positions=True,</span>
<span class="w"> </span>    NetworkX graph
<span class="w"> </span>        The *m* by *n* triangular lattice graph.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    H = empty_graph(0, create_using)</span>
<span class="gi">+    if n == 0 or m == 0:</span>
<span class="gi">+        return H</span>
<span class="gi">+    if periodic:</span>
<span class="gi">+        if n &lt; 5 or m &lt; 3:</span>
<span class="gi">+            msg = f&quot;m &gt; 2 and n &gt; 4 required for periodic. m={m}, n={n}&quot;</span>
<span class="gi">+            raise NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    N = (n + 1) // 2  # number of nodes in row</span>
<span class="gi">+    rows = range(m + 1)</span>
<span class="gi">+    cols = range(N + 1)</span>
<span class="gi">+    # Make grid</span>
<span class="gi">+    H.add_edges_from(((i, j), (i + 1, j)) for j in rows for i in cols[:N])</span>
<span class="gi">+    H.add_edges_from(((i, j), (i, j + 1)) for j in rows[:m] for i in cols)</span>
<span class="gi">+    # add diagonals</span>
<span class="gi">+    H.add_edges_from(((i, j), (i + 1, j + 1)) for j in rows[1:m:2] for i in cols[:N])</span>
<span class="gi">+    H.add_edges_from(((i + 1, j), (i, j + 1)) for j in rows[:m:2] for i in cols[:N])</span>
<span class="gi">+    # identify boundary nodes if periodic</span>
<span class="gi">+    from networkx.algorithms.minors import contracted_nodes</span>
<span class="gi">+</span>
<span class="gi">+    if periodic is True:</span>
<span class="gi">+        for i in cols:</span>
<span class="gi">+            H = contracted_nodes(H, (i, 0), (i, m))</span>
<span class="gi">+        for j in rows[:m]:</span>
<span class="gi">+            H = contracted_nodes(H, (0, j), (N, j))</span>
<span class="gi">+    elif n % 2:</span>
<span class="gi">+        # remove extra nodes</span>
<span class="gi">+        H.remove_nodes_from((N, j) for j in rows[1::2])</span>
<span class="gi">+</span>
<span class="gi">+    # Add position node attributes</span>
<span class="gi">+    if with_positions:</span>
<span class="gi">+        ii = (i for i in cols for j in rows)</span>
<span class="gi">+        jj = (j for i in cols for j in rows)</span>
<span class="gi">+        xx = (0.5 * (j % 2) + i for i in cols for j in rows)</span>
<span class="gi">+        h = sqrt(3) / 2</span>
<span class="gi">+        if periodic:</span>
<span class="gi">+            yy = (h * j + 0.01 * i * i for i in cols for j in rows)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yy = (h * j for i in cols for j in rows)</span>
<span class="gi">+        pos = {(i, j): (x, y) for i, j, x, y in zip(ii, jj, xx, yy) if (i, j) in H}</span>
<span class="gi">+        set_node_attributes(H, pos, &quot;pos&quot;)</span>
<span class="gi">+    return H</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def hexagonal_lattice_graph(m, n, periodic=False, with_positions=True,</span>
<span class="gd">-    create_using=None):</span>
<span class="gi">+def hexagonal_lattice_graph(</span>
<span class="gi">+    m, n, periodic=False, with_positions=True, create_using=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns an `m` by `n` hexagonal lattice graph.

<span class="w"> </span>    The *hexagonal lattice graph* is a graph whose nodes and edges are
<span class="gu">@@ -229,4 +321,47 @@ def hexagonal_lattice_graph(m, n, periodic=False, with_positions=True,</span>
<span class="w"> </span>    NetworkX graph
<span class="w"> </span>        The *m* by *n* hexagonal lattice graph.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(0, create_using)</span>
<span class="gi">+    if m == 0 or n == 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+    if periodic and (n % 2 == 1 or m &lt; 2 or n &lt; 2):</span>
<span class="gi">+        msg = &quot;periodic hexagonal lattice needs m &gt; 1, n &gt; 1 and even n&quot;</span>
<span class="gi">+        raise NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    M = 2 * m  # twice as many nodes as hexagons vertically</span>
<span class="gi">+    rows = range(M + 2)</span>
<span class="gi">+    cols = range(n + 1)</span>
<span class="gi">+    # make lattice</span>
<span class="gi">+    col_edges = (((i, j), (i, j + 1)) for i in cols for j in rows[: M + 1])</span>
<span class="gi">+    row_edges = (((i, j), (i + 1, j)) for i in cols[:n] for j in rows if i % 2 == j % 2)</span>
<span class="gi">+    G.add_edges_from(col_edges)</span>
<span class="gi">+    G.add_edges_from(row_edges)</span>
<span class="gi">+    # Remove corner nodes with one edge</span>
<span class="gi">+    G.remove_node((0, M + 1))</span>
<span class="gi">+    G.remove_node((n, (M + 1) * (n % 2)))</span>
<span class="gi">+</span>
<span class="gi">+    # identify boundary nodes if periodic</span>
<span class="gi">+    from networkx.algorithms.minors import contracted_nodes</span>
<span class="gi">+</span>
<span class="gi">+    if periodic:</span>
<span class="gi">+        for i in cols[:n]:</span>
<span class="gi">+            G = contracted_nodes(G, (i, 0), (i, M))</span>
<span class="gi">+        for i in cols[1:]:</span>
<span class="gi">+            G = contracted_nodes(G, (i, 1), (i, M + 1))</span>
<span class="gi">+        for j in rows[1:M]:</span>
<span class="gi">+            G = contracted_nodes(G, (0, j), (n, j))</span>
<span class="gi">+        G.remove_node((n, M))</span>
<span class="gi">+</span>
<span class="gi">+    # calc position in embedded space</span>
<span class="gi">+    ii = (i for i in cols for j in rows)</span>
<span class="gi">+    jj = (j for i in cols for j in rows)</span>
<span class="gi">+    xx = (0.5 + i + i // 2 + (j % 2) * ((i % 2) - 0.5) for i in cols for j in rows)</span>
<span class="gi">+    h = sqrt(3) / 2</span>
<span class="gi">+    if periodic:</span>
<span class="gi">+        yy = (h * j + 0.01 * i * i for i in cols for j in rows)</span>
<span class="gi">+    else:</span>
<span class="gi">+        yy = (h * j for i in cols for j in rows)</span>
<span class="gi">+    # exclude nodes not in G</span>
<span class="gi">+    pos = {(i, j): (x, y) for i, j, x, y in zip(ii, jj, xx, yy) if (i, j) in G}</span>
<span class="gi">+    set_node_attributes(G, pos, &quot;pos&quot;)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/line.py b/networkx/generators/line.py</span>
<span class="gh">index dce0056f3..57f4d1692 100644</span>
<span class="gd">--- a/networkx/generators/line.py</span>
<span class="gi">+++ b/networkx/generators/line.py</span>
<span class="gu">@@ -2,15 +2,17 @@</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from functools import partial
<span class="w"> </span>from itertools import combinations
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import arbitrary_element
<span class="w"> </span>from networkx.utils.decorators import not_implemented_for
<span class="gd">-__all__ = [&#39;line_graph&#39;, &#39;inverse_line_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;line_graph&quot;, &quot;inverse_line_graph&quot;]</span>


<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def line_graph(G, create_using=None):
<span class="gd">-    &quot;&quot;&quot;Returns the line graph of the graph or digraph `G`.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the line graph of the graph or digraph `G`.</span>

<span class="w"> </span>    The line graph of a graph `G` has a node for each edge in `G` and an
<span class="w"> </span>    edge joining those nodes if the two edges in `G` share a common node. For
<span class="gu">@@ -63,8 +65,8 @@ def line_graph(G, create_using=None):</span>
<span class="w"> </span>    *Self-loops in undirected graphs*

<span class="w"> </span>    For an undirected graph `G` without multiple edges, each edge can be
<span class="gd">-    written as a set `\\{u, v\\}`.  Its line graph `L` has the edges of `G` as</span>
<span class="gd">-    its nodes. If `x` and `y` are two nodes in `L`, then `\\{x, y\\}` is an edge</span>
<span class="gi">+    written as a set `\{u, v\}`.  Its line graph `L` has the edges of `G` as</span>
<span class="gi">+    its nodes. If `x` and `y` are two nodes in `L`, then `\{x, y\}` is an edge</span>
<span class="w"> </span>    in `L` if and only if the intersection of `x` and `y` is nonempty. Thus,
<span class="w"> </span>    the set of all edges is determined by the set of all pairwise intersections
<span class="w"> </span>    of edges in `G`.
<span class="gu">@@ -110,7 +112,11 @@ def line_graph(G, create_using=None):</span>
<span class="w"> </span>      Academic Press Inc., pp. 271--305.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        L = _lg_directed(G, create_using=create_using)</span>
<span class="gi">+    else:</span>
<span class="gi">+        L = _lg_undirected(G, selfloops=False, create_using=create_using)</span>
<span class="gi">+    return L</span>


<span class="w"> </span>def _lg_directed(G, create_using=None):
<span class="gu">@@ -129,7 +135,18 @@ def _lg_directed(G, create_using=None):</span>
<span class="w"> </span>       Default is to use the same graph class as `G`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    L = nx.empty_graph(0, create_using, default=G.__class__)</span>
<span class="gi">+</span>
<span class="gi">+    # Create a graph specific edge function.</span>
<span class="gi">+    get_edges = partial(G.edges, keys=True) if G.is_multigraph() else G.edges</span>
<span class="gi">+</span>
<span class="gi">+    for from_node in get_edges():</span>
<span class="gi">+        # from_node is: (u,v) or (u,v,key)</span>
<span class="gi">+        L.add_node(from_node)</span>
<span class="gi">+        for to_node in get_edges(from_node[1]):</span>
<span class="gi">+            L.add_edge(from_node, to_node)</span>
<span class="gi">+</span>
<span class="gi">+    return L</span>


<span class="w"> </span>def _lg_undirected(G, selfloops=False, create_using=None):
<span class="gu">@@ -156,11 +173,48 @@ def _lg_undirected(G, selfloops=False, create_using=None):</span>
<span class="w"> </span>    produce self-loops.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    L = nx.empty_graph(0, create_using, default=G.__class__)</span>
<span class="gi">+</span>
<span class="gi">+    # Graph specific functions for edges.</span>
<span class="gi">+    get_edges = partial(G.edges, keys=True) if G.is_multigraph() else G.edges</span>
<span class="gi">+</span>
<span class="gi">+    # Determine if we include self-loops or not.</span>
<span class="gi">+    shift = 0 if selfloops else 1</span>

<span class="gi">+    # Introduce numbering of nodes</span>
<span class="gi">+    node_index = {n: i for i, n in enumerate(G)}</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    # Lift canonical representation of nodes to edges in line graph</span>
<span class="gi">+    edge_key_function = lambda edge: (node_index[edge[0]], node_index[edge[1]])</span>
<span class="gi">+</span>
<span class="gi">+    edges = set()</span>
<span class="gi">+    for u in G:</span>
<span class="gi">+        # Label nodes as a sorted tuple of nodes in original graph.</span>
<span class="gi">+        # Decide on representation of {u, v} as (u, v) or (v, u) depending on node_index.</span>
<span class="gi">+        # -&gt; This ensures a canonical representation and avoids comparing values of different types.</span>
<span class="gi">+        nodes = [tuple(sorted(x[:2], key=node_index.get)) + x[2:] for x in get_edges(u)]</span>
<span class="gi">+</span>
<span class="gi">+        if len(nodes) == 1:</span>
<span class="gi">+            # Then the edge will be an isolated node in L.</span>
<span class="gi">+            L.add_node(nodes[0])</span>
<span class="gi">+</span>
<span class="gi">+        # Add a clique of `nodes` to graph. To prevent double adding edges,</span>
<span class="gi">+        # especially important for multigraphs, we store the edges in</span>
<span class="gi">+        # canonical form in a set.</span>
<span class="gi">+        for i, a in enumerate(nodes):</span>
<span class="gi">+            edges.update(</span>
<span class="gi">+                [</span>
<span class="gi">+                    tuple(sorted((a, b), key=edge_key_function))</span>
<span class="gi">+                    for b in nodes[i + shift :]</span>
<span class="gi">+                ]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    L.add_edges_from(edges)</span>
<span class="gi">+    return L</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def inverse_line_graph(G):
<span class="w"> </span>    &quot;&quot;&quot;Returns the inverse line graph of graph G.
<span class="gu">@@ -212,12 +266,61 @@ def inverse_line_graph(G):</span>
<span class="w"> </span>       `DOI link &lt;https://doi.org/10.1016/0020-0190(73)90029-X&gt;`_

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.number_of_nodes() == 0:</span>
<span class="gi">+        return nx.empty_graph(1)</span>
<span class="gi">+    elif G.number_of_nodes() == 1:</span>
<span class="gi">+        v = arbitrary_element(G)</span>
<span class="gi">+        a = (v, 0)</span>
<span class="gi">+        b = (v, 1)</span>
<span class="gi">+        H = nx.Graph([(a, b)])</span>
<span class="gi">+        return H</span>
<span class="gi">+    elif G.number_of_nodes() &gt; 1 and G.number_of_edges() == 0:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;inverse_line_graph() doesn&#39;t work on an edgeless graph. &quot;</span>
<span class="gi">+            &quot;Please use this function on each component separately.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    if nx.number_of_selfloops(G) != 0:</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;A line graph as generated by NetworkX has no selfloops, so G has no &quot;</span>
<span class="gi">+            &quot;inverse line graph. Please remove the selfloops from G and try again.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    starting_cell = _select_starting_cell(G)</span>
<span class="gi">+    P = _find_partition(G, starting_cell)</span>
<span class="gi">+    # count how many times each vertex appears in the partition set</span>
<span class="gi">+    P_count = {u: 0 for u in G.nodes}</span>
<span class="gi">+    for p in P:</span>
<span class="gi">+        for u in p:</span>
<span class="gi">+            P_count[u] += 1</span>
<span class="gi">+</span>
<span class="gi">+    if max(P_count.values()) &gt; 2:</span>
<span class="gi">+        msg = &quot;G is not a line graph (vertex found in more than two partition cells)&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    W = tuple((u,) for u in P_count if P_count[u] == 1)</span>
<span class="gi">+    H = nx.Graph()</span>
<span class="gi">+    H.add_nodes_from(P)</span>
<span class="gi">+    H.add_nodes_from(W)</span>
<span class="gi">+    for a, b in combinations(H.nodes, 2):</span>
<span class="gi">+        if any(a_bit in b for a_bit in a):</span>
<span class="gi">+            H.add_edge(a, b)</span>
<span class="gi">+    return H</span>


<span class="w"> </span>def _triangles(G, e):
<span class="w"> </span>    &quot;&quot;&quot;Return list of all triangles containing edge e&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    u, v = e</span>
<span class="gi">+    if u not in G:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Vertex {u} not in graph&quot;)</span>
<span class="gi">+    if v not in G[u]:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Edge ({u}, {v}) not in graph&quot;)</span>
<span class="gi">+    triangle_list = []</span>
<span class="gi">+    for x in G[u]:</span>
<span class="gi">+        if x in G[v]:</span>
<span class="gi">+            triangle_list.append((u, v, x))</span>
<span class="gi">+    return triangle_list</span>


<span class="w"> </span>def _odd_triangle(G, T):
<span class="gu">@@ -245,7 +348,19 @@ def _odd_triangle(G, T):</span>
<span class="w"> </span>    triangle.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for u in T:</span>
<span class="gi">+        if u not in G.nodes():</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;Vertex {u} not in graph&quot;)</span>
<span class="gi">+    for e in list(combinations(T, 2)):</span>
<span class="gi">+        if e[0] not in G[e[1]]:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;Edge ({e[0]}, {e[1]}) not in graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    T_nbrs = defaultdict(int)</span>
<span class="gi">+    for t in T:</span>
<span class="gi">+        for v in G[t]:</span>
<span class="gi">+            if v not in T:</span>
<span class="gi">+                T_nbrs[v] += 1</span>
<span class="gi">+    return any(T_nbrs[v] in [1, 3] for v in T_nbrs)</span>


<span class="w"> </span>def _find_partition(G, starting_cell):
<span class="gu">@@ -265,7 +380,32 @@ def _find_partition(G, starting_cell):</span>
<span class="w"> </span>    NetworkXError
<span class="w"> </span>        If a cell is not a complete subgraph then G is not a line graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G_partition = G.copy()</span>
<span class="gi">+    P = [starting_cell]  # partition set</span>
<span class="gi">+    G_partition.remove_edges_from(list(combinations(starting_cell, 2)))</span>
<span class="gi">+    # keep list of partitioned nodes which might have an edge in G_partition</span>
<span class="gi">+    partitioned_vertices = list(starting_cell)</span>
<span class="gi">+    while G_partition.number_of_edges() &gt; 0:</span>
<span class="gi">+        # there are still edges left and so more cells to be made</span>
<span class="gi">+        u = partitioned_vertices.pop()</span>
<span class="gi">+        deg_u = len(G_partition[u])</span>
<span class="gi">+        if deg_u != 0:</span>
<span class="gi">+            # if u still has edges then we need to find its other cell</span>
<span class="gi">+            # this other cell must be a complete subgraph or else G is</span>
<span class="gi">+            # not a line graph</span>
<span class="gi">+            new_cell = [u] + list(G_partition[u])</span>
<span class="gi">+            for u in new_cell:</span>
<span class="gi">+                for v in new_cell:</span>
<span class="gi">+                    if (u != v) and (v not in G_partition[u]):</span>
<span class="gi">+                        msg = (</span>
<span class="gi">+                            &quot;G is not a line graph &quot;</span>
<span class="gi">+                            &quot;(partition cell not a complete subgraph)&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                        raise nx.NetworkXError(msg)</span>
<span class="gi">+            P.append(tuple(new_cell))</span>
<span class="gi">+            G_partition.remove_edges_from(list(combinations(new_cell, 2)))</span>
<span class="gi">+            partitioned_vertices += new_cell</span>
<span class="gi">+    return P</span>


<span class="w"> </span>def _select_starting_cell(G, starting_edge=None):
<span class="gu">@@ -292,4 +432,68 @@ def _select_starting_cell(G, starting_edge=None):</span>
<span class="w"> </span>    specific starting edge. Note that the r, s notation for counting
<span class="w"> </span>    triangles is the same as in the Roussopoulos paper cited above.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if starting_edge is None:</span>
<span class="gi">+        e = arbitrary_element(G.edges())</span>
<span class="gi">+    else:</span>
<span class="gi">+        e = starting_edge</span>
<span class="gi">+        if e[0] not in G.nodes():</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;Vertex {e[0]} not in graph&quot;)</span>
<span class="gi">+        if e[1] not in G[e[0]]:</span>
<span class="gi">+            msg = f&quot;starting_edge ({e[0]}, {e[1]}) is not in the Graph&quot;</span>
<span class="gi">+            raise nx.NetworkXError(msg)</span>
<span class="gi">+    e_triangles = _triangles(G, e)</span>
<span class="gi">+    r = len(e_triangles)</span>
<span class="gi">+    if r == 0:</span>
<span class="gi">+        # there are no triangles containing e, so the starting cell is just e</span>
<span class="gi">+        starting_cell = e</span>
<span class="gi">+    elif r == 1:</span>
<span class="gi">+        # there is exactly one triangle, T, containing e. If other 2 edges</span>
<span class="gi">+        # of T belong only to this triangle then T is starting cell</span>
<span class="gi">+        T = e_triangles[0]</span>
<span class="gi">+        a, b, c = T</span>
<span class="gi">+        # ab was original edge so check the other 2 edges</span>
<span class="gi">+        ac_edges = len(_triangles(G, (a, c)))</span>
<span class="gi">+        bc_edges = len(_triangles(G, (b, c)))</span>
<span class="gi">+        if ac_edges == 1:</span>
<span class="gi">+            if bc_edges == 1:</span>
<span class="gi">+                starting_cell = T</span>
<span class="gi">+            else:</span>
<span class="gi">+                return _select_starting_cell(G, starting_edge=(b, c))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _select_starting_cell(G, starting_edge=(a, c))</span>
<span class="gi">+    else:</span>
<span class="gi">+        # r &gt;= 2 so we need to count the number of odd triangles, s</span>
<span class="gi">+        s = 0</span>
<span class="gi">+        odd_triangles = []</span>
<span class="gi">+        for T in e_triangles:</span>
<span class="gi">+            if _odd_triangle(G, T):</span>
<span class="gi">+                s += 1</span>
<span class="gi">+                odd_triangles.append(T)</span>
<span class="gi">+        if r == 2 and s == 0:</span>
<span class="gi">+            # in this case either triangle works, so just use T</span>
<span class="gi">+            starting_cell = T</span>
<span class="gi">+        elif r - 1 &lt;= s &lt;= r:</span>
<span class="gi">+            # check if odd triangles containing e form complete subgraph</span>
<span class="gi">+            triangle_nodes = set()</span>
<span class="gi">+            for T in odd_triangles:</span>
<span class="gi">+                for x in T:</span>
<span class="gi">+                    triangle_nodes.add(x)</span>
<span class="gi">+</span>
<span class="gi">+            for u in triangle_nodes:</span>
<span class="gi">+                for v in triangle_nodes:</span>
<span class="gi">+                    if u != v and (v not in G[u]):</span>
<span class="gi">+                        msg = (</span>
<span class="gi">+                            &quot;G is not a line graph (odd triangles &quot;</span>
<span class="gi">+                            &quot;do not form complete subgraph)&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                        raise nx.NetworkXError(msg)</span>
<span class="gi">+            # otherwise then we can use this as the starting cell</span>
<span class="gi">+            starting_cell = tuple(triangle_nodes)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                &quot;G is not a line graph (incorrect number of &quot;</span>
<span class="gi">+                &quot;odd triangles around starting edge)&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise nx.NetworkXError(msg)</span>
<span class="gi">+    return starting_cell</span>
<span class="gh">diff --git a/networkx/generators/mycielski.py b/networkx/generators/mycielski.py</span>
<span class="gh">index 0783e5d81..804b90369 100644</span>
<span class="gd">--- a/networkx/generators/mycielski.py</span>
<span class="gi">+++ b/networkx/generators/mycielski.py</span>
<span class="gu">@@ -2,16 +2,18 @@</span>
<span class="w"> </span>of graphs.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;mycielskian&#39;, &#39;mycielski_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;mycielskian&quot;, &quot;mycielski_graph&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="w"> </span>def mycielskian(G, iterations=1):
<span class="gd">-    &quot;&quot;&quot;Returns the Mycielskian of a simple, undirected graph G</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Mycielskian of a simple, undirected graph G</span>

<span class="w"> </span>    The Mycielskian of graph preserves a graph&#39;s triangle free
<span class="w"> </span>    property while increasing the chromatic number by 1.
<span class="gu">@@ -23,9 +25,9 @@ def mycielskian(G, iterations=1):</span>

<span class="w"> </span>    Let :math:`V = {0, ..., n-1}`. Construct another vertex set
<span class="w"> </span>    :math:`U = {n, ..., 2n}` and a vertex, `w`.
<span class="gd">-    Construct a new graph, `M`, with vertices :math:`U \\bigcup V \\bigcup w`.</span>
<span class="gd">-    For edges, :math:`(u, v) \\in E` add edges :math:`(u, v), (u, v + n)`, and</span>
<span class="gd">-    :math:`(u + n, v)` to M. Finally, for all vertices :math:`u \\in U`, add</span>
<span class="gi">+    Construct a new graph, `M`, with vertices :math:`U \bigcup V \bigcup w`.</span>
<span class="gi">+    For edges, :math:`(u, v) \in E` add edges :math:`(u, v), (u, v + n)`, and</span>
<span class="gi">+    :math:`(u + n, v)` to M. Finally, for all vertices :math:`u \in U`, add</span>
<span class="w"> </span>    edge :math:`(u, w)` to M.

<span class="w"> </span>    The Mycielski Operation can be done multiple times by repeating the above
<span class="gu">@@ -51,7 +53,19 @@ def mycielskian(G, iterations=1):</span>
<span class="w"> </span>    Graph, node, and edge data are not necessarily propagated to the new graph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    M = nx.convert_node_labels_to_integers(G)</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(iterations):</span>
<span class="gi">+        n = M.number_of_nodes()</span>
<span class="gi">+        M.add_nodes_from(range(n, 2 * n))</span>
<span class="gi">+        old_edges = list(M.edges())</span>
<span class="gi">+        M.add_edges_from((u, v + n) for u, v in old_edges)</span>
<span class="gi">+        M.add_edges_from((u + n, v) for u, v in old_edges)</span>
<span class="gi">+        M.add_node(2 * n)</span>
<span class="gi">+        M.add_edges_from((u + n, 2 * n) for u in range(n))</span>
<span class="gi">+</span>
<span class="gi">+    return M</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -85,4 +99,12 @@ def mycielski_graph(n):</span>
<span class="w"> </span>    The remaining graphs are generated using the Mycielski operation.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if n &lt; 1:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;must satisfy n &gt;= 1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if n == 1:</span>
<span class="gi">+        return nx.empty_graph(1)</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        return mycielskian(nx.path_graph(2), n - 2)</span>
<span class="gh">diff --git a/networkx/generators/nonisomorphic_trees.py b/networkx/generators/nonisomorphic_trees.py</span>
<span class="gh">index a32533c07..9716cf338 100644</span>
<span class="gd">--- a/networkx/generators/nonisomorphic_trees.py</span>
<span class="gi">+++ b/networkx/generators/nonisomorphic_trees.py</span>
<span class="gu">@@ -6,12 +6,14 @@ lists in which the i-th element specifies the distance of vertex i to</span>
<span class="w"> </span>the root.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;nonisomorphic_trees&#39;, &#39;number_of_nonisomorphic_trees&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;nonisomorphic_trees&quot;, &quot;number_of_nonisomorphic_trees&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def nonisomorphic_trees(order, create=&#39;graph&#39;):</span>
<span class="gi">+def nonisomorphic_trees(order, create=&quot;graph&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generates lists of nonisomorphic trees

<span class="w"> </span>    Parameters
<span class="gu">@@ -40,7 +42,34 @@ def nonisomorphic_trees(order, create=&#39;graph&#39;):</span>
<span class="w"> </span>       - ``create=&quot;graph&quot;``: yields a list of `networkx.Graph` instances
<span class="w"> </span>       - ``create=&quot;matrix&quot;``: yields a list of list-of-lists representing adjacency matrices
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if order &lt; 2:</span>
<span class="gi">+        raise ValueError</span>
<span class="gi">+    # start at the path graph rooted at its center</span>
<span class="gi">+    layout = list(range(order // 2 + 1)) + list(range(1, (order + 1) // 2))</span>
<span class="gi">+</span>
<span class="gi">+    while layout is not None:</span>
<span class="gi">+        layout = _next_tree(layout)</span>
<span class="gi">+        if layout is not None:</span>
<span class="gi">+            if create == &quot;graph&quot;:</span>
<span class="gi">+                yield _layout_to_graph(layout)</span>
<span class="gi">+            elif create == &quot;matrix&quot;:</span>
<span class="gi">+                import warnings</span>
<span class="gi">+</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    (</span>
<span class="gi">+                        &quot;\n\nThe &#39;create=matrix&#39; argument of nonisomorphic_trees\n&quot;</span>
<span class="gi">+                        &quot;is deprecated and will be removed in version 3.5.\n&quot;</span>
<span class="gi">+                        &quot;Use ``nx.to_numpy_array`` to convert graphs to adjacency &quot;</span>
<span class="gi">+                        &quot;matrices, e.g.::\n\n&quot;</span>
<span class="gi">+                        &quot;   [nx.to_numpy_array(G) for G in nx.nonisomorphic_trees(N)]&quot;</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    category=DeprecationWarning,</span>
<span class="gi">+                    stacklevel=2,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                yield _layout_to_matrix(layout)</span>
<span class="gi">+            layout = _next_rooted_tree(layout)</span>


<span class="w"> </span>@nx._dispatchable(graphs=None)
<span class="gu">@@ -60,34 +89,124 @@ def number_of_nonisomorphic_trees(order):</span>
<span class="w"> </span>    ----------

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(1 for _ in nonisomorphic_trees(order))</span>


<span class="w"> </span>def _next_rooted_tree(predecessor, p=None):
<span class="w"> </span>    &quot;&quot;&quot;One iteration of the Beyer-Hedetniemi algorithm.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if p is None:</span>
<span class="gi">+        p = len(predecessor) - 1</span>
<span class="gi">+        while predecessor[p] == 1:</span>
<span class="gi">+            p -= 1</span>
<span class="gi">+    if p == 0:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    q = p - 1</span>
<span class="gi">+    while predecessor[q] != predecessor[p] - 1:</span>
<span class="gi">+        q -= 1</span>
<span class="gi">+    result = list(predecessor)</span>
<span class="gi">+    for i in range(p, len(result)):</span>
<span class="gi">+        result[i] = result[i - p + q]</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def _next_tree(candidate):
<span class="w"> </span>    &quot;&quot;&quot;One iteration of the Wright, Richmond, Odlyzko and McKay
<span class="w"> </span>    algorithm.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # valid representation of a free tree if:</span>
<span class="gi">+    # there are at least two vertices at layer 1</span>
<span class="gi">+    # (this is always the case because we start at the path graph)</span>
<span class="gi">+    left, rest = _split_tree(candidate)</span>
<span class="gi">+</span>
<span class="gi">+    # and the left subtree of the root</span>
<span class="gi">+    # is less high than the tree with the left subtree removed</span>
<span class="gi">+    left_height = max(left)</span>
<span class="gi">+    rest_height = max(rest)</span>
<span class="gi">+    valid = rest_height &gt;= left_height</span>
<span class="gi">+</span>
<span class="gi">+    if valid and rest_height == left_height:</span>
<span class="gi">+        # and, if left and rest are of the same height,</span>
<span class="gi">+        # if left does not encompass more vertices</span>
<span class="gi">+        if len(left) &gt; len(rest):</span>
<span class="gi">+            valid = False</span>
<span class="gi">+        # and, if they have the same number or vertices,</span>
<span class="gi">+        # if left does not come after rest lexicographically</span>
<span class="gi">+        elif len(left) == len(rest) and left &gt; rest:</span>
<span class="gi">+            valid = False</span>
<span class="gi">+</span>
<span class="gi">+    if valid:</span>
<span class="gi">+        return candidate</span>
<span class="gi">+    else:</span>
<span class="gi">+        # jump to the next valid free tree</span>
<span class="gi">+        p = len(left)</span>
<span class="gi">+        new_candidate = _next_rooted_tree(candidate, p)</span>
<span class="gi">+        if candidate[p] &gt; 2:</span>
<span class="gi">+            new_left, new_rest = _split_tree(new_candidate)</span>
<span class="gi">+            new_left_height = max(new_left)</span>
<span class="gi">+            suffix = range(1, new_left_height + 2)</span>
<span class="gi">+            new_candidate[-len(suffix) :] = suffix</span>
<span class="gi">+        return new_candidate</span>


<span class="w"> </span>def _split_tree(layout):
<span class="w"> </span>    &quot;&quot;&quot;Returns a tuple of two layouts, one containing the left
<span class="w"> </span>    subtree of the root vertex, and one containing the original tree
<span class="w"> </span>    with the left subtree removed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    one_found = False</span>
<span class="gi">+    m = None</span>
<span class="gi">+    for i in range(len(layout)):</span>
<span class="gi">+        if layout[i] == 1:</span>
<span class="gi">+            if one_found:</span>
<span class="gi">+                m = i</span>
<span class="gi">+                break</span>
<span class="gi">+            else:</span>
<span class="gi">+                one_found = True</span>
<span class="gi">+</span>
<span class="gi">+    if m is None:</span>
<span class="gi">+        m = len(layout)</span>
<span class="gi">+</span>
<span class="gi">+    left = [layout[i] - 1 for i in range(1, m)]</span>
<span class="gi">+    rest = [0] + [layout[i] for i in range(m, len(layout))]</span>
<span class="gi">+    return (left, rest)</span>


<span class="w"> </span>def _layout_to_matrix(layout):
<span class="w"> </span>    &quot;&quot;&quot;Create the adjacency matrix for the tree specified by the
<span class="w"> </span>    given layout (level sequence).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    result = [[0] * len(layout) for i in range(len(layout))]</span>
<span class="gi">+    stack = []</span>
<span class="gi">+    for i in range(len(layout)):</span>
<span class="gi">+        i_level = layout[i]</span>
<span class="gi">+        if stack:</span>
<span class="gi">+            j = stack[-1]</span>
<span class="gi">+            j_level = layout[j]</span>
<span class="gi">+            while j_level &gt;= i_level:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+                j = stack[-1]</span>
<span class="gi">+                j_level = layout[j]</span>
<span class="gi">+            result[i][j] = result[j][i] = 1</span>
<span class="gi">+        stack.append(i)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def _layout_to_graph(layout):
<span class="w"> </span>    &quot;&quot;&quot;Create a NetworkX Graph for the tree specified by the
<span class="w"> </span>    given layout(level sequence)&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    stack = []</span>
<span class="gi">+    for i in range(len(layout)):</span>
<span class="gi">+        i_level = layout[i]</span>
<span class="gi">+        if stack:</span>
<span class="gi">+            j = stack[-1]</span>
<span class="gi">+            j_level = layout[j]</span>
<span class="gi">+            while j_level &gt;= i_level:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+                j = stack[-1]</span>
<span class="gi">+                j_level = layout[j]</span>
<span class="gi">+            G.add_edge(i, j)</span>
<span class="gi">+        stack.append(i)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/random_clustered.py b/networkx/generators/random_clustered.py</span>
<span class="gh">index c607abb23..edf4b94b3 100644</span>
<span class="gd">--- a/networkx/generators/random_clustered.py</span>
<span class="gi">+++ b/networkx/generators/random_clustered.py</span>
<span class="gu">@@ -2,14 +2,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;random_clustered_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;random_clustered_graph&quot;]</span>


<span class="w"> </span>@py_random_state(2)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def random_clustered_graph(joint_degree_sequence, create_using=None, seed=None</span>
<span class="gd">-    ):</span>
<span class="gd">-    &quot;&quot;&quot;Generate a random graph with the given joint independent edge degree and</span>
<span class="gi">+def random_clustered_graph(joint_degree_sequence, create_using=None, seed=None):</span>
<span class="gi">+    r&quot;&quot;&quot;Generate a random graph with the given joint independent edge degree and</span>
<span class="w"> </span>    triangle degree sequence.

<span class="w"> </span>    This uses a configuration model-like approach to generate a random graph
<span class="gu">@@ -17,7 +17,7 @@ def random_clustered_graph(joint_degree_sequence, create_using=None, seed=None</span>
<span class="w"> </span>    the given joint degree sequence.

<span class="w"> </span>    The joint degree sequence is a list of pairs of integers of the form
<span class="gd">-    $[(d_{1,i}, d_{1,t}), \\dotsc, (d_{n,i}, d_{n,t})]$. According to this list,</span>
<span class="gi">+    $[(d_{1,i}, d_{1,t}), \dotsc, (d_{n,i}, d_{n,t})]$. According to this list,</span>
<span class="w"> </span>    vertex $u$ is a member of $d_{u,t}$ triangles and has $d_{u, i}$ other
<span class="w"> </span>    edges. The number $d_{u,t}$ is the *triangle degree* of $u$ and the number
<span class="w"> </span>    $d_{u,i}$ is the *independent edge degree*.
<span class="gu">@@ -85,4 +85,33 @@ def random_clustered_graph(joint_degree_sequence, create_using=None, seed=None</span>
<span class="w"> </span>    &gt;&gt;&gt; G.remove_edges_from(nx.selfloop_edges(G))

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # In Python 3, zip() returns an iterator. Make this into a list.</span>
<span class="gi">+    joint_degree_sequence = list(joint_degree_sequence)</span>
<span class="gi">+</span>
<span class="gi">+    N = len(joint_degree_sequence)</span>
<span class="gi">+    G = nx.empty_graph(N, create_using, default=nx.MultiGraph)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    ilist = []</span>
<span class="gi">+    tlist = []</span>
<span class="gi">+    for n in G:</span>
<span class="gi">+        degrees = joint_degree_sequence[n]</span>
<span class="gi">+        for icount in range(degrees[0]):</span>
<span class="gi">+            ilist.append(n)</span>
<span class="gi">+        for tcount in range(degrees[1]):</span>
<span class="gi">+            tlist.append(n)</span>
<span class="gi">+</span>
<span class="gi">+    if len(ilist) % 2 != 0 or len(tlist) % 3 != 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Invalid degree sequence&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    seed.shuffle(ilist)</span>
<span class="gi">+    seed.shuffle(tlist)</span>
<span class="gi">+    while ilist:</span>
<span class="gi">+        G.add_edge(ilist.pop(), ilist.pop())</span>
<span class="gi">+    while tlist:</span>
<span class="gi">+        n1 = tlist.pop()</span>
<span class="gi">+        n2 = tlist.pop()</span>
<span class="gi">+        n3 = tlist.pop()</span>
<span class="gi">+        G.add_edges_from([(n1, n2), (n1, n3), (n2, n3)])</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/random_graphs.py b/networkx/generators/random_graphs.py</span>
<span class="gh">index d8339ed31..b6f5ebf62 100644</span>
<span class="gd">--- a/networkx/generators/random_graphs.py</span>
<span class="gi">+++ b/networkx/generators/random_graphs.py</span>
<span class="gu">@@ -2,21 +2,38 @@</span>
<span class="w"> </span>Generators for random graphs.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>import math
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gi">+</span>
<span class="w"> </span>from .classic import complete_graph, empty_graph, path_graph, star_graph
<span class="w"> </span>from .degree_seq import degree_sequence_tree
<span class="gd">-__all__ = [&#39;fast_gnp_random_graph&#39;, &#39;gnp_random_graph&#39;,</span>
<span class="gd">-    &#39;dense_gnm_random_graph&#39;, &#39;gnm_random_graph&#39;, &#39;erdos_renyi_graph&#39;,</span>
<span class="gd">-    &#39;binomial_graph&#39;, &#39;newman_watts_strogatz_graph&#39;, &#39;watts_strogatz_graph&#39;,</span>
<span class="gd">-    &#39;connected_watts_strogatz_graph&#39;, &#39;random_regular_graph&#39;,</span>
<span class="gd">-    &#39;barabasi_albert_graph&#39;, &#39;dual_barabasi_albert_graph&#39;,</span>
<span class="gd">-    &#39;extended_barabasi_albert_graph&#39;, &#39;powerlaw_cluster_graph&#39;,</span>
<span class="gd">-    &#39;random_lobster&#39;, &#39;random_shell_graph&#39;, &#39;random_powerlaw_tree&#39;,</span>
<span class="gd">-    &#39;random_powerlaw_tree_sequence&#39;, &#39;random_kernel_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;fast_gnp_random_graph&quot;,</span>
<span class="gi">+    &quot;gnp_random_graph&quot;,</span>
<span class="gi">+    &quot;dense_gnm_random_graph&quot;,</span>
<span class="gi">+    &quot;gnm_random_graph&quot;,</span>
<span class="gi">+    &quot;erdos_renyi_graph&quot;,</span>
<span class="gi">+    &quot;binomial_graph&quot;,</span>
<span class="gi">+    &quot;newman_watts_strogatz_graph&quot;,</span>
<span class="gi">+    &quot;watts_strogatz_graph&quot;,</span>
<span class="gi">+    &quot;connected_watts_strogatz_graph&quot;,</span>
<span class="gi">+    &quot;random_regular_graph&quot;,</span>
<span class="gi">+    &quot;barabasi_albert_graph&quot;,</span>
<span class="gi">+    &quot;dual_barabasi_albert_graph&quot;,</span>
<span class="gi">+    &quot;extended_barabasi_albert_graph&quot;,</span>
<span class="gi">+    &quot;powerlaw_cluster_graph&quot;,</span>
<span class="gi">+    &quot;random_lobster&quot;,</span>
<span class="gi">+    &quot;random_shell_graph&quot;,</span>
<span class="gi">+    &quot;random_powerlaw_tree&quot;,</span>
<span class="gi">+    &quot;random_powerlaw_tree_sequence&quot;,</span>
<span class="gi">+    &quot;random_kernel_graph&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -57,7 +74,38 @@ def fast_gnp_random_graph(n, p, seed=None, directed=False):</span>
<span class="w"> </span>       &quot;Efficient generation of large random networks&quot;,
<span class="w"> </span>       Phys. Rev. E, 71, 036113, 2005.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(n)</span>
<span class="gi">+</span>
<span class="gi">+    if p &lt;= 0 or p &gt;= 1:</span>
<span class="gi">+        return nx.gnp_random_graph(n, p, seed=seed, directed=directed)</span>
<span class="gi">+</span>
<span class="gi">+    lp = math.log(1.0 - p)</span>
<span class="gi">+</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        G = nx.DiGraph(G)</span>
<span class="gi">+        v = 1</span>
<span class="gi">+        w = -1</span>
<span class="gi">+        while v &lt; n:</span>
<span class="gi">+            lr = math.log(1.0 - seed.random())</span>
<span class="gi">+            w = w + 1 + int(lr / lp)</span>
<span class="gi">+            while w &gt;= v and v &lt; n:</span>
<span class="gi">+                w = w - v</span>
<span class="gi">+                v = v + 1</span>
<span class="gi">+            if v &lt; n:</span>
<span class="gi">+                G.add_edge(w, v)</span>
<span class="gi">+</span>
<span class="gi">+    # Nodes in graph are from 0,n-1 (start with v as the second node index).</span>
<span class="gi">+    v = 1</span>
<span class="gi">+    w = -1</span>
<span class="gi">+    while v &lt; n:</span>
<span class="gi">+        lr = math.log(1.0 - seed.random())</span>
<span class="gi">+        w = w + 1 + int(lr / lp)</span>
<span class="gi">+        while w &gt;= v and v &lt; n:</span>
<span class="gi">+            w = w - v</span>
<span class="gi">+            v = v + 1</span>
<span class="gi">+        if v &lt; n:</span>
<span class="gi">+            G.add_edge(v, w)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -102,9 +150,25 @@ def gnp_random_graph(n, p, seed=None, directed=False):</span>
<span class="w"> </span>    .. [1] P. Erdős and A. Rényi, On Random Graphs, Publ. Math. 6, 290 (1959).
<span class="w"> </span>    .. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        edges = itertools.permutations(range(n), 2)</span>
<span class="gi">+        G = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = itertools.combinations(range(n), 2)</span>
<span class="gi">+        G = nx.Graph()</span>
<span class="gi">+    G.add_nodes_from(range(n))</span>
<span class="gi">+    if p &lt;= 0:</span>
<span class="gi">+        return G</span>
<span class="gi">+    if p &gt;= 1:</span>
<span class="gi">+        return complete_graph(n, create_using=G)</span>
<span class="gi">+</span>
<span class="gi">+    for e in edges:</span>
<span class="gi">+        if seed.random() &lt; p:</span>
<span class="gi">+            G.add_edge(*e)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# add some aliases to common names</span>
<span class="w"> </span>binomial_graph = gnp_random_graph
<span class="w"> </span>erdos_renyi_graph = gnp_random_graph

<span class="gu">@@ -145,7 +209,30 @@ def dense_gnm_random_graph(n, m, seed=None):</span>
<span class="w"> </span>    .. [1] Donald E. Knuth, The Art of Computer Programming,
<span class="w"> </span>        Volume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mmax = n * (n - 1) // 2</span>
<span class="gi">+    if m &gt;= mmax:</span>
<span class="gi">+        G = complete_graph(n)</span>
<span class="gi">+    else:</span>
<span class="gi">+        G = empty_graph(n)</span>
<span class="gi">+</span>
<span class="gi">+    if n == 1 or m &gt;= mmax:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    u = 0</span>
<span class="gi">+    v = 1</span>
<span class="gi">+    t = 0</span>
<span class="gi">+    k = 0</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if seed.randrange(mmax - t) &lt; m - k:</span>
<span class="gi">+            G.add_edge(u, v)</span>
<span class="gi">+            k += 1</span>
<span class="gi">+            if k == m:</span>
<span class="gi">+                return G</span>
<span class="gi">+        t += 1</span>
<span class="gi">+        v += 1</span>
<span class="gi">+        if v == n:  # go to next row of adjacency matrix</span>
<span class="gi">+            u += 1</span>
<span class="gi">+            v = u + 1</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -176,7 +263,32 @@ def gnm_random_graph(n, m, seed=None, directed=False):</span>
<span class="w"> </span>    dense_gnm_random_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        G = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        G = nx.Graph()</span>
<span class="gi">+    G.add_nodes_from(range(n))</span>
<span class="gi">+</span>
<span class="gi">+    if n == 1:</span>
<span class="gi">+        return G</span>
<span class="gi">+    max_edges = n * (n - 1)</span>
<span class="gi">+    if not directed:</span>
<span class="gi">+        max_edges /= 2.0</span>
<span class="gi">+    if m &gt;= max_edges:</span>
<span class="gi">+        return complete_graph(n, create_using=G)</span>
<span class="gi">+</span>
<span class="gi">+    nlist = list(G)</span>
<span class="gi">+    edge_count = 0</span>
<span class="gi">+    while edge_count &lt; m:</span>
<span class="gi">+        # generate random edge,u,v</span>
<span class="gi">+        u = seed.choice(nlist)</span>
<span class="gi">+        v = seed.choice(nlist)</span>
<span class="gi">+        if u == v or G.has_edge(u, v):</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            G.add_edge(u, v)</span>
<span class="gi">+            edge_count = edge_count + 1</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -218,7 +330,36 @@ def newman_watts_strogatz_graph(n, k, p, seed=None):</span>
<span class="w"> </span>       Physics Letters A, 263, 341, 1999.
<span class="w"> </span>       https://doi.org/10.1016/S0375-9601(99)00757-4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if k &gt; n:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;k&gt;=n, choose smaller k or larger n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # If k == n the graph return is a complete graph</span>
<span class="gi">+    if k == n:</span>
<span class="gi">+        return nx.complete_graph(n)</span>
<span class="gi">+</span>
<span class="gi">+    G = empty_graph(n)</span>
<span class="gi">+    nlist = list(G.nodes())</span>
<span class="gi">+    fromv = nlist</span>
<span class="gi">+    # connect the k/2 neighbors</span>
<span class="gi">+    for j in range(1, k // 2 + 1):</span>
<span class="gi">+        tov = fromv[j:] + fromv[0:j]  # the first j are now last</span>
<span class="gi">+        for i in range(len(fromv)):</span>
<span class="gi">+            G.add_edge(fromv[i], tov[i])</span>
<span class="gi">+    # for each edge u-v, with probability p, randomly select existing</span>
<span class="gi">+    # node w and add new edge u-w</span>
<span class="gi">+    e = list(G.edges())</span>
<span class="gi">+    for u, v in e:</span>
<span class="gi">+        if seed.random() &lt; p:</span>
<span class="gi">+            w = seed.choice(nlist)</span>
<span class="gi">+            # no self-loops and reject if edge u-w exists</span>
<span class="gi">+            # is that the correct NWS model?</span>
<span class="gi">+            while w == u or G.has_edge(u, w):</span>
<span class="gi">+                w = seed.choice(nlist)</span>
<span class="gi">+                if G.degree(u) &gt;= n - 1:</span>
<span class="gi">+                    break  # skip this rewiring</span>
<span class="gi">+            else:</span>
<span class="gi">+                G.add_edge(u, w)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -263,7 +404,37 @@ def watts_strogatz_graph(n, k, p, seed=None):</span>
<span class="w"> </span>       Collective dynamics of small-world networks,
<span class="w"> </span>       Nature, 393, pp. 440--442, 1998.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if k &gt; n:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;k&gt;n, choose smaller k or larger n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # If k == n, the graph is complete not Watts-Strogatz</span>
<span class="gi">+    if k == n:</span>
<span class="gi">+        return nx.complete_graph(n)</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    nodes = list(range(n))  # nodes are labeled 0 to n-1</span>
<span class="gi">+    # connect each node to k/2 neighbors</span>
<span class="gi">+    for j in range(1, k // 2 + 1):</span>
<span class="gi">+        targets = nodes[j:] + nodes[0:j]  # first j nodes are now last in list</span>
<span class="gi">+        G.add_edges_from(zip(nodes, targets))</span>
<span class="gi">+    # rewire edges from each node</span>
<span class="gi">+    # loop over all nodes in order (label) and neighbors in order (distance)</span>
<span class="gi">+    # no self loops or multiple edges allowed</span>
<span class="gi">+    for j in range(1, k // 2 + 1):  # outer loop is neighbors</span>
<span class="gi">+        targets = nodes[j:] + nodes[0:j]  # first j nodes are now last in list</span>
<span class="gi">+        # inner loop in node order</span>
<span class="gi">+        for u, v in zip(nodes, targets):</span>
<span class="gi">+            if seed.random() &lt; p:</span>
<span class="gi">+                w = seed.choice(nodes)</span>
<span class="gi">+                # Enforce no self-loops or multiple edges</span>
<span class="gi">+                while w == u or G.has_edge(u, w):</span>
<span class="gi">+                    w = seed.choice(nodes)</span>
<span class="gi">+                    if G.degree(u) &gt;= n - 1:</span>
<span class="gi">+                        break  # skip this rewiring</span>
<span class="gi">+                else:</span>
<span class="gi">+                    G.remove_edge(u, v)</span>
<span class="gi">+                    G.add_edge(u, w)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(4)
<span class="gu">@@ -311,13 +482,18 @@ def connected_watts_strogatz_graph(n, k, p, tries=100, seed=None):</span>
<span class="w"> </span>       Collective dynamics of small-world networks,
<span class="w"> </span>       Nature, 393, pp. 440--442, 1998.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for i in range(tries):</span>
<span class="gi">+        # seed is an RNG so should change sequence each call</span>
<span class="gi">+        G = watts_strogatz_graph(n, k, p, seed)</span>
<span class="gi">+        if nx.is_connected(G):</span>
<span class="gi">+            return G</span>
<span class="gi">+    raise nx.NetworkXError(&quot;Maximum number of tries exceeded&quot;)</span>


<span class="w"> </span>@py_random_state(2)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_regular_graph(d, n, seed=None):
<span class="gd">-    &quot;&quot;&quot;Returns a random $d$-regular graph on $n$ nodes.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a random $d$-regular graph on $n$ nodes.</span>

<span class="w"> </span>    A regular graph is a graph where each node has the same number of neighbors.

<span class="gu">@@ -328,7 +504,7 @@ def random_regular_graph(d, n, seed=None):</span>
<span class="w"> </span>    d : int
<span class="w"> </span>      The degree of each node.
<span class="w"> </span>    n : integer
<span class="gd">-      The number of nodes. The value of $n \\times d$ must be even.</span>
<span class="gi">+      The number of nodes. The value of $n \times d$ must be even.</span>
<span class="w"> </span>    seed : integer, random_state, or None (default)
<span class="w"> </span>        Indicator of random number generation state.
<span class="w"> </span>        See :ref:`Randomness&lt;randomness&gt;`.
<span class="gu">@@ -339,13 +515,13 @@ def random_regular_graph(d, n, seed=None):</span>

<span class="w"> </span>    Kim and Vu&#39;s paper [2]_ shows that this algorithm samples in an
<span class="w"> </span>    asymptotically uniform way from the space of random graphs when
<span class="gd">-    $d = O(n^{1 / 3 - \\epsilon})$.</span>
<span class="gi">+    $d = O(n^{1 / 3 - \epsilon})$.</span>

<span class="w"> </span>    Raises
<span class="w"> </span>    ------

<span class="w"> </span>    NetworkXError
<span class="gd">-        If $n \\times d$ is odd or $d$ is greater than or equal to $n$.</span>
<span class="gi">+        If $n \times d$ is odd or $d$ is greater than or equal to $n$.</span>

<span class="w"> </span>    References
<span class="w"> </span>    ----------
<span class="gu">@@ -360,7 +536,74 @@ def random_regular_graph(d, n, seed=None):</span>
<span class="w"> </span>       San Diego, CA, USA, pp 213--222, 2003.
<span class="w"> </span>       http://portal.acm.org/citation.cfm?id=780542.780576
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (n * d) % 2 != 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;n * d must be even&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not 0 &lt;= d &lt; n:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;the 0 &lt;= d &lt; n inequality must be satisfied&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if d == 0:</span>
<span class="gi">+        return empty_graph(n)</span>
<span class="gi">+</span>
<span class="gi">+    def _suitable(edges, potential_edges):</span>
<span class="gi">+        # Helper subroutine to check if there are suitable edges remaining</span>
<span class="gi">+        # If False, the generation of the graph has failed</span>
<span class="gi">+        if not potential_edges:</span>
<span class="gi">+            return True</span>
<span class="gi">+        for s1 in potential_edges:</span>
<span class="gi">+            for s2 in potential_edges:</span>
<span class="gi">+                # Two iterators on the same dictionary are guaranteed</span>
<span class="gi">+                # to visit it in the same order if there are no</span>
<span class="gi">+                # intervening modifications.</span>
<span class="gi">+                if s1 == s2:</span>
<span class="gi">+                    # Only need to consider s1-s2 pair one time</span>
<span class="gi">+                    break</span>
<span class="gi">+                if s1 &gt; s2:</span>
<span class="gi">+                    s1, s2 = s2, s1</span>
<span class="gi">+                if (s1, s2) not in edges:</span>
<span class="gi">+                    return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _try_creation():</span>
<span class="gi">+        # Attempt to create an edge set</span>
<span class="gi">+</span>
<span class="gi">+        edges = set()</span>
<span class="gi">+        stubs = list(range(n)) * d</span>
<span class="gi">+</span>
<span class="gi">+        while stubs:</span>
<span class="gi">+            potential_edges = defaultdict(lambda: 0)</span>
<span class="gi">+            seed.shuffle(stubs)</span>
<span class="gi">+            stubiter = iter(stubs)</span>
<span class="gi">+            for s1, s2 in zip(stubiter, stubiter):</span>
<span class="gi">+                if s1 &gt; s2:</span>
<span class="gi">+                    s1, s2 = s2, s1</span>
<span class="gi">+                if s1 != s2 and ((s1, s2) not in edges):</span>
<span class="gi">+                    edges.add((s1, s2))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    potential_edges[s1] += 1</span>
<span class="gi">+                    potential_edges[s2] += 1</span>
<span class="gi">+</span>
<span class="gi">+            if not _suitable(edges, potential_edges):</span>
<span class="gi">+                return None  # failed to find suitable edge set</span>
<span class="gi">+</span>
<span class="gi">+            stubs = [</span>
<span class="gi">+                node</span>
<span class="gi">+                for node, potential in potential_edges.items()</span>
<span class="gi">+                for _ in range(potential)</span>
<span class="gi">+            ]</span>
<span class="gi">+        return edges</span>
<span class="gi">+</span>
<span class="gi">+    # Even though a suitable edge set exists,</span>
<span class="gi">+    # the generation of such a set is not guaranteed.</span>
<span class="gi">+    # Try repeatedly to find one.</span>
<span class="gi">+    edges = _try_creation()</span>
<span class="gi">+    while edges is None:</span>
<span class="gi">+        edges = _try_creation()</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    G.add_edges_from(edges)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>def _random_subset(seq, m, rng):
<span class="gu">@@ -371,7 +614,11 @@ def _random_subset(seq, m, rng):</span>

<span class="w"> </span>    Note: rng is a random.Random or numpy.random.RandomState instance.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    targets = set()</span>
<span class="gi">+    while len(targets) &lt; m:</span>
<span class="gi">+        x = rng.choice(seq)</span>
<span class="gi">+        targets.add(x)</span>
<span class="gi">+    return targets</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -412,7 +659,39 @@ def barabasi_albert_graph(n, m, seed=None, initial_graph=None):</span>
<span class="w"> </span>    .. [1] A. L. Barabási and R. Albert &quot;Emergence of scaling in
<span class="w"> </span>       random networks&quot;, Science 286, pp 509-512, 1999.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if m &lt; 1 or m &gt;= n:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;Barabási–Albert network must have m &gt;= 1 and m &lt; n, m = {m}, n = {n}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if initial_graph is None:</span>
<span class="gi">+        # Default initial graph : star graph on (m + 1) nodes</span>
<span class="gi">+        G = star_graph(m)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if len(initial_graph) &lt; m or len(initial_graph) &gt; n:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;Barabási–Albert initial graph needs between m={m} and n={n} nodes&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        G = initial_graph.copy()</span>
<span class="gi">+</span>
<span class="gi">+    # List of existing nodes, with nodes repeated once for each adjacent edge</span>
<span class="gi">+    repeated_nodes = [n for n, d in G.degree() for _ in range(d)]</span>
<span class="gi">+    # Start adding the other n - m0 nodes.</span>
<span class="gi">+    source = len(G)</span>
<span class="gi">+    while source &lt; n:</span>
<span class="gi">+        # Now choose m unique nodes from the existing nodes</span>
<span class="gi">+        # Pick uniformly from repeated_nodes (preferential attachment)</span>
<span class="gi">+        targets = _random_subset(repeated_nodes, m, seed)</span>
<span class="gi">+        # Add edges to m nodes from the source.</span>
<span class="gi">+        G.add_edges_from(zip([source] * m, targets))</span>
<span class="gi">+        # Add one node to the list for each new edge just created.</span>
<span class="gi">+        repeated_nodes.extend(targets)</span>
<span class="gi">+        # And the new node &quot;source&quot; has m edges to add to the list.</span>
<span class="gi">+        repeated_nodes.extend([source] * m)</span>
<span class="gi">+</span>
<span class="gi">+        source += 1</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(4)
<span class="gu">@@ -458,7 +737,61 @@ def dual_barabasi_albert_graph(n, m1, m2, p, seed=None, initial_graph=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] N. Moshiri &quot;The dual-Barabasi-Albert model&quot;, arXiv:1810.10538.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if m1 &lt; 1 or m1 &gt;= n:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;Dual Barabási–Albert must have m1 &gt;= 1 and m1 &lt; n, m1 = {m1}, n = {n}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if m2 &lt; 1 or m2 &gt;= n:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;Dual Barabási–Albert must have m2 &gt;= 1 and m2 &lt; n, m2 = {m2}, n = {n}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if p &lt; 0 or p &gt; 1:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            f&quot;Dual Barabási–Albert network must have 0 &lt;= p &lt;= 1, p = {p}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # For simplicity, if p == 0 or 1, just return BA</span>
<span class="gi">+    if p == 1:</span>
<span class="gi">+        return barabasi_albert_graph(n, m1, seed)</span>
<span class="gi">+    elif p == 0:</span>
<span class="gi">+        return barabasi_albert_graph(n, m2, seed)</span>
<span class="gi">+</span>
<span class="gi">+    if initial_graph is None:</span>
<span class="gi">+        # Default initial graph : empty graph on max(m1, m2) nodes</span>
<span class="gi">+        G = star_graph(max(m1, m2))</span>
<span class="gi">+    else:</span>
<span class="gi">+        if len(initial_graph) &lt; max(m1, m2) or len(initial_graph) &gt; n:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;Barabási–Albert initial graph must have between &quot;</span>
<span class="gi">+                f&quot;max(m1, m2) = {max(m1, m2)} and n = {n} nodes&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        G = initial_graph.copy()</span>
<span class="gi">+</span>
<span class="gi">+    # Target nodes for new edges</span>
<span class="gi">+    targets = list(G)</span>
<span class="gi">+    # List of existing nodes, with nodes repeated once for each adjacent edge</span>
<span class="gi">+    repeated_nodes = [n for n, d in G.degree() for _ in range(d)]</span>
<span class="gi">+    # Start adding the remaining nodes.</span>
<span class="gi">+    source = len(G)</span>
<span class="gi">+    while source &lt; n:</span>
<span class="gi">+        # Pick which m to use (m1 or m2)</span>
<span class="gi">+        if seed.random() &lt; p:</span>
<span class="gi">+            m = m1</span>
<span class="gi">+        else:</span>
<span class="gi">+            m = m2</span>
<span class="gi">+        # Now choose m unique nodes from the existing nodes</span>
<span class="gi">+        # Pick uniformly from repeated_nodes (preferential attachment)</span>
<span class="gi">+        targets = _random_subset(repeated_nodes, m, seed)</span>
<span class="gi">+        # Add edges to m nodes from the source.</span>
<span class="gi">+        G.add_edges_from(zip([source] * m, targets))</span>
<span class="gi">+        # Add one node to the list for each new edge just created.</span>
<span class="gi">+        repeated_nodes.extend(targets)</span>
<span class="gi">+        # And the new node &quot;source&quot; has m edges to add to the list.</span>
<span class="gi">+        repeated_nodes.extend([source] * m)</span>
<span class="gi">+</span>
<span class="gi">+        source += 1</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(4)
<span class="gu">@@ -511,7 +844,115 @@ def extended_barabasi_albert_graph(n, m, p, q, seed=None):</span>
<span class="w"> </span>       Topology of evolving networks: local events and universality
<span class="w"> </span>       Physical review letters, 85(24), 5234.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if m &lt; 1 or m &gt;= n:</span>
<span class="gi">+        msg = f&quot;Extended Barabasi-Albert network needs m&gt;=1 and m&lt;n, m={m}, n={n}&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+    if p + q &gt;= 1:</span>
<span class="gi">+        msg = f&quot;Extended Barabasi-Albert network needs p + q &lt;= 1, p={p}, q={q}&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # Add m initial nodes (m0 in barabasi-speak)</span>
<span class="gi">+    G = empty_graph(m)</span>
<span class="gi">+</span>
<span class="gi">+    # List of nodes to represent the preferential attachment random selection.</span>
<span class="gi">+    # At the creation of the graph, all nodes are added to the list</span>
<span class="gi">+    # so that even nodes that are not connected have a chance to get selected,</span>
<span class="gi">+    # for rewiring and adding of edges.</span>
<span class="gi">+    # With each new edge, nodes at the ends of the edge are added to the list.</span>
<span class="gi">+    attachment_preference = []</span>
<span class="gi">+    attachment_preference.extend(range(m))</span>
<span class="gi">+</span>
<span class="gi">+    # Start adding the other n-m nodes. The first node is m.</span>
<span class="gi">+    new_node = m</span>
<span class="gi">+    while new_node &lt; n:</span>
<span class="gi">+        a_probability = seed.random()</span>
<span class="gi">+</span>
<span class="gi">+        # Total number of edges of a Clique of all the nodes</span>
<span class="gi">+        clique_degree = len(G) - 1</span>
<span class="gi">+        clique_size = (len(G) * clique_degree) / 2</span>
<span class="gi">+</span>
<span class="gi">+        # Adding m new edges, if there is room to add them</span>
<span class="gi">+        if a_probability &lt; p and G.size() &lt;= clique_size - m:</span>
<span class="gi">+            # Select the nodes where an edge can be added</span>
<span class="gi">+            eligible_nodes = [nd for nd, deg in G.degree() if deg &lt; clique_degree]</span>
<span class="gi">+            for i in range(m):</span>
<span class="gi">+                # Choosing a random source node from eligible_nodes</span>
<span class="gi">+                src_node = seed.choice(eligible_nodes)</span>
<span class="gi">+</span>
<span class="gi">+                # Picking a possible node that is not &#39;src_node&#39; or</span>
<span class="gi">+                # neighbor with &#39;src_node&#39;, with preferential attachment</span>
<span class="gi">+                prohibited_nodes = list(G[src_node])</span>
<span class="gi">+                prohibited_nodes.append(src_node)</span>
<span class="gi">+                # This will raise an exception if the sequence is empty</span>
<span class="gi">+                dest_node = seed.choice(</span>
<span class="gi">+                    [nd for nd in attachment_preference if nd not in prohibited_nodes]</span>
<span class="gi">+                )</span>
<span class="gi">+                # Adding the new edge</span>
<span class="gi">+                G.add_edge(src_node, dest_node)</span>
<span class="gi">+</span>
<span class="gi">+                # Appending both nodes to add to their preferential attachment</span>
<span class="gi">+                attachment_preference.append(src_node)</span>
<span class="gi">+                attachment_preference.append(dest_node)</span>
<span class="gi">+</span>
<span class="gi">+                # Adjusting the eligible nodes. Degree may be saturated.</span>
<span class="gi">+                if G.degree(src_node) == clique_degree:</span>
<span class="gi">+                    eligible_nodes.remove(src_node)</span>
<span class="gi">+                if G.degree(dest_node) == clique_degree and dest_node in eligible_nodes:</span>
<span class="gi">+                    eligible_nodes.remove(dest_node)</span>
<span class="gi">+</span>
<span class="gi">+        # Rewiring m edges, if there are enough edges</span>
<span class="gi">+        elif p &lt;= a_probability &lt; (p + q) and m &lt;= G.size() &lt; clique_size:</span>
<span class="gi">+            # Selecting nodes that have at least 1 edge but that are not</span>
<span class="gi">+            # fully connected to ALL other nodes (center of star).</span>
<span class="gi">+            # These nodes are the pivot nodes of the edges to rewire</span>
<span class="gi">+            eligible_nodes = [nd for nd, deg in G.degree() if 0 &lt; deg &lt; clique_degree]</span>
<span class="gi">+            for i in range(m):</span>
<span class="gi">+                # Choosing a random source node</span>
<span class="gi">+                node = seed.choice(eligible_nodes)</span>
<span class="gi">+</span>
<span class="gi">+                # The available nodes do have a neighbor at least.</span>
<span class="gi">+                nbr_nodes = list(G[node])</span>
<span class="gi">+</span>
<span class="gi">+                # Choosing the other end that will get detached</span>
<span class="gi">+                src_node = seed.choice(nbr_nodes)</span>
<span class="gi">+</span>
<span class="gi">+                # Picking a target node that is not &#39;node&#39; or</span>
<span class="gi">+                # neighbor with &#39;node&#39;, with preferential attachment</span>
<span class="gi">+                nbr_nodes.append(node)</span>
<span class="gi">+                dest_node = seed.choice(</span>
<span class="gi">+                    [nd for nd in attachment_preference if nd not in nbr_nodes]</span>
<span class="gi">+                )</span>
<span class="gi">+                # Rewire</span>
<span class="gi">+                G.remove_edge(node, src_node)</span>
<span class="gi">+                G.add_edge(node, dest_node)</span>
<span class="gi">+</span>
<span class="gi">+                # Adjusting the preferential attachment list</span>
<span class="gi">+                attachment_preference.remove(src_node)</span>
<span class="gi">+                attachment_preference.append(dest_node)</span>
<span class="gi">+</span>
<span class="gi">+                # Adjusting the eligible nodes.</span>
<span class="gi">+                # nodes may be saturated or isolated.</span>
<span class="gi">+                if G.degree(src_node) == 0 and src_node in eligible_nodes:</span>
<span class="gi">+                    eligible_nodes.remove(src_node)</span>
<span class="gi">+                if dest_node in eligible_nodes:</span>
<span class="gi">+                    if G.degree(dest_node) == clique_degree:</span>
<span class="gi">+                        eligible_nodes.remove(dest_node)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if G.degree(dest_node) == 1:</span>
<span class="gi">+                        eligible_nodes.append(dest_node)</span>
<span class="gi">+</span>
<span class="gi">+        # Adding new node with m edges</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Select the edges&#39; nodes by preferential attachment</span>
<span class="gi">+            targets = _random_subset(attachment_preference, m, seed)</span>
<span class="gi">+            G.add_edges_from(zip([new_node] * m, targets))</span>
<span class="gi">+</span>
<span class="gi">+            # Add one node to the list for each new edge just created.</span>
<span class="gi">+            attachment_preference.extend(targets)</span>
<span class="gi">+            # The new node has m edges to it, plus itself: m + 1</span>
<span class="gi">+            attachment_preference.extend([new_node] * (m + 1))</span>
<span class="gi">+            new_node += 1</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -562,7 +1003,46 @@ def powerlaw_cluster_graph(n, m, p, seed=None):</span>
<span class="w"> </span>       &quot;Growing scale-free networks with tunable clustering&quot;,
<span class="w"> </span>       Phys. Rev. E, 65, 026107, 2002.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if m &lt; 1 or n &lt; m:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;NetworkXError must have m&gt;1 and m&lt;n, m={m},n={n}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if p &gt; 1 or p &lt; 0:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;NetworkXError p must be in [0,1], p={p}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    G = empty_graph(m)  # add m initial nodes (m0 in barabasi-speak)</span>
<span class="gi">+    repeated_nodes = list(G.nodes())  # list of existing nodes to sample from</span>
<span class="gi">+    # with nodes repeated once for each adjacent edge</span>
<span class="gi">+    source = m  # next node is m</span>
<span class="gi">+    while source &lt; n:  # Now add the other n-1 nodes</span>
<span class="gi">+        possible_targets = _random_subset(repeated_nodes, m, seed)</span>
<span class="gi">+        # do one preferential attachment for new node</span>
<span class="gi">+        target = possible_targets.pop()</span>
<span class="gi">+        G.add_edge(source, target)</span>
<span class="gi">+        repeated_nodes.append(target)  # add one node to list for each new link</span>
<span class="gi">+        count = 1</span>
<span class="gi">+        while count &lt; m:  # add m-1 more new links</span>
<span class="gi">+            if seed.random() &lt; p:  # clustering step: add triangle</span>
<span class="gi">+                neighborhood = [</span>
<span class="gi">+                    nbr</span>
<span class="gi">+                    for nbr in G.neighbors(target)</span>
<span class="gi">+                    if not G.has_edge(source, nbr) and nbr != source</span>
<span class="gi">+                ]</span>
<span class="gi">+                if neighborhood:  # if there is a neighbor without a link</span>
<span class="gi">+                    nbr = seed.choice(neighborhood)</span>
<span class="gi">+                    G.add_edge(source, nbr)  # add triangle</span>
<span class="gi">+                    repeated_nodes.append(nbr)</span>
<span class="gi">+                    count = count + 1</span>
<span class="gi">+                    continue  # go to top of while loop</span>
<span class="gi">+            # else do preferential attachment step if above fails</span>
<span class="gi">+            target = possible_targets.pop()</span>
<span class="gi">+            G.add_edge(source, target)</span>
<span class="gi">+            repeated_nodes.append(target)</span>
<span class="gi">+            count = count + 1</span>
<span class="gi">+</span>
<span class="gi">+        repeated_nodes.extend([source] * m)  # add source node to list m times</span>
<span class="gi">+        source += 1</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -596,7 +1076,24 @@ def random_lobster(n, p1, p2, seed=None):</span>
<span class="w"> </span>    NetworkXError
<span class="w"> </span>        If `p1` or `p2` parameters are &gt;= 1 because the while loops would never finish.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    p1, p2 = abs(p1), abs(p2)</span>
<span class="gi">+    if any(p &gt;= 1 for p in [p1, p2]):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Probability values for `p1` and `p2` must both be &lt; 1.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # a necessary ingredient in any self-respecting graph library</span>
<span class="gi">+    llen = int(2 * seed.random() * n + 0.5)</span>
<span class="gi">+    L = path_graph(llen)</span>
<span class="gi">+    # build caterpillar: add edges to path graph with probability p1</span>
<span class="gi">+    current_node = llen - 1</span>
<span class="gi">+    for n in range(llen):</span>
<span class="gi">+        while seed.random() &lt; p1:  # add fuzzy caterpillar parts</span>
<span class="gi">+            current_node += 1</span>
<span class="gi">+            L.add_edge(n, current_node)</span>
<span class="gi">+            cat_node = current_node</span>
<span class="gi">+            while seed.random() &lt; p2:  # add crunchy lobster bits</span>
<span class="gi">+                current_node += 1</span>
<span class="gi">+                L.add_edge(cat_node, current_node)</span>
<span class="gi">+    return L  # voila, un lobster!</span>


<span class="w"> </span>@py_random_state(1)
<span class="gu">@@ -624,7 +1121,37 @@ def random_shell_graph(constructor, seed=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; G = nx.random_shell_graph(constructor)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(0)</span>
<span class="gi">+</span>
<span class="gi">+    glist = []</span>
<span class="gi">+    intra_edges = []</span>
<span class="gi">+    nnodes = 0</span>
<span class="gi">+    # create gnm graphs for each shell</span>
<span class="gi">+    for n, m, d in constructor:</span>
<span class="gi">+        inter_edges = int(m * d)</span>
<span class="gi">+        intra_edges.append(m - inter_edges)</span>
<span class="gi">+        g = nx.convert_node_labels_to_integers(</span>
<span class="gi">+            gnm_random_graph(n, inter_edges, seed=seed), first_label=nnodes</span>
<span class="gi">+        )</span>
<span class="gi">+        glist.append(g)</span>
<span class="gi">+        nnodes += n</span>
<span class="gi">+        G = nx.operators.union(G, g)</span>
<span class="gi">+</span>
<span class="gi">+    # connect the shells randomly</span>
<span class="gi">+    for gi in range(len(glist) - 1):</span>
<span class="gi">+        nlist1 = list(glist[gi])</span>
<span class="gi">+        nlist2 = list(glist[gi + 1])</span>
<span class="gi">+        total_edges = intra_edges[gi]</span>
<span class="gi">+        edge_count = 0</span>
<span class="gi">+        while edge_count &lt; total_edges:</span>
<span class="gi">+            u = seed.choice(nlist1)</span>
<span class="gi">+            v = seed.choice(nlist2)</span>
<span class="gi">+            if u == v or G.has_edge(u, v):</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                G.add_edge(u, v)</span>
<span class="gi">+                edge_count = edge_count + 1</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -658,7 +1185,10 @@ def random_powerlaw_tree(n, gamma=3, seed=None, tries=100):</span>
<span class="w"> </span>    edges is one smaller than the number of nodes).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # This call may raise a NetworkXError if the number of tries is succeeded.</span>
<span class="gi">+    seq = random_powerlaw_tree_sequence(n, gamma=gamma, seed=seed, tries=tries)</span>
<span class="gi">+    G = degree_sequence_tree(seq)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -692,17 +1222,40 @@ def random_powerlaw_tree_sequence(n, gamma=3, seed=None, tries=100):</span>
<span class="w"> </span>    edges is one smaller than the number of nodes).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # get trial sequence</span>
<span class="gi">+    z = nx.utils.powerlaw_sequence(n, exponent=gamma, seed=seed)</span>
<span class="gi">+    # round to integer values in the range [0,n]</span>
<span class="gi">+    zseq = [min(n, max(round(s), 0)) for s in z]</span>
<span class="gi">+</span>
<span class="gi">+    # another sequence to swap values from</span>
<span class="gi">+    z = nx.utils.powerlaw_sequence(tries, exponent=gamma, seed=seed)</span>
<span class="gi">+    # round to integer values in the range [0,n]</span>
<span class="gi">+    swap = [min(n, max(round(s), 0)) for s in z]</span>
<span class="gi">+</span>
<span class="gi">+    for deg in swap:</span>
<span class="gi">+        # If this degree sequence can be the degree sequence of a tree, return</span>
<span class="gi">+        # it. It can be a tree if the number of edges is one fewer than the</span>
<span class="gi">+        # number of nodes, or in other words, `n - sum(zseq) / 2 == 1`. We</span>
<span class="gi">+        # use an equivalent condition below that avoids floating point</span>
<span class="gi">+        # operations.</span>
<span class="gi">+        if 2 * n - sum(zseq) == 2:</span>
<span class="gi">+            return zseq</span>
<span class="gi">+        index = seed.randint(0, n - 1)</span>
<span class="gi">+        zseq[index] = swap.pop()</span>
<span class="gi">+</span>
<span class="gi">+    raise nx.NetworkXError(</span>
<span class="gi">+        f&quot;Exceeded max ({tries}) attempts for a valid tree sequence.&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>@py_random_state(3)
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):
<span class="gd">-    &quot;&quot;&quot;Returns an random graph based on the specified kernel.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns an random graph based on the specified kernel.</span>

<span class="w"> </span>    The algorithm chooses each of the $[n(n-1)]/2$ possible edges with
<span class="gd">-    probability specified by a kernel $\\kappa(x,y)$ [1]_.  The kernel</span>
<span class="gd">-    $\\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,</span>
<span class="gi">+    probability specified by a kernel $\kappa(x,y)$ [1]_.  The kernel</span>
<span class="gi">+    $\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,</span>
<span class="w"> </span>    bounded function.

<span class="w"> </span>    Parameters
<span class="gu">@@ -710,8 +1263,8 @@ def random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):</span>
<span class="w"> </span>    n : int
<span class="w"> </span>        The number of nodes
<span class="w"> </span>    kernel_integral : function
<span class="gd">-        Function that returns the definite integral of the kernel $\\kappa(x,y)$,</span>
<span class="gd">-        $F(y,a,b) := \\int_a^b \\kappa(x,y)dx$</span>
<span class="gi">+        Function that returns the definite integral of the kernel $\kappa(x,y)$,</span>
<span class="gi">+        $F(y,a,b) := \int_a^b \kappa(x,y)dx$</span>
<span class="w"> </span>    kernel_root: function (optional)
<span class="w"> </span>        Function that returns the root $b$ of the equation $F(y,a,b) = r$.
<span class="w"> </span>        If None, the root is found using :func:`scipy.optimize.brentq`
<span class="gu">@@ -732,7 +1285,7 @@ def random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):</span>
<span class="w"> </span>    Examples
<span class="w"> </span>    --------
<span class="w"> </span>    Generate an Erdős–Rényi random graph $G(n,c/n)$, with kernel
<span class="gd">-    $\\kappa(x,y)=c$ where $c$ is the mean expected degree.</span>
<span class="gi">+    $\kappa(x,y)=c$ where $c$ is the mean expected degree.</span>

<span class="w"> </span>    &gt;&gt;&gt; def integral(u, w, z):
<span class="w"> </span>    ...     return c * (z - w)
<span class="gu">@@ -756,4 +1309,23 @@ def random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):</span>
<span class="w"> </span>       &quot;Fast Generation of Sparse Random Kernel Graphs&quot;.
<span class="w"> </span>       PLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if kernel_root is None:</span>
<span class="gi">+        import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+        def kernel_root(y, a, r):</span>
<span class="gi">+            def my_function(b):</span>
<span class="gi">+                return kernel_integral(y, a, b) - r</span>
<span class="gi">+</span>
<span class="gi">+            return sp.optimize.brentq(my_function, a, 1)</span>
<span class="gi">+</span>
<span class="gi">+    graph = nx.Graph()</span>
<span class="gi">+    graph.add_nodes_from(range(n))</span>
<span class="gi">+    (i, j) = (1, 1)</span>
<span class="gi">+    while i &lt; n:</span>
<span class="gi">+        r = -math.log(1 - seed.random())  # (1-seed.random()) in (0, 1]</span>
<span class="gi">+        if kernel_integral(i / n, j / n, 1) &lt;= r:</span>
<span class="gi">+            i, j = i + 1, i + 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            j = math.ceil(n * kernel_root(i / n, j / n, r))</span>
<span class="gi">+            graph.add_edge(i - 1, j - 1)</span>
<span class="gi">+    return graph</span>
<span class="gh">diff --git a/networkx/generators/small.py b/networkx/generators/small.py</span>
<span class="gh">index a019a4826..acd2fbc7a 100644</span>
<span class="gd">--- a/networkx/generators/small.py</span>
<span class="gi">+++ b/networkx/generators/small.py</span>
<span class="gu">@@ -2,18 +2,43 @@</span>
<span class="w"> </span>Various small and named graphs, together with some compact generators.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;LCF_graph&#39;, &#39;bull_graph&#39;, &#39;chvatal_graph&#39;, &#39;cubical_graph&#39;,</span>
<span class="gd">-    &#39;desargues_graph&#39;, &#39;diamond_graph&#39;, &#39;dodecahedral_graph&#39;,</span>
<span class="gd">-    &#39;frucht_graph&#39;, &#39;heawood_graph&#39;, &#39;hoffman_singleton_graph&#39;,</span>
<span class="gd">-    &#39;house_graph&#39;, &#39;house_x_graph&#39;, &#39;icosahedral_graph&#39;,</span>
<span class="gd">-    &#39;krackhardt_kite_graph&#39;, &#39;moebius_kantor_graph&#39;, &#39;octahedral_graph&#39;,</span>
<span class="gd">-    &#39;pappus_graph&#39;, &#39;petersen_graph&#39;, &#39;sedgewick_maze_graph&#39;,</span>
<span class="gd">-    &#39;tetrahedral_graph&#39;, &#39;truncated_cube_graph&#39;,</span>
<span class="gd">-    &#39;truncated_tetrahedron_graph&#39;, &#39;tutte_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;LCF_graph&quot;,</span>
<span class="gi">+    &quot;bull_graph&quot;,</span>
<span class="gi">+    &quot;chvatal_graph&quot;,</span>
<span class="gi">+    &quot;cubical_graph&quot;,</span>
<span class="gi">+    &quot;desargues_graph&quot;,</span>
<span class="gi">+    &quot;diamond_graph&quot;,</span>
<span class="gi">+    &quot;dodecahedral_graph&quot;,</span>
<span class="gi">+    &quot;frucht_graph&quot;,</span>
<span class="gi">+    &quot;heawood_graph&quot;,</span>
<span class="gi">+    &quot;hoffman_singleton_graph&quot;,</span>
<span class="gi">+    &quot;house_graph&quot;,</span>
<span class="gi">+    &quot;house_x_graph&quot;,</span>
<span class="gi">+    &quot;icosahedral_graph&quot;,</span>
<span class="gi">+    &quot;krackhardt_kite_graph&quot;,</span>
<span class="gi">+    &quot;moebius_kantor_graph&quot;,</span>
<span class="gi">+    &quot;octahedral_graph&quot;,</span>
<span class="gi">+    &quot;pappus_graph&quot;,</span>
<span class="gi">+    &quot;petersen_graph&quot;,</span>
<span class="gi">+    &quot;sedgewick_maze_graph&quot;,</span>
<span class="gi">+    &quot;tetrahedral_graph&quot;,</span>
<span class="gi">+    &quot;truncated_cube_graph&quot;,</span>
<span class="gi">+    &quot;truncated_tetrahedron_graph&quot;,</span>
<span class="gi">+    &quot;tutte_graph&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>from functools import wraps
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="gd">-from networkx.generators.classic import complete_graph, cycle_graph, empty_graph, path_graph</span>
<span class="gi">+from networkx.generators.classic import (</span>
<span class="gi">+    complete_graph,</span>
<span class="gi">+    cycle_graph,</span>
<span class="gi">+    empty_graph,</span>
<span class="gi">+    path_graph,</span>
<span class="gi">+)</span>


<span class="w"> </span>def _raise_on_directed(func):
<span class="gu">@@ -22,7 +47,16 @@ def _raise_on_directed(func):</span>
<span class="w"> </span>    NetworkX exception when `create_using` is a DiGraph (class or instance) for
<span class="w"> </span>    graph generators that do not support directed outputs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    @wraps(func)</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        if kwargs.get(&quot;create_using&quot;) is not None:</span>
<span class="gi">+            G = nx.empty_graph(create_using=kwargs[&quot;create_using&quot;])</span>
<span class="gi">+            if G.is_directed():</span>
<span class="gi">+                raise NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+        return func(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -77,7 +111,33 @@ def LCF_graph(n, shift_list, repeats, create_using=None):</span>
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/LCF_notation

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt;= 0:</span>
<span class="gi">+        return empty_graph(0, create_using)</span>
<span class="gi">+</span>
<span class="gi">+    # start with the n-cycle</span>
<span class="gi">+    G = cycle_graph(n, create_using)</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        raise NetworkXError(&quot;Directed Graph not supported&quot;)</span>
<span class="gi">+    G.name = &quot;LCF_graph&quot;</span>
<span class="gi">+    nodes = sorted(G)</span>
<span class="gi">+</span>
<span class="gi">+    n_extra_edges = repeats * len(shift_list)</span>
<span class="gi">+    # edges are added n_extra_edges times</span>
<span class="gi">+    # (not all of these need be new)</span>
<span class="gi">+    if n_extra_edges &lt; 1:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(n_extra_edges):</span>
<span class="gi">+        shift = shift_list[i % len(shift_list)]  # cycle through shift_list</span>
<span class="gi">+        v1 = nodes[i % n]  # cycle repeatedly through nodes</span>
<span class="gi">+        v2 = nodes[(i + shift) % n]</span>
<span class="gi">+        G.add_edge(v1, v2)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# -------------------------------------------------------------------------------</span>
<span class="gi">+#   Various small and named graphs</span>
<span class="gi">+# -------------------------------------------------------------------------------</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -106,7 +166,12 @@ def bull_graph(create_using=None):</span>
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Bull_graph.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 4], 3: [1], 4: [2]},</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Bull Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -135,7 +200,23 @@ def chvatal_graph(create_using=None):</span>
<span class="w"> </span>    .. [2] https://mathworld.wolfram.com/ChvatalGraph.html

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {</span>
<span class="gi">+            0: [1, 4, 6, 9],</span>
<span class="gi">+            1: [2, 5, 7],</span>
<span class="gi">+            2: [3, 6, 8],</span>
<span class="gi">+            3: [4, 7, 9],</span>
<span class="gi">+            4: [5, 8],</span>
<span class="gi">+            5: [10, 11],</span>
<span class="gi">+            6: [10, 11],</span>
<span class="gi">+            7: [8, 11],</span>
<span class="gi">+            8: [10],</span>
<span class="gi">+            9: [10, 11],</span>
<span class="gi">+        },</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Chvatal Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -165,7 +246,21 @@ def cubical_graph(create_using=None):</span>
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Cube#Cubical_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {</span>
<span class="gi">+            0: [1, 3, 4],</span>
<span class="gi">+            1: [0, 2, 7],</span>
<span class="gi">+            2: [1, 3, 6],</span>
<span class="gi">+            3: [0, 2, 5],</span>
<span class="gi">+            4: [0, 5, 7],</span>
<span class="gi">+            5: [3, 4, 6],</span>
<span class="gi">+            6: [2, 5, 7],</span>
<span class="gi">+            7: [1, 4, 6],</span>
<span class="gi">+        },</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Platonic Cubical Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -193,7 +288,9 @@ def desargues_graph(create_using=None):</span>
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Desargues_graph
<span class="w"> </span>    .. [2] https://mathworld.wolfram.com/DesarguesGraph.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = LCF_graph(20, [5, -5, 9, -9], 5, create_using)</span>
<span class="gi">+    G.name = &quot;Desargues Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -219,7 +316,11 @@ def diamond_graph(create_using=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] https://mathworld.wolfram.com/DiamondGraph.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 3], 3: [1, 2]}, create_using=create_using</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Diamond Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -248,7 +349,9 @@ def dodecahedral_graph(create_using=None):</span>
<span class="w"> </span>    .. [2] https://mathworld.wolfram.com/DodecahedralGraph.html

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = LCF_graph(20, [10, 7, 4, -4, -7, 10, -4, 7, -7, 4], 2, create_using)</span>
<span class="gi">+    G.name = &quot;Dodecahedral Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -277,7 +380,25 @@ def frucht_graph(create_using=None):</span>
<span class="w"> </span>    .. [2] https://mathworld.wolfram.com/FruchtGraph.html

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = cycle_graph(7, create_using)</span>
<span class="gi">+    G.add_edges_from(</span>
<span class="gi">+        [</span>
<span class="gi">+            [0, 7],</span>
<span class="gi">+            [1, 7],</span>
<span class="gi">+            [2, 8],</span>
<span class="gi">+            [3, 9],</span>
<span class="gi">+            [4, 9],</span>
<span class="gi">+            [5, 10],</span>
<span class="gi">+            [6, 10],</span>
<span class="gi">+            [7, 11],</span>
<span class="gi">+            [8, 11],</span>
<span class="gi">+            [8, 9],</span>
<span class="gi">+            [10, 11],</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    G.name = &quot;Frucht Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -309,7 +430,9 @@ def heawood_graph(create_using=None):</span>
<span class="w"> </span>    .. [3] https://www.win.tue.nl/~aeb/graphs/Heawood.html

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = LCF_graph(14, [5, -5], 7, create_using)</span>
<span class="gi">+    G.name = &quot;Heawood Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -341,7 +464,18 @@ def hoffman_singleton_graph():</span>
<span class="w"> </span>    .. [3] https://en.wikipedia.org/wiki/Hoffman%E2%80%93Singleton_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    for i in range(5):</span>
<span class="gi">+        for j in range(5):</span>
<span class="gi">+            G.add_edge((&quot;pentagon&quot;, i, j), (&quot;pentagon&quot;, i, (j - 1) % 5))</span>
<span class="gi">+            G.add_edge((&quot;pentagon&quot;, i, j), (&quot;pentagon&quot;, i, (j + 1) % 5))</span>
<span class="gi">+            G.add_edge((&quot;pentagram&quot;, i, j), (&quot;pentagram&quot;, i, (j - 2) % 5))</span>
<span class="gi">+            G.add_edge((&quot;pentagram&quot;, i, j), (&quot;pentagram&quot;, i, (j + 2) % 5))</span>
<span class="gi">+            for k in range(5):</span>
<span class="gi">+                G.add_edge((&quot;pentagon&quot;, i, j), (&quot;pentagram&quot;, k, (i * k + j) % 5))</span>
<span class="gi">+    G = nx.convert_node_labels_to_integers(G)</span>
<span class="gi">+    G.name = &quot;Hoffman-Singleton Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -367,7 +501,12 @@ def house_graph(create_using=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] https://mathworld.wolfram.com/HouseGraph.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {0: [1, 2], 1: [0, 3], 2: [0, 3, 4], 3: [1, 2, 4], 4: [2, 3]},</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;House Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -394,7 +533,10 @@ def house_x_graph(create_using=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] https://mathworld.wolfram.com/HouseGraph.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = house_graph(create_using)</span>
<span class="gi">+    G.add_edges_from([(0, 3), (1, 2)])</span>
<span class="gi">+    G.name = &quot;House-with-X-inside Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -421,7 +563,23 @@ def icosahedral_graph(create_using=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] https://mathworld.wolfram.com/IcosahedralGraph.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {</span>
<span class="gi">+            0: [1, 5, 7, 8, 11],</span>
<span class="gi">+            1: [2, 5, 6, 8],</span>
<span class="gi">+            2: [3, 6, 8, 9],</span>
<span class="gi">+            3: [4, 6, 9, 10],</span>
<span class="gi">+            4: [5, 6, 10, 11],</span>
<span class="gi">+            5: [6, 11],</span>
<span class="gi">+            7: [8, 9, 10, 11],</span>
<span class="gi">+            8: [9],</span>
<span class="gi">+            9: [10],</span>
<span class="gi">+            10: [11],</span>
<span class="gi">+        },</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Platonic Icosahedral Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -456,7 +614,23 @@ def krackhardt_kite_graph(create_using=None):</span>
<span class="w"> </span>       35 (2): 342–369. doi:10.2307/2393394. JSTOR 2393394. June 1990.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {</span>
<span class="gi">+            0: [1, 2, 3, 5],</span>
<span class="gi">+            1: [0, 3, 4, 6],</span>
<span class="gi">+            2: [0, 3, 5],</span>
<span class="gi">+            3: [0, 1, 2, 4, 5, 6],</span>
<span class="gi">+            4: [1, 3, 6],</span>
<span class="gi">+            5: [0, 2, 3, 6, 7],</span>
<span class="gi">+            6: [1, 3, 4, 5, 7],</span>
<span class="gi">+            7: [5, 6, 8],</span>
<span class="gi">+            8: [7, 9],</span>
<span class="gi">+            9: [8],</span>
<span class="gi">+        },</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Krackhardt Kite Social Network&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -483,7 +657,9 @@ def moebius_kantor_graph(create_using=None):</span>
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/M%C3%B6bius%E2%80%93Kantor_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = LCF_graph(16, [5, -5], 8, create_using)</span>
<span class="gi">+    G.name = &quot;Moebius-Kantor Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -514,7 +690,12 @@ def octahedral_graph(create_using=None):</span>
<span class="w"> </span>    .. [2] https://en.wikipedia.org/wiki/Tur%C3%A1n_graph#Special_cases

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {0: [1, 2, 3, 4], 1: [2, 3, 5], 2: [4, 5], 3: [4, 5], 4: [5]},</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Platonic Octahedral Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -535,7 +716,9 @@ def pappus_graph():</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Pappus_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = LCF_graph(18, [5, 7, -7, 7, -7, -5], 3)</span>
<span class="gi">+    G.name = &quot;Pappus Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -564,7 +747,23 @@ def petersen_graph(create_using=None):</span>
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Petersen_graph
<span class="w"> </span>    .. [2] https://www.win.tue.nl/~aeb/drg/graphs/Petersen.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {</span>
<span class="gi">+            0: [1, 4, 5],</span>
<span class="gi">+            1: [0, 2, 6],</span>
<span class="gi">+            2: [1, 3, 7],</span>
<span class="gi">+            3: [2, 4, 8],</span>
<span class="gi">+            4: [3, 0, 9],</span>
<span class="gi">+            5: [0, 7, 8],</span>
<span class="gi">+            6: [1, 8, 9],</span>
<span class="gi">+            7: [2, 5, 9],</span>
<span class="gi">+            8: [3, 5, 6],</span>
<span class="gi">+            9: [4, 6, 7],</span>
<span class="gi">+        },</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Petersen Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -590,7 +789,14 @@ def sedgewick_maze_graph(create_using=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] Figure 18.2, Chapter 18, Graph Algorithms (3rd Ed), Sedgewick
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = empty_graph(0, create_using)</span>
<span class="gi">+    G.add_nodes_from(range(8))</span>
<span class="gi">+    G.add_edges_from([[0, 2], [0, 7], [0, 5]])</span>
<span class="gi">+    G.add_edges_from([[1, 7], [2, 6]])</span>
<span class="gi">+    G.add_edges_from([[3, 4], [3, 5]])</span>
<span class="gi">+    G.add_edges_from([[4, 5], [4, 7], [4, 6]])</span>
<span class="gi">+    G.name = &quot;Sedgewick Maze&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -617,7 +823,9 @@ def tetrahedral_graph(create_using=None):</span>
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Tetrahedron#Tetrahedral_graph

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = complete_graph(4, create_using)</span>
<span class="gi">+    G.name = &quot;Platonic Tetrahedral Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -647,7 +855,36 @@ def truncated_cube_graph(create_using=None):</span>
<span class="w"> </span>    .. [2] https://www.coolmath.com/reference/polyhedra-truncated-cube

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {</span>
<span class="gi">+            0: [1, 2, 4],</span>
<span class="gi">+            1: [11, 14],</span>
<span class="gi">+            2: [3, 4],</span>
<span class="gi">+            3: [6, 8],</span>
<span class="gi">+            4: [5],</span>
<span class="gi">+            5: [16, 18],</span>
<span class="gi">+            6: [7, 8],</span>
<span class="gi">+            7: [10, 12],</span>
<span class="gi">+            8: [9],</span>
<span class="gi">+            9: [17, 20],</span>
<span class="gi">+            10: [11, 12],</span>
<span class="gi">+            11: [14],</span>
<span class="gi">+            12: [13],</span>
<span class="gi">+            13: [21, 22],</span>
<span class="gi">+            14: [15],</span>
<span class="gi">+            15: [19, 23],</span>
<span class="gi">+            16: [17, 18],</span>
<span class="gi">+            17: [20],</span>
<span class="gi">+            18: [19],</span>
<span class="gi">+            19: [23],</span>
<span class="gi">+            20: [21],</span>
<span class="gi">+            21: [22],</span>
<span class="gi">+            22: [23],</span>
<span class="gi">+        },</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Truncated Cube Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -674,7 +911,10 @@ def truncated_tetrahedron_graph(create_using=None):</span>
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Truncated_tetrahedron

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = path_graph(12, create_using)</span>
<span class="gi">+    G.add_edges_from([(0, 2), (0, 9), (1, 6), (3, 11), (4, 11), (5, 7), (8, 10)])</span>
<span class="gi">+    G.name = &quot;Truncated Tetrahedron Graph&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@_raise_on_directed
<span class="gu">@@ -704,4 +944,50 @@ def tutte_graph(create_using=None):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] https://en.wikipedia.org/wiki/Tutte_graph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.from_dict_of_lists(</span>
<span class="gi">+        {</span>
<span class="gi">+            0: [1, 2, 3],</span>
<span class="gi">+            1: [4, 26],</span>
<span class="gi">+            2: [10, 11],</span>
<span class="gi">+            3: [18, 19],</span>
<span class="gi">+            4: [5, 33],</span>
<span class="gi">+            5: [6, 29],</span>
<span class="gi">+            6: [7, 27],</span>
<span class="gi">+            7: [8, 14],</span>
<span class="gi">+            8: [9, 38],</span>
<span class="gi">+            9: [10, 37],</span>
<span class="gi">+            10: [39],</span>
<span class="gi">+            11: [12, 39],</span>
<span class="gi">+            12: [13, 35],</span>
<span class="gi">+            13: [14, 15],</span>
<span class="gi">+            14: [34],</span>
<span class="gi">+            15: [16, 22],</span>
<span class="gi">+            16: [17, 44],</span>
<span class="gi">+            17: [18, 43],</span>
<span class="gi">+            18: [45],</span>
<span class="gi">+            19: [20, 45],</span>
<span class="gi">+            20: [21, 41],</span>
<span class="gi">+            21: [22, 23],</span>
<span class="gi">+            22: [40],</span>
<span class="gi">+            23: [24, 27],</span>
<span class="gi">+            24: [25, 32],</span>
<span class="gi">+            25: [26, 31],</span>
<span class="gi">+            26: [33],</span>
<span class="gi">+            27: [28],</span>
<span class="gi">+            28: [29, 32],</span>
<span class="gi">+            29: [30],</span>
<span class="gi">+            30: [31, 33],</span>
<span class="gi">+            31: [32],</span>
<span class="gi">+            34: [35, 38],</span>
<span class="gi">+            35: [36],</span>
<span class="gi">+            36: [37, 39],</span>
<span class="gi">+            37: [38],</span>
<span class="gi">+            40: [41, 44],</span>
<span class="gi">+            41: [42],</span>
<span class="gi">+            42: [43, 45],</span>
<span class="gi">+            43: [44],</span>
<span class="gi">+        },</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+    )</span>
<span class="gi">+    G.name = &quot;Tutte&#39;s Graph&quot;</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/social.py b/networkx/generators/social.py</span>
<span class="gh">index b8c273f72..6f150e2fc 100644</span>
<span class="gd">--- a/networkx/generators/social.py</span>
<span class="gi">+++ b/networkx/generators/social.py</span>
<span class="gu">@@ -2,8 +2,13 @@</span>
<span class="w"> </span>Famous social networks.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;karate_club_graph&#39;, &#39;davis_southern_women_graph&#39;,</span>
<span class="gd">-    &#39;florentine_families_graph&#39;, &#39;les_miserables_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;karate_club_graph&quot;,</span>
<span class="gi">+    &quot;davis_southern_women_graph&quot;,</span>
<span class="gi">+    &quot;florentine_families_graph&quot;,</span>
<span class="gi">+    &quot;les_miserables_graph&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -31,7 +36,61 @@ def karate_club_graph():</span>
<span class="w"> </span>       &quot;An Information Flow Model for Conflict and Fission in Small Groups.&quot;
<span class="w"> </span>       *Journal of Anthropological Research*, 33, 452--473, (1977).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Create the set of all members, and the members of each club.</span>
<span class="gi">+    all_members = set(range(34))</span>
<span class="gi">+    club1 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17, 19, 21}</span>
<span class="gi">+    # club2 = all_members - club1</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    G.add_nodes_from(all_members)</span>
<span class="gi">+    G.name = &quot;Zachary&#39;s Karate Club&quot;</span>
<span class="gi">+</span>
<span class="gi">+    zacharydat = &quot;&quot;&quot;\</span>
<span class="gi">+0 4 5 3 3 3 3 2 2 0 2 3 2 3 0 0 0 2 0 2 0 2 0 0 0 0 0 0 0 0 0 2 0 0</span>
<span class="gi">+4 0 6 3 0 0 0 4 0 0 0 0 0 5 0 0 0 1 0 2 0 2 0 0 0 0 0 0 0 0 2 0 0 0</span>
<span class="gi">+5 6 0 3 0 0 0 4 5 1 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 3 0</span>
<span class="gi">+3 3 3 0 0 0 0 3 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+3 0 0 0 0 0 2 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+3 0 0 0 0 0 5 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+3 0 0 0 2 5 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+2 4 4 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+2 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 4 3</span>
<span class="gi">+0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2</span>
<span class="gi">+2 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+1 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+3 5 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 2</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 4</span>
<span class="gi">+0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2</span>
<span class="gi">+2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 1</span>
<span class="gi">+2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 4 0 2 0 0 5 4</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 3 0 0 0 2 0 0</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 2 0 0 0 0 0 0 7 0 0</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 2</span>
<span class="gi">+0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 3 0 0 0 0 0 0 0 0 4</span>
<span class="gi">+0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2</span>
<span class="gi">+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 4 0 0 0 0 0 3 2</span>
<span class="gi">+0 2 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3</span>
<span class="gi">+2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 7 0 0 2 0 0 0 4 4</span>
<span class="gi">+0 0 2 0 0 0 0 0 3 0 0 0 0 0 3 3 0 0 1 0 3 0 2 5 0 0 0 0 0 4 3 4 0 5</span>
<span class="gi">+0 0 0 0 0 0 0 0 4 2 0 0 0 3 2 4 0 0 2 1 1 0 3 4 0 0 2 4 2 2 3 4 5 0&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    for row, line in enumerate(zacharydat.split(&quot;\n&quot;)):</span>
<span class="gi">+        thisrow = [int(b) for b in line.split()]</span>
<span class="gi">+        for col, entry in enumerate(thisrow):</span>
<span class="gi">+            if entry &gt;= 1:</span>
<span class="gi">+                G.add_edge(row, col, weight=entry)</span>
<span class="gi">+</span>
<span class="gi">+    # Add the name of each member&#39;s club as a node attribute.</span>
<span class="gi">+    for v in G:</span>
<span class="gi">+        G.nodes[v][&quot;club&quot;] = &quot;Mr. Hi&quot; if v in club1 else &quot;Officer&quot;</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -45,7 +104,144 @@ def davis_southern_women_graph():</span>
<span class="w"> </span>    .. [1] A. Davis, Gardner, B. B., Gardner, M. R., 1941. Deep South.
<span class="w"> </span>        University of Chicago Press, Chicago, IL.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    # Top nodes</span>
<span class="gi">+    women = [</span>
<span class="gi">+        &quot;Evelyn Jefferson&quot;,</span>
<span class="gi">+        &quot;Laura Mandeville&quot;,</span>
<span class="gi">+        &quot;Theresa Anderson&quot;,</span>
<span class="gi">+        &quot;Brenda Rogers&quot;,</span>
<span class="gi">+        &quot;Charlotte McDowd&quot;,</span>
<span class="gi">+        &quot;Frances Anderson&quot;,</span>
<span class="gi">+        &quot;Eleanor Nye&quot;,</span>
<span class="gi">+        &quot;Pearl Oglethorpe&quot;,</span>
<span class="gi">+        &quot;Ruth DeSand&quot;,</span>
<span class="gi">+        &quot;Verne Sanderson&quot;,</span>
<span class="gi">+        &quot;Myra Liddel&quot;,</span>
<span class="gi">+        &quot;Katherina Rogers&quot;,</span>
<span class="gi">+        &quot;Sylvia Avondale&quot;,</span>
<span class="gi">+        &quot;Nora Fayette&quot;,</span>
<span class="gi">+        &quot;Helen Lloyd&quot;,</span>
<span class="gi">+        &quot;Dorothy Murchison&quot;,</span>
<span class="gi">+        &quot;Olivia Carleton&quot;,</span>
<span class="gi">+        &quot;Flora Price&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    G.add_nodes_from(women, bipartite=0)</span>
<span class="gi">+    # Bottom nodes</span>
<span class="gi">+    events = [</span>
<span class="gi">+        &quot;E1&quot;,</span>
<span class="gi">+        &quot;E2&quot;,</span>
<span class="gi">+        &quot;E3&quot;,</span>
<span class="gi">+        &quot;E4&quot;,</span>
<span class="gi">+        &quot;E5&quot;,</span>
<span class="gi">+        &quot;E6&quot;,</span>
<span class="gi">+        &quot;E7&quot;,</span>
<span class="gi">+        &quot;E8&quot;,</span>
<span class="gi">+        &quot;E9&quot;,</span>
<span class="gi">+        &quot;E10&quot;,</span>
<span class="gi">+        &quot;E11&quot;,</span>
<span class="gi">+        &quot;E12&quot;,</span>
<span class="gi">+        &quot;E13&quot;,</span>
<span class="gi">+        &quot;E14&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    G.add_nodes_from(events, bipartite=1)</span>
<span class="gi">+</span>
<span class="gi">+    G.add_edges_from(</span>
<span class="gi">+        [</span>
<span class="gi">+            (&quot;Evelyn Jefferson&quot;, &quot;E1&quot;),</span>
<span class="gi">+            (&quot;Evelyn Jefferson&quot;, &quot;E2&quot;),</span>
<span class="gi">+            (&quot;Evelyn Jefferson&quot;, &quot;E3&quot;),</span>
<span class="gi">+            (&quot;Evelyn Jefferson&quot;, &quot;E4&quot;),</span>
<span class="gi">+            (&quot;Evelyn Jefferson&quot;, &quot;E5&quot;),</span>
<span class="gi">+            (&quot;Evelyn Jefferson&quot;, &quot;E6&quot;),</span>
<span class="gi">+            (&quot;Evelyn Jefferson&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Evelyn Jefferson&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Laura Mandeville&quot;, &quot;E1&quot;),</span>
<span class="gi">+            (&quot;Laura Mandeville&quot;, &quot;E2&quot;),</span>
<span class="gi">+            (&quot;Laura Mandeville&quot;, &quot;E3&quot;),</span>
<span class="gi">+            (&quot;Laura Mandeville&quot;, &quot;E5&quot;),</span>
<span class="gi">+            (&quot;Laura Mandeville&quot;, &quot;E6&quot;),</span>
<span class="gi">+            (&quot;Laura Mandeville&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Laura Mandeville&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Theresa Anderson&quot;, &quot;E2&quot;),</span>
<span class="gi">+            (&quot;Theresa Anderson&quot;, &quot;E3&quot;),</span>
<span class="gi">+            (&quot;Theresa Anderson&quot;, &quot;E4&quot;),</span>
<span class="gi">+            (&quot;Theresa Anderson&quot;, &quot;E5&quot;),</span>
<span class="gi">+            (&quot;Theresa Anderson&quot;, &quot;E6&quot;),</span>
<span class="gi">+            (&quot;Theresa Anderson&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Theresa Anderson&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Theresa Anderson&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Brenda Rogers&quot;, &quot;E1&quot;),</span>
<span class="gi">+            (&quot;Brenda Rogers&quot;, &quot;E3&quot;),</span>
<span class="gi">+            (&quot;Brenda Rogers&quot;, &quot;E4&quot;),</span>
<span class="gi">+            (&quot;Brenda Rogers&quot;, &quot;E5&quot;),</span>
<span class="gi">+            (&quot;Brenda Rogers&quot;, &quot;E6&quot;),</span>
<span class="gi">+            (&quot;Brenda Rogers&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Brenda Rogers&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Charlotte McDowd&quot;, &quot;E3&quot;),</span>
<span class="gi">+            (&quot;Charlotte McDowd&quot;, &quot;E4&quot;),</span>
<span class="gi">+            (&quot;Charlotte McDowd&quot;, &quot;E5&quot;),</span>
<span class="gi">+            (&quot;Charlotte McDowd&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Frances Anderson&quot;, &quot;E3&quot;),</span>
<span class="gi">+            (&quot;Frances Anderson&quot;, &quot;E5&quot;),</span>
<span class="gi">+            (&quot;Frances Anderson&quot;, &quot;E6&quot;),</span>
<span class="gi">+            (&quot;Frances Anderson&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Eleanor Nye&quot;, &quot;E5&quot;),</span>
<span class="gi">+            (&quot;Eleanor Nye&quot;, &quot;E6&quot;),</span>
<span class="gi">+            (&quot;Eleanor Nye&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Eleanor Nye&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Pearl Oglethorpe&quot;, &quot;E6&quot;),</span>
<span class="gi">+            (&quot;Pearl Oglethorpe&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Pearl Oglethorpe&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Ruth DeSand&quot;, &quot;E5&quot;),</span>
<span class="gi">+            (&quot;Ruth DeSand&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Ruth DeSand&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Ruth DeSand&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Verne Sanderson&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Verne Sanderson&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Verne Sanderson&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Verne Sanderson&quot;, &quot;E12&quot;),</span>
<span class="gi">+            (&quot;Myra Liddel&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Myra Liddel&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Myra Liddel&quot;, &quot;E10&quot;),</span>
<span class="gi">+            (&quot;Myra Liddel&quot;, &quot;E12&quot;),</span>
<span class="gi">+            (&quot;Katherina Rogers&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Katherina Rogers&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Katherina Rogers&quot;, &quot;E10&quot;),</span>
<span class="gi">+            (&quot;Katherina Rogers&quot;, &quot;E12&quot;),</span>
<span class="gi">+            (&quot;Katherina Rogers&quot;, &quot;E13&quot;),</span>
<span class="gi">+            (&quot;Katherina Rogers&quot;, &quot;E14&quot;),</span>
<span class="gi">+            (&quot;Sylvia Avondale&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Sylvia Avondale&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Sylvia Avondale&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Sylvia Avondale&quot;, &quot;E10&quot;),</span>
<span class="gi">+            (&quot;Sylvia Avondale&quot;, &quot;E12&quot;),</span>
<span class="gi">+            (&quot;Sylvia Avondale&quot;, &quot;E13&quot;),</span>
<span class="gi">+            (&quot;Sylvia Avondale&quot;, &quot;E14&quot;),</span>
<span class="gi">+            (&quot;Nora Fayette&quot;, &quot;E6&quot;),</span>
<span class="gi">+            (&quot;Nora Fayette&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Nora Fayette&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Nora Fayette&quot;, &quot;E10&quot;),</span>
<span class="gi">+            (&quot;Nora Fayette&quot;, &quot;E11&quot;),</span>
<span class="gi">+            (&quot;Nora Fayette&quot;, &quot;E12&quot;),</span>
<span class="gi">+            (&quot;Nora Fayette&quot;, &quot;E13&quot;),</span>
<span class="gi">+            (&quot;Nora Fayette&quot;, &quot;E14&quot;),</span>
<span class="gi">+            (&quot;Helen Lloyd&quot;, &quot;E7&quot;),</span>
<span class="gi">+            (&quot;Helen Lloyd&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Helen Lloyd&quot;, &quot;E10&quot;),</span>
<span class="gi">+            (&quot;Helen Lloyd&quot;, &quot;E11&quot;),</span>
<span class="gi">+            (&quot;Helen Lloyd&quot;, &quot;E12&quot;),</span>
<span class="gi">+            (&quot;Dorothy Murchison&quot;, &quot;E8&quot;),</span>
<span class="gi">+            (&quot;Dorothy Murchison&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Olivia Carleton&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Olivia Carleton&quot;, &quot;E11&quot;),</span>
<span class="gi">+            (&quot;Flora Price&quot;, &quot;E9&quot;),</span>
<span class="gi">+            (&quot;Flora Price&quot;, &quot;E11&quot;),</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+    G.graph[&quot;top&quot;] = women</span>
<span class="gi">+    G.graph[&quot;bottom&quot;] = events</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -58,7 +254,28 @@ def florentine_families_graph():</span>
<span class="w"> </span>       Cumulated social roles: The duality of persons and their algebras,1
<span class="w"> </span>       Social Networks, Volume 8, Issue 3, September 1986, Pages 215-256
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    G.add_edge(&quot;Acciaiuoli&quot;, &quot;Medici&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Castellani&quot;, &quot;Peruzzi&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Castellani&quot;, &quot;Strozzi&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Castellani&quot;, &quot;Barbadori&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Medici&quot;, &quot;Barbadori&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Medici&quot;, &quot;Ridolfi&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Medici&quot;, &quot;Tornabuoni&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Medici&quot;, &quot;Albizzi&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Medici&quot;, &quot;Salviati&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Salviati&quot;, &quot;Pazzi&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Peruzzi&quot;, &quot;Strozzi&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Peruzzi&quot;, &quot;Bischeri&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Strozzi&quot;, &quot;Ridolfi&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Strozzi&quot;, &quot;Bischeri&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Ridolfi&quot;, &quot;Tornabuoni&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Tornabuoni&quot;, &quot;Guadagni&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Albizzi&quot;, &quot;Ginori&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Albizzi&quot;, &quot;Guadagni&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Bischeri&quot;, &quot;Guadagni&quot;)</span>
<span class="gi">+    G.add_edge(&quot;Guadagni&quot;, &quot;Lamberteschi&quot;)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -71,4 +288,259 @@ def les_miserables_graph():</span>
<span class="w"> </span>       The Stanford GraphBase: a platform for combinatorial computing,
<span class="w"> </span>       pp. 74-87. New York: AcM Press.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    G.add_edge(&quot;Napoleon&quot;, &quot;Myriel&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MlleBaptistine&quot;, &quot;Myriel&quot;, weight=8)</span>
<span class="gi">+    G.add_edge(&quot;MmeMagloire&quot;, &quot;Myriel&quot;, weight=10)</span>
<span class="gi">+    G.add_edge(&quot;MmeMagloire&quot;, &quot;MlleBaptistine&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;CountessDeLo&quot;, &quot;Myriel&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Geborand&quot;, &quot;Myriel&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Champtercier&quot;, &quot;Myriel&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Cravatte&quot;, &quot;Myriel&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Count&quot;, &quot;Myriel&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;OldMan&quot;, &quot;Myriel&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Valjean&quot;, &quot;Labarre&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Valjean&quot;, &quot;MmeMagloire&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Valjean&quot;, &quot;MlleBaptistine&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Valjean&quot;, &quot;Myriel&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Marguerite&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MmeDeR&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Isabeau&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gervais&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Listolier&quot;, &quot;Tholomyes&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Fameuil&quot;, &quot;Tholomyes&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Fameuil&quot;, &quot;Listolier&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Blacheville&quot;, &quot;Tholomyes&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Blacheville&quot;, &quot;Listolier&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Blacheville&quot;, &quot;Fameuil&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Favourite&quot;, &quot;Tholomyes&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Favourite&quot;, &quot;Listolier&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Favourite&quot;, &quot;Fameuil&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Favourite&quot;, &quot;Blacheville&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Dahlia&quot;, &quot;Tholomyes&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Dahlia&quot;, &quot;Listolier&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Dahlia&quot;, &quot;Fameuil&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Dahlia&quot;, &quot;Blacheville&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Dahlia&quot;, &quot;Favourite&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Zephine&quot;, &quot;Tholomyes&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Zephine&quot;, &quot;Listolier&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Zephine&quot;, &quot;Fameuil&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Zephine&quot;, &quot;Blacheville&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Zephine&quot;, &quot;Favourite&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Zephine&quot;, &quot;Dahlia&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Fantine&quot;, &quot;Tholomyes&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Fantine&quot;, &quot;Listolier&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Fantine&quot;, &quot;Fameuil&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Fantine&quot;, &quot;Blacheville&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Fantine&quot;, &quot;Favourite&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Fantine&quot;, &quot;Dahlia&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Fantine&quot;, &quot;Zephine&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Fantine&quot;, &quot;Marguerite&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Fantine&quot;, &quot;Valjean&quot;, weight=9)</span>
<span class="gi">+    G.add_edge(&quot;MmeThenardier&quot;, &quot;Fantine&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;MmeThenardier&quot;, &quot;Valjean&quot;, weight=7)</span>
<span class="gi">+    G.add_edge(&quot;Thenardier&quot;, &quot;MmeThenardier&quot;, weight=13)</span>
<span class="gi">+    G.add_edge(&quot;Thenardier&quot;, &quot;Fantine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Thenardier&quot;, &quot;Valjean&quot;, weight=12)</span>
<span class="gi">+    G.add_edge(&quot;Cosette&quot;, &quot;MmeThenardier&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Cosette&quot;, &quot;Valjean&quot;, weight=31)</span>
<span class="gi">+    G.add_edge(&quot;Cosette&quot;, &quot;Tholomyes&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Cosette&quot;, &quot;Thenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Javert&quot;, &quot;Valjean&quot;, weight=17)</span>
<span class="gi">+    G.add_edge(&quot;Javert&quot;, &quot;Fantine&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Javert&quot;, &quot;Thenardier&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Javert&quot;, &quot;MmeThenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Javert&quot;, &quot;Cosette&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Fauchelevent&quot;, &quot;Valjean&quot;, weight=8)</span>
<span class="gi">+    G.add_edge(&quot;Fauchelevent&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Bamatabois&quot;, &quot;Fantine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Bamatabois&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Bamatabois&quot;, &quot;Valjean&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Perpetue&quot;, &quot;Fantine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Simplice&quot;, &quot;Perpetue&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Simplice&quot;, &quot;Valjean&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Simplice&quot;, &quot;Fantine&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Simplice&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Scaufflaire&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Woman1&quot;, &quot;Valjean&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Woman1&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Judge&quot;, &quot;Valjean&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Judge&quot;, &quot;Bamatabois&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Champmathieu&quot;, &quot;Valjean&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Champmathieu&quot;, &quot;Judge&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Champmathieu&quot;, &quot;Bamatabois&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Brevet&quot;, &quot;Judge&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Brevet&quot;, &quot;Champmathieu&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Brevet&quot;, &quot;Valjean&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Brevet&quot;, &quot;Bamatabois&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Chenildieu&quot;, &quot;Judge&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Chenildieu&quot;, &quot;Champmathieu&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Chenildieu&quot;, &quot;Brevet&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Chenildieu&quot;, &quot;Valjean&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Chenildieu&quot;, &quot;Bamatabois&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Cochepaille&quot;, &quot;Judge&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Cochepaille&quot;, &quot;Champmathieu&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Cochepaille&quot;, &quot;Brevet&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Cochepaille&quot;, &quot;Chenildieu&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Cochepaille&quot;, &quot;Valjean&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Cochepaille&quot;, &quot;Bamatabois&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Pontmercy&quot;, &quot;Thenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Boulatruelle&quot;, &quot;Thenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Eponine&quot;, &quot;MmeThenardier&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Eponine&quot;, &quot;Thenardier&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Anzelma&quot;, &quot;Eponine&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Anzelma&quot;, &quot;Thenardier&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Anzelma&quot;, &quot;MmeThenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Woman2&quot;, &quot;Valjean&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Woman2&quot;, &quot;Cosette&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Woman2&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MotherInnocent&quot;, &quot;Fauchelevent&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;MotherInnocent&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gribier&quot;, &quot;Fauchelevent&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;MmeBurgon&quot;, &quot;Jondrette&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gavroche&quot;, &quot;MmeBurgon&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Gavroche&quot;, &quot;Thenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gavroche&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gavroche&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gillenormand&quot;, &quot;Cosette&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Gillenormand&quot;, &quot;Valjean&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Magnon&quot;, &quot;Gillenormand&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Magnon&quot;, &quot;MmeThenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MlleGillenormand&quot;, &quot;Gillenormand&quot;, weight=9)</span>
<span class="gi">+    G.add_edge(&quot;MlleGillenormand&quot;, &quot;Cosette&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;MlleGillenormand&quot;, &quot;Valjean&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;MmePontmercy&quot;, &quot;MlleGillenormand&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MmePontmercy&quot;, &quot;Pontmercy&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MlleVaubois&quot;, &quot;MlleGillenormand&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;LtGillenormand&quot;, &quot;MlleGillenormand&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;LtGillenormand&quot;, &quot;Gillenormand&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;LtGillenormand&quot;, &quot;Cosette&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;MlleGillenormand&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;Gillenormand&quot;, weight=12)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;Pontmercy&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;LtGillenormand&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;Cosette&quot;, weight=21)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;Valjean&quot;, weight=19)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;Tholomyes&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;Thenardier&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;Eponine&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Marius&quot;, &quot;Gavroche&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;BaronessT&quot;, &quot;Gillenormand&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;BaronessT&quot;, &quot;Marius&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Mabeuf&quot;, &quot;Marius&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Mabeuf&quot;, &quot;Eponine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Mabeuf&quot;, &quot;Gavroche&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Enjolras&quot;, &quot;Marius&quot;, weight=7)</span>
<span class="gi">+    G.add_edge(&quot;Enjolras&quot;, &quot;Gavroche&quot;, weight=7)</span>
<span class="gi">+    G.add_edge(&quot;Enjolras&quot;, &quot;Javert&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;Enjolras&quot;, &quot;Mabeuf&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Enjolras&quot;, &quot;Valjean&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Combeferre&quot;, &quot;Enjolras&quot;, weight=15)</span>
<span class="gi">+    G.add_edge(&quot;Combeferre&quot;, &quot;Marius&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Combeferre&quot;, &quot;Gavroche&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;Combeferre&quot;, &quot;Mabeuf&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Prouvaire&quot;, &quot;Gavroche&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Prouvaire&quot;, &quot;Enjolras&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Prouvaire&quot;, &quot;Combeferre&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Feuilly&quot;, &quot;Gavroche&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Feuilly&quot;, &quot;Enjolras&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;Feuilly&quot;, &quot;Prouvaire&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Feuilly&quot;, &quot;Combeferre&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Feuilly&quot;, &quot;Mabeuf&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Feuilly&quot;, &quot;Marius&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Courfeyrac&quot;, &quot;Marius&quot;, weight=9)</span>
<span class="gi">+    G.add_edge(&quot;Courfeyrac&quot;, &quot;Enjolras&quot;, weight=17)</span>
<span class="gi">+    G.add_edge(&quot;Courfeyrac&quot;, &quot;Combeferre&quot;, weight=13)</span>
<span class="gi">+    G.add_edge(&quot;Courfeyrac&quot;, &quot;Gavroche&quot;, weight=7)</span>
<span class="gi">+    G.add_edge(&quot;Courfeyrac&quot;, &quot;Mabeuf&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Courfeyrac&quot;, &quot;Eponine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Courfeyrac&quot;, &quot;Feuilly&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;Courfeyrac&quot;, &quot;Prouvaire&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Bahorel&quot;, &quot;Combeferre&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Bahorel&quot;, &quot;Gavroche&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Bahorel&quot;, &quot;Courfeyrac&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;Bahorel&quot;, &quot;Mabeuf&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Bahorel&quot;, &quot;Enjolras&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Bahorel&quot;, &quot;Feuilly&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Bahorel&quot;, &quot;Prouvaire&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Bahorel&quot;, &quot;Marius&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Marius&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Courfeyrac&quot;, weight=12)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Gavroche&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Bahorel&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Enjolras&quot;, weight=10)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Feuilly&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Prouvaire&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Combeferre&quot;, weight=9)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Mabeuf&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Bossuet&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Bahorel&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Bossuet&quot;, weight=7)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Gavroche&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Courfeyrac&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Enjolras&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Feuilly&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Prouvaire&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Combeferre&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Mabeuf&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Joly&quot;, &quot;Marius&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Grantaire&quot;, &quot;Bossuet&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Grantaire&quot;, &quot;Enjolras&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Grantaire&quot;, &quot;Combeferre&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Grantaire&quot;, &quot;Courfeyrac&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Grantaire&quot;, &quot;Joly&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Grantaire&quot;, &quot;Gavroche&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Grantaire&quot;, &quot;Bahorel&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Grantaire&quot;, &quot;Feuilly&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Grantaire&quot;, &quot;Prouvaire&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MotherPlutarch&quot;, &quot;Mabeuf&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Gueulemer&quot;, &quot;Thenardier&quot;, weight=5)</span>
<span class="gi">+    G.add_edge(&quot;Gueulemer&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gueulemer&quot;, &quot;MmeThenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gueulemer&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gueulemer&quot;, &quot;Gavroche&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Gueulemer&quot;, &quot;Eponine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Babet&quot;, &quot;Thenardier&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;Babet&quot;, &quot;Gueulemer&quot;, weight=6)</span>
<span class="gi">+    G.add_edge(&quot;Babet&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Babet&quot;, &quot;MmeThenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Babet&quot;, &quot;Javert&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Babet&quot;, &quot;Gavroche&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Babet&quot;, &quot;Eponine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Claquesous&quot;, &quot;Thenardier&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Claquesous&quot;, &quot;Babet&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Claquesous&quot;, &quot;Gueulemer&quot;, weight=4)</span>
<span class="gi">+    G.add_edge(&quot;Claquesous&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Claquesous&quot;, &quot;MmeThenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Claquesous&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Claquesous&quot;, &quot;Eponine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Claquesous&quot;, &quot;Enjolras&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Montparnasse&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Montparnasse&quot;, &quot;Babet&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Montparnasse&quot;, &quot;Gueulemer&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Montparnasse&quot;, &quot;Claquesous&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Montparnasse&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Montparnasse&quot;, &quot;Gavroche&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Montparnasse&quot;, &quot;Eponine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Montparnasse&quot;, &quot;Thenardier&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Toussaint&quot;, &quot;Cosette&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Toussaint&quot;, &quot;Javert&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Toussaint&quot;, &quot;Valjean&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Child1&quot;, &quot;Gavroche&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Child2&quot;, &quot;Gavroche&quot;, weight=2)</span>
<span class="gi">+    G.add_edge(&quot;Child2&quot;, &quot;Child1&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Brujon&quot;, &quot;Babet&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Brujon&quot;, &quot;Gueulemer&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Brujon&quot;, &quot;Thenardier&quot;, weight=3)</span>
<span class="gi">+    G.add_edge(&quot;Brujon&quot;, &quot;Gavroche&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Brujon&quot;, &quot;Eponine&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Brujon&quot;, &quot;Claquesous&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;Brujon&quot;, &quot;Montparnasse&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MmeHucheloup&quot;, &quot;Bossuet&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MmeHucheloup&quot;, &quot;Joly&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MmeHucheloup&quot;, &quot;Grantaire&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MmeHucheloup&quot;, &quot;Bahorel&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MmeHucheloup&quot;, &quot;Courfeyrac&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MmeHucheloup&quot;, &quot;Gavroche&quot;, weight=1)</span>
<span class="gi">+    G.add_edge(&quot;MmeHucheloup&quot;, &quot;Enjolras&quot;, weight=1)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/spectral_graph_forge.py b/networkx/generators/spectral_graph_forge.py</span>
<span class="gh">index a06be505e..3f4ee3ed9 100644</span>
<span class="gd">--- a/networkx/generators/spectral_graph_forge.py</span>
<span class="gi">+++ b/networkx/generators/spectral_graph_forge.py</span>
<span class="gu">@@ -1,12 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Generates graphs with a given eigenvector structure&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import np_random_state
<span class="gd">-__all__ = [&#39;spectral_graph_forge&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;spectral_graph_forge&quot;]</span>


<span class="w"> </span>@np_random_state(3)
<span class="w"> </span>@nx._dispatchable(returns_graph=True)
<span class="gd">-def spectral_graph_forge(G, alpha, transformation=&#39;identity&#39;, seed=None):</span>
<span class="gi">+def spectral_graph_forge(G, alpha, transformation=&quot;identity&quot;, seed=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a random simple graph with spectrum resembling that of `G`

<span class="w"> </span>    This algorithm, called Spectral Graph Forge (SGF), computes the
<span class="gu">@@ -77,4 +80,42 @@ def spectral_graph_forge(G, alpha, transformation=&#39;identity&#39;, seed=None):</span>
<span class="w"> </span>    &gt;&gt;&gt; H = nx.spectral_graph_forge(G, 0.3)
<span class="w"> </span>    &gt;&gt;&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    available_transformations = [&quot;identity&quot;, &quot;modularity&quot;]</span>
<span class="gi">+    alpha = np.clip(alpha, 0, 1)</span>
<span class="gi">+    A = nx.to_numpy_array(G)</span>
<span class="gi">+    n = A.shape[1]</span>
<span class="gi">+    level = round(n * alpha)</span>
<span class="gi">+</span>
<span class="gi">+    if transformation not in available_transformations:</span>
<span class="gi">+        msg = f&quot;{transformation!r} is not a valid transformation. &quot;</span>
<span class="gi">+        msg += f&quot;Transformations: {available_transformations}&quot;</span>
<span class="gi">+        raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    K = np.ones((1, n)) @ A</span>
<span class="gi">+</span>
<span class="gi">+    B = A</span>
<span class="gi">+    if transformation == &quot;modularity&quot;:</span>
<span class="gi">+        B -= K.T @ K / K.sum()</span>
<span class="gi">+</span>
<span class="gi">+    # Compute low-rank approximation of B</span>
<span class="gi">+    evals, evecs = np.linalg.eigh(B)</span>
<span class="gi">+    k = np.argsort(np.abs(evals))[::-1]  # indices of evals in descending order</span>
<span class="gi">+    evecs[:, k[np.arange(level, n)]] = 0  # set smallest eigenvectors to 0</span>
<span class="gi">+    B = evecs @ np.diag(evals) @ evecs.T</span>
<span class="gi">+</span>
<span class="gi">+    if transformation == &quot;modularity&quot;:</span>
<span class="gi">+        B += K.T @ K / K.sum()</span>
<span class="gi">+</span>
<span class="gi">+    B = np.clip(B, 0, 1)</span>
<span class="gi">+    np.fill_diagonal(B, 0)</span>
<span class="gi">+</span>
<span class="gi">+    for i in range(n - 1):</span>
<span class="gi">+        B[i, i + 1 :] = sp.stats.bernoulli.rvs(B[i, i + 1 :], random_state=seed)</span>
<span class="gi">+        B[i + 1 :, i] = np.transpose(B[i, i + 1 :])</span>
<span class="gi">+</span>
<span class="gi">+    H = nx.from_numpy_array(B)</span>
<span class="gi">+</span>
<span class="gi">+    return H</span>
<span class="gh">diff --git a/networkx/generators/stochastic.py b/networkx/generators/stochastic.py</span>
<span class="gh">index bd13bb17b..f53e23154 100644</span>
<span class="gd">--- a/networkx/generators/stochastic.py</span>
<span class="gi">+++ b/networkx/generators/stochastic.py</span>
<span class="gu">@@ -2,16 +2,19 @@</span>
<span class="w"> </span>graph.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.classes import DiGraph, MultiDiGraph
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;stochastic_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;stochastic_graph&quot;]</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;, mutates_input={&#39;not copy&#39;: 1},</span>
<span class="gd">-    returns_graph=True)</span>
<span class="gd">-def stochastic_graph(G, copy=True, weight=&#39;weight&#39;):</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    edge_attrs=&quot;weight&quot;, mutates_input={&quot;not copy&quot;: 1}, returns_graph=True</span>
<span class="gi">+)</span>
<span class="gi">+def stochastic_graph(G, copy=True, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a right-stochastic representation of directed graph `G`.

<span class="w"> </span>    A right-stochastic graph is a weighted digraph in which for each
<span class="gu">@@ -36,4 +39,16 @@ def stochastic_graph(G, copy=True, weight=&#39;weight&#39;):</span>
<span class="w"> </span>        has a weight, it must be a positive number.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if copy:</span>
<span class="gi">+        G = MultiDiGraph(G) if G.is_multigraph() else DiGraph(G)</span>
<span class="gi">+    # There is a tradeoff here: the dictionary of node degrees may</span>
<span class="gi">+    # require a lot of memory, whereas making a call to `G.out_degree`</span>
<span class="gi">+    # inside the loop may be costly in computation time.</span>
<span class="gi">+    degree = dict(G.out_degree(weight=weight))</span>
<span class="gi">+    for u, v, d in G.edges(data=True):</span>
<span class="gi">+        if degree[u] == 0:</span>
<span class="gi">+            d[weight] = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            d[weight] = d.get(weight, 1) / degree[u]</span>
<span class="gi">+    nx._clear_cache(G)</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/sudoku.py b/networkx/generators/sudoku.py</span>
<span class="gh">index 15a3bd74c..f288ed24d 100644</span>
<span class="gd">--- a/networkx/generators/sudoku.py</span>
<span class="gi">+++ b/networkx/generators/sudoku.py</span>
<span class="gu">@@ -40,9 +40,11 @@ References</span>
<span class="w"> </span>.. [3] Wikipedia contributors. &quot;Glossary of Sudoku.&quot; Wikipedia, The Free
<span class="w"> </span>    Encyclopedia, 3 Dec. 2019. Web. 22 Dec. 2019.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="gd">-__all__ = [&#39;sudoku_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;sudoku_graph&quot;]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -88,4 +90,42 @@ def sudoku_graph(n=3):</span>
<span class="w"> </span>    .. [3] Wikipedia contributors. &quot;Glossary of Sudoku.&quot; Wikipedia, The Free
<span class="w"> </span>       Encyclopedia, 3 Dec. 2019. Web. 22 Dec. 2019.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if n &lt; 0:</span>
<span class="gi">+        raise NetworkXError(&quot;The order must be greater than or equal to zero.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    n2 = n * n</span>
<span class="gi">+    n3 = n2 * n</span>
<span class="gi">+    n4 = n3 * n</span>
<span class="gi">+</span>
<span class="gi">+    # Construct an empty graph with n^4 nodes</span>
<span class="gi">+    G = nx.empty_graph(n4)</span>
<span class="gi">+</span>
<span class="gi">+    # A Sudoku graph of order 0 or 1 has no edges</span>
<span class="gi">+    if n &lt; 2:</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    # Add edges for cells in the same row</span>
<span class="gi">+    for row_no in range(n2):</span>
<span class="gi">+        row_start = row_no * n2</span>
<span class="gi">+        for j in range(1, n2):</span>
<span class="gi">+            for i in range(j):</span>
<span class="gi">+                G.add_edge(row_start + i, row_start + j)</span>
<span class="gi">+</span>
<span class="gi">+    # Add edges for cells in the same column</span>
<span class="gi">+    for col_no in range(n2):</span>
<span class="gi">+        for j in range(col_no, n4, n2):</span>
<span class="gi">+            for i in range(col_no, j, n2):</span>
<span class="gi">+                G.add_edge(i, j)</span>
<span class="gi">+</span>
<span class="gi">+    # Add edges for cells in the same box</span>
<span class="gi">+    for band_no in range(n):</span>
<span class="gi">+        for stack_no in range(n):</span>
<span class="gi">+            box_start = n3 * band_no + n * stack_no</span>
<span class="gi">+            for j in range(1, n2):</span>
<span class="gi">+                for i in range(j):</span>
<span class="gi">+                    u = box_start + (i % n) + n2 * (i // n)</span>
<span class="gi">+                    v = box_start + (j % n) + n2 * (j // n)</span>
<span class="gi">+                    G.add_edge(u, v)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/time_series.py b/networkx/generators/time_series.py</span>
<span class="gh">index a63f37bed..6cf54b016 100644</span>
<span class="gd">--- a/networkx/generators/time_series.py</span>
<span class="gi">+++ b/networkx/generators/time_series.py</span>
<span class="gu">@@ -2,8 +2,10 @@</span>
<span class="w"> </span>Time Series Graphs
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import itertools
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;visibility_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;visibility_graph&quot;]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -49,4 +51,23 @@ def visibility_graph(series):</span>
<span class="w"> </span>           National Academy of Sciences 105, no. 13 (2008): 4972-4975.
<span class="w"> </span>           https://www.pnas.org/doi/10.1073/pnas.0709247105
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Sequential values are always connected</span>
<span class="gi">+    G = nx.path_graph(len(series))</span>
<span class="gi">+    nx.set_node_attributes(G, dict(enumerate(series)), &quot;value&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Check all combinations of nodes n series</span>
<span class="gi">+    for (n1, t1), (n2, t2) in itertools.combinations(enumerate(series), 2):</span>
<span class="gi">+        # check if any value between obstructs line of sight</span>
<span class="gi">+        slope = (t2 - t1) / (n2 - n1)</span>
<span class="gi">+        offset = t2 - slope * n2</span>
<span class="gi">+</span>
<span class="gi">+        obstructed = any(</span>
<span class="gi">+            t &gt;= slope * n + offset</span>
<span class="gi">+            for n, t in enumerate(series[n1 + 1 : n2], start=n1 + 1)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if not obstructed:</span>
<span class="gi">+            G.add_edge(n1, n2)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/generators/trees.py b/networkx/generators/trees.py</span>
<span class="gh">index f0abaf2ca..c1b0d7935 100644</span>
<span class="gd">--- a/networkx/generators/trees.py</span>
<span class="gi">+++ b/networkx/generators/trees.py</span>
<span class="gu">@@ -27,15 +27,25 @@ trees and forests uniformly at random. A rooted tree is a tree</span>
<span class="w"> </span>with a designated root node. A rooted forest is a disjoint union
<span class="w"> </span>of rooted trees.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from collections import Counter, defaultdict
<span class="w"> </span>from math import comb, factorial
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;prefix_tree&#39;, &#39;prefix_tree_recursive&#39;, &#39;random_tree&#39;,</span>
<span class="gd">-    &#39;random_labeled_tree&#39;, &#39;random_labeled_rooted_tree&#39;,</span>
<span class="gd">-    &#39;random_labeled_rooted_forest&#39;, &#39;random_unlabeled_tree&#39;,</span>
<span class="gd">-    &#39;random_unlabeled_rooted_tree&#39;, &#39;random_unlabeled_rooted_forest&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;prefix_tree&quot;,</span>
<span class="gi">+    &quot;prefix_tree_recursive&quot;,</span>
<span class="gi">+    &quot;random_tree&quot;,</span>
<span class="gi">+    &quot;random_labeled_tree&quot;,</span>
<span class="gi">+    &quot;random_labeled_rooted_tree&quot;,</span>
<span class="gi">+    &quot;random_labeled_rooted_forest&quot;,</span>
<span class="gi">+    &quot;random_unlabeled_tree&quot;,</span>
<span class="gi">+    &quot;random_unlabeled_rooted_tree&quot;,</span>
<span class="gi">+    &quot;random_unlabeled_rooted_forest&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -129,7 +139,46 @@ def prefix_tree(paths):</span>
<span class="w"> </span>        &gt;&gt;&gt; sorted(recovered)
<span class="w"> </span>        [&#39;ab&#39;, &#39;abs&#39;, &#39;ad&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_children(parent, paths):</span>
<span class="gi">+        children = defaultdict(list)</span>
<span class="gi">+        # Populate dictionary with key(s) as the child/children of the root and</span>
<span class="gi">+        # value(s) as the remaining paths of the corresponding child/children</span>
<span class="gi">+        for path in paths:</span>
<span class="gi">+            # If path is empty, we add an edge to the NIL node.</span>
<span class="gi">+            if not path:</span>
<span class="gi">+                tree.add_edge(parent, NIL)</span>
<span class="gi">+                continue</span>
<span class="gi">+            child, *rest = path</span>
<span class="gi">+            # `child` may exist as the head of more than one path in `paths`.</span>
<span class="gi">+            children[child].append(rest)</span>
<span class="gi">+        return children</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize the prefix tree with a root node and a nil node.</span>
<span class="gi">+    tree = nx.DiGraph()</span>
<span class="gi">+    root = 0</span>
<span class="gi">+    tree.add_node(root, source=None)</span>
<span class="gi">+    NIL = -1</span>
<span class="gi">+    tree.add_node(NIL, source=&quot;NIL&quot;)</span>
<span class="gi">+    children = get_children(root, paths)</span>
<span class="gi">+    stack = [(root, iter(children.items()))]</span>
<span class="gi">+    while stack:</span>
<span class="gi">+        parent, remaining_children = stack[-1]</span>
<span class="gi">+        try:</span>
<span class="gi">+            child, remaining_paths = next(remaining_children)</span>
<span class="gi">+        # Pop item off stack if there are no remaining children</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            stack.pop()</span>
<span class="gi">+            continue</span>
<span class="gi">+        # We relabel each child with an unused name.</span>
<span class="gi">+        new_name = len(tree) - 1</span>
<span class="gi">+        # The &quot;source&quot; node attribute stores the original node name.</span>
<span class="gi">+        tree.add_node(new_name, source=child)</span>
<span class="gi">+        tree.add_edge(parent, new_name)</span>
<span class="gi">+        children = get_children(new_name, remaining_paths)</span>
<span class="gi">+        stack.append((new_name, iter(children.items())))</span>
<span class="gi">+</span>
<span class="gi">+    return tree</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -226,7 +275,52 @@ def prefix_tree_recursive(paths):</span>
<span class="w"> </span>        &gt;&gt;&gt; sorted(recovered)
<span class="w"> </span>        [&#39;ab&#39;, &#39;abs&#39;, &#39;ad&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _helper(paths, root, tree):</span>
<span class="gi">+        &quot;&quot;&quot;Recursively create a trie from the given list of paths.</span>
<span class="gi">+</span>
<span class="gi">+        `paths` is a list of paths, each of which is itself a list of</span>
<span class="gi">+        nodes, relative to the given `root` (but not including it). This</span>
<span class="gi">+        list of paths will be interpreted as a tree-like structure, in</span>
<span class="gi">+        which two paths that share a prefix represent two branches of</span>
<span class="gi">+        the tree with the same initial segment.</span>
<span class="gi">+</span>
<span class="gi">+        `root` is the parent of the node at index 0 in each path.</span>
<span class="gi">+</span>
<span class="gi">+        `tree` is the &quot;accumulator&quot;, the :class:`networkx.DiGraph`</span>
<span class="gi">+        representing the branching to which the new nodes and edges will</span>
<span class="gi">+        be added.</span>
<span class="gi">+</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # For each path, remove the first node and make it a child of root.</span>
<span class="gi">+        # Any remaining paths then get processed recursively.</span>
<span class="gi">+        children = defaultdict(list)</span>
<span class="gi">+        for path in paths:</span>
<span class="gi">+            # If path is empty, we add an edge to the NIL node.</span>
<span class="gi">+            if not path:</span>
<span class="gi">+                tree.add_edge(root, NIL)</span>
<span class="gi">+                continue</span>
<span class="gi">+            child, *rest = path</span>
<span class="gi">+            # `child` may exist as the head of more than one path in `paths`.</span>
<span class="gi">+            children[child].append(rest)</span>
<span class="gi">+        # Add a node for each child, connect root, recurse to remaining paths</span>
<span class="gi">+        for child, remaining_paths in children.items():</span>
<span class="gi">+            # We relabel each child with an unused name.</span>
<span class="gi">+            new_name = len(tree) - 1</span>
<span class="gi">+            # The &quot;source&quot; node attribute stores the original node name.</span>
<span class="gi">+            tree.add_node(new_name, source=child)</span>
<span class="gi">+            tree.add_edge(root, new_name)</span>
<span class="gi">+            _helper(remaining_paths, new_name, tree)</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize the prefix tree with a root node and a nil node.</span>
<span class="gi">+    tree = nx.DiGraph()</span>
<span class="gi">+    root = 0</span>
<span class="gi">+    tree.add_node(root, source=None)</span>
<span class="gi">+    NIL = -1</span>
<span class="gi">+    tree.add_node(NIL, source=&quot;NIL&quot;)</span>
<span class="gi">+    # Populate the tree.</span>
<span class="gi">+    _helper(paths, root, tree)</span>
<span class="gi">+    return tree</span>


<span class="w"> </span>@py_random_state(1)
<span class="gu">@@ -297,10 +391,41 @@ def random_tree(n, seed=None, create_using=None):</span>
<span class="w"> </span>            │           └─╼ 5
<span class="w"> </span>            └─╼ 9
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@py_random_state(&#39;seed&#39;)</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;\n\nrandom_tree is deprecated and will be removed in NX v3.4\n&quot;</span>
<span class="gi">+            &quot;Use random_labeled_tree instead.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;the null graph is not a tree&quot;)</span>
<span class="gi">+    # Cannot create a Prüfer sequence unless `n` is at least two.</span>
<span class="gi">+    if n == 1:</span>
<span class="gi">+        utree = nx.empty_graph(1, create_using)</span>
<span class="gi">+    else:</span>
<span class="gi">+        sequence = [seed.choice(range(n)) for i in range(n - 2)]</span>
<span class="gi">+        utree = nx.from_prufer_sequence(sequence)</span>
<span class="gi">+</span>
<span class="gi">+    if create_using is None:</span>
<span class="gi">+        tree = utree</span>
<span class="gi">+    else:</span>
<span class="gi">+        tree = nx.empty_graph(0, create_using)</span>
<span class="gi">+        if tree.is_directed():</span>
<span class="gi">+            # Use a arbitrary root node and dfs to define edge directions</span>
<span class="gi">+            edges = nx.dfs_edges(utree, source=0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            edges = utree.edges</span>
<span class="gi">+</span>
<span class="gi">+        # Populate the specified graph type</span>
<span class="gi">+        tree.add_nodes_from(utree.nodes)</span>
<span class="gi">+        tree.add_edges_from(edges)</span>
<span class="gi">+</span>
<span class="gi">+    return tree</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@py_random_state(&quot;seed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_labeled_tree(n, *, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a labeled tree on `n` nodes chosen uniformly at random.
<span class="gu">@@ -328,10 +453,15 @@ def random_labeled_tree(n, *, seed=None):</span>
<span class="w"> </span>    NetworkXPointlessConcept
<span class="w"> </span>        If `n` is zero (because the null graph is not a tree).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Cannot create a Prüfer sequence unless `n` is at least two.</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;the null graph is not a tree&quot;)</span>
<span class="gi">+    if n == 1:</span>
<span class="gi">+        return nx.empty_graph(1)</span>
<span class="gi">+    return nx.from_prufer_sequence([seed.choice(range(n)) for i in range(n - 2)])</span>


<span class="gd">-@py_random_state(&#39;seed&#39;)</span>
<span class="gi">+@py_random_state(&quot;seed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_labeled_rooted_tree(n, *, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a labeled rooted tree with `n` nodes.
<span class="gu">@@ -363,10 +493,12 @@ def random_labeled_rooted_tree(n, *, seed=None):</span>
<span class="w"> </span>    NetworkXPointlessConcept
<span class="w"> </span>        If `n` is zero (because the null graph is not a tree).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    t = random_labeled_tree(n, seed=seed)</span>
<span class="gi">+    t.graph[&quot;root&quot;] = seed.randint(0, n - 1)</span>
<span class="gi">+    return t</span>


<span class="gd">-@py_random_state(&#39;seed&#39;)</span>
<span class="gi">+@py_random_state(&quot;seed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_labeled_rooted_forest(n, *, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a labeled rooted forest with `n` nodes.
<span class="gu">@@ -397,7 +529,57 @@ def random_labeled_rooted_forest(n, *, seed=None):</span>
<span class="w"> </span>        Naturwissenschaften an der Formal- und Naturwissenschaftlichen
<span class="w"> </span>        Fakultät der Universität Wien. Wien, May 2000.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Select the number of roots by iterating over the cumulative count of trees</span>
<span class="gi">+    # with at most k roots</span>
<span class="gi">+    def _select_k(n, seed):</span>
<span class="gi">+        r = seed.randint(0, (n + 1) ** (n - 1) - 1)</span>
<span class="gi">+        cum_sum = 0</span>
<span class="gi">+        for k in range(1, n):</span>
<span class="gi">+            cum_sum += (factorial(n - 1) * n ** (n - k)) // (</span>
<span class="gi">+                factorial(k - 1) * factorial(n - k)</span>
<span class="gi">+            )</span>
<span class="gi">+            if r &lt; cum_sum:</span>
<span class="gi">+                return k</span>
<span class="gi">+</span>
<span class="gi">+        return n</span>
<span class="gi">+</span>
<span class="gi">+    F = nx.empty_graph(n)</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        F.graph[&quot;roots&quot;] = {}</span>
<span class="gi">+        return F</span>
<span class="gi">+    # Select the number of roots k</span>
<span class="gi">+    k = _select_k(n, seed)</span>
<span class="gi">+    if k == n:</span>
<span class="gi">+        F.graph[&quot;roots&quot;] = set(range(n))</span>
<span class="gi">+        return F  # Nothing to do</span>
<span class="gi">+    # Select the roots</span>
<span class="gi">+    roots = seed.sample(range(n), k)</span>
<span class="gi">+    # Nonroots</span>
<span class="gi">+    p = set(range(n)).difference(roots)</span>
<span class="gi">+    # Coding sequence</span>
<span class="gi">+    N = [seed.randint(0, n - 1) for i in range(n - k - 1)]</span>
<span class="gi">+    # Multiset of elements in N also in p</span>
<span class="gi">+    degree = Counter([x for x in N if x in p])</span>
<span class="gi">+    # Iterator over the elements of p with degree zero</span>
<span class="gi">+    iterator = iter(x for x in p if degree[x] == 0)</span>
<span class="gi">+    u = last = next(iterator)</span>
<span class="gi">+    # This loop is identical to that for Prüfer sequences,</span>
<span class="gi">+    # except that we can draw nodes only from p</span>
<span class="gi">+    for v in N:</span>
<span class="gi">+        F.add_edge(u, v)</span>
<span class="gi">+        degree[v] -= 1</span>
<span class="gi">+        if v &lt; last and degree[v] == 0:</span>
<span class="gi">+            u = v</span>
<span class="gi">+        else:</span>
<span class="gi">+            last = u = next(iterator)</span>
<span class="gi">+</span>
<span class="gi">+    F.add_edge(u, roots[0])</span>
<span class="gi">+    F.graph[&quot;roots&quot;] = set(roots)</span>
<span class="gi">+    return F</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# The following functions support generation of unlabeled trees and forests.</span>


<span class="w"> </span>def _to_nx(edges, n_nodes, root=None, roots=None):
<span class="gu">@@ -423,7 +605,13 @@ def _to_nx(edges, n_nodes, root=None, roots=None):</span>
<span class="w"> </span>    :class:`networkx.Graph`
<span class="w"> </span>        The graph with `n_nodes` nodes and edges given by `edges`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    G = nx.empty_graph(n_nodes)</span>
<span class="gi">+    G.add_edges_from(edges)</span>
<span class="gi">+    if root is not None:</span>
<span class="gi">+        G.graph[&quot;root&quot;] = root</span>
<span class="gi">+    if roots is not None:</span>
<span class="gi">+        G.graph[&quot;roots&quot;] = roots</span>
<span class="gi">+    return G</span>


<span class="w"> </span>def _num_rooted_trees(n, cache_trees):
<span class="gu">@@ -444,7 +632,18 @@ def _num_rooted_trees(n, cache_trees):</span>
<span class="w"> </span>    int
<span class="w"> </span>        The number of unlabeled rooted trees with `n` nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for n_i in range(len(cache_trees), n + 1):</span>
<span class="gi">+        cache_trees.append(</span>
<span class="gi">+            sum(</span>
<span class="gi">+                [</span>
<span class="gi">+                    d * cache_trees[n_i - j * d] * cache_trees[d]</span>
<span class="gi">+                    for d in range(1, n_i)</span>
<span class="gi">+                    for j in range(1, (n_i - 1) // d + 1)</span>
<span class="gi">+                ]</span>
<span class="gi">+            )</span>
<span class="gi">+            // (n_i - 1)</span>
<span class="gi">+        )</span>
<span class="gi">+    return cache_trees[n]</span>


<span class="w"> </span>def _select_jd_trees(n, cache_trees, seed):
<span class="gu">@@ -475,7 +674,17 @@ def _select_jd_trees(n, cache_trees, seed):</span>
<span class="w"> </span>        Academic Press, 1978.
<span class="w"> </span>        https://doi.org/10.1016/C2013-0-11243-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    p = seed.randint(0, _num_rooted_trees(n, cache_trees) * (n - 1) - 1)</span>
<span class="gi">+    cumsum = 0</span>
<span class="gi">+    for d in range(n - 1, 0, -1):</span>
<span class="gi">+        for j in range(1, (n - 1) // d + 1):</span>
<span class="gi">+            cumsum += (</span>
<span class="gi">+                d</span>
<span class="gi">+                * _num_rooted_trees(n - j * d, cache_trees)</span>
<span class="gi">+                * _num_rooted_trees(d, cache_trees)</span>
<span class="gi">+            )</span>
<span class="gi">+            if p &lt; cumsum:</span>
<span class="gi">+                return (j, d)</span>


<span class="w"> </span>def _random_unlabeled_rooted_tree(n, cache_trees, seed):
<span class="gu">@@ -508,10 +717,26 @@ def _random_unlabeled_rooted_tree(n, cache_trees, seed):</span>
<span class="w"> </span>        Academic Press, 1978.
<span class="w"> </span>        https://doi.org/10.1016/C2013-0-11243-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@py_random_state(&#39;seed&#39;)</span>
<span class="gi">+    if n == 1:</span>
<span class="gi">+        edges, n_nodes = [], 1</span>
<span class="gi">+        return edges, n_nodes</span>
<span class="gi">+    if n == 2:</span>
<span class="gi">+        edges, n_nodes = [(0, 1)], 2</span>
<span class="gi">+        return edges, n_nodes</span>
<span class="gi">+</span>
<span class="gi">+    j, d = _select_jd_trees(n, cache_trees, seed)</span>
<span class="gi">+    t1, t1_nodes = _random_unlabeled_rooted_tree(n - j * d, cache_trees, seed)</span>
<span class="gi">+    t2, t2_nodes = _random_unlabeled_rooted_tree(d, cache_trees, seed)</span>
<span class="gi">+    t12 = [(0, t2_nodes * i + t1_nodes) for i in range(j)]</span>
<span class="gi">+    t1.extend(t12)</span>
<span class="gi">+    for _ in range(j):</span>
<span class="gi">+        t1.extend((n1 + t1_nodes, n2 + t1_nodes) for n1, n2 in t2)</span>
<span class="gi">+        t1_nodes += t2_nodes</span>
<span class="gi">+</span>
<span class="gi">+    return t1, t1_nodes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@py_random_state(&quot;seed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_unlabeled_rooted_tree(n, *, number_of_trees=None, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a number of unlabeled rooted trees uniformly at random
<span class="gu">@@ -557,7 +782,15 @@ def random_unlabeled_rooted_tree(n, *, number_of_trees=None, seed=None):</span>
<span class="w"> </span>        Academic Press, 1978.
<span class="w"> </span>        https://doi.org/10.1016/C2013-0-11243-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;the null graph is not a tree&quot;)</span>
<span class="gi">+    cache_trees = [0, 1]  # initial cache of number of rooted trees</span>
<span class="gi">+    if number_of_trees is None:</span>
<span class="gi">+        return _to_nx(*_random_unlabeled_rooted_tree(n, cache_trees, seed), root=0)</span>
<span class="gi">+    return [</span>
<span class="gi">+        _to_nx(*_random_unlabeled_rooted_tree(n, cache_trees, seed), root=0)</span>
<span class="gi">+        for i in range(number_of_trees)</span>
<span class="gi">+    ]</span>


<span class="w"> </span>def _num_rooted_forests(n, q, cache_forests):
<span class="gu">@@ -589,7 +822,20 @@ def _num_rooted_forests(n, q, cache_forests):</span>
<span class="w"> </span>        Journal of Algorithms 2.2 (1981): 204-207.
<span class="w"> </span>        https://doi.org/10.1016/0196-6774(81)90021-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for n_i in range(len(cache_forests), n + 1):</span>
<span class="gi">+        q_i = min(n_i, q)</span>
<span class="gi">+        cache_forests.append(</span>
<span class="gi">+            sum(</span>
<span class="gi">+                [</span>
<span class="gi">+                    d * cache_forests[n_i - j * d] * cache_forests[d - 1]</span>
<span class="gi">+                    for d in range(1, q_i + 1)</span>
<span class="gi">+                    for j in range(1, n_i // d + 1)</span>
<span class="gi">+                ]</span>
<span class="gi">+            )</span>
<span class="gi">+            // n_i</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return cache_forests[n]</span>


<span class="w"> </span>def _select_jd_forests(n, q, cache_forests, seed):
<span class="gu">@@ -618,7 +864,17 @@ def _select_jd_forests(n, q, cache_forests, seed):</span>
<span class="w"> </span>        Journal of Algorithms 2.2 (1981): 204-207.
<span class="w"> </span>        https://doi.org/10.1016/0196-6774(81)90021-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    p = seed.randint(0, _num_rooted_forests(n, q, cache_forests) * n - 1)</span>
<span class="gi">+    cumsum = 0</span>
<span class="gi">+    for d in range(q, 0, -1):</span>
<span class="gi">+        for j in range(1, n // d + 1):</span>
<span class="gi">+            cumsum += (</span>
<span class="gi">+                d</span>
<span class="gi">+                * _num_rooted_forests(n - j * d, q, cache_forests)</span>
<span class="gi">+                * _num_rooted_forests(d - 1, q, cache_forests)</span>
<span class="gi">+            )</span>
<span class="gi">+            if p &lt; cumsum:</span>
<span class="gi">+                return (j, d)</span>


<span class="w"> </span>def _random_unlabeled_rooted_forest(n, q, cache_trees, cache_forests, seed):
<span class="gu">@@ -650,13 +906,24 @@ def _random_unlabeled_rooted_forest(n, q, cache_trees, cache_forests, seed):</span>
<span class="w"> </span>        Journal of Algorithms 2.2 (1981): 204-207.
<span class="w"> </span>        https://doi.org/10.1016/0196-6774(81)90021-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@py_random_state(&#39;seed&#39;)</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        return ([], 0, [])</span>
<span class="gi">+</span>
<span class="gi">+    j, d = _select_jd_forests(n, q, cache_forests, seed)</span>
<span class="gi">+    t1, t1_nodes, r1 = _random_unlabeled_rooted_forest(</span>
<span class="gi">+        n - j * d, q, cache_trees, cache_forests, seed</span>
<span class="gi">+    )</span>
<span class="gi">+    t2, t2_nodes = _random_unlabeled_rooted_tree(d, cache_trees, seed)</span>
<span class="gi">+    for _ in range(j):</span>
<span class="gi">+        r1.append(t1_nodes)</span>
<span class="gi">+        t1.extend((n1 + t1_nodes, n2 + t1_nodes) for n1, n2 in t2)</span>
<span class="gi">+        t1_nodes += t2_nodes</span>
<span class="gi">+    return t1, t1_nodes, r1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@py_random_state(&quot;seed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def random_unlabeled_rooted_forest(n, *, q=None, number_of_forests=None,</span>
<span class="gd">-    seed=None):</span>
<span class="gi">+def random_unlabeled_rooted_forest(n, *, q=None, number_of_forests=None, seed=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a forest or list of forests selected at random.

<span class="w"> </span>    Returns one or more (depending on `number_of_forests`)
<span class="gu">@@ -703,7 +970,27 @@ def random_unlabeled_rooted_forest(n, *, q=None, number_of_forests=None,</span>
<span class="w"> </span>        Journal of Algorithms 2.2 (1981): 204-207.
<span class="w"> </span>        https://doi.org/10.1016/0196-6774(81)90021-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if q is None:</span>
<span class="gi">+        q = n</span>
<span class="gi">+    if q == 0 and n != 0:</span>
<span class="gi">+        raise ValueError(&quot;q must be a positive integer if n is positive.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    cache_trees = [0, 1]  # initial cache of number of rooted trees</span>
<span class="gi">+    cache_forests = [1]  # initial cache of number of rooted forests</span>
<span class="gi">+</span>
<span class="gi">+    if number_of_forests is None:</span>
<span class="gi">+        g, nodes, rs = _random_unlabeled_rooted_forest(</span>
<span class="gi">+            n, q, cache_trees, cache_forests, seed</span>
<span class="gi">+        )</span>
<span class="gi">+        return _to_nx(g, nodes, roots=set(rs))</span>
<span class="gi">+</span>
<span class="gi">+    res = []</span>
<span class="gi">+    for i in range(number_of_forests):</span>
<span class="gi">+        g, nodes, rs = _random_unlabeled_rooted_forest(</span>
<span class="gi">+            n, q, cache_trees, cache_forests, seed</span>
<span class="gi">+        )</span>
<span class="gi">+        res.append(_to_nx(g, nodes, roots=set(rs)))</span>
<span class="gi">+    return res</span>


<span class="w"> </span>def _num_trees(n, cache_trees):
<span class="gu">@@ -723,7 +1010,15 @@ def _num_trees(n, cache_trees):</span>
<span class="w"> </span>    int
<span class="w"> </span>        The number of unlabeled trees with `n` nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    r = _num_rooted_trees(n, cache_trees) - sum(</span>
<span class="gi">+        [</span>
<span class="gi">+            _num_rooted_trees(j, cache_trees) * _num_rooted_trees(n - j, cache_trees)</span>
<span class="gi">+            for j in range(1, n // 2 + 1)</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+    if n % 2 == 0:</span>
<span class="gi">+        r += comb(_num_rooted_trees(n // 2, cache_trees) + 1, 2)</span>
<span class="gi">+    return r</span>


<span class="w"> </span>def _bicenter(n, cache, seed):
<span class="gu">@@ -751,7 +1046,14 @@ def _bicenter(n, cache, seed):</span>
<span class="w"> </span>        Journal of Algorithms 2.2 (1981): 204-207.
<span class="w"> </span>        https://doi.org/10.1016/0196-6774(81)90021-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    t, t_nodes = _random_unlabeled_rooted_tree(n // 2, cache, seed)</span>
<span class="gi">+    if seed.randint(0, _num_rooted_trees(n // 2, cache)) == 0:</span>
<span class="gi">+        t2, t2_nodes = t, t_nodes</span>
<span class="gi">+    else:</span>
<span class="gi">+        t2, t2_nodes = _random_unlabeled_rooted_tree(n // 2, cache, seed)</span>
<span class="gi">+    t.extend([(n1 + (n // 2), n2 + (n // 2)) for n1, n2 in t2])</span>
<span class="gi">+    t.append((0, n // 2))</span>
<span class="gi">+    return t, t_nodes + t2_nodes</span>


<span class="w"> </span>def _random_unlabeled_tree(n, cache_trees, cache_forests, seed):
<span class="gu">@@ -781,10 +1083,22 @@ def _random_unlabeled_tree(n, cache_trees, cache_forests, seed):</span>
<span class="w"> </span>        Journal of Algorithms 2.2 (1981): 204-207.
<span class="w"> </span>        https://doi.org/10.1016/0196-6774(81)90021-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@py_random_state(&#39;seed&#39;)</span>
<span class="gi">+    if n % 2 == 1:</span>
<span class="gi">+        p = 0</span>
<span class="gi">+    else:</span>
<span class="gi">+        p = comb(_num_rooted_trees(n // 2, cache_trees) + 1, 2)</span>
<span class="gi">+    if seed.randint(0, _num_trees(n, cache_trees) - 1) &lt; p:</span>
<span class="gi">+        return _bicenter(n, cache_trees, seed)</span>
<span class="gi">+    else:</span>
<span class="gi">+        f, n_f, r = _random_unlabeled_rooted_forest(</span>
<span class="gi">+            n - 1, (n - 1) // 2, cache_trees, cache_forests, seed</span>
<span class="gi">+        )</span>
<span class="gi">+        for i in r:</span>
<span class="gi">+            f.append((i, n_f))</span>
<span class="gi">+        return f, n_f + 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@py_random_state(&quot;seed&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def random_unlabeled_tree(n, *, number_of_trees=None, seed=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a tree or list of trees chosen randomly.
<span class="gu">@@ -828,4 +1142,15 @@ def random_unlabeled_tree(n, *, number_of_trees=None, seed=None):</span>
<span class="w"> </span>        Journal of Algorithms 2.2 (1981): 204-207.
<span class="w"> </span>        https://doi.org/10.1016/0196-6774(81)90021-3
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n == 0:</span>
<span class="gi">+        raise nx.NetworkXPointlessConcept(&quot;the null graph is not a tree&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    cache_trees = [0, 1]  # initial cache of number of rooted trees</span>
<span class="gi">+    cache_forests = [1]  # initial cache of number of rooted forests</span>
<span class="gi">+    if number_of_trees is None:</span>
<span class="gi">+        return _to_nx(*_random_unlabeled_tree(n, cache_trees, cache_forests, seed))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return [</span>
<span class="gi">+            _to_nx(*_random_unlabeled_tree(n, cache_trees, cache_forests, seed))</span>
<span class="gi">+            for i in range(number_of_trees)</span>
<span class="gi">+        ]</span>
<span class="gh">diff --git a/networkx/generators/triads.py b/networkx/generators/triads.py</span>
<span class="gh">index fe4c0e896..5d380588b 100644</span>
<span class="gd">--- a/networkx/generators/triads.py</span>
<span class="gi">+++ b/networkx/generators/triads.py</span>
<span class="gu">@@ -1,17 +1,36 @@</span>
<span class="gi">+# See https://github.com/networkx/networkx/pull/1474</span>
<span class="gi">+# Copyright 2011 Reya Group &lt;http://www.reyagroup.com&gt;</span>
<span class="gi">+# Copyright 2011 Alex Levenson &lt;alex@isnotinvain.com&gt;</span>
<span class="gi">+# Copyright 2011 Diederik van Liere &lt;diederik.vanliere@rotman.utoronto.ca&gt;</span>
<span class="w"> </span>&quot;&quot;&quot;Functions that generate the triad graphs, that is, the possible
<span class="w"> </span>digraphs on three nodes.

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.classes import DiGraph
<span class="gd">-__all__ = [&#39;triad_graph&#39;]</span>
<span class="gd">-TRIAD_EDGES = {&#39;003&#39;: [], &#39;012&#39;: [&#39;ab&#39;], &#39;102&#39;: [&#39;ab&#39;, &#39;ba&#39;], &#39;021D&#39;: [&#39;ba&#39;,</span>
<span class="gd">-    &#39;bc&#39;], &#39;021U&#39;: [&#39;ab&#39;, &#39;cb&#39;], &#39;021C&#39;: [&#39;ab&#39;, &#39;bc&#39;], &#39;111D&#39;: [&#39;ac&#39;, &#39;ca&#39;,</span>
<span class="gd">-    &#39;bc&#39;], &#39;111U&#39;: [&#39;ac&#39;, &#39;ca&#39;, &#39;cb&#39;], &#39;030T&#39;: [&#39;ab&#39;, &#39;cb&#39;, &#39;ac&#39;], &#39;030C&#39;:</span>
<span class="gd">-    [&#39;ba&#39;, &#39;cb&#39;, &#39;ac&#39;], &#39;201&#39;: [&#39;ab&#39;, &#39;ba&#39;, &#39;ac&#39;, &#39;ca&#39;], &#39;120D&#39;: [&#39;bc&#39;,</span>
<span class="gd">-    &#39;ba&#39;, &#39;ac&#39;, &#39;ca&#39;], &#39;120U&#39;: [&#39;ab&#39;, &#39;cb&#39;, &#39;ac&#39;, &#39;ca&#39;], &#39;120C&#39;: [&#39;ab&#39;,</span>
<span class="gd">-    &#39;bc&#39;, &#39;ac&#39;, &#39;ca&#39;], &#39;210&#39;: [&#39;ab&#39;, &#39;bc&#39;, &#39;cb&#39;, &#39;ac&#39;, &#39;ca&#39;], &#39;300&#39;: [&#39;ab&#39;,</span>
<span class="gd">-    &#39;ba&#39;, &#39;bc&#39;, &#39;cb&#39;, &#39;ac&#39;, &#39;ca&#39;]}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;triad_graph&quot;]</span>
<span class="gi">+</span>
<span class="gi">+#: Dictionary mapping triad name to list of directed edges in the</span>
<span class="gi">+#: digraph representation of that triad (with nodes &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;).</span>
<span class="gi">+TRIAD_EDGES = {</span>
<span class="gi">+    &quot;003&quot;: [],</span>
<span class="gi">+    &quot;012&quot;: [&quot;ab&quot;],</span>
<span class="gi">+    &quot;102&quot;: [&quot;ab&quot;, &quot;ba&quot;],</span>
<span class="gi">+    &quot;021D&quot;: [&quot;ba&quot;, &quot;bc&quot;],</span>
<span class="gi">+    &quot;021U&quot;: [&quot;ab&quot;, &quot;cb&quot;],</span>
<span class="gi">+    &quot;021C&quot;: [&quot;ab&quot;, &quot;bc&quot;],</span>
<span class="gi">+    &quot;111D&quot;: [&quot;ac&quot;, &quot;ca&quot;, &quot;bc&quot;],</span>
<span class="gi">+    &quot;111U&quot;: [&quot;ac&quot;, &quot;ca&quot;, &quot;cb&quot;],</span>
<span class="gi">+    &quot;030T&quot;: [&quot;ab&quot;, &quot;cb&quot;, &quot;ac&quot;],</span>
<span class="gi">+    &quot;030C&quot;: [&quot;ba&quot;, &quot;cb&quot;, &quot;ac&quot;],</span>
<span class="gi">+    &quot;201&quot;: [&quot;ab&quot;, &quot;ba&quot;, &quot;ac&quot;, &quot;ca&quot;],</span>
<span class="gi">+    &quot;120D&quot;: [&quot;bc&quot;, &quot;ba&quot;, &quot;ac&quot;, &quot;ca&quot;],</span>
<span class="gi">+    &quot;120U&quot;: [&quot;ab&quot;, &quot;cb&quot;, &quot;ac&quot;, &quot;ca&quot;],</span>
<span class="gi">+    &quot;120C&quot;: [&quot;ab&quot;, &quot;bc&quot;, &quot;ac&quot;, &quot;ca&quot;],</span>
<span class="gi">+    &quot;210&quot;: [&quot;ab&quot;, &quot;bc&quot;, &quot;cb&quot;, &quot;ac&quot;, &quot;ca&quot;],</span>
<span class="gi">+    &quot;300&quot;: [&quot;ab&quot;, &quot;ba&quot;, &quot;bc&quot;, &quot;cb&quot;, &quot;ac&quot;, &quot;ca&quot;],</span>
<span class="gi">+}</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -63,4 +82,12 @@ def triad_graph(triad_name):</span>
<span class="w"> </span>    triadic_census

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if triad_name not in TRIAD_EDGES:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            f&#39;unknown triad name &quot;{triad_name}&quot;; use one of the triad names&#39;</span>
<span class="gi">+            &quot; in the TRIAD_NAMES constant&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    G = DiGraph()</span>
<span class="gi">+    G.add_nodes_from(&quot;abc&quot;)</span>
<span class="gi">+    G.add_edges_from(TRIAD_EDGES[triad_name])</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/lazy_imports.py b/networkx/lazy_imports.py</span>
<span class="gh">index b2ed7a12b..396404ba3 100644</span>
<span class="gd">--- a/networkx/lazy_imports.py</span>
<span class="gi">+++ b/networkx/lazy_imports.py</span>
<span class="gu">@@ -4,7 +4,8 @@ import inspect</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="gd">-__all__ = [&#39;attach&#39;, &#39;_lazy_import&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;attach&quot;, &quot;_lazy_import&quot;]</span>


<span class="w"> </span>def attach(module_name, submodules=None, submod_attrs=None):
<span class="gu">@@ -45,28 +46,55 @@ def attach(module_name, submodules=None, submod_attrs=None):</span>
<span class="w"> </span>    __getattr__, __dir__, __all__

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if submod_attrs is None:</span>
<span class="gi">+        submod_attrs = {}</span>
<span class="gi">+</span>
<span class="gi">+    if submodules is None:</span>
<span class="gi">+        submodules = set()</span>
<span class="gi">+    else:</span>
<span class="gi">+        submodules = set(submodules)</span>
<span class="gi">+</span>
<span class="gi">+    attr_to_modules = {</span>
<span class="gi">+        attr: mod for mod, attrs in submod_attrs.items() for attr in attrs</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    __all__ = list(submodules | attr_to_modules.keys())</span>
<span class="gi">+</span>
<span class="gi">+    def __getattr__(name):</span>
<span class="gi">+        if name in submodules:</span>
<span class="gi">+            return importlib.import_module(f&quot;{module_name}.{name}&quot;)</span>
<span class="gi">+        elif name in attr_to_modules:</span>
<span class="gi">+            submod = importlib.import_module(f&quot;{module_name}.{attr_to_modules[name]}&quot;)</span>
<span class="gi">+            return getattr(submod, name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AttributeError(f&quot;No {module_name} attribute {name}&quot;)</span>

<span class="gi">+    def __dir__():</span>
<span class="gi">+        return __all__</span>

<span class="gd">-class DelayedImportErrorModule(types.ModuleType):</span>
<span class="gi">+    if os.environ.get(&quot;EAGER_IMPORT&quot;, &quot;&quot;):</span>
<span class="gi">+        for attr in set(attr_to_modules.keys()) | submodules:</span>
<span class="gi">+            __getattr__(attr)</span>
<span class="gi">+</span>
<span class="gi">+    return __getattr__, __dir__, list(__all__)</span>

<span class="gi">+</span>
<span class="gi">+class DelayedImportErrorModule(types.ModuleType):</span>
<span class="w"> </span>    def __init__(self, frame_data, *args, **kwargs):
<span class="w"> </span>        self.__frame_data = frame_data
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="w"> </span>    def __getattr__(self, x):
<span class="gd">-        if x in (&#39;__class__&#39;, &#39;__file__&#39;, &#39;__frame_data&#39;):</span>
<span class="gi">+        if x in (&quot;__class__&quot;, &quot;__file__&quot;, &quot;__frame_data&quot;):</span>
<span class="w"> </span>            super().__getattr__(x)
<span class="w"> </span>        else:
<span class="w"> </span>            fd = self.__frame_data
<span class="w"> </span>            raise ModuleNotFoundError(
<span class="gd">-                f&quot;&quot;&quot;No module named &#39;{fd[&#39;spec&#39;]}&#39;</span>
<span class="gd">-</span>
<span class="gd">-This error is lazily reported, having originally occurred in</span>
<span class="gd">-  File {fd[&#39;filename&#39;]}, line {fd[&#39;lineno&#39;]}, in {fd[&#39;function&#39;]}</span>
<span class="gd">-</span>
<span class="gd">-----&gt; {&#39;&#39;.join(fd[&#39;code_context&#39;] or &#39;&#39;).strip()}&quot;&quot;&quot;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;No module named &#39;{fd[&#39;spec&#39;]}&#39;\n\n&quot;</span>
<span class="gi">+                &quot;This error is lazily reported, having originally occurred in\n&quot;</span>
<span class="gi">+                f&#39;  File {fd[&quot;filename&quot;]}, line {fd[&quot;lineno&quot;]}, in {fd[&quot;function&quot;]}\n\n&#39;</span>
<span class="gi">+                f&#39;----&gt; {&quot;&quot;.join(fd[&quot;code_context&quot;] or &quot;&quot;).strip()}&#39;</span>
<span class="gi">+            )</span>


<span class="w"> </span>def _lazy_import(fullname):
<span class="gu">@@ -129,4 +157,32 @@ def _lazy_import(fullname):</span>
<span class="w"> </span>        Actual loading of the module occurs upon first attribute request.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return sys.modules[fullname]</span>
<span class="gi">+    except:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Not previously loaded -- look it up</span>
<span class="gi">+    spec = importlib.util.find_spec(fullname)</span>
<span class="gi">+</span>
<span class="gi">+    if spec is None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            parent = inspect.stack()[1]</span>
<span class="gi">+            frame_data = {</span>
<span class="gi">+                &quot;spec&quot;: fullname,</span>
<span class="gi">+                &quot;filename&quot;: parent.filename,</span>
<span class="gi">+                &quot;lineno&quot;: parent.lineno,</span>
<span class="gi">+                &quot;function&quot;: parent.function,</span>
<span class="gi">+                &quot;code_context&quot;: parent.code_context,</span>
<span class="gi">+            }</span>
<span class="gi">+            return DelayedImportErrorModule(frame_data, &quot;DelayedImportErrorModule&quot;)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            del parent</span>
<span class="gi">+</span>
<span class="gi">+    module = importlib.util.module_from_spec(spec)</span>
<span class="gi">+    sys.modules[fullname] = module</span>
<span class="gi">+</span>
<span class="gi">+    loader = importlib.util.LazyLoader(spec.loader)</span>
<span class="gi">+    loader.exec_module(module)</span>
<span class="gi">+</span>
<span class="gi">+    return module</span>
<span class="gh">diff --git a/networkx/linalg/algebraicconnectivity.py b/networkx/linalg/algebraicconnectivity.py</span>
<span class="gh">index 78ad0d311..870b4ec5f 100644</span>
<span class="gd">--- a/networkx/linalg/algebraicconnectivity.py</span>
<span class="gi">+++ b/networkx/linalg/algebraicconnectivity.py</span>
<span class="gu">@@ -2,10 +2,20 @@</span>
<span class="w"> </span>Algebraic connectivity and Fiedler vectors of undirected graphs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from functools import partial
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-from networkx.utils import not_implemented_for, np_random_state, reverse_cuthill_mckee_ordering</span>
<span class="gd">-__all__ = [&#39;algebraic_connectivity&#39;, &#39;fiedler_vector&#39;, &#39;spectral_ordering&#39;,</span>
<span class="gd">-    &#39;spectral_bisection&#39;]</span>
<span class="gi">+from networkx.utils import (</span>
<span class="gi">+    not_implemented_for,</span>
<span class="gi">+    np_random_state,</span>
<span class="gi">+    reverse_cuthill_mckee_ordering,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;algebraic_connectivity&quot;,</span>
<span class="gi">+    &quot;fiedler_vector&quot;,</span>
<span class="gi">+    &quot;spectral_ordering&quot;,</span>
<span class="gi">+    &quot;spectral_bisection&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class _PCGSolver:
<span class="gu">@@ -28,6 +38,42 @@ class _PCGSolver:</span>
<span class="w"> </span>        self._A = A
<span class="w"> </span>        self._M = M

<span class="gi">+    def solve(self, B, tol):</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+        # Densifying step - can this be kept sparse?</span>
<span class="gi">+        B = np.asarray(B)</span>
<span class="gi">+        X = np.ndarray(B.shape, order=&quot;F&quot;)</span>
<span class="gi">+        for j in range(B.shape[1]):</span>
<span class="gi">+            X[:, j] = self._solve(B[:, j], tol)</span>
<span class="gi">+        return X</span>
<span class="gi">+</span>
<span class="gi">+    def _solve(self, b, tol):</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+        import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+        A = self._A</span>
<span class="gi">+        M = self._M</span>
<span class="gi">+        tol *= sp.linalg.blas.dasum(b)</span>
<span class="gi">+        # Initialize.</span>
<span class="gi">+        x = np.zeros(b.shape)</span>
<span class="gi">+        r = b.copy()</span>
<span class="gi">+        z = M(r)</span>
<span class="gi">+        rz = sp.linalg.blas.ddot(r, z)</span>
<span class="gi">+        p = z.copy()</span>
<span class="gi">+        # Iterate.</span>
<span class="gi">+        while True:</span>
<span class="gi">+            Ap = A(p)</span>
<span class="gi">+            alpha = rz / sp.linalg.blas.ddot(p, Ap)</span>
<span class="gi">+            x = sp.linalg.blas.daxpy(p, x, a=alpha)</span>
<span class="gi">+            r = sp.linalg.blas.daxpy(Ap, r, a=-alpha)</span>
<span class="gi">+            if sp.linalg.blas.dasum(r) &lt; tol:</span>
<span class="gi">+                return x</span>
<span class="gi">+            z = M(r)</span>
<span class="gi">+            beta = sp.linalg.blas.ddot(r, z)</span>
<span class="gi">+            beta, rz = beta / rz, beta</span>
<span class="gi">+            p = sp.linalg.blas.daxpy(p, z, a=beta)</span>
<span class="gi">+</span>

<span class="w"> </span>class _LUSolver:
<span class="w"> </span>    &quot;&quot;&quot;LU factorization.
<span class="gu">@@ -42,19 +88,63 @@ class _LUSolver:</span>

<span class="w"> </span>    def __init__(self, A):
<span class="w"> </span>        import scipy as sp
<span class="gd">-        self._LU = sp.sparse.linalg.splu(A, permc_spec=&#39;MMD_AT_PLUS_A&#39;,</span>
<span class="gd">-            diag_pivot_thresh=0.0, options={&#39;Equil&#39;: True, &#39;SymmetricMode&#39;:</span>
<span class="gd">-            True})</span>
<span class="gi">+</span>
<span class="gi">+        self._LU = sp.sparse.linalg.splu(</span>
<span class="gi">+            A,</span>
<span class="gi">+            permc_spec=&quot;MMD_AT_PLUS_A&quot;,</span>
<span class="gi">+            diag_pivot_thresh=0.0,</span>
<span class="gi">+            options={&quot;Equil&quot;: True, &quot;SymmetricMode&quot;: True},</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def solve(self, B, tol=None):</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+        B = np.asarray(B)</span>
<span class="gi">+        X = np.ndarray(B.shape, order=&quot;F&quot;)</span>
<span class="gi">+        for j in range(B.shape[1]):</span>
<span class="gi">+            X[:, j] = self._LU.solve(B[:, j])</span>
<span class="gi">+        return X</span>


<span class="w"> </span>def _preprocess_graph(G, weight):
<span class="w"> </span>    &quot;&quot;&quot;Compute edge weights and eliminate zero-weight edges.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        H = nx.MultiGraph()</span>
<span class="gi">+        H.add_nodes_from(G)</span>
<span class="gi">+        H.add_weighted_edges_from(</span>
<span class="gi">+            ((u, v, e.get(weight, 1.0)) for u, v, e in G.edges(data=True) if u != v),</span>
<span class="gi">+            weight=weight,</span>
<span class="gi">+        )</span>
<span class="gi">+        G = H</span>
<span class="gi">+    if not G.is_multigraph():</span>
<span class="gi">+        edges = (</span>
<span class="gi">+            (u, v, abs(e.get(weight, 1.0))) for u, v, e in G.edges(data=True) if u != v</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        edges = (</span>
<span class="gi">+            (u, v, sum(abs(e.get(weight, 1.0)) for e in G[u][v].values()))</span>
<span class="gi">+            for u, v in G.edges()</span>
<span class="gi">+            if u != v</span>
<span class="gi">+        )</span>
<span class="gi">+    H = nx.Graph()</span>
<span class="gi">+    H.add_nodes_from(G)</span>
<span class="gi">+    H.add_weighted_edges_from((u, v, e) for u, v, e in edges if e != 0)</span>
<span class="gi">+    return H</span>


<span class="w"> </span>def _rcm_estimate(G, nodelist):
<span class="w"> </span>    &quot;&quot;&quot;Estimate the Fiedler vector using the reverse Cuthill-McKee ordering.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    G = G.subgraph(nodelist)</span>
<span class="gi">+    order = reverse_cuthill_mckee_ordering(G)</span>
<span class="gi">+    n = len(nodelist)</span>
<span class="gi">+    index = dict(zip(nodelist, range(n)))</span>
<span class="gi">+    x = np.ndarray(n, dtype=float)</span>
<span class="gi">+    for i, u in enumerate(order):</span>
<span class="gi">+        x[index[u]] = i</span>
<span class="gi">+    x -= (n - 1) / 2.0</span>
<span class="gi">+    return x</span>


<span class="w"> </span>def _tracemin_fiedler(L, X, normalized, tol, method):
<span class="gu">@@ -91,20 +181,142 @@ def _tracemin_fiedler(L, X, normalized, tol, method):</span>
<span class="w"> </span>        As this is for Fiedler vectors, the zero eigenvalue (and
<span class="w"> </span>        constant eigenvector) are avoided.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    n = X.shape[0]</span>
<span class="gi">+</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        # Form the normalized Laplacian matrix and determine the eigenvector of</span>
<span class="gi">+        # its nullspace.</span>
<span class="gi">+        e = np.sqrt(L.diagonal())</span>
<span class="gi">+        # TODO: rm csr_array wrapper when spdiags array creation becomes available</span>
<span class="gi">+        D = sp.sparse.csr_array(sp.sparse.spdiags(1 / e, 0, n, n, format=&quot;csr&quot;))</span>
<span class="gi">+        L = D @ L @ D</span>
<span class="gi">+        e *= 1.0 / np.linalg.norm(e, 2)</span>
<span class="gi">+</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+</span>
<span class="gi">+        def project(X):</span>
<span class="gi">+            &quot;&quot;&quot;Make X orthogonal to the nullspace of L.&quot;&quot;&quot;</span>
<span class="gi">+            X = np.asarray(X)</span>
<span class="gi">+            for j in range(X.shape[1]):</span>
<span class="gi">+                X[:, j] -= (X[:, j] @ e) * e</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def project(X):</span>
<span class="gi">+            &quot;&quot;&quot;Make X orthogonal to the nullspace of L.&quot;&quot;&quot;</span>
<span class="gi">+            X = np.asarray(X)</span>
<span class="gi">+            for j in range(X.shape[1]):</span>
<span class="gi">+                X[:, j] -= X[:, j].sum() / n</span>
<span class="gi">+</span>
<span class="gi">+    if method == &quot;tracemin_pcg&quot;:</span>
<span class="gi">+        D = L.diagonal().astype(float)</span>
<span class="gi">+        solver = _PCGSolver(lambda x: L @ x, lambda x: D * x)</span>
<span class="gi">+    elif method == &quot;tracemin_lu&quot;:</span>
<span class="gi">+        # Convert A to CSC to suppress SparseEfficiencyWarning.</span>
<span class="gi">+        A = sp.sparse.csc_array(L, dtype=float, copy=True)</span>
<span class="gi">+        # Force A to be nonsingular. Since A is the Laplacian matrix of a</span>
<span class="gi">+        # connected graph, its rank deficiency is one, and thus one diagonal</span>
<span class="gi">+        # element needs to modified. Changing to infinity forces a zero in the</span>
<span class="gi">+        # corresponding element in the solution.</span>
<span class="gi">+        i = (A.indptr[1:] - A.indptr[:-1]).argmax()</span>
<span class="gi">+        A[i, i] = np.inf</span>
<span class="gi">+        solver = _LUSolver(A)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Unknown linear system solver: {method}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Initialize.</span>
<span class="gi">+    Lnorm = abs(L).sum(axis=1).flatten().max()</span>
<span class="gi">+    project(X)</span>
<span class="gi">+    W = np.ndarray(X.shape, order=&quot;F&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        # Orthonormalize X.</span>
<span class="gi">+        X = np.linalg.qr(X)[0]</span>
<span class="gi">+        # Compute iteration matrix H.</span>
<span class="gi">+        W[:, :] = L @ X</span>
<span class="gi">+        H = X.T @ W</span>
<span class="gi">+        sigma, Y = sp.linalg.eigh(H, overwrite_a=True)</span>
<span class="gi">+        # Compute the Ritz vectors.</span>
<span class="gi">+        X = X @ Y</span>
<span class="gi">+        # Test for convergence exploiting the fact that L * X == W * Y.</span>
<span class="gi">+        res = sp.linalg.blas.dasum(W @ Y[:, 0] - sigma[0] * X[:, 0]) / Lnorm</span>
<span class="gi">+        if res &lt; tol:</span>
<span class="gi">+            break</span>
<span class="gi">+        # Compute X = L \ X / (X&#39; * (L \ X)).</span>
<span class="gi">+        # L \ X can have an arbitrary projection on the nullspace of L,</span>
<span class="gi">+        # which will be eliminated.</span>
<span class="gi">+        W[:, :] = solver.solve(X, tol)</span>
<span class="gi">+        X = (sp.linalg.inv(W.T @ X) @ W.T).T  # Preserves Fortran storage order.</span>
<span class="gi">+        project(X)</span>
<span class="gi">+</span>
<span class="gi">+    return sigma, np.asarray(X)</span>


<span class="w"> </span>def _get_fiedler_func(method):
<span class="w"> </span>    &quot;&quot;&quot;Returns a function that solves the Fiedler eigenvalue problem.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if method == &quot;tracemin&quot;:  # old style keyword &lt;v2.1</span>
<span class="gi">+        method = &quot;tracemin_pcg&quot;</span>
<span class="gi">+    if method in (&quot;tracemin_pcg&quot;, &quot;tracemin_lu&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        def find_fiedler(L, x, normalized, tol, seed):</span>
<span class="gi">+            q = 1 if method == &quot;tracemin_pcg&quot; else min(4, L.shape[0] - 1)</span>
<span class="gi">+            X = np.asarray(seed.normal(size=(q, L.shape[0]))).T</span>
<span class="gi">+            sigma, X = _tracemin_fiedler(L, X, normalized, tol, method)</span>
<span class="gi">+            return sigma[0], X[:, 0]</span>
<span class="gi">+</span>
<span class="gi">+    elif method == &quot;lanczos&quot; or method == &quot;lobpcg&quot;:</span>
<span class="gi">+</span>
<span class="gi">+        def find_fiedler(L, x, normalized, tol, seed):</span>
<span class="gi">+            import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+            L = sp.sparse.csc_array(L, dtype=float)</span>
<span class="gi">+            n = L.shape[0]</span>
<span class="gi">+            if normalized:</span>
<span class="gi">+                # TODO: rm csc_array wrapping when spdiags array becomes available</span>
<span class="gi">+                D = sp.sparse.csc_array(</span>
<span class="gi">+                    sp.sparse.spdiags(</span>
<span class="gi">+                        1.0 / np.sqrt(L.diagonal()), [0], n, n, format=&quot;csc&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                L = D @ L @ D</span>
<span class="gi">+            if method == &quot;lanczos&quot; or n &lt; 10:</span>
<span class="gi">+                # Avoid LOBPCG when n &lt; 10 due to</span>
<span class="gi">+                # https://github.com/scipy/scipy/issues/3592</span>
<span class="gi">+                # https://github.com/scipy/scipy/pull/3594</span>
<span class="gi">+                sigma, X = sp.sparse.linalg.eigsh(</span>
<span class="gi">+                    L, 2, which=&quot;SM&quot;, tol=tol, return_eigenvectors=True</span>
<span class="gi">+                )</span>
<span class="gi">+                return sigma[1], X[:, 1]</span>
<span class="gi">+            else:</span>
<span class="gi">+                X = np.asarray(np.atleast_2d(x).T)</span>
<span class="gi">+                # TODO: rm csr_array wrapping when spdiags array becomes available</span>
<span class="gi">+                M = sp.sparse.csr_array(sp.sparse.spdiags(1.0 / L.diagonal(), 0, n, n))</span>
<span class="gi">+                Y = np.ones(n)</span>
<span class="gi">+                if normalized:</span>
<span class="gi">+                    Y /= D.diagonal()</span>
<span class="gi">+                sigma, X = sp.sparse.linalg.lobpcg(</span>
<span class="gi">+                    L, X, M=M, Y=np.atleast_2d(Y).T, tol=tol, maxiter=n, largest=False</span>
<span class="gi">+                )</span>
<span class="gi">+                return sigma[0], X[:, 0]</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;unknown method {method!r}.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return find_fiedler</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@np_random_state(5)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def algebraic_connectivity(G, weight=&#39;weight&#39;, normalized=False, tol=1e-08,</span>
<span class="gd">-    method=&#39;tracemin_pcg&#39;, seed=None):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the algebraic connectivity of an undirected graph.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def algebraic_connectivity(</span>
<span class="gi">+    G, weight=&quot;weight&quot;, normalized=False, tol=1e-8, method=&quot;tracemin_pcg&quot;, seed=None</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the algebraic connectivity of an undirected graph.</span>

<span class="w"> </span>    The algebraic connectivity of a connected undirected graph is the second
<span class="w"> </span>    smallest eigenvalue of its Laplacian matrix.
<span class="gu">@@ -178,14 +390,28 @@ def algebraic_connectivity(G, weight=&#39;weight&#39;, normalized=False, tol=1e-08,</span>
<span class="w"> </span>    False

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(G) &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph has less than two nodes.&quot;)</span>
<span class="gi">+    G = _preprocess_graph(G, weight)</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        return 0.0</span>
<span class="gi">+</span>
<span class="gi">+    L = nx.laplacian_matrix(G)</span>
<span class="gi">+    if L.shape[0] == 2:</span>
<span class="gi">+        return 2.0 * float(L[0, 0]) if not normalized else 2.0</span>

<span class="gi">+    find_fiedler = _get_fiedler_func(method)</span>
<span class="gi">+    x = None if method != &quot;lobpcg&quot; else _rcm_estimate(G, G)</span>
<span class="gi">+    sigma, fiedler = find_fiedler(L, x, normalized, tol, seed)</span>
<span class="gi">+    return float(sigma)</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="w"> </span>@np_random_state(5)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def fiedler_vector(G, weight=&#39;weight&#39;, normalized=False, tol=1e-08, method=</span>
<span class="gd">-    &#39;tracemin_pcg&#39;, seed=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def fiedler_vector(</span>
<span class="gi">+    G, weight=&quot;weight&quot;, normalized=False, tol=1e-8, method=&quot;tracemin_pcg&quot;, seed=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the Fiedler vector of a connected undirected graph.

<span class="w"> </span>    The Fiedler vector of a connected undirected graph is the eigenvector
<span class="gu">@@ -260,13 +486,29 @@ def fiedler_vector(G, weight=&#39;weight&#39;, normalized=False, tol=1e-08, method=</span>

<span class="w"> </span>    The connected components are the two 5-node cliques of the barbell graph.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) &lt; 2:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph has less than two nodes.&quot;)</span>
<span class="gi">+    G = _preprocess_graph(G, weight)</span>
<span class="gi">+    if not nx.is_connected(G):</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph is not connected.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if len(G) == 2:</span>
<span class="gi">+        return np.array([1.0, -1.0])</span>
<span class="gi">+</span>
<span class="gi">+    find_fiedler = _get_fiedler_func(method)</span>
<span class="gi">+    L = nx.laplacian_matrix(G)</span>
<span class="gi">+    x = None if method != &quot;lobpcg&quot; else _rcm_estimate(G, G)</span>
<span class="gi">+    sigma, fiedler = find_fiedler(L, x, normalized, tol, seed)</span>
<span class="gi">+    return fiedler</span>


<span class="w"> </span>@np_random_state(5)
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def spectral_ordering(G, weight=&#39;weight&#39;, normalized=False, tol=1e-08,</span>
<span class="gd">-    method=&#39;tracemin_pcg&#39;, seed=None):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def spectral_ordering(</span>
<span class="gi">+    G, weight=&quot;weight&quot;, normalized=False, tol=1e-8, method=&quot;tracemin_pcg&quot;, seed=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Compute the spectral_ordering of a graph.

<span class="w"> </span>    The spectral ordering of a graph is an ordering of its nodes where nodes
<span class="gu">@@ -326,12 +568,30 @@ def spectral_ordering(G, weight=&#39;weight&#39;, normalized=False, tol=1e-08,</span>
<span class="w"> </span>    --------
<span class="w"> </span>    laplacian_matrix
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def spectral_bisection(G, weight=&#39;weight&#39;, normalized=False, tol=1e-08,</span>
<span class="gd">-    method=&#39;tracemin_pcg&#39;, seed=None):</span>
<span class="gi">+    if len(G) == 0:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;graph is empty.&quot;)</span>
<span class="gi">+    G = _preprocess_graph(G, weight)</span>
<span class="gi">+</span>
<span class="gi">+    find_fiedler = _get_fiedler_func(method)</span>
<span class="gi">+    order = []</span>
<span class="gi">+    for component in nx.connected_components(G):</span>
<span class="gi">+        size = len(component)</span>
<span class="gi">+        if size &gt; 2:</span>
<span class="gi">+            L = nx.laplacian_matrix(G, component)</span>
<span class="gi">+            x = None if method != &quot;lobpcg&quot; else _rcm_estimate(G, component)</span>
<span class="gi">+            sigma, fiedler = find_fiedler(L, x, normalized, tol, seed)</span>
<span class="gi">+            sort_info = zip(fiedler, range(size), component)</span>
<span class="gi">+            order.extend(u for x, c, u in sorted(sort_info))</span>
<span class="gi">+        else:</span>
<span class="gi">+            order.extend(component)</span>
<span class="gi">+</span>
<span class="gi">+    return order</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def spectral_bisection(</span>
<span class="gi">+    G, weight=&quot;weight&quot;, normalized=False, tol=1e-8, method=&quot;tracemin_pcg&quot;, seed=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Bisect the graph using the Fiedler vector.

<span class="w"> </span>    This method uses the Fiedler vector to bisect a graph.
<span class="gu">@@ -387,4 +647,10 @@ def spectral_bisection(G, weight=&#39;weight&#39;, normalized=False, tol=1e-08,</span>
<span class="w"> </span>    .. [1] M. E. J Newman &#39;Networks: An Introduction&#39;, pages 364-370
<span class="w"> </span>       Oxford University Press 2011.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    v = nx.fiedler_vector(G, weight, normalized, tol, method, seed)</span>
<span class="gi">+    nodes = np.array(list(G))</span>
<span class="gi">+    pos_vals = v &gt;= 0</span>
<span class="gi">+</span>
<span class="gi">+    return set(nodes[~pos_vals].tolist()), set(nodes[pos_vals].tolist())</span>
<span class="gh">diff --git a/networkx/linalg/attrmatrix.py b/networkx/linalg/attrmatrix.py</span>
<span class="gh">index 1e2c42177..4882c35af 100644</span>
<span class="gd">--- a/networkx/linalg/attrmatrix.py</span>
<span class="gi">+++ b/networkx/linalg/attrmatrix.py</span>
<span class="gu">@@ -2,7 +2,8 @@</span>
<span class="w"> </span>    Functions for constructing matrix-like objects from graph attributes.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;attr_matrix&#39;, &#39;attr_sparse_matrix&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;attr_matrix&quot;, &quot;attr_sparse_matrix&quot;]</span>


<span class="w"> </span>def _node_value(G, node_attr):
<span class="gu">@@ -29,7 +30,25 @@ def _node_value(G, node_attr):</span>
<span class="w"> </span>        returns a value from G.nodes[u] that depends on `edge_attr`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node_attr is None:</span>
<span class="gi">+</span>
<span class="gi">+        def value(u):</span>
<span class="gi">+            return u</span>
<span class="gi">+</span>
<span class="gi">+    elif not callable(node_attr):</span>
<span class="gi">+        # assume it is a key for the node attribute dictionary</span>
<span class="gi">+        def value(u):</span>
<span class="gi">+            return G.nodes[u][node_attr]</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Advanced:  Allow users to specify something else.</span>
<span class="gi">+        #</span>
<span class="gi">+        # For example,</span>
<span class="gi">+        #     node_attr = lambda u: G.nodes[u].get(&#39;size&#39;, .5) * 3</span>
<span class="gi">+        #</span>
<span class="gi">+        value = node_attr</span>
<span class="gi">+</span>
<span class="gi">+    return value</span>


<span class="w"> </span>def _edge_value(G, edge_attr):
<span class="gu">@@ -62,12 +81,77 @@ def _edge_value(G, edge_attr):</span>
<span class="w"> </span>        return a value from G[u][v] that depends on `edge_attr`.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    if edge_attr is None:</span>
<span class="gi">+        # topological count of edges</span>
<span class="gi">+</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+</span>
<span class="gi">+            def value(u, v):</span>
<span class="gi">+                return len(G[u][v])</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+</span>
<span class="gi">+            def value(u, v):</span>
<span class="gi">+                return 1</span>
<span class="gi">+</span>
<span class="gi">+    elif not callable(edge_attr):</span>
<span class="gi">+        # assume it is a key for the edge attribute dictionary</span>
<span class="gi">+</span>
<span class="gi">+        if edge_attr == &quot;weight&quot;:</span>
<span class="gi">+            # provide a default value</span>
<span class="gi">+            if G.is_multigraph():</span>
<span class="gi">+</span>
<span class="gi">+                def value(u, v):</span>
<span class="gi">+                    return sum(d.get(edge_attr, 1) for d in G[u][v].values())</span>

<span class="gd">-@nx._dispatchable(edge_attrs={&#39;edge_attr&#39;: None}, node_attrs=&#39;node_attr&#39;)</span>
<span class="gd">-def attr_matrix(G, edge_attr=None, node_attr=None, normalized=False,</span>
<span class="gd">-    rc_order=None, dtype=None, order=None):</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                def value(u, v):</span>
<span class="gi">+                    return G[u][v].get(edge_attr, 1)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # otherwise, the edge attribute MUST exist for each edge</span>
<span class="gi">+            if G.is_multigraph():</span>
<span class="gi">+</span>
<span class="gi">+                def value(u, v):</span>
<span class="gi">+                    return sum(d[edge_attr] for d in G[u][v].values())</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+</span>
<span class="gi">+                def value(u, v):</span>
<span class="gi">+                    return G[u][v][edge_attr]</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Advanced:  Allow users to specify something else.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Alternative default value:</span>
<span class="gi">+        #     edge_attr = lambda u,v: G[u][v].get(&#39;thickness&#39;, .5)</span>
<span class="gi">+        #</span>
<span class="gi">+        # Function on an attribute:</span>
<span class="gi">+        #     edge_attr = lambda u,v: abs(G[u][v][&#39;weight&#39;])</span>
<span class="gi">+        #</span>
<span class="gi">+        # Handle Multi(Di)Graphs differently:</span>
<span class="gi">+        #     edge_attr = lambda u,v: numpy.prod([d[&#39;size&#39;] for d in G[u][v].values()])</span>
<span class="gi">+        #</span>
<span class="gi">+        # Ignore multiple edges</span>
<span class="gi">+        #     edge_attr = lambda u,v: 1 if len(G[u][v]) else 0</span>
<span class="gi">+        #</span>
<span class="gi">+        value = edge_attr</span>
<span class="gi">+</span>
<span class="gi">+    return value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;edge_attr&quot;: None}, node_attrs=&quot;node_attr&quot;)</span>
<span class="gi">+def attr_matrix(</span>
<span class="gi">+    G,</span>
<span class="gi">+    edge_attr=None,</span>
<span class="gi">+    node_attr=None,</span>
<span class="gi">+    normalized=False,</span>
<span class="gi">+    rc_order=None,</span>
<span class="gi">+    dtype=None,</span>
<span class="gi">+    order=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the attribute matrix using attributes from `G` as a numpy array.

<span class="w"> </span>    If only `G` is passed in, then the adjacency matrix is constructed.
<span class="gu">@@ -185,12 +269,47 @@ def attr_matrix(G, edge_attr=None, node_attr=None, normalized=False,</span>
<span class="w"> </span>        (blue, blue) is 0   # there are no edges with blue endpoints

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs={&#39;edge_attr&#39;: None}, node_attrs=&#39;node_attr&#39;)</span>
<span class="gd">-def attr_sparse_matrix(G, edge_attr=None, node_attr=None, normalized=False,</span>
<span class="gd">-    rc_order=None, dtype=None):</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    edge_value = _edge_value(G, edge_attr)</span>
<span class="gi">+    node_value = _node_value(G, node_attr)</span>
<span class="gi">+</span>
<span class="gi">+    if rc_order is None:</span>
<span class="gi">+        ordering = list({node_value(n) for n in G})</span>
<span class="gi">+    else:</span>
<span class="gi">+        ordering = rc_order</span>
<span class="gi">+</span>
<span class="gi">+    N = len(ordering)</span>
<span class="gi">+    undirected = not G.is_directed()</span>
<span class="gi">+    index = dict(zip(ordering, range(N)))</span>
<span class="gi">+    M = np.zeros((N, N), dtype=dtype, order=order)</span>
<span class="gi">+</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for u, nbrdict in G.adjacency():</span>
<span class="gi">+        for v in nbrdict:</span>
<span class="gi">+            # Obtain the node attribute values.</span>
<span class="gi">+            i, j = index[node_value(u)], index[node_value(v)]</span>
<span class="gi">+            if v not in seen:</span>
<span class="gi">+                M[i, j] += edge_value(u, v)</span>
<span class="gi">+                if undirected:</span>
<span class="gi">+                    M[j, i] = M[i, j]</span>
<span class="gi">+</span>
<span class="gi">+        if undirected:</span>
<span class="gi">+            seen.add(u)</span>
<span class="gi">+</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        M /= M.sum(axis=1).reshape((N, 1))</span>
<span class="gi">+</span>
<span class="gi">+    if rc_order is None:</span>
<span class="gi">+        return M, ordering</span>
<span class="gi">+    else:</span>
<span class="gi">+        return M</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs={&quot;edge_attr&quot;: None}, node_attrs=&quot;node_attr&quot;)</span>
<span class="gi">+def attr_sparse_matrix(</span>
<span class="gi">+    G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a SciPy sparse array using attributes from G.

<span class="w"> </span>    If only `G` is passed in, then the adjacency matrix is constructed.
<span class="gu">@@ -307,4 +426,39 @@ def attr_sparse_matrix(G, edge_attr=None, node_attr=None, normalized=False,</span>
<span class="w"> </span>        (blue, blue) is 0   # there are no edges with blue endpoints

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    edge_value = _edge_value(G, edge_attr)</span>
<span class="gi">+    node_value = _node_value(G, node_attr)</span>
<span class="gi">+</span>
<span class="gi">+    if rc_order is None:</span>
<span class="gi">+        ordering = list({node_value(n) for n in G})</span>
<span class="gi">+    else:</span>
<span class="gi">+        ordering = rc_order</span>
<span class="gi">+</span>
<span class="gi">+    N = len(ordering)</span>
<span class="gi">+    undirected = not G.is_directed()</span>
<span class="gi">+    index = dict(zip(ordering, range(N)))</span>
<span class="gi">+    M = sp.sparse.lil_array((N, N), dtype=dtype)</span>
<span class="gi">+</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for u, nbrdict in G.adjacency():</span>
<span class="gi">+        for v in nbrdict:</span>
<span class="gi">+            # Obtain the node attribute values.</span>
<span class="gi">+            i, j = index[node_value(u)], index[node_value(v)]</span>
<span class="gi">+            if v not in seen:</span>
<span class="gi">+                M[i, j] += edge_value(u, v)</span>
<span class="gi">+                if undirected:</span>
<span class="gi">+                    M[j, i] = M[i, j]</span>
<span class="gi">+</span>
<span class="gi">+        if undirected:</span>
<span class="gi">+            seen.add(u)</span>
<span class="gi">+</span>
<span class="gi">+    if normalized:</span>
<span class="gi">+        M *= 1 / M.sum(axis=1)[:, np.newaxis]  # in-place mult preserves sparse</span>
<span class="gi">+</span>
<span class="gi">+    if rc_order is None:</span>
<span class="gi">+        return M, ordering</span>
<span class="gi">+    else:</span>
<span class="gi">+        return M</span>
<span class="gh">diff --git a/networkx/linalg/bethehessianmatrix.py b/networkx/linalg/bethehessianmatrix.py</span>
<span class="gh">index ee2e467c9..382e51810 100644</span>
<span class="gd">--- a/networkx/linalg/bethehessianmatrix.py</span>
<span class="gi">+++ b/networkx/linalg/bethehessianmatrix.py</span>
<span class="gu">@@ -1,14 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Bethe Hessian or deformed Laplacian matrix of graphs.&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;bethe_hessian_matrix&#39;]</span>

<span class="gi">+__all__ = [&quot;bethe_hessian_matrix&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>@nx._dispatchable
<span class="w"> </span>def bethe_hessian_matrix(G, r=None, nodelist=None):
<span class="gd">-    &quot;&quot;&quot;Returns the Bethe Hessian matrix of G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the Bethe Hessian matrix of G.</span>

<span class="w"> </span>    The Bethe Hessian is a family of matrices parametrized by r, defined as
<span class="w"> </span>    H(r) = (r^2 - 1) I - r A + D where A is the adjacency matrix, D is the
<span class="gu">@@ -18,7 +19,7 @@ def bethe_hessian_matrix(G, r=None, nodelist=None):</span>
<span class="w"> </span>    The default choice of regularizer should be the ratio [2]_

<span class="w"> </span>    .. math::
<span class="gd">-      r_m = \\left(\\sum k_i \\right)^{-1}\\left(\\sum k_i^2 \\right) - 1</span>
<span class="gi">+      r_m = \left(\sum k_i \right)^{-1}\left(\sum k_i^2 \right) - 1</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -62,4 +63,16 @@ def bethe_hessian_matrix(G, r=None, nodelist=None):</span>
<span class="w"> </span>       &quot;Estimating the number of communities in networks by spectral methods&quot;
<span class="w"> </span>       arXiv:1507.00827, 2015.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+    if r is None:</span>
<span class="gi">+        r = sum(d**2 for v, d in nx.degree(G)) / sum(d for v, d in nx.degree(G)) - 1</span>
<span class="gi">+    A = nx.to_scipy_sparse_array(G, nodelist=nodelist, format=&quot;csr&quot;)</span>
<span class="gi">+    n, m = A.shape</span>
<span class="gi">+    # TODO: Rm csr_array wrapper when spdiags array creation becomes available</span>
<span class="gi">+    D = sp.sparse.csr_array(sp.sparse.spdiags(A.sum(axis=1), 0, m, n, format=&quot;csr&quot;))</span>
<span class="gi">+    # TODO: Rm csr_array wrapper when eye array creation becomes available</span>
<span class="gi">+    I = sp.sparse.csr_array(sp.sparse.eye(m, n, format=&quot;csr&quot;))</span>
<span class="gi">+    return (r**2 - 1) * I - r * A + D</span>
<span class="gh">diff --git a/networkx/linalg/graphmatrix.py b/networkx/linalg/graphmatrix.py</span>
<span class="gh">index 02c982d26..640fccc6e 100644</span>
<span class="gd">--- a/networkx/linalg/graphmatrix.py</span>
<span class="gi">+++ b/networkx/linalg/graphmatrix.py</span>
<span class="gu">@@ -2,12 +2,14 @@</span>
<span class="w"> </span>Adjacency matrix and incidence matrix of graphs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;incidence_matrix&#39;, &#39;adjacency_matrix&#39;]</span>

<span class="gi">+__all__ = [&quot;incidence_matrix&quot;, &quot;adjacency_matrix&quot;]</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def incidence_matrix(G, nodelist=None, edgelist=None, oriented=False,</span>
<span class="gd">-    weight=None, *, dtype=None):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def incidence_matrix(</span>
<span class="gi">+    G, nodelist=None, edgelist=None, oriented=False, weight=None, *, dtype=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns incidence matrix of G.

<span class="w"> </span>    The incidence matrix assigns each row to a node and each column to an edge.
<span class="gu">@@ -63,11 +65,47 @@ def incidence_matrix(G, nodelist=None, edgelist=None, oriented=False,</span>
<span class="w"> </span>    .. [1] Gil Strang, Network applications: A = incidence matrix,
<span class="w"> </span>       http://videolectures.net/mit18085f07_strang_lec03/
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def adjacency_matrix(G, nodelist=None, dtype=None, weight=&#39;weight&#39;):</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+    if edgelist is None:</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            edgelist = list(G.edges(keys=True))</span>
<span class="gi">+        else:</span>
<span class="gi">+            edgelist = list(G.edges())</span>
<span class="gi">+    A = sp.sparse.lil_array((len(nodelist), len(edgelist)), dtype=dtype)</span>
<span class="gi">+    node_index = {node: i for i, node in enumerate(nodelist)}</span>
<span class="gi">+    for ei, e in enumerate(edgelist):</span>
<span class="gi">+        (u, v) = e[:2]</span>
<span class="gi">+        if u == v:</span>
<span class="gi">+            continue  # self loops give zero column</span>
<span class="gi">+        try:</span>
<span class="gi">+            ui = node_index[u]</span>
<span class="gi">+            vi = node_index[v]</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;node {u} or {v} in edgelist but not in nodelist&quot;</span>
<span class="gi">+            ) from err</span>
<span class="gi">+        if weight is None:</span>
<span class="gi">+            wt = 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            if G.is_multigraph():</span>
<span class="gi">+                ekey = e[2]</span>
<span class="gi">+                wt = G[u][v][ekey].get(weight, 1)</span>
<span class="gi">+            else:</span>
<span class="gi">+                wt = G[u][v].get(weight, 1)</span>
<span class="gi">+        if oriented:</span>
<span class="gi">+            A[ui, ei] = -wt</span>
<span class="gi">+            A[vi, ei] = wt</span>
<span class="gi">+        else:</span>
<span class="gi">+            A[ui, ei] = wt</span>
<span class="gi">+            A[vi, ei] = wt</span>
<span class="gi">+    return A.asformat(&quot;csc&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def adjacency_matrix(G, nodelist=None, dtype=None, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns adjacency matrix of G.

<span class="w"> </span>    Parameters
<span class="gu">@@ -125,4 +163,4 @@ def adjacency_matrix(G, nodelist=None, dtype=None, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    to_dict_of_dicts
<span class="w"> </span>    adjacency_spectrum
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return nx.to_scipy_sparse_array(G, nodelist=nodelist, dtype=dtype, weight=weight)</span>
<span class="gh">diff --git a/networkx/linalg/laplacianmatrix.py b/networkx/linalg/laplacianmatrix.py</span>
<span class="gh">index 4f556799c..f68c6614d 100644</span>
<span class="gd">--- a/networkx/linalg/laplacianmatrix.py</span>
<span class="gi">+++ b/networkx/linalg/laplacianmatrix.py</span>
<span class="gu">@@ -9,13 +9,18 @@ and `directed_combinatorial_laplacian_matrix` are all normalized.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;laplacian_matrix&#39;, &#39;normalized_laplacian_matrix&#39;,</span>
<span class="gd">-    &#39;total_spanning_tree_weight&#39;, &#39;directed_laplacian_matrix&#39;,</span>
<span class="gd">-    &#39;directed_combinatorial_laplacian_matrix&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;laplacian_matrix&quot;,</span>
<span class="gi">+    &quot;normalized_laplacian_matrix&quot;,</span>
<span class="gi">+    &quot;total_spanning_tree_weight&quot;,</span>
<span class="gi">+    &quot;directed_laplacian_matrix&quot;,</span>
<span class="gi">+    &quot;directed_combinatorial_laplacian_matrix&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def laplacian_matrix(G, nodelist=None, weight=&#39;weight&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def laplacian_matrix(G, nodelist=None, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the Laplacian matrix of G.

<span class="w"> </span>    The graph Laplacian is the matrix L = D - A, where
<span class="gu">@@ -114,12 +119,20 @@ def laplacian_matrix(G, nodelist=None, weight=&#39;weight&#39;):</span>
<span class="w"> </span>       The Science of Search Engine Rankings. Princeton University Press, 2006.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+    A = nx.to_scipy_sparse_array(G, nodelist=nodelist, weight=weight, format=&quot;csr&quot;)</span>
<span class="gi">+    n, m = A.shape</span>
<span class="gi">+    # TODO: rm csr_array wrapper when spdiags can produce arrays</span>
<span class="gi">+    D = sp.sparse.csr_array(sp.sparse.spdiags(A.sum(axis=1), 0, m, n, format=&quot;csr&quot;))</span>
<span class="gi">+    return D - A</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def normalized_laplacian_matrix(G, nodelist=None, weight=&#39;weight&#39;):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the normalized Laplacian matrix of G.</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def normalized_laplacian_matrix(G, nodelist=None, weight=&quot;weight&quot;):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the normalized Laplacian matrix of G.</span>

<span class="w"> </span>    The normalized graph Laplacian is the matrix

<span class="gu">@@ -214,10 +227,26 @@ def normalized_laplacian_matrix(G, nodelist=None, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    .. [3] Langville, Amy N., and Carl D. Meyer. Google’s PageRank and Beyond:
<span class="w"> </span>       The Science of Search Engine Rankings. Princeton University Press, 2006.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+    A = nx.to_scipy_sparse_array(G, nodelist=nodelist, weight=weight, format=&quot;csr&quot;)</span>
<span class="gi">+    n, _ = A.shape</span>
<span class="gi">+    diags = A.sum(axis=1)</span>
<span class="gi">+    # TODO: rm csr_array wrapper when spdiags can produce arrays</span>
<span class="gi">+    D = sp.sparse.csr_array(sp.sparse.spdiags(diags, 0, n, n, format=&quot;csr&quot;))</span>
<span class="gi">+    L = D - A</span>
<span class="gi">+    with np.errstate(divide=&quot;ignore&quot;):</span>
<span class="gi">+        diags_sqrt = 1.0 / np.sqrt(diags)</span>
<span class="gi">+    diags_sqrt[np.isinf(diags_sqrt)] = 0</span>
<span class="gi">+    # TODO: rm csr_array wrapper when spdiags can produce arrays</span>
<span class="gi">+    DH = sp.sparse.csr_array(sp.sparse.spdiags(diags_sqrt, 0, n, n, format=&quot;csr&quot;))</span>
<span class="gi">+    return DH @ (L @ DH)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def total_spanning_tree_weight(G, weight=None, root=None):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the total weight of all spanning trees of `G`.
<span class="gu">@@ -299,24 +328,40 @@ def total_spanning_tree_weight(G, weight=None, root=None):</span>
<span class="w"> </span>        &quot;Matrix-Tree Theorem for Directed Graphs&quot;
<span class="w"> </span>        https://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import warnings</span>
<span class="gi">+</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;\n\ntotal_spanning_tree_weight is deprecated and will be removed in v3.5.\n&quot;</span>
<span class="gi">+            &quot;Use `nx.number_of_spanning_trees(G)` instead.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+        category=DeprecationWarning,</span>
<span class="gi">+        stacklevel=3,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return nx.number_of_spanning_trees(G, weight=weight, root=root)</span>
<span class="gi">+</span>

<span class="gi">+###############################################################################</span>
<span class="gi">+# Code based on work from https://github.com/bjedwards</span>

<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def directed_laplacian_matrix(G, nodelist=None, weight=&#39;weight&#39;, walk_type=</span>
<span class="gd">-    None, alpha=0.95):</span>
<span class="gd">-    &quot;&quot;&quot;Returns the directed Laplacian matrix of G.</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def directed_laplacian_matrix(</span>
<span class="gi">+    G, nodelist=None, weight=&quot;weight&quot;, walk_type=None, alpha=0.95</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the directed Laplacian matrix of G.</span>

<span class="w"> </span>    The graph directed Laplacian is the matrix

<span class="w"> </span>    .. math::

<span class="gd">-        L = I - \\frac{1}{2} \\left (\\Phi^{1/2} P \\Phi^{-1/2} + \\Phi^{-1/2} P^T \\Phi^{1/2} \\right )</span>
<span class="gi">+        L = I - \frac{1}{2} \left (\Phi^{1/2} P \Phi^{-1/2} + \Phi^{-1/2} P^T \Phi^{1/2} \right )</span>

<span class="w"> </span>    where `I` is the identity matrix, `P` is the transition matrix of the
<span class="gd">-    graph, and `\\Phi` a matrix with the Perron vector of `P` in the diagonal and</span>
<span class="gi">+    graph, and `\Phi` a matrix with the Perron vector of `P` in the diagonal and</span>
<span class="w"> </span>    zeros elsewhere [1]_.

<span class="w"> </span>    Depending on the value of walk_type, `P` can be the transition matrix
<span class="gu">@@ -373,23 +418,49 @@ def directed_laplacian_matrix(G, nodelist=None, weight=&#39;weight&#39;, walk_type=</span>
<span class="w"> </span>       Laplacians and the Cheeger inequality for directed graphs.
<span class="w"> </span>       Annals of Combinatorics, 9(1), 2005
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def directed_combinatorial_laplacian_matrix(G, nodelist=None, weight=</span>
<span class="gd">-    &#39;weight&#39;, walk_type=None, alpha=0.95):</span>
<span class="gd">-    &quot;&quot;&quot;Return the directed combinatorial Laplacian matrix of G.</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    # NOTE: P has type ndarray if walk_type==&quot;pagerank&quot;, else csr_array</span>
<span class="gi">+    P = _transition_matrix(</span>
<span class="gi">+        G, nodelist=nodelist, weight=weight, walk_type=walk_type, alpha=alpha</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    n, m = P.shape</span>
<span class="gi">+</span>
<span class="gi">+    evals, evecs = sp.sparse.linalg.eigs(P.T, k=1)</span>
<span class="gi">+    v = evecs.flatten().real</span>
<span class="gi">+    p = v / v.sum()</span>
<span class="gi">+    # p&gt;=0 by Perron-Frobenius Thm. Use abs() to fix roundoff across zero gh-6865</span>
<span class="gi">+    sqrtp = np.sqrt(np.abs(p))</span>
<span class="gi">+    Q = (</span>
<span class="gi">+        # TODO: rm csr_array wrapper when spdiags creates arrays</span>
<span class="gi">+        sp.sparse.csr_array(sp.sparse.spdiags(sqrtp, 0, n, n))</span>
<span class="gi">+        @ P</span>
<span class="gi">+        # TODO: rm csr_array wrapper when spdiags creates arrays</span>
<span class="gi">+        @ sp.sparse.csr_array(sp.sparse.spdiags(1.0 / sqrtp, 0, n, n))</span>
<span class="gi">+    )</span>
<span class="gi">+    # NOTE: This could be sparsified for the non-pagerank cases</span>
<span class="gi">+    I = np.identity(len(G))</span>
<span class="gi">+</span>
<span class="gi">+    return I - (Q + Q.T) / 2.0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def directed_combinatorial_laplacian_matrix(</span>
<span class="gi">+    G, nodelist=None, weight=&quot;weight&quot;, walk_type=None, alpha=0.95</span>
<span class="gi">+):</span>
<span class="gi">+    r&quot;&quot;&quot;Return the directed combinatorial Laplacian matrix of G.</span>

<span class="w"> </span>    The graph directed combinatorial Laplacian is the matrix

<span class="w"> </span>    .. math::

<span class="gd">-        L = \\Phi - \\frac{1}{2} \\left (\\Phi P + P^T \\Phi \\right)</span>
<span class="gi">+        L = \Phi - \frac{1}{2} \left (\Phi P + P^T \Phi \right)</span>

<span class="gd">-    where `P` is the transition matrix of the graph and `\\Phi` a matrix</span>
<span class="gi">+    where `P` is the transition matrix of the graph and `\Phi` a matrix</span>
<span class="w"> </span>    with the Perron vector of `P` in the diagonal and zeros elsewhere [1]_.

<span class="w"> </span>    Depending on the value of walk_type, `P` can be the transition matrix
<span class="gu">@@ -446,11 +517,25 @@ def directed_combinatorial_laplacian_matrix(G, nodelist=None, weight=</span>
<span class="w"> </span>       Laplacians and the Cheeger inequality for directed graphs.
<span class="w"> </span>       Annals of Combinatorics, 9(1), 2005
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    P = _transition_matrix(</span>
<span class="gi">+        G, nodelist=nodelist, weight=weight, walk_type=walk_type, alpha=alpha</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    n, m = P.shape</span>
<span class="gi">+</span>
<span class="gi">+    evals, evecs = sp.sparse.linalg.eigs(P.T, k=1)</span>
<span class="gi">+    v = evecs.flatten().real</span>
<span class="gi">+    p = v / v.sum()</span>
<span class="gi">+    # NOTE: could be improved by not densifying</span>
<span class="gi">+    # TODO: Rm csr_array wrapper when spdiags array creation becomes available</span>
<span class="gi">+    Phi = sp.sparse.csr_array(sp.sparse.spdiags(p, 0, n, n)).toarray()</span>
<span class="gi">+</span>
<span class="gi">+    return Phi - (Phi @ P + P.T @ Phi) / 2.0</span>


<span class="gd">-def _transition_matrix(G, nodelist=None, weight=&#39;weight&#39;, walk_type=None,</span>
<span class="gd">-    alpha=0.95):</span>
<span class="gi">+def _transition_matrix(G, nodelist=None, weight=&quot;weight&quot;, walk_type=None, alpha=0.95):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the transition matrix of G.

<span class="w"> </span>    This is a row stochastic giving the transition probabilities while
<span class="gu">@@ -491,4 +576,41 @@ def _transition_matrix(G, nodelist=None, weight=&#39;weight&#39;, walk_type=None,</span>
<span class="w"> </span>    NetworkXError
<span class="w"> </span>        If walk_type not specified or alpha not in valid range
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if walk_type is None:</span>
<span class="gi">+        if nx.is_strongly_connected(G):</span>
<span class="gi">+            if nx.is_aperiodic(G):</span>
<span class="gi">+                walk_type = &quot;random&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                walk_type = &quot;lazy&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            walk_type = &quot;pagerank&quot;</span>
<span class="gi">+</span>
<span class="gi">+    A = nx.to_scipy_sparse_array(G, nodelist=nodelist, weight=weight, dtype=float)</span>
<span class="gi">+    n, m = A.shape</span>
<span class="gi">+    if walk_type in [&quot;random&quot;, &quot;lazy&quot;]:</span>
<span class="gi">+        # TODO: Rm csr_array wrapper when spdiags array creation becomes available</span>
<span class="gi">+        DI = sp.sparse.csr_array(sp.sparse.spdiags(1.0 / A.sum(axis=1), 0, n, n))</span>
<span class="gi">+        if walk_type == &quot;random&quot;:</span>
<span class="gi">+            P = DI @ A</span>
<span class="gi">+        else:</span>
<span class="gi">+            # TODO: Rm csr_array wrapper when identity array creation becomes available</span>
<span class="gi">+            I = sp.sparse.csr_array(sp.sparse.identity(n))</span>
<span class="gi">+            P = (I + DI @ A) / 2.0</span>
<span class="gi">+</span>
<span class="gi">+    elif walk_type == &quot;pagerank&quot;:</span>
<span class="gi">+        if not (0 &lt; alpha &lt; 1):</span>
<span class="gi">+            raise nx.NetworkXError(&quot;alpha must be between 0 and 1&quot;)</span>
<span class="gi">+        # this is using a dense representation. NOTE: This should be sparsified!</span>
<span class="gi">+        A = A.toarray()</span>
<span class="gi">+        # add constant to dangling nodes&#39; row</span>
<span class="gi">+        A[A.sum(axis=1) == 0, :] = 1 / n</span>
<span class="gi">+        # normalize</span>
<span class="gi">+        A = A / A.sum(axis=1)[np.newaxis, :].T</span>
<span class="gi">+        P = alpha * A + (1 - alpha) / n</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;walk_type must be random, lazy, or pagerank&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return P</span>
<span class="gh">diff --git a/networkx/linalg/modularitymatrix.py b/networkx/linalg/modularitymatrix.py</span>
<span class="gh">index e1c54d42d..fc599b353 100644</span>
<span class="gd">--- a/networkx/linalg/modularitymatrix.py</span>
<span class="gi">+++ b/networkx/linalg/modularitymatrix.py</span>
<span class="gu">@@ -2,14 +2,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import not_implemented_for
<span class="gd">-__all__ = [&#39;modularity_matrix&#39;, &#39;directed_modularity_matrix&#39;]</span>

<span class="gi">+__all__ = [&quot;modularity_matrix&quot;, &quot;directed_modularity_matrix&quot;]</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def modularity_matrix(G, nodelist=None, weight=None):
<span class="gd">-    &quot;&quot;&quot;Returns the modularity matrix of G.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns the modularity matrix of G.</span>

<span class="w"> </span>    The modularity matrix is the matrix B = A - &lt;A&gt;, where A is the adjacency
<span class="w"> </span>    matrix and &lt;A&gt; is the average adjacency matrix, assuming that the graph
<span class="gu">@@ -18,7 +19,7 @@ def modularity_matrix(G, nodelist=None, weight=None):</span>
<span class="w"> </span>    More specifically, the element B_ij of B is defined as

<span class="w"> </span>    .. math::
<span class="gd">-        A_{ij} - {k_i k_j \\over 2 m}</span>
<span class="gi">+        A_{ij} - {k_i k_j \over 2 m}</span>

<span class="w"> </span>    where k_i is the degree of node i, and where m is the number of edges
<span class="w"> </span>    in the graph. When weight is set to a name of an attribute edge, Aij, k_i,
<span class="gu">@@ -61,12 +62,22 @@ def modularity_matrix(G, nodelist=None, weight=None):</span>
<span class="w"> </span>    .. [1] M. E. J. Newman, &quot;Modularity and community structure in networks&quot;,
<span class="w"> </span>           Proc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+    A = nx.to_scipy_sparse_array(G, nodelist=nodelist, weight=weight, format=&quot;csr&quot;)</span>
<span class="gi">+    k = A.sum(axis=1)</span>
<span class="gi">+    m = k.sum() * 0.5</span>
<span class="gi">+    # Expected adjacency matrix</span>
<span class="gi">+    X = np.outer(k, k) / (2 * m)</span>
<span class="gi">+</span>
<span class="gi">+    return A - X</span>


<span class="gd">-@not_implemented_for(&#39;undirected&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;undirected&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="w"> </span>def directed_modularity_matrix(G, nodelist=None, weight=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns the directed modularity matrix of G.

<span class="gu">@@ -141,4 +152,15 @@ def directed_modularity_matrix(G, nodelist=None, weight=None):</span>
<span class="w"> </span>        &quot;Community structure in directed networks&quot;,
<span class="w"> </span>        Phys. Rev Lett., vol. 100, no. 11, p. 118703, 2008.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if nodelist is None:</span>
<span class="gi">+        nodelist = list(G)</span>
<span class="gi">+    A = nx.to_scipy_sparse_array(G, nodelist=nodelist, weight=weight, format=&quot;csr&quot;)</span>
<span class="gi">+    k_in = A.sum(axis=0)</span>
<span class="gi">+    k_out = A.sum(axis=1)</span>
<span class="gi">+    m = k_in.sum()</span>
<span class="gi">+    # Expected adjacency matrix</span>
<span class="gi">+    X = np.outer(k_out, k_in) / m</span>
<span class="gi">+</span>
<span class="gi">+    return A - X</span>
<span class="gh">diff --git a/networkx/linalg/spectrum.py b/networkx/linalg/spectrum.py</span>
<span class="gh">index 6242840de..16dfa148c 100644</span>
<span class="gd">--- a/networkx/linalg/spectrum.py</span>
<span class="gi">+++ b/networkx/linalg/spectrum.py</span>
<span class="gu">@@ -2,13 +2,18 @@</span>
<span class="w"> </span>Eigenvalue spectrum of graphs.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;laplacian_spectrum&#39;, &#39;adjacency_spectrum&#39;,</span>
<span class="gd">-    &#39;modularity_spectrum&#39;, &#39;normalized_laplacian_spectrum&#39;,</span>
<span class="gd">-    &#39;bethe_hessian_spectrum&#39;]</span>

<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;laplacian_spectrum&quot;,</span>
<span class="gi">+    &quot;adjacency_spectrum&quot;,</span>
<span class="gi">+    &quot;modularity_spectrum&quot;,</span>
<span class="gi">+    &quot;normalized_laplacian_spectrum&quot;,</span>
<span class="gi">+    &quot;bethe_hessian_spectrum&quot;,</span>
<span class="gi">+]</span>

<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def laplacian_spectrum(G, weight=&#39;weight&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def laplacian_spectrum(G, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns eigenvalues of the Laplacian of G

<span class="w"> </span>    Parameters
<span class="gu">@@ -46,11 +51,13 @@ def laplacian_spectrum(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    array([0., 0., 0., 2., 2.])

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    return sp.linalg.eigvalsh(nx.laplacian_matrix(G, weight=weight).todense())</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def normalized_laplacian_spectrum(G, weight=&#39;weight&#39;):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def normalized_laplacian_spectrum(G, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Return eigenvalues of the normalized Laplacian of G

<span class="w"> </span>    Parameters
<span class="gu">@@ -76,11 +83,15 @@ def normalized_laplacian_spectrum(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    normalized_laplacian_matrix
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    return sp.linalg.eigvalsh(</span>
<span class="gi">+        nx.normalized_laplacian_matrix(G, weight=weight).todense()</span>
<span class="gi">+    )</span>


<span class="gd">-@nx._dispatchable(edge_attrs=&#39;weight&#39;)</span>
<span class="gd">-def adjacency_spectrum(G, weight=&#39;weight&#39;):</span>
<span class="gi">+@nx._dispatchable(edge_attrs=&quot;weight&quot;)</span>
<span class="gi">+def adjacency_spectrum(G, weight=&quot;weight&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns eigenvalues of the adjacency matrix of G.

<span class="w"> </span>    Parameters
<span class="gu">@@ -106,7 +117,9 @@ def adjacency_spectrum(G, weight=&#39;weight&#39;):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    adjacency_matrix
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    return sp.linalg.eigvals(nx.adjacency_matrix(G, weight=weight).todense())</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -132,7 +145,12 @@ def modularity_spectrum(G):</span>
<span class="w"> </span>    .. [1] M. E. J. Newman, &quot;Modularity and community structure in networks&quot;,
<span class="w"> </span>       Proc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        return sp.linalg.eigvals(nx.directed_modularity_matrix(G))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return sp.linalg.eigvals(nx.modularity_matrix(G))</span>


<span class="w"> </span>@nx._dispatchable
<span class="gu">@@ -162,4 +180,6 @@ def bethe_hessian_spectrum(G, r=None):</span>
<span class="w"> </span>       &quot;Spectral clustering of graphs with the bethe hessian&quot;,
<span class="w"> </span>       Advances in Neural Information Processing Systems. 2014.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import scipy as sp</span>
<span class="gi">+</span>
<span class="gi">+    return sp.linalg.eigvalsh(nx.bethe_hessian_matrix(G, r).todense())</span>
<span class="gh">diff --git a/networkx/readwrite/adjlist.py b/networkx/readwrite/adjlist.py</span>
<span class="gh">index 60e2bbf85..56a1b4d2b 100644</span>
<span class="gd">--- a/networkx/readwrite/adjlist.py</span>
<span class="gi">+++ b/networkx/readwrite/adjlist.py</span>
<span class="gu">@@ -21,13 +21,14 @@ adjacency list (anything following the # in a line is a comment)::</span>
<span class="w"> </span>     a b c # source target target
<span class="w"> </span>     d e
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;generate_adjlist&#39;, &#39;write_adjlist&#39;, &#39;parse_adjlist&#39;, &#39;read_adjlist&#39;</span>
<span class="gd">-    ]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;generate_adjlist&quot;, &quot;write_adjlist&quot;, &quot;parse_adjlist&quot;, &quot;read_adjlist&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import open_file


<span class="gd">-def generate_adjlist(G, delimiter=&#39; &#39;):</span>
<span class="gi">+def generate_adjlist(G, delimiter=&quot; &quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a single line of the graph G in adjacency list format.

<span class="w"> </span>    Parameters
<span class="gu">@@ -68,11 +69,25 @@ def generate_adjlist(G, delimiter=&#39; &#39;):</span>
<span class="w"> </span>    NB: This option is not available for data that isn&#39;t user-generated.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gd">-def write_adjlist(G, path, comments=&#39;#&#39;, delimiter=&#39; &#39;, encoding=&#39;utf-8&#39;):</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for s, nbrs in G.adjacency():</span>
<span class="gi">+        line = str(s) + delimiter</span>
<span class="gi">+        for t, data in nbrs.items():</span>
<span class="gi">+            if not directed and t in seen:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if G.is_multigraph():</span>
<span class="gi">+                for d in data.values():</span>
<span class="gi">+                    line += str(t) + delimiter</span>
<span class="gi">+            else:</span>
<span class="gi">+                line += str(t) + delimiter</span>
<span class="gi">+        if not directed:</span>
<span class="gi">+            seen.add(s)</span>
<span class="gi">+        yield line[: -len(delimiter)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="gi">+def write_adjlist(G, path, comments=&quot;#&quot;, delimiter=&quot; &quot;, encoding=&quot;utf-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write graph G in single-line adjacency-list format to path.


<span class="gu">@@ -117,12 +132,28 @@ def write_adjlist(G, path, comments=&#39;#&#39;, delimiter=&#39; &#39;, encoding=&#39;utf-8&#39;):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    read_adjlist, generate_adjlist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import sys</span>
<span class="gi">+    import time</span>
<span class="gi">+</span>
<span class="gi">+    pargs = comments + &quot; &quot;.join(sys.argv) + &quot;\n&quot;</span>
<span class="gi">+    header = (</span>
<span class="gi">+        pargs</span>
<span class="gi">+        + comments</span>
<span class="gi">+        + f&quot; GMT {time.asctime(time.gmtime())}\n&quot;</span>
<span class="gi">+        + comments</span>
<span class="gi">+        + f&quot; {G.name}\n&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    path.write(header.encode(encoding))</span>
<span class="gi">+</span>
<span class="gi">+    for line in generate_adjlist(G, delimiter):</span>
<span class="gi">+        line += &quot;\n&quot;</span>
<span class="gi">+        path.write(line.encode(encoding))</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def parse_adjlist(lines, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="gd">-    nodetype=None):</span>
<span class="gi">+def parse_adjlist(</span>
<span class="gi">+    lines, comments=&quot;#&quot;, delimiter=None, create_using=None, nodetype=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse lines of a graph adjacency list representation.

<span class="w"> </span>    Parameters
<span class="gu">@@ -163,13 +194,45 @@ def parse_adjlist(lines, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="w"> </span>    read_adjlist

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        p = line.find(comments)</span>
<span class="gi">+        if p &gt;= 0:</span>
<span class="gi">+            line = line[:p]</span>
<span class="gi">+        if not len(line):</span>
<span class="gi">+            continue</span>
<span class="gi">+        vlist = line.strip().split(delimiter)</span>
<span class="gi">+        u = vlist.pop(0)</span>
<span class="gi">+        # convert types</span>
<span class="gi">+        if nodetype is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                u = nodetype(u)</span>
<span class="gi">+            except BaseException as err:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Failed to convert node ({u}) to type {nodetype}&quot;</span>
<span class="gi">+                ) from err</span>
<span class="gi">+        G.add_node(u)</span>
<span class="gi">+        if nodetype is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                vlist = list(map(nodetype, vlist))</span>
<span class="gi">+            except BaseException as err:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Failed to convert nodes ({&#39;,&#39;.join(vlist)}) to type {nodetype}&quot;</span>
<span class="gi">+                ) from err</span>
<span class="gi">+        G.add_edges_from([(u, v) for v in vlist])</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_adjlist(path, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="gd">-    nodetype=None, encoding=&#39;utf-8&#39;):</span>
<span class="gi">+def read_adjlist(</span>
<span class="gi">+    path,</span>
<span class="gi">+    comments=&quot;#&quot;,</span>
<span class="gi">+    delimiter=None,</span>
<span class="gi">+    create_using=None,</span>
<span class="gi">+    nodetype=None,</span>
<span class="gi">+    encoding=&quot;utf-8&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read graph in adjacency list format from path.

<span class="w"> </span>    Parameters
<span class="gu">@@ -237,4 +300,11 @@ def read_adjlist(path, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="w"> </span>    --------
<span class="w"> </span>    write_adjlist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = (line.decode(encoding) for line in path)</span>
<span class="gi">+    return parse_adjlist(</span>
<span class="gi">+        lines,</span>
<span class="gi">+        comments=comments,</span>
<span class="gi">+        delimiter=delimiter,</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+        nodetype=nodetype,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/networkx/readwrite/edgelist.py b/networkx/readwrite/edgelist.py</span>
<span class="gh">index e8aead3fe..ed445c80b 100644</span>
<span class="gd">--- a/networkx/readwrite/edgelist.py</span>
<span class="gi">+++ b/networkx/readwrite/edgelist.py</span>
<span class="gu">@@ -26,13 +26,21 @@ Arbitrary data::</span>

<span class="w"> </span> 1 2 7 green
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;generate_edgelist&#39;, &#39;write_edgelist&#39;, &#39;parse_edgelist&#39;,</span>
<span class="gd">-    &#39;read_edgelist&#39;, &#39;read_weighted_edgelist&#39;, &#39;write_weighted_edgelist&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;generate_edgelist&quot;,</span>
<span class="gi">+    &quot;write_edgelist&quot;,</span>
<span class="gi">+    &quot;parse_edgelist&quot;,</span>
<span class="gi">+    &quot;read_edgelist&quot;,</span>
<span class="gi">+    &quot;read_weighted_edgelist&quot;,</span>
<span class="gi">+    &quot;write_weighted_edgelist&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import open_file


<span class="gd">-def generate_edgelist(G, delimiter=&#39; &#39;, data=True):</span>
<span class="gi">+def generate_edgelist(G, delimiter=&quot; &quot;, data=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a single line of the graph G in edge list format.

<span class="w"> </span>    Parameters
<span class="gu">@@ -97,12 +105,26 @@ def generate_edgelist(G, delimiter=&#39; &#39;, data=True):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    write_adjlist, read_adjlist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gd">-def write_edgelist(G, path, comments=&#39;#&#39;, delimiter=&#39; &#39;, data=True,</span>
<span class="gd">-    encoding=&#39;utf-8&#39;):</span>
<span class="gi">+    if data is True:</span>
<span class="gi">+        for u, v, d in G.edges(data=True):</span>
<span class="gi">+            e = u, v, dict(d)</span>
<span class="gi">+            yield delimiter.join(map(str, e))</span>
<span class="gi">+    elif data is False:</span>
<span class="gi">+        for u, v in G.edges(data=False):</span>
<span class="gi">+            e = u, v</span>
<span class="gi">+            yield delimiter.join(map(str, e))</span>
<span class="gi">+    else:</span>
<span class="gi">+        for u, v, d in G.edges(data=True):</span>
<span class="gi">+            e = [u, v]</span>
<span class="gi">+            try:</span>
<span class="gi">+                e.extend(d[k] for k in data)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass  # missing data for this edge, should warn?</span>
<span class="gi">+            yield delimiter.join(map(str, e))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="gi">+def write_edgelist(G, path, comments=&quot;#&quot;, delimiter=&quot; &quot;, data=True, encoding=&quot;utf-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write graph as a list of edges.

<span class="w"> </span>    Parameters
<span class="gu">@@ -145,12 +167,16 @@ def write_edgelist(G, path, comments=&#39;#&#39;, delimiter=&#39; &#39;, data=True,</span>
<span class="w"> </span>    read_edgelist
<span class="w"> </span>    write_weighted_edgelist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    for line in generate_edgelist(G, delimiter, data):</span>
<span class="gi">+        line += &quot;\n&quot;</span>
<span class="gi">+        path.write(line.encode(encoding))</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def parse_edgelist(lines, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="gd">-    nodetype=None, data=True):</span>
<span class="gi">+def parse_edgelist(</span>
<span class="gi">+    lines, comments=&quot;#&quot;, delimiter=None, create_using=None, nodetype=None, data=True</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse lines of an edge list representation of a graph.

<span class="w"> </span>    Parameters
<span class="gu">@@ -210,13 +236,79 @@ def parse_edgelist(lines, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="w"> </span>    --------
<span class="w"> </span>    read_weighted_edgelist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+    from ast import literal_eval</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        if comments is not None:</span>
<span class="gi">+            p = line.find(comments)</span>
<span class="gi">+            if p &gt;= 0:</span>
<span class="gi">+                line = line[:p]</span>
<span class="gi">+            if not line:</span>
<span class="gi">+                continue</span>
<span class="gi">+        # split line, should have 2 or more</span>
<span class="gi">+        s = line.strip().split(delimiter)</span>
<span class="gi">+        if len(s) &lt; 2:</span>
<span class="gi">+            continue</span>
<span class="gi">+        u = s.pop(0)</span>
<span class="gi">+        v = s.pop(0)</span>
<span class="gi">+        d = s</span>
<span class="gi">+        if nodetype is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                u = nodetype(u)</span>
<span class="gi">+                v = nodetype(v)</span>
<span class="gi">+            except Exception as err:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Failed to convert nodes {u},{v} to type {nodetype}.&quot;</span>
<span class="gi">+                ) from err</span>
<span class="gi">+</span>
<span class="gi">+        if len(d) == 0 or data is False:</span>
<span class="gi">+            # no data or data type specified</span>
<span class="gi">+            edgedata = {}</span>
<span class="gi">+        elif data is True:</span>
<span class="gi">+            # no edge types specified</span>
<span class="gi">+            try:  # try to evaluate as dictionary</span>
<span class="gi">+                if delimiter == &quot;,&quot;:</span>
<span class="gi">+                    edgedata_str = &quot;,&quot;.join(d)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    edgedata_str = &quot; &quot;.join(d)</span>
<span class="gi">+                edgedata = dict(literal_eval(edgedata_str.strip()))</span>
<span class="gi">+            except Exception as err:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Failed to convert edge data ({d}) to dictionary.&quot;</span>
<span class="gi">+                ) from err</span>
<span class="gi">+        else:</span>
<span class="gi">+            # convert edge data to dictionary with specified keys and type</span>
<span class="gi">+            if len(d) != len(data):</span>
<span class="gi">+                raise IndexError(</span>
<span class="gi">+                    f&quot;Edge data {d} and data_keys {data} are not the same length&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            edgedata = {}</span>
<span class="gi">+            for (edge_key, edge_type), edge_value in zip(data, d):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    edge_value = edge_type(edge_value)</span>
<span class="gi">+                except Exception as err:</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        f&quot;Failed to convert {edge_key} data {edge_value} &quot;</span>
<span class="gi">+                        f&quot;to type {edge_type}.&quot;</span>
<span class="gi">+                    ) from err</span>
<span class="gi">+                edgedata.update({edge_key: edge_value})</span>
<span class="gi">+        G.add_edge(u, v, **edgedata)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_edgelist(path, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="gd">-    nodetype=None, data=True, edgetype=None, encoding=&#39;utf-8&#39;):</span>
<span class="gi">+def read_edgelist(</span>
<span class="gi">+    path,</span>
<span class="gi">+    comments=&quot;#&quot;,</span>
<span class="gi">+    delimiter=None,</span>
<span class="gi">+    create_using=None,</span>
<span class="gi">+    nodetype=None,</span>
<span class="gi">+    data=True,</span>
<span class="gi">+    edgetype=None,</span>
<span class="gi">+    encoding=&quot;utf-8&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a graph from a list of edges.

<span class="w"> </span>    Parameters
<span class="gu">@@ -282,11 +374,18 @@ def read_edgelist(path, comments=&#39;#&#39;, delimiter=None, create_using=None,</span>
<span class="w"> </span>    Since nodes must be hashable, the function nodetype must return hashable
<span class="w"> </span>    types (e.g. int, float, str, frozenset - or tuples of those, etc.)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def write_weighted_edgelist(G, path, comments=&#39;#&#39;, delimiter=&#39; &#39;, encoding=</span>
<span class="gd">-    &#39;utf-8&#39;):</span>
<span class="gi">+    lines = (line if isinstance(line, str) else line.decode(encoding) for line in path)</span>
<span class="gi">+    return parse_edgelist(</span>
<span class="gi">+        lines,</span>
<span class="gi">+        comments=comments,</span>
<span class="gi">+        delimiter=delimiter,</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+        nodetype=nodetype,</span>
<span class="gi">+        data=data,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def write_weighted_edgelist(G, path, comments=&quot;#&quot;, delimiter=&quot; &quot;, encoding=&quot;utf-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write graph G as a list of edges with numeric weights.

<span class="w"> </span>    Parameters
<span class="gu">@@ -316,12 +415,25 @@ def write_weighted_edgelist(G, path, comments=&#39;#&#39;, delimiter=&#39; &#39;, encoding=</span>
<span class="w"> </span>    write_edgelist
<span class="w"> </span>    read_weighted_edgelist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    write_edgelist(</span>
<span class="gi">+        G,</span>
<span class="gi">+        path,</span>
<span class="gi">+        comments=comments,</span>
<span class="gi">+        delimiter=delimiter,</span>
<span class="gi">+        data=(&quot;weight&quot;,),</span>
<span class="gi">+        encoding=encoding,</span>
<span class="gi">+    )</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_weighted_edgelist(path, comments=&#39;#&#39;, delimiter=None, create_using</span>
<span class="gd">-    =None, nodetype=None, encoding=&#39;utf-8&#39;):</span>
<span class="gi">+def read_weighted_edgelist(</span>
<span class="gi">+    path,</span>
<span class="gi">+    comments=&quot;#&quot;,</span>
<span class="gi">+    delimiter=None,</span>
<span class="gi">+    create_using=None,</span>
<span class="gi">+    nodetype=None,</span>
<span class="gi">+    encoding=&quot;utf-8&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read a graph as list of edges with numeric weights.

<span class="w"> </span>    Parameters
<span class="gu">@@ -366,4 +478,12 @@ def read_weighted_edgelist(path, comments=&#39;#&#39;, delimiter=None, create_using</span>
<span class="w"> </span>    --------
<span class="w"> </span>    write_weighted_edgelist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return read_edgelist(</span>
<span class="gi">+        path,</span>
<span class="gi">+        comments=comments,</span>
<span class="gi">+        delimiter=delimiter,</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+        nodetype=nodetype,</span>
<span class="gi">+        data=((&quot;weight&quot;, float),),</span>
<span class="gi">+        encoding=encoding,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/networkx/readwrite/gexf.py b/networkx/readwrite/gexf.py</span>
<span class="gh">index 47ccf4e05..16b864377 100644</span>
<span class="gd">--- a/networkx/readwrite/gexf.py</span>
<span class="gi">+++ b/networkx/readwrite/gexf.py</span>
<span class="gu">@@ -18,15 +18,22 @@ specification and http://gexf.net/basic.html for examples.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import itertools
<span class="w"> </span>import time
<span class="gd">-from xml.etree.ElementTree import Element, ElementTree, SubElement, register_namespace, tostring</span>
<span class="gi">+from xml.etree.ElementTree import (</span>
<span class="gi">+    Element,</span>
<span class="gi">+    ElementTree,</span>
<span class="gi">+    SubElement,</span>
<span class="gi">+    register_namespace,</span>
<span class="gi">+    tostring,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import open_file
<span class="gd">-__all__ = [&#39;write_gexf&#39;, &#39;read_gexf&#39;, &#39;relabel_gexf_graph&#39;, &#39;generate_gexf&#39;]</span>

<span class="gi">+__all__ = [&quot;write_gexf&quot;, &quot;read_gexf&quot;, &quot;relabel_gexf_graph&quot;, &quot;generate_gexf&quot;]</span>

<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gd">-def write_gexf(G, path, encoding=&#39;utf-8&#39;, prettyprint=True, version=&#39;1.2draft&#39;</span>
<span class="gd">-    ):</span>
<span class="gi">+</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="gi">+def write_gexf(G, path, encoding=&quot;utf-8&quot;, prettyprint=True, version=&quot;1.2draft&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write G in GEXF format to path.

<span class="w"> </span>    &quot;GEXF (Graph Exchange XML Format) is a language for describing
<span class="gu">@@ -75,10 +82,12 @@ def write_gexf(G, path, encoding=&#39;utf-8&#39;, prettyprint=True, version=&#39;1.2draft&#39;</span>
<span class="w"> </span>    .. [1] GEXF File Format, http://gexf.net/
<span class="w"> </span>    .. [2] GEXF schema, http://gexf.net/schema.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    writer = GEXFWriter(encoding=encoding, prettyprint=prettyprint, version=version)</span>
<span class="gi">+    writer.add_graph(G)</span>
<span class="gi">+    writer.write(path)</span>


<span class="gd">-def generate_gexf(G, encoding=&#39;utf-8&#39;, prettyprint=True, version=&#39;1.2draft&#39;):</span>
<span class="gi">+def generate_gexf(G, encoding=&quot;utf-8&quot;, prettyprint=True, version=&quot;1.2draft&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate lines of GEXF format representation of G.

<span class="w"> </span>    &quot;GEXF (Graph Exchange XML Format) is a language for describing
<span class="gu">@@ -100,8 +109,7 @@ def generate_gexf(G, encoding=&#39;utf-8&#39;, prettyprint=True, version=&#39;1.2draft&#39;):</span>
<span class="w"> </span>    Examples
<span class="w"> </span>    --------
<span class="w"> </span>    &gt;&gt;&gt; G = nx.path_graph(4)
<span class="gd">-    &gt;&gt;&gt; linefeed = chr(10)  # linefeed=</span>
<span class="gd">-</span>
<span class="gi">+    &gt;&gt;&gt; linefeed = chr(10)  # linefeed=\n</span>
<span class="w"> </span>    &gt;&gt;&gt; s = linefeed.join(nx.generate_gexf(G))
<span class="w"> </span>    &gt;&gt;&gt; for line in nx.generate_gexf(G):  # doctest: +SKIP
<span class="w"> </span>    ...     print(line)
<span class="gu">@@ -119,12 +127,14 @@ def generate_gexf(G, encoding=&#39;utf-8&#39;, prettyprint=True, version=&#39;1.2draft&#39;):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] GEXF File Format, https://gephi.org/gexf/format/
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    writer = GEXFWriter(encoding=encoding, prettyprint=prettyprint, version=version)</span>
<span class="gi">+    writer.add_graph(G)</span>
<span class="gi">+    yield from str(writer).splitlines()</span>


<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_gexf(path, node_type=None, relabel=False, version=&#39;1.2draft&#39;):</span>
<span class="gi">+def read_gexf(path, node_type=None, relabel=False, version=&quot;1.2draft&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read graph in GEXF format from path.

<span class="w"> </span>    &quot;GEXF (Graph Exchange XML Format) is a language for describing
<span class="gu">@@ -159,51 +169,151 @@ def read_gexf(path, node_type=None, relabel=False, version=&#39;1.2draft&#39;):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] GEXF File Format, http://gexf.net/
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    reader = GEXFReader(node_type=node_type, version=version)</span>
<span class="gi">+    if relabel:</span>
<span class="gi">+        G = relabel_gexf_graph(reader(path))</span>
<span class="gi">+    else:</span>
<span class="gi">+        G = reader(path)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>class GEXF:
<span class="gd">-    versions = {&#39;1.1draft&#39;: {&#39;NS_GEXF&#39;: &#39;http://www.gexf.net/1.1draft&#39;,</span>
<span class="gd">-        &#39;NS_VIZ&#39;: &#39;http://www.gexf.net/1.1draft/viz&#39;, &#39;NS_XSI&#39;:</span>
<span class="gd">-        &#39;http://www.w3.org/2001/XMLSchema-instance&#39;, &#39;SCHEMALOCATION&#39;: &#39; &#39;.</span>
<span class="gd">-        join([&#39;http://www.gexf.net/1.1draft&#39;,</span>
<span class="gd">-        &#39;http://www.gexf.net/1.1draft/gexf.xsd&#39;]), &#39;VERSION&#39;: &#39;1.1&#39;},</span>
<span class="gd">-        &#39;1.2draft&#39;: {&#39;NS_GEXF&#39;: &#39;http://www.gexf.net/1.2draft&#39;, &#39;NS_VIZ&#39;:</span>
<span class="gd">-        &#39;http://www.gexf.net/1.2draft/viz&#39;, &#39;NS_XSI&#39;:</span>
<span class="gd">-        &#39;http://www.w3.org/2001/XMLSchema-instance&#39;, &#39;SCHEMALOCATION&#39;: &#39; &#39;.</span>
<span class="gd">-        join([&#39;http://www.gexf.net/1.2draft&#39;,</span>
<span class="gd">-        &#39;http://www.gexf.net/1.2draft/gexf.xsd&#39;]), &#39;VERSION&#39;: &#39;1.2&#39;}}</span>
<span class="gd">-    convert_bool = {&#39;true&#39;: True, &#39;false&#39;: False, &#39;True&#39;: True, &#39;False&#39;: </span>
<span class="gd">-        False, &#39;0&#39;: False, (0): False, &#39;1&#39;: True, (1): True}</span>
<span class="gi">+    versions = {</span>
<span class="gi">+        &quot;1.1draft&quot;: {</span>
<span class="gi">+            &quot;NS_GEXF&quot;: &quot;http://www.gexf.net/1.1draft&quot;,</span>
<span class="gi">+            &quot;NS_VIZ&quot;: &quot;http://www.gexf.net/1.1draft/viz&quot;,</span>
<span class="gi">+            &quot;NS_XSI&quot;: &quot;http://www.w3.org/2001/XMLSchema-instance&quot;,</span>
<span class="gi">+            &quot;SCHEMALOCATION&quot;: &quot; &quot;.join(</span>
<span class="gi">+                [</span>
<span class="gi">+                    &quot;http://www.gexf.net/1.1draft&quot;,</span>
<span class="gi">+                    &quot;http://www.gexf.net/1.1draft/gexf.xsd&quot;,</span>
<span class="gi">+                ]</span>
<span class="gi">+            ),</span>
<span class="gi">+            &quot;VERSION&quot;: &quot;1.1&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;1.2draft&quot;: {</span>
<span class="gi">+            &quot;NS_GEXF&quot;: &quot;http://www.gexf.net/1.2draft&quot;,</span>
<span class="gi">+            &quot;NS_VIZ&quot;: &quot;http://www.gexf.net/1.2draft/viz&quot;,</span>
<span class="gi">+            &quot;NS_XSI&quot;: &quot;http://www.w3.org/2001/XMLSchema-instance&quot;,</span>
<span class="gi">+            &quot;SCHEMALOCATION&quot;: &quot; &quot;.join(</span>
<span class="gi">+                [</span>
<span class="gi">+                    &quot;http://www.gexf.net/1.2draft&quot;,</span>
<span class="gi">+                    &quot;http://www.gexf.net/1.2draft/gexf.xsd&quot;,</span>
<span class="gi">+                ]</span>
<span class="gi">+            ),</span>
<span class="gi">+            &quot;VERSION&quot;: &quot;1.2&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    }</span>

<span class="gi">+    def construct_types(self):</span>
<span class="gi">+        types = [</span>
<span class="gi">+            (int, &quot;integer&quot;),</span>
<span class="gi">+            (float, &quot;float&quot;),</span>
<span class="gi">+            (float, &quot;double&quot;),</span>
<span class="gi">+            (bool, &quot;boolean&quot;),</span>
<span class="gi">+            (list, &quot;string&quot;),</span>
<span class="gi">+            (dict, &quot;string&quot;),</span>
<span class="gi">+            (int, &quot;long&quot;),</span>
<span class="gi">+            (str, &quot;liststring&quot;),</span>
<span class="gi">+            (str, &quot;anyURI&quot;),</span>
<span class="gi">+            (str, &quot;string&quot;),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # These additions to types allow writing numpy types</span>
<span class="gi">+        try:</span>
<span class="gi">+            import numpy as np</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            # prepend so that python types are created upon read (last entry wins)</span>
<span class="gi">+            types = [</span>
<span class="gi">+                (np.float64, &quot;float&quot;),</span>
<span class="gi">+                (np.float32, &quot;float&quot;),</span>
<span class="gi">+                (np.float16, &quot;float&quot;),</span>
<span class="gi">+                (np.int_, &quot;int&quot;),</span>
<span class="gi">+                (np.int8, &quot;int&quot;),</span>
<span class="gi">+                (np.int16, &quot;int&quot;),</span>
<span class="gi">+                (np.int32, &quot;int&quot;),</span>
<span class="gi">+                (np.int64, &quot;int&quot;),</span>
<span class="gi">+                (np.uint8, &quot;int&quot;),</span>
<span class="gi">+                (np.uint16, &quot;int&quot;),</span>
<span class="gi">+                (np.uint32, &quot;int&quot;),</span>
<span class="gi">+                (np.uint64, &quot;int&quot;),</span>
<span class="gi">+                (np.int_, &quot;int&quot;),</span>
<span class="gi">+                (np.intc, &quot;int&quot;),</span>
<span class="gi">+                (np.intp, &quot;int&quot;),</span>
<span class="gi">+            ] + types</span>
<span class="gi">+</span>
<span class="gi">+        self.xml_type = dict(types)</span>
<span class="gi">+        self.python_type = dict(reversed(a) for a in types)</span>
<span class="gi">+</span>
<span class="gi">+    # http://www.w3.org/TR/xmlschema-2/#boolean</span>
<span class="gi">+    convert_bool = {</span>
<span class="gi">+        &quot;true&quot;: True,</span>
<span class="gi">+        &quot;false&quot;: False,</span>
<span class="gi">+        &quot;True&quot;: True,</span>
<span class="gi">+        &quot;False&quot;: False,</span>
<span class="gi">+        &quot;0&quot;: False,</span>
<span class="gi">+        0: False,</span>
<span class="gi">+        &quot;1&quot;: True,</span>
<span class="gi">+        1: True,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def set_version(self, version):</span>
<span class="gi">+        d = self.versions.get(version)</span>
<span class="gi">+        if d is None:</span>
<span class="gi">+            raise nx.NetworkXError(f&quot;Unknown GEXF version {version}.&quot;)</span>
<span class="gi">+        self.NS_GEXF = d[&quot;NS_GEXF&quot;]</span>
<span class="gi">+        self.NS_VIZ = d[&quot;NS_VIZ&quot;]</span>
<span class="gi">+        self.NS_XSI = d[&quot;NS_XSI&quot;]</span>
<span class="gi">+        self.SCHEMALOCATION = d[&quot;SCHEMALOCATION&quot;]</span>
<span class="gi">+        self.VERSION = d[&quot;VERSION&quot;]</span>
<span class="gi">+        self.version = version</span>

<span class="gd">-class GEXFWriter(GEXF):</span>

<span class="gd">-    def __init__(self, graph=None, encoding=&#39;utf-8&#39;, prettyprint=True,</span>
<span class="gd">-        version=&#39;1.2draft&#39;):</span>
<span class="gi">+class GEXFWriter(GEXF):</span>
<span class="gi">+    # class for writing GEXF format files</span>
<span class="gi">+    # use write_gexf() function</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, graph=None, encoding=&quot;utf-8&quot;, prettyprint=True, version=&quot;1.2draft&quot;</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.construct_types()
<span class="w"> </span>        self.prettyprint = prettyprint
<span class="w"> </span>        self.encoding = encoding
<span class="w"> </span>        self.set_version(version)
<span class="gd">-        self.xml = Element(&#39;gexf&#39;, {&#39;xmlns&#39;: self.NS_GEXF, &#39;xmlns:xsi&#39;:</span>
<span class="gd">-            self.NS_XSI, &#39;xsi:schemaLocation&#39;: self.SCHEMALOCATION,</span>
<span class="gd">-            &#39;version&#39;: self.VERSION})</span>
<span class="gd">-        meta_element = Element(&#39;meta&#39;)</span>
<span class="gd">-        subelement_text = f&#39;NetworkX {nx.__version__}&#39;</span>
<span class="gd">-        SubElement(meta_element, &#39;creator&#39;).text = subelement_text</span>
<span class="gd">-        meta_element.set(&#39;lastmodifieddate&#39;, time.strftime(&#39;%Y-%m-%d&#39;))</span>
<span class="gi">+        self.xml = Element(</span>
<span class="gi">+            &quot;gexf&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;xmlns&quot;: self.NS_GEXF,</span>
<span class="gi">+                &quot;xmlns:xsi&quot;: self.NS_XSI,</span>
<span class="gi">+                &quot;xsi:schemaLocation&quot;: self.SCHEMALOCATION,</span>
<span class="gi">+                &quot;version&quot;: self.VERSION,</span>
<span class="gi">+            },</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Make meta element a non-graph element</span>
<span class="gi">+        # Also add lastmodifieddate as attribute, not tag</span>
<span class="gi">+        meta_element = Element(&quot;meta&quot;)</span>
<span class="gi">+        subelement_text = f&quot;NetworkX {nx.__version__}&quot;</span>
<span class="gi">+        SubElement(meta_element, &quot;creator&quot;).text = subelement_text</span>
<span class="gi">+        meta_element.set(&quot;lastmodifieddate&quot;, time.strftime(&quot;%Y-%m-%d&quot;))</span>
<span class="w"> </span>        self.xml.append(meta_element)
<span class="gd">-        register_namespace(&#39;viz&#39;, self.NS_VIZ)</span>
<span class="gi">+</span>
<span class="gi">+        register_namespace(&quot;viz&quot;, self.NS_VIZ)</span>
<span class="gi">+</span>
<span class="gi">+        # counters for edge and attribute identifiers</span>
<span class="w"> </span>        self.edge_id = itertools.count()
<span class="w"> </span>        self.attr_id = itertools.count()
<span class="w"> </span>        self.all_edge_ids = set()
<span class="gi">+        # default attributes are stored in dictionaries</span>
<span class="w"> </span>        self.attr = {}
<span class="gd">-        self.attr[&#39;node&#39;] = {}</span>
<span class="gd">-        self.attr[&#39;edge&#39;] = {}</span>
<span class="gd">-        self.attr[&#39;node&#39;][&#39;dynamic&#39;] = {}</span>
<span class="gd">-        self.attr[&#39;node&#39;][&#39;static&#39;] = {}</span>
<span class="gd">-        self.attr[&#39;edge&#39;][&#39;dynamic&#39;] = {}</span>
<span class="gd">-        self.attr[&#39;edge&#39;][&#39;static&#39;] = {}</span>
<span class="gi">+        self.attr[&quot;node&quot;] = {}</span>
<span class="gi">+        self.attr[&quot;edge&quot;] = {}</span>
<span class="gi">+        self.attr[&quot;node&quot;][&quot;dynamic&quot;] = {}</span>
<span class="gi">+        self.attr[&quot;node&quot;][&quot;static&quot;] = {}</span>
<span class="gi">+        self.attr[&quot;edge&quot;][&quot;dynamic&quot;] = {}</span>
<span class="gi">+        self.attr[&quot;edge&quot;][&quot;static&quot;] = {}</span>
<span class="gi">+</span>
<span class="w"> </span>        if graph is not None:
<span class="w"> </span>            self.add_graph(graph)

<span class="gu">@@ -213,26 +323,694 @@ class GEXFWriter(GEXF):</span>
<span class="w"> </span>        s = tostring(self.xml).decode(self.encoding)
<span class="w"> </span>        return s

<span class="gi">+    def add_graph(self, G):</span>
<span class="gi">+        # first pass through G collecting edge ids</span>
<span class="gi">+        for u, v, dd in G.edges(data=True):</span>
<span class="gi">+            eid = dd.get(&quot;id&quot;)</span>
<span class="gi">+            if eid is not None:</span>
<span class="gi">+                self.all_edge_ids.add(str(eid))</span>
<span class="gi">+        # set graph attributes</span>
<span class="gi">+        if G.graph.get(&quot;mode&quot;) == &quot;dynamic&quot;:</span>
<span class="gi">+            mode = &quot;dynamic&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            mode = &quot;static&quot;</span>
<span class="gi">+        # Add a graph element to the XML</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            default = &quot;directed&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            default = &quot;undirected&quot;</span>
<span class="gi">+        name = G.graph.get(&quot;name&quot;, &quot;&quot;)</span>
<span class="gi">+        graph_element = Element(&quot;graph&quot;, defaultedgetype=default, mode=mode, name=name)</span>
<span class="gi">+        self.graph_element = graph_element</span>
<span class="gi">+        self.add_nodes(G, graph_element)</span>
<span class="gi">+        self.add_edges(G, graph_element)</span>
<span class="gi">+        self.xml.append(graph_element)</span>

<span class="gd">-class GEXFReader(GEXF):</span>
<span class="gi">+    def add_nodes(self, G, graph_element):</span>
<span class="gi">+        nodes_element = Element(&quot;nodes&quot;)</span>
<span class="gi">+        for node, data in G.nodes(data=True):</span>
<span class="gi">+            node_data = data.copy()</span>
<span class="gi">+            node_id = str(node_data.pop(&quot;id&quot;, node))</span>
<span class="gi">+            kw = {&quot;id&quot;: node_id}</span>
<span class="gi">+            label = str(node_data.pop(&quot;label&quot;, node))</span>
<span class="gi">+            kw[&quot;label&quot;] = label</span>
<span class="gi">+            try:</span>
<span class="gi">+                pid = node_data.pop(&quot;pid&quot;)</span>
<span class="gi">+                kw[&quot;pid&quot;] = str(pid)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                start = node_data.pop(&quot;start&quot;)</span>
<span class="gi">+                kw[&quot;start&quot;] = str(start)</span>
<span class="gi">+                self.alter_graph_mode_timeformat(start)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                end = node_data.pop(&quot;end&quot;)</span>
<span class="gi">+                kw[&quot;end&quot;] = str(end)</span>
<span class="gi">+                self.alter_graph_mode_timeformat(end)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            # add node element with attributes</span>
<span class="gi">+            node_element = Element(&quot;node&quot;, **kw)</span>
<span class="gi">+            # add node element and attr subelements</span>
<span class="gi">+            default = G.graph.get(&quot;node_default&quot;, {})</span>
<span class="gi">+            node_data = self.add_parents(node_element, node_data)</span>
<span class="gi">+            if self.VERSION == &quot;1.1&quot;:</span>
<span class="gi">+                node_data = self.add_slices(node_element, node_data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                node_data = self.add_spells(node_element, node_data)</span>
<span class="gi">+            node_data = self.add_viz(node_element, node_data)</span>
<span class="gi">+            node_data = self.add_attributes(&quot;node&quot;, node_element, node_data, default)</span>
<span class="gi">+            nodes_element.append(node_element)</span>
<span class="gi">+        graph_element.append(nodes_element)</span>
<span class="gi">+</span>
<span class="gi">+    def add_edges(self, G, graph_element):</span>
<span class="gi">+        def edge_key_data(G):</span>
<span class="gi">+            # helper function to unify multigraph and graph edge iterator</span>
<span class="gi">+            if G.is_multigraph():</span>
<span class="gi">+                for u, v, key, data in G.edges(data=True, keys=True):</span>
<span class="gi">+                    edge_data = data.copy()</span>
<span class="gi">+                    edge_data.update(key=key)</span>
<span class="gi">+                    edge_id = edge_data.pop(&quot;id&quot;, None)</span>
<span class="gi">+                    if edge_id is None:</span>
<span class="gi">+                        edge_id = next(self.edge_id)</span>
<span class="gi">+                        while str(edge_id) in self.all_edge_ids:</span>
<span class="gi">+                            edge_id = next(self.edge_id)</span>
<span class="gi">+                        self.all_edge_ids.add(str(edge_id))</span>
<span class="gi">+                    yield u, v, edge_id, edge_data</span>
<span class="gi">+            else:</span>
<span class="gi">+                for u, v, data in G.edges(data=True):</span>
<span class="gi">+                    edge_data = data.copy()</span>
<span class="gi">+                    edge_id = edge_data.pop(&quot;id&quot;, None)</span>
<span class="gi">+                    if edge_id is None:</span>
<span class="gi">+                        edge_id = next(self.edge_id)</span>
<span class="gi">+                        while str(edge_id) in self.all_edge_ids:</span>
<span class="gi">+                            edge_id = next(self.edge_id)</span>
<span class="gi">+                        self.all_edge_ids.add(str(edge_id))</span>
<span class="gi">+                    yield u, v, edge_id, edge_data</span>
<span class="gi">+</span>
<span class="gi">+        edges_element = Element(&quot;edges&quot;)</span>
<span class="gi">+        for u, v, key, edge_data in edge_key_data(G):</span>
<span class="gi">+            kw = {&quot;id&quot;: str(key)}</span>
<span class="gi">+            try:</span>
<span class="gi">+                edge_label = edge_data.pop(&quot;label&quot;)</span>
<span class="gi">+                kw[&quot;label&quot;] = str(edge_label)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                edge_weight = edge_data.pop(&quot;weight&quot;)</span>
<span class="gi">+                kw[&quot;weight&quot;] = str(edge_weight)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                edge_type = edge_data.pop(&quot;type&quot;)</span>
<span class="gi">+                kw[&quot;type&quot;] = str(edge_type)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                start = edge_data.pop(&quot;start&quot;)</span>
<span class="gi">+                kw[&quot;start&quot;] = str(start)</span>
<span class="gi">+                self.alter_graph_mode_timeformat(start)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            try:</span>
<span class="gi">+                end = edge_data.pop(&quot;end&quot;)</span>
<span class="gi">+                kw[&quot;end&quot;] = str(end)</span>
<span class="gi">+                self.alter_graph_mode_timeformat(end)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            source_id = str(G.nodes[u].get(&quot;id&quot;, u))</span>
<span class="gi">+            target_id = str(G.nodes[v].get(&quot;id&quot;, v))</span>
<span class="gi">+            edge_element = Element(&quot;edge&quot;, source=source_id, target=target_id, **kw)</span>
<span class="gi">+            default = G.graph.get(&quot;edge_default&quot;, {})</span>
<span class="gi">+            if self.VERSION == &quot;1.1&quot;:</span>
<span class="gi">+                edge_data = self.add_slices(edge_element, edge_data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                edge_data = self.add_spells(edge_element, edge_data)</span>
<span class="gi">+            edge_data = self.add_viz(edge_element, edge_data)</span>
<span class="gi">+            edge_data = self.add_attributes(&quot;edge&quot;, edge_element, edge_data, default)</span>
<span class="gi">+            edges_element.append(edge_element)</span>
<span class="gi">+        graph_element.append(edges_element)</span>

<span class="gd">-    def __init__(self, node_type=None, version=&#39;1.2draft&#39;):</span>
<span class="gi">+    def add_attributes(self, node_or_edge, xml_obj, data, default):</span>
<span class="gi">+        # Add attrvalues to node or edge</span>
<span class="gi">+        attvalues = Element(&quot;attvalues&quot;)</span>
<span class="gi">+        if len(data) == 0:</span>
<span class="gi">+            return data</span>
<span class="gi">+        mode = &quot;static&quot;</span>
<span class="gi">+        for k, v in data.items():</span>
<span class="gi">+            # rename generic multigraph key to avoid any name conflict</span>
<span class="gi">+            if k == &quot;key&quot;:</span>
<span class="gi">+                k = &quot;networkx_key&quot;</span>
<span class="gi">+            val_type = type(v)</span>
<span class="gi">+            if val_type not in self.xml_type:</span>
<span class="gi">+                raise TypeError(f&quot;attribute value type is not allowed: {val_type}&quot;)</span>
<span class="gi">+            if isinstance(v, list):</span>
<span class="gi">+                # dynamic data</span>
<span class="gi">+                for val, start, end in v:</span>
<span class="gi">+                    val_type = type(val)</span>
<span class="gi">+                    if start is not None or end is not None:</span>
<span class="gi">+                        mode = &quot;dynamic&quot;</span>
<span class="gi">+                        self.alter_graph_mode_timeformat(start)</span>
<span class="gi">+                        self.alter_graph_mode_timeformat(end)</span>
<span class="gi">+                        break</span>
<span class="gi">+                attr_id = self.get_attr_id(</span>
<span class="gi">+                    str(k), self.xml_type[val_type], node_or_edge, default, mode</span>
<span class="gi">+                )</span>
<span class="gi">+                for val, start, end in v:</span>
<span class="gi">+                    e = Element(&quot;attvalue&quot;)</span>
<span class="gi">+                    e.attrib[&quot;for&quot;] = attr_id</span>
<span class="gi">+                    e.attrib[&quot;value&quot;] = str(val)</span>
<span class="gi">+                    # Handle nan, inf, -inf differently</span>
<span class="gi">+                    if val_type == float:</span>
<span class="gi">+                        if e.attrib[&quot;value&quot;] == &quot;inf&quot;:</span>
<span class="gi">+                            e.attrib[&quot;value&quot;] = &quot;INF&quot;</span>
<span class="gi">+                        elif e.attrib[&quot;value&quot;] == &quot;nan&quot;:</span>
<span class="gi">+                            e.attrib[&quot;value&quot;] = &quot;NaN&quot;</span>
<span class="gi">+                        elif e.attrib[&quot;value&quot;] == &quot;-inf&quot;:</span>
<span class="gi">+                            e.attrib[&quot;value&quot;] = &quot;-INF&quot;</span>
<span class="gi">+                    if start is not None:</span>
<span class="gi">+                        e.attrib[&quot;start&quot;] = str(start)</span>
<span class="gi">+                    if end is not None:</span>
<span class="gi">+                        e.attrib[&quot;end&quot;] = str(end)</span>
<span class="gi">+                    attvalues.append(e)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # static data</span>
<span class="gi">+                mode = &quot;static&quot;</span>
<span class="gi">+                attr_id = self.get_attr_id(</span>
<span class="gi">+                    str(k), self.xml_type[val_type], node_or_edge, default, mode</span>
<span class="gi">+                )</span>
<span class="gi">+                e = Element(&quot;attvalue&quot;)</span>
<span class="gi">+                e.attrib[&quot;for&quot;] = attr_id</span>
<span class="gi">+                if isinstance(v, bool):</span>
<span class="gi">+                    e.attrib[&quot;value&quot;] = str(v).lower()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    e.attrib[&quot;value&quot;] = str(v)</span>
<span class="gi">+                    # Handle float nan, inf, -inf differently</span>
<span class="gi">+                    if val_type == float:</span>
<span class="gi">+                        if e.attrib[&quot;value&quot;] == &quot;inf&quot;:</span>
<span class="gi">+                            e.attrib[&quot;value&quot;] = &quot;INF&quot;</span>
<span class="gi">+                        elif e.attrib[&quot;value&quot;] == &quot;nan&quot;:</span>
<span class="gi">+                            e.attrib[&quot;value&quot;] = &quot;NaN&quot;</span>
<span class="gi">+                        elif e.attrib[&quot;value&quot;] == &quot;-inf&quot;:</span>
<span class="gi">+                            e.attrib[&quot;value&quot;] = &quot;-INF&quot;</span>
<span class="gi">+                attvalues.append(e)</span>
<span class="gi">+        xml_obj.append(attvalues)</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def get_attr_id(self, title, attr_type, edge_or_node, default, mode):</span>
<span class="gi">+        # find the id of the attribute or generate a new id</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.attr[edge_or_node][mode][title]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # generate new id</span>
<span class="gi">+            new_id = str(next(self.attr_id))</span>
<span class="gi">+            self.attr[edge_or_node][mode][title] = new_id</span>
<span class="gi">+            attr_kwargs = {&quot;id&quot;: new_id, &quot;title&quot;: title, &quot;type&quot;: attr_type}</span>
<span class="gi">+            attribute = Element(&quot;attribute&quot;, **attr_kwargs)</span>
<span class="gi">+            # add subelement for data default value if present</span>
<span class="gi">+            default_title = default.get(title)</span>
<span class="gi">+            if default_title is not None:</span>
<span class="gi">+                default_element = Element(&quot;default&quot;)</span>
<span class="gi">+                default_element.text = str(default_title)</span>
<span class="gi">+                attribute.append(default_element)</span>
<span class="gi">+            # new insert it into the XML</span>
<span class="gi">+            attributes_element = None</span>
<span class="gi">+            for a in self.graph_element.findall(&quot;attributes&quot;):</span>
<span class="gi">+                # find existing attributes element by class and mode</span>
<span class="gi">+                a_class = a.get(&quot;class&quot;)</span>
<span class="gi">+                a_mode = a.get(&quot;mode&quot;, &quot;static&quot;)</span>
<span class="gi">+                if a_class == edge_or_node and a_mode == mode:</span>
<span class="gi">+                    attributes_element = a</span>
<span class="gi">+            if attributes_element is None:</span>
<span class="gi">+                # create new attributes element</span>
<span class="gi">+                attr_kwargs = {&quot;mode&quot;: mode, &quot;class&quot;: edge_or_node}</span>
<span class="gi">+                attributes_element = Element(&quot;attributes&quot;, **attr_kwargs)</span>
<span class="gi">+                self.graph_element.insert(0, attributes_element)</span>
<span class="gi">+            attributes_element.append(attribute)</span>
<span class="gi">+        return new_id</span>
<span class="gi">+</span>
<span class="gi">+    def add_viz(self, element, node_data):</span>
<span class="gi">+        viz = node_data.pop(&quot;viz&quot;, False)</span>
<span class="gi">+        if viz:</span>
<span class="gi">+            color = viz.get(&quot;color&quot;)</span>
<span class="gi">+            if color is not None:</span>
<span class="gi">+                if self.VERSION == &quot;1.1&quot;:</span>
<span class="gi">+                    e = Element(</span>
<span class="gi">+                        f&quot;{{{self.NS_VIZ}}}color&quot;,</span>
<span class="gi">+                        r=str(color.get(&quot;r&quot;)),</span>
<span class="gi">+                        g=str(color.get(&quot;g&quot;)),</span>
<span class="gi">+                        b=str(color.get(&quot;b&quot;)),</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    e = Element(</span>
<span class="gi">+                        f&quot;{{{self.NS_VIZ}}}color&quot;,</span>
<span class="gi">+                        r=str(color.get(&quot;r&quot;)),</span>
<span class="gi">+                        g=str(color.get(&quot;g&quot;)),</span>
<span class="gi">+                        b=str(color.get(&quot;b&quot;)),</span>
<span class="gi">+                        a=str(color.get(&quot;a&quot;, 1.0)),</span>
<span class="gi">+                    )</span>
<span class="gi">+                element.append(e)</span>
<span class="gi">+</span>
<span class="gi">+            size = viz.get(&quot;size&quot;)</span>
<span class="gi">+            if size is not None:</span>
<span class="gi">+                e = Element(f&quot;{{{self.NS_VIZ}}}size&quot;, value=str(size))</span>
<span class="gi">+                element.append(e)</span>
<span class="gi">+</span>
<span class="gi">+            thickness = viz.get(&quot;thickness&quot;)</span>
<span class="gi">+            if thickness is not None:</span>
<span class="gi">+                e = Element(f&quot;{{{self.NS_VIZ}}}thickness&quot;, value=str(thickness))</span>
<span class="gi">+                element.append(e)</span>
<span class="gi">+</span>
<span class="gi">+            shape = viz.get(&quot;shape&quot;)</span>
<span class="gi">+            if shape is not None:</span>
<span class="gi">+                if shape.startswith(&quot;http&quot;):</span>
<span class="gi">+                    e = Element(</span>
<span class="gi">+                        f&quot;{{{self.NS_VIZ}}}shape&quot;, value=&quot;image&quot;, uri=str(shape)</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    e = Element(f&quot;{{{self.NS_VIZ}}}shape&quot;, value=str(shape))</span>
<span class="gi">+                element.append(e)</span>
<span class="gi">+</span>
<span class="gi">+            position = viz.get(&quot;position&quot;)</span>
<span class="gi">+            if position is not None:</span>
<span class="gi">+                e = Element(</span>
<span class="gi">+                    f&quot;{{{self.NS_VIZ}}}position&quot;,</span>
<span class="gi">+                    x=str(position.get(&quot;x&quot;)),</span>
<span class="gi">+                    y=str(position.get(&quot;y&quot;)),</span>
<span class="gi">+                    z=str(position.get(&quot;z&quot;)),</span>
<span class="gi">+                )</span>
<span class="gi">+                element.append(e)</span>
<span class="gi">+        return node_data</span>
<span class="gi">+</span>
<span class="gi">+    def add_parents(self, node_element, node_data):</span>
<span class="gi">+        parents = node_data.pop(&quot;parents&quot;, False)</span>
<span class="gi">+        if parents:</span>
<span class="gi">+            parents_element = Element(&quot;parents&quot;)</span>
<span class="gi">+            for p in parents:</span>
<span class="gi">+                e = Element(&quot;parent&quot;)</span>
<span class="gi">+                e.attrib[&quot;for&quot;] = str(p)</span>
<span class="gi">+                parents_element.append(e)</span>
<span class="gi">+            node_element.append(parents_element)</span>
<span class="gi">+        return node_data</span>
<span class="gi">+</span>
<span class="gi">+    def add_slices(self, node_or_edge_element, node_or_edge_data):</span>
<span class="gi">+        slices = node_or_edge_data.pop(&quot;slices&quot;, False)</span>
<span class="gi">+        if slices:</span>
<span class="gi">+            slices_element = Element(&quot;slices&quot;)</span>
<span class="gi">+            for start, end in slices:</span>
<span class="gi">+                e = Element(&quot;slice&quot;, start=str(start), end=str(end))</span>
<span class="gi">+                slices_element.append(e)</span>
<span class="gi">+            node_or_edge_element.append(slices_element)</span>
<span class="gi">+        return node_or_edge_data</span>
<span class="gi">+</span>
<span class="gi">+    def add_spells(self, node_or_edge_element, node_or_edge_data):</span>
<span class="gi">+        spells = node_or_edge_data.pop(&quot;spells&quot;, False)</span>
<span class="gi">+        if spells:</span>
<span class="gi">+            spells_element = Element(&quot;spells&quot;)</span>
<span class="gi">+            for start, end in spells:</span>
<span class="gi">+                e = Element(&quot;spell&quot;)</span>
<span class="gi">+                if start is not None:</span>
<span class="gi">+                    e.attrib[&quot;start&quot;] = str(start)</span>
<span class="gi">+                    self.alter_graph_mode_timeformat(start)</span>
<span class="gi">+                if end is not None:</span>
<span class="gi">+                    e.attrib[&quot;end&quot;] = str(end)</span>
<span class="gi">+                    self.alter_graph_mode_timeformat(end)</span>
<span class="gi">+                spells_element.append(e)</span>
<span class="gi">+            node_or_edge_element.append(spells_element)</span>
<span class="gi">+        return node_or_edge_data</span>
<span class="gi">+</span>
<span class="gi">+    def alter_graph_mode_timeformat(self, start_or_end):</span>
<span class="gi">+        # If &#39;start&#39; or &#39;end&#39; appears, alter Graph mode to dynamic and</span>
<span class="gi">+        # set timeformat</span>
<span class="gi">+        if self.graph_element.get(&quot;mode&quot;) == &quot;static&quot;:</span>
<span class="gi">+            if start_or_end is not None:</span>
<span class="gi">+                if isinstance(start_or_end, str):</span>
<span class="gi">+                    timeformat = &quot;date&quot;</span>
<span class="gi">+                elif isinstance(start_or_end, float):</span>
<span class="gi">+                    timeformat = &quot;double&quot;</span>
<span class="gi">+                elif isinstance(start_or_end, int):</span>
<span class="gi">+                    timeformat = &quot;long&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise nx.NetworkXError(</span>
<span class="gi">+                        &quot;timeformat should be of the type int, float or str&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                self.graph_element.set(&quot;timeformat&quot;, timeformat)</span>
<span class="gi">+                self.graph_element.set(&quot;mode&quot;, &quot;dynamic&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, fh):</span>
<span class="gi">+        # Serialize graph G in GEXF to the open fh</span>
<span class="gi">+        if self.prettyprint:</span>
<span class="gi">+            self.indent(self.xml)</span>
<span class="gi">+        document = ElementTree(self.xml)</span>
<span class="gi">+        document.write(fh, encoding=self.encoding, xml_declaration=True)</span>
<span class="gi">+</span>
<span class="gi">+    def indent(self, elem, level=0):</span>
<span class="gi">+        # in-place prettyprint formatter</span>
<span class="gi">+        i = &quot;\n&quot; + &quot;  &quot; * level</span>
<span class="gi">+        if len(elem):</span>
<span class="gi">+            if not elem.text or not elem.text.strip():</span>
<span class="gi">+                elem.text = i + &quot;  &quot;</span>
<span class="gi">+            if not elem.tail or not elem.tail.strip():</span>
<span class="gi">+                elem.tail = i</span>
<span class="gi">+            for elem in elem:</span>
<span class="gi">+                self.indent(elem, level + 1)</span>
<span class="gi">+            if not elem.tail or not elem.tail.strip():</span>
<span class="gi">+                elem.tail = i</span>
<span class="gi">+        else:</span>
<span class="gi">+            if level and (not elem.tail or not elem.tail.strip()):</span>
<span class="gi">+                elem.tail = i</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class GEXFReader(GEXF):</span>
<span class="gi">+    # Class to read GEXF format files</span>
<span class="gi">+    # use read_gexf() function</span>
<span class="gi">+    def __init__(self, node_type=None, version=&quot;1.2draft&quot;):</span>
<span class="w"> </span>        self.construct_types()
<span class="w"> </span>        self.node_type = node_type
<span class="gi">+        # assume simple graph and test for multigraph on read</span>
<span class="w"> </span>        self.simple_graph = True
<span class="w"> </span>        self.set_version(version)

<span class="w"> </span>    def __call__(self, stream):
<span class="w"> </span>        self.xml = ElementTree(file=stream)
<span class="gd">-        g = self.xml.find(f&#39;{{{self.NS_GEXF}}}graph&#39;)</span>
<span class="gi">+        g = self.xml.find(f&quot;{{{self.NS_GEXF}}}graph&quot;)</span>
<span class="w"> </span>        if g is not None:
<span class="w"> </span>            return self.make_graph(g)
<span class="gi">+        # try all the versions</span>
<span class="w"> </span>        for version in self.versions:
<span class="w"> </span>            self.set_version(version)
<span class="gd">-            g = self.xml.find(f&#39;{{{self.NS_GEXF}}}graph&#39;)</span>
<span class="gi">+            g = self.xml.find(f&quot;{{{self.NS_GEXF}}}graph&quot;)</span>
<span class="w"> </span>            if g is not None:
<span class="w"> </span>                return self.make_graph(g)
<span class="gd">-        raise nx.NetworkXError(&#39;No &lt;graph&gt; element in GEXF file.&#39;)</span>
<span class="gi">+        raise nx.NetworkXError(&quot;No &lt;graph&gt; element in GEXF file.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def make_graph(self, graph_xml):</span>
<span class="gi">+        # start with empty DiGraph or MultiDiGraph</span>
<span class="gi">+        edgedefault = graph_xml.get(&quot;defaultedgetype&quot;, None)</span>
<span class="gi">+        if edgedefault == &quot;directed&quot;:</span>
<span class="gi">+            G = nx.MultiDiGraph()</span>
<span class="gi">+        else:</span>
<span class="gi">+            G = nx.MultiGraph()</span>
<span class="gi">+</span>
<span class="gi">+        # graph attributes</span>
<span class="gi">+        graph_name = graph_xml.get(&quot;name&quot;, &quot;&quot;)</span>
<span class="gi">+        if graph_name != &quot;&quot;:</span>
<span class="gi">+            G.graph[&quot;name&quot;] = graph_name</span>
<span class="gi">+        graph_start = graph_xml.get(&quot;start&quot;)</span>
<span class="gi">+        if graph_start is not None:</span>
<span class="gi">+            G.graph[&quot;start&quot;] = graph_start</span>
<span class="gi">+        graph_end = graph_xml.get(&quot;end&quot;)</span>
<span class="gi">+        if graph_end is not None:</span>
<span class="gi">+            G.graph[&quot;end&quot;] = graph_end</span>
<span class="gi">+        graph_mode = graph_xml.get(&quot;mode&quot;, &quot;&quot;)</span>
<span class="gi">+        if graph_mode == &quot;dynamic&quot;:</span>
<span class="gi">+            G.graph[&quot;mode&quot;] = &quot;dynamic&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            G.graph[&quot;mode&quot;] = &quot;static&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # timeformat</span>
<span class="gi">+        self.timeformat = graph_xml.get(&quot;timeformat&quot;)</span>
<span class="gi">+        if self.timeformat == &quot;date&quot;:</span>
<span class="gi">+            self.timeformat = &quot;string&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # node and edge attributes</span>
<span class="gi">+        attributes_elements = graph_xml.findall(f&quot;{{{self.NS_GEXF}}}attributes&quot;)</span>
<span class="gi">+        # dictionaries to hold attributes and attribute defaults</span>
<span class="gi">+        node_attr = {}</span>
<span class="gi">+        node_default = {}</span>
<span class="gi">+        edge_attr = {}</span>
<span class="gi">+        edge_default = {}</span>
<span class="gi">+        for a in attributes_elements:</span>
<span class="gi">+            attr_class = a.get(&quot;class&quot;)</span>
<span class="gi">+            if attr_class == &quot;node&quot;:</span>
<span class="gi">+                na, nd = self.find_gexf_attributes(a)</span>
<span class="gi">+                node_attr.update(na)</span>
<span class="gi">+                node_default.update(nd)</span>
<span class="gi">+                G.graph[&quot;node_default&quot;] = node_default</span>
<span class="gi">+            elif attr_class == &quot;edge&quot;:</span>
<span class="gi">+                ea, ed = self.find_gexf_attributes(a)</span>
<span class="gi">+                edge_attr.update(ea)</span>
<span class="gi">+                edge_default.update(ed)</span>
<span class="gi">+                G.graph[&quot;edge_default&quot;] = edge_default</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise  # unknown attribute class</span>
<span class="gi">+</span>
<span class="gi">+        # Hack to handle Gephi0.7beta bug</span>
<span class="gi">+        # add weight attribute</span>
<span class="gi">+        ea = {&quot;weight&quot;: {&quot;type&quot;: &quot;double&quot;, &quot;mode&quot;: &quot;static&quot;, &quot;title&quot;: &quot;weight&quot;}}</span>
<span class="gi">+        ed = {}</span>
<span class="gi">+        edge_attr.update(ea)</span>
<span class="gi">+        edge_default.update(ed)</span>
<span class="gi">+        G.graph[&quot;edge_default&quot;] = edge_default</span>
<span class="gi">+</span>
<span class="gi">+        # add nodes</span>
<span class="gi">+        nodes_element = graph_xml.find(f&quot;{{{self.NS_GEXF}}}nodes&quot;)</span>
<span class="gi">+        if nodes_element is not None:</span>
<span class="gi">+            for node_xml in nodes_element.findall(f&quot;{{{self.NS_GEXF}}}node&quot;):</span>
<span class="gi">+                self.add_node(G, node_xml, node_attr)</span>
<span class="gi">+</span>
<span class="gi">+        # add edges</span>
<span class="gi">+        edges_element = graph_xml.find(f&quot;{{{self.NS_GEXF}}}edges&quot;)</span>
<span class="gi">+        if edges_element is not None:</span>
<span class="gi">+            for edge_xml in edges_element.findall(f&quot;{{{self.NS_GEXF}}}edge&quot;):</span>
<span class="gi">+                self.add_edge(G, edge_xml, edge_attr)</span>
<span class="gi">+</span>
<span class="gi">+        # switch to Graph or DiGraph if no parallel edges were found.</span>
<span class="gi">+        if self.simple_graph:</span>
<span class="gi">+            if G.is_directed():</span>
<span class="gi">+                G = nx.DiGraph(G)</span>
<span class="gi">+            else:</span>
<span class="gi">+                G = nx.Graph(G)</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="gi">+    def add_node(self, G, node_xml, node_attr, node_pid=None):</span>
<span class="gi">+        # add a single node with attributes to the graph</span>
<span class="gi">+</span>
<span class="gi">+        # get attributes and subattributues for node</span>
<span class="gi">+        data = self.decode_attr_elements(node_attr, node_xml)</span>
<span class="gi">+        data = self.add_parents(data, node_xml)  # add any parents</span>
<span class="gi">+        if self.VERSION == &quot;1.1&quot;:</span>
<span class="gi">+            data = self.add_slices(data, node_xml)  # add slices</span>
<span class="gi">+        else:</span>
<span class="gi">+            data = self.add_spells(data, node_xml)  # add spells</span>
<span class="gi">+        data = self.add_viz(data, node_xml)  # add viz</span>
<span class="gi">+        data = self.add_start_end(data, node_xml)  # add start/end</span>
<span class="gi">+</span>
<span class="gi">+        # find the node id and cast it to the appropriate type</span>
<span class="gi">+        node_id = node_xml.get(&quot;id&quot;)</span>
<span class="gi">+        if self.node_type is not None:</span>
<span class="gi">+            node_id = self.node_type(node_id)</span>
<span class="gi">+</span>
<span class="gi">+        # every node should have a label</span>
<span class="gi">+        node_label = node_xml.get(&quot;label&quot;)</span>
<span class="gi">+        data[&quot;label&quot;] = node_label</span>
<span class="gi">+</span>
<span class="gi">+        # parent node id</span>
<span class="gi">+        node_pid = node_xml.get(&quot;pid&quot;, node_pid)</span>
<span class="gi">+        if node_pid is not None:</span>
<span class="gi">+            data[&quot;pid&quot;] = node_pid</span>
<span class="gi">+</span>
<span class="gi">+        # check for subnodes, recursive</span>
<span class="gi">+        subnodes = node_xml.find(f&quot;{{{self.NS_GEXF}}}nodes&quot;)</span>
<span class="gi">+        if subnodes is not None:</span>
<span class="gi">+            for node_xml in subnodes.findall(f&quot;{{{self.NS_GEXF}}}node&quot;):</span>
<span class="gi">+                self.add_node(G, node_xml, node_attr, node_pid=node_id)</span>
<span class="gi">+</span>
<span class="gi">+        G.add_node(node_id, **data)</span>
<span class="gi">+</span>
<span class="gi">+    def add_start_end(self, data, xml):</span>
<span class="gi">+        # start and end times</span>
<span class="gi">+        ttype = self.timeformat</span>
<span class="gi">+        node_start = xml.get(&quot;start&quot;)</span>
<span class="gi">+        if node_start is not None:</span>
<span class="gi">+            data[&quot;start&quot;] = self.python_type[ttype](node_start)</span>
<span class="gi">+        node_end = xml.get(&quot;end&quot;)</span>
<span class="gi">+        if node_end is not None:</span>
<span class="gi">+            data[&quot;end&quot;] = self.python_type[ttype](node_end)</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def add_viz(self, data, node_xml):</span>
<span class="gi">+        # add viz element for node</span>
<span class="gi">+        viz = {}</span>
<span class="gi">+        color = node_xml.find(f&quot;{{{self.NS_VIZ}}}color&quot;)</span>
<span class="gi">+        if color is not None:</span>
<span class="gi">+            if self.VERSION == &quot;1.1&quot;:</span>
<span class="gi">+                viz[&quot;color&quot;] = {</span>
<span class="gi">+                    &quot;r&quot;: int(color.get(&quot;r&quot;)),</span>
<span class="gi">+                    &quot;g&quot;: int(color.get(&quot;g&quot;)),</span>
<span class="gi">+                    &quot;b&quot;: int(color.get(&quot;b&quot;)),</span>
<span class="gi">+                }</span>
<span class="gi">+            else:</span>
<span class="gi">+                viz[&quot;color&quot;] = {</span>
<span class="gi">+                    &quot;r&quot;: int(color.get(&quot;r&quot;)),</span>
<span class="gi">+                    &quot;g&quot;: int(color.get(&quot;g&quot;)),</span>
<span class="gi">+                    &quot;b&quot;: int(color.get(&quot;b&quot;)),</span>
<span class="gi">+                    &quot;a&quot;: float(color.get(&quot;a&quot;, 1)),</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="gi">+        size = node_xml.find(f&quot;{{{self.NS_VIZ}}}size&quot;)</span>
<span class="gi">+        if size is not None:</span>
<span class="gi">+            viz[&quot;size&quot;] = float(size.get(&quot;value&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        thickness = node_xml.find(f&quot;{{{self.NS_VIZ}}}thickness&quot;)</span>
<span class="gi">+        if thickness is not None:</span>
<span class="gi">+            viz[&quot;thickness&quot;] = float(thickness.get(&quot;value&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        shape = node_xml.find(f&quot;{{{self.NS_VIZ}}}shape&quot;)</span>
<span class="gi">+        if shape is not None:</span>
<span class="gi">+            viz[&quot;shape&quot;] = shape.get(&quot;shape&quot;)</span>
<span class="gi">+            if viz[&quot;shape&quot;] == &quot;image&quot;:</span>
<span class="gi">+                viz[&quot;shape&quot;] = shape.get(&quot;uri&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        position = node_xml.find(f&quot;{{{self.NS_VIZ}}}position&quot;)</span>
<span class="gi">+        if position is not None:</span>
<span class="gi">+            viz[&quot;position&quot;] = {</span>
<span class="gi">+                &quot;x&quot;: float(position.get(&quot;x&quot;, 0)),</span>
<span class="gi">+                &quot;y&quot;: float(position.get(&quot;y&quot;, 0)),</span>
<span class="gi">+                &quot;z&quot;: float(position.get(&quot;z&quot;, 0)),</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        if len(viz) &gt; 0:</span>
<span class="gi">+            data[&quot;viz&quot;] = viz</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def add_parents(self, data, node_xml):</span>
<span class="gi">+        parents_element = node_xml.find(f&quot;{{{self.NS_GEXF}}}parents&quot;)</span>
<span class="gi">+        if parents_element is not None:</span>
<span class="gi">+            data[&quot;parents&quot;] = []</span>
<span class="gi">+            for p in parents_element.findall(f&quot;{{{self.NS_GEXF}}}parent&quot;):</span>
<span class="gi">+                parent = p.get(&quot;for&quot;)</span>
<span class="gi">+                data[&quot;parents&quot;].append(parent)</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def add_slices(self, data, node_or_edge_xml):</span>
<span class="gi">+        slices_element = node_or_edge_xml.find(f&quot;{{{self.NS_GEXF}}}slices&quot;)</span>
<span class="gi">+        if slices_element is not None:</span>
<span class="gi">+            data[&quot;slices&quot;] = []</span>
<span class="gi">+            for s in slices_element.findall(f&quot;{{{self.NS_GEXF}}}slice&quot;):</span>
<span class="gi">+                start = s.get(&quot;start&quot;)</span>
<span class="gi">+                end = s.get(&quot;end&quot;)</span>
<span class="gi">+                data[&quot;slices&quot;].append((start, end))</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def add_spells(self, data, node_or_edge_xml):</span>
<span class="gi">+        spells_element = node_or_edge_xml.find(f&quot;{{{self.NS_GEXF}}}spells&quot;)</span>
<span class="gi">+        if spells_element is not None:</span>
<span class="gi">+            data[&quot;spells&quot;] = []</span>
<span class="gi">+            ttype = self.timeformat</span>
<span class="gi">+            for s in spells_element.findall(f&quot;{{{self.NS_GEXF}}}spell&quot;):</span>
<span class="gi">+                start = self.python_type[ttype](s.get(&quot;start&quot;))</span>
<span class="gi">+                end = self.python_type[ttype](s.get(&quot;end&quot;))</span>
<span class="gi">+                data[&quot;spells&quot;].append((start, end))</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    def add_edge(self, G, edge_element, edge_attr):</span>
<span class="gi">+        # add an edge to the graph</span>
<span class="gi">+</span>
<span class="gi">+        # raise error if we find mixed directed and undirected edges</span>
<span class="gi">+        edge_direction = edge_element.get(&quot;type&quot;)</span>
<span class="gi">+        if G.is_directed() and edge_direction == &quot;undirected&quot;:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Undirected edge found in directed graph.&quot;)</span>
<span class="gi">+        if (not G.is_directed()) and edge_direction == &quot;directed&quot;:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;Directed edge found in undirected graph.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Get source and target and recast type if required</span>
<span class="gi">+        source = edge_element.get(&quot;source&quot;)</span>
<span class="gi">+        target = edge_element.get(&quot;target&quot;)</span>
<span class="gi">+        if self.node_type is not None:</span>
<span class="gi">+            source = self.node_type(source)</span>
<span class="gi">+            target = self.node_type(target)</span>
<span class="gi">+</span>
<span class="gi">+        data = self.decode_attr_elements(edge_attr, edge_element)</span>
<span class="gi">+        data = self.add_start_end(data, edge_element)</span>
<span class="gi">+</span>
<span class="gi">+        if self.VERSION == &quot;1.1&quot;:</span>
<span class="gi">+            data = self.add_slices(data, edge_element)  # add slices</span>
<span class="gi">+        else:</span>
<span class="gi">+            data = self.add_spells(data, edge_element)  # add spells</span>
<span class="gi">+</span>
<span class="gi">+        # GEXF stores edge ids as an attribute</span>
<span class="gi">+        # NetworkX uses them as keys in multigraphs</span>
<span class="gi">+        # if networkx_key is not specified as an attribute</span>
<span class="gi">+        edge_id = edge_element.get(&quot;id&quot;)</span>
<span class="gi">+        if edge_id is not None:</span>
<span class="gi">+            data[&quot;id&quot;] = edge_id</span>
<span class="gi">+</span>
<span class="gi">+        # check if there is a &#39;multigraph_key&#39; and use that as edge_id</span>
<span class="gi">+        multigraph_key = data.pop(&quot;networkx_key&quot;, None)</span>
<span class="gi">+        if multigraph_key is not None:</span>
<span class="gi">+            edge_id = multigraph_key</span>
<span class="gi">+</span>
<span class="gi">+        weight = edge_element.get(&quot;weight&quot;)</span>
<span class="gi">+        if weight is not None:</span>
<span class="gi">+            data[&quot;weight&quot;] = float(weight)</span>
<span class="gi">+</span>
<span class="gi">+        edge_label = edge_element.get(&quot;label&quot;)</span>
<span class="gi">+        if edge_label is not None:</span>
<span class="gi">+            data[&quot;label&quot;] = edge_label</span>
<span class="gi">+</span>
<span class="gi">+        if G.has_edge(source, target):</span>
<span class="gi">+            # seen this edge before - this is a multigraph</span>
<span class="gi">+            self.simple_graph = False</span>
<span class="gi">+        G.add_edge(source, target, key=edge_id, **data)</span>
<span class="gi">+        if edge_direction == &quot;mutual&quot;:</span>
<span class="gi">+            G.add_edge(target, source, key=edge_id, **data)</span>
<span class="gi">+</span>
<span class="gi">+    def decode_attr_elements(self, gexf_keys, obj_xml):</span>
<span class="gi">+        # Use the key information to decode the attr XML</span>
<span class="gi">+        attr = {}</span>
<span class="gi">+        # look for outer &#39;&lt;attvalues&gt;&#39; element</span>
<span class="gi">+        attr_element = obj_xml.find(f&quot;{{{self.NS_GEXF}}}attvalues&quot;)</span>
<span class="gi">+        if attr_element is not None:</span>
<span class="gi">+            # loop over &lt;attvalue&gt; elements</span>
<span class="gi">+            for a in attr_element.findall(f&quot;{{{self.NS_GEXF}}}attvalue&quot;):</span>
<span class="gi">+                key = a.get(&quot;for&quot;)  # for is required</span>
<span class="gi">+                try:  # should be in our gexf_keys dictionary</span>
<span class="gi">+                    title = gexf_keys[key][&quot;title&quot;]</span>
<span class="gi">+                except KeyError as err:</span>
<span class="gi">+                    raise nx.NetworkXError(f&quot;No attribute defined for={key}.&quot;) from err</span>
<span class="gi">+                atype = gexf_keys[key][&quot;type&quot;]</span>
<span class="gi">+                value = a.get(&quot;value&quot;)</span>
<span class="gi">+                if atype == &quot;boolean&quot;:</span>
<span class="gi">+                    value = self.convert_bool[value]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    value = self.python_type[atype](value)</span>
<span class="gi">+                if gexf_keys[key][&quot;mode&quot;] == &quot;dynamic&quot;:</span>
<span class="gi">+                    # for dynamic graphs use list of three-tuples</span>
<span class="gi">+                    # [(value1,start1,end1), (value2,start2,end2), etc]</span>
<span class="gi">+                    ttype = self.timeformat</span>
<span class="gi">+                    start = self.python_type[ttype](a.get(&quot;start&quot;))</span>
<span class="gi">+                    end = self.python_type[ttype](a.get(&quot;end&quot;))</span>
<span class="gi">+                    if title in attr:</span>
<span class="gi">+                        attr[title].append((value, start, end))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        attr[title] = [(value, start, end)]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # for static graphs just assign the value</span>
<span class="gi">+                    attr[title] = value</span>
<span class="gi">+        return attr</span>
<span class="gi">+</span>
<span class="gi">+    def find_gexf_attributes(self, attributes_element):</span>
<span class="gi">+        # Extract all the attributes and defaults</span>
<span class="gi">+        attrs = {}</span>
<span class="gi">+        defaults = {}</span>
<span class="gi">+        mode = attributes_element.get(&quot;mode&quot;)</span>
<span class="gi">+        for k in attributes_element.findall(f&quot;{{{self.NS_GEXF}}}attribute&quot;):</span>
<span class="gi">+            attr_id = k.get(&quot;id&quot;)</span>
<span class="gi">+            title = k.get(&quot;title&quot;)</span>
<span class="gi">+            atype = k.get(&quot;type&quot;)</span>
<span class="gi">+            attrs[attr_id] = {&quot;title&quot;: title, &quot;type&quot;: atype, &quot;mode&quot;: mode}</span>
<span class="gi">+            # check for the &#39;default&#39; subelement of key element and add</span>
<span class="gi">+            default = k.find(f&quot;{{{self.NS_GEXF}}}default&quot;)</span>
<span class="gi">+            if default is not None:</span>
<span class="gi">+                if atype == &quot;boolean&quot;:</span>
<span class="gi">+                    value = self.convert_bool[default.text]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    value = self.python_type[atype](default.text)</span>
<span class="gi">+                defaults[title] = value</span>
<span class="gi">+        return attrs, defaults</span>


<span class="w"> </span>def relabel_gexf_graph(G):
<span class="gu">@@ -259,4 +1037,29 @@ def relabel_gexf_graph(G):</span>
<span class="w"> </span>    &quot;label&quot; attribute.  It also handles relabeling the specific GEXF
<span class="w"> </span>    node attributes &quot;parents&quot;, and &quot;pid&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # build mapping of node labels, do some error checking</span>
<span class="gi">+    try:</span>
<span class="gi">+        mapping = [(u, G.nodes[u][&quot;label&quot;]) for u in G]</span>
<span class="gi">+    except KeyError as err:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;Failed to relabel nodes: missing node labels found. Use relabel=False.&quot;</span>
<span class="gi">+        ) from err</span>
<span class="gi">+    x, y = zip(*mapping)</span>
<span class="gi">+    if len(set(y)) != len(G):</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;Failed to relabel nodes: &quot;</span>
<span class="gi">+            &quot;duplicate node labels found. &quot;</span>
<span class="gi">+            &quot;Use relabel=False.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    mapping = dict(mapping)</span>
<span class="gi">+    H = nx.relabel_nodes(G, mapping)</span>
<span class="gi">+    # relabel attributes</span>
<span class="gi">+    for n in G:</span>
<span class="gi">+        m = mapping[n]</span>
<span class="gi">+        H.nodes[m][&quot;id&quot;] = n</span>
<span class="gi">+        H.nodes[m].pop(&quot;label&quot;)</span>
<span class="gi">+        if &quot;pid&quot; in H.nodes[m]:</span>
<span class="gi">+            H.nodes[m][&quot;pid&quot;] = mapping[G.nodes[n][&quot;pid&quot;]]</span>
<span class="gi">+        if &quot;parents&quot; in H.nodes[m]:</span>
<span class="gi">+            H.nodes[m][&quot;parents&quot;] = [mapping[p] for p in G.nodes[n][&quot;parents&quot;]]</span>
<span class="gi">+    return H</span>
<span class="gh">diff --git a/networkx/readwrite/gml.py b/networkx/readwrite/gml.py</span>
<span class="gh">index f9204066b..bec991549 100644</span>
<span class="gd">--- a/networkx/readwrite/gml.py</span>
<span class="gi">+++ b/networkx/readwrite/gml.py</span>
<span class="gu">@@ -35,10 +35,12 @@ from collections import defaultdict</span>
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from typing import Any, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.utils import open_file
<span class="gd">-__all__ = [&#39;read_gml&#39;, &#39;parse_gml&#39;, &#39;generate_gml&#39;, &#39;write_gml&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;read_gml&quot;, &quot;parse_gml&quot;, &quot;generate_gml&quot;, &quot;write_gml&quot;]</span>


<span class="w"> </span>def escape(text):
<span class="gu">@@ -47,12 +49,38 @@ def escape(text):</span>
<span class="w"> </span>    Use XML character references for unprintable or non-ASCII
<span class="w"> </span>    characters, double quotes and ampersands in a string
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def fixup(m):</span>
<span class="gi">+        ch = m.group(0)</span>
<span class="gi">+        return &quot;&amp;#&quot; + str(ord(ch)) + &quot;;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    text = re.sub(&#39;[^ -~]|[&amp;&quot;]&#39;, fixup, text)</span>
<span class="gi">+    return text if isinstance(text, str) else str(text)</span>


<span class="w"> </span>def unescape(text):
<span class="w"> </span>    &quot;&quot;&quot;Replace XML character references with the referenced characters&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def fixup(m):</span>
<span class="gi">+        text = m.group(0)</span>
<span class="gi">+        if text[1] == &quot;#&quot;:</span>
<span class="gi">+            # Character reference</span>
<span class="gi">+            if text[2] == &quot;x&quot;:</span>
<span class="gi">+                code = int(text[3:-1], 16)</span>
<span class="gi">+            else:</span>
<span class="gi">+                code = int(text[2:-1])</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Named entity</span>
<span class="gi">+            try:</span>
<span class="gi">+                code = htmlentitydefs.name2codepoint[text[1:-1]]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                return text  # leave unchanged</span>
<span class="gi">+        try:</span>
<span class="gi">+            return chr(code)</span>
<span class="gi">+        except (ValueError, OverflowError):</span>
<span class="gi">+            return text  # leave unchanged</span>
<span class="gi">+</span>
<span class="gi">+    return re.sub(&quot;&amp;(?:[0-9A-Za-z]+|#(?:[0-9]+|x[0-9A-Fa-f]+));&quot;, fixup, text)</span>


<span class="w"> </span>def literal_destringizer(rep):
<span class="gu">@@ -73,12 +101,19 @@ def literal_destringizer(rep):</span>
<span class="w"> </span>    ValueError
<span class="w"> </span>        If `rep` is not a Python literal.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(rep, str):</span>
<span class="gi">+        orig_rep = rep</span>
<span class="gi">+        try:</span>
<span class="gi">+            return literal_eval(rep)</span>
<span class="gi">+        except SyntaxError as err:</span>
<span class="gi">+            raise ValueError(f&quot;{orig_rep!r} is not a valid Python literal&quot;) from err</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;{rep!r} is not a string&quot;)</span>


<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_gml(path, label=&#39;label&#39;, destringizer=None):</span>
<span class="gi">+def read_gml(path, label=&quot;label&quot;, destringizer=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read graph in GML format from `path`.

<span class="w"> </span>    Parameters
<span class="gu">@@ -143,11 +178,25 @@ def read_gml(path, label=&#39;label&#39;, destringizer=None):</span>
<span class="w"> </span>    NodeView((0, 1, 2, 3))

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def filter_lines(lines):</span>
<span class="gi">+        for line in lines:</span>
<span class="gi">+            try:</span>
<span class="gi">+                line = line.decode(&quot;ascii&quot;)</span>
<span class="gi">+            except UnicodeDecodeError as err:</span>
<span class="gi">+                raise NetworkXError(&quot;input is not ASCII-encoded&quot;) from err</span>
<span class="gi">+            if not isinstance(line, str):</span>
<span class="gi">+                lines = str(lines)</span>
<span class="gi">+            if line and line[-1] == &quot;\n&quot;:</span>
<span class="gi">+                line = line[:-1]</span>
<span class="gi">+            yield line</span>
<span class="gi">+</span>
<span class="gi">+    G = parse_gml_lines(filter_lines(path), label, destringizer)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def parse_gml(lines, label=&#39;label&#39;, destringizer=None):</span>
<span class="gi">+def parse_gml(lines, label=&quot;label&quot;, destringizer=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse GML graph from a string or iterable.

<span class="w"> </span>    Parameters
<span class="gu">@@ -195,11 +244,38 @@ def parse_gml(lines, label=&#39;label&#39;, destringizer=None):</span>

<span class="w"> </span>    See the module docstring :mod:`networkx.readwrite.gml` for more details.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def decode_line(line):</span>
<span class="gi">+        if isinstance(line, bytes):</span>
<span class="gi">+            try:</span>
<span class="gi">+                line.decode(&quot;ascii&quot;)</span>
<span class="gi">+            except UnicodeDecodeError as err:</span>
<span class="gi">+                raise NetworkXError(&quot;input is not ASCII-encoded&quot;) from err</span>
<span class="gi">+        if not isinstance(line, str):</span>
<span class="gi">+            line = str(line)</span>
<span class="gi">+        return line</span>
<span class="gi">+</span>
<span class="gi">+    def filter_lines(lines):</span>
<span class="gi">+        if isinstance(lines, str):</span>
<span class="gi">+            lines = decode_line(lines)</span>
<span class="gi">+            lines = lines.splitlines()</span>
<span class="gi">+            yield from lines</span>
<span class="gi">+        else:</span>
<span class="gi">+            for line in lines:</span>
<span class="gi">+                line = decode_line(line)</span>
<span class="gi">+                if line and line[-1] == &quot;\n&quot;:</span>
<span class="gi">+                    line = line[:-1]</span>
<span class="gi">+                if line.find(&quot;\n&quot;) != -1:</span>
<span class="gi">+                    raise NetworkXError(&quot;input line contains newline&quot;)</span>
<span class="gi">+                yield line</span>
<span class="gi">+</span>
<span class="gi">+    G = parse_gml_lines(filter_lines(lines), label, destringizer)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>class Pattern(Enum):
<span class="w"> </span>    &quot;&quot;&quot;encodes the index of each token-matching pattern in `tokenize`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    KEYS = 0
<span class="w"> </span>    REALS = 1
<span class="w"> </span>    INTS = 2
<span class="gu">@@ -216,12 +292,233 @@ class Token(NamedTuple):</span>
<span class="w"> </span>    position: int


<span class="gd">-LIST_START_VALUE = &#39;_networkx_list_start&#39;</span>
<span class="gi">+LIST_START_VALUE = &quot;_networkx_list_start&quot;</span>


<span class="w"> </span>def parse_gml_lines(lines, label, destringizer):
<span class="w"> </span>    &quot;&quot;&quot;Parse GML `lines` into a graph.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def tokenize():</span>
<span class="gi">+        patterns = [</span>
<span class="gi">+            r&quot;[A-Za-z][0-9A-Za-z_]*\b&quot;,  # keys</span>
<span class="gi">+            # reals</span>
<span class="gi">+            r&quot;[+-]?(?:[0-9]*\.[0-9]+|[0-9]+\.[0-9]*|INF)(?:[Ee][+-]?[0-9]+)?&quot;,</span>
<span class="gi">+            r&quot;[+-]?[0-9]+&quot;,  # ints</span>
<span class="gi">+            r&#39;&quot;.*?&quot;&#39;,  # strings</span>
<span class="gi">+            r&quot;\[&quot;,  # dict start</span>
<span class="gi">+            r&quot;\]&quot;,  # dict end</span>
<span class="gi">+            r&quot;#.*$|\s+&quot;,  # comments and whitespaces</span>
<span class="gi">+        ]</span>
<span class="gi">+        tokens = re.compile(&quot;|&quot;.join(f&quot;({pattern})&quot; for pattern in patterns))</span>
<span class="gi">+        lineno = 0</span>
<span class="gi">+        multilines = []  # entries spread across multiple lines</span>
<span class="gi">+        for line in lines:</span>
<span class="gi">+            pos = 0</span>
<span class="gi">+</span>
<span class="gi">+            # deal with entries spread across multiple lines</span>
<span class="gi">+            #</span>
<span class="gi">+            # should we actually have to deal with escaped &quot;s then do it here</span>
<span class="gi">+            if multilines:</span>
<span class="gi">+                multilines.append(line.strip())</span>
<span class="gi">+                if line[-1] == &#39;&quot;&#39;:  # closing multiline entry</span>
<span class="gi">+                    # multiline entries will be joined by space. cannot</span>
<span class="gi">+                    # reintroduce newlines as this will break the tokenizer</span>
<span class="gi">+                    line = &quot; &quot;.join(multilines)</span>
<span class="gi">+                    multilines = []</span>
<span class="gi">+                else:  # continued multiline entry</span>
<span class="gi">+                    lineno += 1</span>
<span class="gi">+                    continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                if line.count(&#39;&quot;&#39;) == 1:  # opening multiline entry</span>
<span class="gi">+                    if line.strip()[0] != &#39;&quot;&#39; and line.strip()[-1] != &#39;&quot;&#39;:</span>
<span class="gi">+                        # since we expect something like key &quot;value&quot;, the &quot; should not be found at ends</span>
<span class="gi">+                        # otherwise tokenizer will pick up the formatting mistake.</span>
<span class="gi">+                        multilines = [line.rstrip()]</span>
<span class="gi">+                        lineno += 1</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+            length = len(line)</span>
<span class="gi">+</span>
<span class="gi">+            while pos &lt; length:</span>
<span class="gi">+                match = tokens.match(line, pos)</span>
<span class="gi">+                if match is None:</span>
<span class="gi">+                    m = f&quot;cannot tokenize {line[pos:]} at ({lineno + 1}, {pos + 1})&quot;</span>
<span class="gi">+                    raise NetworkXError(m)</span>
<span class="gi">+                for i in range(len(patterns)):</span>
<span class="gi">+                    group = match.group(i + 1)</span>
<span class="gi">+                    if group is not None:</span>
<span class="gi">+                        if i == 0:  # keys</span>
<span class="gi">+                            value = group.rstrip()</span>
<span class="gi">+                        elif i == 1:  # reals</span>
<span class="gi">+                            value = float(group)</span>
<span class="gi">+                        elif i == 2:  # ints</span>
<span class="gi">+                            value = int(group)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            value = group</span>
<span class="gi">+                        if i != 6:  # comments and whitespaces</span>
<span class="gi">+                            yield Token(Pattern(i), value, lineno + 1, pos + 1)</span>
<span class="gi">+                        pos += len(group)</span>
<span class="gi">+                        break</span>
<span class="gi">+            lineno += 1</span>
<span class="gi">+        yield Token(None, None, lineno + 1, 1)  # EOF</span>
<span class="gi">+</span>
<span class="gi">+    def unexpected(curr_token, expected):</span>
<span class="gi">+        category, value, lineno, pos = curr_token</span>
<span class="gi">+        value = repr(value) if value is not None else &quot;EOF&quot;</span>
<span class="gi">+        raise NetworkXError(f&quot;expected {expected}, found {value} at ({lineno}, {pos})&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def consume(curr_token, category, expected):</span>
<span class="gi">+        if curr_token.category == category:</span>
<span class="gi">+            return next(tokens)</span>
<span class="gi">+        unexpected(curr_token, expected)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_kv(curr_token):</span>
<span class="gi">+        dct = defaultdict(list)</span>
<span class="gi">+        while curr_token.category == Pattern.KEYS:</span>
<span class="gi">+            key = curr_token.value</span>
<span class="gi">+            curr_token = next(tokens)</span>
<span class="gi">+            category = curr_token.category</span>
<span class="gi">+            if category == Pattern.REALS or category == Pattern.INTS:</span>
<span class="gi">+                value = curr_token.value</span>
<span class="gi">+                curr_token = next(tokens)</span>
<span class="gi">+            elif category == Pattern.STRINGS:</span>
<span class="gi">+                value = unescape(curr_token.value[1:-1])</span>
<span class="gi">+                if destringizer:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        value = destringizer(value)</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                # Special handling for empty lists and tuples</span>
<span class="gi">+                if value == &quot;()&quot;:</span>
<span class="gi">+                    value = ()</span>
<span class="gi">+                if value == &quot;[]&quot;:</span>
<span class="gi">+                    value = []</span>
<span class="gi">+                curr_token = next(tokens)</span>
<span class="gi">+            elif category == Pattern.DICT_START:</span>
<span class="gi">+                curr_token, value = parse_dict(curr_token)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Allow for string convertible id and label values</span>
<span class="gi">+                if key in (&quot;id&quot;, &quot;label&quot;, &quot;source&quot;, &quot;target&quot;):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        # String convert the token value</span>
<span class="gi">+                        value = unescape(str(curr_token.value))</span>
<span class="gi">+                        if destringizer:</span>
<span class="gi">+                            try:</span>
<span class="gi">+                                value = destringizer(value)</span>
<span class="gi">+                            except ValueError:</span>
<span class="gi">+                                pass</span>
<span class="gi">+                        curr_token = next(tokens)</span>
<span class="gi">+                    except Exception:</span>
<span class="gi">+                        msg = (</span>
<span class="gi">+                            &quot;an int, float, string, &#39;[&#39; or string&quot;</span>
<span class="gi">+                            + &quot; convertible ASCII value for node id or label&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                        unexpected(curr_token, msg)</span>
<span class="gi">+                # Special handling for nan and infinity.  Since the gml language</span>
<span class="gi">+                # defines unquoted strings as keys, the numeric and string branches</span>
<span class="gi">+                # are skipped and we end up in this special branch, so we need to</span>
<span class="gi">+                # convert the current token value to a float for NAN and plain INF.</span>
<span class="gi">+                # +/-INF are handled in the pattern for &#39;reals&#39; in tokenize().  This</span>
<span class="gi">+                # allows labels and values to be nan or infinity, but not keys.</span>
<span class="gi">+                elif curr_token.value in {&quot;NAN&quot;, &quot;INF&quot;}:</span>
<span class="gi">+                    value = float(curr_token.value)</span>
<span class="gi">+                    curr_token = next(tokens)</span>
<span class="gi">+                else:  # Otherwise error out</span>
<span class="gi">+                    unexpected(curr_token, &quot;an int, float, string or &#39;[&#39;&quot;)</span>
<span class="gi">+            dct[key].append(value)</span>
<span class="gi">+</span>
<span class="gi">+        def clean_dict_value(value):</span>
<span class="gi">+            if not isinstance(value, list):</span>
<span class="gi">+                return value</span>
<span class="gi">+            if len(value) == 1:</span>
<span class="gi">+                return value[0]</span>
<span class="gi">+            if value[0] == LIST_START_VALUE:</span>
<span class="gi">+                return value[1:]</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        dct = {key: clean_dict_value(value) for key, value in dct.items()}</span>
<span class="gi">+        return curr_token, dct</span>
<span class="gi">+</span>
<span class="gi">+    def parse_dict(curr_token):</span>
<span class="gi">+        # dict start</span>
<span class="gi">+        curr_token = consume(curr_token, Pattern.DICT_START, &quot;&#39;[&#39;&quot;)</span>
<span class="gi">+        # dict contents</span>
<span class="gi">+        curr_token, dct = parse_kv(curr_token)</span>
<span class="gi">+        # dict end</span>
<span class="gi">+        curr_token = consume(curr_token, Pattern.DICT_END, &quot;&#39;]&#39;&quot;)</span>
<span class="gi">+        return curr_token, dct</span>
<span class="gi">+</span>
<span class="gi">+    def parse_graph():</span>
<span class="gi">+        curr_token, dct = parse_kv(next(tokens))</span>
<span class="gi">+        if curr_token.category is not None:  # EOF</span>
<span class="gi">+            unexpected(curr_token, &quot;EOF&quot;)</span>
<span class="gi">+        if &quot;graph&quot; not in dct:</span>
<span class="gi">+            raise NetworkXError(&quot;input contains no graph&quot;)</span>
<span class="gi">+        graph = dct[&quot;graph&quot;]</span>
<span class="gi">+        if isinstance(graph, list):</span>
<span class="gi">+            raise NetworkXError(&quot;input contains more than one graph&quot;)</span>
<span class="gi">+        return graph</span>
<span class="gi">+</span>
<span class="gi">+    tokens = tokenize()</span>
<span class="gi">+    graph = parse_graph()</span>
<span class="gi">+</span>
<span class="gi">+    directed = graph.pop(&quot;directed&quot;, False)</span>
<span class="gi">+    multigraph = graph.pop(&quot;multigraph&quot;, False)</span>
<span class="gi">+    if not multigraph:</span>
<span class="gi">+        G = nx.DiGraph() if directed else nx.Graph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        G = nx.MultiDiGraph() if directed else nx.MultiGraph()</span>
<span class="gi">+    graph_attr = {k: v for k, v in graph.items() if k not in (&quot;node&quot;, &quot;edge&quot;)}</span>
<span class="gi">+    G.graph.update(graph_attr)</span>
<span class="gi">+</span>
<span class="gi">+    def pop_attr(dct, category, attr, i):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return dct.pop(attr)</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;{category} #{i} has no {attr!r} attribute&quot;) from err</span>
<span class="gi">+</span>
<span class="gi">+    nodes = graph.get(&quot;node&quot;, [])</span>
<span class="gi">+    mapping = {}</span>
<span class="gi">+    node_labels = set()</span>
<span class="gi">+    for i, node in enumerate(nodes if isinstance(nodes, list) else [nodes]):</span>
<span class="gi">+        id = pop_attr(node, &quot;node&quot;, &quot;id&quot;, i)</span>
<span class="gi">+        if id in G:</span>
<span class="gi">+            raise NetworkXError(f&quot;node id {id!r} is duplicated&quot;)</span>
<span class="gi">+        if label is not None and label != &quot;id&quot;:</span>
<span class="gi">+            node_label = pop_attr(node, &quot;node&quot;, label, i)</span>
<span class="gi">+            if node_label in node_labels:</span>
<span class="gi">+                raise NetworkXError(f&quot;node label {node_label!r} is duplicated&quot;)</span>
<span class="gi">+            node_labels.add(node_label)</span>
<span class="gi">+            mapping[id] = node_label</span>
<span class="gi">+        G.add_node(id, **node)</span>
<span class="gi">+</span>
<span class="gi">+    edges = graph.get(&quot;edge&quot;, [])</span>
<span class="gi">+    for i, edge in enumerate(edges if isinstance(edges, list) else [edges]):</span>
<span class="gi">+        source = pop_attr(edge, &quot;edge&quot;, &quot;source&quot;, i)</span>
<span class="gi">+        target = pop_attr(edge, &quot;edge&quot;, &quot;target&quot;, i)</span>
<span class="gi">+        if source not in G:</span>
<span class="gi">+            raise NetworkXError(f&quot;edge #{i} has undefined source {source!r}&quot;)</span>
<span class="gi">+        if target not in G:</span>
<span class="gi">+            raise NetworkXError(f&quot;edge #{i} has undefined target {target!r}&quot;)</span>
<span class="gi">+        if not multigraph:</span>
<span class="gi">+            if not G.has_edge(source, target):</span>
<span class="gi">+                G.add_edge(source, target, **edge)</span>
<span class="gi">+            else:</span>
<span class="gi">+                arrow = &quot;-&gt;&quot; if directed else &quot;--&quot;</span>
<span class="gi">+                msg = f&quot;edge #{i} ({source!r}{arrow}{target!r}) is duplicated&quot;</span>
<span class="gi">+                raise nx.NetworkXError(msg)</span>
<span class="gi">+        else:</span>
<span class="gi">+            key = edge.pop(&quot;key&quot;, None)</span>
<span class="gi">+            if key is not None and G.has_edge(source, target, key):</span>
<span class="gi">+                arrow = &quot;-&gt;&quot; if directed else &quot;--&quot;</span>
<span class="gi">+                msg = f&quot;edge #{i} ({source!r}{arrow}{target!r}, {key!r})&quot;</span>
<span class="gi">+                msg2 = &#39;Hint: If multigraph add &quot;multigraph 1&quot; to file header.&#39;</span>
<span class="gi">+                raise nx.NetworkXError(msg + &quot; is duplicated\n&quot; + msg2)</span>
<span class="gi">+            G.add_edge(source, target, key, **edge)</span>
<span class="gi">+</span>
<span class="gi">+    if label is not None and label != &quot;id&quot;:</span>
<span class="gi">+        G = nx.relabel_nodes(G, mapping)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>def literal_stringizer(value):
<span class="gu">@@ -248,11 +545,85 @@ def literal_stringizer(value):</span>
<span class="w"> </span>    The original value can be recovered using the
<span class="w"> </span>    :func:`networkx.readwrite.gml.literal_destringizer` function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def stringize(value):</span>
<span class="gi">+        if isinstance(value, int | bool) or value is None:</span>
<span class="gi">+            if value is True:  # GML uses 1/0 for boolean values.</span>
<span class="gi">+                buf.write(str(1))</span>
<span class="gi">+            elif value is False:</span>
<span class="gi">+                buf.write(str(0))</span>
<span class="gi">+            else:</span>
<span class="gi">+                buf.write(str(value))</span>
<span class="gi">+        elif isinstance(value, str):</span>
<span class="gi">+            text = repr(value)</span>
<span class="gi">+            if text[0] != &quot;u&quot;:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    value.encode(&quot;latin1&quot;)</span>
<span class="gi">+                except UnicodeEncodeError:</span>
<span class="gi">+                    text = &quot;u&quot; + text</span>
<span class="gi">+            buf.write(text)</span>
<span class="gi">+        elif isinstance(value, float | complex | str | bytes):</span>
<span class="gi">+            buf.write(repr(value))</span>
<span class="gi">+        elif isinstance(value, list):</span>
<span class="gi">+            buf.write(&quot;[&quot;)</span>
<span class="gi">+            first = True</span>
<span class="gi">+            for item in value:</span>
<span class="gi">+                if not first:</span>
<span class="gi">+                    buf.write(&quot;,&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    first = False</span>
<span class="gi">+                stringize(item)</span>
<span class="gi">+            buf.write(&quot;]&quot;)</span>
<span class="gi">+        elif isinstance(value, tuple):</span>
<span class="gi">+            if len(value) &gt; 1:</span>
<span class="gi">+                buf.write(&quot;(&quot;)</span>
<span class="gi">+                first = True</span>
<span class="gi">+                for item in value:</span>
<span class="gi">+                    if not first:</span>
<span class="gi">+                        buf.write(&quot;,&quot;)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        first = False</span>
<span class="gi">+                    stringize(item)</span>
<span class="gi">+                buf.write(&quot;)&quot;)</span>
<span class="gi">+            elif value:</span>
<span class="gi">+                buf.write(&quot;(&quot;)</span>
<span class="gi">+                stringize(value[0])</span>
<span class="gi">+                buf.write(&quot;,)&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                buf.write(&quot;()&quot;)</span>
<span class="gi">+        elif isinstance(value, dict):</span>
<span class="gi">+            buf.write(&quot;{&quot;)</span>
<span class="gi">+            first = True</span>
<span class="gi">+            for key, value in value.items():</span>
<span class="gi">+                if not first:</span>
<span class="gi">+                    buf.write(&quot;,&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    first = False</span>
<span class="gi">+                stringize(key)</span>
<span class="gi">+                buf.write(&quot;:&quot;)</span>
<span class="gi">+                stringize(value)</span>
<span class="gi">+            buf.write(&quot;}&quot;)</span>
<span class="gi">+        elif isinstance(value, set):</span>
<span class="gi">+            buf.write(&quot;{&quot;)</span>
<span class="gi">+            first = True</span>
<span class="gi">+            for item in value:</span>
<span class="gi">+                if not first:</span>
<span class="gi">+                    buf.write(&quot;,&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    first = False</span>
<span class="gi">+                stringize(item)</span>
<span class="gi">+            buf.write(&quot;}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = f&quot;{value!r} cannot be converted into a Python literal&quot;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    buf = StringIO()</span>
<span class="gi">+    stringize(value)</span>
<span class="gi">+    return buf.getvalue()</span>


<span class="w"> </span>def generate_gml(G, stringizer=None):
<span class="gd">-    &quot;&quot;&quot;Generate a single entry of the graph `G` in GML format.</span>
<span class="gi">+    r&quot;&quot;&quot;Generate a single entry of the graph `G` in GML format.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -303,7 +674,7 @@ def generate_gml(G, stringizer=None):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    &gt;&gt;&gt; G = nx.Graph()
<span class="w"> </span>    &gt;&gt;&gt; G.add_node(&quot;1&quot;)
<span class="gd">-    &gt;&gt;&gt; print(&quot;\\n&quot;.join(nx.generate_gml(G)))</span>
<span class="gi">+    &gt;&gt;&gt; print(&quot;\n&quot;.join(nx.generate_gml(G)))</span>
<span class="w"> </span>    graph [
<span class="w"> </span>      node [
<span class="w"> </span>        id 0
<span class="gu">@@ -311,7 +682,7 @@ def generate_gml(G, stringizer=None):</span>
<span class="w"> </span>      ]
<span class="w"> </span>    ]
<span class="w"> </span>    &gt;&gt;&gt; G = nx.MultiGraph([(&quot;a&quot;, &quot;b&quot;), (&quot;a&quot;, &quot;b&quot;)])
<span class="gd">-    &gt;&gt;&gt; print(&quot;\\n&quot;.join(nx.generate_gml(G)))</span>
<span class="gi">+    &gt;&gt;&gt; print(&quot;\n&quot;.join(nx.generate_gml(G)))</span>
<span class="w"> </span>    graph [
<span class="w"> </span>      multigraph 1
<span class="w"> </span>      node [
<span class="gu">@@ -334,10 +705,115 @@ def generate_gml(G, stringizer=None):</span>
<span class="w"> </span>      ]
<span class="w"> </span>    ]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gi">+    valid_keys = re.compile(&quot;^[A-Za-z][0-9A-Za-z_]*$&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def stringize(key, value, ignored_keys, indent, in_list=False):</span>
<span class="gi">+        if not isinstance(key, str):</span>
<span class="gi">+            raise NetworkXError(f&quot;{key!r} is not a string&quot;)</span>
<span class="gi">+        if not valid_keys.match(key):</span>
<span class="gi">+            raise NetworkXError(f&quot;{key!r} is not a valid key&quot;)</span>
<span class="gi">+        if not isinstance(key, str):</span>
<span class="gi">+            key = str(key)</span>
<span class="gi">+        if key not in ignored_keys:</span>
<span class="gi">+            if isinstance(value, int | bool):</span>
<span class="gi">+                if key == &quot;label&quot;:</span>
<span class="gi">+                    yield indent + key + &#39; &quot;&#39; + str(value) + &#39;&quot;&#39;</span>
<span class="gi">+                elif value is True:</span>
<span class="gi">+                    # python bool is an instance of int</span>
<span class="gi">+                    yield indent + key + &quot; 1&quot;</span>
<span class="gi">+                elif value is False:</span>
<span class="gi">+                    yield indent + key + &quot; 0&quot;</span>
<span class="gi">+                # GML only supports signed 32-bit integers</span>
<span class="gi">+                elif value &lt; -(2**31) or value &gt;= 2**31:</span>
<span class="gi">+                    yield indent + key + &#39; &quot;&#39; + str(value) + &#39;&quot;&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield indent + key + &quot; &quot; + str(value)</span>
<span class="gi">+            elif isinstance(value, float):</span>
<span class="gi">+                text = repr(value).upper()</span>
<span class="gi">+                # GML matches INF to keys, so prepend + to INF. Use repr(float(*))</span>
<span class="gi">+                # instead of string literal to future proof against changes to repr.</span>
<span class="gi">+                if text == repr(float(&quot;inf&quot;)).upper():</span>
<span class="gi">+                    text = &quot;+&quot; + text</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # GML requires that a real literal contain a decimal point, but</span>
<span class="gi">+                    # repr may not output a decimal point when the mantissa is</span>
<span class="gi">+                    # integral and hence needs fixing.</span>
<span class="gi">+                    epos = text.rfind(&quot;E&quot;)</span>
<span class="gi">+                    if epos != -1 and text.find(&quot;.&quot;, 0, epos) == -1:</span>
<span class="gi">+                        text = text[:epos] + &quot;.&quot; + text[epos:]</span>
<span class="gi">+                if key == &quot;label&quot;:</span>
<span class="gi">+                    yield indent + key + &#39; &quot;&#39; + text + &#39;&quot;&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield indent + key + &quot; &quot; + text</span>
<span class="gi">+            elif isinstance(value, dict):</span>
<span class="gi">+                yield indent + key + &quot; [&quot;</span>
<span class="gi">+                next_indent = indent + &quot;  &quot;</span>
<span class="gi">+                for key, value in value.items():</span>
<span class="gi">+                    yield from stringize(key, value, (), next_indent)</span>
<span class="gi">+                yield indent + &quot;]&quot;</span>
<span class="gi">+            elif isinstance(value, tuple) and key == &quot;label&quot;:</span>
<span class="gi">+                yield indent + key + f&quot; \&quot;({&#39;,&#39;.join(repr(v) for v in value)})\&quot;&quot;</span>
<span class="gi">+            elif isinstance(value, list | tuple) and key != &quot;label&quot; and not in_list:</span>
<span class="gi">+                if len(value) == 0:</span>
<span class="gi">+                    yield indent + key + &quot; &quot; + f&#39;&quot;{value!r}&quot;&#39;</span>
<span class="gi">+                if len(value) == 1:</span>
<span class="gi">+                    yield indent + key + &quot; &quot; + f&#39;&quot;{LIST_START_VALUE}&quot;&#39;</span>
<span class="gi">+                for val in value:</span>
<span class="gi">+                    yield from stringize(key, val, (), indent, True)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if stringizer:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        value = stringizer(value)</span>
<span class="gi">+                    except ValueError as err:</span>
<span class="gi">+                        raise NetworkXError(</span>
<span class="gi">+                            f&quot;{value!r} cannot be converted into a string&quot;</span>
<span class="gi">+                        ) from err</span>
<span class="gi">+                if not isinstance(value, str):</span>
<span class="gi">+                    raise NetworkXError(f&quot;{value!r} is not a string&quot;)</span>
<span class="gi">+                yield indent + key + &#39; &quot;&#39; + escape(value) + &#39;&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    multigraph = G.is_multigraph()</span>
<span class="gi">+    yield &quot;graph [&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Output graph attributes</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        yield &quot;  directed 1&quot;</span>
<span class="gi">+    if multigraph:</span>
<span class="gi">+        yield &quot;  multigraph 1&quot;</span>
<span class="gi">+    ignored_keys = {&quot;directed&quot;, &quot;multigraph&quot;, &quot;node&quot;, &quot;edge&quot;}</span>
<span class="gi">+    for attr, value in G.graph.items():</span>
<span class="gi">+        yield from stringize(attr, value, ignored_keys, &quot;  &quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Output node data</span>
<span class="gi">+    node_id = dict(zip(G, range(len(G))))</span>
<span class="gi">+    ignored_keys = {&quot;id&quot;, &quot;label&quot;}</span>
<span class="gi">+    for node, attrs in G.nodes.items():</span>
<span class="gi">+        yield &quot;  node [&quot;</span>
<span class="gi">+        yield &quot;    id &quot; + str(node_id[node])</span>
<span class="gi">+        yield from stringize(&quot;label&quot;, node, (), &quot;    &quot;)</span>
<span class="gi">+        for attr, value in attrs.items():</span>
<span class="gi">+            yield from stringize(attr, value, ignored_keys, &quot;    &quot;)</span>
<span class="gi">+        yield &quot;  ]&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Output edge data</span>
<span class="gi">+    ignored_keys = {&quot;source&quot;, &quot;target&quot;}</span>
<span class="gi">+    kwargs = {&quot;data&quot;: True}</span>
<span class="gi">+    if multigraph:</span>
<span class="gi">+        ignored_keys.add(&quot;key&quot;)</span>
<span class="gi">+        kwargs[&quot;keys&quot;] = True</span>
<span class="gi">+    for e in G.edges(**kwargs):</span>
<span class="gi">+        yield &quot;  edge [&quot;</span>
<span class="gi">+        yield &quot;    source &quot; + str(node_id[e[0]])</span>
<span class="gi">+        yield &quot;    target &quot; + str(node_id[e[1]])</span>
<span class="gi">+        if multigraph:</span>
<span class="gi">+            yield from stringize(&quot;key&quot;, e[2], (), &quot;    &quot;)</span>
<span class="gi">+        for attr, value in e[-1].items():</span>
<span class="gi">+            yield from stringize(attr, value, ignored_keys, &quot;    &quot;)</span>
<span class="gi">+        yield &quot;  ]&quot;</span>
<span class="gi">+    yield &quot;]&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="w"> </span>def write_gml(G, path, stringizer=None):
<span class="w"> </span>    &quot;&quot;&quot;Write a graph `G` in GML format to the file or file handle `path`.

<span class="gu">@@ -398,4 +874,5 @@ def write_gml(G, path, stringizer=None):</span>

<span class="w"> </span>    &gt;&gt;&gt; nx.write_gml(G, &quot;test.gml.gz&quot;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for line in generate_gml(G, stringizer):</span>
<span class="gi">+        path.write((line + &quot;\n&quot;).encode(&quot;ascii&quot;))</span>
<span class="gh">diff --git a/networkx/readwrite/graph6.py b/networkx/readwrite/graph6.py</span>
<span class="gh">index bde8b1b56..5e2a30aa7 100644</span>
<span class="gd">--- a/networkx/readwrite/graph6.py</span>
<span class="gi">+++ b/networkx/readwrite/graph6.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+# Original author: D. Eppstein, UC Irvine, August 12, 2003.</span>
<span class="gi">+# The original code at http://www.ics.uci.edu/~eppstein/PADS/ is public domain.</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for reading and writing graphs in the *graph6* format.

<span class="w"> </span>The *graph6* file format is suitable for small graphs or large dense
<span class="gu">@@ -9,11 +11,12 @@ For more information, see the `graph6`_ homepage.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from itertools import islice
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.utils import not_implemented_for, open_file
<span class="gd">-__all__ = [&#39;from_graph6_bytes&#39;, &#39;read_graph6&#39;, &#39;to_graph6_bytes&#39;,</span>
<span class="gd">-    &#39;write_graph6&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;from_graph6_bytes&quot;, &quot;read_graph6&quot;, &quot;to_graph6_bytes&quot;, &quot;write_graph6&quot;]</span>


<span class="w"> </span>def _generate_graph6_bytes(G, nodes, header):
<span class="gu">@@ -37,7 +40,24 @@ def _generate_graph6_bytes(G, nodes, header):</span>
<span class="w"> </span>    the graph6 format (that is, greater than ``2 ** 36`` nodes).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    if n &gt;= 2**36:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;graph6 is only defined if number of nodes is less than 2 ** 36&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if header:</span>
<span class="gi">+        yield b&quot;&gt;&gt;graph6&lt;&lt;&quot;</span>
<span class="gi">+    for d in n_to_data(n):</span>
<span class="gi">+        yield str.encode(chr(d + 63))</span>
<span class="gi">+    # This generates the same as `(v in G[u] for u, v in combinations(G, 2))`,</span>
<span class="gi">+    # but in &quot;column-major&quot; order instead of &quot;row-major&quot; order.</span>
<span class="gi">+    bits = (nodes[j] in G[nodes[i]] for j in range(1, n) for i in range(j))</span>
<span class="gi">+    chunk = list(islice(bits, 6))</span>
<span class="gi">+    while chunk:</span>
<span class="gi">+        d = sum(b &lt;&lt; 5 - i for i, b in enumerate(chunk))</span>
<span class="gi">+        yield str.encode(chr(d + 63))</span>
<span class="gi">+        chunk = list(islice(bits, 6))</span>
<span class="gi">+    yield b&quot;\n&quot;</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -78,11 +98,39 @@ def from_graph6_bytes(bytes_in):</span>
<span class="w"> </span>           &lt;http://users.cecs.anu.edu.au/~bdm/data/formats.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def bits():</span>
<span class="gi">+        &quot;&quot;&quot;Returns sequence of individual bits from 6-bit-per-value</span>
<span class="gi">+        list of data values.&quot;&quot;&quot;</span>
<span class="gi">+        for d in data:</span>
<span class="gi">+            for i in [5, 4, 3, 2, 1, 0]:</span>
<span class="gi">+                yield (d &gt;&gt; i) &amp; 1</span>
<span class="gi">+</span>
<span class="gi">+    if bytes_in.startswith(b&quot;&gt;&gt;graph6&lt;&lt;&quot;):</span>
<span class="gi">+        bytes_in = bytes_in[10:]</span>
<span class="gi">+</span>
<span class="gi">+    data = [c - 63 for c in bytes_in]</span>
<span class="gi">+    if any(c &gt; 63 for c in data):</span>
<span class="gi">+        raise ValueError(&quot;each input character must be in range(63, 127)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    n, data = data_to_n(data)</span>
<span class="gi">+    nd = (n * (n - 1) // 2 + 5) // 6</span>
<span class="gi">+    if len(data) != nd:</span>
<span class="gi">+        raise NetworkXError(</span>
<span class="gi">+            f&quot;Expected {n * (n - 1) // 2} bits but got {len(data) * 6} in graph6&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+    G = nx.Graph()</span>
<span class="gi">+    G.add_nodes_from(range(n))</span>
<span class="gi">+    for (i, j), b in zip(((i, j) for j in range(1, n) for i in range(j)), bits()):</span>
<span class="gi">+        if b:</span>
<span class="gi">+            G.add_edge(i, j)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>def to_graph6_bytes(G, nodes=None, header=True):
<span class="w"> </span>    &quot;&quot;&quot;Convert a simple undirected graph to bytes in graph6 format.

<span class="gu">@@ -128,10 +176,14 @@ def to_graph6_bytes(G, nodes=None, header=True):</span>
<span class="w"> </span>           &lt;http://users.cecs.anu.edu.au/~bdm/data/formats.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes is not None:</span>
<span class="gi">+        G = G.subgraph(nodes)</span>
<span class="gi">+    H = nx.convert_node_labels_to_integers(G)</span>
<span class="gi">+    nodes = sorted(H.nodes())</span>
<span class="gi">+    return b&quot;&quot;.join(_generate_graph6_bytes(H, nodes, header))</span>


<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def read_graph6(path):
<span class="w"> </span>    &quot;&quot;&quot;Read simple undirected graphs in graph6 format from path.
<span class="gu">@@ -183,12 +235,21 @@ def read_graph6(path):</span>
<span class="w"> </span>           &lt;http://users.cecs.anu.edu.au/~bdm/data/formats.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gi">+    glist = []</span>
<span class="gi">+    for line in path:</span>
<span class="gi">+        line = line.strip()</span>
<span class="gi">+        if not len(line):</span>
<span class="gi">+            continue</span>
<span class="gi">+        glist.append(from_graph6_bytes(line))</span>
<span class="gi">+    if len(glist) == 1:</span>
<span class="gi">+        return glist[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return glist</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="w"> </span>def write_graph6(G, path, nodes=None, header=True):
<span class="w"> </span>    &quot;&quot;&quot;Write a simple undirected graph to a path in graph6 format.

<span class="gu">@@ -244,11 +305,11 @@ def write_graph6(G, path, nodes=None, header=True):</span>
<span class="w"> </span>           &lt;http://users.cecs.anu.edu.au/~bdm/data/formats.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return write_graph6_file(G, path, nodes=nodes, header=header)</span>


<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@not_implemented_for(&#39;multigraph&#39;)</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@not_implemented_for(&quot;multigraph&quot;)</span>
<span class="w"> </span>def write_graph6_file(G, f, nodes=None, header=True):
<span class="w"> </span>    &quot;&quot;&quot;Write a simple undirected graph to a file-like object in graph6 format.

<span class="gu">@@ -304,7 +365,12 @@ def write_graph6_file(G, f, nodes=None, header=True):</span>
<span class="w"> </span>           &lt;http://users.cecs.anu.edu.au/~bdm/data/formats.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes is not None:</span>
<span class="gi">+        G = G.subgraph(nodes)</span>
<span class="gi">+    H = nx.convert_node_labels_to_integers(G)</span>
<span class="gi">+    nodes = sorted(H.nodes())</span>
<span class="gi">+    for b in _generate_graph6_bytes(H, nodes, header):</span>
<span class="gi">+        f.write(b)</span>


<span class="w"> </span>def data_to_n(data):
<span class="gu">@@ -312,7 +378,19 @@ def data_to_n(data):</span>
<span class="w"> </span>    integer sequence.

<span class="w"> </span>    Return (value, rest of seq.)&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if data[0] &lt;= 62:</span>
<span class="gi">+        return data[0], data[1:]</span>
<span class="gi">+    if data[1] &lt;= 62:</span>
<span class="gi">+        return (data[1] &lt;&lt; 12) + (data[2] &lt;&lt; 6) + data[3], data[4:]</span>
<span class="gi">+    return (</span>
<span class="gi">+        (data[2] &lt;&lt; 30)</span>
<span class="gi">+        + (data[3] &lt;&lt; 24)</span>
<span class="gi">+        + (data[4] &lt;&lt; 18)</span>
<span class="gi">+        + (data[5] &lt;&lt; 12)</span>
<span class="gi">+        + (data[6] &lt;&lt; 6)</span>
<span class="gi">+        + data[7],</span>
<span class="gi">+        data[8:],</span>
<span class="gi">+    )</span>


<span class="w"> </span>def n_to_data(n):
<span class="gu">@@ -321,4 +399,18 @@ def n_to_data(n):</span>
<span class="w"> </span>    This function is undefined if `n` is not in ``range(2 ** 36)``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n &lt;= 62:</span>
<span class="gi">+        return [n]</span>
<span class="gi">+    elif n &lt;= 258047:</span>
<span class="gi">+        return [63, (n &gt;&gt; 12) &amp; 0x3F, (n &gt;&gt; 6) &amp; 0x3F, n &amp; 0x3F]</span>
<span class="gi">+    else:  # if n &lt;= 68719476735:</span>
<span class="gi">+        return [</span>
<span class="gi">+            63,</span>
<span class="gi">+            63,</span>
<span class="gi">+            (n &gt;&gt; 30) &amp; 0x3F,</span>
<span class="gi">+            (n &gt;&gt; 24) &amp; 0x3F,</span>
<span class="gi">+            (n &gt;&gt; 18) &amp; 0x3F,</span>
<span class="gi">+            (n &gt;&gt; 12) &amp; 0x3F,</span>
<span class="gi">+            (n &gt;&gt; 6) &amp; 0x3F,</span>
<span class="gi">+            n &amp; 0x3F,</span>
<span class="gi">+        ]</span>
<span class="gh">diff --git a/networkx/readwrite/graphml.py b/networkx/readwrite/graphml.py</span>
<span class="gh">index 4b7a04ad1..0b05e03a3 100644</span>
<span class="gd">--- a/networkx/readwrite/graphml.py</span>
<span class="gi">+++ b/networkx/readwrite/graphml.py</span>
<span class="gu">@@ -42,17 +42,32 @@ for examples.</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import warnings
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import open_file
<span class="gd">-__all__ = [&#39;write_graphml&#39;, &#39;read_graphml&#39;, &#39;generate_graphml&#39;,</span>
<span class="gd">-    &#39;write_graphml_xml&#39;, &#39;write_graphml_lxml&#39;, &#39;parse_graphml&#39;,</span>
<span class="gd">-    &#39;GraphMLWriter&#39;, &#39;GraphMLReader&#39;]</span>
<span class="gd">-</span>

<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gd">-def write_graphml_xml(G, path, encoding=&#39;utf-8&#39;, prettyprint=True,</span>
<span class="gd">-    infer_numeric_types=False, named_key_ids=False, edge_id_from_attribute=None</span>
<span class="gd">-    ):</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;write_graphml&quot;,</span>
<span class="gi">+    &quot;read_graphml&quot;,</span>
<span class="gi">+    &quot;generate_graphml&quot;,</span>
<span class="gi">+    &quot;write_graphml_xml&quot;,</span>
<span class="gi">+    &quot;write_graphml_lxml&quot;,</span>
<span class="gi">+    &quot;parse_graphml&quot;,</span>
<span class="gi">+    &quot;GraphMLWriter&quot;,</span>
<span class="gi">+    &quot;GraphMLReader&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="gi">+def write_graphml_xml(</span>
<span class="gi">+    G,</span>
<span class="gi">+    path,</span>
<span class="gi">+    encoding=&quot;utf-8&quot;,</span>
<span class="gi">+    prettyprint=True,</span>
<span class="gi">+    infer_numeric_types=False,</span>
<span class="gi">+    named_key_ids=False,</span>
<span class="gi">+    edge_id_from_attribute=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write G in GraphML XML format to path

<span class="w"> </span>    Parameters
<span class="gu">@@ -87,13 +102,27 @@ def write_graphml_xml(G, path, encoding=&#39;utf-8&#39;, prettyprint=True,</span>
<span class="w"> </span>    This implementation does not support mixed graphs (directed
<span class="w"> </span>    and unidirected edges together) hyperedges, nested graphs, or ports.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gd">-def write_graphml_lxml(G, path, encoding=&#39;utf-8&#39;, prettyprint=True,</span>
<span class="gd">-    infer_numeric_types=False, named_key_ids=False, edge_id_from_attribute=None</span>
<span class="gd">-    ):</span>
<span class="gi">+    writer = GraphMLWriter(</span>
<span class="gi">+        encoding=encoding,</span>
<span class="gi">+        prettyprint=prettyprint,</span>
<span class="gi">+        infer_numeric_types=infer_numeric_types,</span>
<span class="gi">+        named_key_ids=named_key_ids,</span>
<span class="gi">+        edge_id_from_attribute=edge_id_from_attribute,</span>
<span class="gi">+    )</span>
<span class="gi">+    writer.add_graph_element(G)</span>
<span class="gi">+    writer.dump(path)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="gi">+def write_graphml_lxml(</span>
<span class="gi">+    G,</span>
<span class="gi">+    path,</span>
<span class="gi">+    encoding=&quot;utf-8&quot;,</span>
<span class="gi">+    prettyprint=True,</span>
<span class="gi">+    infer_numeric_types=False,</span>
<span class="gi">+    named_key_ids=False,</span>
<span class="gi">+    edge_id_from_attribute=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write G in GraphML XML format to path

<span class="w"> </span>    This function uses the LXML framework and should be faster than
<span class="gu">@@ -131,11 +160,38 @@ def write_graphml_lxml(G, path, encoding=&#39;utf-8&#39;, prettyprint=True,</span>
<span class="w"> </span>    This implementation does not support mixed graphs (directed
<span class="w"> </span>    and unidirected edges together) hyperedges, nested graphs, or ports.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def generate_graphml(G, encoding=&#39;utf-8&#39;, prettyprint=True, named_key_ids=</span>
<span class="gd">-    False, edge_id_from_attribute=None):</span>
<span class="gi">+    try:</span>
<span class="gi">+        import lxml.etree as lxmletree</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        return write_graphml_xml(</span>
<span class="gi">+            G,</span>
<span class="gi">+            path,</span>
<span class="gi">+            encoding,</span>
<span class="gi">+            prettyprint,</span>
<span class="gi">+            infer_numeric_types,</span>
<span class="gi">+            named_key_ids,</span>
<span class="gi">+            edge_id_from_attribute,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    writer = GraphMLWriterLxml(</span>
<span class="gi">+        path,</span>
<span class="gi">+        graph=G,</span>
<span class="gi">+        encoding=encoding,</span>
<span class="gi">+        prettyprint=prettyprint,</span>
<span class="gi">+        infer_numeric_types=infer_numeric_types,</span>
<span class="gi">+        named_key_ids=named_key_ids,</span>
<span class="gi">+        edge_id_from_attribute=edge_id_from_attribute,</span>
<span class="gi">+    )</span>
<span class="gi">+    writer.dump()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generate_graphml(</span>
<span class="gi">+    G,</span>
<span class="gi">+    encoding=&quot;utf-8&quot;,</span>
<span class="gi">+    prettyprint=True,</span>
<span class="gi">+    named_key_ids=False,</span>
<span class="gi">+    edge_id_from_attribute=None,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate GraphML lines for G

<span class="w"> </span>    Parameters
<span class="gu">@@ -156,8 +212,7 @@ def generate_graphml(G, encoding=&#39;utf-8&#39;, prettyprint=True, named_key_ids=</span>
<span class="w"> </span>    Examples
<span class="w"> </span>    --------
<span class="w"> </span>    &gt;&gt;&gt; G = nx.path_graph(4)
<span class="gd">-    &gt;&gt;&gt; linefeed = chr(10)  # linefeed = </span>
<span class="gd">-</span>
<span class="gi">+    &gt;&gt;&gt; linefeed = chr(10)  # linefeed = \n</span>
<span class="w"> </span>    &gt;&gt;&gt; s = linefeed.join(nx.generate_graphml(G))
<span class="w"> </span>    &gt;&gt;&gt; for line in nx.generate_graphml(G):  # doctest: +SKIP
<span class="w"> </span>    ...     print(line)
<span class="gu">@@ -167,13 +222,19 @@ def generate_graphml(G, encoding=&#39;utf-8&#39;, prettyprint=True, named_key_ids=</span>
<span class="w"> </span>    This implementation does not support mixed graphs (directed and unidirected
<span class="w"> </span>    edges together) hyperedges, nested graphs, or ports.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    writer = GraphMLWriter(</span>
<span class="gi">+        encoding=encoding,</span>
<span class="gi">+        prettyprint=prettyprint,</span>
<span class="gi">+        named_key_ids=named_key_ids,</span>
<span class="gi">+        edge_id_from_attribute=edge_id_from_attribute,</span>
<span class="gi">+    )</span>
<span class="gi">+    writer.add_graph_element(G)</span>
<span class="gi">+    yield from str(writer).splitlines()</span>


<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_graphml(path, node_type=str, edge_key_type=int, force_multigraph=False</span>
<span class="gd">-    ):</span>
<span class="gi">+def read_graphml(path, node_type=str, edge_key_type=int, force_multigraph=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read graph in GraphML format from path.

<span class="w"> </span>    Parameters
<span class="gu">@@ -230,12 +291,25 @@ def read_graphml(path, node_type=str, edge_key_type=int, force_multigraph=False</span>
<span class="w"> </span>    the file to &quot;file.graphml.gz&quot;.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    reader = GraphMLReader(node_type, edge_key_type, force_multigraph)</span>
<span class="gi">+    # need to check for multiple graphs</span>
<span class="gi">+    glist = list(reader(path=path))</span>
<span class="gi">+    if len(glist) == 0:</span>
<span class="gi">+        # If no graph comes back, try looking for an incomplete header</span>
<span class="gi">+        header = b&#39;&lt;graphml xmlns=&quot;http://graphml.graphdrawing.org/xmlns&quot;&gt;&#39;</span>
<span class="gi">+        path.seek(0)</span>
<span class="gi">+        old_bytes = path.read()</span>
<span class="gi">+        new_bytes = old_bytes.replace(b&quot;&lt;graphml&gt;&quot;, header)</span>
<span class="gi">+        glist = list(reader(string=new_bytes))</span>
<span class="gi">+        if len(glist) == 0:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;file not successfully read as graphml&quot;)</span>
<span class="gi">+    return glist[0]</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def parse_graphml(graphml_string, node_type=str, edge_key_type=int,</span>
<span class="gd">-    force_multigraph=False):</span>
<span class="gi">+def parse_graphml(</span>
<span class="gi">+    graphml_string, node_type=str, edge_key_type=int, force_multigraph=False</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read graph in GraphML format from string.

<span class="w"> </span>    Parameters
<span class="gu">@@ -265,8 +339,7 @@ def parse_graphml(graphml_string, node_type=str, edge_key_type=int,</span>
<span class="w"> </span>    Examples
<span class="w"> </span>    --------
<span class="w"> </span>    &gt;&gt;&gt; G = nx.path_graph(4)
<span class="gd">-    &gt;&gt;&gt; linefeed = chr(10)  # linefeed = </span>
<span class="gd">-</span>
<span class="gi">+    &gt;&gt;&gt; linefeed = chr(10)  # linefeed = \n</span>
<span class="w"> </span>    &gt;&gt;&gt; s = linefeed.join(nx.generate_graphml(G))
<span class="w"> </span>    &gt;&gt;&gt; H = nx.parse_graphml(s)

<span class="gu">@@ -294,49 +367,136 @@ def parse_graphml(graphml_string, node_type=str, edge_key_type=int,</span>
<span class="w"> </span>    will be provided.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    reader = GraphMLReader(node_type, edge_key_type, force_multigraph)</span>
<span class="gi">+    # need to check for multiple graphs</span>
<span class="gi">+    glist = list(reader(string=graphml_string))</span>
<span class="gi">+    if len(glist) == 0:</span>
<span class="gi">+        # If no graph comes back, try looking for an incomplete header</span>
<span class="gi">+        header = &#39;&lt;graphml xmlns=&quot;http://graphml.graphdrawing.org/xmlns&quot;&gt;&#39;</span>
<span class="gi">+        new_string = graphml_string.replace(&quot;&lt;graphml&gt;&quot;, header)</span>
<span class="gi">+        glist = list(reader(string=new_string))</span>
<span class="gi">+        if len(glist) == 0:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;file not successfully read as graphml&quot;)</span>
<span class="gi">+    return glist[0]</span>


<span class="w"> </span>class GraphML:
<span class="gd">-    NS_GRAPHML = &#39;http://graphml.graphdrawing.org/xmlns&#39;</span>
<span class="gd">-    NS_XSI = &#39;http://www.w3.org/2001/XMLSchema-instance&#39;</span>
<span class="gd">-    NS_Y = &#39;http://www.yworks.com/xml/graphml&#39;</span>
<span class="gd">-    SCHEMALOCATION = &#39; &#39;.join([&#39;http://graphml.graphdrawing.org/xmlns&#39;,</span>
<span class="gd">-        &#39;http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd&#39;])</span>
<span class="gd">-    convert_bool = {&#39;true&#39;: True, &#39;false&#39;: False, &#39;0&#39;: False, (0): False,</span>
<span class="gd">-        &#39;1&#39;: True, (1): True}</span>
<span class="gi">+    NS_GRAPHML = &quot;http://graphml.graphdrawing.org/xmlns&quot;</span>
<span class="gi">+    NS_XSI = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="gi">+    # xmlns:y=&quot;http://www.yworks.com/xml/graphml&quot;</span>
<span class="gi">+    NS_Y = &quot;http://www.yworks.com/xml/graphml&quot;</span>
<span class="gi">+    SCHEMALOCATION = &quot; &quot;.join(</span>
<span class="gi">+        [</span>
<span class="gi">+            &quot;http://graphml.graphdrawing.org/xmlns&quot;,</span>
<span class="gi">+            &quot;http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def construct_types(self):</span>
<span class="gi">+        types = [</span>
<span class="gi">+            (int, &quot;integer&quot;),  # for Gephi GraphML bug</span>
<span class="gi">+            (str, &quot;yfiles&quot;),</span>
<span class="gi">+            (str, &quot;string&quot;),</span>
<span class="gi">+            (int, &quot;int&quot;),</span>
<span class="gi">+            (int, &quot;long&quot;),</span>
<span class="gi">+            (float, &quot;float&quot;),</span>
<span class="gi">+            (float, &quot;double&quot;),</span>
<span class="gi">+            (bool, &quot;boolean&quot;),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # These additions to types allow writing numpy types</span>
<span class="gi">+        try:</span>
<span class="gi">+            import numpy as np</span>
<span class="gi">+        except:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            # prepend so that python types are created upon read (last entry wins)</span>
<span class="gi">+            types = [</span>
<span class="gi">+                (np.float64, &quot;float&quot;),</span>
<span class="gi">+                (np.float32, &quot;float&quot;),</span>
<span class="gi">+                (np.float16, &quot;float&quot;),</span>
<span class="gi">+                (np.int_, &quot;int&quot;),</span>
<span class="gi">+                (np.int8, &quot;int&quot;),</span>
<span class="gi">+                (np.int16, &quot;int&quot;),</span>
<span class="gi">+                (np.int32, &quot;int&quot;),</span>
<span class="gi">+                (np.int64, &quot;int&quot;),</span>
<span class="gi">+                (np.uint8, &quot;int&quot;),</span>
<span class="gi">+                (np.uint16, &quot;int&quot;),</span>
<span class="gi">+                (np.uint32, &quot;int&quot;),</span>
<span class="gi">+                (np.uint64, &quot;int&quot;),</span>
<span class="gi">+                (np.int_, &quot;int&quot;),</span>
<span class="gi">+                (np.intc, &quot;int&quot;),</span>
<span class="gi">+                (np.intp, &quot;int&quot;),</span>
<span class="gi">+            ] + types</span>
<span class="gi">+</span>
<span class="gi">+        self.xml_type = dict(types)</span>
<span class="gi">+        self.python_type = dict(reversed(a) for a in types)</span>
<span class="gi">+</span>
<span class="gi">+    # This page says that data types in GraphML follow Java(TM).</span>
<span class="gi">+    #  http://graphml.graphdrawing.org/primer/graphml-primer.html#AttributesDefinition</span>
<span class="gi">+    # true and false are the only boolean literals:</span>
<span class="gi">+    #  http://en.wikibooks.org/wiki/Java_Programming/Literals#Boolean_Literals</span>
<span class="gi">+    convert_bool = {</span>
<span class="gi">+        # We use data.lower() in actual use.</span>
<span class="gi">+        &quot;true&quot;: True,</span>
<span class="gi">+        &quot;false&quot;: False,</span>
<span class="gi">+        # Include integer strings for convenience.</span>
<span class="gi">+        &quot;0&quot;: False,</span>
<span class="gi">+        0: False,</span>
<span class="gi">+        &quot;1&quot;: True,</span>
<span class="gi">+        1: True,</span>
<span class="gi">+    }</span>

<span class="w"> </span>    def get_xml_type(self, key):
<span class="w"> </span>        &quot;&quot;&quot;Wrapper around the xml_type dict that raises a more informative
<span class="w"> </span>        exception message when a user attempts to use data of a type not
<span class="w"> </span>        supported by GraphML.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.xml_type[key]</span>
<span class="gi">+        except KeyError as err:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&quot;GraphML does not support type {key} as data values.&quot;</span>
<span class="gi">+            ) from err</span>


<span class="w"> </span>class GraphMLWriter(GraphML):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, graph=None, encoding=&#39;utf-8&#39;, prettyprint=True,</span>
<span class="gd">-        infer_numeric_types=False, named_key_ids=False,</span>
<span class="gd">-        edge_id_from_attribute=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        graph=None,</span>
<span class="gi">+        encoding=&quot;utf-8&quot;,</span>
<span class="gi">+        prettyprint=True,</span>
<span class="gi">+        infer_numeric_types=False,</span>
<span class="gi">+        named_key_ids=False,</span>
<span class="gi">+        edge_id_from_attribute=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.construct_types()
<span class="w"> </span>        from xml.etree.ElementTree import Element
<span class="gi">+</span>
<span class="w"> </span>        self.myElement = Element
<span class="gi">+</span>
<span class="w"> </span>        self.infer_numeric_types = infer_numeric_types
<span class="w"> </span>        self.prettyprint = prettyprint
<span class="w"> </span>        self.named_key_ids = named_key_ids
<span class="w"> </span>        self.edge_id_from_attribute = edge_id_from_attribute
<span class="w"> </span>        self.encoding = encoding
<span class="gd">-        self.xml = self.myElement(&#39;graphml&#39;, {&#39;xmlns&#39;: self.NS_GRAPHML,</span>
<span class="gd">-            &#39;xmlns:xsi&#39;: self.NS_XSI, &#39;xsi:schemaLocation&#39;: self.</span>
<span class="gd">-            SCHEMALOCATION})</span>
<span class="gi">+        self.xml = self.myElement(</span>
<span class="gi">+            &quot;graphml&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;xmlns&quot;: self.NS_GRAPHML,</span>
<span class="gi">+                &quot;xmlns:xsi&quot;: self.NS_XSI,</span>
<span class="gi">+                &quot;xsi:schemaLocation&quot;: self.SCHEMALOCATION,</span>
<span class="gi">+            },</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.keys = {}
<span class="w"> </span>        self.attributes = defaultdict(list)
<span class="w"> </span>        self.attribute_types = defaultdict(set)
<span class="gi">+</span>
<span class="w"> </span>        if graph is not None:
<span class="w"> </span>            self.add_graph_element(graph)

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        from xml.etree.ElementTree import tostring
<span class="gi">+</span>
<span class="w"> </span>        if self.prettyprint:
<span class="w"> </span>            self.indent(self.xml)
<span class="w"> </span>        s = tostring(self.xml).decode(self.encoding)
<span class="gu">@@ -351,30 +511,176 @@ class GraphMLWriter(GraphML):</span>
<span class="w"> </span>        means edges with data named &#39;weight&#39; are treated separately from nodes
<span class="w"> </span>        with data named &#39;weight&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_data(self, name, element_type, value, scope=&#39;all&#39;, default=None):</span>
<span class="gi">+        if self.infer_numeric_types:</span>
<span class="gi">+            types = self.attribute_types[(name, scope)]</span>
<span class="gi">+</span>
<span class="gi">+            if len(types) &gt; 1:</span>
<span class="gi">+                types = {self.get_xml_type(t) for t in types}</span>
<span class="gi">+                if &quot;string&quot; in types:</span>
<span class="gi">+                    return str</span>
<span class="gi">+                elif &quot;float&quot; in types or &quot;double&quot; in types:</span>
<span class="gi">+                    return float</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return int</span>
<span class="gi">+            else:</span>
<span class="gi">+                return list(types)[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return type(value)</span>
<span class="gi">+</span>
<span class="gi">+    def get_key(self, name, attr_type, scope, default):</span>
<span class="gi">+        keys_key = (name, attr_type, scope)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.keys[keys_key]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if self.named_key_ids:</span>
<span class="gi">+                new_id = name</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_id = f&quot;d{len(list(self.keys))}&quot;</span>
<span class="gi">+</span>
<span class="gi">+            self.keys[keys_key] = new_id</span>
<span class="gi">+            key_kwargs = {</span>
<span class="gi">+                &quot;id&quot;: new_id,</span>
<span class="gi">+                &quot;for&quot;: scope,</span>
<span class="gi">+                &quot;attr.name&quot;: name,</span>
<span class="gi">+                &quot;attr.type&quot;: attr_type,</span>
<span class="gi">+            }</span>
<span class="gi">+            key_element = self.myElement(&quot;key&quot;, **key_kwargs)</span>
<span class="gi">+            # add subelement for data default value if present</span>
<span class="gi">+            if default is not None:</span>
<span class="gi">+                default_element = self.myElement(&quot;default&quot;)</span>
<span class="gi">+                default_element.text = str(default)</span>
<span class="gi">+                key_element.append(default_element)</span>
<span class="gi">+            self.xml.insert(0, key_element)</span>
<span class="gi">+        return new_id</span>
<span class="gi">+</span>
<span class="gi">+    def add_data(self, name, element_type, value, scope=&quot;all&quot;, default=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Make a data element for an edge or a node. Keep a log of the
<span class="w"> </span>        type in the keys table.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if element_type not in self.xml_type:</span>
<span class="gi">+            raise nx.NetworkXError(</span>
<span class="gi">+                f&quot;GraphML writer does not support {element_type} as data values.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        keyid = self.get_key(name, self.get_xml_type(element_type), scope, default)</span>
<span class="gi">+        data_element = self.myElement(&quot;data&quot;, key=keyid)</span>
<span class="gi">+        data_element.text = str(value)</span>
<span class="gi">+        return data_element</span>

<span class="w"> </span>    def add_attributes(self, scope, xml_obj, data, default):
<span class="w"> </span>        &quot;&quot;&quot;Appends attribute data to edges or nodes, and stores type information
<span class="w"> </span>        to be added later. See add_graph_element.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for k, v in data.items():</span>
<span class="gi">+            self.attribute_types[(str(k), scope)].add(type(v))</span>
<span class="gi">+            self.attributes[xml_obj].append([k, v, scope, default.get(k)])</span>
<span class="gi">+</span>
<span class="gi">+    def add_nodes(self, G, graph_element):</span>
<span class="gi">+        default = G.graph.get(&quot;node_default&quot;, {})</span>
<span class="gi">+        for node, data in G.nodes(data=True):</span>
<span class="gi">+            node_element = self.myElement(&quot;node&quot;, id=str(node))</span>
<span class="gi">+            self.add_attributes(&quot;node&quot;, node_element, data, default)</span>
<span class="gi">+            graph_element.append(node_element)</span>
<span class="gi">+</span>
<span class="gi">+    def add_edges(self, G, graph_element):</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            for u, v, key, data in G.edges(data=True, keys=True):</span>
<span class="gi">+                edge_element = self.myElement(</span>
<span class="gi">+                    &quot;edge&quot;,</span>
<span class="gi">+                    source=str(u),</span>
<span class="gi">+                    target=str(v),</span>
<span class="gi">+                    id=str(data.get(self.edge_id_from_attribute))</span>
<span class="gi">+                    if self.edge_id_from_attribute</span>
<span class="gi">+                    and self.edge_id_from_attribute in data</span>
<span class="gi">+                    else str(key),</span>
<span class="gi">+                )</span>
<span class="gi">+                default = G.graph.get(&quot;edge_default&quot;, {})</span>
<span class="gi">+                self.add_attributes(&quot;edge&quot;, edge_element, data, default)</span>
<span class="gi">+                graph_element.append(edge_element)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for u, v, data in G.edges(data=True):</span>
<span class="gi">+                if self.edge_id_from_attribute and self.edge_id_from_attribute in data:</span>
<span class="gi">+                    # select attribute to be edge id</span>
<span class="gi">+                    edge_element = self.myElement(</span>
<span class="gi">+                        &quot;edge&quot;,</span>
<span class="gi">+                        source=str(u),</span>
<span class="gi">+                        target=str(v),</span>
<span class="gi">+                        id=str(data.get(self.edge_id_from_attribute)),</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # default: no edge id</span>
<span class="gi">+                    edge_element = self.myElement(&quot;edge&quot;, source=str(u), target=str(v))</span>
<span class="gi">+                default = G.graph.get(&quot;edge_default&quot;, {})</span>
<span class="gi">+                self.add_attributes(&quot;edge&quot;, edge_element, data, default)</span>
<span class="gi">+                graph_element.append(edge_element)</span>

<span class="w"> </span>    def add_graph_element(self, G):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Serialize graph G in GraphML to the stream.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            default_edge_type = &quot;directed&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            default_edge_type = &quot;undirected&quot;</span>
<span class="gi">+</span>
<span class="gi">+        graphid = G.graph.pop(&quot;id&quot;, None)</span>
<span class="gi">+        if graphid is None:</span>
<span class="gi">+            graph_element = self.myElement(&quot;graph&quot;, edgedefault=default_edge_type)</span>
<span class="gi">+        else:</span>
<span class="gi">+            graph_element = self.myElement(</span>
<span class="gi">+                &quot;graph&quot;, edgedefault=default_edge_type, id=graphid</span>
<span class="gi">+            )</span>
<span class="gi">+        default = {}</span>
<span class="gi">+        data = {</span>
<span class="gi">+            k: v</span>
<span class="gi">+            for (k, v) in G.graph.items()</span>
<span class="gi">+            if k not in [&quot;node_default&quot;, &quot;edge_default&quot;]</span>
<span class="gi">+        }</span>
<span class="gi">+        self.add_attributes(&quot;graph&quot;, graph_element, data, default)</span>
<span class="gi">+        self.add_nodes(G, graph_element)</span>
<span class="gi">+        self.add_edges(G, graph_element)</span>
<span class="gi">+</span>
<span class="gi">+        # self.attributes contains a mapping from XML Objects to a list of</span>
<span class="gi">+        # data that needs to be added to them.</span>
<span class="gi">+        # We postpone processing in order to do type inference/generalization.</span>
<span class="gi">+        # See self.attr_type</span>
<span class="gi">+        for xml_obj, data in self.attributes.items():</span>
<span class="gi">+            for k, v, scope, default in data:</span>
<span class="gi">+                xml_obj.append(</span>
<span class="gi">+                    self.add_data(</span>
<span class="gi">+                        str(k), self.attr_type(k, scope, v), str(v), scope, default</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+        self.xml.append(graph_element)</span>

<span class="w"> </span>    def add_graphs(self, graph_list):
<span class="w"> </span>        &quot;&quot;&quot;Add many graphs to this GraphML document.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for G in graph_list:</span>
<span class="gi">+            self.add_graph_element(G)</span>
<span class="gi">+</span>
<span class="gi">+    def dump(self, stream):</span>
<span class="gi">+        from xml.etree.ElementTree import ElementTree</span>
<span class="gi">+</span>
<span class="gi">+        if self.prettyprint:</span>
<span class="gi">+            self.indent(self.xml)</span>
<span class="gi">+        document = ElementTree(self.xml)</span>
<span class="gi">+        document.write(stream, encoding=self.encoding, xml_declaration=True)</span>
<span class="gi">+</span>
<span class="gi">+    def indent(self, elem, level=0):</span>
<span class="gi">+        # in-place prettyprint formatter</span>
<span class="gi">+        i = &quot;\n&quot; + level * &quot;  &quot;</span>
<span class="gi">+        if len(elem):</span>
<span class="gi">+            if not elem.text or not elem.text.strip():</span>
<span class="gi">+                elem.text = i + &quot;  &quot;</span>
<span class="gi">+            if not elem.tail or not elem.tail.strip():</span>
<span class="gi">+                elem.tail = i</span>
<span class="gi">+            for elem in elem:</span>
<span class="gi">+                self.indent(elem, level + 1)</span>
<span class="gi">+            if not elem.tail or not elem.tail.strip():</span>
<span class="gi">+                elem.tail = i</span>
<span class="gi">+        else:</span>
<span class="gi">+            if level and (not elem.tail or not elem.tail.strip()):</span>
<span class="gi">+                elem.tail = i</span>


<span class="w"> </span>class IncrementalElement:
<span class="gu">@@ -388,31 +694,54 @@ class IncrementalElement:</span>
<span class="w"> </span>        self.xml = xml
<span class="w"> </span>        self.prettyprint = prettyprint

<span class="gi">+    def append(self, element):</span>
<span class="gi">+        self.xml.write(element, pretty_print=self.prettyprint)</span>

<span class="gd">-class GraphMLWriterLxml(GraphMLWriter):</span>

<span class="gd">-    def __init__(self, path, graph=None, encoding=&#39;utf-8&#39;, prettyprint=True,</span>
<span class="gd">-        infer_numeric_types=False, named_key_ids=False,</span>
<span class="gd">-        edge_id_from_attribute=None):</span>
<span class="gi">+class GraphMLWriterLxml(GraphMLWriter):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        graph=None,</span>
<span class="gi">+        encoding=&quot;utf-8&quot;,</span>
<span class="gi">+        prettyprint=True,</span>
<span class="gi">+        infer_numeric_types=False,</span>
<span class="gi">+        named_key_ids=False,</span>
<span class="gi">+        edge_id_from_attribute=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.construct_types()
<span class="w"> </span>        import lxml.etree as lxmletree
<span class="gi">+</span>
<span class="w"> </span>        self.myElement = lxmletree.Element
<span class="gi">+</span>
<span class="w"> </span>        self._encoding = encoding
<span class="w"> </span>        self._prettyprint = prettyprint
<span class="w"> </span>        self.named_key_ids = named_key_ids
<span class="w"> </span>        self.edge_id_from_attribute = edge_id_from_attribute
<span class="w"> </span>        self.infer_numeric_types = infer_numeric_types
<span class="gi">+</span>
<span class="w"> </span>        self._xml_base = lxmletree.xmlfile(path, encoding=encoding)
<span class="w"> </span>        self._xml = self._xml_base.__enter__()
<span class="w"> </span>        self._xml.write_declaration()
<span class="gi">+</span>
<span class="gi">+        # We need to have a xml variable that support insertion. This call is</span>
<span class="gi">+        # used for adding the keys to the document.</span>
<span class="gi">+        # We will store those keys in a plain list, and then after the graph</span>
<span class="gi">+        # element is closed we will add them to the main graphml element.</span>
<span class="w"> </span>        self.xml = []
<span class="w"> </span>        self._keys = self.xml
<span class="gd">-        self._graphml = self._xml.element(&#39;graphml&#39;, {&#39;xmlns&#39;: self.</span>
<span class="gd">-            NS_GRAPHML, &#39;xmlns:xsi&#39;: self.NS_XSI, &#39;xsi:schemaLocation&#39;:</span>
<span class="gd">-            self.SCHEMALOCATION})</span>
<span class="gi">+        self._graphml = self._xml.element(</span>
<span class="gi">+            &quot;graphml&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;xmlns&quot;: self.NS_GRAPHML,</span>
<span class="gi">+                &quot;xmlns:xsi&quot;: self.NS_XSI,</span>
<span class="gi">+                &quot;xsi:schemaLocation&quot;: self.SCHEMALOCATION,</span>
<span class="gi">+            },</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._graphml.__enter__()
<span class="w"> </span>        self.keys = {}
<span class="w"> </span>        self.attribute_types = defaultdict(set)
<span class="gi">+</span>
<span class="w"> </span>        if graph is not None:
<span class="w"> </span>            self.add_graph_element(graph)

<span class="gu">@@ -420,54 +749,304 @@ class GraphMLWriterLxml(GraphMLWriter):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Serialize graph G in GraphML to the stream.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if G.is_directed():</span>
<span class="gi">+            default_edge_type = &quot;directed&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            default_edge_type = &quot;undirected&quot;</span>
<span class="gi">+</span>
<span class="gi">+        graphid = G.graph.pop(&quot;id&quot;, None)</span>
<span class="gi">+        if graphid is None:</span>
<span class="gi">+            graph_element = self._xml.element(&quot;graph&quot;, edgedefault=default_edge_type)</span>
<span class="gi">+        else:</span>
<span class="gi">+            graph_element = self._xml.element(</span>
<span class="gi">+                &quot;graph&quot;, edgedefault=default_edge_type, id=graphid</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # gather attributes types for the whole graph</span>
<span class="gi">+        # to find the most general numeric format needed.</span>
<span class="gi">+        # Then pass through attributes to create key_id for each.</span>
<span class="gi">+        graphdata = {</span>
<span class="gi">+            k: v</span>
<span class="gi">+            for k, v in G.graph.items()</span>
<span class="gi">+            if k not in (&quot;node_default&quot;, &quot;edge_default&quot;)</span>
<span class="gi">+        }</span>
<span class="gi">+        node_default = G.graph.get(&quot;node_default&quot;, {})</span>
<span class="gi">+        edge_default = G.graph.get(&quot;edge_default&quot;, {})</span>
<span class="gi">+        # Graph attributes</span>
<span class="gi">+        for k, v in graphdata.items():</span>
<span class="gi">+            self.attribute_types[(str(k), &quot;graph&quot;)].add(type(v))</span>
<span class="gi">+        for k, v in graphdata.items():</span>
<span class="gi">+            element_type = self.get_xml_type(self.attr_type(k, &quot;graph&quot;, v))</span>
<span class="gi">+            self.get_key(str(k), element_type, &quot;graph&quot;, None)</span>
<span class="gi">+        # Nodes and data</span>
<span class="gi">+        for node, d in G.nodes(data=True):</span>
<span class="gi">+            for k, v in d.items():</span>
<span class="gi">+                self.attribute_types[(str(k), &quot;node&quot;)].add(type(v))</span>
<span class="gi">+        for node, d in G.nodes(data=True):</span>
<span class="gi">+            for k, v in d.items():</span>
<span class="gi">+                T = self.get_xml_type(self.attr_type(k, &quot;node&quot;, v))</span>
<span class="gi">+                self.get_key(str(k), T, &quot;node&quot;, node_default.get(k))</span>
<span class="gi">+        # Edges and data</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            for u, v, ekey, d in G.edges(keys=True, data=True):</span>
<span class="gi">+                for k, v in d.items():</span>
<span class="gi">+                    self.attribute_types[(str(k), &quot;edge&quot;)].add(type(v))</span>
<span class="gi">+            for u, v, ekey, d in G.edges(keys=True, data=True):</span>
<span class="gi">+                for k, v in d.items():</span>
<span class="gi">+                    T = self.get_xml_type(self.attr_type(k, &quot;edge&quot;, v))</span>
<span class="gi">+                    self.get_key(str(k), T, &quot;edge&quot;, edge_default.get(k))</span>
<span class="gi">+        else:</span>
<span class="gi">+            for u, v, d in G.edges(data=True):</span>
<span class="gi">+                for k, v in d.items():</span>
<span class="gi">+                    self.attribute_types[(str(k), &quot;edge&quot;)].add(type(v))</span>
<span class="gi">+            for u, v, d in G.edges(data=True):</span>
<span class="gi">+                for k, v in d.items():</span>
<span class="gi">+                    T = self.get_xml_type(self.attr_type(k, &quot;edge&quot;, v))</span>
<span class="gi">+                    self.get_key(str(k), T, &quot;edge&quot;, edge_default.get(k))</span>
<span class="gi">+</span>
<span class="gi">+        # Now add attribute keys to the xml file</span>
<span class="gi">+        for key in self.xml:</span>
<span class="gi">+            self._xml.write(key, pretty_print=self._prettyprint)</span>
<span class="gi">+</span>
<span class="gi">+        # The incremental_writer writes each node/edge as it is created</span>
<span class="gi">+        incremental_writer = IncrementalElement(self._xml, self._prettyprint)</span>
<span class="gi">+        with graph_element:</span>
<span class="gi">+            self.add_attributes(&quot;graph&quot;, incremental_writer, graphdata, {})</span>
<span class="gi">+            self.add_nodes(G, incremental_writer)  # adds attributes too</span>
<span class="gi">+            self.add_edges(G, incremental_writer)  # adds attributes too</span>

<span class="w"> </span>    def add_attributes(self, scope, xml_obj, data, default):
<span class="w"> </span>        &quot;&quot;&quot;Appends attribute data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for k, v in data.items():</span>
<span class="gi">+            data_element = self.add_data(</span>
<span class="gi">+                str(k), self.attr_type(str(k), scope, v), str(v), scope, default.get(k)</span>
<span class="gi">+            )</span>
<span class="gi">+            xml_obj.append(data_element)</span>

<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return object.__str__(self)

<span class="gi">+    def dump(self, stream=None):</span>
<span class="gi">+        self._graphml.__exit__(None, None, None)</span>
<span class="gi">+        self._xml_base.__exit__(None, None, None)</span>

<span class="gi">+</span>
<span class="gi">+# default is lxml is present.</span>
<span class="w"> </span>write_graphml = write_graphml_lxml


<span class="w"> </span>class GraphMLReader(GraphML):
<span class="w"> </span>    &quot;&quot;&quot;Read a GraphML document.  Produces NetworkX graph objects.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, node_type=str, edge_key_type=int, force_multigraph=False</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init__(self, node_type=str, edge_key_type=int, force_multigraph=False):</span>
<span class="w"> </span>        self.construct_types()
<span class="w"> </span>        self.node_type = node_type
<span class="w"> </span>        self.edge_key_type = edge_key_type
<span class="gd">-        self.multigraph = force_multigraph</span>
<span class="gd">-        self.edge_ids = {}</span>
<span class="gi">+        self.multigraph = force_multigraph  # If False, test for multiedges</span>
<span class="gi">+        self.edge_ids = {}  # dict mapping (u,v) tuples to edge id attributes</span>

<span class="w"> </span>    def __call__(self, path=None, string=None):
<span class="w"> </span>        from xml.etree.ElementTree import ElementTree, fromstring
<span class="gi">+</span>
<span class="w"> </span>        if path is not None:
<span class="w"> </span>            self.xml = ElementTree(file=path)
<span class="w"> </span>        elif string is not None:
<span class="w"> </span>            self.xml = fromstring(string)
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError(&quot;Must specify either &#39;path&#39; or &#39;string&#39; as kwarg&quot;)
<span class="gd">-        keys, defaults = self.find_graphml_keys(self.xml)</span>
<span class="gd">-        for g in self.xml.findall(f&#39;{{{self.NS_GRAPHML}}}graph&#39;):</span>
<span class="gi">+        (keys, defaults) = self.find_graphml_keys(self.xml)</span>
<span class="gi">+        for g in self.xml.findall(f&quot;{{{self.NS_GRAPHML}}}graph&quot;):</span>
<span class="w"> </span>            yield self.make_graph(g, keys, defaults)

<span class="gi">+    def make_graph(self, graph_xml, graphml_keys, defaults, G=None):</span>
<span class="gi">+        # set default graph type</span>
<span class="gi">+        edgedefault = graph_xml.get(&quot;edgedefault&quot;, None)</span>
<span class="gi">+        if G is None:</span>
<span class="gi">+            if edgedefault == &quot;directed&quot;:</span>
<span class="gi">+                G = nx.MultiDiGraph()</span>
<span class="gi">+            else:</span>
<span class="gi">+                G = nx.MultiGraph()</span>
<span class="gi">+        # set defaults for graph attributes</span>
<span class="gi">+        G.graph[&quot;node_default&quot;] = {}</span>
<span class="gi">+        G.graph[&quot;edge_default&quot;] = {}</span>
<span class="gi">+        for key_id, value in defaults.items():</span>
<span class="gi">+            key_for = graphml_keys[key_id][&quot;for&quot;]</span>
<span class="gi">+            name = graphml_keys[key_id][&quot;name&quot;]</span>
<span class="gi">+            python_type = graphml_keys[key_id][&quot;type&quot;]</span>
<span class="gi">+            if key_for == &quot;node&quot;:</span>
<span class="gi">+                G.graph[&quot;node_default&quot;].update({name: python_type(value)})</span>
<span class="gi">+            if key_for == &quot;edge&quot;:</span>
<span class="gi">+                G.graph[&quot;edge_default&quot;].update({name: python_type(value)})</span>
<span class="gi">+        # hyperedges are not supported</span>
<span class="gi">+        hyperedge = graph_xml.find(f&quot;{{{self.NS_GRAPHML}}}hyperedge&quot;)</span>
<span class="gi">+        if hyperedge is not None:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;GraphML reader doesn&#39;t support hyperedges&quot;)</span>
<span class="gi">+        # add nodes</span>
<span class="gi">+        for node_xml in graph_xml.findall(f&quot;{{{self.NS_GRAPHML}}}node&quot;):</span>
<span class="gi">+            self.add_node(G, node_xml, graphml_keys, defaults)</span>
<span class="gi">+        # add edges</span>
<span class="gi">+        for edge_xml in graph_xml.findall(f&quot;{{{self.NS_GRAPHML}}}edge&quot;):</span>
<span class="gi">+            self.add_edge(G, edge_xml, graphml_keys)</span>
<span class="gi">+        # add graph data</span>
<span class="gi">+        data = self.decode_data_elements(graphml_keys, graph_xml)</span>
<span class="gi">+        G.graph.update(data)</span>
<span class="gi">+</span>
<span class="gi">+        # switch to Graph or DiGraph if no parallel edges were found</span>
<span class="gi">+        if self.multigraph:</span>
<span class="gi">+            return G</span>
<span class="gi">+</span>
<span class="gi">+        G = nx.DiGraph(G) if G.is_directed() else nx.Graph(G)</span>
<span class="gi">+        # add explicit edge &quot;id&quot; from file as attribute in NX graph.</span>
<span class="gi">+        nx.set_edge_attributes(G, values=self.edge_ids, name=&quot;id&quot;)</span>
<span class="gi">+        return G</span>
<span class="gi">+</span>
<span class="w"> </span>    def add_node(self, G, node_xml, graphml_keys, defaults):
<span class="w"> </span>        &quot;&quot;&quot;Add a node to the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # warn on finding unsupported ports tag</span>
<span class="gi">+        ports = node_xml.find(f&quot;{{{self.NS_GRAPHML}}}port&quot;)</span>
<span class="gi">+        if ports is not None:</span>
<span class="gi">+            warnings.warn(&quot;GraphML port tag not supported.&quot;)</span>
<span class="gi">+        # find the node by id and cast it to the appropriate type</span>
<span class="gi">+        node_id = self.node_type(node_xml.get(&quot;id&quot;))</span>
<span class="gi">+        # get data/attributes for node</span>
<span class="gi">+        data = self.decode_data_elements(graphml_keys, node_xml)</span>
<span class="gi">+        G.add_node(node_id, **data)</span>
<span class="gi">+        # get child nodes</span>
<span class="gi">+        if node_xml.attrib.get(&quot;yfiles.foldertype&quot;) == &quot;group&quot;:</span>
<span class="gi">+            graph_xml = node_xml.find(f&quot;{{{self.NS_GRAPHML}}}graph&quot;)</span>
<span class="gi">+            self.make_graph(graph_xml, graphml_keys, defaults, G)</span>

<span class="w"> </span>    def add_edge(self, G, edge_element, graphml_keys):
<span class="w"> </span>        &quot;&quot;&quot;Add an edge to the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # warn on finding unsupported ports tag</span>
<span class="gi">+        ports = edge_element.find(f&quot;{{{self.NS_GRAPHML}}}port&quot;)</span>
<span class="gi">+        if ports is not None:</span>
<span class="gi">+            warnings.warn(&quot;GraphML port tag not supported.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # raise error if we find mixed directed and undirected edges</span>
<span class="gi">+        directed = edge_element.get(&quot;directed&quot;)</span>
<span class="gi">+        if G.is_directed() and directed == &quot;false&quot;:</span>
<span class="gi">+            msg = &quot;directed=false edge found in directed graph.&quot;</span>
<span class="gi">+            raise nx.NetworkXError(msg)</span>
<span class="gi">+        if (not G.is_directed()) and directed == &quot;true&quot;:</span>
<span class="gi">+            msg = &quot;directed=true edge found in undirected graph.&quot;</span>
<span class="gi">+            raise nx.NetworkXError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        source = self.node_type(edge_element.get(&quot;source&quot;))</span>
<span class="gi">+        target = self.node_type(edge_element.get(&quot;target&quot;))</span>
<span class="gi">+        data = self.decode_data_elements(graphml_keys, edge_element)</span>
<span class="gi">+        # GraphML stores edge ids as an attribute</span>
<span class="gi">+        # NetworkX uses them as keys in multigraphs too if no key</span>
<span class="gi">+        # attribute is specified</span>
<span class="gi">+        edge_id = edge_element.get(&quot;id&quot;)</span>
<span class="gi">+        if edge_id:</span>
<span class="gi">+            # self.edge_ids is used by `make_graph` method for non-multigraphs</span>
<span class="gi">+            self.edge_ids[source, target] = edge_id</span>
<span class="gi">+            try:</span>
<span class="gi">+                edge_id = self.edge_key_type(edge_id)</span>
<span class="gi">+            except ValueError:  # Could not convert.</span>
<span class="gi">+                pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            edge_id = data.get(&quot;key&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if G.has_edge(source, target):</span>
<span class="gi">+            # mark this as a multigraph</span>
<span class="gi">+            self.multigraph = True</span>
<span class="gi">+</span>
<span class="gi">+        # Use add_edges_from to avoid error with add_edge when `&#39;key&#39; in data`</span>
<span class="gi">+        # Note there is only one edge here...</span>
<span class="gi">+        G.add_edges_from([(source, target, edge_id, data)])</span>

<span class="w"> </span>    def decode_data_elements(self, graphml_keys, obj_xml):
<span class="w"> </span>        &quot;&quot;&quot;Use the key information to decode the data XML if present.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        data = {}</span>
<span class="gi">+        for data_element in obj_xml.findall(f&quot;{{{self.NS_GRAPHML}}}data&quot;):</span>
<span class="gi">+            key = data_element.get(&quot;key&quot;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                data_name = graphml_keys[key][&quot;name&quot;]</span>
<span class="gi">+                data_type = graphml_keys[key][&quot;type&quot;]</span>
<span class="gi">+            except KeyError as err:</span>
<span class="gi">+                raise nx.NetworkXError(f&quot;Bad GraphML data: no key {key}&quot;) from err</span>
<span class="gi">+            text = data_element.text</span>
<span class="gi">+            # assume anything with subelements is a yfiles extension</span>
<span class="gi">+            if text is not None and len(list(data_element)) == 0:</span>
<span class="gi">+                if data_type == bool:</span>
<span class="gi">+                    # Ignore cases.</span>
<span class="gi">+                    # http://docs.oracle.com/javase/6/docs/api/java/lang/</span>
<span class="gi">+                    # Boolean.html#parseBoolean%28java.lang.String%29</span>
<span class="gi">+                    data[data_name] = self.convert_bool[text.lower()]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    data[data_name] = data_type(text)</span>
<span class="gi">+            elif len(list(data_element)) &gt; 0:</span>
<span class="gi">+                # Assume yfiles as subelements, try to extract node_label</span>
<span class="gi">+                node_label = None</span>
<span class="gi">+                # set GenericNode&#39;s configuration as shape type</span>
<span class="gi">+                gn = data_element.find(f&quot;{{{self.NS_Y}}}GenericNode&quot;)</span>
<span class="gi">+                if gn is not None:</span>
<span class="gi">+                    data[&quot;shape_type&quot;] = gn.get(&quot;configuration&quot;)</span>
<span class="gi">+                for node_type in [&quot;GenericNode&quot;, &quot;ShapeNode&quot;, &quot;SVGNode&quot;, &quot;ImageNode&quot;]:</span>
<span class="gi">+                    pref = f&quot;{{{self.NS_Y}}}{node_type}/{{{self.NS_Y}}}&quot;</span>
<span class="gi">+                    geometry = data_element.find(f&quot;{pref}Geometry&quot;)</span>
<span class="gi">+                    if geometry is not None:</span>
<span class="gi">+                        data[&quot;x&quot;] = geometry.get(&quot;x&quot;)</span>
<span class="gi">+                        data[&quot;y&quot;] = geometry.get(&quot;y&quot;)</span>
<span class="gi">+                    if node_label is None:</span>
<span class="gi">+                        node_label = data_element.find(f&quot;{pref}NodeLabel&quot;)</span>
<span class="gi">+                    shape = data_element.find(f&quot;{pref}Shape&quot;)</span>
<span class="gi">+                    if shape is not None:</span>
<span class="gi">+                        data[&quot;shape_type&quot;] = shape.get(&quot;type&quot;)</span>
<span class="gi">+                if node_label is not None:</span>
<span class="gi">+                    data[&quot;label&quot;] = node_label.text</span>
<span class="gi">+</span>
<span class="gi">+                # check all the different types of edges available in yEd.</span>
<span class="gi">+                for edge_type in [</span>
<span class="gi">+                    &quot;PolyLineEdge&quot;,</span>
<span class="gi">+                    &quot;SplineEdge&quot;,</span>
<span class="gi">+                    &quot;QuadCurveEdge&quot;,</span>
<span class="gi">+                    &quot;BezierEdge&quot;,</span>
<span class="gi">+                    &quot;ArcEdge&quot;,</span>
<span class="gi">+                ]:</span>
<span class="gi">+                    pref = f&quot;{{{self.NS_Y}}}{edge_type}/{{{self.NS_Y}}}&quot;</span>
<span class="gi">+                    edge_label = data_element.find(f&quot;{pref}EdgeLabel&quot;)</span>
<span class="gi">+                    if edge_label is not None:</span>
<span class="gi">+                        break</span>
<span class="gi">+                if edge_label is not None:</span>
<span class="gi">+                    data[&quot;label&quot;] = edge_label.text</span>
<span class="gi">+            elif text is None:</span>
<span class="gi">+                data[data_name] = &quot;&quot;</span>
<span class="gi">+        return data</span>

<span class="w"> </span>    def find_graphml_keys(self, graph_element):
<span class="w"> </span>        &quot;&quot;&quot;Extracts all the keys and key defaults from the xml.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        graphml_keys = {}</span>
<span class="gi">+        graphml_key_defaults = {}</span>
<span class="gi">+        for k in graph_element.findall(f&quot;{{{self.NS_GRAPHML}}}key&quot;):</span>
<span class="gi">+            attr_id = k.get(&quot;id&quot;)</span>
<span class="gi">+            attr_type = k.get(&quot;attr.type&quot;)</span>
<span class="gi">+            attr_name = k.get(&quot;attr.name&quot;)</span>
<span class="gi">+            yfiles_type = k.get(&quot;yfiles.type&quot;)</span>
<span class="gi">+            if yfiles_type is not None:</span>
<span class="gi">+                attr_name = yfiles_type</span>
<span class="gi">+                attr_type = &quot;yfiles&quot;</span>
<span class="gi">+            if attr_type is None:</span>
<span class="gi">+                attr_type = &quot;string&quot;</span>
<span class="gi">+                warnings.warn(f&quot;No key type for id {attr_id}. Using string&quot;)</span>
<span class="gi">+            if attr_name is None:</span>
<span class="gi">+                raise nx.NetworkXError(f&quot;Unknown key for id {attr_id}.&quot;)</span>
<span class="gi">+            graphml_keys[attr_id] = {</span>
<span class="gi">+                &quot;name&quot;: attr_name,</span>
<span class="gi">+                &quot;type&quot;: self.python_type[attr_type],</span>
<span class="gi">+                &quot;for&quot;: k.get(&quot;for&quot;),</span>
<span class="gi">+            }</span>
<span class="gi">+            # check for &quot;default&quot; sub-element of key element</span>
<span class="gi">+            default = k.find(f&quot;{{{self.NS_GRAPHML}}}default&quot;)</span>
<span class="gi">+            if default is not None:</span>
<span class="gi">+                # Handle default values identically to data element values</span>
<span class="gi">+                python_type = graphml_keys[attr_id][&quot;type&quot;]</span>
<span class="gi">+                if python_type == bool:</span>
<span class="gi">+                    graphml_key_defaults[attr_id] = self.convert_bool[</span>
<span class="gi">+                        default.text.lower()</span>
<span class="gi">+                    ]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    graphml_key_defaults[attr_id] = python_type(default.text)</span>
<span class="gi">+        return graphml_keys, graphml_key_defaults</span>
<span class="gh">diff --git a/networkx/readwrite/json_graph/adjacency.py b/networkx/readwrite/json_graph/adjacency.py</span>
<span class="gh">index fa9e1461a..3b0574756 100644</span>
<span class="gd">--- a/networkx/readwrite/json_graph/adjacency.py</span>
<span class="gi">+++ b/networkx/readwrite/json_graph/adjacency.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;adjacency_data&#39;, &#39;adjacency_graph&#39;]</span>
<span class="gd">-_attrs = {&#39;id&#39;: &#39;id&#39;, &#39;key&#39;: &#39;key&#39;}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;adjacency_data&quot;, &quot;adjacency_graph&quot;]</span>
<span class="gi">+</span>
<span class="gi">+_attrs = {&quot;id&quot;: &quot;id&quot;, &quot;key&quot;: &quot;key&quot;}</span>


<span class="w"> </span>def adjacency_data(G, attrs=_attrs):
<span class="gu">@@ -53,7 +55,30 @@ def adjacency_data(G, attrs=_attrs):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    adjacency_graph, node_link_data, tree_data
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    multigraph = G.is_multigraph()</span>
<span class="gi">+    id_ = attrs[&quot;id&quot;]</span>
<span class="gi">+    # Allow &#39;key&#39; to be omitted from attrs if the graph is not a multigraph.</span>
<span class="gi">+    key = None if not multigraph else attrs[&quot;key&quot;]</span>
<span class="gi">+    if id_ == key:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Attribute names are not unique.&quot;)</span>
<span class="gi">+    data = {}</span>
<span class="gi">+    data[&quot;directed&quot;] = G.is_directed()</span>
<span class="gi">+    data[&quot;multigraph&quot;] = multigraph</span>
<span class="gi">+    data[&quot;graph&quot;] = list(G.graph.items())</span>
<span class="gi">+    data[&quot;nodes&quot;] = []</span>
<span class="gi">+    data[&quot;adjacency&quot;] = []</span>
<span class="gi">+    for n, nbrdict in G.adjacency():</span>
<span class="gi">+        data[&quot;nodes&quot;].append({**G.nodes[n], id_: n})</span>
<span class="gi">+        adj = []</span>
<span class="gi">+        if multigraph:</span>
<span class="gi">+            for nbr, keys in nbrdict.items():</span>
<span class="gi">+                for k, d in keys.items():</span>
<span class="gi">+                    adj.append({**d, id_: nbr, key: k})</span>
<span class="gi">+        else:</span>
<span class="gi">+            for nbr, d in nbrdict.items():</span>
<span class="gi">+                adj.append({**d, id_: nbr})</span>
<span class="gi">+        data[&quot;adjacency&quot;].append(adj)</span>
<span class="gi">+    return data</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -97,4 +122,35 @@ def adjacency_graph(data, directed=False, multigraph=True, attrs=_attrs):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    adjacency_graph, node_link_data, tree_data
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    multigraph = data.get(&quot;multigraph&quot;, multigraph)</span>
<span class="gi">+    directed = data.get(&quot;directed&quot;, directed)</span>
<span class="gi">+    if multigraph:</span>
<span class="gi">+        graph = nx.MultiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        graph = nx.Graph()</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        graph = graph.to_directed()</span>
<span class="gi">+    id_ = attrs[&quot;id&quot;]</span>
<span class="gi">+    # Allow &#39;key&#39; to be omitted from attrs if the graph is not a multigraph.</span>
<span class="gi">+    key = None if not multigraph else attrs[&quot;key&quot;]</span>
<span class="gi">+    graph.graph = dict(data.get(&quot;graph&quot;, []))</span>
<span class="gi">+    mapping = []</span>
<span class="gi">+    for d in data[&quot;nodes&quot;]:</span>
<span class="gi">+        node_data = d.copy()</span>
<span class="gi">+        node = node_data.pop(id_)</span>
<span class="gi">+        mapping.append(node)</span>
<span class="gi">+        graph.add_node(node)</span>
<span class="gi">+        graph.nodes[node].update(node_data)</span>
<span class="gi">+    for i, d in enumerate(data[&quot;adjacency&quot;]):</span>
<span class="gi">+        source = mapping[i]</span>
<span class="gi">+        for tdata in d:</span>
<span class="gi">+            target_data = tdata.copy()</span>
<span class="gi">+            target = target_data.pop(id_)</span>
<span class="gi">+            if not multigraph:</span>
<span class="gi">+                graph.add_edge(source, target)</span>
<span class="gi">+                graph[source][target].update(target_data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ky = target_data.pop(key, None)</span>
<span class="gi">+                graph.add_edge(source, target, key=ky)</span>
<span class="gi">+                graph[source][target][ky].update(target_data)</span>
<span class="gi">+    return graph</span>
<span class="gh">diff --git a/networkx/readwrite/json_graph/cytoscape.py b/networkx/readwrite/json_graph/cytoscape.py</span>
<span class="gh">index fbb5b7437..2f3b2176a 100644</span>
<span class="gd">--- a/networkx/readwrite/json_graph/cytoscape.py</span>
<span class="gi">+++ b/networkx/readwrite/json_graph/cytoscape.py</span>
<span class="gu">@@ -1,8 +1,9 @@</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;cytoscape_data&#39;, &#39;cytoscape_graph&#39;]</span>

<span class="gi">+__all__ = [&quot;cytoscape_data&quot;, &quot;cytoscape_graph&quot;]</span>

<span class="gd">-def cytoscape_data(G, name=&#39;name&#39;, ident=&#39;id&#39;):</span>
<span class="gi">+</span>
<span class="gi">+def cytoscape_data(G, name=&quot;name&quot;, ident=&quot;id&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns data in Cytoscape JSON format (cyjs).

<span class="w"> </span>    Parameters
<span class="gu">@@ -46,11 +47,41 @@ def cytoscape_data(G, name=&#39;name&#39;, ident=&#39;id&#39;):</span>
<span class="w"> </span>       {&#39;data&#39;: {&#39;id&#39;: &#39;1&#39;, &#39;value&#39;: 1, &#39;name&#39;: &#39;1&#39;}}],
<span class="w"> </span>      &#39;edges&#39;: [{&#39;data&#39;: {&#39;source&#39;: 0, &#39;target&#39;: 1}}]}}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name == ident:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;name and ident must be different.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    jsondata = {&quot;data&quot;: list(G.graph.items())}</span>
<span class="gi">+    jsondata[&quot;directed&quot;] = G.is_directed()</span>
<span class="gi">+    jsondata[&quot;multigraph&quot;] = G.is_multigraph()</span>
<span class="gi">+    jsondata[&quot;elements&quot;] = {&quot;nodes&quot;: [], &quot;edges&quot;: []}</span>
<span class="gi">+    nodes = jsondata[&quot;elements&quot;][&quot;nodes&quot;]</span>
<span class="gi">+    edges = jsondata[&quot;elements&quot;][&quot;edges&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    for i, j in G.nodes.items():</span>
<span class="gi">+        n = {&quot;data&quot;: j.copy()}</span>
<span class="gi">+        n[&quot;data&quot;][&quot;id&quot;] = j.get(ident) or str(i)</span>
<span class="gi">+        n[&quot;data&quot;][&quot;value&quot;] = i</span>
<span class="gi">+        n[&quot;data&quot;][&quot;name&quot;] = j.get(name) or str(i)</span>
<span class="gi">+        nodes.append(n)</span>
<span class="gi">+</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        for e in G.edges(keys=True):</span>
<span class="gi">+            n = {&quot;data&quot;: G.adj[e[0]][e[1]][e[2]].copy()}</span>
<span class="gi">+            n[&quot;data&quot;][&quot;source&quot;] = e[0]</span>
<span class="gi">+            n[&quot;data&quot;][&quot;target&quot;] = e[1]</span>
<span class="gi">+            n[&quot;data&quot;][&quot;key&quot;] = e[2]</span>
<span class="gi">+            edges.append(n)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for e in G.edges():</span>
<span class="gi">+            n = {&quot;data&quot;: G.adj[e[0]][e[1]].copy()}</span>
<span class="gi">+            n[&quot;data&quot;][&quot;source&quot;] = e[0]</span>
<span class="gi">+            n[&quot;data&quot;][&quot;target&quot;] = e[1]</span>
<span class="gi">+            edges.append(n)</span>
<span class="gi">+    return jsondata</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def cytoscape_graph(data, name=&#39;name&#39;, ident=&#39;id&#39;):</span>
<span class="gi">+def cytoscape_graph(data, name=&quot;name&quot;, ident=&quot;id&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Create a NetworkX graph from a dictionary in cytoscape JSON format.

<span class="gu">@@ -109,4 +140,39 @@ def cytoscape_graph(data, name=&#39;name&#39;, ident=&#39;id&#39;):</span>
<span class="w"> </span>    &gt;&gt;&gt; G.edges(data=True)
<span class="w"> </span>    EdgeDataView([(0, 1, {&#39;source&#39;: 0, &#39;target&#39;: 1})])
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if name == ident:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;name and ident must be different.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    multigraph = data.get(&quot;multigraph&quot;)</span>
<span class="gi">+    directed = data.get(&quot;directed&quot;)</span>
<span class="gi">+    if multigraph:</span>
<span class="gi">+        graph = nx.MultiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        graph = nx.Graph()</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        graph = graph.to_directed()</span>
<span class="gi">+    graph.graph = dict(data.get(&quot;data&quot;))</span>
<span class="gi">+    for d in data[&quot;elements&quot;][&quot;nodes&quot;]:</span>
<span class="gi">+        node_data = d[&quot;data&quot;].copy()</span>
<span class="gi">+        node = d[&quot;data&quot;][&quot;value&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if d[&quot;data&quot;].get(name):</span>
<span class="gi">+            node_data[name] = d[&quot;data&quot;].get(name)</span>
<span class="gi">+        if d[&quot;data&quot;].get(ident):</span>
<span class="gi">+            node_data[ident] = d[&quot;data&quot;].get(ident)</span>
<span class="gi">+</span>
<span class="gi">+        graph.add_node(node)</span>
<span class="gi">+        graph.nodes[node].update(node_data)</span>
<span class="gi">+</span>
<span class="gi">+    for d in data[&quot;elements&quot;][&quot;edges&quot;]:</span>
<span class="gi">+        edge_data = d[&quot;data&quot;].copy()</span>
<span class="gi">+        sour = d[&quot;data&quot;][&quot;source&quot;]</span>
<span class="gi">+        targ = d[&quot;data&quot;][&quot;target&quot;]</span>
<span class="gi">+        if multigraph:</span>
<span class="gi">+            key = d[&quot;data&quot;].get(&quot;key&quot;, 0)</span>
<span class="gi">+            graph.add_edge(sour, targ, key=key)</span>
<span class="gi">+            graph.edges[sour, targ, key].update(edge_data)</span>
<span class="gi">+        else:</span>
<span class="gi">+            graph.add_edge(sour, targ)</span>
<span class="gi">+            graph.edges[sour, targ].update(edge_data)</span>
<span class="gi">+    return graph</span>
<span class="gh">diff --git a/networkx/readwrite/json_graph/node_link.py b/networkx/readwrite/json_graph/node_link.py</span>
<span class="gh">index a03c444ff..e29100f44 100644</span>
<span class="gd">--- a/networkx/readwrite/json_graph/node_link.py</span>
<span class="gi">+++ b/networkx/readwrite/json_graph/node_link.py</span>
<span class="gu">@@ -1,8 +1,17 @@</span>
<span class="w"> </span>from itertools import chain, count
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;node_link_data&#39;, &#39;node_link_graph&#39;]</span>
<span class="gd">-_attrs = {&#39;source&#39;: &#39;source&#39;, &#39;target&#39;: &#39;target&#39;, &#39;name&#39;: &#39;id&#39;, &#39;key&#39;:</span>
<span class="gd">-    &#39;key&#39;, &#39;link&#39;: &#39;links&#39;}</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;node_link_data&quot;, &quot;node_link_graph&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_attrs = {</span>
<span class="gi">+    &quot;source&quot;: &quot;source&quot;,</span>
<span class="gi">+    &quot;target&quot;: &quot;target&quot;,</span>
<span class="gi">+    &quot;name&quot;: &quot;id&quot;,</span>
<span class="gi">+    &quot;key&quot;: &quot;key&quot;,</span>
<span class="gi">+    &quot;link&quot;: &quot;links&quot;,</span>
<span class="gi">+}</span>


<span class="w"> </span>def _to_tuple(x):
<span class="gu">@@ -17,11 +26,20 @@ def _to_tuple(x):</span>
<span class="w"> </span>    &gt;&gt;&gt; _to_tuple([1, 2, [3, 4]])
<span class="w"> </span>    (1, 2, (3, 4))
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def node_link_data(G, *, source=&#39;source&#39;, target=&#39;target&#39;, name=&#39;id&#39;, key=</span>
<span class="gd">-    &#39;key&#39;, link=&#39;links&#39;):</span>
<span class="gi">+    if not isinstance(x, tuple | list):</span>
<span class="gi">+        return x</span>
<span class="gi">+    return tuple(map(_to_tuple, x))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def node_link_data(</span>
<span class="gi">+    G,</span>
<span class="gi">+    *,</span>
<span class="gi">+    source=&quot;source&quot;,</span>
<span class="gi">+    target=&quot;target&quot;,</span>
<span class="gi">+    name=&quot;id&quot;,</span>
<span class="gi">+    key=&quot;key&quot;,</span>
<span class="gi">+    link=&quot;links&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns data in node-link format that is suitable for JSON serialization
<span class="w"> </span>    and use in JavaScript documents.

<span class="gu">@@ -92,12 +110,40 @@ def node_link_data(G, *, source=&#39;source&#39;, target=&#39;target&#39;, name=&#39;id&#39;, key=</span>
<span class="w"> </span>    --------
<span class="w"> </span>    node_link_graph, adjacency_data, tree_data
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    multigraph = G.is_multigraph()</span>
<span class="gi">+</span>
<span class="gi">+    # Allow &#39;key&#39; to be omitted from attrs if the graph is not a multigraph.</span>
<span class="gi">+    key = None if not multigraph else key</span>
<span class="gi">+    if len({source, target, key}) &lt; 3:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;Attribute names are not unique.&quot;)</span>
<span class="gi">+    data = {</span>
<span class="gi">+        &quot;directed&quot;: G.is_directed(),</span>
<span class="gi">+        &quot;multigraph&quot;: multigraph,</span>
<span class="gi">+        &quot;graph&quot;: G.graph,</span>
<span class="gi">+        &quot;nodes&quot;: [{**G.nodes[n], name: n} for n in G],</span>
<span class="gi">+    }</span>
<span class="gi">+    if multigraph:</span>
<span class="gi">+        data[link] = [</span>
<span class="gi">+            {**d, source: u, target: v, key: k}</span>
<span class="gi">+            for u, v, k, d in G.edges(keys=True, data=True)</span>
<span class="gi">+        ]</span>
<span class="gi">+    else:</span>
<span class="gi">+        data[link] = [{**d, source: u, target: v} for u, v, d in G.edges(data=True)]</span>
<span class="gi">+    return data</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def node_link_graph(data, directed=False, multigraph=True, *, source=</span>
<span class="gd">-    &#39;source&#39;, target=&#39;target&#39;, name=&#39;id&#39;, key=&#39;key&#39;, link=&#39;links&#39;):</span>
<span class="gi">+def node_link_graph(</span>
<span class="gi">+    data,</span>
<span class="gi">+    directed=False,</span>
<span class="gi">+    multigraph=True,</span>
<span class="gi">+    *,</span>
<span class="gi">+    source=&quot;source&quot;,</span>
<span class="gi">+    target=&quot;target&quot;,</span>
<span class="gi">+    name=&quot;id&quot;,</span>
<span class="gi">+    key=&quot;key&quot;,</span>
<span class="gi">+    link=&quot;links&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns graph from node-link data format.
<span class="w"> </span>    Useful for de-serialization from JSON.

<span class="gu">@@ -164,4 +210,35 @@ def node_link_graph(data, directed=False, multigraph=True, *, source=</span>
<span class="w"> </span>    --------
<span class="w"> </span>    node_link_data, adjacency_data, tree_data
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    multigraph = data.get(&quot;multigraph&quot;, multigraph)</span>
<span class="gi">+    directed = data.get(&quot;directed&quot;, directed)</span>
<span class="gi">+    if multigraph:</span>
<span class="gi">+        graph = nx.MultiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        graph = nx.Graph()</span>
<span class="gi">+    if directed:</span>
<span class="gi">+        graph = graph.to_directed()</span>
<span class="gi">+</span>
<span class="gi">+    # Allow &#39;key&#39; to be omitted from attrs if the graph is not a multigraph.</span>
<span class="gi">+    key = None if not multigraph else key</span>
<span class="gi">+    graph.graph = data.get(&quot;graph&quot;, {})</span>
<span class="gi">+    c = count()</span>
<span class="gi">+    for d in data[&quot;nodes&quot;]:</span>
<span class="gi">+        node = _to_tuple(d.get(name, next(c)))</span>
<span class="gi">+        nodedata = {str(k): v for k, v in d.items() if k != name}</span>
<span class="gi">+        graph.add_node(node, **nodedata)</span>
<span class="gi">+    for d in data[link]:</span>
<span class="gi">+        src = tuple(d[source]) if isinstance(d[source], list) else d[source]</span>
<span class="gi">+        tgt = tuple(d[target]) if isinstance(d[target], list) else d[target]</span>
<span class="gi">+        if not multigraph:</span>
<span class="gi">+            edgedata = {str(k): v for k, v in d.items() if k != source and k != target}</span>
<span class="gi">+            graph.add_edge(src, tgt, **edgedata)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ky = d.get(key, None)</span>
<span class="gi">+            edgedata = {</span>
<span class="gi">+                str(k): v</span>
<span class="gi">+                for k, v in d.items()</span>
<span class="gi">+                if k != source and k != target and k != key</span>
<span class="gi">+            }</span>
<span class="gi">+            graph.add_edge(src, tgt, ky, **edgedata)</span>
<span class="gi">+    return graph</span>
<span class="gh">diff --git a/networkx/readwrite/json_graph/tree.py b/networkx/readwrite/json_graph/tree.py</span>
<span class="gh">index 97edd3f5b..22b07b09d 100644</span>
<span class="gd">--- a/networkx/readwrite/json_graph/tree.py</span>
<span class="gi">+++ b/networkx/readwrite/json_graph/tree.py</span>
<span class="gu">@@ -1,9 +1,11 @@</span>
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;tree_data&#39;, &#39;tree_graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;tree_data&quot;, &quot;tree_graph&quot;]</span>


<span class="gd">-def tree_data(G, root, ident=&#39;id&#39;, children=&#39;children&#39;):</span>
<span class="gi">+def tree_data(G, root, ident=&quot;id&quot;, children=&quot;children&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns data in tree format that is suitable for JSON serialization
<span class="w"> </span>    and use in JavaScript documents.

<span class="gu">@@ -55,11 +57,34 @@ def tree_data(G, root, ident=&#39;id&#39;, children=&#39;children&#39;):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    tree_graph, node_link_data, adjacency_data
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.number_of_nodes() != G.number_of_edges() + 1:</span>
<span class="gi">+        raise TypeError(&quot;G is not a tree.&quot;)</span>
<span class="gi">+    if not G.is_directed():</span>
<span class="gi">+        raise TypeError(&quot;G is not directed.&quot;)</span>
<span class="gi">+    if not nx.is_weakly_connected(G):</span>
<span class="gi">+        raise TypeError(&quot;G is not weakly connected.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if ident == children:</span>
<span class="gi">+        raise nx.NetworkXError(&quot;The values for `id` and `children` must be different.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def add_children(n, G):</span>
<span class="gi">+        nbrs = G[n]</span>
<span class="gi">+        if len(nbrs) == 0:</span>
<span class="gi">+            return []</span>
<span class="gi">+        children_ = []</span>
<span class="gi">+        for child in nbrs:</span>
<span class="gi">+            d = {**G.nodes[child], ident: child}</span>
<span class="gi">+            c = add_children(child, G)</span>
<span class="gi">+            if c:</span>
<span class="gi">+                d[children] = c</span>
<span class="gi">+            children_.append(d)</span>
<span class="gi">+        return children_</span>
<span class="gi">+</span>
<span class="gi">+    return {**G.nodes[root], ident: root, children: add_children(root, G)}</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def tree_graph(data, ident=&#39;id&#39;, children=&#39;children&#39;):</span>
<span class="gi">+def tree_graph(data, ident=&quot;id&quot;, children=&quot;children&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns graph from tree data format.

<span class="w"> </span>    Parameters
<span class="gu">@@ -90,4 +115,23 @@ def tree_graph(data, ident=&#39;id&#39;, children=&#39;children&#39;):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    tree_data, node_link_data, adjacency_data
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    graph = nx.DiGraph()</span>
<span class="gi">+</span>
<span class="gi">+    def add_children(parent, children_):</span>
<span class="gi">+        for data in children_:</span>
<span class="gi">+            child = data[ident]</span>
<span class="gi">+            graph.add_edge(parent, child)</span>
<span class="gi">+            grandchildren = data.get(children, [])</span>
<span class="gi">+            if grandchildren:</span>
<span class="gi">+                add_children(child, grandchildren)</span>
<span class="gi">+            nodedata = {</span>
<span class="gi">+                str(k): v for k, v in data.items() if k != ident and k != children</span>
<span class="gi">+            }</span>
<span class="gi">+            graph.add_node(child, **nodedata)</span>
<span class="gi">+</span>
<span class="gi">+    root = data[ident]</span>
<span class="gi">+    children_ = data.get(children, [])</span>
<span class="gi">+    nodedata = {str(k): v for k, v in data.items() if k != ident and k != children}</span>
<span class="gi">+    graph.add_node(root, **nodedata)</span>
<span class="gi">+    add_children(root, children_)</span>
<span class="gi">+    return graph</span>
<span class="gh">diff --git a/networkx/readwrite/leda.py b/networkx/readwrite/leda.py</span>
<span class="gh">index 260434ad9..9fb57db14 100644</span>
<span class="gd">--- a/networkx/readwrite/leda.py</span>
<span class="gi">+++ b/networkx/readwrite/leda.py</span>
<span class="gu">@@ -8,15 +8,19 @@ Format</span>
<span class="w"> </span>See http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html

<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;read_leda&#39;, &#39;parse_leda&#39;]</span>
<span class="gi">+# Original author: D. Eppstein, UC Irvine, August 12, 2003.</span>
<span class="gi">+# The original code at http://www.ics.uci.edu/~eppstein/PADS/ is public domain.</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;read_leda&quot;, &quot;parse_leda&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.utils import open_file


<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_leda(path, encoding=&#39;UTF-8&#39;):</span>
<span class="gi">+def read_leda(path, encoding=&quot;UTF-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read graph in LEDA format from path.

<span class="w"> </span>    Parameters
<span class="gu">@@ -37,7 +41,9 @@ def read_leda(path, encoding=&#39;UTF-8&#39;):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = (line.decode(encoding) for line in path)</span>
<span class="gi">+    G = parse_leda(lines)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -61,4 +67,42 @@ def parse_leda(lines):</span>
<span class="w"> </span>    ----------
<span class="w"> </span>    .. [1] http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(lines, str):</span>
<span class="gi">+        lines = iter(lines.split(&quot;\n&quot;))</span>
<span class="gi">+    lines = iter(</span>
<span class="gi">+        [</span>
<span class="gi">+            line.rstrip(&quot;\n&quot;)</span>
<span class="gi">+            for line in lines</span>
<span class="gi">+            if not (line.startswith((&quot;#&quot;, &quot;\n&quot;)) or line == &quot;&quot;)</span>
<span class="gi">+        ]</span>
<span class="gi">+    )</span>
<span class="gi">+    for i in range(3):</span>
<span class="gi">+        next(lines)</span>
<span class="gi">+    # Graph</span>
<span class="gi">+    du = int(next(lines))  # -1=directed, -2=undirected</span>
<span class="gi">+    if du == -1:</span>
<span class="gi">+        G = nx.DiGraph()</span>
<span class="gi">+    else:</span>
<span class="gi">+        G = nx.Graph()</span>
<span class="gi">+</span>
<span class="gi">+    # Nodes</span>
<span class="gi">+    n = int(next(lines))  # number of nodes</span>
<span class="gi">+    node = {}</span>
<span class="gi">+    for i in range(1, n + 1):  # LEDA counts from 1 to n</span>
<span class="gi">+        symbol = next(lines).rstrip().strip(&quot;|{}|  &quot;)</span>
<span class="gi">+        if symbol == &quot;&quot;:</span>
<span class="gi">+            symbol = str(i)  # use int if no label - could be trouble</span>
<span class="gi">+        node[i] = symbol</span>
<span class="gi">+</span>
<span class="gi">+    G.add_nodes_from([s for i, s in node.items()])</span>
<span class="gi">+</span>
<span class="gi">+    # Edges</span>
<span class="gi">+    m = int(next(lines))  # number of edges</span>
<span class="gi">+    for i in range(m):</span>
<span class="gi">+        try:</span>
<span class="gi">+            s, t, reversal, label = next(lines).split()</span>
<span class="gi">+        except BaseException as err:</span>
<span class="gi">+            raise NetworkXError(f&quot;Too few fields in LEDA.GRAPH edge {i+1}&quot;) from err</span>
<span class="gi">+        # BEWARE: no handling of reversal edges</span>
<span class="gi">+        G.add_edge(node[int(s)], node[int(t)], label=label[2:-2])</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/readwrite/multiline_adjlist.py b/networkx/readwrite/multiline_adjlist.py</span>
<span class="gh">index 97096a711..526b30a9b 100644</span>
<span class="gd">--- a/networkx/readwrite/multiline_adjlist.py</span>
<span class="gi">+++ b/networkx/readwrite/multiline_adjlist.py</span>
<span class="gu">@@ -24,13 +24,19 @@ adjacency list (anything following the # in a line is a comment)::</span>
<span class="w"> </span>     d 1
<span class="w"> </span>     e
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-__all__ = [&#39;generate_multiline_adjlist&#39;, &#39;write_multiline_adjlist&#39;,</span>
<span class="gd">-    &#39;parse_multiline_adjlist&#39;, &#39;read_multiline_adjlist&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;generate_multiline_adjlist&quot;,</span>
<span class="gi">+    &quot;write_multiline_adjlist&quot;,</span>
<span class="gi">+    &quot;parse_multiline_adjlist&quot;,</span>
<span class="gi">+    &quot;read_multiline_adjlist&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import open_file


<span class="gd">-def generate_multiline_adjlist(G, delimiter=&#39; &#39;):</span>
<span class="gi">+def generate_multiline_adjlist(G, delimiter=&quot; &quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a single line of the graph G in multiline adjacency list format.

<span class="w"> </span>    Parameters
<span class="gu">@@ -71,12 +77,64 @@ def generate_multiline_adjlist(G, delimiter=&#39; &#39;):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    write_multiline_adjlist, read_multiline_adjlist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gd">-def write_multiline_adjlist(G, path, delimiter=&#39; &#39;, comments=&#39;#&#39;, encoding=</span>
<span class="gd">-    &#39;utf-8&#39;):</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            for s, nbrs in G.adjacency():</span>
<span class="gi">+                nbr_edges = [</span>
<span class="gi">+                    (u, data)</span>
<span class="gi">+                    for u, datadict in nbrs.items()</span>
<span class="gi">+                    for key, data in datadict.items()</span>
<span class="gi">+                ]</span>
<span class="gi">+                deg = len(nbr_edges)</span>
<span class="gi">+                yield str(s) + delimiter + str(deg)</span>
<span class="gi">+                for u, d in nbr_edges:</span>
<span class="gi">+                    if d is None:</span>
<span class="gi">+                        yield str(u)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield str(u) + delimiter + str(d)</span>
<span class="gi">+        else:  # directed single edges</span>
<span class="gi">+            for s, nbrs in G.adjacency():</span>
<span class="gi">+                deg = len(nbrs)</span>
<span class="gi">+                yield str(s) + delimiter + str(deg)</span>
<span class="gi">+                for u, d in nbrs.items():</span>
<span class="gi">+                    if d is None:</span>
<span class="gi">+                        yield str(u)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield str(u) + delimiter + str(d)</span>
<span class="gi">+    else:  # undirected</span>
<span class="gi">+        if G.is_multigraph():</span>
<span class="gi">+            seen = set()  # helper dict used to avoid duplicate edges</span>
<span class="gi">+            for s, nbrs in G.adjacency():</span>
<span class="gi">+                nbr_edges = [</span>
<span class="gi">+                    (u, data)</span>
<span class="gi">+                    for u, datadict in nbrs.items()</span>
<span class="gi">+                    if u not in seen</span>
<span class="gi">+                    for key, data in datadict.items()</span>
<span class="gi">+                ]</span>
<span class="gi">+                deg = len(nbr_edges)</span>
<span class="gi">+                yield str(s) + delimiter + str(deg)</span>
<span class="gi">+                for u, d in nbr_edges:</span>
<span class="gi">+                    if d is None:</span>
<span class="gi">+                        yield str(u)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield str(u) + delimiter + str(d)</span>
<span class="gi">+                seen.add(s)</span>
<span class="gi">+        else:  # undirected single edges</span>
<span class="gi">+            seen = set()  # helper dict used to avoid duplicate edges</span>
<span class="gi">+            for s, nbrs in G.adjacency():</span>
<span class="gi">+                nbr_edges = [(u, d) for u, d in nbrs.items() if u not in seen]</span>
<span class="gi">+                deg = len(nbr_edges)</span>
<span class="gi">+                yield str(s) + delimiter + str(deg)</span>
<span class="gi">+                for u, d in nbr_edges:</span>
<span class="gi">+                    if d is None:</span>
<span class="gi">+                        yield str(u)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield str(u) + delimiter + str(d)</span>
<span class="gi">+                seen.add(s)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="gi">+def write_multiline_adjlist(G, path, delimiter=&quot; &quot;, comments=&quot;#&quot;, encoding=&quot;utf-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write the graph G in multiline adjacency list format to path

<span class="w"> </span>    Parameters
<span class="gu">@@ -115,12 +173,28 @@ def write_multiline_adjlist(G, path, delimiter=&#39; &#39;, comments=&#39;#&#39;, encoding=</span>
<span class="w"> </span>    --------
<span class="w"> </span>    read_multiline_adjlist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import sys</span>
<span class="gi">+    import time</span>
<span class="gi">+</span>
<span class="gi">+    pargs = comments + &quot; &quot;.join(sys.argv)</span>
<span class="gi">+    header = (</span>
<span class="gi">+        f&quot;{pargs}\n&quot;</span>
<span class="gi">+        + comments</span>
<span class="gi">+        + f&quot; GMT {time.asctime(time.gmtime())}\n&quot;</span>
<span class="gi">+        + comments</span>
<span class="gi">+        + f&quot; {G.name}\n&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    path.write(header.encode(encoding))</span>
<span class="gi">+</span>
<span class="gi">+    for multiline in generate_multiline_adjlist(G, delimiter):</span>
<span class="gi">+        multiline += &quot;\n&quot;</span>
<span class="gi">+        path.write(multiline.encode(encoding))</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def parse_multiline_adjlist(lines, comments=&#39;#&#39;, delimiter=None,</span>
<span class="gd">-    create_using=None, nodetype=None, edgetype=None):</span>
<span class="gi">+def parse_multiline_adjlist(</span>
<span class="gi">+    lines, comments=&quot;#&quot;, delimiter=None, create_using=None, nodetype=None, edgetype=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse lines of a multiline adjacency list representation of a graph.

<span class="w"> </span>    Parameters
<span class="gu">@@ -162,13 +236,81 @@ def parse_multiline_adjlist(lines, comments=&#39;#&#39;, delimiter=None,</span>
<span class="w"> </span>    [1, 2, 3, 5]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+    from ast import literal_eval</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.empty_graph(0, create_using)</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        p = line.find(comments)</span>
<span class="gi">+        if p &gt;= 0:</span>
<span class="gi">+            line = line[:p]</span>
<span class="gi">+        if not line:</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            (u, deg) = line.strip().split(delimiter)</span>
<span class="gi">+            deg = int(deg)</span>
<span class="gi">+        except BaseException as err:</span>
<span class="gi">+            raise TypeError(f&quot;Failed to read node and degree on line ({line})&quot;) from err</span>
<span class="gi">+        if nodetype is not None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                u = nodetype(u)</span>
<span class="gi">+            except BaseException as err:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;Failed to convert node ({u}) to type {nodetype}&quot;</span>
<span class="gi">+                ) from err</span>
<span class="gi">+        G.add_node(u)</span>
<span class="gi">+        for i in range(deg):</span>
<span class="gi">+            while True:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    line = next(lines)</span>
<span class="gi">+                except StopIteration as err:</span>
<span class="gi">+                    msg = f&quot;Failed to find neighbor for node ({u})&quot;</span>
<span class="gi">+                    raise TypeError(msg) from err</span>
<span class="gi">+                p = line.find(comments)</span>
<span class="gi">+                if p &gt;= 0:</span>
<span class="gi">+                    line = line[:p]</span>
<span class="gi">+                if line:</span>
<span class="gi">+                    break</span>
<span class="gi">+            vlist = line.strip().split(delimiter)</span>
<span class="gi">+            numb = len(vlist)</span>
<span class="gi">+            if numb &lt; 1:</span>
<span class="gi">+                continue  # isolated node</span>
<span class="gi">+            v = vlist.pop(0)</span>
<span class="gi">+            data = &quot;&quot;.join(vlist)</span>
<span class="gi">+            if nodetype is not None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    v = nodetype(v)</span>
<span class="gi">+                except BaseException as err:</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        f&quot;Failed to convert node ({v}) to type {nodetype}&quot;</span>
<span class="gi">+                    ) from err</span>
<span class="gi">+            if edgetype is not None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    edgedata = {&quot;weight&quot;: edgetype(data)}</span>
<span class="gi">+                except BaseException as err:</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        f&quot;Failed to convert edge data ({data}) to type {edgetype}&quot;</span>
<span class="gi">+                    ) from err</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:  # try to evaluate</span>
<span class="gi">+                    edgedata = literal_eval(data)</span>
<span class="gi">+                except:</span>
<span class="gi">+                    edgedata = {}</span>
<span class="gi">+            G.add_edge(u, v, **edgedata)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_multiline_adjlist(path, comments=&#39;#&#39;, delimiter=None, create_using</span>
<span class="gd">-    =None, nodetype=None, edgetype=None, encoding=&#39;utf-8&#39;):</span>
<span class="gi">+def read_multiline_adjlist(</span>
<span class="gi">+    path,</span>
<span class="gi">+    comments=&quot;#&quot;,</span>
<span class="gi">+    delimiter=None,</span>
<span class="gi">+    create_using=None,</span>
<span class="gi">+    nodetype=None,</span>
<span class="gi">+    edgetype=None,</span>
<span class="gi">+    encoding=&quot;utf-8&quot;,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read graph in multi-line adjacency list format from path.

<span class="w"> </span>    Parameters
<span class="gu">@@ -240,4 +382,12 @@ def read_multiline_adjlist(path, comments=&#39;#&#39;, delimiter=None, create_using</span>
<span class="w"> </span>    --------
<span class="w"> </span>    write_multiline_adjlist
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = (line.decode(encoding) for line in path)</span>
<span class="gi">+    return parse_multiline_adjlist(</span>
<span class="gi">+        lines,</span>
<span class="gi">+        comments=comments,</span>
<span class="gi">+        delimiter=delimiter,</span>
<span class="gi">+        create_using=create_using,</span>
<span class="gi">+        nodetype=nodetype,</span>
<span class="gi">+        edgetype=edgetype,</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/networkx/readwrite/p2g.py b/networkx/readwrite/p2g.py</span>
<span class="gh">index 6a11f184f..85f07ec84 100644</span>
<span class="gd">--- a/networkx/readwrite/p2g.py</span>
<span class="gi">+++ b/networkx/readwrite/p2g.py</span>
<span class="gu">@@ -35,8 +35,8 @@ import networkx as nx</span>
<span class="w"> </span>from networkx.utils import open_file


<span class="gd">-@open_file(1, mode=&#39;w&#39;)</span>
<span class="gd">-def write_p2g(G, path, encoding=&#39;utf-8&#39;):</span>
<span class="gi">+@open_file(1, mode=&quot;w&quot;)</span>
<span class="gi">+def write_p2g(G, path, encoding=&quot;utf-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write NetworkX graph in p2g format.

<span class="w"> </span>    Notes
<span class="gu">@@ -44,12 +44,21 @@ def write_p2g(G, path, encoding=&#39;utf-8&#39;):</span>
<span class="w"> </span>    This format is meant to be used with directed graphs with
<span class="w"> </span>    possible self loops.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(0, mode=&#39;r&#39;)</span>
<span class="gi">+    path.write((f&quot;{G.name}\n&quot;).encode(encoding))</span>
<span class="gi">+    path.write((f&quot;{G.order()} {G.size()}\n&quot;).encode(encoding))</span>
<span class="gi">+    nodes = list(G)</span>
<span class="gi">+    # make dictionary mapping nodes to integers</span>
<span class="gi">+    nodenumber = dict(zip(nodes, range(len(nodes))))</span>
<span class="gi">+    for n in nodes:</span>
<span class="gi">+        path.write((f&quot;{n}\n&quot;).encode(encoding))</span>
<span class="gi">+        for nbr in G.neighbors(n):</span>
<span class="gi">+            path.write((f&quot;{nodenumber[nbr]} &quot;).encode(encoding))</span>
<span class="gi">+        path.write(&quot;\n&quot;.encode(encoding))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(0, mode=&quot;r&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_p2g(path, encoding=&#39;utf-8&#39;):</span>
<span class="gi">+def read_p2g(path, encoding=&quot;utf-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read graph in p2g format from path.

<span class="w"> </span>    Returns
<span class="gu">@@ -61,7 +70,9 @@ def read_p2g(path, encoding=&#39;utf-8&#39;):</span>
<span class="w"> </span>    If you want a DiGraph (with no self loops allowed and no edge data)
<span class="w"> </span>    use D=nx.DiGraph(read_p2g(path))
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = (line.decode(encoding) for line in path)</span>
<span class="gi">+    G = parse_p2g(lines)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -72,4 +83,22 @@ def parse_p2g(lines):</span>
<span class="w"> </span>    -------
<span class="w"> </span>    MultiDiGraph
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    description = next(lines).strip()</span>
<span class="gi">+    # are multiedges (parallel edges) allowed?</span>
<span class="gi">+    G = nx.MultiDiGraph(name=description, selfloops=True)</span>
<span class="gi">+    nnodes, nedges = map(int, next(lines).split())</span>
<span class="gi">+    nodelabel = {}</span>
<span class="gi">+    nbrs = {}</span>
<span class="gi">+    # loop over the nodes keeping track of node labels and out neighbors</span>
<span class="gi">+    # defer adding edges until all node labels are known</span>
<span class="gi">+    for i in range(nnodes):</span>
<span class="gi">+        n = next(lines).strip()</span>
<span class="gi">+        nodelabel[i] = n</span>
<span class="gi">+        G.add_node(n)</span>
<span class="gi">+        nbrs[n] = map(int, next(lines).split())</span>
<span class="gi">+    # now we know all of the node labels so we can add the edges</span>
<span class="gi">+    # with the correct labels</span>
<span class="gi">+    for n in G:</span>
<span class="gi">+        for nbr in nbrs[n]:</span>
<span class="gi">+            G.add_edge(n, nodelabel[nbr])</span>
<span class="gi">+    return G</span>
<span class="gh">diff --git a/networkx/readwrite/pajek.py b/networkx/readwrite/pajek.py</span>
<span class="gh">index 59e1de9ac..f148f1620 100644</span>
<span class="gd">--- a/networkx/readwrite/pajek.py</span>
<span class="gi">+++ b/networkx/readwrite/pajek.py</span>
<span class="gu">@@ -13,10 +13,13 @@ See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm</span>
<span class="w"> </span>for format information.

<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import open_file
<span class="gd">-__all__ = [&#39;read_pajek&#39;, &#39;parse_pajek&#39;, &#39;generate_pajek&#39;, &#39;write_pajek&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;read_pajek&quot;, &quot;parse_pajek&quot;, &quot;generate_pajek&quot;, &quot;write_pajek&quot;]</span>


<span class="w"> </span>def generate_pajek(G):
<span class="gu">@@ -32,11 +35,69 @@ def generate_pajek(G):</span>
<span class="w"> </span>    See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm
<span class="w"> </span>    for format information.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if G.name == &quot;&quot;:</span>
<span class="gi">+        name = &quot;NetworkX&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        name = G.name</span>
<span class="gi">+    # Apparently many Pajek format readers can&#39;t process this line</span>
<span class="gi">+    # So we&#39;ll leave it out for now.</span>
<span class="gi">+    # yield &#39;*network %s&#39;%name</span>
<span class="gi">+</span>
<span class="gi">+    # write nodes with attributes</span>
<span class="gi">+    yield f&quot;*vertices {G.order()}&quot;</span>
<span class="gi">+    nodes = list(G)</span>
<span class="gi">+    # make dictionary mapping nodes to integers</span>
<span class="gi">+    nodenumber = dict(zip(nodes, range(1, len(nodes) + 1)))</span>
<span class="gi">+    for n in nodes:</span>
<span class="gi">+        # copy node attributes and pop mandatory attributes</span>
<span class="gi">+        # to avoid duplication.</span>
<span class="gi">+        na = G.nodes.get(n, {}).copy()</span>
<span class="gi">+        x = na.pop(&quot;x&quot;, 0.0)</span>
<span class="gi">+        y = na.pop(&quot;y&quot;, 0.0)</span>
<span class="gi">+        try:</span>
<span class="gi">+            id = int(na.pop(&quot;id&quot;, nodenumber[n]))</span>
<span class="gi">+        except ValueError as err:</span>
<span class="gi">+            err.args += (</span>
<span class="gi">+                (</span>
<span class="gi">+                    &quot;Pajek format requires &#39;id&#39; to be an int().&quot;</span>
<span class="gi">+                    &quot; Refer to the &#39;Relabeling nodes&#39; section.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+            raise</span>
<span class="gi">+        nodenumber[n] = id</span>
<span class="gi">+        shape = na.pop(&quot;shape&quot;, &quot;ellipse&quot;)</span>
<span class="gi">+        s = &quot; &quot;.join(map(make_qstr, (id, n, x, y, shape)))</span>
<span class="gi">+        # only optional attributes are left in na.</span>
<span class="gi">+        for k, v in na.items():</span>
<span class="gi">+            if isinstance(v, str) and v.strip() != &quot;&quot;:</span>
<span class="gi">+                s += f&quot; {make_qstr(k)} {make_qstr(v)}&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&quot;Node attribute {k} is not processed. {(&#39;Empty attribute&#39; if isinstance(v, str) else &#39;Non-string attribute&#39;)}.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        yield s</span>

<span class="gi">+    # write edges with attributes</span>
<span class="gi">+    if G.is_directed():</span>
<span class="gi">+        yield &quot;*arcs&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield &quot;*edges&quot;</span>
<span class="gi">+    for u, v, edgedata in G.edges(data=True):</span>
<span class="gi">+        d = edgedata.copy()</span>
<span class="gi">+        value = d.pop(&quot;weight&quot;, 1.0)  # use 1 as default edge value</span>
<span class="gi">+        s = &quot; &quot;.join(map(make_qstr, (nodenumber[u], nodenumber[v], value)))</span>
<span class="gi">+        for k, v in d.items():</span>
<span class="gi">+            if isinstance(v, str) and v.strip() != &quot;&quot;:</span>
<span class="gi">+                s += f&quot; {make_qstr(k)} {make_qstr(v)}&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&quot;Edge attribute {k} is not processed. {(&#39;Empty attribute&#39; if isinstance(v, str) else &#39;Non-string attribute&#39;)}.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        yield s</span>

<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gd">-def write_pajek(G, path, encoding=&#39;UTF-8&#39;):</span>
<span class="gi">+</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="gi">+def write_pajek(G, path, encoding=&quot;UTF-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Write graph in Pajek format to path.

<span class="w"> </span>    Parameters
<span class="gu">@@ -63,12 +124,14 @@ def write_pajek(G, path, encoding=&#39;UTF-8&#39;):</span>
<span class="w"> </span>    See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm
<span class="w"> </span>    for format information.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for line in generate_pajek(G):</span>
<span class="gi">+        line += &quot;\n&quot;</span>
<span class="gi">+        path.write(line.encode(encoding))</span>


<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gd">-def read_pajek(path, encoding=&#39;UTF-8&#39;):</span>
<span class="gi">+def read_pajek(path, encoding=&quot;UTF-8&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Read graph in Pajek format from path.

<span class="w"> </span>    Parameters
<span class="gu">@@ -96,7 +159,8 @@ def read_pajek(path, encoding=&#39;UTF-8&#39;):</span>
<span class="w"> </span>    See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm
<span class="w"> </span>    for format information.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = (line.decode(encoding) for line in path)</span>
<span class="gi">+    return parse_pajek(lines)</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -117,11 +181,106 @@ def parse_pajek(lines):</span>
<span class="w"> </span>    read_pajek

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import shlex</span>
<span class="gi">+</span>
<span class="gi">+    # multigraph=False</span>
<span class="gi">+    if isinstance(lines, str):</span>
<span class="gi">+        lines = iter(lines.split(&quot;\n&quot;))</span>
<span class="gi">+    lines = iter([line.rstrip(&quot;\n&quot;) for line in lines])</span>
<span class="gi">+    G = nx.MultiDiGraph()  # are multiedges allowed in Pajek? assume yes</span>
<span class="gi">+    labels = []  # in the order of the file, needed for matrix</span>
<span class="gi">+    while lines:</span>
<span class="gi">+        try:</span>
<span class="gi">+            l = next(lines)</span>
<span class="gi">+        except:  # EOF</span>
<span class="gi">+            break</span>
<span class="gi">+        if l.lower().startswith(&quot;*network&quot;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                label, name = l.split(None, 1)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                # Line was not of the form:  *network NAME</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                G.graph[&quot;name&quot;] = name</span>
<span class="gi">+        elif l.lower().startswith(&quot;*vertices&quot;):</span>
<span class="gi">+            nodelabels = {}</span>
<span class="gi">+            l, nnodes = l.split()</span>
<span class="gi">+            for i in range(int(nnodes)):</span>
<span class="gi">+                l = next(lines)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    splitline = [</span>
<span class="gi">+                        x.decode(&quot;utf-8&quot;) for x in shlex.split(str(l).encode(&quot;utf-8&quot;))</span>
<span class="gi">+                    ]</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    splitline = shlex.split(str(l))</span>
<span class="gi">+                id, label = splitline[0:2]</span>
<span class="gi">+                labels.append(label)</span>
<span class="gi">+                G.add_node(label)</span>
<span class="gi">+                nodelabels[id] = label</span>
<span class="gi">+                G.nodes[label][&quot;id&quot;] = id</span>
<span class="gi">+                try:</span>
<span class="gi">+                    x, y, shape = splitline[2:5]</span>
<span class="gi">+                    G.nodes[label].update(</span>
<span class="gi">+                        {&quot;x&quot;: float(x), &quot;y&quot;: float(y), &quot;shape&quot;: shape}</span>
<span class="gi">+                    )</span>
<span class="gi">+                except:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                extra_attr = zip(splitline[5::2], splitline[6::2])</span>
<span class="gi">+                G.nodes[label].update(extra_attr)</span>
<span class="gi">+        elif l.lower().startswith(&quot;*edges&quot;) or l.lower().startswith(&quot;*arcs&quot;):</span>
<span class="gi">+            if l.lower().startswith(&quot;*edge&quot;):</span>
<span class="gi">+                # switch from multidigraph to multigraph</span>
<span class="gi">+                G = nx.MultiGraph(G)</span>
<span class="gi">+            if l.lower().startswith(&quot;*arcs&quot;):</span>
<span class="gi">+                # switch to directed with multiple arcs for each existing edge</span>
<span class="gi">+                G = G.to_directed()</span>
<span class="gi">+            for l in lines:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    splitline = [</span>
<span class="gi">+                        x.decode(&quot;utf-8&quot;) for x in shlex.split(str(l).encode(&quot;utf-8&quot;))</span>
<span class="gi">+                    ]</span>
<span class="gi">+                except AttributeError:</span>
<span class="gi">+                    splitline = shlex.split(str(l))</span>
<span class="gi">+</span>
<span class="gi">+                if len(splitline) &lt; 2:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                ui, vi = splitline[0:2]</span>
<span class="gi">+                u = nodelabels.get(ui, ui)</span>
<span class="gi">+                v = nodelabels.get(vi, vi)</span>
<span class="gi">+                # parse the data attached to this edge and put in a dictionary</span>
<span class="gi">+                edge_data = {}</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # there should always be a single value on the edge?</span>
<span class="gi">+                    w = splitline[2:3]</span>
<span class="gi">+                    edge_data.update({&quot;weight&quot;: float(w[0])})</span>
<span class="gi">+                except:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                    # if there isn&#39;t, just assign a 1</span>
<span class="gi">+                #                    edge_data.update({&#39;value&#39;:1})</span>
<span class="gi">+                extra_attr = zip(splitline[3::2], splitline[4::2])</span>
<span class="gi">+                edge_data.update(extra_attr)</span>
<span class="gi">+                # if G.has_edge(u,v):</span>
<span class="gi">+                #     multigraph=True</span>
<span class="gi">+                G.add_edge(u, v, **edge_data)</span>
<span class="gi">+        elif l.lower().startswith(&quot;*matrix&quot;):</span>
<span class="gi">+            G = nx.DiGraph(G)</span>
<span class="gi">+            adj_list = (</span>
<span class="gi">+                (labels[row], labels[col], {&quot;weight&quot;: int(data)})</span>
<span class="gi">+                for (row, line) in enumerate(lines)</span>
<span class="gi">+                for (col, data) in enumerate(line.split())</span>
<span class="gi">+                if int(data) != 0</span>
<span class="gi">+            )</span>
<span class="gi">+            G.add_edges_from(adj_list)</span>
<span class="gi">+</span>
<span class="gi">+    return G</span>


<span class="w"> </span>def make_qstr(t):
<span class="w"> </span>    &quot;&quot;&quot;Returns the string representation of t.
<span class="w"> </span>    Add outer double-quotes if the string has a space.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(t, str):</span>
<span class="gi">+        t = str(t)</span>
<span class="gi">+    if &quot; &quot; in t:</span>
<span class="gi">+        t = f&#39;&quot;{t}&quot;&#39;</span>
<span class="gi">+    return t</span>
<span class="gh">diff --git a/networkx/readwrite/sparse6.py b/networkx/readwrite/sparse6.py</span>
<span class="gh">index 2030070f6..a70599438 100644</span>
<span class="gd">--- a/networkx/readwrite/sparse6.py</span>
<span class="gi">+++ b/networkx/readwrite/sparse6.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+# Original author: D. Eppstein, UC Irvine, August 12, 2003.</span>
<span class="gi">+# The original code at https://www.ics.uci.edu/~eppstein/PADS/ is public domain.</span>
<span class="w"> </span>&quot;&quot;&quot;Functions for reading and writing graphs in the *sparse6* format.

<span class="w"> </span>The *sparse6* file format is a space-efficient format for large sparse
<span class="gu">@@ -13,8 +15,8 @@ import networkx as nx</span>
<span class="w"> </span>from networkx.exception import NetworkXError
<span class="w"> </span>from networkx.readwrite.graph6 import data_to_n, n_to_data
<span class="w"> </span>from networkx.utils import not_implemented_for, open_file
<span class="gd">-__all__ = [&#39;from_sparse6_bytes&#39;, &#39;read_sparse6&#39;, &#39;to_sparse6_bytes&#39;,</span>
<span class="gd">-    &#39;write_sparse6&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;from_sparse6_bytes&quot;, &quot;read_sparse6&quot;, &quot;to_sparse6_bytes&quot;, &quot;write_sparse6&quot;]</span>


<span class="w"> </span>def _generate_sparse6_bytes(G, nodes, header):
<span class="gu">@@ -38,7 +40,65 @@ def _generate_sparse6_bytes(G, nodes, header):</span>
<span class="w"> </span>    the graph6 format (that is, greater than ``2 ** 36`` nodes).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    n = len(G)</span>
<span class="gi">+    if n &gt;= 2**36:</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;sparse6 is only defined if number of nodes is less than 2 ** 36&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+    if header:</span>
<span class="gi">+        yield b&quot;&gt;&gt;sparse6&lt;&lt;&quot;</span>
<span class="gi">+    yield b&quot;:&quot;</span>
<span class="gi">+    for d in n_to_data(n):</span>
<span class="gi">+        yield str.encode(chr(d + 63))</span>
<span class="gi">+</span>
<span class="gi">+    k = 1</span>
<span class="gi">+    while 1 &lt;&lt; k &lt; n:</span>
<span class="gi">+        k += 1</span>
<span class="gi">+</span>
<span class="gi">+    def enc(x):</span>
<span class="gi">+        &quot;&quot;&quot;Big endian k-bit encoding of x&quot;&quot;&quot;</span>
<span class="gi">+        return [1 if (x &amp; 1 &lt;&lt; (k - 1 - i)) else 0 for i in range(k)]</span>
<span class="gi">+</span>
<span class="gi">+    edges = sorted((max(u, v), min(u, v)) for u, v in G.edges())</span>
<span class="gi">+    bits = []</span>
<span class="gi">+    curv = 0</span>
<span class="gi">+    for v, u in edges:</span>
<span class="gi">+        if v == curv:  # current vertex edge</span>
<span class="gi">+            bits.append(0)</span>
<span class="gi">+            bits.extend(enc(u))</span>
<span class="gi">+        elif v == curv + 1:  # next vertex edge</span>
<span class="gi">+            curv += 1</span>
<span class="gi">+            bits.append(1)</span>
<span class="gi">+            bits.extend(enc(u))</span>
<span class="gi">+        else:  # skip to vertex v and then add edge to u</span>
<span class="gi">+            curv = v</span>
<span class="gi">+            bits.append(1)</span>
<span class="gi">+            bits.extend(enc(v))</span>
<span class="gi">+            bits.append(0)</span>
<span class="gi">+            bits.extend(enc(u))</span>
<span class="gi">+    if k &lt; 6 and n == (1 &lt;&lt; k) and ((-len(bits)) % 6) &gt;= k and curv &lt; (n - 1):</span>
<span class="gi">+        # Padding special case: small k, n=2^k,</span>
<span class="gi">+        # more than k bits of padding needed,</span>
<span class="gi">+        # current vertex is not (n-1) --</span>
<span class="gi">+        # appending 1111... would add a loop on (n-1)</span>
<span class="gi">+        bits.append(0)</span>
<span class="gi">+        bits.extend([1] * ((-len(bits)) % 6))</span>
<span class="gi">+    else:</span>
<span class="gi">+        bits.extend([1] * ((-len(bits)) % 6))</span>
<span class="gi">+</span>
<span class="gi">+    data = [</span>
<span class="gi">+        (bits[i + 0] &lt;&lt; 5)</span>
<span class="gi">+        + (bits[i + 1] &lt;&lt; 4)</span>
<span class="gi">+        + (bits[i + 2] &lt;&lt; 3)</span>
<span class="gi">+        + (bits[i + 3] &lt;&lt; 2)</span>
<span class="gi">+        + (bits[i + 4] &lt;&lt; 1)</span>
<span class="gi">+        + (bits[i + 5] &lt;&lt; 0)</span>
<span class="gi">+        for i in range(0, len(bits), 6)</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    for d in data:</span>
<span class="gi">+        yield str.encode(chr(d + 63))</span>
<span class="gi">+    yield b&quot;\n&quot;</span>


<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="gu">@@ -75,7 +135,68 @@ def from_sparse6_bytes(string):</span>
<span class="w"> </span>           &lt;https://users.cecs.anu.edu.au/~bdm/data/formats.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if string.startswith(b&quot;&gt;&gt;sparse6&lt;&lt;&quot;):</span>
<span class="gi">+        string = string[11:]</span>
<span class="gi">+    if not string.startswith(b&quot;:&quot;):</span>
<span class="gi">+        raise NetworkXError(&quot;Expected leading colon in sparse6&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    chars = [c - 63 for c in string[1:]]</span>
<span class="gi">+    n, data = data_to_n(chars)</span>
<span class="gi">+    k = 1</span>
<span class="gi">+    while 1 &lt;&lt; k &lt; n:</span>
<span class="gi">+        k += 1</span>
<span class="gi">+</span>
<span class="gi">+    def parseData():</span>
<span class="gi">+        &quot;&quot;&quot;Returns stream of pairs b[i], x[i] for sparse6 format.&quot;&quot;&quot;</span>
<span class="gi">+        chunks = iter(data)</span>
<span class="gi">+        d = None  # partial data word</span>
<span class="gi">+        dLen = 0  # how many unparsed bits are left in d</span>
<span class="gi">+</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            if dLen &lt; 1:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    d = next(chunks)</span>
<span class="gi">+                except StopIteration:</span>
<span class="gi">+                    return</span>
<span class="gi">+                dLen = 6</span>
<span class="gi">+            dLen -= 1</span>
<span class="gi">+            b = (d &gt;&gt; dLen) &amp; 1  # grab top remaining bit</span>
<span class="gi">+</span>
<span class="gi">+            x = d &amp; ((1 &lt;&lt; dLen) - 1)  # partially built up value of x</span>
<span class="gi">+            xLen = dLen  # how many bits included so far in x</span>
<span class="gi">+            while xLen &lt; k:  # now grab full chunks until we have enough</span>
<span class="gi">+                try:</span>
<span class="gi">+                    d = next(chunks)</span>
<span class="gi">+                except StopIteration:</span>
<span class="gi">+                    return</span>
<span class="gi">+                dLen = 6</span>
<span class="gi">+                x = (x &lt;&lt; 6) + d</span>
<span class="gi">+                xLen += 6</span>
<span class="gi">+            x = x &gt;&gt; (xLen - k)  # shift back the extra bits</span>
<span class="gi">+            dLen = xLen - k</span>
<span class="gi">+            yield b, x</span>
<span class="gi">+</span>
<span class="gi">+    v = 0</span>
<span class="gi">+</span>
<span class="gi">+    G = nx.MultiGraph()</span>
<span class="gi">+    G.add_nodes_from(range(n))</span>
<span class="gi">+</span>
<span class="gi">+    multigraph = False</span>
<span class="gi">+    for b, x in parseData():</span>
<span class="gi">+        if b == 1:</span>
<span class="gi">+            v += 1</span>
<span class="gi">+        # padding with ones can cause overlarge number here</span>
<span class="gi">+        if x &gt;= n or v &gt;= n:</span>
<span class="gi">+            break</span>
<span class="gi">+        elif x &gt; v:</span>
<span class="gi">+            v = x</span>
<span class="gi">+        else:</span>
<span class="gi">+            if G.has_edge(x, v):</span>
<span class="gi">+                multigraph = True</span>
<span class="gi">+            G.add_edge(x, v)</span>
<span class="gi">+    if not multigraph:</span>
<span class="gi">+        G = nx.Graph(G)</span>
<span class="gi">+    return G</span>


<span class="w"> </span>def to_sparse6_bytes(G, nodes=None, header=True):
<span class="gu">@@ -122,10 +243,13 @@ def to_sparse6_bytes(G, nodes=None, header=True):</span>
<span class="w"> </span>           &lt;https://users.cecs.anu.edu.au/~bdm/data/formats.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes is not None:</span>
<span class="gi">+        G = G.subgraph(nodes)</span>
<span class="gi">+    G = nx.convert_node_labels_to_integers(G, ordering=&quot;sorted&quot;)</span>
<span class="gi">+    return b&quot;&quot;.join(_generate_sparse6_bytes(G, nodes, header))</span>


<span class="gd">-@open_file(0, mode=&#39;rb&#39;)</span>
<span class="gi">+@open_file(0, mode=&quot;rb&quot;)</span>
<span class="w"> </span>@nx._dispatchable(graphs=None, returns_graph=True)
<span class="w"> </span>def read_sparse6(path):
<span class="w"> </span>    &quot;&quot;&quot;Read an undirected graph in sparse6 format from path.
<span class="gu">@@ -177,11 +301,20 @@ def read_sparse6(path):</span>
<span class="w"> </span>           &lt;https://users.cecs.anu.edu.au/~bdm/data/formats.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@not_implemented_for(&#39;directed&#39;)</span>
<span class="gd">-@open_file(1, mode=&#39;wb&#39;)</span>
<span class="gi">+    glist = []</span>
<span class="gi">+    for line in path:</span>
<span class="gi">+        line = line.strip()</span>
<span class="gi">+        if not len(line):</span>
<span class="gi">+            continue</span>
<span class="gi">+        glist.append(from_sparse6_bytes(line))</span>
<span class="gi">+    if len(glist) == 1:</span>
<span class="gi">+        return glist[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return glist</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@not_implemented_for(&quot;directed&quot;)</span>
<span class="gi">+@open_file(1, mode=&quot;wb&quot;)</span>
<span class="w"> </span>def write_sparse6(G, path, nodes=None, header=True):
<span class="w"> </span>    &quot;&quot;&quot;Write graph G to given path in sparse6 format.

<span class="gu">@@ -236,4 +369,8 @@ def write_sparse6(G, path, nodes=None, header=True):</span>
<span class="w"> </span>           &lt;https://users.cecs.anu.edu.au/~bdm/data/formats.html&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if nodes is not None:</span>
<span class="gi">+        G = G.subgraph(nodes)</span>
<span class="gi">+    G = nx.convert_node_labels_to_integers(G, ordering=&quot;sorted&quot;)</span>
<span class="gi">+    for b in _generate_sparse6_bytes(G, nodes, header):</span>
<span class="gi">+        path.write(b)</span>
<span class="gh">diff --git a/networkx/readwrite/text.py b/networkx/readwrite/text.py</span>
<span class="gh">index af38a5513..dc182f598 100644</span>
<span class="gd">--- a/networkx/readwrite/text.py</span>
<span class="gi">+++ b/networkx/readwrite/text.py</span>
<span class="gu">@@ -4,63 +4,80 @@ Text-based visual representations of graphs</span>
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from collections import defaultdict
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import open_file
<span class="gd">-__all__ = [&#39;forest_str&#39;, &#39;generate_network_text&#39;, &#39;write_network_text&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;forest_str&quot;, &quot;generate_network_text&quot;, &quot;write_network_text&quot;]</span>


<span class="w"> </span>class BaseGlyphs:
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def as_dict(cls):</span>
<span class="gi">+        return {</span>
<span class="gi">+            a: getattr(cls, a)</span>
<span class="gi">+            for a in dir(cls)</span>
<span class="gi">+            if not a.startswith(&quot;_&quot;) and a != &quot;as_dict&quot;</span>
<span class="gi">+        }</span>


<span class="w"> </span>class AsciiBaseGlyphs(BaseGlyphs):
<span class="gd">-    empty: str = &#39;+&#39;</span>
<span class="gd">-    newtree_last: str = &#39;+-- &#39;</span>
<span class="gd">-    newtree_mid: str = &#39;+-- &#39;</span>
<span class="gd">-    endof_forest: str = &#39;    &#39;</span>
<span class="gd">-    within_forest: str = &#39;:   &#39;</span>
<span class="gd">-    within_tree: str = &#39;|   &#39;</span>
<span class="gi">+    empty: str = &quot;+&quot;</span>
<span class="gi">+    newtree_last: str = &quot;+-- &quot;</span>
<span class="gi">+    newtree_mid: str = &quot;+-- &quot;</span>
<span class="gi">+    endof_forest: str = &quot;    &quot;</span>
<span class="gi">+    within_forest: str = &quot;:   &quot;</span>
<span class="gi">+    within_tree: str = &quot;|   &quot;</span>


<span class="w"> </span>class AsciiDirectedGlyphs(AsciiBaseGlyphs):
<span class="gd">-    last: str = &#39;L-&gt; &#39;</span>
<span class="gd">-    mid: str = &#39;|-&gt; &#39;</span>
<span class="gd">-    backedge: str = &#39;&lt;-&#39;</span>
<span class="gd">-    vertical_edge: str = &#39;!&#39;</span>
<span class="gi">+    last: str = &quot;L-&gt; &quot;</span>
<span class="gi">+    mid: str = &quot;|-&gt; &quot;</span>
<span class="gi">+    backedge: str = &quot;&lt;-&quot;</span>
<span class="gi">+    vertical_edge: str = &quot;!&quot;</span>


<span class="w"> </span>class AsciiUndirectedGlyphs(AsciiBaseGlyphs):
<span class="gd">-    last: str = &#39;L-- &#39;</span>
<span class="gd">-    mid: str = &#39;|-- &#39;</span>
<span class="gd">-    backedge: str = &#39;-&#39;</span>
<span class="gd">-    vertical_edge: str = &#39;|&#39;</span>
<span class="gi">+    last: str = &quot;L-- &quot;</span>
<span class="gi">+    mid: str = &quot;|-- &quot;</span>
<span class="gi">+    backedge: str = &quot;-&quot;</span>
<span class="gi">+    vertical_edge: str = &quot;|&quot;</span>


<span class="w"> </span>class UtfBaseGlyphs(BaseGlyphs):
<span class="gd">-    empty: str = &#39;╙&#39;</span>
<span class="gd">-    newtree_last: str = &#39;╙── &#39;</span>
<span class="gd">-    newtree_mid: str = &#39;╟── &#39;</span>
<span class="gd">-    endof_forest: str = &#39;    &#39;</span>
<span class="gd">-    within_forest: str = &#39;╎   &#39;</span>
<span class="gd">-    within_tree: str = &#39;│   &#39;</span>
<span class="gi">+    # Notes on available box and arrow characters</span>
<span class="gi">+    # https://en.wikipedia.org/wiki/Box-drawing_character</span>
<span class="gi">+    # https://stackoverflow.com/questions/2701192/triangle-arrow</span>
<span class="gi">+    empty: str = &quot;╙&quot;</span>
<span class="gi">+    newtree_last: str = &quot;╙── &quot;</span>
<span class="gi">+    newtree_mid: str = &quot;╟── &quot;</span>
<span class="gi">+    endof_forest: str = &quot;    &quot;</span>
<span class="gi">+    within_forest: str = &quot;╎   &quot;</span>
<span class="gi">+    within_tree: str = &quot;│   &quot;</span>


<span class="w"> </span>class UtfDirectedGlyphs(UtfBaseGlyphs):
<span class="gd">-    last: str = &#39;└─╼ &#39;</span>
<span class="gd">-    mid: str = &#39;├─╼ &#39;</span>
<span class="gd">-    backedge: str = &#39;╾&#39;</span>
<span class="gd">-    vertical_edge: str = &#39;╽&#39;</span>
<span class="gi">+    last: str = &quot;└─╼ &quot;</span>
<span class="gi">+    mid: str = &quot;├─╼ &quot;</span>
<span class="gi">+    backedge: str = &quot;╾&quot;</span>
<span class="gi">+    vertical_edge: str = &quot;╽&quot;</span>


<span class="w"> </span>class UtfUndirectedGlyphs(UtfBaseGlyphs):
<span class="gd">-    last: str = &#39;└── &#39;</span>
<span class="gd">-    mid: str = &#39;├── &#39;</span>
<span class="gd">-    backedge: str = &#39;─&#39;</span>
<span class="gd">-    vertical_edge: str = &#39;│&#39;</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def generate_network_text(graph, with_labels=True, sources=None, max_depth=</span>
<span class="gd">-    None, ascii_only=False, vertical_chains=False):</span>
<span class="gi">+    last: str = &quot;└── &quot;</span>
<span class="gi">+    mid: str = &quot;├── &quot;</span>
<span class="gi">+    backedge: str = &quot;─&quot;</span>
<span class="gi">+    vertical_edge: str = &quot;│&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generate_network_text(</span>
<span class="gi">+    graph,</span>
<span class="gi">+    with_labels=True,</span>
<span class="gi">+    sources=None,</span>
<span class="gi">+    max_depth=None,</span>
<span class="gi">+    ascii_only=False,</span>
<span class="gi">+    vertical_chains=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate lines in the &quot;network text&quot; format

<span class="w"> </span>    This works via a depth-first traversal of the graph and writing a line for
<span class="gu">@@ -194,12 +211,225 @@ def generate_network_text(graph, with_labels=True, sources=None, max_depth=</span>
<span class="w"> </span>            ├── E
<span class="w"> </span>            └── F
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-@open_file(1, &#39;w&#39;)</span>
<span class="gd">-def write_network_text(graph, path=None, with_labels=True, sources=None,</span>
<span class="gd">-    max_depth=None, ascii_only=False, end=&#39;\n&#39;, vertical_chains=False):</span>
<span class="gi">+    from typing import Any, NamedTuple</span>
<span class="gi">+</span>
<span class="gi">+    class StackFrame(NamedTuple):</span>
<span class="gi">+        parent: Any</span>
<span class="gi">+        node: Any</span>
<span class="gi">+        indents: list</span>
<span class="gi">+        this_islast: bool</span>
<span class="gi">+        this_vertical: bool</span>
<span class="gi">+</span>
<span class="gi">+    collapse_attr = &quot;collapse&quot;</span>
<span class="gi">+</span>
<span class="gi">+    is_directed = graph.is_directed()</span>
<span class="gi">+</span>
<span class="gi">+    if is_directed:</span>
<span class="gi">+        glyphs = AsciiDirectedGlyphs if ascii_only else UtfDirectedGlyphs</span>
<span class="gi">+        succ = graph.succ</span>
<span class="gi">+        pred = graph.pred</span>
<span class="gi">+    else:</span>
<span class="gi">+        glyphs = AsciiUndirectedGlyphs if ascii_only else UtfUndirectedGlyphs</span>
<span class="gi">+        succ = graph.adj</span>
<span class="gi">+        pred = graph.adj</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(with_labels, str):</span>
<span class="gi">+        label_attr = with_labels</span>
<span class="gi">+    elif with_labels:</span>
<span class="gi">+        label_attr = &quot;label&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        label_attr = None</span>
<span class="gi">+</span>
<span class="gi">+    if max_depth == 0:</span>
<span class="gi">+        yield glyphs.empty + &quot; ...&quot;</span>
<span class="gi">+    elif len(graph.nodes) == 0:</span>
<span class="gi">+        yield glyphs.empty</span>
<span class="gi">+    else:</span>
<span class="gi">+        # If the nodes to traverse are unspecified, find the minimal set of</span>
<span class="gi">+        # nodes that will reach the entire graph</span>
<span class="gi">+        if sources is None:</span>
<span class="gi">+            sources = _find_sources(graph)</span>
<span class="gi">+</span>
<span class="gi">+        # Populate the stack with each:</span>
<span class="gi">+        # 1. parent node in the DFS tree (or None for root nodes),</span>
<span class="gi">+        # 2. the current node in the DFS tree</span>
<span class="gi">+        # 2. a list of indentations indicating depth</span>
<span class="gi">+        # 3. a flag indicating if the node is the final one to be written.</span>
<span class="gi">+        # Reverse the stack so sources are popped in the correct order.</span>
<span class="gi">+        last_idx = len(sources) - 1</span>
<span class="gi">+        stack = [</span>
<span class="gi">+            StackFrame(None, node, [], (idx == last_idx), False)</span>
<span class="gi">+            for idx, node in enumerate(sources)</span>
<span class="gi">+        ][::-1]</span>
<span class="gi">+</span>
<span class="gi">+        num_skipped_children = defaultdict(lambda: 0)</span>
<span class="gi">+        seen_nodes = set()</span>
<span class="gi">+        while stack:</span>
<span class="gi">+            parent, node, indents, this_islast, this_vertical = stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+            if node is not Ellipsis:</span>
<span class="gi">+                skip = node in seen_nodes</span>
<span class="gi">+                if skip:</span>
<span class="gi">+                    # Mark that we skipped a parent&#39;s child</span>
<span class="gi">+                    num_skipped_children[parent] += 1</span>
<span class="gi">+</span>
<span class="gi">+                if this_islast:</span>
<span class="gi">+                    # If we reached the last child of a parent, and we skipped</span>
<span class="gi">+                    # any of that parents children, then we should emit an</span>
<span class="gi">+                    # ellipsis at the end after this.</span>
<span class="gi">+                    if num_skipped_children[parent] and parent is not None:</span>
<span class="gi">+                        # Append the ellipsis to be emitted last</span>
<span class="gi">+                        next_islast = True</span>
<span class="gi">+                        try_frame = StackFrame(</span>
<span class="gi">+                            node, Ellipsis, indents, next_islast, False</span>
<span class="gi">+                        )</span>
<span class="gi">+                        stack.append(try_frame)</span>
<span class="gi">+</span>
<span class="gi">+                        # Redo this frame, but not as a last object</span>
<span class="gi">+                        next_islast = False</span>
<span class="gi">+                        try_frame = StackFrame(</span>
<span class="gi">+                            parent, node, indents, next_islast, this_vertical</span>
<span class="gi">+                        )</span>
<span class="gi">+                        stack.append(try_frame)</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                if skip:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                seen_nodes.add(node)</span>
<span class="gi">+</span>
<span class="gi">+            if not indents:</span>
<span class="gi">+                # Top level items (i.e. trees in the forest) get different</span>
<span class="gi">+                # glyphs to indicate they are not actually connected</span>
<span class="gi">+                if this_islast:</span>
<span class="gi">+                    this_vertical = False</span>
<span class="gi">+                    this_prefix = indents + [glyphs.newtree_last]</span>
<span class="gi">+                    next_prefix = indents + [glyphs.endof_forest]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    this_prefix = indents + [glyphs.newtree_mid]</span>
<span class="gi">+                    next_prefix = indents + [glyphs.within_forest]</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Non-top-level items</span>
<span class="gi">+                if this_vertical:</span>
<span class="gi">+                    this_prefix = indents</span>
<span class="gi">+                    next_prefix = indents</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if this_islast:</span>
<span class="gi">+                        this_prefix = indents + [glyphs.last]</span>
<span class="gi">+                        next_prefix = indents + [glyphs.endof_forest]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        this_prefix = indents + [glyphs.mid]</span>
<span class="gi">+                        next_prefix = indents + [glyphs.within_tree]</span>
<span class="gi">+</span>
<span class="gi">+            if node is Ellipsis:</span>
<span class="gi">+                label = &quot; ...&quot;</span>
<span class="gi">+                suffix = &quot;&quot;</span>
<span class="gi">+                children = []</span>
<span class="gi">+            else:</span>
<span class="gi">+                if label_attr is not None:</span>
<span class="gi">+                    label = str(graph.nodes[node].get(label_attr, node))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    label = str(node)</span>
<span class="gi">+</span>
<span class="gi">+                # Determine if we want to show the children of this node.</span>
<span class="gi">+                if collapse_attr is not None:</span>
<span class="gi">+                    collapse = graph.nodes[node].get(collapse_attr, False)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    collapse = False</span>
<span class="gi">+</span>
<span class="gi">+                # Determine:</span>
<span class="gi">+                # (1) children to traverse into after showing this node.</span>
<span class="gi">+                # (2) parents to immediately show to the right of this node.</span>
<span class="gi">+                if is_directed:</span>
<span class="gi">+                    # In the directed case we must show every successor node</span>
<span class="gi">+                    # note: it may be skipped later, but we don&#39;t have that</span>
<span class="gi">+                    # information here.</span>
<span class="gi">+                    children = list(succ[node])</span>
<span class="gi">+                    # In the directed case we must show every predecessor</span>
<span class="gi">+                    # except for parent we directly traversed from.</span>
<span class="gi">+                    handled_parents = {parent}</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Showing only the unseen children results in a more</span>
<span class="gi">+                    # concise representation for the undirected case.</span>
<span class="gi">+                    children = [</span>
<span class="gi">+                        child for child in succ[node] if child not in seen_nodes</span>
<span class="gi">+                    ]</span>
<span class="gi">+</span>
<span class="gi">+                    # In the undirected case, parents are also children, so we</span>
<span class="gi">+                    # only need to immediately show the ones we can no longer</span>
<span class="gi">+                    # traverse</span>
<span class="gi">+                    handled_parents = {*children, parent}</span>
<span class="gi">+</span>
<span class="gi">+                if max_depth is not None and len(indents) == max_depth - 1:</span>
<span class="gi">+                    # Use ellipsis to indicate we have reached maximum depth</span>
<span class="gi">+                    if children:</span>
<span class="gi">+                        children = [Ellipsis]</span>
<span class="gi">+                    handled_parents = {parent}</span>
<span class="gi">+</span>
<span class="gi">+                if collapse:</span>
<span class="gi">+                    # Collapsing a node is the same as reaching maximum depth</span>
<span class="gi">+                    if children:</span>
<span class="gi">+                        children = [Ellipsis]</span>
<span class="gi">+                    handled_parents = {parent}</span>
<span class="gi">+</span>
<span class="gi">+                # The other parents are other predecessors of this node that</span>
<span class="gi">+                # are not handled elsewhere.</span>
<span class="gi">+                other_parents = [p for p in pred[node] if p not in handled_parents]</span>
<span class="gi">+                if other_parents:</span>
<span class="gi">+                    if label_attr is not None:</span>
<span class="gi">+                        other_parents_labels = &quot;, &quot;.join(</span>
<span class="gi">+                            [</span>
<span class="gi">+                                str(graph.nodes[p].get(label_attr, p))</span>
<span class="gi">+                                for p in other_parents</span>
<span class="gi">+                            ]</span>
<span class="gi">+                        )</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        other_parents_labels = &quot;, &quot;.join(</span>
<span class="gi">+                            [str(p) for p in other_parents]</span>
<span class="gi">+                        )</span>
<span class="gi">+                    suffix = &quot; &quot;.join([&quot;&quot;, glyphs.backedge, other_parents_labels])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    suffix = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+            # Emit the line for this node, this will be called for each node</span>
<span class="gi">+            # exactly once.</span>
<span class="gi">+            if this_vertical:</span>
<span class="gi">+                yield &quot;&quot;.join(this_prefix + [glyphs.vertical_edge])</span>
<span class="gi">+</span>
<span class="gi">+            yield &quot;&quot;.join(this_prefix + [label, suffix])</span>
<span class="gi">+</span>
<span class="gi">+            if vertical_chains:</span>
<span class="gi">+                if is_directed:</span>
<span class="gi">+                    num_children = len(set(children))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    num_children = len(set(children) - {parent})</span>
<span class="gi">+                # The next node can be drawn vertically if it is the only</span>
<span class="gi">+                # remaining child of this node.</span>
<span class="gi">+                next_is_vertical = num_children == 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                next_is_vertical = False</span>
<span class="gi">+</span>
<span class="gi">+            # Push children on the stack in reverse order so they are popped in</span>
<span class="gi">+            # the original order.</span>
<span class="gi">+            for idx, child in enumerate(children[::-1]):</span>
<span class="gi">+                next_islast = idx == 0</span>
<span class="gi">+                try_frame = StackFrame(</span>
<span class="gi">+                    node, child, next_prefix, next_islast, next_is_vertical</span>
<span class="gi">+                )</span>
<span class="gi">+                stack.append(try_frame)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@open_file(1, &quot;w&quot;)</span>
<span class="gi">+def write_network_text(</span>
<span class="gi">+    graph,</span>
<span class="gi">+    path=None,</span>
<span class="gi">+    with_labels=True,</span>
<span class="gi">+    sources=None,</span>
<span class="gi">+    max_depth=None,</span>
<span class="gi">+    ascii_only=False,</span>
<span class="gi">+    end=&quot;\n&quot;,</span>
<span class="gi">+    vertical_chains=False,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Creates a nice text representation of a graph

<span class="w"> </span>    This works via a depth-first traversal of the graph and writing a line for
<span class="gu">@@ -354,18 +584,67 @@ def write_network_text(graph, path=None, with_labels=True, sources=None,</span>
<span class="w"> </span>        │   └─╼  ...
<span class="w"> </span>        └─╼  ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if path is None:</span>
<span class="gi">+        # The path is unspecified, write to stdout</span>
<span class="gi">+        _write = sys.stdout.write</span>
<span class="gi">+    elif hasattr(path, &quot;write&quot;):</span>
<span class="gi">+        # The path is already an open file</span>
<span class="gi">+        _write = path.write</span>
<span class="gi">+    elif callable(path):</span>
<span class="gi">+        # The path is a custom callable</span>
<span class="gi">+        _write = path</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(type(path))</span>
<span class="gi">+</span>
<span class="gi">+    for line in generate_network_text(</span>
<span class="gi">+        graph,</span>
<span class="gi">+        with_labels=with_labels,</span>
<span class="gi">+        sources=sources,</span>
<span class="gi">+        max_depth=max_depth,</span>
<span class="gi">+        ascii_only=ascii_only,</span>
<span class="gi">+        vertical_chains=vertical_chains,</span>
<span class="gi">+    ):</span>
<span class="gi">+        _write(line + end)</span>


<span class="w"> </span>def _find_sources(graph):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Determine a minimal set of nodes such that the entire graph is reachable
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def forest_str(graph, with_labels=True, sources=None, write=None,</span>
<span class="gd">-    ascii_only=False):</span>
<span class="gi">+    # For each connected part of the graph, choose at least</span>
<span class="gi">+    # one node as a starting point, preferably without a parent</span>
<span class="gi">+    if graph.is_directed():</span>
<span class="gi">+        # Choose one node from each SCC with minimum in_degree</span>
<span class="gi">+        sccs = list(nx.strongly_connected_components(graph))</span>
<span class="gi">+        # condensing the SCCs forms a dag, the nodes in this graph with</span>
<span class="gi">+        # 0 in-degree correspond to the SCCs from which the minimum set</span>
<span class="gi">+        # of nodes from which all other nodes can be reached.</span>
<span class="gi">+        scc_graph = nx.condensation(graph, sccs)</span>
<span class="gi">+        supernode_to_nodes = {sn: [] for sn in scc_graph.nodes()}</span>
<span class="gi">+        # Note: the order of mapping differs between pypy and cpython</span>
<span class="gi">+        # so we have to loop over graph nodes for consistency</span>
<span class="gi">+        mapping = scc_graph.graph[&quot;mapping&quot;]</span>
<span class="gi">+        for n in graph.nodes:</span>
<span class="gi">+            sn = mapping[n]</span>
<span class="gi">+            supernode_to_nodes[sn].append(n)</span>
<span class="gi">+        sources = []</span>
<span class="gi">+        for sn in scc_graph.nodes():</span>
<span class="gi">+            if scc_graph.in_degree[sn] == 0:</span>
<span class="gi">+                scc = supernode_to_nodes[sn]</span>
<span class="gi">+                node = min(scc, key=lambda n: graph.in_degree[n])</span>
<span class="gi">+                sources.append(node)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # For undirected graph, the entire graph will be reachable as</span>
<span class="gi">+        # long as we consider one node from every connected component</span>
<span class="gi">+        sources = [</span>
<span class="gi">+            min(cc, key=lambda n: graph.degree[n])</span>
<span class="gi">+            for cc in nx.connected_components(graph)</span>
<span class="gi">+        ]</span>
<span class="gi">+        sources = sorted(sources, key=lambda n: graph.degree[n])</span>
<span class="gi">+    return sources</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def forest_str(graph, with_labels=True, sources=None, write=None, ascii_only=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;Creates a nice utf8 representation of a forest

<span class="w"> </span>    This function has been superseded by
<span class="gu">@@ -433,7 +712,35 @@ def forest_str(graph, with_labels=True, sources=None, write=None,</span>
<span class="w"> </span>        L-- 1
<span class="w"> </span>            L-- 2
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    msg = (</span>
<span class="gi">+        &quot;\nforest_str is deprecated as of version 3.1 and will be removed &quot;</span>
<span class="gi">+        &quot;in version 3.3. Use generate_network_text or write_network_text &quot;</span>
<span class="gi">+        &quot;instead.\n&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    warnings.warn(msg, DeprecationWarning)</span>
<span class="gi">+</span>
<span class="gi">+    if len(graph.nodes) &gt; 0:</span>
<span class="gi">+        if not nx.is_forest(graph):</span>
<span class="gi">+            raise nx.NetworkXNotImplemented(&quot;input must be a forest or the empty graph&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    printbuf = []</span>
<span class="gi">+    if write is None:</span>
<span class="gi">+        _write = printbuf.append</span>
<span class="gi">+    else:</span>
<span class="gi">+        _write = write</span>
<span class="gi">+</span>
<span class="gi">+    write_network_text(</span>
<span class="gi">+        graph,</span>
<span class="gi">+        _write,</span>
<span class="gi">+        with_labels=with_labels,</span>
<span class="gi">+        sources=sources,</span>
<span class="gi">+        ascii_only=ascii_only,</span>
<span class="gi">+        end=&quot;&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if write is None:</span>
<span class="gi">+        # Only return a string if the custom write function was not specified</span>
<span class="gi">+        return &quot;\n&quot;.join(printbuf)</span>


<span class="w"> </span>def _parse_network_text(lines):
<span class="gu">@@ -455,4 +762,189 @@ def _parse_network_text(lines):</span>
<span class="w"> </span>    G: NetworkX graph
<span class="w"> </span>        The graph corresponding to the lines in network text format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from itertools import chain</span>
<span class="gi">+    from typing import Any, NamedTuple, Union</span>
<span class="gi">+</span>
<span class="gi">+    class ParseStackFrame(NamedTuple):</span>
<span class="gi">+        node: Any</span>
<span class="gi">+        indent: int</span>
<span class="gi">+        has_vertical_child: int | None</span>
<span class="gi">+</span>
<span class="gi">+    initial_line_iter = iter(lines)</span>
<span class="gi">+</span>
<span class="gi">+    is_ascii = None</span>
<span class="gi">+    is_directed = None</span>
<span class="gi">+</span>
<span class="gi">+    ##############</span>
<span class="gi">+    # Initial Pass</span>
<span class="gi">+    ##############</span>
<span class="gi">+</span>
<span class="gi">+    # Do an initial pass over the lines to determine what type of graph it is.</span>
<span class="gi">+    # Remember what these lines were, so we can reiterate over them in the</span>
<span class="gi">+    # parsing pass.</span>
<span class="gi">+    initial_lines = []</span>
<span class="gi">+    try:</span>
<span class="gi">+        first_line = next(initial_line_iter)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        ...</span>
<span class="gi">+    else:</span>
<span class="gi">+        initial_lines.append(first_line)</span>
<span class="gi">+        # The first character indicates if it is an ASCII or UTF graph</span>
<span class="gi">+        first_char = first_line[0]</span>
<span class="gi">+        if first_char in {</span>
<span class="gi">+            UtfBaseGlyphs.empty,</span>
<span class="gi">+            UtfBaseGlyphs.newtree_mid[0],</span>
<span class="gi">+            UtfBaseGlyphs.newtree_last[0],</span>
<span class="gi">+        }:</span>
<span class="gi">+            is_ascii = False</span>
<span class="gi">+        elif first_char in {</span>
<span class="gi">+            AsciiBaseGlyphs.empty,</span>
<span class="gi">+            AsciiBaseGlyphs.newtree_mid[0],</span>
<span class="gi">+            AsciiBaseGlyphs.newtree_last[0],</span>
<span class="gi">+        }:</span>
<span class="gi">+            is_ascii = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError(f&quot;Unexpected first character: {first_char}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if is_ascii:</span>
<span class="gi">+        directed_glyphs = AsciiDirectedGlyphs.as_dict()</span>
<span class="gi">+        undirected_glyphs = AsciiUndirectedGlyphs.as_dict()</span>
<span class="gi">+    else:</span>
<span class="gi">+        directed_glyphs = UtfDirectedGlyphs.as_dict()</span>
<span class="gi">+        undirected_glyphs = UtfUndirectedGlyphs.as_dict()</span>
<span class="gi">+</span>
<span class="gi">+    # For both directed / undirected glyphs, determine which glyphs never</span>
<span class="gi">+    # appear as substrings in the other undirected / directed glyphs.  Glyphs</span>
<span class="gi">+    # with this property unambiguously indicates if a graph is directed /</span>
<span class="gi">+    # undirected.</span>
<span class="gi">+    directed_items = set(directed_glyphs.values())</span>
<span class="gi">+    undirected_items = set(undirected_glyphs.values())</span>
<span class="gi">+    unambiguous_directed_items = []</span>
<span class="gi">+    for item in directed_items:</span>
<span class="gi">+        other_items = undirected_items</span>
<span class="gi">+        other_supersets = [other for other in other_items if item in other]</span>
<span class="gi">+        if not other_supersets:</span>
<span class="gi">+            unambiguous_directed_items.append(item)</span>
<span class="gi">+    unambiguous_undirected_items = []</span>
<span class="gi">+    for item in undirected_items:</span>
<span class="gi">+        other_items = directed_items</span>
<span class="gi">+        other_supersets = [other for other in other_items if item in other]</span>
<span class="gi">+        if not other_supersets:</span>
<span class="gi">+            unambiguous_undirected_items.append(item)</span>
<span class="gi">+</span>
<span class="gi">+    for line in initial_line_iter:</span>
<span class="gi">+        initial_lines.append(line)</span>
<span class="gi">+        if any(item in line for item in unambiguous_undirected_items):</span>
<span class="gi">+            is_directed = False</span>
<span class="gi">+            break</span>
<span class="gi">+        elif any(item in line for item in unambiguous_directed_items):</span>
<span class="gi">+            is_directed = True</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    if is_directed is None:</span>
<span class="gi">+        # Not enough information to determine, choose undirected by default</span>
<span class="gi">+        is_directed = False</span>
<span class="gi">+</span>
<span class="gi">+    glyphs = directed_glyphs if is_directed else undirected_glyphs</span>
<span class="gi">+</span>
<span class="gi">+    # the backedge symbol by itself can be ambiguous, but with spaces around it</span>
<span class="gi">+    # becomes unambiguous.</span>
<span class="gi">+    backedge_symbol = &quot; &quot; + glyphs[&quot;backedge&quot;] + &quot; &quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Reconstruct an iterator over all of the lines.</span>
<span class="gi">+    parsing_line_iter = chain(initial_lines, initial_line_iter)</span>
<span class="gi">+</span>
<span class="gi">+    ##############</span>
<span class="gi">+    # Parsing Pass</span>
<span class="gi">+    ##############</span>
<span class="gi">+</span>
<span class="gi">+    edges = []</span>
<span class="gi">+    nodes = []</span>
<span class="gi">+    is_empty = None</span>
<span class="gi">+</span>
<span class="gi">+    noparent = object()  # sentinel value</span>
<span class="gi">+</span>
<span class="gi">+    # keep a stack of previous nodes that could be parents of subsequent nodes</span>
<span class="gi">+    stack = [ParseStackFrame(noparent, -1, None)]</span>
<span class="gi">+</span>
<span class="gi">+    for line in parsing_line_iter:</span>
<span class="gi">+        if line == glyphs[&quot;empty&quot;]:</span>
<span class="gi">+            # If the line is the empty glyph, we are done.</span>
<span class="gi">+            # There shouldn&#39;t be anything else after this.</span>
<span class="gi">+            is_empty = True</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if backedge_symbol in line:</span>
<span class="gi">+            # This line has one or more backedges, separate those out</span>
<span class="gi">+            node_part, backedge_part = line.split(backedge_symbol)</span>
<span class="gi">+            backedge_nodes = [u.strip() for u in backedge_part.split(&quot;, &quot;)]</span>
<span class="gi">+            # Now the node can be parsed</span>
<span class="gi">+            node_part = node_part.rstrip()</span>
<span class="gi">+            prefix, node = node_part.rsplit(&quot; &quot;, 1)</span>
<span class="gi">+            node = node.strip()</span>
<span class="gi">+            # Add the backedges to the edge list</span>
<span class="gi">+            edges.extend([(u, node) for u in backedge_nodes])</span>
<span class="gi">+        else:</span>
<span class="gi">+            # No backedge, the tail of this line is the node</span>
<span class="gi">+            prefix, node = line.rsplit(&quot; &quot;, 1)</span>
<span class="gi">+            node = node.strip()</span>
<span class="gi">+</span>
<span class="gi">+        prev = stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+        if node in glyphs[&quot;vertical_edge&quot;]:</span>
<span class="gi">+            # Previous node is still the previous node, but we know it will</span>
<span class="gi">+            # have exactly one child, which will need to have its nesting level</span>
<span class="gi">+            # adjusted.</span>
<span class="gi">+            modified_prev = ParseStackFrame(</span>
<span class="gi">+                prev.node,</span>
<span class="gi">+                prev.indent,</span>
<span class="gi">+                True,</span>
<span class="gi">+            )</span>
<span class="gi">+            stack.append(modified_prev)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # The length of the string before the node characters give us a hint</span>
<span class="gi">+        # about our nesting level. The only case where this doesn&#39;t work is</span>
<span class="gi">+        # when there are vertical chains, which is handled explicitly.</span>
<span class="gi">+        indent = len(prefix)</span>
<span class="gi">+        curr = ParseStackFrame(node, indent, None)</span>
<span class="gi">+</span>
<span class="gi">+        if prev.has_vertical_child:</span>
<span class="gi">+            # In this case we know prev must be the parent of our current line,</span>
<span class="gi">+            # so we don&#39;t have to search the stack. (which is good because the</span>
<span class="gi">+            # indentation check wouldn&#39;t work in this case).</span>
<span class="gi">+            ...</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If the previous node nesting-level is greater than the current</span>
<span class="gi">+            # nodes nesting-level than the previous node was the end of a path,</span>
<span class="gi">+            # and is not our parent. We can safely pop nodes off the stack</span>
<span class="gi">+            # until we find one with a comparable nesting-level, which is our</span>
<span class="gi">+            # parent.</span>
<span class="gi">+            while curr.indent &lt;= prev.indent:</span>
<span class="gi">+                prev = stack.pop()</span>
<span class="gi">+</span>
<span class="gi">+        if node == &quot;...&quot;:</span>
<span class="gi">+            # The current previous node is no longer a valid parent,</span>
<span class="gi">+            # keep it popped from the stack.</span>
<span class="gi">+            stack.append(prev)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # The previous and current nodes may still be parents, so add them</span>
<span class="gi">+            # back onto the stack.</span>
<span class="gi">+            stack.append(prev)</span>
<span class="gi">+            stack.append(curr)</span>
<span class="gi">+</span>
<span class="gi">+            # Add the node and the edge to its parent to the node / edge lists.</span>
<span class="gi">+            nodes.append(curr.node)</span>
<span class="gi">+            if prev.node is not noparent:</span>
<span class="gi">+                edges.append((prev.node, curr.node))</span>
<span class="gi">+</span>
<span class="gi">+    if is_empty:</span>
<span class="gi">+        # Sanity check</span>
<span class="gi">+        assert len(nodes) == 0</span>
<span class="gi">+</span>
<span class="gi">+    # Reconstruct the graph</span>
<span class="gi">+    cls = nx.DiGraph if is_directed else nx.Graph</span>
<span class="gi">+    new = cls()</span>
<span class="gi">+    new.add_nodes_from(nodes)</span>
<span class="gi">+    new.add_edges_from(edges)</span>
<span class="gi">+    return new</span>
<span class="gh">diff --git a/networkx/relabel.py b/networkx/relabel.py</span>
<span class="gh">index c92e95f46..4b870f726 100644</span>
<span class="gd">--- a/networkx/relabel.py</span>
<span class="gi">+++ b/networkx/relabel.py</span>
<span class="gu">@@ -1,9 +1,11 @@</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;convert_node_labels_to_integers&#39;, &#39;relabel_nodes&#39;]</span>

<span class="gi">+__all__ = [&quot;convert_node_labels_to_integers&quot;, &quot;relabel_nodes&quot;]</span>

<span class="gd">-@nx._dispatchable(preserve_all_attrs=True, mutates_input={&#39;not copy&#39;: 2},</span>
<span class="gd">-    returns_graph=True)</span>
<span class="gi">+</span>
<span class="gi">+@nx._dispatchable(</span>
<span class="gi">+    preserve_all_attrs=True, mutates_input={&quot;not copy&quot;: 2}, returns_graph=True</span>
<span class="gi">+)</span>
<span class="w"> </span>def relabel_nodes(G, mapping, copy=True):
<span class="w"> </span>    &quot;&quot;&quot;Relabel the nodes of the graph G according to a given mapping.

<span class="gu">@@ -115,12 +117,116 @@ def relabel_nodes(G, mapping, copy=True):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    convert_node_labels_to_integers
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # you can pass any callable e.g. f(old_label) -&gt; new_label or</span>
<span class="gi">+    # e.g. str(old_label) -&gt; new_label, but we&#39;ll just make a dictionary here regardless</span>
<span class="gi">+    m = {n: mapping(n) for n in G} if callable(mapping) else mapping</span>
<span class="gi">+</span>
<span class="gi">+    if copy:</span>
<span class="gi">+        return _relabel_copy(G, m)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _relabel_inplace(G, m)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _relabel_inplace(G, mapping):</span>
<span class="gi">+    if len(mapping.keys() &amp; mapping.values()) &gt; 0:</span>
<span class="gi">+        # labels sets overlap</span>
<span class="gi">+        # can we topological sort and still do the relabeling?</span>
<span class="gi">+        D = nx.DiGraph(list(mapping.items()))</span>
<span class="gi">+        D.remove_edges_from(nx.selfloop_edges(D))</span>
<span class="gi">+        try:</span>
<span class="gi">+            nodes = reversed(list(nx.topological_sort(D)))</span>
<span class="gi">+        except nx.NetworkXUnfeasible as err:</span>
<span class="gi">+            raise nx.NetworkXUnfeasible(</span>
<span class="gi">+                &quot;The node label sets are overlapping and no ordering can &quot;</span>
<span class="gi">+                &quot;resolve the mapping. Use copy=True.&quot;</span>
<span class="gi">+            ) from err</span>
<span class="gi">+    else:</span>
<span class="gi">+        # non-overlapping label sets, sort them in the order of G nodes</span>
<span class="gi">+        nodes = [n for n in G if n in mapping]</span>
<span class="gi">+</span>
<span class="gi">+    multigraph = G.is_multigraph()</span>
<span class="gi">+    directed = G.is_directed()</span>
<span class="gi">+</span>
<span class="gi">+    for old in nodes:</span>
<span class="gi">+        # Test that old is in both mapping and G, otherwise ignore.</span>
<span class="gi">+        try:</span>
<span class="gi">+            new = mapping[old]</span>
<span class="gi">+            G.add_node(new, **G.nodes[old])</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if new == old:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if multigraph:</span>
<span class="gi">+            new_edges = [</span>
<span class="gi">+                (new, new if old == target else target, key, data)</span>
<span class="gi">+                for (_, target, key, data) in G.edges(old, data=True, keys=True)</span>
<span class="gi">+            ]</span>
<span class="gi">+            if directed:</span>
<span class="gi">+                new_edges += [</span>
<span class="gi">+                    (new if old == source else source, new, key, data)</span>
<span class="gi">+                    for (source, _, key, data) in G.in_edges(old, data=True, keys=True)</span>
<span class="gi">+                ]</span>
<span class="gi">+            # Ensure new edges won&#39;t overwrite existing ones</span>
<span class="gi">+            seen = set()</span>
<span class="gi">+            for i, (source, target, key, data) in enumerate(new_edges):</span>
<span class="gi">+                if target in G[source] and key in G[source][target]:</span>
<span class="gi">+                    new_key = 0 if not isinstance(key, int | float) else key</span>
<span class="gi">+                    while new_key in G[source][target] or (target, new_key) in seen:</span>
<span class="gi">+                        new_key += 1</span>
<span class="gi">+                    new_edges[i] = (source, target, new_key, data)</span>
<span class="gi">+                    seen.add((target, new_key))</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_edges = [</span>
<span class="gi">+                (new, new if old == target else target, data)</span>
<span class="gi">+                for (_, target, data) in G.edges(old, data=True)</span>
<span class="gi">+            ]</span>
<span class="gi">+            if directed:</span>
<span class="gi">+                new_edges += [</span>
<span class="gi">+                    (new if old == source else source, new, data)</span>
<span class="gi">+                    for (source, _, data) in G.in_edges(old, data=True)</span>
<span class="gi">+                ]</span>
<span class="gi">+        G.remove_node(old)</span>
<span class="gi">+        G.add_edges_from(new_edges)</span>
<span class="gi">+    return G</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _relabel_copy(G, mapping):</span>
<span class="gi">+    H = G.__class__()</span>
<span class="gi">+    H.add_nodes_from(mapping.get(n, n) for n in G)</span>
<span class="gi">+    H._node.update((mapping.get(n, n), d.copy()) for n, d in G.nodes.items())</span>
<span class="gi">+    if G.is_multigraph():</span>
<span class="gi">+        new_edges = [</span>
<span class="gi">+            (mapping.get(n1, n1), mapping.get(n2, n2), k, d.copy())</span>
<span class="gi">+            for (n1, n2, k, d) in G.edges(keys=True, data=True)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # check for conflicting edge-keys</span>
<span class="gi">+        undirected = not G.is_directed()</span>
<span class="gi">+        seen_edges = set()</span>
<span class="gi">+        for i, (source, target, key, data) in enumerate(new_edges):</span>
<span class="gi">+            while (source, target, key) in seen_edges:</span>
<span class="gi">+                if not isinstance(key, int | float):</span>
<span class="gi">+                    key = 0</span>
<span class="gi">+                key += 1</span>
<span class="gi">+            seen_edges.add((source, target, key))</span>
<span class="gi">+            if undirected:</span>
<span class="gi">+                seen_edges.add((target, source, key))</span>
<span class="gi">+            new_edges[i] = (source, target, key, data)</span>
<span class="gi">+</span>
<span class="gi">+        H.add_edges_from(new_edges)</span>
<span class="gi">+    else:</span>
<span class="gi">+        H.add_edges_from(</span>
<span class="gi">+            (mapping.get(n1, n1), mapping.get(n2, n2), d.copy())</span>
<span class="gi">+            for (n1, n2, d) in G.edges(data=True)</span>
<span class="gi">+        )</span>
<span class="gi">+    H.graph.update(G.graph)</span>
<span class="gi">+    return H</span>


<span class="w"> </span>@nx._dispatchable(preserve_all_attrs=True, returns_graph=True)
<span class="gd">-def convert_node_labels_to_integers(G, first_label=0, ordering=&#39;default&#39;,</span>
<span class="gd">-    label_attribute=None):</span>
<span class="gi">+def convert_node_labels_to_integers(</span>
<span class="gi">+    G, first_label=0, ordering=&quot;default&quot;, label_attribute=None</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a copy of the graph G with the nodes relabeled using
<span class="w"> </span>    consecutive integers.

<span class="gu">@@ -155,4 +261,25 @@ def convert_node_labels_to_integers(G, first_label=0, ordering=&#39;default&#39;,</span>
<span class="w"> </span>    --------
<span class="w"> </span>    relabel_nodes
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    N = G.number_of_nodes() + first_label</span>
<span class="gi">+    if ordering == &quot;default&quot;:</span>
<span class="gi">+        mapping = dict(zip(G.nodes(), range(first_label, N)))</span>
<span class="gi">+    elif ordering == &quot;sorted&quot;:</span>
<span class="gi">+        nlist = sorted(G.nodes())</span>
<span class="gi">+        mapping = dict(zip(nlist, range(first_label, N)))</span>
<span class="gi">+    elif ordering == &quot;increasing degree&quot;:</span>
<span class="gi">+        dv_pairs = [(d, n) for (n, d) in G.degree()]</span>
<span class="gi">+        dv_pairs.sort()  # in-place sort from lowest to highest degree</span>
<span class="gi">+        mapping = dict(zip([n for d, n in dv_pairs], range(first_label, N)))</span>
<span class="gi">+    elif ordering == &quot;decreasing degree&quot;:</span>
<span class="gi">+        dv_pairs = [(d, n) for (n, d) in G.degree()]</span>
<span class="gi">+        dv_pairs.sort()  # in-place sort from lowest to highest degree</span>
<span class="gi">+        dv_pairs.reverse()</span>
<span class="gi">+        mapping = dict(zip([n for d, n in dv_pairs], range(first_label, N)))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.NetworkXError(f&quot;Unknown node ordering: {ordering}&quot;)</span>
<span class="gi">+    H = relabel_nodes(G, mapping)</span>
<span class="gi">+    # create node attribute with the old label</span>
<span class="gi">+    if label_attribute is not None:</span>
<span class="gi">+        nx.set_node_attributes(H, {v: k for k, v in mapping.items()}, label_attribute)</span>
<span class="gi">+    return H</span>
<span class="gh">diff --git a/networkx/utils/backends.py b/networkx/utils/backends.py</span>
<span class="gh">index 692ebe3c7..b48798d80 100644</span>
<span class="gd">--- a/networkx/utils/backends.py</span>
<span class="gi">+++ b/networkx/utils/backends.py</span>
<span class="gu">@@ -190,20 +190,23 @@ Notes</span>
<span class="w"> </span>-   A backend graph instance may have a ``G.__networkx_cache__`` dict to enable
<span class="w"> </span>    caching, and care should be taken to clear the cache when appropriate.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import inspect
<span class="w"> </span>import itertools
<span class="w"> </span>import os
<span class="w"> </span>import warnings
<span class="w"> </span>from functools import partial
<span class="w"> </span>from importlib.metadata import entry_points
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from .decorators import argmap
<span class="gd">-__all__ = [&#39;_dispatchable&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;_dispatchable&quot;]</span>


<span class="w"> </span>def _do_nothing():
<span class="w"> </span>    &quot;&quot;&quot;This does nothing at all, yet it helps turn `_dispatchable` into functions.&quot;&quot;&quot;
<span class="gd">-    pass</span>


<span class="w"> </span>def _get_backends(group, *, load_and_call=False):
<span class="gu">@@ -228,21 +231,77 @@ def _get_backends(group, *, load_and_call=False):</span>
<span class="w"> </span>    The `nx-loopback` backend is removed if it exists, as it is only available during testing.
<span class="w"> </span>    A warning is displayed if an error occurs while loading a backend.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    items = entry_points(group=group)</span>
<span class="gi">+    rv = {}</span>
<span class="gi">+    for ep in items:</span>
<span class="gi">+        if ep.name in rv:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&quot;networkx backend defined more than once: {ep.name}&quot;,</span>
<span class="gi">+                RuntimeWarning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif load_and_call:</span>
<span class="gi">+            try:</span>
<span class="gi">+                rv[ep.name] = ep.load()()</span>
<span class="gi">+            except Exception as exc:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&quot;Error encountered when loading info for backend {ep.name}: {exc}&quot;,</span>
<span class="gi">+                    RuntimeWarning,</span>
<span class="gi">+                    stacklevel=2,</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            rv[ep.name] = ep</span>
<span class="gi">+    rv.pop(&quot;nx-loopback&quot;, None)</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>

<span class="gi">+backends = _get_backends(&quot;networkx.backends&quot;)</span>
<span class="gi">+backend_info = _get_backends(&quot;networkx.backend_info&quot;, load_and_call=True)</span>

<span class="gd">-backends = _get_backends(&#39;networkx.backends&#39;)</span>
<span class="gd">-backend_info = _get_backends(&#39;networkx.backend_info&#39;, load_and_call=True)</span>
<span class="gi">+# We must import from config after defining `backends` above</span>
<span class="w"> </span>from .configs import Config, config
<span class="gd">-config.backend_priority = [x.strip() for x in os.environ.get(</span>
<span class="gd">-    &#39;NETWORKX_BACKEND_PRIORITY&#39;, os.environ.get(</span>
<span class="gd">-    &#39;NETWORKX_AUTOMATIC_BACKENDS&#39;, &#39;&#39;)).split(&#39;,&#39;) if x.strip()]</span>
<span class="gd">-config.backends = Config(**{backend: ((cfg if isinstance((cfg := info[</span>
<span class="gd">-    &#39;default_config&#39;]), Config) else Config(**cfg)) if &#39;default_config&#39; in</span>
<span class="gd">-    info else Config()) for backend, info in backend_info.items()})</span>
<span class="gd">-type(config.backends</span>
<span class="gd">-    ).__doc__ = &#39;All installed NetworkX backends and their configs.&#39;</span>
<span class="gd">-_loaded_backends = {}</span>
<span class="gi">+</span>
<span class="gi">+# Get default configuration from environment variables at import time</span>
<span class="gi">+config.backend_priority = [</span>
<span class="gi">+    x.strip()</span>
<span class="gi">+    for x in os.environ.get(</span>
<span class="gi">+        &quot;NETWORKX_BACKEND_PRIORITY&quot;,</span>
<span class="gi">+        os.environ.get(&quot;NETWORKX_AUTOMATIC_BACKENDS&quot;, &quot;&quot;),</span>
<span class="gi">+    ).split(&quot;,&quot;)</span>
<span class="gi">+    if x.strip()</span>
<span class="gi">+]</span>
<span class="gi">+# Initialize default configuration for backends</span>
<span class="gi">+config.backends = Config(</span>
<span class="gi">+    **{</span>
<span class="gi">+        backend: (</span>
<span class="gi">+            cfg if isinstance(cfg := info[&quot;default_config&quot;], Config) else Config(**cfg)</span>
<span class="gi">+        )</span>
<span class="gi">+        if &quot;default_config&quot; in info</span>
<span class="gi">+        else Config()</span>
<span class="gi">+        for backend, info in backend_info.items()</span>
<span class="gi">+    }</span>
<span class="gi">+)</span>
<span class="gi">+type(config.backends).__doc__ = &quot;All installed NetworkX backends and their configs.&quot;</span>
<span class="gi">+</span>
<span class="gi">+# Load and cache backends on-demand</span>
<span class="gi">+_loaded_backends = {}  # type: ignore[var-annotated]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _always_run(name, args, kwargs):</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_backend(backend_name):</span>
<span class="gi">+    if backend_name in _loaded_backends:</span>
<span class="gi">+        return _loaded_backends[backend_name]</span>
<span class="gi">+    rv = _loaded_backends[backend_name] = backends[backend_name].load()</span>
<span class="gi">+    if not hasattr(rv, &quot;can_run&quot;):</span>
<span class="gi">+        rv.can_run = _always_run</span>
<span class="gi">+    if not hasattr(rv, &quot;should_run&quot;):</span>
<span class="gi">+        rv.should_run = _always_run</span>
<span class="gi">+    return rv</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_registered_algorithms = {}


<span class="gu">@@ -259,14 +318,27 @@ class _dispatchable:</span>
<span class="w"> </span>    For example: `PYTHONPATH=. pytest --backend graphblas --fallback-to-nx`
<span class="w"> </span>    Future work: add configuration to control these.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _is_testing = False</span>
<span class="gd">-    _fallback_to_nx = os.environ.get(&#39;NETWORKX_FALLBACK_TO_NX&#39;, &#39;true&#39;).strip(</span>
<span class="gd">-        ).lower() == &#39;true&#39;</span>

<span class="gd">-    def __new__(cls, func=None, *, name=None, graphs=&#39;G&#39;, edge_attrs=None,</span>
<span class="gd">-        node_attrs=None, preserve_edge_attrs=False, preserve_node_attrs=</span>
<span class="gd">-        False, preserve_graph_attrs=False, preserve_all_attrs=False,</span>
<span class="gd">-        mutates_input=False, returns_graph=False):</span>
<span class="gi">+    _is_testing = False</span>
<span class="gi">+    _fallback_to_nx = (</span>
<span class="gi">+        os.environ.get(&quot;NETWORKX_FALLBACK_TO_NX&quot;, &quot;true&quot;).strip().lower() == &quot;true&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __new__(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        func=None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        name=None,</span>
<span class="gi">+        graphs=&quot;G&quot;,</span>
<span class="gi">+        edge_attrs=None,</span>
<span class="gi">+        node_attrs=None,</span>
<span class="gi">+        preserve_edge_attrs=False,</span>
<span class="gi">+        preserve_node_attrs=False,</span>
<span class="gi">+        preserve_graph_attrs=False,</span>
<span class="gi">+        preserve_all_attrs=False,</span>
<span class="gi">+        mutates_input=False,</span>
<span class="gi">+        returns_graph=False,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;A decorator that makes certain input graph types dispatch to ``func``&#39;s
<span class="w"> </span>        backend implementation.

<span class="gu">@@ -359,31 +431,46 @@ class _dispatchable:</span>
<span class="w"> </span>            functions that return graphs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if func is None:
<span class="gd">-            return partial(_dispatchable, name=name, graphs=graphs,</span>
<span class="gd">-                edge_attrs=edge_attrs, node_attrs=node_attrs,</span>
<span class="gi">+            return partial(</span>
<span class="gi">+                _dispatchable,</span>
<span class="gi">+                name=name,</span>
<span class="gi">+                graphs=graphs,</span>
<span class="gi">+                edge_attrs=edge_attrs,</span>
<span class="gi">+                node_attrs=node_attrs,</span>
<span class="w"> </span>                preserve_edge_attrs=preserve_edge_attrs,
<span class="w"> </span>                preserve_node_attrs=preserve_node_attrs,
<span class="w"> </span>                preserve_graph_attrs=preserve_graph_attrs,
<span class="gd">-                preserve_all_attrs=preserve_all_attrs, mutates_input=</span>
<span class="gd">-                mutates_input, returns_graph=returns_graph)</span>
<span class="gi">+                preserve_all_attrs=preserve_all_attrs,</span>
<span class="gi">+                mutates_input=mutates_input,</span>
<span class="gi">+                returns_graph=returns_graph,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        if isinstance(func, str):
<span class="gd">-            raise TypeError(&quot;&#39;name&#39; and &#39;graphs&#39; must be passed by keyword&quot;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+            raise TypeError(&quot;&#39;name&#39; and &#39;graphs&#39; must be passed by keyword&quot;) from None</span>
<span class="gi">+        # If name not provided, use the name of the function</span>
<span class="w"> </span>        if name is None:
<span class="w"> </span>            name = func.__name__
<span class="gi">+</span>
<span class="w"> </span>        self = object.__new__(cls)
<span class="gi">+</span>
<span class="gi">+        # standard function-wrapping stuff</span>
<span class="gi">+        # __annotations__ not used</span>
<span class="w"> </span>        self.__name__ = func.__name__
<span class="gi">+        # self.__doc__ = func.__doc__  # __doc__ handled as cached property</span>
<span class="w"> </span>        self.__defaults__ = func.__defaults__
<span class="gi">+        # We &quot;magically&quot; add `backend=` keyword argument to allow backend to be specified</span>
<span class="w"> </span>        if func.__kwdefaults__:
<span class="gd">-            self.__kwdefaults__ = {**func.__kwdefaults__, &#39;backend&#39;: None}</span>
<span class="gi">+            self.__kwdefaults__ = {**func.__kwdefaults__, &quot;backend&quot;: None}</span>
<span class="w"> </span>        else:
<span class="gd">-            self.__kwdefaults__ = {&#39;backend&#39;: None}</span>
<span class="gi">+            self.__kwdefaults__ = {&quot;backend&quot;: None}</span>
<span class="w"> </span>        self.__module__ = func.__module__
<span class="w"> </span>        self.__qualname__ = func.__qualname__
<span class="w"> </span>        self.__dict__.update(func.__dict__)
<span class="w"> </span>        self.__wrapped__ = func
<span class="gi">+</span>
<span class="gi">+        # Supplement docstring with backend info; compute and cache when needed</span>
<span class="w"> </span>        self._orig_doc = func.__doc__
<span class="w"> </span>        self._cached_doc = None
<span class="gi">+</span>
<span class="w"> </span>        self.orig_func = func
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.edge_attrs = edge_attrs
<span class="gu">@@ -392,62 +479,91 @@ class _dispatchable:</span>
<span class="w"> </span>        self.preserve_node_attrs = preserve_node_attrs or preserve_all_attrs
<span class="w"> </span>        self.preserve_graph_attrs = preserve_graph_attrs or preserve_all_attrs
<span class="w"> </span>        self.mutates_input = mutates_input
<span class="gi">+        # Keep `returns_graph` private for now, b/c we may extend info on return types</span>
<span class="w"> </span>        self._returns_graph = returns_graph
<span class="gi">+</span>
<span class="w"> </span>        if edge_attrs is not None and not isinstance(edge_attrs, str | dict):
<span class="w"> </span>            raise TypeError(
<span class="gd">-                f&#39;Bad type for edge_attrs: {type(edge_attrs)}. Expected str or dict.&#39;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+                f&quot;Bad type for edge_attrs: {type(edge_attrs)}. Expected str or dict.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="w"> </span>        if node_attrs is not None and not isinstance(node_attrs, str | dict):
<span class="w"> </span>            raise TypeError(
<span class="gd">-                f&#39;Bad type for node_attrs: {type(node_attrs)}. Expected str or dict.&#39;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+                f&quot;Bad type for node_attrs: {type(node_attrs)}. Expected str or dict.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="w"> </span>        if not isinstance(self.preserve_edge_attrs, bool | str | dict):
<span class="w"> </span>            raise TypeError(
<span class="gd">-                f&#39;Bad type for preserve_edge_attrs: {type(self.preserve_edge_attrs)}. Expected bool, str, or dict.&#39;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+                f&quot;Bad type for preserve_edge_attrs: {type(self.preserve_edge_attrs)}.&quot;</span>
<span class="gi">+                &quot; Expected bool, str, or dict.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="w"> </span>        if not isinstance(self.preserve_node_attrs, bool | str | dict):
<span class="w"> </span>            raise TypeError(
<span class="gd">-                f&#39;Bad type for preserve_node_attrs: {type(self.preserve_node_attrs)}. Expected bool, str, or dict.&#39;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+                f&quot;Bad type for preserve_node_attrs: {type(self.preserve_node_attrs)}.&quot;</span>
<span class="gi">+                &quot; Expected bool, str, or dict.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="w"> </span>        if not isinstance(self.preserve_graph_attrs, bool | set):
<span class="w"> </span>            raise TypeError(
<span class="gd">-                f&#39;Bad type for preserve_graph_attrs: {type(self.preserve_graph_attrs)}. Expected bool or set.&#39;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+                f&quot;Bad type for preserve_graph_attrs: {type(self.preserve_graph_attrs)}.&quot;</span>
<span class="gi">+                &quot; Expected bool or set.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="w"> </span>        if not isinstance(self.mutates_input, bool | dict):
<span class="w"> </span>            raise TypeError(
<span class="gd">-                f&#39;Bad type for mutates_input: {type(self.mutates_input)}. Expected bool or dict.&#39;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+                f&quot;Bad type for mutates_input: {type(self.mutates_input)}.&quot;</span>
<span class="gi">+                &quot; Expected bool or dict.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="w"> </span>        if not isinstance(self._returns_graph, bool):
<span class="w"> </span>            raise TypeError(
<span class="gd">-                f&#39;Bad type for returns_graph: {type(self._returns_graph)}. Expected bool.&#39;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+                f&quot;Bad type for returns_graph: {type(self._returns_graph)}.&quot;</span>
<span class="gi">+                &quot; Expected bool.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="gi">+</span>
<span class="w"> </span>        if isinstance(graphs, str):
<span class="w"> </span>            graphs = {graphs: 0}
<span class="w"> </span>        elif graphs is None:
<span class="w"> </span>            pass
<span class="w"> </span>        elif not isinstance(graphs, dict):
<span class="w"> </span>            raise TypeError(
<span class="gd">-                f&#39;Bad type for graphs: {type(graphs)}. Expected str or dict.&#39;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+                f&quot;Bad type for graphs: {type(graphs)}. Expected str or dict.&quot;</span>
<span class="gi">+            ) from None</span>
<span class="w"> </span>        elif len(graphs) == 0:
<span class="gd">-            raise KeyError(&quot;&#39;graphs&#39; must contain at least one variable name&quot;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+            raise KeyError(&quot;&#39;graphs&#39; must contain at least one variable name&quot;) from None</span>
<span class="gi">+</span>
<span class="gi">+        # This dict comprehension is complicated for better performance; equivalent shown below.</span>
<span class="w"> </span>        self.optional_graphs = set()
<span class="w"> </span>        self.list_graphs = set()
<span class="w"> </span>        if graphs is None:
<span class="w"> </span>            self.graphs = {}
<span class="w"> </span>        else:
<span class="gd">-            self.graphs = {(self.optional_graphs.add((val := k[:-1])) or</span>
<span class="gd">-                val if (last := k[-1]) == &#39;?&#39; else self.list_graphs.add((</span>
<span class="gd">-                val := k[1:-1])) or val if last == &#39;]&#39; else k): v for k, v in</span>
<span class="gd">-                graphs.items()}</span>
<span class="gi">+            self.graphs = {</span>
<span class="gi">+                self.optional_graphs.add(val := k[:-1]) or val</span>
<span class="gi">+                if (last := k[-1]) == &quot;?&quot;</span>
<span class="gi">+                else self.list_graphs.add(val := k[1:-1]) or val</span>
<span class="gi">+                if last == &quot;]&quot;</span>
<span class="gi">+                else k: v</span>
<span class="gi">+                for k, v in graphs.items()</span>
<span class="gi">+            }</span>
<span class="gi">+        # The above is equivalent to:</span>
<span class="gi">+        # self.optional_graphs = {k[:-1] for k in graphs if k[-1] == &quot;?&quot;}</span>
<span class="gi">+        # self.list_graphs = {k[1:-1] for k in graphs if k[-1] == &quot;]&quot;}</span>
<span class="gi">+        # self.graphs = {k[:-1] if k[-1] == &quot;?&quot; else k: v for k, v in graphs.items()}</span>
<span class="gi">+</span>
<span class="gi">+        # Compute and cache the signature on-demand</span>
<span class="w"> </span>        self._sig = None
<span class="gd">-        self.backends = {backend for backend, info in backend_info.items() if</span>
<span class="gd">-            &#39;functions&#39; in info and name in info[&#39;functions&#39;]}</span>
<span class="gi">+</span>
<span class="gi">+        # Which backends implement this function?</span>
<span class="gi">+        self.backends = {</span>
<span class="gi">+            backend</span>
<span class="gi">+            for backend, info in backend_info.items()</span>
<span class="gi">+            if &quot;functions&quot; in info and name in info[&quot;functions&quot;]</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="w"> </span>        if name in _registered_algorithms:
<span class="w"> </span>            raise KeyError(
<span class="gd">-                f&#39;Algorithm already exists in dispatch registry: {name}&#39;</span>
<span class="gd">-                ) from None</span>
<span class="gi">+                f&quot;Algorithm already exists in dispatch registry: {name}&quot;</span>
<span class="gi">+            ) from None</span>
<span class="gi">+        # Use the magic of `argmap` to turn `self` into a function. This does result</span>
<span class="gi">+        # in small additional overhead compared to calling `_dispatchable` directly,</span>
<span class="gi">+        # but `argmap` has the magical property that it can stack with other `argmap`</span>
<span class="gi">+        # decorators &quot;for free&quot;. Being a function is better for REPRs and type-checkers.</span>
<span class="w"> </span>        self = argmap(_do_nothing)(self)
<span class="w"> </span>        _registered_algorithms[name] = self
<span class="w"> </span>        return self
<span class="gu">@@ -457,6 +573,7 @@ class _dispatchable:</span>
<span class="w"> </span>        &quot;&quot;&quot;If the cached documentation exists, it is returned.
<span class="w"> </span>        Otherwise, the documentation is generated using _make_doc() method,
<span class="w"> </span>        cached, and then returned.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        if (rv := self._cached_doc) is not None:
<span class="w"> </span>            return rv
<span class="w"> </span>        rv = self._cached_doc = self._make_doc()
<span class="gu">@@ -466,6 +583,7 @@ class _dispatchable:</span>
<span class="w"> </span>    def __doc__(self, val):
<span class="w"> </span>        &quot;&quot;&quot;Sets the original documentation to the given value and resets the
<span class="w"> </span>        cached documentation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self._orig_doc = val
<span class="w"> </span>        self._cached_doc = None

<span class="gu">@@ -473,131 +591,245 @@ class _dispatchable:</span>
<span class="w"> </span>    def __signature__(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the signature of the original function, with the addition of
<span class="w"> </span>        the `backend` and `backend_kwargs` parameters.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        if self._sig is None:
<span class="w"> </span>            sig = inspect.signature(self.orig_func)
<span class="gd">-            if not any(p.kind == inspect.Parameter.VAR_KEYWORD for p in sig</span>
<span class="gd">-                .parameters.values()):</span>
<span class="gd">-                sig = sig.replace(parameters=[*sig.parameters.values(),</span>
<span class="gd">-                    inspect.Parameter(&#39;backend&#39;, inspect.Parameter.</span>
<span class="gd">-                    KEYWORD_ONLY, default=None), inspect.Parameter(</span>
<span class="gd">-                    &#39;backend_kwargs&#39;, inspect.Parameter.VAR_KEYWORD)])</span>
<span class="gi">+            # `backend` is now a reserved argument used by dispatching.</span>
<span class="gi">+            # assert &quot;backend&quot; not in sig.parameters</span>
<span class="gi">+            if not any(</span>
<span class="gi">+                p.kind == inspect.Parameter.VAR_KEYWORD for p in sig.parameters.values()</span>
<span class="gi">+            ):</span>
<span class="gi">+                sig = sig.replace(</span>
<span class="gi">+                    parameters=[</span>
<span class="gi">+                        *sig.parameters.values(),</span>
<span class="gi">+                        inspect.Parameter(</span>
<span class="gi">+                            &quot;backend&quot;, inspect.Parameter.KEYWORD_ONLY, default=None</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        inspect.Parameter(</span>
<span class="gi">+                            &quot;backend_kwargs&quot;, inspect.Parameter.VAR_KEYWORD</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="w"> </span>            else:
<span class="w"> </span>                *parameters, var_keyword = sig.parameters.values()
<span class="gd">-                sig = sig.replace(parameters=[*parameters, inspect.</span>
<span class="gd">-                    Parameter(&#39;backend&#39;, inspect.Parameter.KEYWORD_ONLY,</span>
<span class="gd">-                    default=None), var_keyword])</span>
<span class="gi">+                sig = sig.replace(</span>
<span class="gi">+                    parameters=[</span>
<span class="gi">+                        *parameters,</span>
<span class="gi">+                        inspect.Parameter(</span>
<span class="gi">+                            &quot;backend&quot;, inspect.Parameter.KEYWORD_ONLY, default=None</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        var_keyword,</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="w"> </span>            self._sig = sig
<span class="w"> </span>        return self._sig

<span class="w"> </span>    def __call__(self, /, *args, backend=None, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Returns the result of the original function, or the backend function if
<span class="w"> </span>        the backend is specified and that backend implements `func`.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        if not backends:
<span class="gi">+            # Fast path if no backends are installed</span>
<span class="w"> </span>            return self.orig_func(*args, **kwargs)
<span class="gi">+</span>
<span class="gi">+        # Use `backend_name` in this function instead of `backend`</span>
<span class="w"> </span>        backend_name = backend
<span class="w"> </span>        if backend_name is not None and backend_name not in backends:
<span class="gd">-            raise ImportError(f&#39;Unable to load backend: {backend_name}&#39;)</span>
<span class="gi">+            raise ImportError(f&quot;Unable to load backend: {backend_name}&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        graphs_resolved = {}
<span class="w"> </span>        for gname, pos in self.graphs.items():
<span class="w"> </span>            if pos &lt; len(args):
<span class="w"> </span>                if gname in kwargs:
<span class="gd">-                    raise TypeError(</span>
<span class="gd">-                        f&#39;{self.name}() got multiple values for {gname!r}&#39;)</span>
<span class="gi">+                    raise TypeError(f&quot;{self.name}() got multiple values for {gname!r}&quot;)</span>
<span class="w"> </span>                val = args[pos]
<span class="w"> </span>            elif gname in kwargs:
<span class="w"> </span>                val = kwargs[gname]
<span class="w"> </span>            elif gname not in self.optional_graphs:
<span class="w"> </span>                raise TypeError(
<span class="gd">-                    f&#39;{self.name}() missing required graph argument: {gname}&#39;)</span>
<span class="gi">+                    f&quot;{self.name}() missing required graph argument: {gname}&quot;</span>
<span class="gi">+                )</span>
<span class="w"> </span>            else:
<span class="w"> </span>                continue
<span class="w"> </span>            if val is None:
<span class="w"> </span>                if gname not in self.optional_graphs:
<span class="w"> </span>                    raise TypeError(
<span class="gd">-                        f&#39;{self.name}() required graph argument {gname!r} is None; must be a graph&#39;</span>
<span class="gd">-                        )</span>
<span class="gi">+                        f&quot;{self.name}() required graph argument {gname!r} is None; must be a graph&quot;</span>
<span class="gi">+                    )</span>
<span class="w"> </span>            else:
<span class="w"> </span>                graphs_resolved[gname] = val
<span class="gi">+</span>
<span class="gi">+        # Alternative to the above that does not check duplicated args or missing required graphs.</span>
<span class="gi">+        # graphs_resolved = {</span>
<span class="gi">+        #     val</span>
<span class="gi">+        #     for gname, pos in self.graphs.items()</span>
<span class="gi">+        #     if (val := args[pos] if pos &lt; len(args) else kwargs.get(gname)) is not None</span>
<span class="gi">+        # }</span>
<span class="gi">+</span>
<span class="gi">+        # Check if any graph comes from a backend</span>
<span class="w"> </span>        if self.list_graphs:
<span class="gi">+            # Make sure we don&#39;t lose values by consuming an iterator</span>
<span class="w"> </span>            args = list(args)
<span class="gd">-            for gname in (self.list_graphs &amp; graphs_resolved.keys()):</span>
<span class="gi">+            for gname in self.list_graphs &amp; graphs_resolved.keys():</span>
<span class="w"> </span>                val = list(graphs_resolved[gname])
<span class="w"> </span>                graphs_resolved[gname] = val
<span class="w"> </span>                if gname in kwargs:
<span class="w"> </span>                    kwargs[gname] = val
<span class="w"> </span>                else:
<span class="w"> </span>                    args[self.graphs[gname]] = val
<span class="gd">-            has_backends = any(hasattr(g, &#39;__networkx_backend__&#39;) if gname</span>
<span class="gd">-                 not in self.list_graphs else any(hasattr(g2,</span>
<span class="gd">-                &#39;__networkx_backend__&#39;) for g2 in g) for gname, g in</span>
<span class="gd">-                graphs_resolved.items())</span>
<span class="gi">+</span>
<span class="gi">+            has_backends = any(</span>
<span class="gi">+                hasattr(g, &quot;__networkx_backend__&quot;)</span>
<span class="gi">+                if gname not in self.list_graphs</span>
<span class="gi">+                else any(hasattr(g2, &quot;__networkx_backend__&quot;) for g2 in g)</span>
<span class="gi">+                for gname, g in graphs_resolved.items()</span>
<span class="gi">+            )</span>
<span class="w"> </span>            if has_backends:
<span class="gd">-                graph_backend_names = {getattr(g, &#39;__networkx_backend__&#39;,</span>
<span class="gd">-                    &#39;networkx&#39;) for gname, g in graphs_resolved.items() if </span>
<span class="gd">-                    gname not in self.list_graphs}</span>
<span class="gd">-                for gname in (self.list_graphs &amp; graphs_resolved.keys()):</span>
<span class="gd">-                    graph_backend_names.update(getattr(g,</span>
<span class="gd">-                        &#39;__networkx_backend__&#39;, &#39;networkx&#39;) for g in</span>
<span class="gd">-                        graphs_resolved[gname])</span>
<span class="gi">+                graph_backend_names = {</span>
<span class="gi">+                    getattr(g, &quot;__networkx_backend__&quot;, &quot;networkx&quot;)</span>
<span class="gi">+                    for gname, g in graphs_resolved.items()</span>
<span class="gi">+                    if gname not in self.list_graphs</span>
<span class="gi">+                }</span>
<span class="gi">+                for gname in self.list_graphs &amp; graphs_resolved.keys():</span>
<span class="gi">+                    graph_backend_names.update(</span>
<span class="gi">+                        getattr(g, &quot;__networkx_backend__&quot;, &quot;networkx&quot;)</span>
<span class="gi">+                        for g in graphs_resolved[gname]</span>
<span class="gi">+                    )</span>
<span class="w"> </span>        else:
<span class="gd">-            has_backends = any(hasattr(g, &#39;__networkx_backend__&#39;) for g in</span>
<span class="gd">-                graphs_resolved.values())</span>
<span class="gi">+            has_backends = any(</span>
<span class="gi">+                hasattr(g, &quot;__networkx_backend__&quot;) for g in graphs_resolved.values()</span>
<span class="gi">+            )</span>
<span class="w"> </span>            if has_backends:
<span class="gd">-                graph_backend_names = {getattr(g, &#39;__networkx_backend__&#39;,</span>
<span class="gd">-                    &#39;networkx&#39;) for g in graphs_resolved.values()}</span>
<span class="gi">+                graph_backend_names = {</span>
<span class="gi">+                    getattr(g, &quot;__networkx_backend__&quot;, &quot;networkx&quot;)</span>
<span class="gi">+                    for g in graphs_resolved.values()</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="w"> </span>        backend_priority = config.backend_priority
<span class="w"> </span>        if self._is_testing and backend_priority and backend_name is None:
<span class="gd">-            return self._convert_and_call_for_tests(backend_priority[0],</span>
<span class="gd">-                args, kwargs, fallback_to_nx=self._fallback_to_nx)</span>
<span class="gi">+            # Special path if we are running networkx tests with a backend.</span>
<span class="gi">+            # This even runs for (and handles) functions that mutate input graphs.</span>
<span class="gi">+            return self._convert_and_call_for_tests(</span>
<span class="gi">+                backend_priority[0],</span>
<span class="gi">+                args,</span>
<span class="gi">+                kwargs,</span>
<span class="gi">+                fallback_to_nx=self._fallback_to_nx,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        if has_backends:
<span class="gd">-            backend_names = graph_backend_names - {&#39;networkx&#39;}</span>
<span class="gi">+            # Dispatchable graphs found! Dispatch to backend function.</span>
<span class="gi">+            # We don&#39;t handle calls with different backend graphs yet,</span>
<span class="gi">+            # but we may be able to convert additional networkx graphs.</span>
<span class="gi">+            backend_names = graph_backend_names - {&quot;networkx&quot;}</span>
<span class="w"> </span>            if len(backend_names) != 1:
<span class="gi">+                # Future work: convert between backends and run if multiple backends found</span>
<span class="w"> </span>                raise TypeError(
<span class="gd">-                    f&#39;{self.name}() graphs must all be from the same backend, found {backend_names}&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    f&quot;{self.name}() graphs must all be from the same backend, found {backend_names}&quot;</span>
<span class="gi">+                )</span>
<span class="w"> </span>            [graph_backend_name] = backend_names
<span class="w"> </span>            if backend_name is not None and backend_name != graph_backend_name:
<span class="gi">+                # Future work: convert between backends to `backend_name` backend</span>
<span class="w"> </span>                raise TypeError(
<span class="gd">-                    f&#39;{self.name}() is unable to convert graph from backend {graph_backend_name!r} to the specified backend {backend_name!r}.&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    f&quot;{self.name}() is unable to convert graph from backend {graph_backend_name!r} &quot;</span>
<span class="gi">+                    f&quot;to the specified backend {backend_name!r}.&quot;</span>
<span class="gi">+                )</span>
<span class="w"> </span>            if graph_backend_name not in backends:
<span class="gd">-                raise ImportError(</span>
<span class="gd">-                    f&#39;Unable to load backend: {graph_backend_name}&#39;)</span>
<span class="gd">-            if (&#39;networkx&#39; in graph_backend_names and graph_backend_name not in</span>
<span class="gd">-                backend_priority):</span>
<span class="gi">+                raise ImportError(f&quot;Unable to load backend: {graph_backend_name}&quot;)</span>
<span class="gi">+            if (</span>
<span class="gi">+                &quot;networkx&quot; in graph_backend_names</span>
<span class="gi">+                and graph_backend_name not in backend_priority</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Not configured to convert networkx graphs to this backend</span>
<span class="w"> </span>                raise TypeError(
<span class="gd">-                    f&#39;Unable to convert inputs and run {self.name}. {self.name}() has networkx and {graph_backend_name} graphs, but NetworkX is not configured to automatically convert graphs from networkx to {graph_backend_name}.&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    f&quot;Unable to convert inputs and run {self.name}. &quot;</span>
<span class="gi">+                    f&quot;{self.name}() has networkx and {graph_backend_name} graphs, but NetworkX is not &quot;</span>
<span class="gi">+                    f&quot;configured to automatically convert graphs from networkx to {graph_backend_name}.&quot;</span>
<span class="gi">+                )</span>
<span class="w"> </span>            backend = _load_backend(graph_backend_name)
<span class="w"> </span>            if hasattr(backend, self.name):
<span class="gd">-                if &#39;networkx&#39; in graph_backend_names:</span>
<span class="gd">-                    return self._convert_and_call(graph_backend_name, args,</span>
<span class="gd">-                        kwargs, fallback_to_nx=self._fallback_to_nx)</span>
<span class="gi">+                if &quot;networkx&quot; in graph_backend_names:</span>
<span class="gi">+                    # We need to convert networkx graphs to backend graphs.</span>
<span class="gi">+                    # There is currently no need to check `self.mutates_input` here.</span>
<span class="gi">+                    return self._convert_and_call(</span>
<span class="gi">+                        graph_backend_name,</span>
<span class="gi">+                        args,</span>
<span class="gi">+                        kwargs,</span>
<span class="gi">+                        fallback_to_nx=self._fallback_to_nx,</span>
<span class="gi">+                    )</span>
<span class="gi">+                # All graphs are backend graphs--no need to convert!</span>
<span class="w"> </span>                return getattr(backend, self.name)(*args, **kwargs)
<span class="gi">+            # Future work: try to convert and run with other backends in backend_priority</span>
<span class="w"> </span>            raise nx.NetworkXNotImplemented(
<span class="gd">-                f&quot;&#39;{self.name}&#39; not implemented by {graph_backend_name}&quot;)</span>
<span class="gi">+                f&quot;&#39;{self.name}&#39; not implemented by {graph_backend_name}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # If backend was explicitly given by the user, so we need to use it no matter what</span>
<span class="w"> </span>        if backend_name is not None:
<span class="gd">-            return self._convert_and_call(backend_name, args, kwargs,</span>
<span class="gd">-                fallback_to_nx=False)</span>
<span class="gd">-        if not self._returns_graph and (not self.mutates_input or </span>
<span class="gd">-            isinstance(self.mutates_input, dict) and any(not (args[arg_pos] if</span>
<span class="gd">-            len(args) &gt; arg_pos else kwargs.get(arg_name[4:], True)) if</span>
<span class="gd">-            arg_name.startswith(&#39;not &#39;) else (args[arg_pos] if len(args) &gt;</span>
<span class="gd">-            arg_pos else kwargs.get(arg_name)) is not None for arg_name,</span>
<span class="gd">-            arg_pos in self.mutates_input.items())):</span>
<span class="gi">+            return self._convert_and_call(</span>
<span class="gi">+                backend_name, args, kwargs, fallback_to_nx=False</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Only networkx graphs; try to convert and run with a backend with automatic</span>
<span class="gi">+        # conversion, but don&#39;t do this by default for graph generators or loaders,</span>
<span class="gi">+        # or if the functions mutates an input graph or returns a graph.</span>
<span class="gi">+        # Only convert and run if `backend.should_run(...)` returns True.</span>
<span class="gi">+        if (</span>
<span class="gi">+            not self._returns_graph</span>
<span class="gi">+            and (</span>
<span class="gi">+                not self.mutates_input</span>
<span class="gi">+                or isinstance(self.mutates_input, dict)</span>
<span class="gi">+                # If `mutates_input` begins with &quot;not &quot;, then assume the argument is boolean,</span>
<span class="gi">+                # otherwise treat it as a node or edge attribute if it&#39;s not None.</span>
<span class="gi">+                and any(</span>
<span class="gi">+                    not (</span>
<span class="gi">+                        args[arg_pos]</span>
<span class="gi">+                        if len(args) &gt; arg_pos</span>
<span class="gi">+                        else kwargs.get(arg_name[4:], True)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if arg_name.startswith(&quot;not &quot;)</span>
<span class="gi">+                    else (</span>
<span class="gi">+                        args[arg_pos] if len(args) &gt; arg_pos else kwargs.get(arg_name)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    is not None</span>
<span class="gi">+                    for arg_name, arg_pos in self.mutates_input.items()</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Should we warn or log if we don&#39;t convert b/c the input will be mutated?</span>
<span class="w"> </span>            for backend_name in backend_priority:
<span class="w"> </span>                if self._should_backend_run(backend_name, *args, **kwargs):
<span class="gd">-                    return self._convert_and_call(backend_name, args,</span>
<span class="gd">-                        kwargs, fallback_to_nx=self._fallback_to_nx)</span>
<span class="gi">+                    return self._convert_and_call(</span>
<span class="gi">+                        backend_name,</span>
<span class="gi">+                        args,</span>
<span class="gi">+                        kwargs,</span>
<span class="gi">+                        fallback_to_nx=self._fallback_to_nx,</span>
<span class="gi">+                    )</span>
<span class="gi">+        # Default: run with networkx on networkx inputs</span>
<span class="w"> </span>        return self.orig_func(*args, **kwargs)

<span class="w"> </span>    def _can_backend_run(self, backend_name, /, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Can the specified backend run this algorithm with these arguments?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        backend = _load_backend(backend_name)</span>
<span class="gi">+        # `backend.can_run` and `backend.should_run` may return strings that describe</span>
<span class="gi">+        # why they can&#39;t or shouldn&#39;t be run. We plan to use the strings in the future.</span>
<span class="gi">+        return (</span>
<span class="gi">+            hasattr(backend, self.name)</span>
<span class="gi">+            and (can_run := backend.can_run(self.name, args, kwargs))</span>
<span class="gi">+            and not isinstance(can_run, str)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _should_backend_run(self, backend_name, /, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Can/should the specified backend run this algorithm with these arguments?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        backend = _load_backend(backend_name)</span>
<span class="gi">+        # `backend.can_run` and `backend.should_run` may return strings that describe</span>
<span class="gi">+        # why they can&#39;t or shouldn&#39;t be run. We plan to use the strings in the future.</span>
<span class="gi">+        return (</span>
<span class="gi">+            hasattr(backend, self.name)</span>
<span class="gi">+            and (can_run := backend.can_run(self.name, args, kwargs))</span>
<span class="gi">+            and not isinstance(can_run, str)</span>
<span class="gi">+            and (should_run := backend.should_run(self.name, args, kwargs))</span>
<span class="gi">+            and not isinstance(should_run, str)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _convert_arguments(self, backend_name, args, kwargs, *, use_cache):
<span class="w"> </span>        &quot;&quot;&quot;Convert graph arguments to the specified backend.
<span class="gu">@@ -606,22 +838,686 @@ class _dispatchable:</span>
<span class="w"> </span>        -------
<span class="w"> </span>        args tuple and kwargs dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bound = self.__signature__.bind(*args, **kwargs)</span>
<span class="gi">+        bound.apply_defaults()</span>
<span class="gi">+        if not self.graphs:</span>
<span class="gi">+            bound_kwargs = bound.kwargs</span>
<span class="gi">+            del bound_kwargs[&quot;backend&quot;]</span>
<span class="gi">+            return bound.args, bound_kwargs</span>
<span class="gi">+        # Convert graphs into backend graph-like object</span>
<span class="gi">+        # Include the edge and/or node labels if provided to the algorithm</span>
<span class="gi">+        preserve_edge_attrs = self.preserve_edge_attrs</span>
<span class="gi">+        edge_attrs = self.edge_attrs</span>
<span class="gi">+        if preserve_edge_attrs is False:</span>
<span class="gi">+            # e.g. `preserve_edge_attrs=False`</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif preserve_edge_attrs is True:</span>
<span class="gi">+            # e.g. `preserve_edge_attrs=True`</span>
<span class="gi">+            edge_attrs = None</span>
<span class="gi">+        elif isinstance(preserve_edge_attrs, str):</span>
<span class="gi">+            if bound.arguments[preserve_edge_attrs] is True or callable(</span>
<span class="gi">+                bound.arguments[preserve_edge_attrs]</span>
<span class="gi">+            ):</span>
<span class="gi">+                # e.g. `preserve_edge_attrs=&quot;attr&quot;` and `func(attr=True)`</span>
<span class="gi">+                # e.g. `preserve_edge_attrs=&quot;attr&quot;` and `func(attr=myfunc)`</span>
<span class="gi">+                preserve_edge_attrs = True</span>
<span class="gi">+                edge_attrs = None</span>
<span class="gi">+            elif bound.arguments[preserve_edge_attrs] is False and (</span>
<span class="gi">+                isinstance(edge_attrs, str)</span>
<span class="gi">+                and edge_attrs == preserve_edge_attrs</span>
<span class="gi">+                or isinstance(edge_attrs, dict)</span>
<span class="gi">+                and preserve_edge_attrs in edge_attrs</span>
<span class="gi">+            ):</span>
<span class="gi">+                # e.g. `preserve_edge_attrs=&quot;attr&quot;` and `func(attr=False)`</span>
<span class="gi">+                # Treat `False` argument as meaning &quot;preserve_edge_data=False&quot;</span>
<span class="gi">+                # and not `False` as the edge attribute to use.</span>
<span class="gi">+                preserve_edge_attrs = False</span>
<span class="gi">+                edge_attrs = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                # e.g. `preserve_edge_attrs=&quot;attr&quot;` and `func(attr=&quot;weight&quot;)`</span>
<span class="gi">+                preserve_edge_attrs = False</span>
<span class="gi">+        # Else: e.g. `preserve_edge_attrs={&quot;G&quot;: {&quot;weight&quot;: 1}}`</span>

<span class="gd">-    def _convert_and_call(self, backend_name, args, kwargs, *,</span>
<span class="gd">-        fallback_to_nx=False):</span>
<span class="gd">-        &quot;&quot;&quot;Call this dispatchable function with a backend, converting graphs if necessary.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if edge_attrs is None:</span>
<span class="gi">+            # May have been set to None above b/c all attributes are preserved</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif isinstance(edge_attrs, str):</span>
<span class="gi">+            if edge_attrs[0] == &quot;[&quot;:</span>
<span class="gi">+                # e.g. `edge_attrs=&quot;[edge_attributes]&quot;` (argument of list of attributes)</span>
<span class="gi">+                # e.g. `func(edge_attributes=[&quot;foo&quot;, &quot;bar&quot;])`</span>
<span class="gi">+                edge_attrs = {</span>
<span class="gi">+                    edge_attr: 1 for edge_attr in bound.arguments[edge_attrs[1:-1]]</span>
<span class="gi">+                }</span>
<span class="gi">+            elif callable(bound.arguments[edge_attrs]):</span>
<span class="gi">+                # e.g. `edge_attrs=&quot;weight&quot;` and `func(weight=myfunc)`</span>
<span class="gi">+                preserve_edge_attrs = True</span>
<span class="gi">+                edge_attrs = None</span>
<span class="gi">+            elif bound.arguments[edge_attrs] is not None:</span>
<span class="gi">+                # e.g. `edge_attrs=&quot;weight&quot;` and `func(weight=&quot;foo&quot;)` (default of 1)</span>
<span class="gi">+                edge_attrs = {bound.arguments[edge_attrs]: 1}</span>
<span class="gi">+            elif self.name == &quot;to_numpy_array&quot; and hasattr(</span>
<span class="gi">+                bound.arguments[&quot;dtype&quot;], &quot;names&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Custom handling: attributes may be obtained from `dtype`</span>
<span class="gi">+                edge_attrs = {</span>
<span class="gi">+                    edge_attr: 1 for edge_attr in bound.arguments[&quot;dtype&quot;].names</span>
<span class="gi">+                }</span>
<span class="gi">+            else:</span>
<span class="gi">+                # e.g. `edge_attrs=&quot;weight&quot;` and `func(weight=None)`</span>
<span class="gi">+                edge_attrs = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            # e.g. `edge_attrs={&quot;attr&quot;: &quot;default&quot;}` and `func(attr=&quot;foo&quot;, default=7)`</span>
<span class="gi">+            # e.g. `edge_attrs={&quot;attr&quot;: 0}` and `func(attr=&quot;foo&quot;)`</span>
<span class="gi">+            edge_attrs = {</span>
<span class="gi">+                edge_attr: bound.arguments.get(val, 1) if isinstance(val, str) else val</span>
<span class="gi">+                for key, val in edge_attrs.items()</span>
<span class="gi">+                if (edge_attr := bound.arguments[key]) is not None</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        preserve_node_attrs = self.preserve_node_attrs</span>
<span class="gi">+        node_attrs = self.node_attrs</span>
<span class="gi">+        if preserve_node_attrs is False:</span>
<span class="gi">+            # e.g. `preserve_node_attrs=False`</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif preserve_node_attrs is True:</span>
<span class="gi">+            # e.g. `preserve_node_attrs=True`</span>
<span class="gi">+            node_attrs = None</span>
<span class="gi">+        elif isinstance(preserve_node_attrs, str):</span>
<span class="gi">+            if bound.arguments[preserve_node_attrs] is True or callable(</span>
<span class="gi">+                bound.arguments[preserve_node_attrs]</span>
<span class="gi">+            ):</span>
<span class="gi">+                # e.g. `preserve_node_attrs=&quot;attr&quot;` and `func(attr=True)`</span>
<span class="gi">+                # e.g. `preserve_node_attrs=&quot;attr&quot;` and `func(attr=myfunc)`</span>
<span class="gi">+                preserve_node_attrs = True</span>
<span class="gi">+                node_attrs = None</span>
<span class="gi">+            elif bound.arguments[preserve_node_attrs] is False and (</span>
<span class="gi">+                isinstance(node_attrs, str)</span>
<span class="gi">+                and node_attrs == preserve_node_attrs</span>
<span class="gi">+                or isinstance(node_attrs, dict)</span>
<span class="gi">+                and preserve_node_attrs in node_attrs</span>
<span class="gi">+            ):</span>
<span class="gi">+                # e.g. `preserve_node_attrs=&quot;attr&quot;` and `func(attr=False)`</span>
<span class="gi">+                # Treat `False` argument as meaning &quot;preserve_node_data=False&quot;</span>
<span class="gi">+                # and not `False` as the node attribute to use. Is this used?</span>
<span class="gi">+                preserve_node_attrs = False</span>
<span class="gi">+                node_attrs = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                # e.g. `preserve_node_attrs=&quot;attr&quot;` and `func(attr=&quot;weight&quot;)`</span>
<span class="gi">+                preserve_node_attrs = False</span>
<span class="gi">+        # Else: e.g. `preserve_node_attrs={&quot;G&quot;: {&quot;pos&quot;: None}}`</span>
<span class="gi">+</span>
<span class="gi">+        if node_attrs is None:</span>
<span class="gi">+            # May have been set to None above b/c all attributes are preserved</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif isinstance(node_attrs, str):</span>
<span class="gi">+            if node_attrs[0] == &quot;[&quot;:</span>
<span class="gi">+                # e.g. `node_attrs=&quot;[node_attributes]&quot;` (argument of list of attributes)</span>
<span class="gi">+                # e.g. `func(node_attributes=[&quot;foo&quot;, &quot;bar&quot;])`</span>
<span class="gi">+                node_attrs = {</span>
<span class="gi">+                    node_attr: None for node_attr in bound.arguments[node_attrs[1:-1]]</span>
<span class="gi">+                }</span>
<span class="gi">+            elif callable(bound.arguments[node_attrs]):</span>
<span class="gi">+                # e.g. `node_attrs=&quot;weight&quot;` and `func(weight=myfunc)`</span>
<span class="gi">+                preserve_node_attrs = True</span>
<span class="gi">+                node_attrs = None</span>
<span class="gi">+            elif bound.arguments[node_attrs] is not None:</span>
<span class="gi">+                # e.g. `node_attrs=&quot;weight&quot;` and `func(weight=&quot;foo&quot;)`</span>
<span class="gi">+                node_attrs = {bound.arguments[node_attrs]: None}</span>
<span class="gi">+            else:</span>
<span class="gi">+                # e.g. `node_attrs=&quot;weight&quot;` and `func(weight=None)`</span>
<span class="gi">+                node_attrs = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            # e.g. `node_attrs={&quot;attr&quot;: &quot;default&quot;}` and `func(attr=&quot;foo&quot;, default=7)`</span>
<span class="gi">+            # e.g. `node_attrs={&quot;attr&quot;: 0}` and `func(attr=&quot;foo&quot;)`</span>
<span class="gi">+            node_attrs = {</span>
<span class="gi">+                node_attr: bound.arguments.get(val) if isinstance(val, str) else val</span>
<span class="gi">+                for key, val in node_attrs.items()</span>
<span class="gi">+                if (node_attr := bound.arguments[key]) is not None</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        preserve_graph_attrs = self.preserve_graph_attrs</span>
<span class="gi">+</span>
<span class="gi">+        # It should be safe to assume that we either have networkx graphs or backend graphs.</span>
<span class="gi">+        # Future work: allow conversions between backends.</span>
<span class="gi">+        for gname in self.graphs:</span>
<span class="gi">+            if gname in self.list_graphs:</span>
<span class="gi">+                bound.arguments[gname] = [</span>
<span class="gi">+                    self._convert_graph(</span>
<span class="gi">+                        backend_name,</span>
<span class="gi">+                        g,</span>
<span class="gi">+                        edge_attrs=edge_attrs,</span>
<span class="gi">+                        node_attrs=node_attrs,</span>
<span class="gi">+                        preserve_edge_attrs=preserve_edge_attrs,</span>
<span class="gi">+                        preserve_node_attrs=preserve_node_attrs,</span>
<span class="gi">+                        preserve_graph_attrs=preserve_graph_attrs,</span>
<span class="gi">+                        graph_name=gname,</span>
<span class="gi">+                        use_cache=use_cache,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if getattr(g, &quot;__networkx_backend__&quot;, &quot;networkx&quot;) == &quot;networkx&quot;</span>
<span class="gi">+                    else g</span>
<span class="gi">+                    for g in bound.arguments[gname]</span>
<span class="gi">+                ]</span>
<span class="gi">+            else:</span>
<span class="gi">+                graph = bound.arguments[gname]</span>
<span class="gi">+                if graph is None:</span>
<span class="gi">+                    if gname in self.optional_graphs:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        f&quot;Missing required graph argument `{gname}` in {self.name} function&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                if isinstance(preserve_edge_attrs, dict):</span>
<span class="gi">+                    preserve_edges = False</span>
<span class="gi">+                    edges = preserve_edge_attrs.get(gname, edge_attrs)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    preserve_edges = preserve_edge_attrs</span>
<span class="gi">+                    edges = edge_attrs</span>
<span class="gi">+                if isinstance(preserve_node_attrs, dict):</span>
<span class="gi">+                    preserve_nodes = False</span>
<span class="gi">+                    nodes = preserve_node_attrs.get(gname, node_attrs)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    preserve_nodes = preserve_node_attrs</span>
<span class="gi">+                    nodes = node_attrs</span>
<span class="gi">+                if isinstance(preserve_graph_attrs, set):</span>
<span class="gi">+                    preserve_graph = gname in preserve_graph_attrs</span>
<span class="gi">+                else:</span>
<span class="gi">+                    preserve_graph = preserve_graph_attrs</span>
<span class="gi">+                if getattr(graph, &quot;__networkx_backend__&quot;, &quot;networkx&quot;) == &quot;networkx&quot;:</span>
<span class="gi">+                    bound.arguments[gname] = self._convert_graph(</span>
<span class="gi">+                        backend_name,</span>
<span class="gi">+                        graph,</span>
<span class="gi">+                        edge_attrs=edges,</span>
<span class="gi">+                        node_attrs=nodes,</span>
<span class="gi">+                        preserve_edge_attrs=preserve_edges,</span>
<span class="gi">+                        preserve_node_attrs=preserve_nodes,</span>
<span class="gi">+                        preserve_graph_attrs=preserve_graph,</span>
<span class="gi">+                        graph_name=gname,</span>
<span class="gi">+                        use_cache=use_cache,</span>
<span class="gi">+                    )</span>
<span class="gi">+        bound_kwargs = bound.kwargs</span>
<span class="gi">+        del bound_kwargs[&quot;backend&quot;]</span>
<span class="gi">+        return bound.args, bound_kwargs</span>
<span class="gi">+</span>
<span class="gi">+    def _convert_graph(</span>
<span class="gi">+        self,</span>
<span class="gi">+        backend_name,</span>
<span class="gi">+        graph,</span>
<span class="gi">+        *,</span>
<span class="gi">+        edge_attrs,</span>
<span class="gi">+        node_attrs,</span>
<span class="gi">+        preserve_edge_attrs,</span>
<span class="gi">+        preserve_node_attrs,</span>
<span class="gi">+        preserve_graph_attrs,</span>
<span class="gi">+        graph_name,</span>
<span class="gi">+        use_cache,</span>
<span class="gi">+    ):</span>
<span class="gi">+        if (</span>
<span class="gi">+            use_cache</span>
<span class="gi">+            and (nx_cache := getattr(graph, &quot;__networkx_cache__&quot;, None)) is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            cache = nx_cache.setdefault(&quot;backends&quot;, {}).setdefault(backend_name, {})</span>
<span class="gi">+            # edge_attrs: dict | None</span>
<span class="gi">+            # node_attrs: dict | None</span>
<span class="gi">+            # preserve_edge_attrs: bool (False if edge_attrs is not None)</span>
<span class="gi">+            # preserve_node_attrs: bool (False if node_attrs is not None)</span>
<span class="gi">+            # preserve_graph_attrs: bool</span>
<span class="gi">+            key = edge_key, node_key, graph_key = (</span>
<span class="gi">+                frozenset(edge_attrs.items())</span>
<span class="gi">+                if edge_attrs is not None</span>
<span class="gi">+                else preserve_edge_attrs,</span>
<span class="gi">+                frozenset(node_attrs.items())</span>
<span class="gi">+                if node_attrs is not None</span>
<span class="gi">+                else preserve_node_attrs,</span>
<span class="gi">+                preserve_graph_attrs,</span>
<span class="gi">+            )</span>
<span class="gi">+            if cache:</span>
<span class="gi">+                warning_message = (</span>
<span class="gi">+                    f&quot;Using cached graph for {backend_name!r} backend in &quot;</span>
<span class="gi">+                    f&quot;call to {self.name}.\n\nFor the cache to be consistent &quot;</span>
<span class="gi">+                    &quot;(i.e., correct), the input graph must not have been &quot;</span>
<span class="gi">+                    &quot;manually mutated since the cached graph was created. &quot;</span>
<span class="gi">+                    &quot;Examples of manually mutating the graph data structures &quot;</span>
<span class="gi">+                    &quot;resulting in an inconsistent cache include:\n\n&quot;</span>
<span class="gi">+                    &quot;    &gt;&gt;&gt; G[u][v][key] = val\n\n&quot;</span>
<span class="gi">+                    &quot;and\n\n&quot;</span>
<span class="gi">+                    &quot;    &gt;&gt;&gt; for u, v, d in G.edges(data=True):\n&quot;</span>
<span class="gi">+                    &quot;    ...     d[key] = val\n\n&quot;</span>
<span class="gi">+                    &quot;Using methods such as `G.add_edge(u, v, weight=val)` &quot;</span>
<span class="gi">+                    &quot;will correctly clear the cache to keep it consistent. &quot;</span>
<span class="gi">+                    &quot;You may also use `G.__networkx_cache__.clear()` to &quot;</span>
<span class="gi">+                    &quot;manually clear the cache, or set `G.__networkx_cache__` &quot;</span>
<span class="gi">+                    &quot;to None to disable caching for G. Enable or disable &quot;</span>
<span class="gi">+                    &quot;caching via `nx.config.cache_converted_graphs` config.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                # Do a simple search for a cached graph with compatible data.</span>
<span class="gi">+                # For example, if we need a single attribute, then it&#39;s okay</span>
<span class="gi">+                # to use a cached graph that preserved all attributes.</span>
<span class="gi">+                # This looks for an exact match first.</span>
<span class="gi">+                for compat_key in itertools.product(</span>
<span class="gi">+                    (edge_key, True) if edge_key is not True else (True,),</span>
<span class="gi">+                    (node_key, True) if node_key is not True else (True,),</span>
<span class="gi">+                    (graph_key, True) if graph_key is not True else (True,),</span>
<span class="gi">+                ):</span>
<span class="gi">+                    if (rv := cache.get(compat_key)) is not None:</span>
<span class="gi">+                        warnings.warn(warning_message)</span>
<span class="gi">+                        return rv</span>
<span class="gi">+                if edge_key is not True and node_key is not True:</span>
<span class="gi">+                    # Iterate over the items in `cache` to see if any are compatible.</span>
<span class="gi">+                    # For example, if no edge attributes are needed, then a graph</span>
<span class="gi">+                    # with any edge attribute will suffice. We use the same logic</span>
<span class="gi">+                    # below (but switched) to clear unnecessary items from the cache.</span>
<span class="gi">+                    # Use `list(cache.items())` to be thread-safe.</span>
<span class="gi">+                    for (ekey, nkey, gkey), val in list(cache.items()):</span>
<span class="gi">+                        if edge_key is False or ekey is True:</span>
<span class="gi">+                            pass</span>
<span class="gi">+                        elif (</span>
<span class="gi">+                            edge_key is True</span>
<span class="gi">+                            or ekey is False</span>
<span class="gi">+                            or not edge_key.issubset(ekey)</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        if node_key is False or nkey is True:</span>
<span class="gi">+                            pass</span>
<span class="gi">+                        elif (</span>
<span class="gi">+                            node_key is True</span>
<span class="gi">+                            or nkey is False</span>
<span class="gi">+                            or not node_key.issubset(nkey)</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        if graph_key and not gkey:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        warnings.warn(warning_message)</span>
<span class="gi">+                        return val</span>
<span class="gi">+</span>
<span class="gi">+        backend = _load_backend(backend_name)</span>
<span class="gi">+        rv = backend.convert_from_nx(</span>
<span class="gi">+            graph,</span>
<span class="gi">+            edge_attrs=edge_attrs,</span>
<span class="gi">+            node_attrs=node_attrs,</span>
<span class="gi">+            preserve_edge_attrs=preserve_edge_attrs,</span>
<span class="gi">+            preserve_node_attrs=preserve_node_attrs,</span>
<span class="gi">+            preserve_graph_attrs=preserve_graph_attrs,</span>
<span class="gi">+            name=self.name,</span>
<span class="gi">+            graph_name=graph_name,</span>
<span class="gi">+        )</span>
<span class="gi">+        if use_cache and nx_cache is not None:</span>
<span class="gi">+            # Remove old cached items that are no longer necessary since they</span>
<span class="gi">+            # are dominated/subsumed/outdated by what was just calculated.</span>
<span class="gi">+            # This uses the same logic as above, but with keys switched.</span>
<span class="gi">+            cache[key] = rv  # Set at beginning to be thread-safe</span>
<span class="gi">+            for cur_key in list(cache):</span>
<span class="gi">+                if cur_key == key:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                ekey, nkey, gkey = cur_key</span>
<span class="gi">+                if ekey is False or edge_key is True:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif ekey is True or edge_key is False or not ekey.issubset(edge_key):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if nkey is False or node_key is True:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif nkey is True or node_key is False or not nkey.issubset(node_key):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if gkey and not graph_key:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                cache.pop(cur_key, None)  # Use pop instead of del to be thread-safe</span>

<span class="gd">-    def _convert_and_call_for_tests(self, backend_name, args, kwargs, *,</span>
<span class="gd">-        fallback_to_nx=False):</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def _convert_and_call(self, backend_name, args, kwargs, *, fallback_to_nx=False):</span>
<span class="gi">+        &quot;&quot;&quot;Call this dispatchable function with a backend, converting graphs if necessary.&quot;&quot;&quot;</span>
<span class="gi">+        backend = _load_backend(backend_name)</span>
<span class="gi">+        if not self._can_backend_run(backend_name, *args, **kwargs):</span>
<span class="gi">+            if fallback_to_nx:</span>
<span class="gi">+                return self.orig_func(*args, **kwargs)</span>
<span class="gi">+            msg = f&quot;&#39;{self.name}&#39; not implemented by {backend_name}&quot;</span>
<span class="gi">+            if hasattr(backend, self.name):</span>
<span class="gi">+                msg += &quot; with the given arguments&quot;</span>
<span class="gi">+            raise RuntimeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            converted_args, converted_kwargs = self._convert_arguments(</span>
<span class="gi">+                backend_name, args, kwargs, use_cache=config.cache_converted_graphs</span>
<span class="gi">+            )</span>
<span class="gi">+            result = getattr(backend, self.name)(*converted_args, **converted_kwargs)</span>
<span class="gi">+        except (NotImplementedError, nx.NetworkXNotImplemented) as exc:</span>
<span class="gi">+            if fallback_to_nx:</span>
<span class="gi">+                return self.orig_func(*args, **kwargs)</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _convert_and_call_for_tests(</span>
<span class="gi">+        self, backend_name, args, kwargs, *, fallback_to_nx=False</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Call this dispatchable function with a backend; for use with testing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        backend = _load_backend(backend_name)</span>
<span class="gi">+        if not self._can_backend_run(backend_name, *args, **kwargs):</span>
<span class="gi">+            if fallback_to_nx or not self.graphs:</span>
<span class="gi">+                return self.orig_func(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            import pytest</span>
<span class="gi">+</span>
<span class="gi">+            msg = f&quot;&#39;{self.name}&#39; not implemented by {backend_name}&quot;</span>
<span class="gi">+            if hasattr(backend, self.name):</span>
<span class="gi">+                msg += &quot; with the given arguments&quot;</span>
<span class="gi">+            pytest.xfail(msg)</span>
<span class="gi">+</span>
<span class="gi">+        from collections.abc import Iterable, Iterator, Mapping</span>
<span class="gi">+        from copy import copy</span>
<span class="gi">+        from io import BufferedReader, BytesIO, StringIO, TextIOWrapper</span>
<span class="gi">+        from itertools import tee</span>
<span class="gi">+        from random import Random</span>
<span class="gi">+</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+        from numpy.random import Generator, RandomState</span>
<span class="gi">+        from scipy.sparse import sparray</span>
<span class="gi">+</span>
<span class="gi">+        # We sometimes compare the backend result to the original result,</span>
<span class="gi">+        # so we need two sets of arguments. We tee iterators and copy</span>
<span class="gi">+        # random state so that they may be used twice.</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            args1 = args2 = args</span>
<span class="gi">+        else:</span>
<span class="gi">+            args1, args2 = zip(</span>
<span class="gi">+                *(</span>
<span class="gi">+                    (arg, copy(arg))</span>
<span class="gi">+                    if isinstance(</span>
<span class="gi">+                        arg, BytesIO | StringIO | Random | Generator | RandomState</span>
<span class="gi">+                    )</span>
<span class="gi">+                    else tee(arg)</span>
<span class="gi">+                    if isinstance(arg, Iterator)</span>
<span class="gi">+                    and not isinstance(arg, BufferedReader | TextIOWrapper)</span>
<span class="gi">+                    else (arg, arg)</span>
<span class="gi">+                    for arg in args</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        if not kwargs:</span>
<span class="gi">+            kwargs1 = kwargs2 = kwargs</span>
<span class="gi">+        else:</span>
<span class="gi">+            kwargs1, kwargs2 = zip(</span>
<span class="gi">+                *(</span>
<span class="gi">+                    ((k, v), (k, copy(v)))</span>
<span class="gi">+                    if isinstance(</span>
<span class="gi">+                        v, BytesIO | StringIO | Random | Generator | RandomState</span>
<span class="gi">+                    )</span>
<span class="gi">+                    else ((k, (teed := tee(v))[0]), (k, teed[1]))</span>
<span class="gi">+                    if isinstance(v, Iterator)</span>
<span class="gi">+                    and not isinstance(v, BufferedReader | TextIOWrapper)</span>
<span class="gi">+                    else ((k, v), (k, v))</span>
<span class="gi">+                    for k, v in kwargs.items()</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            kwargs1 = dict(kwargs1)</span>
<span class="gi">+            kwargs2 = dict(kwargs2)</span>
<span class="gi">+        try:</span>
<span class="gi">+            converted_args, converted_kwargs = self._convert_arguments(</span>
<span class="gi">+                backend_name, args1, kwargs1, use_cache=False</span>
<span class="gi">+            )</span>
<span class="gi">+            result = getattr(backend, self.name)(*converted_args, **converted_kwargs)</span>
<span class="gi">+        except (NotImplementedError, nx.NetworkXNotImplemented) as exc:</span>
<span class="gi">+            if fallback_to_nx:</span>
<span class="gi">+                return self.orig_func(*args2, **kwargs2)</span>
<span class="gi">+            import pytest</span>
<span class="gi">+</span>
<span class="gi">+            pytest.xfail(</span>
<span class="gi">+                exc.args[0] if exc.args else f&quot;{self.name} raised {type(exc).__name__}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        # Verify that `self._returns_graph` is correct. This compares the return type</span>
<span class="gi">+        # to the type expected from `self._returns_graph`. This handles tuple and list</span>
<span class="gi">+        # return types, but *does not* catch functions that yield graphs.</span>
<span class="gi">+        if (</span>
<span class="gi">+            self._returns_graph</span>
<span class="gi">+            != (</span>
<span class="gi">+                isinstance(result, nx.Graph)</span>
<span class="gi">+                or hasattr(result, &quot;__networkx_backend__&quot;)</span>
<span class="gi">+                or isinstance(result, tuple | list)</span>
<span class="gi">+                and any(</span>
<span class="gi">+                    isinstance(x, nx.Graph) or hasattr(x, &quot;__networkx_backend__&quot;)</span>
<span class="gi">+                    for x in result</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            and not (</span>
<span class="gi">+                # May return Graph or None</span>
<span class="gi">+                self.name in {&quot;check_planarity&quot;, &quot;check_planarity_recursive&quot;}</span>
<span class="gi">+                and any(x is None for x in result)</span>
<span class="gi">+            )</span>
<span class="gi">+            and not (</span>
<span class="gi">+                # May return Graph or dict</span>
<span class="gi">+                self.name in {&quot;held_karp_ascent&quot;}</span>
<span class="gi">+                and any(isinstance(x, dict) for x in result)</span>
<span class="gi">+            )</span>
<span class="gi">+            and self.name</span>
<span class="gi">+            not in {</span>
<span class="gi">+                # yields graphs</span>
<span class="gi">+                &quot;all_triads&quot;,</span>
<span class="gi">+                &quot;general_k_edge_subgraphs&quot;,</span>
<span class="gi">+                # yields graphs or arrays</span>
<span class="gi">+                &quot;nonisomorphic_trees&quot;,</span>
<span class="gi">+            }</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise RuntimeError(f&quot;`returns_graph` is incorrect for {self.name}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def check_result(val, depth=0):</span>
<span class="gi">+            if isinstance(val, np.number):</span>
<span class="gi">+                raise RuntimeError(</span>
<span class="gi">+                    f&quot;{self.name} returned a numpy scalar {val} ({type(val)}, depth={depth})&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if isinstance(val, np.ndarray | sparray):</span>
<span class="gi">+                return</span>
<span class="gi">+            if isinstance(val, nx.Graph):</span>
<span class="gi">+                check_result(val._node, depth=depth + 1)</span>
<span class="gi">+                check_result(val._adj, depth=depth + 1)</span>
<span class="gi">+                return</span>
<span class="gi">+            if isinstance(val, Iterator):</span>
<span class="gi">+                raise NotImplementedError</span>
<span class="gi">+            if isinstance(val, Iterable) and not isinstance(val, str):</span>
<span class="gi">+                for x in val:</span>
<span class="gi">+                    check_result(x, depth=depth + 1)</span>
<span class="gi">+            if isinstance(val, Mapping):</span>
<span class="gi">+                for x in val.values():</span>
<span class="gi">+                    check_result(x, depth=depth + 1)</span>
<span class="gi">+</span>
<span class="gi">+        def check_iterator(it):</span>
<span class="gi">+            for val in it:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    check_result(val)</span>
<span class="gi">+                except RuntimeError as exc:</span>
<span class="gi">+                    raise RuntimeError(</span>
<span class="gi">+                        f&quot;{self.name} returned a numpy scalar {val} ({type(val)})&quot;</span>
<span class="gi">+                    ) from exc</span>
<span class="gi">+                yield val</span>
<span class="gi">+</span>
<span class="gi">+        if self.name in {&quot;from_edgelist&quot;}:</span>
<span class="gi">+            # numpy scalars are explicitly given as values in some tests</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif isinstance(result, Iterator):</span>
<span class="gi">+            result = check_iterator(result)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                check_result(result)</span>
<span class="gi">+            except RuntimeError as exc:</span>
<span class="gi">+                raise RuntimeError(</span>
<span class="gi">+                    f&quot;{self.name} returned a numpy scalar {result} ({type(result)})&quot;</span>
<span class="gi">+                ) from exc</span>
<span class="gi">+            check_result(result)</span>
<span class="gi">+</span>
<span class="gi">+        if self.name in {</span>
<span class="gi">+            &quot;edmonds_karp&quot;,</span>
<span class="gi">+            &quot;barycenter&quot;,</span>
<span class="gi">+            &quot;contracted_edge&quot;,</span>
<span class="gi">+            &quot;contracted_nodes&quot;,</span>
<span class="gi">+            &quot;stochastic_graph&quot;,</span>
<span class="gi">+            &quot;relabel_nodes&quot;,</span>
<span class="gi">+            &quot;maximum_branching&quot;,</span>
<span class="gi">+            &quot;incremental_closeness_centrality&quot;,</span>
<span class="gi">+            &quot;minimal_branching&quot;,</span>
<span class="gi">+            &quot;minimum_spanning_arborescence&quot;,</span>
<span class="gi">+            &quot;recursive_simple_cycles&quot;,</span>
<span class="gi">+            &quot;connected_double_edge_swap&quot;,</span>
<span class="gi">+        }:</span>
<span class="gi">+            # Special-case algorithms that mutate input graphs</span>
<span class="gi">+            bound = self.__signature__.bind(*converted_args, **converted_kwargs)</span>
<span class="gi">+            bound.apply_defaults()</span>
<span class="gi">+            bound2 = self.__signature__.bind(*args2, **kwargs2)</span>
<span class="gi">+            bound2.apply_defaults()</span>
<span class="gi">+            if self.name in {</span>
<span class="gi">+                &quot;minimal_branching&quot;,</span>
<span class="gi">+                &quot;minimum_spanning_arborescence&quot;,</span>
<span class="gi">+                &quot;recursive_simple_cycles&quot;,</span>
<span class="gi">+                &quot;connected_double_edge_swap&quot;,</span>
<span class="gi">+            }:</span>
<span class="gi">+                G1 = backend.convert_to_nx(bound.arguments[&quot;G&quot;])</span>
<span class="gi">+                G2 = bound2.arguments[&quot;G&quot;]</span>
<span class="gi">+                G2._adj = G1._adj</span>
<span class="gi">+                nx._clear_cache(G2)</span>
<span class="gi">+            elif self.name == &quot;edmonds_karp&quot;:</span>
<span class="gi">+                R1 = backend.convert_to_nx(bound.arguments[&quot;residual&quot;])</span>
<span class="gi">+                R2 = bound2.arguments[&quot;residual&quot;]</span>
<span class="gi">+                if R1 is not None and R2 is not None:</span>
<span class="gi">+                    for k, v in R1.edges.items():</span>
<span class="gi">+                        R2.edges[k][&quot;flow&quot;] = v[&quot;flow&quot;]</span>
<span class="gi">+                    R2.graph.update(R1.graph)</span>
<span class="gi">+                    nx._clear_cache(R2)</span>
<span class="gi">+            elif self.name == &quot;barycenter&quot; and bound.arguments[&quot;attr&quot;] is not None:</span>
<span class="gi">+                G1 = backend.convert_to_nx(bound.arguments[&quot;G&quot;])</span>
<span class="gi">+                G2 = bound2.arguments[&quot;G&quot;]</span>
<span class="gi">+                attr = bound.arguments[&quot;attr&quot;]</span>
<span class="gi">+                for k, v in G1.nodes.items():</span>
<span class="gi">+                    G2.nodes[k][attr] = v[attr]</span>
<span class="gi">+                nx._clear_cache(G2)</span>
<span class="gi">+            elif (</span>
<span class="gi">+                self.name in {&quot;contracted_nodes&quot;, &quot;contracted_edge&quot;}</span>
<span class="gi">+                and not bound.arguments[&quot;copy&quot;]</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Edges and nodes changed; node &quot;contraction&quot; and edge &quot;weight&quot; attrs</span>
<span class="gi">+                G1 = backend.convert_to_nx(bound.arguments[&quot;G&quot;])</span>
<span class="gi">+                G2 = bound2.arguments[&quot;G&quot;]</span>
<span class="gi">+                G2.__dict__.update(G1.__dict__)</span>
<span class="gi">+                nx._clear_cache(G2)</span>
<span class="gi">+            elif self.name == &quot;stochastic_graph&quot; and not bound.arguments[&quot;copy&quot;]:</span>
<span class="gi">+                G1 = backend.convert_to_nx(bound.arguments[&quot;G&quot;])</span>
<span class="gi">+                G2 = bound2.arguments[&quot;G&quot;]</span>
<span class="gi">+                for k, v in G1.edges.items():</span>
<span class="gi">+                    G2.edges[k][&quot;weight&quot;] = v[&quot;weight&quot;]</span>
<span class="gi">+                nx._clear_cache(G2)</span>
<span class="gi">+            elif (</span>
<span class="gi">+                self.name == &quot;relabel_nodes&quot;</span>
<span class="gi">+                and not bound.arguments[&quot;copy&quot;]</span>
<span class="gi">+                or self.name in {&quot;incremental_closeness_centrality&quot;}</span>
<span class="gi">+            ):</span>
<span class="gi">+                G1 = backend.convert_to_nx(bound.arguments[&quot;G&quot;])</span>
<span class="gi">+                G2 = bound2.arguments[&quot;G&quot;]</span>
<span class="gi">+                if G1 is G2:</span>
<span class="gi">+                    return G2</span>
<span class="gi">+                G2._node.clear()</span>
<span class="gi">+                G2._node.update(G1._node)</span>
<span class="gi">+                G2._adj.clear()</span>
<span class="gi">+                G2._adj.update(G1._adj)</span>
<span class="gi">+                if hasattr(G1, &quot;_pred&quot;) and hasattr(G2, &quot;_pred&quot;):</span>
<span class="gi">+                    G2._pred.clear()</span>
<span class="gi">+                    G2._pred.update(G1._pred)</span>
<span class="gi">+                if hasattr(G1, &quot;_succ&quot;) and hasattr(G2, &quot;_succ&quot;):</span>
<span class="gi">+                    G2._succ.clear()</span>
<span class="gi">+                    G2._succ.update(G1._succ)</span>
<span class="gi">+                nx._clear_cache(G2)</span>
<span class="gi">+                if self.name == &quot;relabel_nodes&quot;:</span>
<span class="gi">+                    return G2</span>
<span class="gi">+            return backend.convert_to_nx(result)</span>
<span class="gi">+</span>
<span class="gi">+        converted_result = backend.convert_to_nx(result)</span>
<span class="gi">+        if isinstance(converted_result, nx.Graph) and self.name not in {</span>
<span class="gi">+            &quot;boykov_kolmogorov&quot;,</span>
<span class="gi">+            &quot;preflow_push&quot;,</span>
<span class="gi">+            &quot;quotient_graph&quot;,</span>
<span class="gi">+            &quot;shortest_augmenting_path&quot;,</span>
<span class="gi">+            &quot;spectral_graph_forge&quot;,</span>
<span class="gi">+            # We don&#39;t handle tempfile.NamedTemporaryFile arguments</span>
<span class="gi">+            &quot;read_gml&quot;,</span>
<span class="gi">+            &quot;read_graph6&quot;,</span>
<span class="gi">+            &quot;read_sparse6&quot;,</span>
<span class="gi">+            # We don&#39;t handle io.BufferedReader or io.TextIOWrapper arguments</span>
<span class="gi">+            &quot;bipartite_read_edgelist&quot;,</span>
<span class="gi">+            &quot;read_adjlist&quot;,</span>
<span class="gi">+            &quot;read_edgelist&quot;,</span>
<span class="gi">+            &quot;read_graphml&quot;,</span>
<span class="gi">+            &quot;read_multiline_adjlist&quot;,</span>
<span class="gi">+            &quot;read_pajek&quot;,</span>
<span class="gi">+            &quot;from_pydot&quot;,</span>
<span class="gi">+            &quot;pydot_read_dot&quot;,</span>
<span class="gi">+            &quot;agraph_read_dot&quot;,</span>
<span class="gi">+            # graph comparison fails b/c of nan values</span>
<span class="gi">+            &quot;read_gexf&quot;,</span>
<span class="gi">+        }:</span>
<span class="gi">+            # For graph return types (e.g. generators), we compare that results are</span>
<span class="gi">+            # the same between the backend and networkx, then return the original</span>
<span class="gi">+            # networkx result so the iteration order will be consistent in tests.</span>
<span class="gi">+            G = self.orig_func(*args2, **kwargs2)</span>
<span class="gi">+            if not nx.utils.graphs_equal(G, converted_result):</span>
<span class="gi">+                assert G.number_of_nodes() == converted_result.number_of_nodes()</span>
<span class="gi">+                assert G.number_of_edges() == converted_result.number_of_edges()</span>
<span class="gi">+                assert G.graph == converted_result.graph</span>
<span class="gi">+                assert G.nodes == converted_result.nodes</span>
<span class="gi">+                assert G.adj == converted_result.adj</span>
<span class="gi">+                assert type(G) is type(converted_result)</span>
<span class="gi">+                raise AssertionError(&quot;Graphs are not equal&quot;)</span>
<span class="gi">+            return G</span>
<span class="gi">+        return converted_result</span>

<span class="w"> </span>    def _make_doc(self):
<span class="w"> </span>        &quot;&quot;&quot;Generate the backends section at the end for functions having an alternate
<span class="w"> </span>        backend implementation(s) using the `backend_info` entry-point.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if not self.backends:</span>
<span class="gi">+            return self._orig_doc</span>
<span class="gi">+        lines = [</span>
<span class="gi">+            &quot;Backends&quot;,</span>
<span class="gi">+            &quot;--------&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+        for backend in sorted(self.backends):</span>
<span class="gi">+            info = backend_info[backend]</span>
<span class="gi">+            if &quot;short_summary&quot; in info:</span>
<span class="gi">+                lines.append(f&quot;{backend} : {info[&#39;short_summary&#39;]}&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(backend)</span>
<span class="gi">+            if &quot;functions&quot; not in info or self.name not in info[&quot;functions&quot;]:</span>
<span class="gi">+                lines.append(&quot;&quot;)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            func_info = info[&quot;functions&quot;][self.name]</span>
<span class="gi">+</span>
<span class="gi">+            # Renaming extra_docstring to additional_docs</span>
<span class="gi">+            if func_docs := (</span>
<span class="gi">+                func_info.get(&quot;additional_docs&quot;) or func_info.get(&quot;extra_docstring&quot;)</span>
<span class="gi">+            ):</span>
<span class="gi">+                lines.extend(</span>
<span class="gi">+                    f&quot;  {line}&quot; if line else line for line in func_docs.split(&quot;\n&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+                add_gap = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                add_gap = False</span>
<span class="gi">+</span>
<span class="gi">+            # Renaming extra_parameters to additional_parameters</span>
<span class="gi">+            if extra_parameters := (</span>
<span class="gi">+                func_info.get(&quot;extra_parameters&quot;)</span>
<span class="gi">+                or func_info.get(&quot;additional_parameters&quot;)</span>
<span class="gi">+            ):</span>
<span class="gi">+                if add_gap:</span>
<span class="gi">+                    lines.append(&quot;&quot;)</span>
<span class="gi">+                lines.append(&quot;  Additional parameters:&quot;)</span>
<span class="gi">+                for param in sorted(extra_parameters):</span>
<span class="gi">+                    lines.append(f&quot;    {param}&quot;)</span>
<span class="gi">+                    if desc := extra_parameters[param]:</span>
<span class="gi">+                        lines.append(f&quot;      {desc}&quot;)</span>
<span class="gi">+                    lines.append(&quot;&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if func_url := func_info.get(&quot;url&quot;):</span>
<span class="gi">+                lines.append(f&quot;[`Source &lt;{func_url}&gt;`_]&quot;)</span>
<span class="gi">+                lines.append(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        lines.pop()  # Remove last empty line</span>
<span class="gi">+        to_add = &quot;\n    &quot;.join(lines)</span>
<span class="gi">+        return f&quot;{self._orig_doc.rstrip()}\n\n    {to_add}&quot;</span>

<span class="w"> </span>    def __reduce__(self):
<span class="w"> </span>        &quot;&quot;&quot;Allow this object to be serialized with pickle.
<span class="gu">@@ -631,9 +1527,27 @@ class _dispatchable:</span>
<span class="w"> </span>        return _restore_dispatchable, (self.name,)


<span class="gd">-if os.environ.get(&#39;_NETWORKX_BUILDING_DOCS_&#39;):</span>
<span class="gi">+def _restore_dispatchable(name):</span>
<span class="gi">+    return _registered_algorithms[name]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if os.environ.get(&quot;_NETWORKX_BUILDING_DOCS_&quot;):</span>
<span class="gi">+    # When building docs with Sphinx, use the original function with the</span>
<span class="gi">+    # dispatched __doc__, b/c Sphinx renders normal Python functions better.</span>
<span class="gi">+    # This doesn&#39;t show e.g. `*, backend=None, **backend_kwargs` in the</span>
<span class="gi">+    # signatures, which is probably okay. It does allow the docstring to be</span>
<span class="gi">+    # updated based on the installed backends.</span>
<span class="w"> </span>    _orig_dispatchable = _dispatchable
<span class="gd">-    _dispatchable.__doc__ = _orig_dispatchable.__new__.__doc__</span>
<span class="gi">+</span>
<span class="gi">+    def _dispatchable(func=None, **kwargs):  # type: ignore[no-redef]</span>
<span class="gi">+        if func is None:</span>
<span class="gi">+            return partial(_dispatchable, **kwargs)</span>
<span class="gi">+        dispatched_func = _orig_dispatchable(func, **kwargs)</span>
<span class="gi">+        func.__doc__ = dispatched_func.__doc__</span>
<span class="gi">+        return func</span>
<span class="gi">+</span>
<span class="gi">+    _dispatchable.__doc__ = _orig_dispatchable.__new__.__doc__  # type: ignore[method-assign,assignment]</span>
<span class="w"> </span>    _sig = inspect.signature(_orig_dispatchable.__new__)
<span class="gd">-    _dispatchable.__signature__ = _sig.replace(parameters=[v for k, v in</span>
<span class="gd">-        _sig.parameters.items() if k != &#39;cls&#39;])</span>
<span class="gi">+    _dispatchable.__signature__ = _sig.replace(  # type: ignore[method-assign,assignment]</span>
<span class="gi">+        parameters=[v for k, v in _sig.parameters.items() if k != &quot;cls&quot;]</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/networkx/utils/configs.py b/networkx/utils/configs.py</span>
<span class="gh">index 78a483d3f..e61741e0a 100644</span>
<span class="gd">--- a/networkx/utils/configs.py</span>
<span class="gi">+++ b/networkx/utils/configs.py</span>
<span class="gu">@@ -2,7 +2,8 @@ import collections</span>
<span class="w"> </span>import os
<span class="w"> </span>import typing
<span class="w"> </span>from dataclasses import dataclass
<span class="gd">-__all__ = [&#39;Config&#39;, &#39;config&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;Config&quot;, &quot;config&quot;]</span>


<span class="w"> </span>@dataclass(init=False, eq=False, slots=True, kw_only=True, match_args=False)
<span class="gu">@@ -63,27 +64,36 @@ class Config:</span>
<span class="w"> </span>    def __new__(cls, **kwargs):
<span class="w"> </span>        orig_class = cls
<span class="w"> </span>        if cls is Config:
<span class="gd">-            cls = type(cls.__name__, (cls,), {&#39;__annotations__&#39;: {key:</span>
<span class="gd">-                typing.Any for key in kwargs}})</span>
<span class="gd">-        cls = dataclass(eq=False, repr=cls._strict, slots=cls._strict,</span>
<span class="gd">-            kw_only=True, match_args=False)(cls)</span>
<span class="gi">+            # Enable the &quot;simple&quot; case of accepting config definition as keywords</span>
<span class="gi">+            cls = type(</span>
<span class="gi">+                cls.__name__,</span>
<span class="gi">+                (cls,),</span>
<span class="gi">+                {&quot;__annotations__&quot;: {key: typing.Any for key in kwargs}},</span>
<span class="gi">+            )</span>
<span class="gi">+        cls = dataclass(</span>
<span class="gi">+            eq=False,</span>
<span class="gi">+            repr=cls._strict,</span>
<span class="gi">+            slots=cls._strict,</span>
<span class="gi">+            kw_only=True,</span>
<span class="gi">+            match_args=False,</span>
<span class="gi">+        )(cls)</span>
<span class="w"> </span>        if not cls._strict:
<span class="w"> </span>            cls.__repr__ = _flexible_repr
<span class="gd">-        cls._orig_class = orig_class</span>
<span class="gi">+        cls._orig_class = orig_class  # Save original class so we can pickle</span>
<span class="w"> </span>        instance = object.__new__(cls)
<span class="w"> </span>        instance.__init__(**kwargs)
<span class="w"> </span>        return instance

<span class="w"> </span>    def _check_config(self, key, value):
<span class="w"> </span>        &quot;&quot;&quot;Check whether config value is valid. This is useful for subclasses.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gi">+    # Control behavior of attributes</span>
<span class="w"> </span>    def __dir__(self):
<span class="w"> </span>        return self.__dataclass_fields__.keys()

<span class="w"> </span>    def __setattr__(self, key, value):
<span class="w"> </span>        if self._strict and key not in self.__dataclass_fields__:
<span class="gd">-            raise AttributeError(f&#39;Invalid config name: {key!r}&#39;)</span>
<span class="gi">+            raise AttributeError(f&quot;Invalid config name: {key!r}&quot;)</span>
<span class="w"> </span>        self._check_config(key, value)
<span class="w"> </span>        object.__setattr__(self, key, value)

<span class="gu">@@ -91,25 +101,25 @@ class Config:</span>
<span class="w"> </span>        if self._strict:
<span class="w"> </span>            raise TypeError(
<span class="w"> </span>                f&quot;Configuration items can&#39;t be deleted (can&#39;t delete {key!r}).&quot;
<span class="gd">-                )</span>
<span class="gi">+            )</span>
<span class="w"> </span>        object.__delattr__(self, key)

<span class="gi">+    # Be a `collection.abc.Collection`</span>
<span class="w"> </span>    def __contains__(self, key):
<span class="gd">-        return (key in self.__dataclass_fields__ if self._strict else key in</span>
<span class="gd">-            self.__dict__)</span>
<span class="gi">+        return (</span>
<span class="gi">+            key in self.__dataclass_fields__ if self._strict else key in self.__dict__</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __iter__(self):
<span class="gd">-        return iter(self.__dataclass_fields__ if self._strict else self.</span>
<span class="gd">-            __dict__)</span>
<span class="gi">+        return iter(self.__dataclass_fields__ if self._strict else self.__dict__)</span>

<span class="w"> </span>    def __len__(self):
<span class="gd">-        return len(self.__dataclass_fields__ if self._strict else self.__dict__</span>
<span class="gd">-            )</span>
<span class="gi">+        return len(self.__dataclass_fields__ if self._strict else self.__dict__)</span>

<span class="w"> </span>    def __reversed__(self):
<span class="gd">-        return reversed(self.__dataclass_fields__ if self._strict else self</span>
<span class="gd">-            .__dict__)</span>
<span class="gi">+        return reversed(self.__dataclass_fields__ if self._strict else self.__dict__)</span>

<span class="gi">+    # Add dunder methods for `collections.abc.Mapping`</span>
<span class="w"> </span>    def __getitem__(self, key):
<span class="w"> </span>        try:
<span class="w"> </span>            return getattr(self, key)
<span class="gu">@@ -127,18 +137,46 @@ class Config:</span>
<span class="w"> </span>            self.__delattr__(key)
<span class="w"> </span>        except AttributeError as err:
<span class="w"> </span>            raise KeyError(*err.args) from None
<span class="gd">-    _ipython_key_completions_ = __dir__</span>

<span class="gi">+    _ipython_key_completions_ = __dir__  # config[&quot;&lt;TAB&gt;</span>
<span class="gi">+</span>
<span class="gi">+    # Go ahead and make it a `collections.abc.Mapping`</span>
<span class="gi">+    def get(self, key, default=None):</span>
<span class="gi">+        return getattr(self, key, default)</span>
<span class="gi">+</span>
<span class="gi">+    def items(self):</span>
<span class="gi">+        return collections.abc.ItemsView(self)</span>
<span class="gi">+</span>
<span class="gi">+    def keys(self):</span>
<span class="gi">+        return collections.abc.KeysView(self)</span>
<span class="gi">+</span>
<span class="gi">+    def values(self):</span>
<span class="gi">+        return collections.abc.ValuesView(self)</span>
<span class="gi">+</span>
<span class="gi">+    # dataclass can define __eq__ for us, but do it here so it works after pickling</span>
<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, Config):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return self._orig_class == other._orig_class and self.items(</span>
<span class="gd">-            ) == other.items()</span>
<span class="gi">+        return self._orig_class == other._orig_class and self.items() == other.items()</span>

<span class="gi">+    # Make pickle work</span>
<span class="w"> </span>    def __reduce__(self):
<span class="w"> </span>        return self._deserialize, (self._orig_class, dict(self))

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _deserialize(cls, kwargs):</span>
<span class="gi">+        return cls(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _flexible_repr(self):</span>
<span class="gi">+    return (</span>
<span class="gi">+        f&quot;{self.__class__.__qualname__}(&quot;</span>
<span class="gi">+        + &quot;, &quot;.join(f&quot;{key}={val!r}&quot; for key, val in self.__dict__.items())</span>
<span class="gi">+        + &quot;)&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>

<span class="gi">+# Register, b/c `Mapping.__subclasshook__` returns `NotImplemented`</span>
<span class="w"> </span>collections.abc.Mapping.register(Config)


<span class="gu">@@ -181,11 +219,42 @@ class NetworkXConfig(Config):</span>

<span class="w"> </span>    This is a global configuration. Use with caution when using from multiple threads.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    backend_priority: list[str]
<span class="w"> </span>    backends: Config
<span class="w"> </span>    cache_converted_graphs: bool

<span class="gi">+    def _check_config(self, key, value):</span>
<span class="gi">+        from .backends import backends</span>

<span class="gd">-config = NetworkXConfig(backend_priority=[], backends=Config(),</span>
<span class="gd">-    cache_converted_graphs=bool(os.environ.get(</span>
<span class="gd">-    &#39;NETWORKX_CACHE_CONVERTED_GRAPHS&#39;, &#39;&#39;)))</span>
<span class="gi">+        if key == &quot;backend_priority&quot;:</span>
<span class="gi">+            if not (isinstance(value, list) and all(isinstance(x, str) for x in value)):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;{key!r} config must be a list of backend names; got {value!r}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if missing := {x for x in value if x not in backends}:</span>
<span class="gi">+                missing = &quot;, &quot;.join(map(repr, sorted(missing)))</span>
<span class="gi">+                raise ValueError(f&quot;Unknown backend when setting {key!r}: {missing}&quot;)</span>
<span class="gi">+        elif key == &quot;backends&quot;:</span>
<span class="gi">+            if not (</span>
<span class="gi">+                isinstance(value, Config)</span>
<span class="gi">+                and all(isinstance(key, str) for key in value)</span>
<span class="gi">+                and all(isinstance(val, Config) for val in value.values())</span>
<span class="gi">+            ):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    f&quot;{key!r} config must be a Config of backend configs; got {value!r}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if missing := {x for x in value if x not in backends}:</span>
<span class="gi">+                missing = &quot;, &quot;.join(map(repr, sorted(missing)))</span>
<span class="gi">+                raise ValueError(f&quot;Unknown backend when setting {key!r}: {missing}&quot;)</span>
<span class="gi">+        elif key == &quot;cache_converted_graphs&quot;:</span>
<span class="gi">+            if not isinstance(value, bool):</span>
<span class="gi">+                raise TypeError(f&quot;{key!r} config must be True or False; got {value!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Backend configuration will be updated in backends.py</span>
<span class="gi">+config = NetworkXConfig(</span>
<span class="gi">+    backend_priority=[],</span>
<span class="gi">+    backends=Config(),</span>
<span class="gi">+    cache_converted_graphs=bool(os.environ.get(&quot;NETWORKX_CACHE_CONVERTED_GRAPHS&quot;, &quot;&quot;)),</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/networkx/utils/decorators.py b/networkx/utils/decorators.py</span>
<span class="gh">index 0e85b150b..205bf5005 100644</span>
<span class="gd">--- a/networkx/utils/decorators.py</span>
<span class="gi">+++ b/networkx/utils/decorators.py</span>
<span class="gu">@@ -11,11 +11,19 @@ from functools import wraps</span>
<span class="w"> </span>from inspect import Parameter, signature
<span class="w"> </span>from os.path import splitext
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import create_py_random_state, create_random_state
<span class="gd">-__all__ = [&#39;not_implemented_for&#39;, &#39;open_file&#39;, &#39;nodes_or_number&#39;,</span>
<span class="gd">-    &#39;np_random_state&#39;, &#39;py_random_state&#39;, &#39;argmap&#39;, &#39;deprecate_positional_args&#39;</span>
<span class="gd">-    ]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;not_implemented_for&quot;,</span>
<span class="gi">+    &quot;open_file&quot;,</span>
<span class="gi">+    &quot;nodes_or_number&quot;,</span>
<span class="gi">+    &quot;np_random_state&quot;,</span>
<span class="gi">+    &quot;py_random_state&quot;,</span>
<span class="gi">+    &quot;argmap&quot;,</span>
<span class="gi">+    &quot;deprecate_positional_args&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>def not_implemented_for(*graph_types):
<span class="gu">@@ -62,14 +70,43 @@ def not_implemented_for(*graph_types):</span>
<span class="w"> </span>       def sp_np_function(G):
<span class="w"> </span>           pass
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-fopeners = {&#39;.gz&#39;: gzip.open, &#39;.gzip&#39;: gzip.open, &#39;.bz2&#39;: bz2.BZ2File}</span>
<span class="gd">-_dispatch_dict = defaultdict(lambda : open, **fopeners)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def open_file(path_arg, mode=&#39;r&#39;):</span>
<span class="gi">+    if (&quot;directed&quot; in graph_types) and (&quot;undirected&quot; in graph_types):</span>
<span class="gi">+        raise ValueError(&quot;Function not implemented on directed AND undirected graphs?&quot;)</span>
<span class="gi">+    if (&quot;multigraph&quot; in graph_types) and (&quot;graph&quot; in graph_types):</span>
<span class="gi">+        raise ValueError(&quot;Function not implemented on graph AND multigraphs?&quot;)</span>
<span class="gi">+    if not set(graph_types) &lt; {&quot;directed&quot;, &quot;undirected&quot;, &quot;multigraph&quot;, &quot;graph&quot;}:</span>
<span class="gi">+        raise KeyError(</span>
<span class="gi">+            &quot;use one or more of directed, undirected, multigraph, graph.  &quot;</span>
<span class="gi">+            f&quot;You used {graph_types}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # 3-way logic: True if &quot;directed&quot; input, False if &quot;undirected&quot; input, else None</span>
<span class="gi">+    dval = (&quot;directed&quot; in graph_types) or &quot;undirected&quot; not in graph_types and None</span>
<span class="gi">+    mval = (&quot;multigraph&quot; in graph_types) or &quot;graph&quot; not in graph_types and None</span>
<span class="gi">+    errmsg = f&quot;not implemented for {&#39; &#39;.join(graph_types)} type&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _not_implemented_for(g):</span>
<span class="gi">+        if (mval is None or mval == g.is_multigraph()) and (</span>
<span class="gi">+            dval is None or dval == g.is_directed()</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise nx.NetworkXNotImplemented(errmsg)</span>
<span class="gi">+</span>
<span class="gi">+        return g</span>
<span class="gi">+</span>
<span class="gi">+    return argmap(_not_implemented_for, 0)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# To handle new extensions, define a function accepting a `path` and `mode`.</span>
<span class="gi">+# Then add the extension to _dispatch_dict.</span>
<span class="gi">+fopeners = {</span>
<span class="gi">+    &quot;.gz&quot;: gzip.open,</span>
<span class="gi">+    &quot;.gzip&quot;: gzip.open,</span>
<span class="gi">+    &quot;.bz2&quot;: bz2.BZ2File,</span>
<span class="gi">+}</span>
<span class="gi">+_dispatch_dict = defaultdict(lambda: open, **fopeners)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def open_file(path_arg, mode=&quot;r&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator to ensure clean opening and closing of files.

<span class="w"> </span>    Parameters
<span class="gu">@@ -144,7 +181,25 @@ def open_file(path_arg, mode=&#39;r&#39;):</span>
<span class="w"> </span>    Instead, we use a try block, as shown above.
<span class="w"> </span>    When we exit the function, fobj will be closed, if it should be, by the decorator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _open_file(path):</span>
<span class="gi">+        # Now we have the path_arg. There are two types of input to consider:</span>
<span class="gi">+        #   1) string representing a path that should be opened</span>
<span class="gi">+        #   2) an already opened file object</span>
<span class="gi">+        if isinstance(path, str):</span>
<span class="gi">+            ext = splitext(path)[1]</span>
<span class="gi">+        elif isinstance(path, Path):</span>
<span class="gi">+            # path is a pathlib reference to a filename</span>
<span class="gi">+            ext = path.suffix</span>
<span class="gi">+            path = str(path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # could be None, or a file handle, in which case the algorithm will deal with it</span>
<span class="gi">+            return path, lambda: None</span>
<span class="gi">+</span>
<span class="gi">+        fobj = _dispatch_dict[ext](path, mode=mode)</span>
<span class="gi">+        return fobj, lambda: fobj.close()</span>
<span class="gi">+</span>
<span class="gi">+    return argmap(_open_file, path_arg, try_finally=True)</span>


<span class="w"> </span>def nodes_or_number(which_args):
<span class="gu">@@ -192,7 +247,23 @@ def nodes_or_number(which_args):</span>
<span class="w"> </span>           # presumably r is a number. It is not handled by this decorator.
<span class="w"> </span>           # n is converted to a list of nodes
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _nodes_or_number(n):</span>
<span class="gi">+        try:</span>
<span class="gi">+            nodes = list(range(n))</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            nodes = tuple(n)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if n &lt; 0:</span>
<span class="gi">+                raise nx.NetworkXError(f&quot;Negative number of nodes not valid: {n}&quot;)</span>
<span class="gi">+        return (n, nodes)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        iter_wa = iter(which_args)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        iter_wa = (which_args,)</span>
<span class="gi">+</span>
<span class="gi">+    return argmap(_nodes_or_number, *iter_wa)</span>


<span class="w"> </span>def np_random_state(random_state_argument):
<span class="gu">@@ -239,7 +310,7 @@ def np_random_state(random_state_argument):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    py_random_state
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return argmap(create_random_state, random_state_argument)</span>


<span class="w"> </span>def py_random_state(random_state_argument):
<span class="gu">@@ -298,7 +369,8 @@ def py_random_state(random_state_argument):</span>
<span class="w"> </span>    --------
<span class="w"> </span>    np_random_state
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return argmap(create_py_random_state, random_state_argument)</span>


<span class="w"> </span>class argmap:
<span class="gu">@@ -686,7 +758,11 @@ class argmap:</span>
<span class="w"> </span>        [1] https://github.com/networkx/networkx/issues/4732

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        real_func = func.__argmap__.compile(func.__wrapped__)</span>
<span class="gi">+        func.__code__ = real_func.__code__</span>
<span class="gi">+        func.__globals__.update(real_func.__globals__)</span>
<span class="gi">+        func.__dict__.update(real_func.__dict__)</span>
<span class="gi">+        return func</span>

<span class="w"> </span>    def __call__(self, f):
<span class="w"> </span>        &quot;&quot;&quot;Construct a lazily decorated wrapper of f.
<span class="gu">@@ -711,6 +787,8 @@ class argmap:</span>

<span class="w"> </span>        def func(*args, __wrapper=None, **kwargs):
<span class="w"> </span>            return argmap._lazy_compile(__wrapper)(*args, **kwargs)
<span class="gi">+</span>
<span class="gi">+        # standard function-wrapping stuff</span>
<span class="w"> </span>        func.__name__ = f.__name__
<span class="w"> </span>        func.__doc__ = f.__doc__
<span class="w"> </span>        func.__defaults__ = f.__defaults__
<span class="gu">@@ -719,17 +797,35 @@ class argmap:</span>
<span class="w"> </span>        func.__qualname__ = f.__qualname__
<span class="w"> </span>        func.__dict__.update(f.__dict__)
<span class="w"> </span>        func.__wrapped__ = f
<span class="gd">-        func.__kwdefaults__[&#39;_argmap__wrapper&#39;] = func</span>
<span class="gi">+</span>
<span class="gi">+        # now that we&#39;ve wrapped f, we may have picked up some __dict__ or</span>
<span class="gi">+        # __kwdefaults__ items that were set by a previous argmap.  Thus, we set</span>
<span class="gi">+        # these values after those update() calls.</span>
<span class="gi">+</span>
<span class="gi">+        # If we attempt to access func from within itself, that happens through</span>
<span class="gi">+        # a closure -- which trips an error when we replace func.__code__.  The</span>
<span class="gi">+        # standard workaround for functions which can&#39;t see themselves is to use</span>
<span class="gi">+        # a Y-combinator, as we do here.</span>
<span class="gi">+        func.__kwdefaults__[&quot;_argmap__wrapper&quot;] = func</span>
<span class="gi">+</span>
<span class="gi">+        # this self-reference is here because functools.wraps preserves</span>
<span class="gi">+        # everything in __dict__, and we don&#39;t want to mistake a non-argmap</span>
<span class="gi">+        # wrapper for an argmap wrapper</span>
<span class="w"> </span>        func.__self__ = func
<span class="gi">+</span>
<span class="gi">+        # this is used to variously call self.assemble and self.compile</span>
<span class="w"> </span>        func.__argmap__ = self
<span class="gd">-        if hasattr(f, &#39;__argmap__&#39;):</span>
<span class="gi">+</span>
<span class="gi">+        if hasattr(f, &quot;__argmap__&quot;):</span>
<span class="w"> </span>            func.__is_generator = f.__is_generator
<span class="w"> </span>        else:
<span class="w"> </span>            func.__is_generator = inspect.isgeneratorfunction(f)
<span class="gi">+</span>
<span class="w"> </span>        if self._finally and func.__is_generator:
<span class="gd">-            raise nx.NetworkXError(</span>
<span class="gd">-                &#39;argmap cannot decorate generators with try_finally&#39;)</span>
<span class="gi">+            raise nx.NetworkXError(&quot;argmap cannot decorate generators with try_finally&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>        return func
<span class="gi">+</span>
<span class="w"> </span>    __count = 0

<span class="w"> </span>    @classmethod
<span class="gu">@@ -750,8 +846,10 @@ class argmap:</span>
<span class="w"> </span>        count : int
<span class="w"> </span>            An integer unique to this Python session (simply counts from zero)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    _bad_chars = re.compile(&#39;[^a-zA-Z0-9_]&#39;)</span>
<span class="gi">+        cls.__count += 1</span>
<span class="gi">+        return cls.__count</span>
<span class="gi">+</span>
<span class="gi">+    _bad_chars = re.compile(&quot;[^a-zA-Z0-9_]&quot;)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _name(cls, f):
<span class="gu">@@ -769,7 +867,9 @@ class argmap:</span>
<span class="w"> </span>            The mangled version of `f.__name__` (if `f.__name__` exists) or `f`

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        f = f.__name__ if hasattr(f, &quot;__name__&quot;) else f</span>
<span class="gi">+        fname = re.sub(cls._bad_chars, &quot;_&quot;, f)</span>
<span class="gi">+        return f&quot;argmap_{fname}_{cls._count()}&quot;</span>

<span class="w"> </span>    def compile(self, f):
<span class="w"> </span>        &quot;&quot;&quot;Compile the decorated function.
<span class="gu">@@ -801,7 +901,23 @@ class argmap:</span>
<span class="w"> </span>            The decorated file

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sig, wrapped_name, functions, mapblock, finallys, mutable_args = self.assemble(</span>
<span class="gi">+            f</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        call = f&quot;{sig.call_sig.format(wrapped_name)}#&quot;</span>
<span class="gi">+        mut_args = f&quot;{sig.args} = list({sig.args})&quot; if mutable_args else &quot;&quot;</span>
<span class="gi">+        body = argmap._indent(sig.def_sig, mut_args, mapblock, call, finallys)</span>
<span class="gi">+        code = &quot;\n&quot;.join(body)</span>
<span class="gi">+</span>
<span class="gi">+        locl = {}</span>
<span class="gi">+        globl = dict(functions.values())</span>
<span class="gi">+        filename = f&quot;{self.__class__} compilation {self._count()}&quot;</span>
<span class="gi">+        compiled = compile(code, filename, &quot;exec&quot;)</span>
<span class="gi">+        exec(compiled, globl, locl)</span>
<span class="gi">+        func = locl[sig.name]</span>
<span class="gi">+        func._code = code</span>
<span class="gi">+        return func</span>

<span class="w"> </span>    def assemble(self, f):
<span class="w"> </span>        &quot;&quot;&quot;Collects components of the source for the decorated function wrapping f.
<span class="gu">@@ -843,11 +959,111 @@ class argmap:</span>
<span class="w"> </span>            via their indices. The compile method then turns the argument
<span class="w"> </span>            tuple into a list so that the arguments can be modified.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # first, we check if f is already argmapped -- if that&#39;s the case,</span>
<span class="gi">+        # build up the function recursively.</span>
<span class="gi">+        # &gt; mapblock is generally a list of function calls of the sort</span>
<span class="gi">+        #     arg = func(arg)</span>
<span class="gi">+        # in addition to some try-blocks if needed.</span>
<span class="gi">+        # &gt; finallys is a recursive list of finally blocks of the sort</span>
<span class="gi">+        #         finally:</span>
<span class="gi">+        #             close_func_1()</span>
<span class="gi">+        #     finally:</span>
<span class="gi">+        #         close_func_2()</span>
<span class="gi">+        # &gt; functions is a dict of functions used in the scope of our decorated</span>
<span class="gi">+        # function. It will be used to construct globals used in compilation.</span>
<span class="gi">+        # We make functions[id(f)] = name_of_f, f to ensure that a given</span>
<span class="gi">+        # function is stored and named exactly once even if called by</span>
<span class="gi">+        # nested decorators.</span>
<span class="gi">+        if hasattr(f, &quot;__argmap__&quot;) and f.__self__ is f:</span>
<span class="gi">+            (</span>
<span class="gi">+                sig,</span>
<span class="gi">+                wrapped_name,</span>
<span class="gi">+                functions,</span>
<span class="gi">+                mapblock,</span>
<span class="gi">+                finallys,</span>
<span class="gi">+                mutable_args,</span>
<span class="gi">+            ) = f.__argmap__.assemble(f.__wrapped__)</span>
<span class="gi">+            functions = dict(functions)  # shallow-copy just in case</span>
<span class="gi">+        else:</span>
<span class="gi">+            sig = self.signature(f)</span>
<span class="gi">+            wrapped_name = self._name(f)</span>
<span class="gi">+            mapblock, finallys = [], []</span>
<span class="gi">+            functions = {id(f): (wrapped_name, f)}</span>
<span class="gi">+            mutable_args = False</span>
<span class="gi">+</span>
<span class="gi">+        if id(self._func) in functions:</span>
<span class="gi">+            fname, _ = functions[id(self._func)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            fname, _ = functions[id(self._func)] = self._name(self._func), self._func</span>
<span class="gi">+</span>
<span class="gi">+        # this is a bit complicated -- we can call functions with a variety of</span>
<span class="gi">+        # nested arguments, so long as their input and output are tuples with</span>
<span class="gi">+        # the same nested structure. e.g. (&quot;a&quot;, &quot;b&quot;) maps arguments a and b.</span>
<span class="gi">+        # A more complicated nesting like (0, (3, 4)) maps arguments 0, 3, 4</span>
<span class="gi">+        # expecting the mapping to output new values in the same nested shape.</span>
<span class="gi">+        # The ability to argmap multiple arguments was necessary for</span>
<span class="gi">+        # the decorator `nx.algorithms.community.quality.require_partition`, and</span>
<span class="gi">+        # while we&#39;re not taking full advantage of the ability to handle</span>
<span class="gi">+        # multiply-nested tuples, it was convenient to implement this in</span>
<span class="gi">+        # generality because the recursive call to `get_name` is necessary in</span>
<span class="gi">+        # any case.</span>
<span class="gi">+        applied = set()</span>
<span class="gi">+</span>
<span class="gi">+        def get_name(arg, first=True):</span>
<span class="gi">+            nonlocal mutable_args</span>
<span class="gi">+            if isinstance(arg, tuple):</span>
<span class="gi">+                name = &quot;, &quot;.join(get_name(x, False) for x in arg)</span>
<span class="gi">+                return name if first else f&quot;({name})&quot;</span>
<span class="gi">+            if arg in applied:</span>
<span class="gi">+                raise nx.NetworkXError(f&quot;argument {arg} is specified multiple times&quot;)</span>
<span class="gi">+            applied.add(arg)</span>
<span class="gi">+            if arg in sig.names:</span>
<span class="gi">+                return sig.names[arg]</span>
<span class="gi">+            elif isinstance(arg, str):</span>
<span class="gi">+                if sig.kwargs is None:</span>
<span class="gi">+                    raise nx.NetworkXError(</span>
<span class="gi">+                        f&quot;name {arg} is not a named parameter and this function doesn&#39;t have kwargs&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                return f&quot;{sig.kwargs}[{arg!r}]&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                if sig.args is None:</span>
<span class="gi">+                    raise nx.NetworkXError(</span>
<span class="gi">+                        f&quot;index {arg} not a parameter index and this function doesn&#39;t have args&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                mutable_args = True</span>
<span class="gi">+                return f&quot;{sig.args}[{arg - sig.n_positional}]&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if self._finally:</span>
<span class="gi">+            # here&#39;s where we handle try_finally decorators.  Such a decorator</span>
<span class="gi">+            # returns a mapped argument and a function to be called in a</span>
<span class="gi">+            # finally block.  This feature was required by the open_file</span>
<span class="gi">+            # decorator.  The below generates the code</span>
<span class="gi">+            #</span>
<span class="gi">+            # name, final = func(name)                   #&lt;--append to mapblock</span>
<span class="gi">+            # try:                                       #&lt;--append to mapblock</span>
<span class="gi">+            #     ... more argmapping and try blocks</span>
<span class="gi">+            #     return WRAPPED_FUNCTION(...)</span>
<span class="gi">+            #     ... more finally blocks</span>
<span class="gi">+            # finally:                                   #&lt;--prepend to finallys</span>
<span class="gi">+            #     final()                                #&lt;--prepend to finallys</span>
<span class="gi">+            #</span>
<span class="gi">+            for a in self._args:</span>
<span class="gi">+                name = get_name(a)</span>
<span class="gi">+                final = self._name(name)</span>
<span class="gi">+                mapblock.append(f&quot;{name}, {final} = {fname}({name})&quot;)</span>
<span class="gi">+                mapblock.append(&quot;try:&quot;)</span>
<span class="gi">+                finallys = [&quot;finally:&quot;, f&quot;{final}()#&quot;, &quot;#&quot;, finallys]</span>
<span class="gi">+        else:</span>
<span class="gi">+            mapblock.extend(</span>
<span class="gi">+                f&quot;{name} = {fname}({name})&quot; for name in map(get_name, self._args)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return sig, wrapped_name, functions, mapblock, finallys, mutable_args</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def signature(cls, f):
<span class="gd">-        &quot;&quot;&quot;Construct a Signature object describing `f`</span>
<span class="gi">+        r&quot;&quot;&quot;Construct a Signature object describing `f`</span>

<span class="w"> </span>        Compute a Signature so that we can write a function wrapping f with
<span class="w"> </span>        the same signature and call-type.
<span class="gu">@@ -872,16 +1088,84 @@ class argmap:</span>
<span class="w"> </span>            call_sig : a string used as code to call the decorated function
<span class="w"> </span>            names : a dict keyed by argument name and index to the argument&#39;s name
<span class="w"> </span>            n_positional : the number of positional arguments in the signature
<span class="gd">-            args : the name of the VAR_POSITIONAL argument if any, i.e. \\*theseargs</span>
<span class="gd">-            kwargs : the name of the VAR_KEYWORDS argument if any, i.e. \\*\\*kwargs</span>
<span class="gi">+            args : the name of the VAR_POSITIONAL argument if any, i.e. \*theseargs</span>
<span class="gi">+            kwargs : the name of the VAR_KEYWORDS argument if any, i.e. \*\*kwargs</span>

<span class="w"> </span>        These named attributes of the signature are used in `assemble` and `compile`
<span class="w"> </span>        to construct a string of source code for the decorated function.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    Signature = collections.namedtuple(&#39;Signature&#39;, [&#39;name&#39;, &#39;signature&#39;,</span>
<span class="gd">-        &#39;def_sig&#39;, &#39;call_sig&#39;, &#39;names&#39;, &#39;n_positional&#39;, &#39;args&#39;, &#39;kwargs&#39;])</span>
<span class="gi">+        sig = inspect.signature(f, follow_wrapped=False)</span>
<span class="gi">+        def_sig = []</span>
<span class="gi">+        call_sig = []</span>
<span class="gi">+        names = {}</span>
<span class="gi">+</span>
<span class="gi">+        kind = None</span>
<span class="gi">+        args = None</span>
<span class="gi">+        kwargs = None</span>
<span class="gi">+        npos = 0</span>
<span class="gi">+        for i, param in enumerate(sig.parameters.values()):</span>
<span class="gi">+            # parameters can be position-only, keyword-or-position, keyword-only</span>
<span class="gi">+            # in any combination, but only in the order as above.  we do edge</span>
<span class="gi">+            # detection to add the appropriate punctuation</span>
<span class="gi">+            prev = kind</span>
<span class="gi">+            kind = param.kind</span>
<span class="gi">+            if prev == param.POSITIONAL_ONLY != kind:</span>
<span class="gi">+                # the last token was position-only, but this one isn&#39;t</span>
<span class="gi">+                def_sig.append(&quot;/&quot;)</span>
<span class="gi">+            if (</span>
<span class="gi">+                param.VAR_POSITIONAL</span>
<span class="gi">+                != prev</span>
<span class="gi">+                != param.KEYWORD_ONLY</span>
<span class="gi">+                == kind</span>
<span class="gi">+                != param.VAR_POSITIONAL</span>
<span class="gi">+            ):</span>
<span class="gi">+                # param is the first keyword-only arg and isn&#39;t starred</span>
<span class="gi">+                def_sig.append(&quot;*&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            # star arguments as appropriate</span>
<span class="gi">+            if kind == param.VAR_POSITIONAL:</span>
<span class="gi">+                name = &quot;*&quot; + param.name</span>
<span class="gi">+                args = param.name</span>
<span class="gi">+                count = 0</span>
<span class="gi">+            elif kind == param.VAR_KEYWORD:</span>
<span class="gi">+                name = &quot;**&quot; + param.name</span>
<span class="gi">+                kwargs = param.name</span>
<span class="gi">+                count = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                names[i] = names[param.name] = param.name</span>
<span class="gi">+                name = param.name</span>
<span class="gi">+                count = 1</span>
<span class="gi">+</span>
<span class="gi">+            # assign to keyword-only args in the function call</span>
<span class="gi">+            if kind == param.KEYWORD_ONLY:</span>
<span class="gi">+                call_sig.append(f&quot;{name} = {name}&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                npos += count</span>
<span class="gi">+                call_sig.append(name)</span>
<span class="gi">+</span>
<span class="gi">+            def_sig.append(name)</span>
<span class="gi">+</span>
<span class="gi">+        fname = cls._name(f)</span>
<span class="gi">+        def_sig = f&#39;def {fname}({&quot;, &quot;.join(def_sig)}):&#39;</span>
<span class="gi">+</span>
<span class="gi">+        call_sig = f&quot;return {{}}({&#39;, &#39;.join(call_sig)})&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return cls.Signature(fname, sig, def_sig, call_sig, names, npos, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    Signature = collections.namedtuple(</span>
<span class="gi">+        &quot;Signature&quot;,</span>
<span class="gi">+        [</span>
<span class="gi">+            &quot;name&quot;,</span>
<span class="gi">+            &quot;signature&quot;,</span>
<span class="gi">+            &quot;def_sig&quot;,</span>
<span class="gi">+            &quot;call_sig&quot;,</span>
<span class="gi">+            &quot;names&quot;,</span>
<span class="gi">+            &quot;n_positional&quot;,</span>
<span class="gi">+            &quot;args&quot;,</span>
<span class="gi">+            &quot;kwargs&quot;,</span>
<span class="gi">+        ],</span>
<span class="gi">+    )</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _flatten(nestlist, visited):
<span class="gu">@@ -901,8 +1185,17 @@ class argmap:</span>
<span class="w"> </span>        Non-list objects contained in nestlist

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    _tabs = &#39; &#39; * 64</span>
<span class="gi">+        for thing in nestlist:</span>
<span class="gi">+            if isinstance(thing, list):</span>
<span class="gi">+                if id(thing) in visited:</span>
<span class="gi">+                    raise ValueError(&quot;A cycle was found in nestlist.  Be a tree.&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    visited.add(id(thing))</span>
<span class="gi">+                yield from argmap._flatten(thing, visited)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield thing</span>
<span class="gi">+</span>
<span class="gi">+    _tabs = &quot; &quot; * 64</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _indent(*lines):
<span class="gu">@@ -939,9 +1232,13 @@ class argmap:</span>
<span class="w"> </span>            finally:
<span class="w"> </span>             pass#&#39;&#39;&#39;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        depth = 0</span>
<span class="gi">+        for line in argmap._flatten(lines, set()):</span>
<span class="gi">+            yield f&quot;{argmap._tabs[:depth]}{line}&quot;</span>
<span class="gi">+            depth += (line[-1:] == &quot;:&quot;) - (line[-1:] == &quot;#&quot;)</span>


<span class="gi">+# Vendored in from https://github.com/scikit-learn/scikit-learn/blob/8ed0270b99344cee9bb253cbfa1d986561ea6cd7/sklearn/utils/validation.py#L37C1-L90C44</span>
<span class="w"> </span>def deprecate_positional_args(func=None, *, version):
<span class="w"> </span>    &quot;&quot;&quot;Decorator for methods that issues warnings for positional arguments.

<span class="gu">@@ -955,4 +1252,44 @@ def deprecate_positional_args(func=None, *, version):</span>
<span class="w"> </span>    version : callable, default=&quot;1.3&quot;
<span class="w"> </span>        The version when positional arguments will result in error.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _inner_deprecate_positional_args(f):</span>
<span class="gi">+        sig = signature(f)</span>
<span class="gi">+        kwonly_args = []</span>
<span class="gi">+        all_args = []</span>
<span class="gi">+</span>
<span class="gi">+        for name, param in sig.parameters.items():</span>
<span class="gi">+            if param.kind == Parameter.POSITIONAL_OR_KEYWORD:</span>
<span class="gi">+                all_args.append(name)</span>
<span class="gi">+            elif param.kind == Parameter.KEYWORD_ONLY:</span>
<span class="gi">+                kwonly_args.append(name)</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(f)</span>
<span class="gi">+        def inner_f(*args, **kwargs):</span>
<span class="gi">+            extra_args = len(args) - len(all_args)</span>
<span class="gi">+            if extra_args &lt;= 0:</span>
<span class="gi">+                return f(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+            # extra_args &gt; 0</span>
<span class="gi">+            args_msg = [</span>
<span class="gi">+                f&quot;{name}={arg}&quot;</span>
<span class="gi">+                for name, arg in zip(kwonly_args[:extra_args], args[-extra_args:])</span>
<span class="gi">+            ]</span>
<span class="gi">+            args_msg = &quot;, &quot;.join(args_msg)</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                (</span>
<span class="gi">+                    f&quot;Pass {args_msg} as keyword args. From NetworkX version &quot;</span>
<span class="gi">+                    f&quot;{version} passing these as positional arguments &quot;</span>
<span class="gi">+                    &quot;will result in an error&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+                FutureWarning,</span>
<span class="gi">+            )</span>
<span class="gi">+            kwargs.update(zip(sig.parameters, args))</span>
<span class="gi">+            return f(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return inner_f</span>
<span class="gi">+</span>
<span class="gi">+    if func is not None:</span>
<span class="gi">+        return _inner_deprecate_positional_args(func)</span>
<span class="gi">+</span>
<span class="gi">+    return _inner_deprecate_positional_args</span>
<span class="gh">diff --git a/networkx/utils/heaps.py b/networkx/utils/heaps.py</span>
<span class="gh">index 53979ae9f..3db279063 100644</span>
<span class="gd">--- a/networkx/utils/heaps.py</span>
<span class="gi">+++ b/networkx/utils/heaps.py</span>
<span class="gu">@@ -1,10 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Min-heaps.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from heapq import heappop, heappush
<span class="w"> </span>from itertools import count
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;MinHeap&#39;, &#39;PairingHeap&#39;, &#39;BinaryHeap&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;MinHeap&quot;, &quot;PairingHeap&quot;, &quot;BinaryHeap&quot;]</span>


<span class="w"> </span>class MinHeap:
<span class="gu">@@ -15,10 +18,10 @@ class MinHeap:</span>
<span class="w"> </span>    value in an existing pair and deleting the minimum pair.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>    class _Item:
<span class="w"> </span>        &quot;&quot;&quot;Used by subclassess to represent a key-value pair.&quot;&quot;&quot;
<span class="gd">-        __slots__ = &#39;key&#39;, &#39;value&#39;</span>
<span class="gi">+</span>
<span class="gi">+        __slots__ = (&quot;key&quot;, &quot;value&quot;)</span>

<span class="w"> </span>        def __init__(self, key, value):
<span class="w"> </span>            self.key = key
<span class="gu">@@ -44,7 +47,7 @@ class MinHeap:</span>
<span class="w"> </span>        NetworkXError
<span class="w"> </span>            If the heap is empty.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def pop(self):
<span class="w"> </span>        &quot;&quot;&quot;Delete the minimum pair in the heap.
<span class="gu">@@ -59,7 +62,7 @@ class MinHeap:</span>
<span class="w"> </span>        NetworkXError
<span class="w"> </span>            If the heap is empty.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def get(self, key, default=None):
<span class="w"> </span>        &quot;&quot;&quot;Returns the value associated with a key.
<span class="gu">@@ -78,7 +81,7 @@ class MinHeap:</span>
<span class="w"> </span>        value : object.
<span class="w"> </span>            The value associated with the key.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def insert(self, key, value, allow_increase=False):
<span class="w"> </span>        &quot;&quot;&quot;Insert a new key-value pair or modify the value in an existing
<span class="gu">@@ -101,7 +104,7 @@ class MinHeap:</span>
<span class="w"> </span>        decreased : bool
<span class="w"> </span>            True if a pair is inserted or the existing value is decreased.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def __nonzero__(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns whether the heap if empty.&quot;&quot;&quot;
<span class="gu">@@ -129,20 +132,24 @@ class MinHeap:</span>
<span class="w"> </span>class PairingHeap(MinHeap):
<span class="w"> </span>    &quot;&quot;&quot;A pairing heap.&quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>    class _Node(MinHeap._Item):
<span class="w"> </span>        &quot;&quot;&quot;A node in a pairing heap.

<span class="w"> </span>        A tree in a pairing heap is stored using the left-child, right-sibling
<span class="w"> </span>        representation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        __slots__ = &#39;left&#39;, &#39;next&#39;, &#39;prev&#39;, &#39;parent&#39;</span>
<span class="gi">+</span>
<span class="gi">+        __slots__ = (&quot;left&quot;, &quot;next&quot;, &quot;prev&quot;, &quot;parent&quot;)</span>

<span class="w"> </span>        def __init__(self, key, value):
<span class="w"> </span>            super().__init__(key, value)
<span class="gi">+            # The leftmost child.</span>
<span class="w"> </span>            self.left = None
<span class="gi">+            # The next sibling.</span>
<span class="w"> </span>            self.next = None
<span class="gi">+            # The previous sibling.</span>
<span class="w"> </span>            self.prev = None
<span class="gi">+            # The parent.</span>
<span class="w"> </span>            self.parent = None

<span class="w"> </span>    def __init__(self):
<span class="gu">@@ -150,21 +157,125 @@ class PairingHeap(MinHeap):</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._root = None

<span class="gi">+    def min(self):</span>
<span class="gi">+        if self._root is None:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;heap is empty.&quot;)</span>
<span class="gi">+        return (self._root.key, self._root.value)</span>
<span class="gi">+</span>
<span class="gi">+    def pop(self):</span>
<span class="gi">+        if self._root is None:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;heap is empty.&quot;)</span>
<span class="gi">+        min_node = self._root</span>
<span class="gi">+        self._root = self._merge_children(self._root)</span>
<span class="gi">+        del self._dict[min_node.key]</span>
<span class="gi">+        return (min_node.key, min_node.value)</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, key, default=None):</span>
<span class="gi">+        node = self._dict.get(key)</span>
<span class="gi">+        return node.value if node is not None else default</span>
<span class="gi">+</span>
<span class="gi">+    def insert(self, key, value, allow_increase=False):</span>
<span class="gi">+        node = self._dict.get(key)</span>
<span class="gi">+        root = self._root</span>
<span class="gi">+        if node is not None:</span>
<span class="gi">+            if value &lt; node.value:</span>
<span class="gi">+                node.value = value</span>
<span class="gi">+                if node is not root and value &lt; node.parent.value:</span>
<span class="gi">+                    self._cut(node)</span>
<span class="gi">+                    self._root = self._link(root, node)</span>
<span class="gi">+                return True</span>
<span class="gi">+            elif allow_increase and value &gt; node.value:</span>
<span class="gi">+                node.value = value</span>
<span class="gi">+                child = self._merge_children(node)</span>
<span class="gi">+                # Nonstandard step: Link the merged subtree with the root. See</span>
<span class="gi">+                # below for the standard step.</span>
<span class="gi">+                if child is not None:</span>
<span class="gi">+                    self._root = self._link(self._root, child)</span>
<span class="gi">+                # Standard step: Perform a decrease followed by a pop as if the</span>
<span class="gi">+                # value were the smallest in the heap. Then insert the new</span>
<span class="gi">+                # value into the heap.</span>
<span class="gi">+                # if node is not root:</span>
<span class="gi">+                #     self._cut(node)</span>
<span class="gi">+                #     if child is not None:</span>
<span class="gi">+                #         root = self._link(root, child)</span>
<span class="gi">+                #     self._root = self._link(root, node)</span>
<span class="gi">+                # else:</span>
<span class="gi">+                #     self._root = (self._link(node, child)</span>
<span class="gi">+                #                   if child is not None else node)</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Insert a new key.</span>
<span class="gi">+            node = self._Node(key, value)</span>
<span class="gi">+            self._dict[key] = node</span>
<span class="gi">+            self._root = self._link(root, node) if root is not None else node</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="w"> </span>    def _link(self, root, other):
<span class="w"> </span>        &quot;&quot;&quot;Link two nodes, making the one with the smaller value the parent of
<span class="w"> </span>        the other.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if other.value &lt; root.value:</span>
<span class="gi">+            root, other = other, root</span>
<span class="gi">+        next = root.left</span>
<span class="gi">+        other.next = next</span>
<span class="gi">+        if next is not None:</span>
<span class="gi">+            next.prev = other</span>
<span class="gi">+        other.prev = None</span>
<span class="gi">+        root.left = other</span>
<span class="gi">+        other.parent = root</span>
<span class="gi">+        return root</span>

<span class="w"> </span>    def _merge_children(self, root):
<span class="w"> </span>        &quot;&quot;&quot;Merge the subtrees of the root using the standard two-pass method.
<span class="w"> </span>        The resulting subtree is detached from the root.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node = root.left</span>
<span class="gi">+        root.left = None</span>
<span class="gi">+        if node is not None:</span>
<span class="gi">+            link = self._link</span>
<span class="gi">+            # Pass 1: Merge pairs of consecutive subtrees from left to right.</span>
<span class="gi">+            # At the end of the pass, only the prev pointers of the resulting</span>
<span class="gi">+            # subtrees have meaningful values. The other pointers will be fixed</span>
<span class="gi">+            # in pass 2.</span>
<span class="gi">+            prev = None</span>
<span class="gi">+            while True:</span>
<span class="gi">+                next = node.next</span>
<span class="gi">+                if next is None:</span>
<span class="gi">+                    node.prev = prev</span>
<span class="gi">+                    break</span>
<span class="gi">+                next_next = next.next</span>
<span class="gi">+                node = link(node, next)</span>
<span class="gi">+                node.prev = prev</span>
<span class="gi">+                prev = node</span>
<span class="gi">+                if next_next is None:</span>
<span class="gi">+                    break</span>
<span class="gi">+                node = next_next</span>
<span class="gi">+            # Pass 2: Successively merge the subtrees produced by pass 1 from</span>
<span class="gi">+            # right to left with the rightmost one.</span>
<span class="gi">+            prev = node.prev</span>
<span class="gi">+            while prev is not None:</span>
<span class="gi">+                prev_prev = prev.prev</span>
<span class="gi">+                node = link(prev, node)</span>
<span class="gi">+                prev = prev_prev</span>
<span class="gi">+            # Now node can become the new root. Its has no parent nor siblings.</span>
<span class="gi">+            node.prev = None</span>
<span class="gi">+            node.next = None</span>
<span class="gi">+            node.parent = None</span>
<span class="gi">+        return node</span>

<span class="w"> </span>    def _cut(self, node):
<span class="w"> </span>        &quot;&quot;&quot;Cut a node from its parent.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prev = node.prev</span>
<span class="gi">+        next = node.next</span>
<span class="gi">+        if prev is not None:</span>
<span class="gi">+            prev.next = next</span>
<span class="gi">+        else:</span>
<span class="gi">+            node.parent.left = next</span>
<span class="gi">+        node.prev = None</span>
<span class="gi">+        if next is not None:</span>
<span class="gi">+            next.prev = prev</span>
<span class="gi">+            node.next = None</span>
<span class="gi">+        node.parent = None</span>


<span class="w"> </span>class BinaryHeap(MinHeap):
<span class="gu">@@ -175,3 +286,55 @@ class BinaryHeap(MinHeap):</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._heap = []
<span class="w"> </span>        self._count = count()
<span class="gi">+</span>
<span class="gi">+    def min(self):</span>
<span class="gi">+        dict = self._dict</span>
<span class="gi">+        if not dict:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;heap is empty&quot;)</span>
<span class="gi">+        heap = self._heap</span>
<span class="gi">+        pop = heappop</span>
<span class="gi">+        # Repeatedly remove stale key-value pairs until a up-to-date one is</span>
<span class="gi">+        # met.</span>
<span class="gi">+        while True:</span>
<span class="gi">+            value, _, key = heap[0]</span>
<span class="gi">+            if key in dict and value == dict[key]:</span>
<span class="gi">+                break</span>
<span class="gi">+            pop(heap)</span>
<span class="gi">+        return (key, value)</span>
<span class="gi">+</span>
<span class="gi">+    def pop(self):</span>
<span class="gi">+        dict = self._dict</span>
<span class="gi">+        if not dict:</span>
<span class="gi">+            raise nx.NetworkXError(&quot;heap is empty&quot;)</span>
<span class="gi">+        heap = self._heap</span>
<span class="gi">+        pop = heappop</span>
<span class="gi">+        # Repeatedly remove stale key-value pairs until a up-to-date one is</span>
<span class="gi">+        # met.</span>
<span class="gi">+        while True:</span>
<span class="gi">+            value, _, key = heap[0]</span>
<span class="gi">+            pop(heap)</span>
<span class="gi">+            if key in dict and value == dict[key]:</span>
<span class="gi">+                break</span>
<span class="gi">+        del dict[key]</span>
<span class="gi">+        return (key, value)</span>
<span class="gi">+</span>
<span class="gi">+    def get(self, key, default=None):</span>
<span class="gi">+        return self._dict.get(key, default)</span>
<span class="gi">+</span>
<span class="gi">+    def insert(self, key, value, allow_increase=False):</span>
<span class="gi">+        dict = self._dict</span>
<span class="gi">+        if key in dict:</span>
<span class="gi">+            old_value = dict[key]</span>
<span class="gi">+            if value &lt; old_value or (allow_increase and value &gt; old_value):</span>
<span class="gi">+                # Since there is no way to efficiently obtain the location of a</span>
<span class="gi">+                # key-value pair in the heap, insert a new pair even if ones</span>
<span class="gi">+                # with the same key may already be present. Deem the old ones</span>
<span class="gi">+                # as stale and skip them when the minimum pair is queried.</span>
<span class="gi">+                dict[key] = value</span>
<span class="gi">+                heappush(self._heap, (value, next(self._count), key))</span>
<span class="gi">+                return value &lt; old_value</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            dict[key] = value</span>
<span class="gi">+            heappush(self._heap, (value, next(self._count), key))</span>
<span class="gi">+            return True</span>
<span class="gh">diff --git a/networkx/utils/mapped_queue.py b/networkx/utils/mapped_queue.py</span>
<span class="gh">index f98621d8f..afb97404c 100644</span>
<span class="gd">--- a/networkx/utils/mapped_queue.py</span>
<span class="gi">+++ b/networkx/utils/mapped_queue.py</span>
<span class="gu">@@ -1,7 +1,9 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Priority queue class with updatable priorities.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import heapq
<span class="gd">-__all__ = [&#39;MappedQueue&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;MappedQueue&quot;]</span>


<span class="w"> </span>class _HeapElement:
<span class="gu">@@ -26,7 +28,8 @@ class _HeapElement:</span>
<span class="w"> </span>    as a tiebreaker. This provides compatibility with older systems that
<span class="w"> </span>    use tuples to combine priority and elements.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = [&#39;priority&#39;, &#39;element&#39;, &#39;_hash&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = [&quot;priority&quot;, &quot;element&quot;, &quot;_hash&quot;]</span>

<span class="w"> </span>    def __init__(self, priority, element):
<span class="w"> </span>        self.priority = priority
<span class="gu">@@ -38,13 +41,14 @@ class _HeapElement:</span>
<span class="w"> </span>            other_priority = other.priority
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            return self.priority &lt; other
<span class="gi">+        # assume comparing to another _HeapElement</span>
<span class="w"> </span>        if self.priority == other_priority:
<span class="w"> </span>            try:
<span class="w"> </span>                return self.element &lt; other.element
<span class="w"> </span>            except TypeError as err:
<span class="w"> </span>                raise TypeError(
<span class="gd">-                    &#39;Consider using a tuple, with a priority value that can be compared.&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    &quot;Consider using a tuple, with a priority value that can be compared.&quot;</span>
<span class="gi">+                )</span>
<span class="w"> </span>        return self.priority &lt; other_priority

<span class="w"> </span>    def __gt__(self, other):
<span class="gu">@@ -52,13 +56,14 @@ class _HeapElement:</span>
<span class="w"> </span>            other_priority = other.priority
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            return self.priority &gt; other
<span class="gi">+        # assume comparing to another _HeapElement</span>
<span class="w"> </span>        if self.priority == other_priority:
<span class="w"> </span>            try:
<span class="w"> </span>                return self.element &gt; other.element
<span class="w"> </span>            except TypeError as err:
<span class="w"> </span>                raise TypeError(
<span class="gd">-                    &#39;Consider using a tuple, with a priority value that can be compared.&#39;</span>
<span class="gd">-                    )</span>
<span class="gi">+                    &quot;Consider using a tuple, with a priority value that can be compared.&quot;</span>
<span class="gi">+                )</span>
<span class="w"> </span>        return self.priority &gt; other_priority

<span class="w"> </span>    def __eq__(self, other):
<span class="gu">@@ -81,7 +86,7 @@ class _HeapElement:</span>
<span class="w"> </span>            yield self.element

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;_HeapElement({self.priority}, {self.element})&#39;</span>
<span class="gi">+        return f&quot;_HeapElement({self.priority}, {self.element})&quot;</span>


<span class="w"> </span>class MappedQueue:
<span class="gu">@@ -159,26 +164,78 @@ class MappedQueue:</span>

<span class="w"> </span>    def _heapify(self):
<span class="w"> </span>        &quot;&quot;&quot;Restore heap invariant and recalculate map.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        heapq.heapify(self.heap)</span>
<span class="gi">+        self.position = {elt: pos for pos, elt in enumerate(self.heap)}</span>
<span class="gi">+        if len(self.heap) != len(self.position):</span>
<span class="gi">+            raise AssertionError(&quot;Heap contains duplicate elements&quot;)</span>

<span class="w"> </span>    def __len__(self):
<span class="w"> </span>        return len(self.heap)

<span class="w"> </span>    def push(self, elt, priority=None):
<span class="w"> </span>        &quot;&quot;&quot;Add an element to the queue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if priority is not None:</span>
<span class="gi">+            elt = _HeapElement(priority, elt)</span>
<span class="gi">+        # If element is already in queue, do nothing</span>
<span class="gi">+        if elt in self.position:</span>
<span class="gi">+            return False</span>
<span class="gi">+        # Add element to heap and dict</span>
<span class="gi">+        pos = len(self.heap)</span>
<span class="gi">+        self.heap.append(elt)</span>
<span class="gi">+        self.position[elt] = pos</span>
<span class="gi">+        # Restore invariant by sifting down</span>
<span class="gi">+        self._siftdown(0, pos)</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    def pop(self):
<span class="w"> </span>        &quot;&quot;&quot;Remove and return the smallest element in the queue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Remove smallest element</span>
<span class="gi">+        elt = self.heap[0]</span>
<span class="gi">+        del self.position[elt]</span>
<span class="gi">+        # If elt is last item, remove and return</span>
<span class="gi">+        if len(self.heap) == 1:</span>
<span class="gi">+            self.heap.pop()</span>
<span class="gi">+            return elt</span>
<span class="gi">+        # Replace root with last element</span>
<span class="gi">+        last = self.heap.pop()</span>
<span class="gi">+        self.heap[0] = last</span>
<span class="gi">+        self.position[last] = 0</span>
<span class="gi">+        # Restore invariant by sifting up</span>
<span class="gi">+        self._siftup(0)</span>
<span class="gi">+        # Return smallest element</span>
<span class="gi">+        return elt</span>

<span class="w"> </span>    def update(self, elt, new, priority=None):
<span class="w"> </span>        &quot;&quot;&quot;Replace an element in the queue with a new one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if priority is not None:</span>
<span class="gi">+            new = _HeapElement(priority, new)</span>
<span class="gi">+        # Replace</span>
<span class="gi">+        pos = self.position[elt]</span>
<span class="gi">+        self.heap[pos] = new</span>
<span class="gi">+        del self.position[elt]</span>
<span class="gi">+        self.position[new] = pos</span>
<span class="gi">+        # Restore invariant by sifting up</span>
<span class="gi">+        self._siftup(pos)</span>

<span class="w"> </span>    def remove(self, elt):
<span class="w"> </span>        &quot;&quot;&quot;Remove an element from the queue.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Find and remove element</span>
<span class="gi">+        try:</span>
<span class="gi">+            pos = self.position[elt]</span>
<span class="gi">+            del self.position[elt]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # Not in queue</span>
<span class="gi">+            raise</span>
<span class="gi">+        # If elt is last item, remove and return</span>
<span class="gi">+        if pos == len(self.heap) - 1:</span>
<span class="gi">+            self.heap.pop()</span>
<span class="gi">+            return</span>
<span class="gi">+        # Replace elt with last element</span>
<span class="gi">+        last = self.heap.pop()</span>
<span class="gi">+        self.heap[pos] = last</span>
<span class="gi">+        self.position[last] = pos</span>
<span class="gi">+        # Restore invariant by sifting up</span>
<span class="gi">+        self._siftup(pos)</span>

<span class="w"> </span>    def _siftup(self, pos):
<span class="w"> </span>        &quot;&quot;&quot;Move smaller child up until hitting a leaf.
<span class="gu">@@ -186,7 +243,38 @@ class MappedQueue:</span>
<span class="w"> </span>        Built to mimic code for heapq._siftup
<span class="w"> </span>        only updating position dict too.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        heap, position = self.heap, self.position</span>
<span class="gi">+        end_pos = len(heap)</span>
<span class="gi">+        startpos = pos</span>
<span class="gi">+        newitem = heap[pos]</span>
<span class="gi">+        # Shift up the smaller child until hitting a leaf</span>
<span class="gi">+        child_pos = (pos &lt;&lt; 1) + 1  # start with leftmost child position</span>
<span class="gi">+        while child_pos &lt; end_pos:</span>
<span class="gi">+            # Set child_pos to index of smaller child.</span>
<span class="gi">+            child = heap[child_pos]</span>
<span class="gi">+            right_pos = child_pos + 1</span>
<span class="gi">+            if right_pos &lt; end_pos:</span>
<span class="gi">+                right = heap[right_pos]</span>
<span class="gi">+                if not child &lt; right:</span>
<span class="gi">+                    child = right</span>
<span class="gi">+                    child_pos = right_pos</span>
<span class="gi">+            # Move the smaller child up.</span>
<span class="gi">+            heap[pos] = child</span>
<span class="gi">+            position[child] = pos</span>
<span class="gi">+            pos = child_pos</span>
<span class="gi">+            child_pos = (pos &lt;&lt; 1) + 1</span>
<span class="gi">+        # pos is a leaf position. Put newitem there, and bubble it up</span>
<span class="gi">+        # to its final resting place (by sifting its parents down).</span>
<span class="gi">+        while pos &gt; 0:</span>
<span class="gi">+            parent_pos = (pos - 1) &gt;&gt; 1</span>
<span class="gi">+            parent = heap[parent_pos]</span>
<span class="gi">+            if not newitem &lt; parent:</span>
<span class="gi">+                break</span>
<span class="gi">+            heap[pos] = parent</span>
<span class="gi">+            position[parent] = pos</span>
<span class="gi">+            pos = parent_pos</span>
<span class="gi">+        heap[pos] = newitem</span>
<span class="gi">+        position[newitem] = pos</span>

<span class="w"> </span>    def _siftdown(self, start_pos, pos):
<span class="w"> </span>        &quot;&quot;&quot;Restore invariant. keep swapping with parent until smaller.
<span class="gu">@@ -194,4 +282,17 @@ class MappedQueue:</span>
<span class="w"> </span>        Built to mimic code for heapq._siftdown
<span class="w"> </span>        only updating position dict too.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        heap, position = self.heap, self.position</span>
<span class="gi">+        newitem = heap[pos]</span>
<span class="gi">+        # Follow the path to the root, moving parents down until finding a place</span>
<span class="gi">+        # newitem fits.</span>
<span class="gi">+        while pos &gt; start_pos:</span>
<span class="gi">+            parent_pos = (pos - 1) &gt;&gt; 1</span>
<span class="gi">+            parent = heap[parent_pos]</span>
<span class="gi">+            if not newitem &lt; parent:</span>
<span class="gi">+                break</span>
<span class="gi">+            heap[pos] = parent</span>
<span class="gi">+            position[parent] = pos</span>
<span class="gi">+            pos = parent_pos</span>
<span class="gi">+        heap[pos] = newitem</span>
<span class="gi">+        position[newitem] = pos</span>
<span class="gh">diff --git a/networkx/utils/misc.py b/networkx/utils/misc.py</span>
<span class="gh">index a6dba26aa..096e46ab6 100644</span>
<span class="gd">--- a/networkx/utils/misc.py</span>
<span class="gi">+++ b/networkx/utils/misc.py</span>
<span class="gu">@@ -10,6 +10,7 @@ can be accessed, for example, as</span>
<span class="w"> </span>&gt;&gt;&gt; networkx.utils.arbitrary_element({5, 1, 7})  # doctest: +SKIP
<span class="w"> </span>1
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import random
<span class="w"> </span>import sys
<span class="w"> </span>import uuid
<span class="gu">@@ -17,17 +18,44 @@ import warnings</span>
<span class="w"> </span>from collections import defaultdict, deque
<span class="w"> </span>from collections.abc import Iterable, Iterator, Sized
<span class="w"> </span>from itertools import chain, tee
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gd">-__all__ = [&#39;flatten&#39;, &#39;make_list_of_ints&#39;, &#39;dict_to_numpy_array&#39;,</span>
<span class="gd">-    &#39;arbitrary_element&#39;, &#39;pairwise&#39;, &#39;groups&#39;, &#39;create_random_state&#39;,</span>
<span class="gd">-    &#39;create_py_random_state&#39;, &#39;PythonRandomInterface&#39;,</span>
<span class="gd">-    &#39;PythonRandomViaNumpyBits&#39;, &#39;nodes_equal&#39;, &#39;edges_equal&#39;,</span>
<span class="gd">-    &#39;graphs_equal&#39;, &#39;_clear_cache&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;flatten&quot;,</span>
<span class="gi">+    &quot;make_list_of_ints&quot;,</span>
<span class="gi">+    &quot;dict_to_numpy_array&quot;,</span>
<span class="gi">+    &quot;arbitrary_element&quot;,</span>
<span class="gi">+    &quot;pairwise&quot;,</span>
<span class="gi">+    &quot;groups&quot;,</span>
<span class="gi">+    &quot;create_random_state&quot;,</span>
<span class="gi">+    &quot;create_py_random_state&quot;,</span>
<span class="gi">+    &quot;PythonRandomInterface&quot;,</span>
<span class="gi">+    &quot;PythonRandomViaNumpyBits&quot;,</span>
<span class="gi">+    &quot;nodes_equal&quot;,</span>
<span class="gi">+    &quot;edges_equal&quot;,</span>
<span class="gi">+    &quot;graphs_equal&quot;,</span>
<span class="gi">+    &quot;_clear_cache&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# some cookbook stuff</span>
<span class="gi">+# used in deciding whether something is a bunch of nodes, edges, etc.</span>
<span class="gi">+# see G.add_nodes and others in Graph Class in networkx/base.py</span>


<span class="w"> </span>def flatten(obj, result=None):
<span class="w"> </span>    &quot;&quot;&quot;Return flattened version of (possibly nested) iterable object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(obj, Iterable | Sized) or isinstance(obj, str):</span>
<span class="gi">+        return obj</span>
<span class="gi">+    if result is None:</span>
<span class="gi">+        result = []</span>
<span class="gi">+    for item in obj:</span>
<span class="gi">+        if not isinstance(item, Iterable | Sized) or isinstance(item, str):</span>
<span class="gi">+            result.append(item)</span>
<span class="gi">+        else:</span>
<span class="gi">+            flatten(item, result)</span>
<span class="gi">+    return tuple(result)</span>


<span class="w"> </span>def make_list_of_ints(sequence):
<span class="gu">@@ -39,13 +67,42 @@ def make_list_of_ints(sequence):</span>
<span class="w"> </span>    If sequence is a list, the non-int values are replaced with ints.
<span class="w"> </span>    So, no new list is created
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(sequence, list):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for i in sequence:</span>
<span class="gi">+            errmsg = f&quot;sequence is not all integers: {i}&quot;</span>
<span class="gi">+            try:</span>
<span class="gi">+                ii = int(i)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                raise nx.NetworkXError(errmsg) from None</span>
<span class="gi">+            if ii != i:</span>
<span class="gi">+                raise nx.NetworkXError(errmsg)</span>
<span class="gi">+            result.append(ii)</span>
<span class="gi">+        return result</span>
<span class="gi">+    # original sequence is a list... in-place conversion to ints</span>
<span class="gi">+    for indx, i in enumerate(sequence):</span>
<span class="gi">+        errmsg = f&quot;sequence is not all integers: {i}&quot;</span>
<span class="gi">+        if isinstance(i, int):</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            ii = int(i)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise nx.NetworkXError(errmsg) from None</span>
<span class="gi">+        if ii != i:</span>
<span class="gi">+            raise nx.NetworkXError(errmsg)</span>
<span class="gi">+        sequence[indx] = ii</span>
<span class="gi">+    return sequence</span>


<span class="w"> </span>def dict_to_numpy_array(d, mapping=None):
<span class="w"> </span>    &quot;&quot;&quot;Convert a dictionary of dictionaries to a numpy array
<span class="w"> </span>    with optional mapping.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _dict_to_numpy_array2(d, mapping)</span>
<span class="gi">+    except (AttributeError, TypeError):</span>
<span class="gi">+        # AttributeError is when no mapping was provided and v.keys() fails.</span>
<span class="gi">+        # TypeError is when a mapping was provided and d[k1][k2] fails.</span>
<span class="gi">+        return _dict_to_numpy_array1(d, mapping)</span>


<span class="w"> </span>def _dict_to_numpy_array2(d, mapping=None):
<span class="gu">@@ -53,12 +110,37 @@ def _dict_to_numpy_array2(d, mapping=None):</span>
<span class="w"> </span>    with optional mapping.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if mapping is None:</span>
<span class="gi">+        s = set(d.keys())</span>
<span class="gi">+        for k, v in d.items():</span>
<span class="gi">+            s.update(v.keys())</span>
<span class="gi">+        mapping = dict(zip(s, range(len(s))))</span>
<span class="gi">+    n = len(mapping)</span>
<span class="gi">+    a = np.zeros((n, n))</span>
<span class="gi">+    for k1, i in mapping.items():</span>
<span class="gi">+        for k2, j in mapping.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                a[i, j] = d[k1][k2]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    return a</span>


<span class="w"> </span>def _dict_to_numpy_array1(d, mapping=None):
<span class="w"> </span>    &quot;&quot;&quot;Convert a dictionary of numbers to a 1d numpy array with optional mapping.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if mapping is None:</span>
<span class="gi">+        s = set(d.keys())</span>
<span class="gi">+        mapping = dict(zip(s, range(len(s))))</span>
<span class="gi">+    n = len(mapping)</span>
<span class="gi">+    a = np.zeros(n)</span>
<span class="gi">+    for k1, i in mapping.items():</span>
<span class="gi">+        i = mapping[k1]</span>
<span class="gi">+        a[i] = d[k1]</span>
<span class="gi">+    return a</span>


<span class="w"> </span>def arbitrary_element(iterable):
<span class="gu">@@ -124,12 +206,20 @@ def arbitrary_element(iterable):</span>
<span class="w"> </span>        1

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(iterable, Iterator):</span>
<span class="gi">+        raise ValueError(&quot;cannot return an arbitrary item from an iterator&quot;)</span>
<span class="gi">+    # Another possible implementation is ``for x in iterable: return x``.</span>
<span class="gi">+    return next(iter(iterable))</span>


<span class="gi">+# Recipe from the itertools documentation.</span>
<span class="w"> </span>def pairwise(iterable, cyclic=False):
<span class="gd">-    &quot;&quot;&quot;s -&gt; (s0, s1), (s1, s2), (s2, s3), ...&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &quot;s -&gt; (s0, s1), (s1, s2), (s2, s3), ...&quot;</span>
<span class="gi">+    a, b = tee(iterable)</span>
<span class="gi">+    first = next(b, None)</span>
<span class="gi">+    if cyclic is True:</span>
<span class="gi">+        return zip(a, chain(b, (first,)))</span>
<span class="gi">+    return zip(a, b)</span>


<span class="w"> </span>def groups(many_to_one):
<span class="gu">@@ -148,7 +238,10 @@ def groups(many_to_one):</span>
<span class="w"> </span>    &gt;&gt;&gt; groups(many_to_one)  # doctest: +SKIP
<span class="w"> </span>    {1: {&#39;a&#39;, &#39;b&#39;}, 2: {&#39;c&#39;}, 3: {&#39;e&#39;, &#39;d&#39;}}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    one_to_many = defaultdict(set)</span>
<span class="gi">+    for v, k in many_to_one.items():</span>
<span class="gi">+        one_to_many[k].add(v)</span>
<span class="gi">+    return dict(one_to_many)</span>


<span class="w"> </span>def create_random_state(random_state=None):
<span class="gu">@@ -164,7 +257,21 @@ def create_random_state(random_state=None):</span>
<span class="w"> </span>        if None or numpy.random, return the global random number generator used
<span class="w"> </span>        by numpy.random.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+    if random_state is None or random_state is np.random:</span>
<span class="gi">+        return np.random.mtrand._rand</span>
<span class="gi">+    if isinstance(random_state, np.random.RandomState):</span>
<span class="gi">+        return random_state</span>
<span class="gi">+    if isinstance(random_state, int):</span>
<span class="gi">+        return np.random.RandomState(random_state)</span>
<span class="gi">+    if isinstance(random_state, np.random.Generator):</span>
<span class="gi">+        return random_state</span>
<span class="gi">+    msg = (</span>
<span class="gi">+        f&quot;{random_state} cannot be used to create a numpy.random.RandomState or\n&quot;</span>
<span class="gi">+        &quot;numpy.random.Generator instance&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    raise ValueError(msg)</span>


<span class="w"> </span>class PythonRandomViaNumpyBits(random.Random):
<span class="gu">@@ -189,27 +296,42 @@ class PythonRandomViaNumpyBits(random.Random):</span>
<span class="w"> </span>        try:
<span class="w"> </span>            import numpy as np
<span class="w"> </span>        except ImportError:
<span class="gd">-            msg = &#39;numpy not found, only random.random available.&#39;</span>
<span class="gi">+            msg = &quot;numpy not found, only random.random available.&quot;</span>
<span class="w"> </span>            warnings.warn(msg, ImportWarning)
<span class="gi">+</span>
<span class="w"> </span>        if rng is None:
<span class="w"> </span>            self._rng = np.random.mtrand._rand
<span class="w"> </span>        else:
<span class="w"> </span>            self._rng = rng
<span class="gi">+</span>
<span class="gi">+        # Not necessary, given our overriding of gauss() below, but it&#39;s</span>
<span class="gi">+        # in the superclass and nominally public, so initialize it here.</span>
<span class="w"> </span>        self.gauss_next = None

<span class="w"> </span>    def random(self):
<span class="w"> </span>        &quot;&quot;&quot;Get the next random number in the range 0.0 &lt;= X &lt; 1.0.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._rng.random()</span>

<span class="w"> </span>    def getrandbits(self, k):
<span class="w"> </span>        &quot;&quot;&quot;getrandbits(k) -&gt; x.  Generates an int with k random bits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if k &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;number of bits must be non-negative&quot;)</span>
<span class="gi">+        numbytes = (k + 7) // 8  # bits / 8 and rounded up</span>
<span class="gi">+        x = int.from_bytes(self._rng.bytes(numbytes), &quot;big&quot;)</span>
<span class="gi">+        return x &gt;&gt; (numbytes * 8 - k)  # trim excess bits</span>
<span class="gi">+</span>
<span class="gi">+    def getstate(self):</span>
<span class="gi">+        return self._rng.__getstate__()</span>
<span class="gi">+</span>
<span class="gi">+    def setstate(self, state):</span>
<span class="gi">+        self._rng.__setstate__(state)</span>

<span class="w"> </span>    def seed(self, *args, **kwds):
<span class="gd">-        &quot;&quot;&quot;Do nothing override method.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;Do nothing override method.&quot;</span>
<span class="gi">+        raise NotImplementedError(&quot;seed() not implemented in PythonRandomViaNumpyBits&quot;)</span>


<span class="gi">+##################################################################</span>
<span class="w"> </span>class PythonRandomInterface:
<span class="w"> </span>    &quot;&quot;&quot;PythonRandomInterface is included for backward compatibility
<span class="w"> </span>    New code should use PythonRandomViaNumpyBits instead.
<span class="gu">@@ -219,13 +341,86 @@ class PythonRandomInterface:</span>
<span class="w"> </span>        try:
<span class="w"> </span>            import numpy as np
<span class="w"> </span>        except ImportError:
<span class="gd">-            msg = &#39;numpy not found, only random.random available.&#39;</span>
<span class="gi">+            msg = &quot;numpy not found, only random.random available.&quot;</span>
<span class="w"> </span>            warnings.warn(msg, ImportWarning)
<span class="gi">+</span>
<span class="w"> </span>        if rng is None:
<span class="w"> </span>            self._rng = np.random.mtrand._rand
<span class="w"> </span>        else:
<span class="w"> </span>            self._rng = rng

<span class="gi">+    def random(self):</span>
<span class="gi">+        return self._rng.random()</span>
<span class="gi">+</span>
<span class="gi">+    def uniform(self, a, b):</span>
<span class="gi">+        return a + (b - a) * self._rng.random()</span>
<span class="gi">+</span>
<span class="gi">+    def randrange(self, a, b=None):</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+        if b is None:</span>
<span class="gi">+            a, b = 0, a</span>
<span class="gi">+        if b &gt; 9223372036854775807:  # from np.iinfo(np.int64).max</span>
<span class="gi">+            tmp_rng = PythonRandomViaNumpyBits(self._rng)</span>
<span class="gi">+            return tmp_rng.randrange(a, b)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self._rng, np.random.Generator):</span>
<span class="gi">+            return self._rng.integers(a, b)</span>
<span class="gi">+        return self._rng.randint(a, b)</span>
<span class="gi">+</span>
<span class="gi">+    # NOTE: the numpy implementations of `choice` don&#39;t support strings, so</span>
<span class="gi">+    # this cannot be replaced with self._rng.choice</span>
<span class="gi">+    def choice(self, seq):</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self._rng, np.random.Generator):</span>
<span class="gi">+            idx = self._rng.integers(0, len(seq))</span>
<span class="gi">+        else:</span>
<span class="gi">+            idx = self._rng.randint(0, len(seq))</span>
<span class="gi">+        return seq[idx]</span>
<span class="gi">+</span>
<span class="gi">+    def gauss(self, mu, sigma):</span>
<span class="gi">+        return self._rng.normal(mu, sigma)</span>
<span class="gi">+</span>
<span class="gi">+    def shuffle(self, seq):</span>
<span class="gi">+        return self._rng.shuffle(seq)</span>
<span class="gi">+</span>
<span class="gi">+    #    Some methods don&#39;t match API for numpy RandomState.</span>
<span class="gi">+    #    Commented out versions are not used by NetworkX</span>
<span class="gi">+</span>
<span class="gi">+    def sample(self, seq, k):</span>
<span class="gi">+        return self._rng.choice(list(seq), size=(k,), replace=False)</span>
<span class="gi">+</span>
<span class="gi">+    def randint(self, a, b):</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+</span>
<span class="gi">+        if b &gt; 9223372036854775807:  # from np.iinfo(np.int64).max</span>
<span class="gi">+            tmp_rng = PythonRandomViaNumpyBits(self._rng)</span>
<span class="gi">+            return tmp_rng.randint(a, b)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(self._rng, np.random.Generator):</span>
<span class="gi">+            return self._rng.integers(a, b + 1)</span>
<span class="gi">+        return self._rng.randint(a, b + 1)</span>
<span class="gi">+</span>
<span class="gi">+    #    exponential as expovariate with 1/argument,</span>
<span class="gi">+    def expovariate(self, scale):</span>
<span class="gi">+        return self._rng.exponential(1 / scale)</span>
<span class="gi">+</span>
<span class="gi">+    #    pareto as paretovariate with 1/argument,</span>
<span class="gi">+    def paretovariate(self, shape):</span>
<span class="gi">+        return self._rng.pareto(shape)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#    weibull as weibullvariate multiplied by beta,</span>
<span class="gi">+#    def weibullvariate(self, alpha, beta):</span>
<span class="gi">+#        return self._rng.weibull(alpha) * beta</span>
<span class="gi">+#</span>
<span class="gi">+#    def triangular(self, low, high, mode):</span>
<span class="gi">+#        return self._rng.triangular(low, mode, high)</span>
<span class="gi">+#</span>
<span class="gi">+#    def choices(self, seq, weights=None, cum_weights=None, k=1):</span>
<span class="gi">+#        return self._rng.choice(seq</span>
<span class="gi">+</span>

<span class="w"> </span>def create_py_random_state(random_state=None):
<span class="w"> </span>    &quot;&quot;&quot;Returns a random.Random instance depending on input.
<span class="gu">@@ -264,7 +459,33 @@ def create_py_random_state(random_state=None):</span>
<span class="w"> </span>      wrapper as well. We use it only used if passed a (non-default) `np.RandomState`
<span class="w"> </span>      instance pre-initialized from a seed. Otherwise the newer wrapper is used.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if random_state is None or random_state is random:</span>
<span class="gi">+        return random._inst</span>
<span class="gi">+    if isinstance(random_state, random.Random):</span>
<span class="gi">+        return random_state</span>
<span class="gi">+    if isinstance(random_state, int):</span>
<span class="gi">+        return random.Random(random_state)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import numpy as np</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        if isinstance(random_state, PythonRandomInterface | PythonRandomViaNumpyBits):</span>
<span class="gi">+            return random_state</span>
<span class="gi">+        if isinstance(random_state, np.random.Generator):</span>
<span class="gi">+            return PythonRandomViaNumpyBits(random_state)</span>
<span class="gi">+        if random_state is np.random:</span>
<span class="gi">+            return PythonRandomViaNumpyBits(np.random.mtrand._rand)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(random_state, np.random.RandomState):</span>
<span class="gi">+            if random_state is np.random.mtrand._rand:</span>
<span class="gi">+                return PythonRandomViaNumpyBits(random_state)</span>
<span class="gi">+            # Only need older interface if specially constructed RandomState used</span>
<span class="gi">+            return PythonRandomInterface(random_state)</span>
<span class="gi">+</span>
<span class="gi">+    msg = f&quot;{random_state} cannot be used to generate a random.Random instance&quot;</span>
<span class="gi">+    raise ValueError(msg)</span>


<span class="w"> </span>def nodes_equal(nodes1, nodes2):
<span class="gu">@@ -283,7 +504,15 @@ def nodes_equal(nodes1, nodes2):</span>
<span class="w"> </span>    bool
<span class="w"> </span>        True if nodes are equal, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nlist1 = list(nodes1)</span>
<span class="gi">+    nlist2 = list(nodes2)</span>
<span class="gi">+    try:</span>
<span class="gi">+        d1 = dict(nlist1)</span>
<span class="gi">+        d2 = dict(nlist2)</span>
<span class="gi">+    except (ValueError, TypeError):</span>
<span class="gi">+        d1 = dict.fromkeys(nlist1)</span>
<span class="gi">+        d2 = dict.fromkeys(nlist2)</span>
<span class="gi">+    return d1 == d2</span>


<span class="w"> </span>def edges_equal(edges1, edges2):
<span class="gu">@@ -305,7 +534,40 @@ def edges_equal(edges1, edges2):</span>
<span class="w"> </span>    bool
<span class="w"> </span>        True if edges are equal, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from collections import defaultdict</span>
<span class="gi">+</span>
<span class="gi">+    d1 = defaultdict(dict)</span>
<span class="gi">+    d2 = defaultdict(dict)</span>
<span class="gi">+    c1 = 0</span>
<span class="gi">+    for c1, e in enumerate(edges1):</span>
<span class="gi">+        u, v = e[0], e[1]</span>
<span class="gi">+        data = [e[2:]]</span>
<span class="gi">+        if v in d1[u]:</span>
<span class="gi">+            data = d1[u][v] + data</span>
<span class="gi">+        d1[u][v] = data</span>
<span class="gi">+        d1[v][u] = data</span>
<span class="gi">+    c2 = 0</span>
<span class="gi">+    for c2, e in enumerate(edges2):</span>
<span class="gi">+        u, v = e[0], e[1]</span>
<span class="gi">+        data = [e[2:]]</span>
<span class="gi">+        if v in d2[u]:</span>
<span class="gi">+            data = d2[u][v] + data</span>
<span class="gi">+        d2[u][v] = data</span>
<span class="gi">+        d2[v][u] = data</span>
<span class="gi">+    if c1 != c2:</span>
<span class="gi">+        return False</span>
<span class="gi">+    # can check one direction because lengths are the same.</span>
<span class="gi">+    for n, nbrdict in d1.items():</span>
<span class="gi">+        for nbr, datalist in nbrdict.items():</span>
<span class="gi">+            if n not in d2:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if nbr not in d2[n]:</span>
<span class="gi">+                return False</span>
<span class="gi">+            d2datalist = d2[n][nbr]</span>
<span class="gi">+            for data in datalist:</span>
<span class="gi">+                if datalist.count(data) != d2datalist.count(data):</span>
<span class="gi">+                    return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def graphs_equal(graph1, graph2):
<span class="gu">@@ -323,7 +585,11 @@ def graphs_equal(graph1, graph2):</span>
<span class="w"> </span>    bool
<span class="w"> </span>        True if graphs are equal, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        graph1.adj == graph2.adj</span>
<span class="gi">+        and graph1.nodes == graph2.nodes</span>
<span class="gi">+        and graph1.graph == graph2.graph</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _clear_cache(G):
<span class="gu">@@ -331,4 +597,5 @@ def _clear_cache(G):</span>

<span class="w"> </span>    Caching is controlled via ``nx.config.cache_converted_graphs`` configuration.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cache := getattr(G, &quot;__networkx_cache__&quot;, None):</span>
<span class="gi">+        cache.clear()</span>
<span class="gh">diff --git a/networkx/utils/random_sequence.py b/networkx/utils/random_sequence.py</span>
<span class="gh">index 403d9033f..20a7b5e0a 100644</span>
<span class="gd">--- a/networkx/utils/random_sequence.py</span>
<span class="gi">+++ b/networkx/utils/random_sequence.py</span>
<span class="gu">@@ -2,10 +2,23 @@</span>
<span class="w"> </span>Utilities for generating random numbers, random sequences, and
<span class="w"> </span>random selections.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="w"> </span>from networkx.utils import py_random_state
<span class="gd">-__all__ = [&#39;powerlaw_sequence&#39;, &#39;zipf_rv&#39;, &#39;cumulative_distribution&#39;,</span>
<span class="gd">-    &#39;discrete_sequence&#39;, &#39;random_weighted_sample&#39;, &#39;weighted_choice&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &quot;powerlaw_sequence&quot;,</span>
<span class="gi">+    &quot;zipf_rv&quot;,</span>
<span class="gi">+    &quot;cumulative_distribution&quot;,</span>
<span class="gi">+    &quot;discrete_sequence&quot;,</span>
<span class="gi">+    &quot;random_weighted_sample&quot;,</span>
<span class="gi">+    &quot;weighted_choice&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# The same helpers for choosing random sequences from distributions</span>
<span class="gi">+# uses Python&#39;s random module</span>
<span class="gi">+# https://docs.python.org/3/library/random.html</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -13,20 +26,20 @@ def powerlaw_sequence(n, exponent=2.0, seed=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return sample sequence of length n from a power law distribution.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [seed.paretovariate(exponent - 1) for i in range(n)]</span>


<span class="w"> </span>@py_random_state(2)
<span class="w"> </span>def zipf_rv(alpha, xmin=1, seed=None):
<span class="gd">-    &quot;&quot;&quot;Returns a random value chosen from the Zipf distribution.</span>
<span class="gi">+    r&quot;&quot;&quot;Returns a random value chosen from the Zipf distribution.</span>

<span class="w"> </span>    The return value is an integer drawn from the probability distribution

<span class="w"> </span>    .. math::

<span class="gd">-        p(x)=\\frac{x^{-\\alpha}}{\\zeta(\\alpha, x_{\\min})},</span>
<span class="gi">+        p(x)=\frac{x^{-\alpha}}{\zeta(\alpha, x_{\min})},</span>

<span class="gd">-    where $\\zeta(\\alpha, x_{\\min})$ is the Hurwitz zeta function.</span>
<span class="gi">+    where $\zeta(\alpha, x_{\min})$ is the Hurwitz zeta function.</span>

<span class="w"> </span>    Parameters
<span class="w"> </span>    ----------
<span class="gu">@@ -65,12 +78,30 @@ def zipf_rv(alpha, xmin=1, seed=None):</span>
<span class="w"> </span>    .. [1] Luc Devroye, Non-Uniform Random Variate Generation,
<span class="w"> </span>       Springer-Verlag, New York, 1986.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if xmin &lt; 1:</span>
<span class="gi">+        raise ValueError(&quot;xmin &lt; 1&quot;)</span>
<span class="gi">+    if alpha &lt;= 1:</span>
<span class="gi">+        raise ValueError(&quot;a &lt;= 1.0&quot;)</span>
<span class="gi">+    a1 = alpha - 1.0</span>
<span class="gi">+    b = 2**a1</span>
<span class="gi">+    while True:</span>
<span class="gi">+        u = 1.0 - seed.random()  # u in (0,1]</span>
<span class="gi">+        v = seed.random()  # v in [0,1)</span>
<span class="gi">+        x = int(xmin * u ** -(1.0 / a1))</span>
<span class="gi">+        t = (1.0 + (1.0 / x)) ** a1</span>
<span class="gi">+        if v * x * (t - 1.0) / (b - 1.0) &lt;= t / b:</span>
<span class="gi">+            break</span>
<span class="gi">+    return x</span>


<span class="w"> </span>def cumulative_distribution(distribution):
<span class="w"> </span>    &quot;&quot;&quot;Returns normalized cumulative distribution from discrete distribution.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    cdf = [0.0]</span>
<span class="gi">+    psum = sum(distribution)</span>
<span class="gi">+    for i in range(len(distribution)):</span>
<span class="gi">+        cdf.append(cdf[i] + distribution[i] / psum)</span>
<span class="gi">+    return cdf</span>


<span class="w"> </span>@py_random_state(3)
<span class="gu">@@ -86,7 +117,23 @@ def discrete_sequence(n, distribution=None, cdistribution=None, seed=None):</span>
<span class="w"> </span>    cdistribution = normalized discrete cumulative distribution

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import bisect</span>
<span class="gi">+</span>
<span class="gi">+    if cdistribution is not None:</span>
<span class="gi">+        cdf = cdistribution</span>
<span class="gi">+    elif distribution is not None:</span>
<span class="gi">+        cdf = cumulative_distribution(distribution)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nx.NetworkXError(</span>
<span class="gi">+            &quot;discrete_sequence: distribution or cdistribution missing&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # get a uniform random number</span>
<span class="gi">+    inputseq = [seed.random() for i in range(n)]</span>
<span class="gi">+</span>
<span class="gi">+    # choose from CDF</span>
<span class="gi">+    seq = [bisect.bisect_left(cdf, s) - 1 for s in inputseq]</span>
<span class="gi">+    return seq</span>


<span class="w"> </span>@py_random_state(2)
<span class="gu">@@ -95,7 +142,12 @@ def random_weighted_sample(mapping, k, seed=None):</span>

<span class="w"> </span>    The input is a dictionary of items with weights as values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if k &gt; len(mapping):</span>
<span class="gi">+        raise ValueError(&quot;sample larger than population&quot;)</span>
<span class="gi">+    sample = set()</span>
<span class="gi">+    while len(sample) &lt; k:</span>
<span class="gi">+        sample.add(weighted_choice(mapping, seed))</span>
<span class="gi">+    return list(sample)</span>


<span class="w"> </span>@py_random_state(1)
<span class="gu">@@ -104,4 +156,9 @@ def weighted_choice(mapping, seed=None):</span>

<span class="w"> </span>    The input is a dictionary of items with weights as values.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # use roulette method</span>
<span class="gi">+    rnd = seed.random() * sum(mapping.values())</span>
<span class="gi">+    for k, w in mapping.items():</span>
<span class="gi">+        rnd -= w</span>
<span class="gi">+        if rnd &lt; 0:</span>
<span class="gi">+            return k</span>
<span class="gh">diff --git a/networkx/utils/rcm.py b/networkx/utils/rcm.py</span>
<span class="gh">index fa7b20746..f9e1bfee6 100644</span>
<span class="gd">--- a/networkx/utils/rcm.py</span>
<span class="gi">+++ b/networkx/utils/rcm.py</span>
<span class="gu">@@ -3,9 +3,12 @@ Cuthill-McKee ordering of graph nodes to produce sparse matrices</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from collections import deque
<span class="w"> </span>from operator import itemgetter
<span class="gi">+</span>
<span class="w"> </span>import networkx as nx
<span class="gi">+</span>
<span class="w"> </span>from ..utils import arbitrary_element
<span class="gd">-__all__ = [&#39;cuthill_mckee_ordering&#39;, &#39;reverse_cuthill_mckee_ordering&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [&quot;cuthill_mckee_ordering&quot;, &quot;reverse_cuthill_mckee_ordering&quot;]</span>


<span class="w"> </span>def cuthill_mckee_ordering(G, heuristic=None):
<span class="gu">@@ -61,7 +64,8 @@ def cuthill_mckee_ordering(G, heuristic=None):</span>
<span class="w"> </span>    .. [2]  Steven S. Skiena. 1997. The Algorithm Design Manual.
<span class="w"> </span>       Springer-Verlag New York, Inc., New York, NY, USA.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for c in nx.connected_components(G):</span>
<span class="gi">+        yield from connected_cuthill_mckee_ordering(G.subgraph(c), heuristic)</span>


<span class="w"> </span>def reverse_cuthill_mckee_ordering(G, heuristic=None):
<span class="gu">@@ -117,4 +121,38 @@ def reverse_cuthill_mckee_ordering(G, heuristic=None):</span>
<span class="w"> </span>    .. [2]  Steven S. Skiena. 1997. The Algorithm Design Manual.
<span class="w"> </span>       Springer-Verlag New York, Inc., New York, NY, USA.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return reversed(list(cuthill_mckee_ordering(G, heuristic=heuristic)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def connected_cuthill_mckee_ordering(G, heuristic=None):</span>
<span class="gi">+    # the cuthill mckee algorithm for connected graphs</span>
<span class="gi">+    if heuristic is None:</span>
<span class="gi">+        start = pseudo_peripheral_node(G)</span>
<span class="gi">+    else:</span>
<span class="gi">+        start = heuristic(G)</span>
<span class="gi">+    visited = {start}</span>
<span class="gi">+    queue = deque([start])</span>
<span class="gi">+    while queue:</span>
<span class="gi">+        parent = queue.popleft()</span>
<span class="gi">+        yield parent</span>
<span class="gi">+        nd = sorted(G.degree(set(G[parent]) - visited), key=itemgetter(1))</span>
<span class="gi">+        children = [n for n, d in nd]</span>
<span class="gi">+        visited.update(children)</span>
<span class="gi">+        queue.extend(children)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def pseudo_peripheral_node(G):</span>
<span class="gi">+    # helper for cuthill-mckee to find a node in a &quot;pseudo peripheral pair&quot;</span>
<span class="gi">+    # to use as good starting node</span>
<span class="gi">+    u = arbitrary_element(G)</span>
<span class="gi">+    lp = 0</span>
<span class="gi">+    v = u</span>
<span class="gi">+    while True:</span>
<span class="gi">+        spl = dict(nx.shortest_path_length(G, v))</span>
<span class="gi">+        l = max(spl.values())</span>
<span class="gi">+        if l &lt;= lp:</span>
<span class="gi">+            break</span>
<span class="gi">+        lp = l</span>
<span class="gi">+        farthest = (n for n, dist in spl.items() if dist == l)</span>
<span class="gi">+        v, deg = min(G.degree(farthest), key=itemgetter(1))</span>
<span class="gi">+    return v</span>
<span class="gh">diff --git a/networkx/utils/union_find.py b/networkx/utils/union_find.py</span>
<span class="gh">index 4d9d7ad5f..2a07129f5 100644</span>
<span class="gd">--- a/networkx/utils/union_find.py</span>
<span class="gi">+++ b/networkx/utils/union_find.py</span>
<span class="gu">@@ -1,6 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>Union-find data structure.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from networkx.utils import groups


<span class="gu">@@ -44,16 +45,22 @@ class UnionFind:</span>

<span class="w"> </span>    def __getitem__(self, object):
<span class="w"> </span>        &quot;&quot;&quot;Find and return the name of the set containing the object.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+        # check for previously unknown object</span>
<span class="w"> </span>        if object not in self.parents:
<span class="w"> </span>            self.parents[object] = object
<span class="w"> </span>            self.weights[object] = 1
<span class="w"> </span>            return object
<span class="gi">+</span>
<span class="gi">+        # find path of objects leading to the root</span>
<span class="w"> </span>        path = []
<span class="w"> </span>        root = self.parents[object]
<span class="w"> </span>        while root != object:
<span class="w"> </span>            path.append(object)
<span class="w"> </span>            object = root
<span class="w"> </span>            root = self.parents[object]
<span class="gi">+</span>
<span class="gi">+        # compress the path and return</span>
<span class="w"> </span>        for ancestor in path:
<span class="w"> </span>            self.parents[ancestor] = root
<span class="w"> </span>        return root
<span class="gu">@@ -75,8 +82,25 @@ class UnionFind:</span>
<span class="w"> </span>            [[&#39;x&#39;, &#39;y&#39;], [&#39;z&#39;]]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Ensure fully pruned paths</span>
<span class="gi">+        for x in self.parents:</span>
<span class="gi">+            _ = self[x]  # Evaluated for side-effect only</span>
<span class="gi">+</span>
<span class="gi">+        yield from groups(self.parents).values()</span>

<span class="w"> </span>    def union(self, *objects):
<span class="w"> </span>        &quot;&quot;&quot;Find the sets containing the objects and merge them all.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Find the heaviest root according to its weight.</span>
<span class="gi">+        roots = iter(</span>
<span class="gi">+            sorted(</span>
<span class="gi">+                {self[x] for x in objects}, key=lambda r: self.weights[r], reverse=True</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        try:</span>
<span class="gi">+            root = next(roots)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for r in roots:</span>
<span class="gi">+            self.weights[root] += self.weights[r]</span>
<span class="gi">+            self.parents[r] = root</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>