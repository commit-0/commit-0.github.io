
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference pylint - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-pylint" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference pylint
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unittest_non_ascii_namepytestnonasciicheckertest_check_importfrom_okay_module_import_bad_as_good_and_star" class="md-nav__link">
    <span class="md-ellipsis">
      unittest_non_ascii_name.py::TestNonAsciiChecker::test_check_import[from_okay_module_import_bad_as_good_and_star]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unittest_invalid_encodingpytestinvalidencodingtest_invalid_unicode_filespep_bidirectional_utf_16_le_no_bomtxt-2" class="md-nav__link">
    <span class="md-ellipsis">
      unittest_invalid_encoding.py::TestInvalidEncoding::test_invalid_unicode_files[pep_bidirectional_utf_16_le_no_bom.txt-2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unittest_invalid_encodingpytestinvalidencodingtest_invalid_unicode_filespep_bidirectional_utf_32_le_no_bomtxt-2" class="md-nav__link">
    <span class="md-ellipsis">
      unittest_invalid_encoding.py::TestInvalidEncoding::test_invalid_unicode_files[pep_bidirectional_utf_32_le_no_bom.txt-2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unittest_invalid_encodingpytestinvalidencodingtest__determine_codecpep263_utf-16le_real" class="md-nav__link">
    <span class="md-ellipsis">
      unittest_invalid_encoding.py::TestInvalidEncoding::test__determine_codec[pep263_utf-16le_real]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalinconsistent_returns" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[inconsistent_returns]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalinvalid_all_format_valid_5" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[invalid_all_format_valid_5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalinvalid_all_format_valid_6" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[invalid_all_format_valid_6]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalrecursion_error_3152" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[recursion_error_3152]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalregression_4680" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[regression_4680]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalunreachable" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[unreachable]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalundefined_variable_typing" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[undefined_variable_typing]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalunused_import_assigned_to" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[unused_import_assigned_to]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalused_before_assignment" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[used_before_assignment]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_functionalpytest_functionalused_before_assignment_else_return" class="md-nav__link">
    <span class="md-ellipsis">
      test_functional.py::test_functional[used_before_assignment_else_return]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regrpytest_packagefile_names1-" class="md-nav__link">
    <span class="md-ellipsis">
      test_regr.py::test_package[file_names1-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selfpytestruntctest_abbreviations_are_not_supported" class="md-nav__link">
    <span class="md-ellipsis">
      test_self.py::TestRunTC::test_abbreviations_are_not_supported
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selfpytestruntctest_do_not_import_files_from_local_directoryargs0" class="md-nav__link">
    <span class="md-ellipsis">
      test_self.py::TestRunTC::test_do_not_import_files_from_local_directory[args0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_selfpytestruntctest_do_not_import_files_from_local_directoryargs1" class="md-nav__link">
    <span class="md-ellipsis">
      test_self.py::TestRunTC::test_do_not_import_files_from_local_directory[args1]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-pylint"><strong>Reference (Gold)</strong>: pylint</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">1825</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">333</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">13</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">2176</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">2176</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="unittest_non_ascii_namepytestnonasciicheckertest_check_importfrom_okay_module_import_bad_as_good_and_star">unittest_non_ascii_name.py::TestNonAsciiChecker::test_check_import[from_okay_module_import_bad_as_good_and_star]</h3>
<details><summary> <pre>unittest_non_ascii_name.py::TestNonAsciiChecker::test_check_import[from_okay_module_import_bad_as_good_and_star]</pre></summary><pre>
self = <astroid.builder.AstroidBuilder object at 0x7f244a7f78e0>
data = 'from foo.bar import functiøn as good, * #@', modname = '', path = None

    def _data_build(
        self, data: str, modname: str, path: str | None
    ) -> tuple[nodes.Module, rebuilder.TreeRebuilder]:
        """Build tree node from data and add some informations."""
        try:
>           node, parser_module = _parse_string(
                data, type_comments=True, modname=modname
            )

.venv/lib/python3.10/site-packages/astroid/builder.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/astroid/builder.py:480: in _parse_string
    parsed = parser_module.parse(
.venv/lib/python3.10/site-packages/astroid/_ast.py:30: in parse
    return ast.parse(string, type_comments=type_comments)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'from foo.bar import functiøn as good, * #@\n', filename = '<unknown>'
mode = 'exec'

    def parse(source, filename='<unknown>', mode='exec', *,
              type_comments=False, feature_version=None):
        """
        Parse the source into an AST node.
        Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
        Pass type_comments=True to get back type comments where the syntax allows.
        """
        flags = PyCF_ONLY_AST
        if type_comments:
            flags |= PyCF_TYPE_COMMENTS
        if isinstance(feature_version, tuple):
            major, minor = feature_version  # Should be a 2-tuple.
            assert major == 3
            feature_version = minor
        elif feature_version is None:
            feature_version = -1
        # Else it should be an int giving the minor version for 3.x.
>       return compile(source, filename, mode, flags,
                       _feature_version=feature_version)
E         File "<unknown>", line 1
E           from foo.bar import functiøn as good, * #@
E                                                 ^
E       SyntaxError: invalid syntax

/usr/lib/python3.10/ast.py:50: SyntaxError

The above exception was the direct cause of the following exception:

self = <checkers.unittest_non_ascii_name.TestNonAsciiChecker object at 0x7f244d2409d0>
import_statement = 'from foo.bar import functiøn as good, *'
wrong_name = 'functiøn'

    @pytest.mark.parametrize(
        "import_statement, wrong_name",
        [
            pytest.param("import fürimma", "fürimma", id="bad_single_main_module"),
            pytest.param(
                "import fürimma as okay",
                None,
                id="bad_single_main_module_with_okay_alias",
            ),
            pytest.param(
                "import fürimma, pathlib",
                "fürimma",
                id="bad_single_main_module_with_stdlib_import",
            ),
            pytest.param(
                "import pathlib, os, foobar, fürimma",
                "fürimma",
                id="stdlib_with_bad_single_main_module",
            ),
            pytest.param(
                "import pathlib, os, foobar, sys as systëm",
                "systëm",
                id="stdlib_with_bad_alias",
            ),
            pytest.param(
                "import fürimma as okay, pathlib",
                None,
                id="bad_single_main_module_with_okay_alias_with_stdlib_import",
            ),
            pytest.param(
                "import fürimma.submodule", "fürimma.submodule", id="bad_main_module"
            ),
            pytest.param(
                "import fürimma.submodule as submodule",
                None,
                id="bad_main_module_with_okay_alias",
            ),
            pytest.param(
                "import main_module.fürimma", "main_module.fürimma", id="bad_submodule"
            ),
            pytest.param(
                "import main_module.fürimma as okay",
                None,
                id="bad_submodule_with_okay_alias",
            ),
            pytest.param(
                "import main_module.fürimma as not_økay",
                "not_økay",
                id="bad_submodule_with_bad_alias",
            ),
            pytest.param(
                "from foo.bar import function", None, id="from_okay_module_import_okay"
            ),
            pytest.param(
                "from foo.bär import function", None, id="from_bad_module_import_okay"
            ),
            pytest.param(
                "from foo.bar import functiøn",
                "functiøn",
                id="from_okay_module_import_bad",
            ),
            pytest.param(
                "from foo.bar import functiøn as function",
                None,
                id="from_okay_module_import_bad_as_good",
            ),
            pytest.param(
                "from foo.bär import functiøn as function",
                None,
                id="from_bad_module_import_bad_as_good",
            ),
            pytest.param(
                "from foo.bar import functiøn as føl",
                "føl",
                id="from_okay_module_import_bad_as_bad",
            ),
            pytest.param(
                "from foo.bar import functiøn as good, bäd",
                "bäd",
                id="from_okay_module_import_bad_as_good_and_bad",
            ),
            pytest.param(
                "from foo.bar import functiøn as good, bäd",
                "bäd",
                id="from_okay_module_import_bad_as_good_and_bad",
            ),
            pytest.param(
                "from foo.bar import functiøn as good, *",
                # We still have functiøn within our namespace and could detect this
                # But to do this properly we would need to check all `*` imports
                # -> Too much effort!
                "functiøn",
                id="from_okay_module_import_bad_as_good_and_star",
                marks=pytest.mark.xfail(
                    reason="We don't know what is imported when using star"
                ),
            ),
        ],
    )
    def test_check_import(self, import_statement: str, wrong_name: str | None) -> None:
        """We expect that for everything that user can change there is a message."""
>       node = astroid.extract_node(f"{import_statement} #@")

tests/checkers/unittest_non_ascii_name.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/astroid/builder.py:446: in extract_node
    tree = parse(code, module_name=module_name)
.venv/lib/python3.10/site-packages/astroid/builder.py:303: in parse
    return builder.string_build(code, modname=module_name, path=path)
.venv/lib/python3.10/site-packages/astroid/builder.py:151: in string_build
    module, builder = self._data_build(data, modname, path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astroid.builder.AstroidBuilder object at 0x7f244a7f78e0>
data = 'from foo.bar import functiøn as good, * #@', modname = '', path = None

    def _data_build(
        self, data: str, modname: str, path: str | None
    ) -> tuple[nodes.Module, rebuilder.TreeRebuilder]:
        """Build tree node from data and add some informations."""
        try:
            node, parser_module = _parse_string(
                data, type_comments=True, modname=modname
            )
        except (TypeError, ValueError, SyntaxError) as exc:
>           raise AstroidSyntaxError(
                "Parsing Python code failed:\n{error}",
                source=data,
                modname=modname,
                path=path,
                error=exc,
            ) from exc
E           astroid.exceptions.AstroidSyntaxError: Parsing Python code failed:
E           invalid syntax (<unknown>, line 1)

.venv/lib/python3.10/site-packages/astroid/builder.py:185: AstroidSyntaxError
</pre>
</details>
<h3 id="unittest_invalid_encodingpytestinvalidencodingtest_invalid_unicode_filespep_bidirectional_utf_16_le_no_bomtxt-2">unittest_invalid_encoding.py::TestInvalidEncoding::test_invalid_unicode_files[pep_bidirectional_utf_16_le_no_bom.txt-2]</h3>
<details><summary> <pre>unittest_invalid_encoding.py::TestInvalidEncoding::test_invalid_unicode_files[pep_bidirectional_utf_16_le_no_bom.txt-2]</pre></summary><pre>
self = <checkers.unittest_unicode.unittest_invalid_encoding.TestInvalidEncoding object at 0x7f244e7d4df0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_invalid_unicode_files_pep0')
test_file = 'pep_bidirectional_utf_16_le_no_bom.txt', line_no = 2

    @pytest.mark.parametrize(
        "test_file, line_no",
        [
            pytest.param(
                "pep_bidirectional_utf_16_le_no_bom.txt",
                2,
                marks=pytest.mark.xfail(
                    reason="Python currently doesn't support UTF-16 code detection"
                ),
            ),
            pytest.param(
                "pep_bidirectional_utf_32_le_no_bom.txt",
                2,
                marks=pytest.mark.xfail(
                    reason="Python currently doesn't support UTF-32 code detection"
                ),
            ),
            # A note to the xfails above: If you open these files in an editor, you
            # only will see garbage if you don't select the correct encoding by hand.
            # Still maybe in the future the python way of defining the encoding could
            # work - even so it is unlikely as the first line is not ASCII and would
            # have to be treated differently anyway...
            ("pep_bidirectional_utf_16_bom.txt", 1),
            ("pep_bidirectional_utf_32_bom.txt", 1),
        ],
    )
    def test_invalid_unicode_files(
        self, tmp_path: Path, test_file: str, line_no: int
    ) -> None:
        test_file_path = UNICODE_TESTS / test_file
        target = shutil.copy(
            test_file_path, tmp_path / test_file.replace(".txt", ".py")
        )

        # Fake node as otherwise we get syntax errors etc...
        # So currently the UTF-16/UTF-32 tests does not work, as UTF-16 / UTF-32
        # is not really working at all in in Python, but checking it now already
        # is future save in case that changes....

        module = FakeNode(Path(target).read_bytes())

>       with self.assertAddsMessages(
            pylint.testutils.MessageTest(
                msg_id="invalid-unicode-codec",
                confidence=pylint.interfaces.HIGH,
                # node=module,
                line=line_no,
                end_line=1,
                col_offset=None,
                end_col_offset=None,
            ),
            pylint.testutils.MessageTest(
                msg_id="bidirectional-unicode",
                confidence=pylint.interfaces.HIGH,
                # node=module,
                line=line_no + 2,
                end_line=line_no + 2,
                col_offset=0,
                end_col_offset=37,
            ),
        ):

tests/checkers/unittest_unicode/unittest_invalid_encoding.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:142: in __exit__
    next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <checkers.unittest_unicode.unittest_invalid_encoding.TestInvalidEncoding object at 0x7f244e7d4df0>
ignore_position = False
messages = (MessageTest(msg_id='invalid-unicode-codec', line=2, node=None, args=None, confidence=Confidence(name='HIGH', descript...me='HIGH', description='Warning that is not based on inference result.'), col_offset=0, end_line=4, end_col_offset=37))
got = [MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', descript...GH', description='Warning that is not based on inference result.'), col_offset=12, end_line=1, end_col_offset=13), ...]
no_msg = 'No message.'

    @contextlib.contextmanager
    def assertAddsMessages(
        self, *messages: MessageTest, ignore_position: bool = False
    ) -> Generator[None, None, None]:
        """Assert that exactly the given method adds the given messages.

        The list of messages must exactly match *all* the messages added by the
        method. Additionally, we check to see whether the args in each message can
        actually be substituted into the message string.

        Using the keyword argument `ignore_position`, all checks for position
        arguments (line, col_offset, ...) will be skipped. This can be used to
        just test messages for the correct node.
        """
        yield
        got = self.linter.release_messages()
        no_msg = "No message."
        expected = "\n".join(repr(m) for m in messages) or no_msg
        got_str = "\n".join(repr(m) for m in got) or no_msg
        msg = (
            "Expected messages did not match actual.\n"
            f"\nExpected:\n{expected}\n\nGot:\n{got_str}\n"
        )

>       assert len(messages) == len(got), msg
E       AssertionError: Expected messages did not match actual.
E         
E         Expected:
E         MessageTest(msg_id='invalid-unicode-codec', line=2, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=None, end_line=1, end_col_offset=None)
E         MessageTest(msg_id='bidirectional-unicode', line=4, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=0, end_line=4, end_col_offset=37)
E         
E         Got:
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=2, end_line=1, end_col_offset=3)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=4, end_line=1, end_col_offset=5)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=6, end_line=1, end_col_offset=7)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=8, end_line=1, end_col_offset=9)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=10, end_line=1, end_col_offset=11)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=12, end_line=1, end_col_offset=13)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=14, end_line=1, end_col_offset=15)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=16, end_line=1, end_col_offset=17)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=18, end_line=1, end_col_offset=19)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=20, end_line=1, end_col_offset=21)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=22, end_line=1, end_col_offset=23)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=24, end_line=1, end_col_offset=25)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=26, end_line=1, end_col_offset=27)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=28, end_line=1, end_col_offset=29)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=30, end_line=1, end_col_offset=31)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=32, end_line=1, end_col_offset=33)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=34, end_line=1, end_col_offset=35)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=36, end_line=1, end_col_offset=37)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=38, end_line=1, end_col_offset=39)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=40, end_line=1, end_col_offset=41)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=42, end_line=1, end_col_offset=43)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=44, end_line=1, end_col_offset=45)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=46, end_line=1, end_col_offset=47)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=48, end_line=1, end_col_offset=49)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=50, end_line=1, end_col_offset=51)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=52, end_line=1, end_col_offset=53)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=54, end_line=1, end_col_offset=55)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=56, end_line=1, end_col_offset=57)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=58, end_line=1, end_col_offset=59)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=60, end_line=1, end_col_offset=61)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=62, end_line=1, end_col_offset=63)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=64, end_line=1, end_col_offset=65)
E         
E       assert 2 == 32
E        +  where 2 = len((MessageTest(msg_id='invalid-unicode-codec', line=2, node=None, args=None, confidence=Confidence(name='HIGH', descript...me='HIGH', description='Warning that is not based on inference result.'), col_offset=0, end_line=4, end_col_offset=37)))
E        +  and   32 = len([MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', descript...GH', description='Warning that is not based on inference result.'), col_offset=12, end_line=1, end_col_offset=13), ...])

pylint/testutils/checker_test_case.py:65: AssertionError
</pre>
</details>
<h3 id="unittest_invalid_encodingpytestinvalidencodingtest_invalid_unicode_filespep_bidirectional_utf_32_le_no_bomtxt-2">unittest_invalid_encoding.py::TestInvalidEncoding::test_invalid_unicode_files[pep_bidirectional_utf_32_le_no_bom.txt-2]</h3>
<details><summary> <pre>unittest_invalid_encoding.py::TestInvalidEncoding::test_invalid_unicode_files[pep_bidirectional_utf_32_le_no_bom.txt-2]</pre></summary><pre>
self = <checkers.unittest_unicode.unittest_invalid_encoding.TestInvalidEncoding object at 0x7f244e7d4910>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_invalid_unicode_files_pep1')
test_file = 'pep_bidirectional_utf_32_le_no_bom.txt', line_no = 2

    @pytest.mark.parametrize(
        "test_file, line_no",
        [
            pytest.param(
                "pep_bidirectional_utf_16_le_no_bom.txt",
                2,
                marks=pytest.mark.xfail(
                    reason="Python currently doesn't support UTF-16 code detection"
                ),
            ),
            pytest.param(
                "pep_bidirectional_utf_32_le_no_bom.txt",
                2,
                marks=pytest.mark.xfail(
                    reason="Python currently doesn't support UTF-32 code detection"
                ),
            ),
            # A note to the xfails above: If you open these files in an editor, you
            # only will see garbage if you don't select the correct encoding by hand.
            # Still maybe in the future the python way of defining the encoding could
            # work - even so it is unlikely as the first line is not ASCII and would
            # have to be treated differently anyway...
            ("pep_bidirectional_utf_16_bom.txt", 1),
            ("pep_bidirectional_utf_32_bom.txt", 1),
        ],
    )
    def test_invalid_unicode_files(
        self, tmp_path: Path, test_file: str, line_no: int
    ) -> None:
        test_file_path = UNICODE_TESTS / test_file
        target = shutil.copy(
            test_file_path, tmp_path / test_file.replace(".txt", ".py")
        )

        # Fake node as otherwise we get syntax errors etc...
        # So currently the UTF-16/UTF-32 tests does not work, as UTF-16 / UTF-32
        # is not really working at all in in Python, but checking it now already
        # is future save in case that changes....

        module = FakeNode(Path(target).read_bytes())

>       with self.assertAddsMessages(
            pylint.testutils.MessageTest(
                msg_id="invalid-unicode-codec",
                confidence=pylint.interfaces.HIGH,
                # node=module,
                line=line_no,
                end_line=1,
                col_offset=None,
                end_col_offset=None,
            ),
            pylint.testutils.MessageTest(
                msg_id="bidirectional-unicode",
                confidence=pylint.interfaces.HIGH,
                # node=module,
                line=line_no + 2,
                end_line=line_no + 2,
                col_offset=0,
                end_col_offset=37,
            ),
        ):

tests/checkers/unittest_unicode/unittest_invalid_encoding.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:142: in __exit__
    next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <checkers.unittest_unicode.unittest_invalid_encoding.TestInvalidEncoding object at 0x7f244e7d4910>
ignore_position = False
messages = (MessageTest(msg_id='invalid-unicode-codec', line=2, node=None, args=None, confidence=Confidence(name='HIGH', descript...me='HIGH', description='Warning that is not based on inference result.'), col_offset=0, end_line=4, end_col_offset=37))
got = [MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', descript...HIGH', description='Warning that is not based on inference result.'), col_offset=8, end_line=1, end_col_offset=9), ...]
no_msg = 'No message.'

    @contextlib.contextmanager
    def assertAddsMessages(
        self, *messages: MessageTest, ignore_position: bool = False
    ) -> Generator[None, None, None]:
        """Assert that exactly the given method adds the given messages.

        The list of messages must exactly match *all* the messages added by the
        method. Additionally, we check to see whether the args in each message can
        actually be substituted into the message string.

        Using the keyword argument `ignore_position`, all checks for position
        arguments (line, col_offset, ...) will be skipped. This can be used to
        just test messages for the correct node.
        """
        yield
        got = self.linter.release_messages()
        no_msg = "No message."
        expected = "\n".join(repr(m) for m in messages) or no_msg
        got_str = "\n".join(repr(m) for m in got) or no_msg
        msg = (
            "Expected messages did not match actual.\n"
            f"\nExpected:\n{expected}\n\nGot:\n{got_str}\n"
        )

>       assert len(messages) == len(got), msg
E       AssertionError: Expected messages did not match actual.
E         
E         Expected:
E         MessageTest(msg_id='invalid-unicode-codec', line=2, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=None, end_line=1, end_col_offset=None)
E         MessageTest(msg_id='bidirectional-unicode', line=4, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=0, end_line=4, end_col_offset=37)
E         
E         Got:
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=2, end_line=1, end_col_offset=3)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=3, end_line=1, end_col_offset=4)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=4, end_line=1, end_col_offset=5)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=6, end_line=1, end_col_offset=7)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=7, end_line=1, end_col_offset=8)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=8, end_line=1, end_col_offset=9)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=10, end_line=1, end_col_offset=11)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=11, end_line=1, end_col_offset=12)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=12, end_line=1, end_col_offset=13)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=14, end_line=1, end_col_offset=15)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=15, end_line=1, end_col_offset=16)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=16, end_line=1, end_col_offset=17)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=18, end_line=1, end_col_offset=19)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=19, end_line=1, end_col_offset=20)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=20, end_line=1, end_col_offset=21)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=22, end_line=1, end_col_offset=23)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=23, end_line=1, end_col_offset=24)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=24, end_line=1, end_col_offset=25)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=26, end_line=1, end_col_offset=27)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=27, end_line=1, end_col_offset=28)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=28, end_line=1, end_col_offset=29)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=30, end_line=1, end_col_offset=31)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=31, end_line=1, end_col_offset=32)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=32, end_line=1, end_col_offset=33)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=34, end_line=1, end_col_offset=35)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=35, end_line=1, end_col_offset=36)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=36, end_line=1, end_col_offset=37)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=38, end_line=1, end_col_offset=39)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=39, end_line=1, end_col_offset=40)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=40, end_line=1, end_col_offset=41)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=42, end_line=1, end_col_offset=43)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=43, end_line=1, end_col_offset=44)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=44, end_line=1, end_col_offset=45)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=46, end_line=1, end_col_offset=47)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=47, end_line=1, end_col_offset=48)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=48, end_line=1, end_col_offset=49)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=50, end_line=1, end_col_offset=51)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=51, end_line=1, end_col_offset=52)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=52, end_line=1, end_col_offset=53)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=54, end_line=1, end_col_offset=55)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=55, end_line=1, end_col_offset=56)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=56, end_line=1, end_col_offset=57)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=58, end_line=1, end_col_offset=59)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=59, end_line=1, end_col_offset=60)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=60, end_line=1, end_col_offset=61)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=62, end_line=1, end_col_offset=63)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=63, end_line=1, end_col_offset=64)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=64, end_line=1, end_col_offset=65)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=66, end_line=1, end_col_offset=67)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=67, end_line=1, end_col_offset=68)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=68, end_line=1, end_col_offset=69)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=70, end_line=1, end_col_offset=71)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=71, end_line=1, end_col_offset=72)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=72, end_line=1, end_col_offset=73)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=74, end_line=1, end_col_offset=75)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=75, end_line=1, end_col_offset=76)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=76, end_line=1, end_col_offset=77)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=78, end_line=1, end_col_offset=79)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=79, end_line=1, end_col_offset=80)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=80, end_line=1, end_col_offset=81)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=82, end_line=1, end_col_offset=83)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=83, end_line=1, end_col_offset=84)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=84, end_line=1, end_col_offset=85)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=86, end_line=1, end_col_offset=87)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=87, end_line=1, end_col_offset=88)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=88, end_line=1, end_col_offset=89)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=90, end_line=1, end_col_offset=91)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=91, end_line=1, end_col_offset=92)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=92, end_line=1, end_col_offset=93)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=94, end_line=1, end_col_offset=95)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=95, end_line=1, end_col_offset=96)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=96, end_line=1, end_col_offset=97)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=98, end_line=1, end_col_offset=99)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=99, end_line=1, end_col_offset=100)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=100, end_line=1, end_col_offset=101)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=102, end_line=1, end_col_offset=103)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=103, end_line=1, end_col_offset=104)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=104, end_line=1, end_col_offset=105)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=106, end_line=1, end_col_offset=107)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=107, end_line=1, end_col_offset=108)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=108, end_line=1, end_col_offset=109)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=110, end_line=1, end_col_offset=111)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=111, end_line=1, end_col_offset=112)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=112, end_line=1, end_col_offset=113)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=114, end_line=1, end_col_offset=115)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=115, end_line=1, end_col_offset=116)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=116, end_line=1, end_col_offset=117)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=118, end_line=1, end_col_offset=119)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=119, end_line=1, end_col_offset=120)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=120, end_line=1, end_col_offset=121)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=122, end_line=1, end_col_offset=123)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=123, end_line=1, end_col_offset=124)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=124, end_line=1, end_col_offset=125)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=126, end_line=1, end_col_offset=127)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=127, end_line=1, end_col_offset=128)
E         MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', description='Warning that is not based on inference result.'), col_offset=128, end_line=1, end_col_offset=129)
E         
E       assert 2 == 96
E        +  where 2 = len((MessageTest(msg_id='invalid-unicode-codec', line=2, node=None, args=None, confidence=Confidence(name='HIGH', descript...me='HIGH', description='Warning that is not based on inference result.'), col_offset=0, end_line=4, end_col_offset=37)))
E        +  and   96 = len([MessageTest(msg_id='invalid-character-nul', line=1, node=None, args=None, confidence=Confidence(name='HIGH', descript...HIGH', description='Warning that is not based on inference result.'), col_offset=8, end_line=1, end_col_offset=9), ...])

pylint/testutils/checker_test_case.py:65: AssertionError
</pre>
</details>
<h3 id="unittest_invalid_encodingpytestinvalidencodingtest__determine_codecpep263_utf-16le_real">unittest_invalid_encoding.py::TestInvalidEncoding::test__determine_codec[pep263_utf-16le_real]</h3>
<details><summary> <pre>unittest_invalid_encoding.py::TestInvalidEncoding::test__determine_codec[pep263_utf-16le_real]</pre></summary><pre>
self = <checkers.unittest_unicode.unittest_invalid_encoding.TestInvalidEncoding object at 0x7f244d48ee30>
content = b'#\x00 \x00c\x00o\x00d\x00i\x00n\x00g\x00:\x00 \x00U\x00T\x00F\x00-\x001\x006\x00l\x00e\x00'
codec = 'utf-16le', line = 1

    @pytest.mark.parametrize(
        "content, codec, line",
        [
            pytest.param(b"# Nothing", "utf-8", 1, id="default_utf8"),
            pytest.param(b"# coding: latin-1", "iso-8859-1", 1, id="pep263_latin1"),
            pytest.param(
                b"#!/usr/bin/python\n# coding: latin-1",
                "iso-8859-1",
                2,
                id="pep263_latin1_multiline",
            ),
            pytest.param(b"# coding: ascii", "ascii", 1, id="pep263_ascii"),
            pytest.param(b"# coding: UTF-8", "utf-8", 1, id="pep263_utf-8"),
            # This looks correct but is actually wrong. If you would try to decode
            # the byte to utf-16be it would fail
            pytest.param(
                b"# coding: UTF-16le", "utf-16le", 1, id="pep263_utf-16le_fake"
            ),
            # This contains no bom but a correct encoding line in none ascii
            # So this fails at the moment
            pytest.param(
                "# coding: UTF-16le".encode("utf-16le"),
                "utf-16le",
                1,
                id="pep263_utf-16le_real",
                marks=pytest.mark.xfail(reason="Currently not supported by Python"),
            ),
            *(
                pytest.param(bom, codec, 1, id=f"bom_{codec}")
                for codec, bom in (
                    ("utf-8", codecs.BOM_UTF8),
                    ("utf-16le", codecs.BOM_UTF16_LE),
                    ("utf-16be", codecs.BOM_UTF16_BE),
                    ("utf-32le", codecs.BOM_UTF32_LE),
                    ("utf-32be", codecs.BOM_UTF32_BE),
                )
            ),
        ],
    )
    def test__determine_codec(self, content: bytes, codec: str, line: int) -> None:
        """The codec determined should be exact no matter what we throw at it."""
>       assert self.checker._determine_codec(io.BytesIO(content)) == (codec, line)
E       AssertionError: assert ('utf-8', 1) == ('utf-16le', 1)
E         
E         At index 0 diff: 'utf-8' != 'utf-16le'
E         Use -v to get more diff

tests/checkers/unittest_unicode/unittest_invalid_encoding.py:133: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalinconsistent_returns">test_functional.py::test_functional[inconsistent_returns]</h3>
<details><summary> <pre>test_functional.py::test_functional[inconsistent_returns]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f242b6eebc0>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "inconsistent_returns.py":
E       
E       Unexpected in testdata:
E        111: inconsistent-return-statements

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalinvalid_all_format_valid_5">test_functional.py::test_functional[invalid_all_format_valid_5]</h3>
<details><summary> <pre>test_functional.py::test_functional[invalid_all_format_valid_5]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f242df65420>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "invalid_all_format_valid_5.py":
E       
E       Unexpected in testdata:
E          5: no-name-in-module

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalinvalid_all_format_valid_6">test_functional.py::test_functional[invalid_all_format_valid_6]</h3>
<details><summary> <pre>test_functional.py::test_functional[invalid_all_format_valid_6]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f2429eebd00>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "invalid_all_format_valid_6.py":
E       
E       Unexpected in testdata:
E          5: no-name-in-module

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalrecursion_error_3152">test_functional.py::test_functional[recursion_error_3152]</h3>
<details><summary> <pre>test_functional.py::test_functional[recursion_error_3152]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f2427078070>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "recursion_error_3152.py":
E       
E       Unexpected in testdata:
E          6: abstract-method

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalregression_4680">test_functional.py::test_functional[regression_4680]</h3>
<details><summary> <pre>test_functional.py::test_functional[regression_4680]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f2422eaf0d0>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "regression_4680.py":
E       
E       Unexpected in testdata:
E          3: no-name-in-module
E         18: c-extension-no-member

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalunreachable">test_functional.py::test_functional[unreachable]</h3>
<details><summary> <pre>test_functional.py::test_functional[unreachable]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f241dad2110>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "unreachable.py":
E       
E       Expected in testdata:
E         42: unreachable
E         80: unreachable

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalundefined_variable_typing">test_functional.py::test_functional[undefined_variable_typing]</h3>
<details><summary> <pre>test_functional.py::test_functional[undefined_variable_typing]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f241c672350>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "undefined_variable_typing.py":
E       
E       Unexpected in testdata:
E         10: no-name-in-module

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalunused_import_assigned_to">test_functional.py::test_functional[unused_import_assigned_to]</h3>
<details><summary> <pre>test_functional.py::test_functional[unused_import_assigned_to]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f241ac43f70>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "unused_import_assigned_to.py":
E       
E       Unexpected in testdata:
E         25: c-extension-no-member

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalused_before_assignment">test_functional.py::test_functional[used_before_assignment]</h3>
<details><summary> <pre>test_functional.py::test_functional[used_before_assignment]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f241d18ff40>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "used_before_assignment.py":
E       
E       Unexpected in testdata:
E        127: possibly-used-before-assignment

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_functionalpytest_functionalused_before_assignment_else_return">test_functional.py::test_functional[used_before_assignment_else_return]</h3>
<details><summary> <pre>test_functional.py::test_functional[used_before_assignment_else_return]</pre></summary><pre>
self = <pylint.testutils.lint_module_test.LintModuleTest object at 0x7f24287b7ca0>

    def runTest(self) -> None:
>       self._runTest()
E       AssertionError: Wrong message(s) raised for "used_before_assignment_else_return.py":
E       
E       Unexpected in testdata:
E         71: used-before-assignment

pylint/testutils/lint_module_test.py:147: AssertionError
</pre>
</details>
<h3 id="test_regrpytest_packagefile_names1-">test_regr.py::test_package[file_names1-<lambda>]</h3>
<details><summary> <pre>test_regr.py::test_package[file_names1-<lambda>]</pre></summary><pre>
finalize_linter = Checker 'main' (responsible for 'F0001', 'F0002', 'F0010', 'F0011', 'I0001', 'I0010', 'I0011', 'I0013', 'I0020', 'I0021', 'I0022', 'E0001', 'E0011', 'W0012', 'R0022', 'E0013', 'E0014', 'E0015')
file_names = ['precedence_test']
check = <function Equals.<locals>.<lambda> at 0x7f244b8623b0>

    @pytest.mark.parametrize(
        "file_names, check",
        [
            (["package.__init__"], Equals("")),
            (["precedence_test"], Equals("")),
            (["import_package_subpackage_module"], Equals("")),
            (["pylint.checkers.__init__"], lambda x: "__path__" not in x),
            ([join(REGR_DATA, "classdoc_usage.py")], Equals("")),
            ([join(REGR_DATA, "module_global.py")], Equals("")),
            ([join(REGR_DATA, "decimal_inference.py")], Equals("")),
            ([join(REGR_DATA, "absimp", "string.py")], Equals("")),
            ([join(REGR_DATA, "bad_package")], lambda x: "Unused import missing" in x),
        ],
    )
    def test_package(
        finalize_linter: PyLinter, file_names: list[str], check: Callable[[str], bool]
    ) -> None:
        finalize_linter.check(file_names)
        finalize_linter.reporter = cast(  # Due to fixture
            testutils.GenericTestReporter, finalize_linter.reporter
        )
        got = finalize_linter.reporter.finalize().strip()
>       assert check(got)
E       assert False
E        +  where False = <function Equals.<locals>.<lambda> at 0x7f244b8623b0>("E: 21: Module 'package.AudioTime' has no 'DECIMAL' member")

tests/test_regr.py:77: AssertionError
</pre>
</details>
<h3 id="test_selfpytestruntctest_abbreviations_are_not_supported">test_self.py::TestRunTC::test_abbreviations_are_not_supported</h3>
<details><summary> <pre>test_self.py::TestRunTC::test_abbreviations_are_not_supported</pre></summary><pre>
self = <test_self.TestRunTC object at 0x7f244be725f0>

    @pytest.mark.xfail
    def test_abbreviations_are_not_supported(self) -> None:
        expected = "No module named --load-plugin"
>       self._test_output([".", "--load-plugin"], expected_output=expected)

tests/test_self.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_self.TestRunTC object at 0x7f244be725f0>
args = ['--rcfile=/testbed/pylint/testutils/testing_pylintrc', '.', '--load-plugin']
expected_output = 'No module named --load-plugin', unexpected_output = ''

    def _test_output(
        self, args: list[str], expected_output: str, unexpected_output: str = ""
    ) -> None:
        out = StringIO()
        args = _add_rcfile_default_pylintrc(args)
        self._run_pylint(args, out=out)
        actual_output = self._clean_paths(out.getvalue())
        expected_output = self._clean_paths(expected_output)
>       assert expected_output.strip() in actual_output.strip()
E       AssertionError: assert 'No module named --load-plugin' in 'Option --load-plugin expects a value'
E        +  where 'No module named --load-plugin' = <built-in method strip of str object at 0x7f244bdec440>()
E        +    where <built-in method strip of str object at 0x7f244bdec440> = 'No module named --load-plugin'.strip
E        +  and   'Option --load-plugin expects a value' = <built-in method strip of str object at 0x7f244b33da70>()
E        +    where <built-in method strip of str object at 0x7f244b33da70> = 'Option --load-plugin expects a value\n'.strip

tests/test_self.py:158: AssertionError
</pre>
</details>
<h3 id="test_selfpytestruntctest_do_not_import_files_from_local_directoryargs0">test_self.py::TestRunTC::test_do_not_import_files_from_local_directory[args0]</h3>
<details><summary> <pre>test_self.py::TestRunTC::test_do_not_import_files_from_local_directory[args0]</pre></summary><pre>
self = <test_self.TestRunTC object at 0x7f244bd3e3e0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_do_not_import_files_from_0')
args = ['--disable=import-error,unused-import']

    @pytest.mark.parametrize(
        "args",
        [
            ["--disable=import-error,unused-import"],
            # Test with multiple jobs for 'hmac.py' for which we have a
            # CVE against: https://github.com/pylint-dev/pylint/issues/959
            ["-j2", "--disable=import-error,unused-import"],
        ],
    )
    def test_do_not_import_files_from_local_directory(
        self, tmp_path: Path, args: list[str]
    ) -> None:
        for path in ("astroid.py", "hmac.py"):
            file_path = tmp_path / path
            file_path.write_text("'Docstring'\nimport completely_unknown\n")
            pylint_call = [sys.executable, "-m", "pylint", *args, path]
            with _test_cwd(tmp_path):
                subprocess.check_output(pylint_call, cwd=str(tmp_path))
            new_python_path = os.environ.get("PYTHONPATH", "").strip(":")
            with _test_cwd(tmp_path), _test_environ_pythonpath(f"{new_python_path}:"):
                # Appending a colon to PYTHONPATH should not break path stripping
                # https://github.com/pylint-dev/pylint/issues/3636
>               subprocess.check_output(pylint_call, cwd=str(tmp_path))

tests/test_self.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/subprocess.py:421: in check_output
    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (['/testbed/.venv/bin/python3', '-m', 'pylint', '--disable=import-error,unused-import', 'astroid.py'],)
kwargs = {'cwd': '/tmp/pytest-of-root/pytest-0/test_do_not_import_files_from_0', 'stdout': -1}
process = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', '-m', 'pylint', '...>
stdout = b'', stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.

        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.

        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.

        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.

        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.

        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.

        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE

        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE

        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/testbed/.venv/bin/python3', '-m', 'pylint', '--disable=import-error,unused-import', 'astroid.py']' returned non-zero exit status 1.

/usr/lib/python3.10/subprocess.py:526: CalledProcessError
</pre>
</details>
<h3 id="test_selfpytestruntctest_do_not_import_files_from_local_directoryargs1">test_self.py::TestRunTC::test_do_not_import_files_from_local_directory[args1]</h3>
<details><summary> <pre>test_self.py::TestRunTC::test_do_not_import_files_from_local_directory[args1]</pre></summary><pre>
self = <test_self.TestRunTC object at 0x7f244bd3e500>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_do_not_import_files_from_1')
args = ['-j2', '--disable=import-error,unused-import']

    @pytest.mark.parametrize(
        "args",
        [
            ["--disable=import-error,unused-import"],
            # Test with multiple jobs for 'hmac.py' for which we have a
            # CVE against: https://github.com/pylint-dev/pylint/issues/959
            ["-j2", "--disable=import-error,unused-import"],
        ],
    )
    def test_do_not_import_files_from_local_directory(
        self, tmp_path: Path, args: list[str]
    ) -> None:
        for path in ("astroid.py", "hmac.py"):
            file_path = tmp_path / path
            file_path.write_text("'Docstring'\nimport completely_unknown\n")
            pylint_call = [sys.executable, "-m", "pylint", *args, path]
            with _test_cwd(tmp_path):
                subprocess.check_output(pylint_call, cwd=str(tmp_path))
            new_python_path = os.environ.get("PYTHONPATH", "").strip(":")
            with _test_cwd(tmp_path), _test_environ_pythonpath(f"{new_python_path}:"):
                # Appending a colon to PYTHONPATH should not break path stripping
                # https://github.com/pylint-dev/pylint/issues/3636
>               subprocess.check_output(pylint_call, cwd=str(tmp_path))

tests/test_self.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/subprocess.py:421: in check_output
    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (['/testbed/.venv/bin/python3', '-m', 'pylint', '-j2', '--disable=import-error,unused-import', 'astroid.py'],)
kwargs = {'cwd': '/tmp/pytest-of-root/pytest-0/test_do_not_import_files_from_1', 'stdout': -1}
process = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', '-m', 'pylint', '...>
stdout = b'', stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.

        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.

        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.

        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.

        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.

        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.

        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE

        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE

        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/testbed/.venv/bin/python3', '-m', 'pylint', '-j2', '--disable=import-error,unused-import', 'astroid.py']' returned non-zero exit status 1.

/usr/lib/python3.10/subprocess.py:526: CalledProcessError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/pylint/__pkginfo__.py b/pylint/__pkginfo__.py</span>
<span class="gh">index 74986243c..729826c7e 100644</span>
<span class="gd">--- a/pylint/__pkginfo__.py</span>
<span class="gi">+++ b/pylint/__pkginfo__.py</span>
<span class="gu">@@ -1,18 +1,43 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;This module exists for compatibility reasons.

<span class="w"> </span>It&#39;s updated via tbump, do not modify.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gd">-__version__ = &#39;3.2.6&#39;</span>

<span class="gi">+__version__ = &quot;3.2.6&quot;</span>

<span class="gd">-def get_numversion_from_version(v: str) -&gt;tuple[int, int, int]:</span>
<span class="gi">+</span>
<span class="gi">+def get_numversion_from_version(v: str) -&gt; tuple[int, int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Kept for compatibility reason.

<span class="w"> </span>    See https://github.com/pylint-dev/pylint/issues/4399
<span class="w"> </span>    https://github.com/pylint-dev/pylint/issues/4420,
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    version = v.replace(&quot;pylint-&quot;, &quot;&quot;)</span>
<span class="gi">+    result_version = []</span>
<span class="gi">+    for number in version.split(&quot;.&quot;)[0:3]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            result_version.append(int(number))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            current_number = &quot;&quot;</span>
<span class="gi">+            for char in number:</span>
<span class="gi">+                if char.isdigit():</span>
<span class="gi">+                    current_number += char</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+            try:</span>
<span class="gi">+                result_version.append(int(current_number))</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                result_version.append(0)</span>
<span class="gi">+    while len(result_version) != 3:</span>
<span class="gi">+        result_version.append(0)</span>
<span class="gi">+</span>
<span class="gi">+    return tuple(result_version)  # type: ignore[return-value] # mypy can&#39;t infer the length</span>


<span class="w"> </span>numversion = get_numversion_from_version(__version__)
<span class="gh">diff --git a/pylint/checkers/async.py b/pylint/checkers/async.py</span>
<span class="gh">index 03df31611..a8ee77302 100644</span>
<span class="gd">--- a/pylint/checkers/async.py</span>
<span class="gi">+++ b/pylint/checkers/async.py</span>
<span class="gu">@@ -1,23 +1,96 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checker for anything related to the async protocol (PEP 492).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes, util
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils as checker_utils
<span class="w"> </span>from pylint.checkers.utils import decorated_with
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class AsyncChecker(checkers.BaseChecker):
<span class="gd">-    name = &#39;async&#39;</span>
<span class="gd">-    msgs = {&#39;E1700&#39;: (&#39;Yield inside async function&#39;,</span>
<span class="gd">-        &#39;yield-inside-async-function&#39;,</span>
<span class="gd">-        &#39;Used when an `yield` or `yield from` statement is found inside an async function.&#39;</span>
<span class="gd">-        , {&#39;minversion&#39;: (3, 5)}), &#39;E1701&#39;: (</span>
<span class="gd">-        &quot;Async context manager &#39;%s&#39; doesn&#39;t implement __aenter__ and __aexit__.&quot;</span>
<span class="gd">-        , &#39;not-async-context-manager&#39;,</span>
<span class="gd">-        &#39;Used when an async context manager is used with an object that does not implement the async context management protocol.&#39;</span>
<span class="gd">-        , {&#39;minversion&#39;: (3, 5)})}</span>
<span class="gi">+    name = &quot;async&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;E1700&quot;: (</span>
<span class="gi">+            &quot;Yield inside async function&quot;,</span>
<span class="gi">+            &quot;yield-inside-async-function&quot;,</span>
<span class="gi">+            &quot;Used when an `yield` or `yield from` statement is &quot;</span>
<span class="gi">+            &quot;found inside an async function.&quot;,</span>
<span class="gi">+            {&quot;minversion&quot;: (3, 5)},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1701&quot;: (</span>
<span class="gi">+            &quot;Async context manager &#39;%s&#39; doesn&#39;t implement __aenter__ and __aexit__.&quot;,</span>
<span class="gi">+            &quot;not-async-context-manager&quot;,</span>
<span class="gi">+            &quot;Used when an async context manager is used with an object &quot;</span>
<span class="gi">+            &quot;that does not implement the async context management protocol.&quot;,</span>
<span class="gi">+            {&quot;minversion&quot;: (3, 5)},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        self._mixin_class_rgx = self.linter.config.mixin_class_rgx</span>
<span class="gi">+        self._async_generators = [&quot;contextlib.asynccontextmanager&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    @checker_utils.only_required_for_messages(&quot;yield-inside-async-function&quot;)</span>
<span class="gi">+    def visit_asyncfunctiondef(self, node: nodes.AsyncFunctionDef) -&gt; None:</span>
<span class="gi">+        for child in node.nodes_of_class(nodes.Yield):</span>
<span class="gi">+            if child.scope() is node and (</span>
<span class="gi">+                sys.version_info[:2] == (3, 5) or isinstance(child, nodes.YieldFrom)</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;yield-inside-async-function&quot;, node=child)</span>
<span class="gi">+</span>
<span class="gi">+    @checker_utils.only_required_for_messages(&quot;not-async-context-manager&quot;)</span>
<span class="gi">+    def visit_asyncwith(self, node: nodes.AsyncWith) -&gt; None:</span>
<span class="gi">+        for ctx_mgr, _ in node.items:</span>
<span class="gi">+            inferred = checker_utils.safe_infer(ctx_mgr)</span>
<span class="gi">+            if inferred is None or isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(inferred, nodes.AsyncFunctionDef):</span>
<span class="gi">+                # Check if we are dealing with a function decorated</span>
<span class="gi">+                # with contextlib.asynccontextmanager.</span>
<span class="gi">+                if decorated_with(inferred, self._async_generators):</span>
<span class="gi">+                    continue</span>
<span class="gi">+            elif isinstance(inferred, astroid.bases.AsyncGenerator):</span>
<span class="gi">+                # Check if we are dealing with a function decorated</span>
<span class="gi">+                # with contextlib.asynccontextmanager.</span>
<span class="gi">+                if decorated_with(inferred.parent, self._async_generators):</span>
<span class="gi">+                    continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    inferred.getattr(&quot;__aenter__&quot;)</span>
<span class="gi">+                    inferred.getattr(&quot;__aexit__&quot;)</span>
<span class="gi">+                except astroid.exceptions.NotFoundError:</span>
<span class="gi">+                    if isinstance(inferred, astroid.Instance):</span>
<span class="gi">+                        # If we do not know the bases of this class,</span>
<span class="gi">+                        # just skip it.</span>
<span class="gi">+                        if not checker_utils.has_known_bases(inferred):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        # Ignore mixin classes if they match the rgx option.</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            &quot;not-async-context-manager&quot;</span>
<span class="gi">+                            in self.linter.config.ignored_checks_for_mixins</span>
<span class="gi">+                            and self._mixin_class_rgx.match(inferred.name)</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                else:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;not-async-context-manager&quot;, node=node, args=(inferred.name,)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(AsyncChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/bad_chained_comparison.py b/pylint/checkers/bad_chained_comparison.py</span>
<span class="gh">index 09763c88d..2e1912160 100644</span>
<span class="gd">--- a/pylint/checkers/bad_chained_comparison.py</span>
<span class="gi">+++ b/pylint/checkers/bad_chained_comparison.py</span>
<span class="gu">@@ -1,20 +1,60 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-COMPARISON_OP = frozenset((&#39;&lt;&#39;, &#39;&lt;=&#39;, &#39;&gt;&#39;, &#39;&gt;=&#39;, &#39;!=&#39;, &#39;==&#39;))</span>
<span class="gd">-IDENTITY_OP = frozenset((&#39;is&#39;, &#39;is not&#39;))</span>
<span class="gd">-MEMBERSHIP_OP = frozenset((&#39;in&#39;, &#39;not in&#39;))</span>
<span class="gi">+</span>
<span class="gi">+COMPARISON_OP = frozenset((&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;!=&quot;, &quot;==&quot;))</span>
<span class="gi">+IDENTITY_OP = frozenset((&quot;is&quot;, &quot;is not&quot;))</span>
<span class="gi">+MEMBERSHIP_OP = frozenset((&quot;in&quot;, &quot;not in&quot;))</span>


<span class="w"> </span>class BadChainedComparisonChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks for unintentional usage of chained comparison.&quot;&quot;&quot;
<span class="gd">-    name = &#39;bad-chained-comparison&#39;</span>
<span class="gd">-    msgs = {&#39;W3601&#39;: (</span>
<span class="gd">-        &#39;Suspicious %s-part chained comparison using semantically incompatible operators (%s)&#39;</span>
<span class="gd">-        , &#39;bad-chained-comparison&#39;,</span>
<span class="gd">-        &#39;Used when there is a chained comparison where one expression is part of two comparisons that belong to different semantic groups (&quot;&lt;&quot; does not mean the same thing as &quot;is&quot;, chaining them in &quot;0 &lt; x is None&quot; is probably a mistake).&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;bad-chained-comparison&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W3601&quot;: (</span>
<span class="gi">+            &quot;Suspicious %s-part chained comparison using semantically incompatible operators (%s)&quot;,</span>
<span class="gi">+            &quot;bad-chained-comparison&quot;,</span>
<span class="gi">+            &quot;Used when there is a chained comparison where one expression is part &quot;</span>
<span class="gi">+            &quot;of two comparisons that belong to different semantic groups &quot;</span>
<span class="gi">+            &#39;(&quot;&lt;&quot; does not mean the same thing as &quot;is&quot;, chaining them in &#39;</span>
<span class="gi">+            &#39;&quot;0 &lt; x is None&quot; is probably a mistake).&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def _has_diff_semantic_groups(self, operators: list[str]) -&gt; bool:</span>
<span class="gi">+        # Check if comparison operators are in the same semantic group</span>
<span class="gi">+        for semantic_group in (COMPARISON_OP, IDENTITY_OP, MEMBERSHIP_OP):</span>
<span class="gi">+            if operators[0] in semantic_group:</span>
<span class="gi">+                group = semantic_group</span>
<span class="gi">+        return not all(o in group for o in operators)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_compare(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        operators = sorted({op[0] for op in node.ops})</span>
<span class="gi">+        if self._has_diff_semantic_groups(operators):</span>
<span class="gi">+            num_parts = f&quot;{len(node.ops)}&quot;</span>
<span class="gi">+            incompatibles = (</span>
<span class="gi">+                &quot;, &quot;.join(f&quot;&#39;{o}&#39;&quot; for o in operators[:-1]) + f&quot; and &#39;{operators[-1]}&#39;&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;bad-chained-comparison&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(num_parts, incompatibles),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(BadChainedComparisonChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/base/basic_checker.py b/pylint/checkers/base/basic_checker.py</span>
<span class="gh">index 2c39eeb46..bd3190528 100644</span>
<span class="gd">--- a/pylint/checkers/base/basic_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/basic_checker.py</span>
<span class="gu">@@ -1,16 +1,25 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Basic checker for Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import itertools
<span class="w"> </span>from collections.abc import Iterator
<span class="w"> </span>from typing import TYPE_CHECKING, Literal, cast
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes, objects, util
<span class="gi">+</span>
<span class="w"> </span>from pylint import utils as lint_utils
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="w"> </span>from pylint.interfaces import HIGH, INFERENCE, Confidence
<span class="w"> </span>from pylint.reporters.ureports import nodes as reporter_nodes
<span class="w"> </span>from pylint.utils import LinterStats
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter

<span class="gu">@@ -19,29 +28,77 @@ class _BasicChecker(BaseChecker):</span>
<span class="w"> </span>    &quot;&quot;&quot;Permits separating multiple checks with the same checker name into
<span class="w"> </span>    classes/file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;basic&#39;</span>
<span class="gd">-</span>

<span class="gd">-REVERSED_PROTOCOL_METHOD = &#39;__reversed__&#39;</span>
<span class="gd">-SEQUENCE_PROTOCOL_METHODS = &#39;__getitem__&#39;, &#39;__len__&#39;</span>
<span class="gd">-REVERSED_METHODS = SEQUENCE_PROTOCOL_METHODS, (REVERSED_PROTOCOL_METHOD,)</span>
<span class="gd">-DEFAULT_ARGUMENT_SYMBOLS = dict(zip([&#39;.&#39;.join([&#39;builtins&#39;, x]) for x in (</span>
<span class="gd">-    &#39;set&#39;, &#39;dict&#39;, &#39;list&#39;)], [&#39;set()&#39;, &#39;{}&#39;, &#39;[]&#39;]), **{x: f&#39;{x}()&#39; for x in</span>
<span class="gd">-    (&#39;collections.deque&#39;, &#39;collections.ChainMap&#39;, &#39;collections.Counter&#39;,</span>
<span class="gd">-    &#39;collections.OrderedDict&#39;, &#39;collections.defaultdict&#39;,</span>
<span class="gd">-    &#39;collections.UserDict&#39;, &#39;collections.UserList&#39;)})</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def report_by_type_stats(sect: reporter_nodes.Section, stats: LinterStats,</span>
<span class="gd">-    old_stats: (LinterStats | None)) -&gt;None:</span>
<span class="gi">+    name = &quot;basic&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+REVERSED_PROTOCOL_METHOD = &quot;__reversed__&quot;</span>
<span class="gi">+SEQUENCE_PROTOCOL_METHODS = (&quot;__getitem__&quot;, &quot;__len__&quot;)</span>
<span class="gi">+REVERSED_METHODS = (SEQUENCE_PROTOCOL_METHODS, (REVERSED_PROTOCOL_METHOD,))</span>
<span class="gi">+# A mapping from qname -&gt; symbol, to be used when generating messages</span>
<span class="gi">+# about dangerous default values as arguments</span>
<span class="gi">+DEFAULT_ARGUMENT_SYMBOLS = dict(</span>
<span class="gi">+    zip(</span>
<span class="gi">+        [&quot;.&quot;.join([&quot;builtins&quot;, x]) for x in (&quot;set&quot;, &quot;dict&quot;, &quot;list&quot;)],</span>
<span class="gi">+        [&quot;set()&quot;, &quot;{}&quot;, &quot;[]&quot;],</span>
<span class="gi">+    ),</span>
<span class="gi">+    **{</span>
<span class="gi">+        x: f&quot;{x}()&quot;</span>
<span class="gi">+        for x in (</span>
<span class="gi">+            &quot;collections.deque&quot;,</span>
<span class="gi">+            &quot;collections.ChainMap&quot;,</span>
<span class="gi">+            &quot;collections.Counter&quot;,</span>
<span class="gi">+            &quot;collections.OrderedDict&quot;,</span>
<span class="gi">+            &quot;collections.defaultdict&quot;,</span>
<span class="gi">+            &quot;collections.UserDict&quot;,</span>
<span class="gi">+            &quot;collections.UserList&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    },</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def report_by_type_stats(</span>
<span class="gi">+    sect: reporter_nodes.Section,</span>
<span class="gi">+    stats: LinterStats,</span>
<span class="gi">+    old_stats: LinterStats | None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a report of.

<span class="w"> </span>    * percentage of different types documented
<span class="w"> </span>    * percentage of different types with a bad name
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    # percentage of different types documented and/or with a bad name</span>
<span class="gi">+    nice_stats: dict[str, dict[str, str]] = {}</span>
<span class="gi">+    for node_type in (&quot;module&quot;, &quot;class&quot;, &quot;method&quot;, &quot;function&quot;):</span>
<span class="gi">+        node_type = cast(Literal[&quot;function&quot;, &quot;class&quot;, &quot;method&quot;, &quot;module&quot;], node_type)</span>
<span class="gi">+        total = stats.get_node_count(node_type)</span>
<span class="gi">+        nice_stats[node_type] = {}</span>
<span class="gi">+        if total != 0:</span>
<span class="gi">+            undocumented_node = stats.get_undocumented(node_type)</span>
<span class="gi">+            documented = total - undocumented_node</span>
<span class="gi">+            percent = (documented * 100.0) / total</span>
<span class="gi">+            nice_stats[node_type][&quot;percent_documented&quot;] = f&quot;{percent:.2f}&quot;</span>
<span class="gi">+            badname_node = stats.get_bad_names(node_type)</span>
<span class="gi">+            percent = (badname_node * 100.0) / total</span>
<span class="gi">+            nice_stats[node_type][&quot;percent_badname&quot;] = f&quot;{percent:.2f}&quot;</span>
<span class="gi">+    lines = [&quot;type&quot;, &quot;number&quot;, &quot;old number&quot;, &quot;difference&quot;, &quot;%documented&quot;, &quot;%badname&quot;]</span>
<span class="gi">+    for node_type in (&quot;module&quot;, &quot;class&quot;, &quot;method&quot;, &quot;function&quot;):</span>
<span class="gi">+        node_type = cast(Literal[&quot;function&quot;, &quot;class&quot;, &quot;method&quot;, &quot;module&quot;], node_type)</span>
<span class="gi">+        new = stats.get_node_count(node_type)</span>
<span class="gi">+        old = old_stats.get_node_count(node_type) if old_stats else None</span>
<span class="gi">+        diff_str = lint_utils.diff_string(old, new) if old else None</span>
<span class="gi">+        lines += [</span>
<span class="gi">+            node_type,</span>
<span class="gi">+            str(new),</span>
<span class="gi">+            str(old) if old else &quot;NC&quot;,</span>
<span class="gi">+            diff_str if diff_str else &quot;NC&quot;,</span>
<span class="gi">+            nice_stats[node_type].get(&quot;percent_documented&quot;, &quot;0&quot;),</span>
<span class="gi">+            nice_stats[node_type].get(&quot;percent_badname&quot;, &quot;0&quot;),</span>
<span class="gi">+        ]</span>
<span class="gi">+    sect.append(reporter_nodes.Table(children=lines, cols=6, rheaders=1))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable-next = too-many-public-methods</span>
<span class="w"> </span>class BasicChecker(_BasicChecker):
<span class="w"> </span>    &quot;&quot;&quot;Basic checker.

<span class="gu">@@ -54,129 +111,531 @@ class BasicChecker(_BasicChecker):</span>
<span class="w"> </span>    * redefinition of function / method / class
<span class="w"> </span>    * uses of the global statement
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;basic&#39;</span>
<span class="gd">-    msgs = {&#39;W0101&#39;: (&#39;Unreachable code&#39;, &#39;unreachable&#39;,</span>
<span class="gd">-        &#39;Used when there is some code behind a &quot;return&quot; or &quot;raise&quot; statement, which will never be accessed.&#39;</span>
<span class="gd">-        ), &#39;W0102&#39;: (&#39;Dangerous default value %s as argument&#39;,</span>
<span class="gd">-        &#39;dangerous-default-value&#39;,</span>
<span class="gd">-        &#39;Used when a mutable value as list or dictionary is detected in a default value for an argument.&#39;</span>
<span class="gd">-        ), &#39;W0104&#39;: (&#39;Statement seems to have no effect&#39;,</span>
<span class="gd">-        &#39;pointless-statement&#39;,</span>
<span class="gd">-        &quot;Used when a statement doesn&#39;t have (or at least seems to) any effect.&quot;</span>
<span class="gd">-        ), &#39;W0105&#39;: (&#39;String statement has no effect&#39;,</span>
<span class="gd">-        &#39;pointless-string-statement&#39;,</span>
<span class="gd">-        &quot;Used when a string is used as a statement (which of course has no effect). This is a particular case of W0104 with its own message so you can easily disable it if you&#39;re using those strings as documentation, instead of comments.&quot;</span>
<span class="gd">-        ), &#39;W0106&#39;: (&#39;Expression &quot;%s&quot; is assigned to nothing&#39;,</span>
<span class="gd">-        &#39;expression-not-assigned&#39;,</span>
<span class="gd">-        &#39;Used when an expression that is not a function call is assigned to nothing. Probably something else was intended.&#39;</span>
<span class="gd">-        ), &#39;W0108&#39;: (&#39;Lambda may not be necessary&#39;, &#39;unnecessary-lambda&#39;,</span>
<span class="gd">-        &#39;Used when the body of a lambda expression is a function call on the same argument list as the lambda itself; such lambda expressions are in all but a few cases replaceable with the function being called in the body of the lambda.&#39;</span>
<span class="gd">-        ), &#39;W0109&#39;: (&#39;Duplicate key %r in dictionary&#39;, &#39;duplicate-key&#39;,</span>
<span class="gd">-        &#39;Used when a dictionary expression binds the same key multiple times.&#39;</span>
<span class="gd">-        ), &#39;W0122&#39;: (&#39;Use of exec&#39;, &#39;exec-used&#39;,</span>
<span class="gd">-        &quot;Raised when the &#39;exec&#39; statement is used. It&#39;s dangerous to use this function for a user input, and it&#39;s also slower than actual code in general. This doesn&#39;t mean you should never use it, but you should consider alternatives first and restrict the functions available.&quot;</span>
<span class="gd">-        ), &#39;W0123&#39;: (&#39;Use of eval&#39;, &#39;eval-used&#39;,</span>
<span class="gd">-        &#39;Used when you use the &quot;eval&quot; function, to discourage its usage. Consider using `ast.literal_eval` for safely evaluating strings containing Python expressions from untrusted sources.&#39;</span>
<span class="gd">-        ), &#39;W0150&#39;: (&#39;%s statement in finally block may swallow exception&#39;,</span>
<span class="gd">-        &#39;lost-exception&#39;,</span>
<span class="gd">-        &#39;Used when a break or a return statement is found inside the finally clause of a try...finally block: the exceptions raised in the try clause will be silently swallowed instead of being re-raised.&#39;</span>
<span class="gd">-        ), &#39;W0199&#39;: (</span>
<span class="gd">-        &quot;Assert called on a populated tuple. Did you mean &#39;assert x,y&#39;?&quot;,</span>
<span class="gd">-        &#39;assert-on-tuple&#39;,</span>
<span class="gd">-        &#39;A call of assert on a tuple will always evaluate to true if the tuple is not empty, and will always evaluate to false if it is.&#39;</span>
<span class="gd">-        ), &#39;W0124&#39;: (</span>
<span class="gd">-        &#39;Following &quot;as&quot; with another context manager looks like a tuple.&#39;,</span>
<span class="gd">-        &#39;confusing-with-statement&#39;,</span>
<span class="gd">-        &quot;Emitted when a `with` statement component returns multiple values and uses name binding with `as` only for a part of those values, as in with ctx() as a, b. This can be misleading, since it&#39;s not clear if the context manager returns a tuple or if the node without a name binding is another context manager.&quot;</span>
<span class="gd">-        ), &#39;W0125&#39;: (&#39;Using a conditional statement with a constant value&#39;,</span>
<span class="gd">-        &#39;using-constant-test&#39;,</span>
<span class="gd">-        &#39;Emitted when a conditional statement (If or ternary if) uses a constant value for its test. This might not be what the user intended to do.&#39;</span>
<span class="gd">-        ), &#39;W0126&#39;: (</span>
<span class="gd">-        &#39;Using a conditional statement with potentially wrong function or method call due to missing parentheses&#39;</span>
<span class="gd">-        , &#39;missing-parentheses-for-call-in-test&#39;,</span>
<span class="gd">-        &#39;Emitted when a conditional statement (If or ternary if) seems to wrongly call a function due to missing parentheses&#39;</span>
<span class="gd">-        ), &#39;W0127&#39;: (&#39;Assigning the same variable %r to itself&#39;,</span>
<span class="gd">-        &#39;self-assigning-variable&#39;,</span>
<span class="gd">-        &#39;Emitted when we detect that a variable is assigned to itself&#39;),</span>
<span class="gd">-        &#39;W0128&#39;: (&#39;Redeclared variable %r in assignment&#39;,</span>
<span class="gd">-        &#39;redeclared-assigned-name&#39;,</span>
<span class="gd">-        &#39;Emitted when we detect that a variable was redeclared in the same assignment.&#39;</span>
<span class="gd">-        ), &#39;E0111&#39;: (&#39;The first reversed() argument is not a sequence&#39;,</span>
<span class="gd">-        &#39;bad-reversed-sequence&#39;,</span>
<span class="gd">-        &quot;Used when the first argument to reversed() builtin isn&#39;t a sequence (does not implement __reversed__, nor __getitem__ and __len__&quot;</span>
<span class="gd">-        ), &#39;E0119&#39;: (&#39;format function is not called on str&#39;,</span>
<span class="gd">-        &#39;misplaced-format-function&#39;,</span>
<span class="gd">-        &#39;Emitted when format function is not called on str object. e.g doing print(&quot;value: {}&quot;).format(123) instead of print(&quot;value: {}&quot;.format(123)). This might not be what the user intended to do.&#39;</span>
<span class="gd">-        ), &#39;W0129&#39;: (</span>
<span class="gd">-        &#39;Assert statement has a string literal as its first argument. The assert will %s fail.&#39;</span>
<span class="gd">-        , &#39;assert-on-string-literal&#39;,</span>
<span class="gd">-        &#39;Used when an assert statement has a string literal as its first argument, which will cause the assert to always pass.&#39;</span>
<span class="gd">-        ), &#39;W0130&#39;: (&#39;Duplicate value %r in set&#39;, &#39;duplicate-value&#39;,</span>
<span class="gd">-        &#39;This message is emitted when a set contains the same value two or more times.&#39;</span>
<span class="gd">-        ), &#39;W0131&#39;: (&#39;Named expression used without context&#39;,</span>
<span class="gd">-        &#39;named-expr-without-context&#39;,</span>
<span class="gd">-        &#39;Emitted if named expression is used to do a regular assignment outside a context like if, for, while, or a comprehension.&#39;</span>
<span class="gd">-        ), &#39;W0133&#39;: (&#39;Exception statement has no effect&#39;,</span>
<span class="gd">-        &#39;pointless-exception-statement&#39;,</span>
<span class="gd">-        &#39;Used when an exception is created without being assigned, raised or returned for subsequent use elsewhere.&#39;</span>
<span class="gd">-        ), &#39;W0134&#39;: (&quot;&#39;return&#39; shadowed by the &#39;finally&#39; clause.&quot;,</span>
<span class="gd">-        &#39;return-in-finally&#39;,</span>
<span class="gd">-        &quot;Emitted when a &#39;return&#39; statement is found in a &#39;finally&#39; block. This will overwrite the return value of a function and should be avoided.&quot;</span>
<span class="gd">-        )}</span>
<span class="gd">-    reports = (&#39;RP0101&#39;, &#39;Statistics by type&#39;, report_by_type_stats),</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;basic&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W0101&quot;: (</span>
<span class="gi">+            &quot;Unreachable code&quot;,</span>
<span class="gi">+            &quot;unreachable&quot;,</span>
<span class="gi">+            &#39;Used when there is some code behind a &quot;return&quot; or &quot;raise&quot; &#39;</span>
<span class="gi">+            &quot;statement, which will never be accessed.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0102&quot;: (</span>
<span class="gi">+            &quot;Dangerous default value %s as argument&quot;,</span>
<span class="gi">+            &quot;dangerous-default-value&quot;,</span>
<span class="gi">+            &quot;Used when a mutable value as list or dictionary is detected in &quot;</span>
<span class="gi">+            &quot;a default value for an argument.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0104&quot;: (</span>
<span class="gi">+            &quot;Statement seems to have no effect&quot;,</span>
<span class="gi">+            &quot;pointless-statement&quot;,</span>
<span class="gi">+            &quot;Used when a statement doesn&#39;t have (or at least seems to) any effect.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0105&quot;: (</span>
<span class="gi">+            &quot;String statement has no effect&quot;,</span>
<span class="gi">+            &quot;pointless-string-statement&quot;,</span>
<span class="gi">+            &quot;Used when a string is used as a statement (which of course &quot;</span>
<span class="gi">+            &quot;has no effect). This is a particular case of W0104 with its &quot;</span>
<span class="gi">+            &quot;own message so you can easily disable it if you&#39;re using &quot;</span>
<span class="gi">+            &quot;those strings as documentation, instead of comments.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0106&quot;: (</span>
<span class="gi">+            &#39;Expression &quot;%s&quot; is assigned to nothing&#39;,</span>
<span class="gi">+            &quot;expression-not-assigned&quot;,</span>
<span class="gi">+            &quot;Used when an expression that is not a function call is assigned &quot;</span>
<span class="gi">+            &quot;to nothing. Probably something else was intended.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0108&quot;: (</span>
<span class="gi">+            &quot;Lambda may not be necessary&quot;,</span>
<span class="gi">+            &quot;unnecessary-lambda&quot;,</span>
<span class="gi">+            &quot;Used when the body of a lambda expression is a function call &quot;</span>
<span class="gi">+            &quot;on the same argument list as the lambda itself; such lambda &quot;</span>
<span class="gi">+            &quot;expressions are in all but a few cases replaceable with the &quot;</span>
<span class="gi">+            &quot;function being called in the body of the lambda.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0109&quot;: (</span>
<span class="gi">+            &quot;Duplicate key %r in dictionary&quot;,</span>
<span class="gi">+            &quot;duplicate-key&quot;,</span>
<span class="gi">+            &quot;Used when a dictionary expression binds the same key multiple times.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0122&quot;: (</span>
<span class="gi">+            &quot;Use of exec&quot;,</span>
<span class="gi">+            &quot;exec-used&quot;,</span>
<span class="gi">+            &quot;Raised when the &#39;exec&#39; statement is used. It&#39;s dangerous to use this &quot;</span>
<span class="gi">+            &quot;function for a user input, and it&#39;s also slower than actual code in &quot;</span>
<span class="gi">+            &quot;general. This doesn&#39;t mean you should never use it, but you should &quot;</span>
<span class="gi">+            &quot;consider alternatives first and restrict the functions available.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0123&quot;: (</span>
<span class="gi">+            &quot;Use of eval&quot;,</span>
<span class="gi">+            &quot;eval-used&quot;,</span>
<span class="gi">+            &#39;Used when you use the &quot;eval&quot; function, to discourage its &#39;</span>
<span class="gi">+            &quot;usage. Consider using `ast.literal_eval` for safely evaluating &quot;</span>
<span class="gi">+            &quot;strings containing Python expressions &quot;</span>
<span class="gi">+            &quot;from untrusted sources.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0150&quot;: (</span>
<span class="gi">+            &quot;%s statement in finally block may swallow exception&quot;,</span>
<span class="gi">+            &quot;lost-exception&quot;,</span>
<span class="gi">+            &quot;Used when a break or a return statement is found inside the &quot;</span>
<span class="gi">+            &quot;finally clause of a try...finally block: the exceptions raised &quot;</span>
<span class="gi">+            &quot;in the try clause will be silently swallowed instead of being &quot;</span>
<span class="gi">+            &quot;re-raised.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0199&quot;: (</span>
<span class="gi">+            &quot;Assert called on a populated tuple. Did you mean &#39;assert x,y&#39;?&quot;,</span>
<span class="gi">+            &quot;assert-on-tuple&quot;,</span>
<span class="gi">+            &quot;A call of assert on a tuple will always evaluate to true if &quot;</span>
<span class="gi">+            &quot;the tuple is not empty, and will always evaluate to false if &quot;</span>
<span class="gi">+            &quot;it is.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0124&quot;: (</span>
<span class="gi">+            &#39;Following &quot;as&quot; with another context manager looks like a tuple.&#39;,</span>
<span class="gi">+            &quot;confusing-with-statement&quot;,</span>
<span class="gi">+            &quot;Emitted when a `with` statement component returns multiple values &quot;</span>
<span class="gi">+            &quot;and uses name binding with `as` only for a part of those values, &quot;</span>
<span class="gi">+            &quot;as in with ctx() as a, b. This can be misleading, since it&#39;s not &quot;</span>
<span class="gi">+            &quot;clear if the context manager returns a tuple or if the node without &quot;</span>
<span class="gi">+            &quot;a name binding is another context manager.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0125&quot;: (</span>
<span class="gi">+            &quot;Using a conditional statement with a constant value&quot;,</span>
<span class="gi">+            &quot;using-constant-test&quot;,</span>
<span class="gi">+            &quot;Emitted when a conditional statement (If or ternary if) &quot;</span>
<span class="gi">+            &quot;uses a constant value for its test. This might not be what &quot;</span>
<span class="gi">+            &quot;the user intended to do.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0126&quot;: (</span>
<span class="gi">+            &quot;Using a conditional statement with potentially wrong function or method call due to &quot;</span>
<span class="gi">+            &quot;missing parentheses&quot;,</span>
<span class="gi">+            &quot;missing-parentheses-for-call-in-test&quot;,</span>
<span class="gi">+            &quot;Emitted when a conditional statement (If or ternary if) &quot;</span>
<span class="gi">+            &quot;seems to wrongly call a function due to missing parentheses&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0127&quot;: (</span>
<span class="gi">+            &quot;Assigning the same variable %r to itself&quot;,</span>
<span class="gi">+            &quot;self-assigning-variable&quot;,</span>
<span class="gi">+            &quot;Emitted when we detect that a variable is assigned to itself&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0128&quot;: (</span>
<span class="gi">+            &quot;Redeclared variable %r in assignment&quot;,</span>
<span class="gi">+            &quot;redeclared-assigned-name&quot;,</span>
<span class="gi">+            &quot;Emitted when we detect that a variable was redeclared in the same assignment.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0111&quot;: (</span>
<span class="gi">+            &quot;The first reversed() argument is not a sequence&quot;,</span>
<span class="gi">+            &quot;bad-reversed-sequence&quot;,</span>
<span class="gi">+            &quot;Used when the first argument to reversed() builtin &quot;</span>
<span class="gi">+            &quot;isn&#39;t a sequence (does not implement __reversed__, &quot;</span>
<span class="gi">+            &quot;nor __getitem__ and __len__&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0119&quot;: (</span>
<span class="gi">+            &quot;format function is not called on str&quot;,</span>
<span class="gi">+            &quot;misplaced-format-function&quot;,</span>
<span class="gi">+            &quot;Emitted when format function is not called on str object. &quot;</span>
<span class="gi">+            &#39;e.g doing print(&quot;value: {}&quot;).format(123) instead of &#39;</span>
<span class="gi">+            &#39;print(&quot;value: {}&quot;.format(123)). This might not be what the user &#39;</span>
<span class="gi">+            &quot;intended to do.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0129&quot;: (</span>
<span class="gi">+            &quot;Assert statement has a string literal as its first argument. The assert will %s fail.&quot;,</span>
<span class="gi">+            &quot;assert-on-string-literal&quot;,</span>
<span class="gi">+            &quot;Used when an assert statement has a string literal as its first argument, which will &quot;</span>
<span class="gi">+            &quot;cause the assert to always pass.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0130&quot;: (</span>
<span class="gi">+            &quot;Duplicate value %r in set&quot;,</span>
<span class="gi">+            &quot;duplicate-value&quot;,</span>
<span class="gi">+            &quot;This message is emitted when a set contains the same value two or more times.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0131&quot;: (</span>
<span class="gi">+            &quot;Named expression used without context&quot;,</span>
<span class="gi">+            &quot;named-expr-without-context&quot;,</span>
<span class="gi">+            &quot;Emitted if named expression is used to do a regular assignment &quot;</span>
<span class="gi">+            &quot;outside a context like if, for, while, or a comprehension.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0133&quot;: (</span>
<span class="gi">+            &quot;Exception statement has no effect&quot;,</span>
<span class="gi">+            &quot;pointless-exception-statement&quot;,</span>
<span class="gi">+            &quot;Used when an exception is created without being assigned, raised or returned &quot;</span>
<span class="gi">+            &quot;for subsequent use elsewhere.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0134&quot;: (</span>
<span class="gi">+            &quot;&#39;return&#39; shadowed by the &#39;finally&#39; clause.&quot;,</span>
<span class="gi">+            &quot;return-in-finally&quot;,</span>
<span class="gi">+            &quot;Emitted when a &#39;return&#39; statement is found in a &#39;finally&#39; block. This will overwrite &quot;</span>
<span class="gi">+            &quot;the return value of a function and should be avoided.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    reports = ((&quot;RP0101&quot;, &quot;Statistics by type&quot;, report_by_type_stats),)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="w"> </span>        self._trys: list[nodes.Try]

<span class="gd">-    def open(self) -&gt;None:</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize visit variables and statistics.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        py_version = self.linter.config.py_version</span>
<span class="gi">+        self._py38_plus = py_version &gt;= (3, 8)</span>
<span class="gi">+        self._trys = []</span>
<span class="gi">+        self.linter.stats.reset_node_count()</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;using-constant-test&quot;, &quot;missing-parentheses-for-call-in-test&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_if(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        self._check_using_constant_test(node, node.test)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;using-constant-test&quot;, &quot;missing-parentheses-for-call-in-test&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_ifexp(self, node: nodes.IfExp) -&gt; None:</span>
<span class="gi">+        self._check_using_constant_test(node, node.test)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;using-constant-test&quot;, &quot;missing-parentheses-for-call-in-test&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_comprehension(self, node: nodes.Comprehension) -&gt; None:</span>
<span class="gi">+        if node.ifs:</span>
<span class="gi">+            for if_test in node.ifs:</span>
<span class="gi">+                self._check_using_constant_test(node, if_test)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_using_constant_test(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.If | nodes.IfExp | nodes.Comprehension,</span>
<span class="gi">+        test: nodes.NodeNG | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        const_nodes = (</span>
<span class="gi">+            nodes.Module,</span>
<span class="gi">+            nodes.GeneratorExp,</span>
<span class="gi">+            nodes.Lambda,</span>
<span class="gi">+            nodes.FunctionDef,</span>
<span class="gi">+            nodes.ClassDef,</span>
<span class="gi">+            astroid.bases.Generator,</span>
<span class="gi">+            astroid.UnboundMethod,</span>
<span class="gi">+            astroid.BoundMethod,</span>
<span class="gi">+            nodes.Module,</span>
<span class="gi">+        )</span>
<span class="gi">+        structs = (nodes.Dict, nodes.Tuple, nodes.Set, nodes.List)</span>
<span class="gi">+</span>
<span class="gi">+        # These nodes are excepted, since they are not constant</span>
<span class="gi">+        # values, requiring a computation to happen.</span>
<span class="gi">+        except_nodes = (</span>
<span class="gi">+            nodes.Call,</span>
<span class="gi">+            nodes.BinOp,</span>
<span class="gi">+            nodes.BoolOp,</span>
<span class="gi">+            nodes.UnaryOp,</span>
<span class="gi">+            nodes.Subscript,</span>
<span class="gi">+        )</span>
<span class="gi">+        inferred = None</span>
<span class="gi">+        emit = isinstance(test, (nodes.Const, *structs, *const_nodes))</span>
<span class="gi">+        maybe_generator_call = None</span>
<span class="gi">+        if not isinstance(test, except_nodes):</span>
<span class="gi">+            inferred = utils.safe_infer(test)</span>
<span class="gi">+            if isinstance(inferred, util.UninferableBase) and isinstance(</span>
<span class="gi">+                test, nodes.Name</span>
<span class="gi">+            ):</span>
<span class="gi">+                emit, maybe_generator_call = BasicChecker._name_holds_generator(test)</span>
<span class="gi">+</span>
<span class="gi">+        # Emit if calling a function that only returns GeneratorExp (always tests True)</span>
<span class="gi">+        elif isinstance(test, nodes.Call):</span>
<span class="gi">+            maybe_generator_call = test</span>
<span class="gi">+        if maybe_generator_call:</span>
<span class="gi">+            inferred_call = utils.safe_infer(maybe_generator_call.func)</span>
<span class="gi">+            if isinstance(inferred_call, nodes.FunctionDef):</span>
<span class="gi">+                # Can&#39;t use all(x) or not any(not x) for this condition, because it</span>
<span class="gi">+                # will return True for empty generators, which is not what we want.</span>
<span class="gi">+                all_returns_were_generator = None</span>
<span class="gi">+                for return_node in inferred_call._get_return_nodes_skip_functions():</span>
<span class="gi">+                    if not isinstance(return_node.value, nodes.GeneratorExp):</span>
<span class="gi">+                        all_returns_were_generator = False</span>
<span class="gi">+                        break</span>
<span class="gi">+                    all_returns_were_generator = True</span>
<span class="gi">+                if all_returns_were_generator:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;using-constant-test&quot;, node=node, confidence=INFERENCE</span>
<span class="gi">+                    )</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+        if emit:</span>
<span class="gi">+            self.add_message(&quot;using-constant-test&quot;, node=test, confidence=INFERENCE)</span>
<span class="gi">+        elif isinstance(inferred, const_nodes):</span>
<span class="gi">+            # If the constant node is a FunctionDef or Lambda then</span>
<span class="gi">+            # it may be an illicit function call due to missing parentheses</span>
<span class="gi">+            call_inferred = None</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Just forcing the generator to infer all elements.</span>
<span class="gi">+                # astroid.exceptions.InferenceError are false positives</span>
<span class="gi">+                # see https://github.com/pylint-dev/pylint/pull/8185</span>
<span class="gi">+                if isinstance(inferred, nodes.FunctionDef):</span>
<span class="gi">+                    call_inferred = list(inferred.infer_call_result(node))</span>
<span class="gi">+                elif isinstance(inferred, nodes.Lambda):</span>
<span class="gi">+                    call_inferred = list(inferred.infer_call_result(node))</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                call_inferred = None</span>
<span class="gi">+            if call_inferred:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;missing-parentheses-for-call-in-test&quot;,</span>
<span class="gi">+                    node=test,</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+            self.add_message(&quot;using-constant-test&quot;, node=test, confidence=INFERENCE)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _name_holds_generator(test: nodes.Name) -&gt;tuple[bool, nodes.Call | None</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def _name_holds_generator(test: nodes.Name) -&gt; tuple[bool, nodes.Call | None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return whether `test` tests a name certain to hold a generator, or optionally
<span class="w"> </span>        a call that should be then tested to see if *it* returns only generators.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_module(self, _: nodes.Module) -&gt;None:</span>
<span class="gi">+        assert isinstance(test, nodes.Name)</span>
<span class="gi">+        emit = False</span>
<span class="gi">+        maybe_generator_call = None</span>
<span class="gi">+        lookup_result = test.frame().lookup(test.name)</span>
<span class="gi">+        if not lookup_result:</span>
<span class="gi">+            return emit, maybe_generator_call</span>
<span class="gi">+        maybe_generator_assigned = (</span>
<span class="gi">+            isinstance(assign_name.parent.value, nodes.GeneratorExp)</span>
<span class="gi">+            for assign_name in lookup_result[1]</span>
<span class="gi">+            if isinstance(assign_name.parent, nodes.Assign)</span>
<span class="gi">+        )</span>
<span class="gi">+        first_item = next(maybe_generator_assigned, None)</span>
<span class="gi">+        if first_item is not None:</span>
<span class="gi">+            # Emit if this variable is certain to hold a generator</span>
<span class="gi">+            if all(itertools.chain((first_item,), maybe_generator_assigned)):</span>
<span class="gi">+                emit = True</span>
<span class="gi">+            # If this variable holds the result of a call, save it for next test</span>
<span class="gi">+            elif (</span>
<span class="gi">+                len(lookup_result[1]) == 1</span>
<span class="gi">+                and isinstance(lookup_result[1][0].parent, nodes.Assign)</span>
<span class="gi">+                and isinstance(lookup_result[1][0].parent.value, nodes.Call)</span>
<span class="gi">+            ):</span>
<span class="gi">+                maybe_generator_call = lookup_result[1][0].parent.value</span>
<span class="gi">+        return emit, maybe_generator_call</span>
<span class="gi">+</span>
<span class="gi">+    def visit_module(self, _: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check module name, docstring and required arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.linter.stats.node_count[&quot;module&quot;] += 1</span>

<span class="gd">-    def visit_classdef(self, _: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    def visit_classdef(self, _: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check module name, docstring and redefinition
<span class="w"> </span>        increment branch counter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;pointless-statement&#39;,</span>
<span class="gd">-        &#39;pointless-exception-statement&#39;, &#39;pointless-string-statement&#39;,</span>
<span class="gd">-        &#39;expression-not-assigned&#39;, &#39;named-expr-without-context&#39;)</span>
<span class="gd">-    def visit_expr(self, node: nodes.Expr) -&gt;None:</span>
<span class="gi">+        self.linter.stats.node_count[&quot;klass&quot;] += 1</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;pointless-statement&quot;,</span>
<span class="gi">+        &quot;pointless-exception-statement&quot;,</span>
<span class="gi">+        &quot;pointless-string-statement&quot;,</span>
<span class="gi">+        &quot;expression-not-assigned&quot;,</span>
<span class="gi">+        &quot;named-expr-without-context&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_expr(self, node: nodes.Expr) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for various kind of statements without effect.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        expr = node.value</span>
<span class="gi">+        if isinstance(expr, nodes.Const) and isinstance(expr.value, str):</span>
<span class="gi">+            # treat string statement in a separated message</span>
<span class="gi">+            # Handle PEP-257 attribute docstrings.</span>
<span class="gi">+            # An attribute docstring is defined as being a string right after</span>
<span class="gi">+            # an assignment at the module level, class level or __init__ level.</span>
<span class="gi">+            scope = expr.scope()</span>
<span class="gi">+            if isinstance(scope, (nodes.ClassDef, nodes.Module, nodes.FunctionDef)):</span>
<span class="gi">+                if isinstance(scope, nodes.FunctionDef) and scope.name != &quot;__init__&quot;:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    sibling = expr.previous_sibling()</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        sibling is not None</span>
<span class="gi">+                        and sibling.scope() is scope</span>
<span class="gi">+                        and isinstance(</span>
<span class="gi">+                            sibling, (nodes.Assign, nodes.AnnAssign, nodes.TypeAlias)</span>
<span class="gi">+                        )</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return</span>
<span class="gi">+            self.add_message(&quot;pointless-string-statement&quot;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Warn W0133 for exceptions that are used as statements</span>
<span class="gi">+        if isinstance(expr, nodes.Call):</span>
<span class="gi">+            name = &quot;&quot;</span>
<span class="gi">+            if isinstance(expr.func, nodes.Name):</span>
<span class="gi">+                name = expr.func.name</span>
<span class="gi">+            elif isinstance(expr.func, nodes.Attribute):</span>
<span class="gi">+                name = expr.func.attrname</span>
<span class="gi">+</span>
<span class="gi">+            # Heuristic: only run inference for names that begin with an uppercase char</span>
<span class="gi">+            # This reduces W0133&#39;s coverage, but retains acceptable runtime performance</span>
<span class="gi">+            # For more details, see: https://github.com/pylint-dev/pylint/issues/8073</span>
<span class="gi">+            inferred = utils.safe_infer(expr) if name[:1].isupper() else None</span>
<span class="gi">+            if isinstance(inferred, objects.ExceptionInstance):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;pointless-exception-statement&quot;, node=node, confidence=INFERENCE</span>
<span class="gi">+                )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Ignore if this is :</span>
<span class="gi">+        # * the unique child of a try/except body</span>
<span class="gi">+        # * a yield statement</span>
<span class="gi">+        # * an ellipsis (which can be used on Python 3 instead of pass)</span>
<span class="gi">+        # warn W0106 if we have any underlying function call (we can&#39;t predict</span>
<span class="gi">+        # side effects), else pointless-statement</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(expr, (nodes.Yield, nodes.Await))</span>
<span class="gi">+            or (</span>
<span class="gi">+                isinstance(node.parent, (nodes.Try, nodes.TryStar))</span>
<span class="gi">+                and node.parent.body == [node]</span>
<span class="gi">+            )</span>
<span class="gi">+            or (isinstance(expr, nodes.Const) and expr.value is Ellipsis)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(expr, nodes.NamedExpr):</span>
<span class="gi">+            self.add_message(&quot;named-expr-without-context&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+        elif any(expr.nodes_of_class(nodes.Call)):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;expression-not-assigned&quot;, node=node, args=expr.as_string()</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_message(&quot;pointless-statement&quot;, node=node)</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;unnecessary-lambda&#39;)</span>
<span class="gd">-    def visit_lambda(self, node: nodes.Lambda) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Check whether the lambda is suspicious.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _filter_vararg(</span>
<span class="gi">+        node: nodes.Lambda, call_args: list[nodes.NodeNG]</span>
<span class="gi">+    ) -&gt; Iterator[nodes.NodeNG]:</span>
<span class="gi">+        # Return the arguments for the given call which are</span>
<span class="gi">+        # not passed as vararg.</span>
<span class="gi">+        for arg in call_args:</span>
<span class="gi">+            if isinstance(arg, nodes.Starred):</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(arg.value, nodes.Name)</span>
<span class="gi">+                    and arg.value.name != node.args.vararg</span>
<span class="gi">+                ):</span>
<span class="gi">+                    yield arg</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield arg</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;dangerous-default-value&#39;)</span>
<span class="gd">-    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _has_variadic_argument(</span>
<span class="gi">+        args: list[nodes.Starred | nodes.Keyword], variadic_name: str</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        return not args or any(</span>
<span class="gi">+            isinstance(a.value, nodes.Name)</span>
<span class="gi">+            and a.value.name != variadic_name</span>
<span class="gi">+            or not isinstance(a.value, nodes.Name)</span>
<span class="gi">+            for a in args</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;unnecessary-lambda&quot;)</span>
<span class="gi">+    def visit_lambda(self, node: nodes.Lambda) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Check whether the lambda is suspicious.&quot;&quot;&quot;</span>
<span class="gi">+        # if the body of the lambda is a call expression with the same</span>
<span class="gi">+        # argument list as the lambda itself, then the lambda is</span>
<span class="gi">+        # possibly unnecessary and at least suspicious.</span>
<span class="gi">+        if node.args.defaults:</span>
<span class="gi">+            # If the arguments of the lambda include defaults, then a</span>
<span class="gi">+            # judgment cannot be made because there is no way to check</span>
<span class="gi">+            # that the defaults defined by the lambda are the same as</span>
<span class="gi">+            # the defaults defined by the function called in the body</span>
<span class="gi">+            # of the lambda.</span>
<span class="gi">+            return</span>
<span class="gi">+        call = node.body</span>
<span class="gi">+        if not isinstance(call, nodes.Call):</span>
<span class="gi">+            # The body of the lambda must be a function call expression</span>
<span class="gi">+            # for the lambda to be unnecessary.</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node.body.func, nodes.Attribute) and isinstance(</span>
<span class="gi">+            node.body.func.expr, nodes.Call</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Chained call, the intermediate call might</span>
<span class="gi">+            # return something else (but we don&#39;t check that, yet).</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        ordinary_args = list(node.args.args)</span>
<span class="gi">+        new_call_args = list(self._filter_vararg(node, call.args))</span>
<span class="gi">+        if node.args.kwarg:</span>
<span class="gi">+            if self._has_variadic_argument(call.keywords, node.args.kwarg):</span>
<span class="gi">+                return</span>
<span class="gi">+        elif call.keywords:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if node.args.vararg:</span>
<span class="gi">+            if self._has_variadic_argument(call.starargs, node.args.vararg):</span>
<span class="gi">+                return</span>
<span class="gi">+        elif call.starargs:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # The &quot;ordinary&quot; arguments must be in a correspondence such that:</span>
<span class="gi">+        # ordinary_args[i].name == call.args[i].name.</span>
<span class="gi">+        if len(ordinary_args) != len(new_call_args):</span>
<span class="gi">+            return</span>
<span class="gi">+        for arg, passed_arg in zip(ordinary_args, new_call_args):</span>
<span class="gi">+            if not isinstance(passed_arg, nodes.Name):</span>
<span class="gi">+                return</span>
<span class="gi">+            if arg.name != passed_arg.name:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        # The lambda is necessary if it uses its parameter in the function it is</span>
<span class="gi">+        # calling in the lambda&#39;s body</span>
<span class="gi">+        # e.g. lambda foo: (func1 if foo else func2)(foo)</span>
<span class="gi">+        for name in call.func.nodes_of_class(nodes.Name):</span>
<span class="gi">+            if name.lookup(name.name)[0] is node:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;unnecessary-lambda&quot;, line=node.fromlineno, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;dangerous-default-value&quot;)</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check function name, docstring, arguments, redefinition,
<span class="w"> </span>        variable names, max locals.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.is_method():</span>
<span class="gi">+            self.linter.stats.node_count[&quot;method&quot;] += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.linter.stats.node_count[&quot;function&quot;] += 1</span>
<span class="gi">+        self._check_dangerous_default(node)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    def _check_dangerous_default(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    def _check_dangerous_default(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for dangerous default values as arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;unreachable&#39;, &#39;lost-exception&#39;)</span>
<span class="gd">-    def visit_return(self, node: nodes.Return) -&gt;None:</span>
<span class="gi">+        def is_iterable(internal_node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+            return isinstance(internal_node, (nodes.List, nodes.Set, nodes.Dict))</span>
<span class="gi">+</span>
<span class="gi">+        defaults = (node.args.defaults or []) + (node.args.kw_defaults or [])</span>
<span class="gi">+        for default in defaults:</span>
<span class="gi">+            if not default:</span>
<span class="gi">+                continue</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = next(default.infer())</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(value, astroid.Instance)</span>
<span class="gi">+                and value.qname() in DEFAULT_ARGUMENT_SYMBOLS</span>
<span class="gi">+            ):</span>
<span class="gi">+                if value is default:</span>
<span class="gi">+                    msg = DEFAULT_ARGUMENT_SYMBOLS[value.qname()]</span>
<span class="gi">+                elif isinstance(value, astroid.Instance) or is_iterable(value):</span>
<span class="gi">+                    # We are here in the following situation(s):</span>
<span class="gi">+                    #   * a dict/set/list/tuple call which wasn&#39;t inferred</span>
<span class="gi">+                    #     to a syntax node ({}, () etc.). This can happen</span>
<span class="gi">+                    #     when the arguments are invalid or unknown to</span>
<span class="gi">+                    #     the inference.</span>
<span class="gi">+                    #   * a variable from somewhere else, which turns out to be a list</span>
<span class="gi">+                    #     or a dict.</span>
<span class="gi">+                    if is_iterable(default):</span>
<span class="gi">+                        msg = value.pytype()</span>
<span class="gi">+                    elif isinstance(default, nodes.Call):</span>
<span class="gi">+                        msg = f&quot;{value.name}() ({value.qname()})&quot;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        msg = f&quot;{default.as_string()} ({value.qname()})&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # this argument is a name</span>
<span class="gi">+                    msg = f&quot;{default.as_string()} ({DEFAULT_ARGUMENT_SYMBOLS[value.qname()]})&quot;</span>
<span class="gi">+                self.add_message(&quot;dangerous-default-value&quot;, node=node, args=(msg,))</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;unreachable&quot;, &quot;lost-exception&quot;)</span>
<span class="gi">+    def visit_return(self, node: nodes.Return) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return node visitor.

<span class="w"> </span>        1 - check if the node has a right sibling (if so, that&#39;s some
<span class="gu">@@ -184,17 +643,19 @@ class BasicChecker(_BasicChecker):</span>
<span class="w"> </span>        2 - check if the node is inside the &#39;finally&#39; clause of a &#39;try...finally&#39;
<span class="w"> </span>        block
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_unreachable(node)</span>
<span class="gi">+        # Is it inside final body of a try...finally block ?</span>
<span class="gi">+        self._check_not_in_finally(node, &quot;return&quot;, (nodes.FunctionDef,))</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;unreachable&#39;)</span>
<span class="gd">-    def visit_continue(self, node: nodes.Continue) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;unreachable&quot;)</span>
<span class="gi">+    def visit_continue(self, node: nodes.Continue) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check is the node has a right sibling (if so, that&#39;s some unreachable
<span class="w"> </span>        code).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_unreachable(node)</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;unreachable&#39;, &#39;lost-exception&#39;)</span>
<span class="gd">-    def visit_break(self, node: nodes.Break) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;unreachable&quot;, &quot;lost-exception&quot;)</span>
<span class="gi">+    def visit_break(self, node: nodes.Break) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Break node visitor.

<span class="w"> </span>        1 - check if the node has a right sibling (if so, that&#39;s some
<span class="gu">@@ -202,61 +663,309 @@ class BasicChecker(_BasicChecker):</span>
<span class="w"> </span>        2 - check if the node is inside the &#39;finally&#39; clause of a &#39;try...finally&#39;
<span class="w"> </span>        block
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # 1 - Is it right sibling ?</span>
<span class="gi">+        self._check_unreachable(node)</span>
<span class="gi">+        # 2 - Is it inside final body of a try...finally block ?</span>
<span class="gi">+        self._check_not_in_finally(node, &quot;break&quot;, (nodes.For, nodes.While))</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;unreachable&#39;)</span>
<span class="gd">-    def visit_raise(self, node: nodes.Raise) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;unreachable&quot;)</span>
<span class="gi">+    def visit_raise(self, node: nodes.Raise) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the node has a right sibling (if so, that&#39;s some unreachable
<span class="w"> </span>        code).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;eval-used&#39;, &#39;exec-used&#39;,</span>
<span class="gd">-        &#39;bad-reversed-sequence&#39;, &#39;misplaced-format-function&#39;, &#39;unreachable&#39;)</span>
<span class="gd">-    def visit_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+        self._check_unreachable(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_misplaced_format_function(self, call_node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if not isinstance(call_node.func, nodes.Attribute):</span>
<span class="gi">+            return</span>
<span class="gi">+        if call_node.func.attrname != &quot;format&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        expr = utils.safe_infer(call_node.func.expr)</span>
<span class="gi">+        if isinstance(expr, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not expr:</span>
<span class="gi">+            # we are doubtful on inferred type of node, so here just check if format</span>
<span class="gi">+            # was called on print()</span>
<span class="gi">+            call_expr = call_node.func.expr</span>
<span class="gi">+            if not isinstance(call_expr, nodes.Call):</span>
<span class="gi">+                return</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(call_expr.func, nodes.Name)</span>
<span class="gi">+                and call_expr.func.name == &quot;print&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;misplaced-format-function&quot;, node=call_node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;eval-used&quot;,</span>
<span class="gi">+        &quot;exec-used&quot;,</span>
<span class="gi">+        &quot;bad-reversed-sequence&quot;,</span>
<span class="gi">+        &quot;misplaced-format-function&quot;,</span>
<span class="gi">+        &quot;unreachable&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit a Call node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;assert-on-tuple&#39;,</span>
<span class="gd">-        &#39;assert-on-string-literal&#39;)</span>
<span class="gd">-    def visit_assert(self, node: nodes.Assert) -&gt;None:</span>
<span class="gi">+        if utils.is_terminating_func(node):</span>
<span class="gi">+            self._check_unreachable(node, confidence=INFERENCE)</span>
<span class="gi">+        self._check_misplaced_format_function(node)</span>
<span class="gi">+        if isinstance(node.func, nodes.Name):</span>
<span class="gi">+            name = node.func.name</span>
<span class="gi">+            # ignore the name if it&#39;s not a builtin (i.e. not defined in the</span>
<span class="gi">+            # locals nor globals scope)</span>
<span class="gi">+            if not (name in node.frame() or name in node.root()):</span>
<span class="gi">+                if name == &quot;exec&quot;:</span>
<span class="gi">+                    self.add_message(&quot;exec-used&quot;, node=node)</span>
<span class="gi">+                elif name == &quot;reversed&quot;:</span>
<span class="gi">+                    self._check_reversed(node)</span>
<span class="gi">+                elif name == &quot;eval&quot;:</span>
<span class="gi">+                    self.add_message(&quot;eval-used&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;assert-on-tuple&quot;, &quot;assert-on-string-literal&quot;)</span>
<span class="gi">+    def visit_assert(self, node: nodes.Assert) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether assert is used on a tuple or string literal.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;duplicate-key&#39;)</span>
<span class="gd">-    def visit_dict(self, node: nodes.Dict) -&gt;None:</span>
<span class="gi">+        if isinstance(node.test, nodes.Tuple) and len(node.test.elts) &gt; 0:</span>
<span class="gi">+            self.add_message(&quot;assert-on-tuple&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.test, nodes.Const) and isinstance(node.test.value, str):</span>
<span class="gi">+            if node.test.value:</span>
<span class="gi">+                when = &quot;never&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                when = &quot;always&quot;</span>
<span class="gi">+            self.add_message(&quot;assert-on-string-literal&quot;, node=node, args=(when,))</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;duplicate-key&quot;)</span>
<span class="gi">+    def visit_dict(self, node: nodes.Dict) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check duplicate key in dictionary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;duplicate-value&#39;)</span>
<span class="gd">-    def visit_set(self, node: nodes.Set) -&gt;None:</span>
<span class="gi">+        keys = set()</span>
<span class="gi">+        for k, _ in node.items:</span>
<span class="gi">+            if isinstance(k, nodes.Const):</span>
<span class="gi">+                key = k.value</span>
<span class="gi">+            elif isinstance(k, nodes.Attribute):</span>
<span class="gi">+                key = k.as_string()</span>
<span class="gi">+            else:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if key in keys:</span>
<span class="gi">+                self.add_message(&quot;duplicate-key&quot;, node=node, args=key)</span>
<span class="gi">+            keys.add(key)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;duplicate-value&quot;)</span>
<span class="gi">+    def visit_set(self, node: nodes.Set) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check duplicate value in set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_try(self, node: nodes.Try) -&gt;None:</span>
<span class="gi">+        values = set()</span>
<span class="gi">+        for v in node.elts:</span>
<span class="gi">+            if isinstance(v, nodes.Const):</span>
<span class="gi">+                value = v.value</span>
<span class="gi">+            else:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if value in values:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;duplicate-value&quot;, node=node, args=value, confidence=HIGH</span>
<span class="gi">+                )</span>
<span class="gi">+            values.add(value)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_try(self, node: nodes.Try) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update try block flag.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._trys.append(node)</span>

<span class="gd">-    def leave_try(self, _: nodes.Try) -&gt;None:</span>
<span class="gi">+        for final_node in node.finalbody:</span>
<span class="gi">+            for return_node in final_node.nodes_of_class(nodes.Return):</span>
<span class="gi">+                self.add_message(&quot;return-in-finally&quot;, node=return_node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    def leave_try(self, _: nodes.Try) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update try block flag.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._trys.pop()</span>

<span class="gd">-    def _check_unreachable(self, node: (nodes.Return | nodes.Continue |</span>
<span class="gd">-        nodes.Break | nodes.Raise | nodes.Call), confidence: Confidence=HIGH</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _check_unreachable(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Return | nodes.Continue | nodes.Break | nodes.Raise | nodes.Call,</span>
<span class="gi">+        confidence: Confidence = HIGH,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check unreachable code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_not_in_finally(self, node: (nodes.Break | nodes.Return),</span>
<span class="gd">-        node_name: str, breaker_classes: tuple[nodes.NodeNG, ...]=()) -&gt;None:</span>
<span class="gi">+        unreachable_statement = node.next_sibling()</span>
<span class="gi">+        if unreachable_statement is not None:</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(node, nodes.Return)</span>
<span class="gi">+                and isinstance(unreachable_statement, nodes.Expr)</span>
<span class="gi">+                and isinstance(unreachable_statement.value, nodes.Yield)</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Don&#39;t add &#39;unreachable&#39; for empty generators.</span>
<span class="gi">+                # Only add warning if &#39;yield&#39; is followed by another node.</span>
<span class="gi">+                unreachable_statement = unreachable_statement.next_sibling()</span>
<span class="gi">+                if unreachable_statement is None:</span>
<span class="gi">+                    return</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unreachable&quot;, node=unreachable_statement, confidence=confidence</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_not_in_finally(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Break | nodes.Return,</span>
<span class="gi">+        node_name: str,</span>
<span class="gi">+        breaker_classes: tuple[nodes.NodeNG, ...] = (),</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that a node is not inside a &#39;finally&#39; clause of a
<span class="w"> </span>        &#39;try...finally&#39; statement.

<span class="w"> </span>        If we find a parent which type is in breaker_classes before
<span class="w"> </span>        a &#39;try...finally&#39; block we skip the whole check.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_reversed(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+        # if self._trys is empty, we&#39;re not an in try block</span>
<span class="gi">+        if not self._trys:</span>
<span class="gi">+            return</span>
<span class="gi">+        # the node could be a grand-grand...-child of the &#39;try...finally&#39;</span>
<span class="gi">+        _parent = node.parent</span>
<span class="gi">+        _node = node</span>
<span class="gi">+        while _parent and not isinstance(_parent, breaker_classes):</span>
<span class="gi">+            if hasattr(_parent, &quot;finalbody&quot;) and _node in _parent.finalbody:</span>
<span class="gi">+                self.add_message(&quot;lost-exception&quot;, node=node, args=node_name)</span>
<span class="gi">+                return</span>
<span class="gi">+            _node = _parent</span>
<span class="gi">+            _parent = _node.parent</span>
<span class="gi">+</span>
<span class="gi">+    def _check_reversed(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that the argument to `reversed` is a sequence.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            argument = utils.safe_infer(utils.get_argument_from_call(node, position=0))</span>
<span class="gi">+        except utils.NoSuchArgumentError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(argument, util.UninferableBase):</span>
<span class="gi">+                return</span>
<span class="gi">+            if argument is None:</span>
<span class="gi">+                # Nothing was inferred.</span>
<span class="gi">+                # Try to see if we have iter().</span>
<span class="gi">+                if isinstance(node.args[0], nodes.Call):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        func = next(node.args[0].func.infer())</span>
<span class="gi">+                    except astroid.InferenceError:</span>
<span class="gi">+                        return</span>
<span class="gi">+                    if getattr(</span>
<span class="gi">+                        func, &quot;name&quot;, None</span>
<span class="gi">+                    ) == &quot;iter&quot; and utils.is_builtin_object(func):</span>
<span class="gi">+                        self.add_message(&quot;bad-reversed-sequence&quot;, node=node)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(argument, (nodes.List, nodes.Tuple)):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # dicts are reversible, but only from Python 3.8 onward. Prior to</span>
<span class="gi">+            # that, any class based on dict must explicitly provide a</span>
<span class="gi">+            # __reversed__ method</span>
<span class="gi">+            if not self._py38_plus and isinstance(argument, astroid.Instance):</span>
<span class="gi">+                if any(</span>
<span class="gi">+                    ancestor.name == &quot;dict&quot; and utils.is_builtin_object(ancestor)</span>
<span class="gi">+                    for ancestor in itertools.chain(</span>
<span class="gi">+                        (argument._proxied,), argument._proxied.ancestors()</span>
<span class="gi">+                    )</span>
<span class="gi">+                ):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        argument.locals[REVERSED_PROTOCOL_METHOD]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        self.add_message(&quot;bad-reversed-sequence&quot;, node=node)</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            if hasattr(argument, &quot;getattr&quot;):</span>
<span class="gi">+                # everything else is not a proper sequence for reversed()</span>
<span class="gi">+                for methods in REVERSED_METHODS:</span>
<span class="gi">+                    for meth in methods:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            argument.getattr(meth)</span>
<span class="gi">+                        except astroid.NotFoundError:</span>
<span class="gi">+                            break</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_message(&quot;bad-reversed-sequence&quot;, node=node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.add_message(&quot;bad-reversed-sequence&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;confusing-with-statement&quot;)</span>
<span class="gi">+    def visit_with(self, node: nodes.With) -&gt; None:</span>
<span class="gi">+        # a &quot;with&quot; statement with multiple managers corresponds</span>
<span class="gi">+        # to one AST &quot;With&quot; node with multiple items</span>
<span class="gi">+        pairs = node.items</span>
<span class="gi">+        if pairs:</span>
<span class="gi">+            for prev_pair, pair in zip(pairs, pairs[1:]):</span>
<span class="gi">+                if isinstance(prev_pair[1], nodes.AssignName) and (</span>
<span class="gi">+                    pair[1] is None and not isinstance(pair[0], nodes.Call)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Don&#39;t emit a message if the second is a function call</span>
<span class="gi">+                    # there&#39;s no way that can be mistaken for a name assignment.</span>
<span class="gi">+                    # If the line number doesn&#39;t match</span>
<span class="gi">+                    # we assume it&#39;s a nested &quot;with&quot;.</span>
<span class="gi">+                    self.add_message(&quot;confusing-with-statement&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_self_assigning_variable(self, node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        # Detect assigning to the same variable.</span>
<span class="gi">+</span>
<span class="gi">+        scope = node.scope()</span>
<span class="gi">+        scope_locals = scope.locals</span>
<span class="gi">+</span>
<span class="gi">+        rhs_names = []</span>
<span class="gi">+        targets = node.targets</span>
<span class="gi">+        if isinstance(targets[0], nodes.Tuple):</span>
<span class="gi">+            if len(targets) != 1:</span>
<span class="gi">+                # A complex assignment, so bail out early.</span>
<span class="gi">+                return</span>
<span class="gi">+            targets = targets[0].elts</span>
<span class="gi">+            if len(targets) == 1:</span>
<span class="gi">+                # Unpacking a variable into the same name.</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.value, nodes.Name):</span>
<span class="gi">+            if len(targets) != 1:</span>
<span class="gi">+                return</span>
<span class="gi">+            rhs_names = [node.value]</span>
<span class="gi">+        elif isinstance(node.value, nodes.Tuple):</span>
<span class="gi">+            rhs_count = len(node.value.elts)</span>
<span class="gi">+            if len(targets) != rhs_count or rhs_count == 1:</span>
<span class="gi">+                return</span>
<span class="gi">+            rhs_names = node.value.elts</span>
<span class="gi">+</span>
<span class="gi">+        for target, lhs_name in zip(targets, rhs_names):</span>
<span class="gi">+            if not isinstance(lhs_name, nodes.Name):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not isinstance(target, nodes.AssignName):</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Check that the scope is different from a class level, which is usually</span>
<span class="gi">+            # a pattern to expose module level attributes as class level ones.</span>
<span class="gi">+            if isinstance(scope, nodes.ClassDef) and target.name in scope_locals:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if target.name == lhs_name.name:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;self-assigning-variable&quot;, args=(target.name,), node=target</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_redeclared_assign_name(self, targets: list[nodes.NodeNG | None]) -&gt; None:</span>
<span class="gi">+        dummy_variables_rgx = self.linter.config.dummy_variables_rgx</span>
<span class="gi">+</span>
<span class="gi">+        for target in targets:</span>
<span class="gi">+            if not isinstance(target, nodes.Tuple):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            found_names = []</span>
<span class="gi">+            for element in target.elts:</span>
<span class="gi">+                if isinstance(element, nodes.Tuple):</span>
<span class="gi">+                    self._check_redeclared_assign_name([element])</span>
<span class="gi">+                elif isinstance(element, nodes.AssignName) and element.name != &quot;_&quot;:</span>
<span class="gi">+                    if dummy_variables_rgx and dummy_variables_rgx.match(element.name):</span>
<span class="gi">+                        return</span>
<span class="gi">+                    found_names.append(element.name)</span>
<span class="gi">+</span>
<span class="gi">+            names = collections.Counter(found_names)</span>
<span class="gi">+            for name, count in names.most_common():</span>
<span class="gi">+                if count &gt; 1:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;redeclared-assigned-name&quot;, args=(name,), node=target</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;self-assigning-variable&quot;, &quot;redeclared-assigned-name&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        self._check_self_assigning_variable(node)</span>
<span class="gi">+        self._check_redeclared_assign_name(node.targets)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;redeclared-assigned-name&quot;)</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        self._check_redeclared_assign_name([node.target])</span>
<span class="gh">diff --git a/pylint/checkers/base/basic_error_checker.py b/pylint/checkers/base/basic_error_checker.py</span>
<span class="gh">index 14c962bfb..e58be2309 100644</span>
<span class="gd">--- a/pylint/checkers/base/basic_error_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/basic_error_checker.py</span>
<span class="gu">@@ -1,22 +1,31 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Basic Error checker from the basic checker.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>from collections.abc import Iterator
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="w"> </span>from astroid.typing import InferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.base.basic_checker import _BasicChecker
<span class="w"> </span>from pylint.checkers.utils import infer_all
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gd">-ABC_METACLASSES = {&#39;_py_abc.ABCMeta&#39;, &#39;abc.ABCMeta&#39;}</span>
<span class="gd">-REDEFINABLE_METHODS = frozenset((&#39;__module__&#39;,))</span>
<span class="gd">-TYPING_FORWARD_REF_QNAME = &#39;typing.ForwardRef&#39;</span>
<span class="gi">+</span>
<span class="gi">+ABC_METACLASSES = {&quot;_py_abc.ABCMeta&quot;, &quot;abc.ABCMeta&quot;}  # Python 3.7+,</span>
<span class="gi">+# List of methods which can be redefined</span>
<span class="gi">+REDEFINABLE_METHODS = frozenset((&quot;__module__&quot;,))</span>
<span class="gi">+TYPING_FORWARD_REF_QNAME = &quot;typing.ForwardRef&quot;</span>


<span class="gd">-def _get_break_loop_node(break_node: nodes.Break) -&gt;(nodes.For | nodes.</span>
<span class="gd">-    While | None):</span>
<span class="gi">+def _get_break_loop_node(break_node: nodes.Break) -&gt; nodes.For | nodes.While | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the loop node that holds the break node in arguments.

<span class="w"> </span>    Args:
<span class="gu">@@ -25,10 +34,19 @@ def _get_break_loop_node(break_node: nodes.Break) -&gt;(nodes.For | nodes.</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        astroid.For or astroid.While: the loop node holding the break node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop_nodes = (nodes.For, nodes.While)</span>
<span class="gi">+    parent = break_node.parent</span>
<span class="gi">+    while not isinstance(parent, loop_nodes) or break_node in getattr(</span>
<span class="gi">+        parent, &quot;orelse&quot;, []</span>
<span class="gi">+    ):</span>
<span class="gi">+        break_node = parent</span>
<span class="gi">+        parent = parent.parent</span>
<span class="gi">+        if parent is None:</span>
<span class="gi">+            break</span>
<span class="gi">+    return parent</span>


<span class="gd">-def _loop_exits_early(loop: (nodes.For | nodes.While)) -&gt;bool:</span>
<span class="gi">+def _loop_exits_early(loop: nodes.For | nodes.While) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns true if a loop may end with a break statement.

<span class="w"> </span>    Args:
<span class="gu">@@ -37,19 +55,30 @@ def _loop_exits_early(loop: (nodes.For | nodes.While)) -&gt;bool:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        bool: True if the loop may end with a break statement, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    loop_nodes = (nodes.For, nodes.While)</span>
<span class="gi">+    definition_nodes = (nodes.FunctionDef, nodes.ClassDef)</span>
<span class="gi">+    inner_loop_nodes: list[nodes.For | nodes.While] = [</span>
<span class="gi">+        _node</span>
<span class="gi">+        for _node in loop.nodes_of_class(loop_nodes, skip_klass=definition_nodes)</span>
<span class="gi">+        if _node != loop</span>
<span class="gi">+    ]</span>
<span class="gi">+    return any(</span>
<span class="gi">+        _node</span>
<span class="gi">+        for _node in loop.nodes_of_class(nodes.Break, skip_klass=definition_nodes)</span>
<span class="gi">+        if _get_break_loop_node(_node) not in inner_loop_nodes</span>
<span class="gi">+    )</span>


<span class="gd">-def _has_abstract_methods(node: nodes.ClassDef) -&gt;bool:</span>
<span class="gi">+def _has_abstract_methods(node: nodes.ClassDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine if the given `node` has abstract methods.

<span class="w"> </span>    The methods should be made abstract by decorating them
<span class="w"> </span>    with `abc` decorators.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(utils.unimplemented_abstract_methods(node)) &gt; 0</span>


<span class="gd">-def redefined_by_decorator(node: nodes.FunctionDef) -&gt;bool:</span>
<span class="gi">+def redefined_by_decorator(node: nodes.FunctionDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if the object is a method redefined via decorator.

<span class="w"> </span>    For example:
<span class="gu">@@ -58,93 +87,495 @@ def redefined_by_decorator(node: nodes.FunctionDef) -&gt;bool:</span>
<span class="w"> </span>        @x.setter
<span class="w"> </span>        def x(self, value): self._x = value
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node.decorators:</span>
<span class="gi">+        for decorator in node.decorators.nodes:</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(decorator, nodes.Attribute)</span>
<span class="gi">+                and getattr(decorator.expr, &quot;name&quot;, None) == node.name</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class BasicErrorChecker(_BasicChecker):
<span class="gd">-    msgs = {&#39;E0100&#39;: (&#39;__init__ method is a generator&#39;, &#39;init-is-generator&#39;,</span>
<span class="gd">-        &#39;Used when the special class method __init__ is turned into a generator by a yield in its body.&#39;</span>
<span class="gd">-        ), &#39;E0101&#39;: (&#39;Explicit return in __init__&#39;, &#39;return-in-init&#39;,</span>
<span class="gd">-        &#39;Used when the special class method __init__ has an explicit return value.&#39;</span>
<span class="gd">-        ), &#39;E0102&#39;: (&#39;%s already defined line %s&#39;, &#39;function-redefined&#39;,</span>
<span class="gd">-        &#39;Used when a function / class / method is redefined.&#39;), &#39;E0103&#39;: (</span>
<span class="gd">-        &#39;%r not properly in loop&#39;, &#39;not-in-loop&#39;,</span>
<span class="gd">-        &#39;Used when break or continue keywords are used outside a loop.&#39;),</span>
<span class="gd">-        &#39;E0104&#39;: (&#39;Return outside function&#39;, &#39;return-outside-function&#39;,</span>
<span class="gd">-        &#39;Used when a &quot;return&quot; statement is found outside a function or method.&#39;</span>
<span class="gd">-        ), &#39;E0105&#39;: (&#39;Yield outside function&#39;, &#39;yield-outside-function&#39;,</span>
<span class="gd">-        &#39;Used when a &quot;yield&quot; statement is found outside a function or method.&#39;</span>
<span class="gd">-        ), &#39;E0106&#39;: (&#39;Return with argument inside generator&#39;,</span>
<span class="gd">-        &#39;return-arg-in-generator&#39;,</span>
<span class="gd">-        &#39;Used when a &quot;return&quot; statement with an argument is found in a generator function or method (e.g. with some &quot;yield&quot; statements).&#39;</span>
<span class="gd">-        , {&#39;maxversion&#39;: (3, 3)}), &#39;E0107&#39;: (</span>
<span class="gd">-        &#39;Use of the non-existent %s operator&#39;, &#39;nonexistent-operator&#39;,</span>
<span class="gd">-        &quot;Used when you attempt to use the C-style pre-increment or pre-decrement operator -- and ++, which doesn&#39;t exist in Python.&quot;</span>
<span class="gd">-        ), &#39;E0108&#39;: (&#39;Duplicate argument name %s in function definition&#39;,</span>
<span class="gd">-        &#39;duplicate-argument-name&#39;,</span>
<span class="gd">-        &#39;Duplicate argument names in function definitions are syntax errors.&#39;</span>
<span class="gd">-        ), &#39;E0110&#39;: (&#39;Abstract class %r with abstract methods instantiated&#39;,</span>
<span class="gd">-        &#39;abstract-class-instantiated&#39;,</span>
<span class="gd">-        &#39;Used when an abstract class with `abc.ABCMeta` as metaclass has abstract methods and is instantiated.&#39;</span>
<span class="gd">-        ), &#39;W0120&#39;: (</span>
<span class="gd">-        &#39;Else clause on loop without a break statement, remove the else and de-indent all the code inside it&#39;</span>
<span class="gd">-        , &#39;useless-else-on-loop&#39;,</span>
<span class="gd">-        &#39;Loops should only have an else clause if they can exit early with a break statement, otherwise the statements under else should be on the same scope as the loop itself.&#39;</span>
<span class="gd">-        ), &#39;E0112&#39;: (&#39;More than one starred expression in assignment&#39;,</span>
<span class="gd">-        &#39;too-many-star-expressions&#39;,</span>
<span class="gd">-        &#39;Emitted when there are more than one starred expressions (`*x`) in an assignment. This is a SyntaxError.&#39;</span>
<span class="gd">-        ), &#39;E0113&#39;: (&#39;Starred assignment target must be in a list or tuple&#39;,</span>
<span class="gd">-        &#39;invalid-star-assignment-target&#39;,</span>
<span class="gd">-        &#39;Emitted when a star expression is used as a starred assignment target.&#39;</span>
<span class="gd">-        ), &#39;E0114&#39;: (&#39;Can use starred expression only in assignment target&#39;,</span>
<span class="gd">-        &#39;star-needs-assignment-target&#39;,</span>
<span class="gd">-        &#39;Emitted when a star expression is not used in an assignment target.&#39;</span>
<span class="gd">-        ), &#39;E0115&#39;: (&#39;Name %r is nonlocal and global&#39;,</span>
<span class="gd">-        &#39;nonlocal-and-global&#39;,</span>
<span class="gd">-        &#39;Emitted when a name is both nonlocal and global.&#39;), &#39;E0116&#39;: (</span>
<span class="gd">-        &quot;&#39;continue&#39; not supported inside &#39;finally&#39; clause&quot;,</span>
<span class="gd">-        &#39;continue-in-finally&#39;,</span>
<span class="gd">-        &#39;Emitted when the `continue` keyword is found inside a finally clause, which is a SyntaxError.&#39;</span>
<span class="gd">-        ), &#39;E0117&#39;: (&#39;nonlocal name %s found without binding&#39;,</span>
<span class="gd">-        &#39;nonlocal-without-binding&#39;,</span>
<span class="gd">-        &#39;Emitted when a nonlocal variable does not have an attached name somewhere in the parent scopes&#39;</span>
<span class="gd">-        ), &#39;E0118&#39;: (&#39;Name %r is used prior to global declaration&#39;,</span>
<span class="gd">-        &#39;used-prior-global-declaration&#39;,</span>
<span class="gd">-        &#39;Emitted when a name is used prior a global declaration, which results in an error since Python 3.6.&#39;</span>
<span class="gd">-        , {&#39;minversion&#39;: (3, 6)})}</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;star-needs-assignment-target&#39;)</span>
<span class="gd">-    def visit_starred(self, node: nodes.Starred) -&gt;None:</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;E0100&quot;: (</span>
<span class="gi">+            &quot;__init__ method is a generator&quot;,</span>
<span class="gi">+            &quot;init-is-generator&quot;,</span>
<span class="gi">+            &quot;Used when the special class method __init__ is turned into a &quot;</span>
<span class="gi">+            &quot;generator by a yield in its body.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0101&quot;: (</span>
<span class="gi">+            &quot;Explicit return in __init__&quot;,</span>
<span class="gi">+            &quot;return-in-init&quot;,</span>
<span class="gi">+            &quot;Used when the special class method __init__ has an explicit &quot;</span>
<span class="gi">+            &quot;return value.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0102&quot;: (</span>
<span class="gi">+            &quot;%s already defined line %s&quot;,</span>
<span class="gi">+            &quot;function-redefined&quot;,</span>
<span class="gi">+            &quot;Used when a function / class / method is redefined.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0103&quot;: (</span>
<span class="gi">+            &quot;%r not properly in loop&quot;,</span>
<span class="gi">+            &quot;not-in-loop&quot;,</span>
<span class="gi">+            &quot;Used when break or continue keywords are used outside a loop.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0104&quot;: (</span>
<span class="gi">+            &quot;Return outside function&quot;,</span>
<span class="gi">+            &quot;return-outside-function&quot;,</span>
<span class="gi">+            &#39;Used when a &quot;return&quot; statement is found outside a function or method.&#39;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0105&quot;: (</span>
<span class="gi">+            &quot;Yield outside function&quot;,</span>
<span class="gi">+            &quot;yield-outside-function&quot;,</span>
<span class="gi">+            &#39;Used when a &quot;yield&quot; statement is found outside a function or method.&#39;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0106&quot;: (</span>
<span class="gi">+            &quot;Return with argument inside generator&quot;,</span>
<span class="gi">+            &quot;return-arg-in-generator&quot;,</span>
<span class="gi">+            &#39;Used when a &quot;return&quot; statement with an argument is found &#39;</span>
<span class="gi">+            &#39;in a generator function or method (e.g. with some &quot;yield&quot; statements).&#39;,</span>
<span class="gi">+            {&quot;maxversion&quot;: (3, 3)},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0107&quot;: (</span>
<span class="gi">+            &quot;Use of the non-existent %s operator&quot;,</span>
<span class="gi">+            &quot;nonexistent-operator&quot;,</span>
<span class="gi">+            &quot;Used when you attempt to use the C-style pre-increment or &quot;</span>
<span class="gi">+            &quot;pre-decrement operator -- and ++, which doesn&#39;t exist in Python.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0108&quot;: (</span>
<span class="gi">+            &quot;Duplicate argument name %s in function definition&quot;,</span>
<span class="gi">+            &quot;duplicate-argument-name&quot;,</span>
<span class="gi">+            &quot;Duplicate argument names in function definitions are syntax errors.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0110&quot;: (</span>
<span class="gi">+            &quot;Abstract class %r with abstract methods instantiated&quot;,</span>
<span class="gi">+            &quot;abstract-class-instantiated&quot;,</span>
<span class="gi">+            &quot;Used when an abstract class with `abc.ABCMeta` as metaclass &quot;</span>
<span class="gi">+            &quot;has abstract methods and is instantiated.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0120&quot;: (</span>
<span class="gi">+            &quot;Else clause on loop without a break statement, remove the else and&quot;</span>
<span class="gi">+            &quot; de-indent all the code inside it&quot;,</span>
<span class="gi">+            &quot;useless-else-on-loop&quot;,</span>
<span class="gi">+            &quot;Loops should only have an else clause if they can exit early &quot;</span>
<span class="gi">+            &quot;with a break statement, otherwise the statements under else &quot;</span>
<span class="gi">+            &quot;should be on the same scope as the loop itself.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0112&quot;: (</span>
<span class="gi">+            &quot;More than one starred expression in assignment&quot;,</span>
<span class="gi">+            &quot;too-many-star-expressions&quot;,</span>
<span class="gi">+            &quot;Emitted when there are more than one starred &quot;</span>
<span class="gi">+            &quot;expressions (`*x`) in an assignment. This is a SyntaxError.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0113&quot;: (</span>
<span class="gi">+            &quot;Starred assignment target must be in a list or tuple&quot;,</span>
<span class="gi">+            &quot;invalid-star-assignment-target&quot;,</span>
<span class="gi">+            &quot;Emitted when a star expression is used as a starred assignment target.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0114&quot;: (</span>
<span class="gi">+            &quot;Can use starred expression only in assignment target&quot;,</span>
<span class="gi">+            &quot;star-needs-assignment-target&quot;,</span>
<span class="gi">+            &quot;Emitted when a star expression is not used in an assignment target.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0115&quot;: (</span>
<span class="gi">+            &quot;Name %r is nonlocal and global&quot;,</span>
<span class="gi">+            &quot;nonlocal-and-global&quot;,</span>
<span class="gi">+            &quot;Emitted when a name is both nonlocal and global.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0116&quot;: (</span>
<span class="gi">+            &quot;&#39;continue&#39; not supported inside &#39;finally&#39; clause&quot;,</span>
<span class="gi">+            &quot;continue-in-finally&quot;,</span>
<span class="gi">+            &quot;Emitted when the `continue` keyword is found &quot;</span>
<span class="gi">+            &quot;inside a finally clause, which is a SyntaxError.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0117&quot;: (</span>
<span class="gi">+            &quot;nonlocal name %s found without binding&quot;,</span>
<span class="gi">+            &quot;nonlocal-without-binding&quot;,</span>
<span class="gi">+            &quot;Emitted when a nonlocal variable does not have an attached &quot;</span>
<span class="gi">+            &quot;name somewhere in the parent scopes&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0118&quot;: (</span>
<span class="gi">+            &quot;Name %r is used prior to global declaration&quot;,</span>
<span class="gi">+            &quot;used-prior-global-declaration&quot;,</span>
<span class="gi">+            &quot;Emitted when a name is used prior a global declaration, &quot;</span>
<span class="gi">+            &quot;which results in an error since Python 3.6.&quot;,</span>
<span class="gi">+            {&quot;minversion&quot;: (3, 6)},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        py_version = self.linter.config.py_version</span>
<span class="gi">+        self._py38_plus = py_version &gt;= (3, 8)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;function-redefined&quot;)</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        self._check_redefinition(&quot;class&quot;, node)</span>
<span class="gi">+</span>
<span class="gi">+    def _too_many_starred_for_tuple(self, assign_tuple: nodes.Tuple) -&gt; bool:</span>
<span class="gi">+        starred_count = 0</span>
<span class="gi">+        for elem in assign_tuple.itered():</span>
<span class="gi">+            if isinstance(elem, nodes.Tuple):</span>
<span class="gi">+                return self._too_many_starred_for_tuple(elem)</span>
<span class="gi">+            if isinstance(elem, nodes.Starred):</span>
<span class="gi">+                starred_count += 1</span>
<span class="gi">+        return starred_count &gt; 1</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;too-many-star-expressions&quot;, &quot;invalid-star-assignment-target&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        # Check *a, *b = ...</span>
<span class="gi">+        assign_target = node.targets[0]</span>
<span class="gi">+        # Check *a = b</span>
<span class="gi">+        if isinstance(node.targets[0], nodes.Starred):</span>
<span class="gi">+            self.add_message(&quot;invalid-star-assignment-target&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(assign_target, nodes.Tuple):</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._too_many_starred_for_tuple(assign_target):</span>
<span class="gi">+            self.add_message(&quot;too-many-star-expressions&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;star-needs-assignment-target&quot;)</span>
<span class="gi">+    def visit_starred(self, node: nodes.Starred) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that a Starred expression is used in an assignment target.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.parent, nodes.Call):</span>
<span class="gi">+            # f(*args) is converted to Call(args=[Starred]), so ignore</span>
<span class="gi">+            # them for this check.</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node.parent, (nodes.List, nodes.Tuple, nodes.Set, nodes.Dict)):</span>
<span class="gi">+            # PEP 448 unpacking.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        stmt = node.statement()</span>
<span class="gi">+        if not isinstance(stmt, nodes.Assign):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if stmt.value is node or stmt.value.parent_of(node):</span>
<span class="gi">+            self.add_message(&quot;star-needs-assignment-target&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;init-is-generator&quot;,</span>
<span class="gi">+        &quot;return-in-init&quot;,</span>
<span class="gi">+        &quot;function-redefined&quot;,</span>
<span class="gi">+        &quot;return-arg-in-generator&quot;,</span>
<span class="gi">+        &quot;duplicate-argument-name&quot;,</span>
<span class="gi">+        &quot;nonlocal-and-global&quot;,</span>
<span class="gi">+        &quot;used-prior-global-declaration&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        self._check_nonlocal_and_global(node)</span>
<span class="gi">+        self._check_name_used_prior_global(node)</span>
<span class="gi">+        if not redefined_by_decorator(</span>
<span class="gi">+            node</span>
<span class="gi">+        ) and not utils.is_registered_in_singledispatch_function(node):</span>
<span class="gi">+            self._check_redefinition(node.is_method() and &quot;method&quot; or &quot;function&quot;, node)</span>
<span class="gi">+        # checks for max returns, branch, return in __init__</span>
<span class="gi">+        returns = node.nodes_of_class(</span>
<span class="gi">+            nodes.Return, skip_klass=(nodes.FunctionDef, nodes.ClassDef)</span>
<span class="gi">+        )</span>
<span class="gi">+        if node.is_method() and node.name == &quot;__init__&quot;:</span>
<span class="gi">+            if node.is_generator():</span>
<span class="gi">+                self.add_message(&quot;init-is-generator&quot;, node=node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                values = [r.value for r in returns]</span>
<span class="gi">+                # Are we returning anything but None from constructors</span>
<span class="gi">+                if any(v for v in values if not utils.is_none(v)):</span>
<span class="gi">+                    self.add_message(&quot;return-in-init&quot;, node=node)</span>
<span class="gi">+        # Check for duplicate names by clustering args with same name for detailed report</span>
<span class="gi">+        arg_clusters = {}</span>
<span class="gi">+        arguments: Iterator[Any] = filter(None, [node.args.args, node.args.kwonlyargs])</span>
<span class="gi">+        for arg in itertools.chain.from_iterable(arguments):</span>
<span class="gi">+            if arg.name in arg_clusters:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;duplicate-argument-name&quot;,</span>
<span class="gi">+                    node=arg,</span>
<span class="gi">+                    args=(arg.name,),</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                arg_clusters[arg.name] = arg</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    def _check_nonlocal_and_global(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    def _check_name_used_prior_global(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        scope_globals = {</span>
<span class="gi">+            name: child</span>
<span class="gi">+            for child in node.nodes_of_class(nodes.Global)</span>
<span class="gi">+            for name in child.names</span>
<span class="gi">+            if child.scope() is node</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if not scope_globals:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for node_name in node.nodes_of_class(nodes.Name):</span>
<span class="gi">+            if node_name.scope() is not node:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            name = node_name.name</span>
<span class="gi">+            corresponding_global = scope_globals.get(name)</span>
<span class="gi">+            if not corresponding_global:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            global_lineno = corresponding_global.fromlineno</span>
<span class="gi">+            if global_lineno and global_lineno &gt; node_name.fromlineno:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;used-prior-global-declaration&quot;, node=node_name, args=(name,)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_nonlocal_and_global(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that a name is both nonlocal and global.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;nonexistent-operator&#39;)</span>
<span class="gd">-    def visit_unaryop(self, node: nodes.UnaryOp) -&gt;None:</span>
<span class="gi">+        def same_scope(current: nodes.Global | nodes.Nonlocal) -&gt; bool:</span>
<span class="gi">+            return current.scope() is node</span>
<span class="gi">+</span>
<span class="gi">+        from_iter = itertools.chain.from_iterable</span>
<span class="gi">+        nonlocals = set(</span>
<span class="gi">+            from_iter(</span>
<span class="gi">+                child.names</span>
<span class="gi">+                for child in node.nodes_of_class(nodes.Nonlocal)</span>
<span class="gi">+                if same_scope(child)</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if not nonlocals:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        global_vars = set(</span>
<span class="gi">+            from_iter(</span>
<span class="gi">+                child.names</span>
<span class="gi">+                for child in node.nodes_of_class(nodes.Global)</span>
<span class="gi">+                if same_scope(child)</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        for name in nonlocals.intersection(global_vars):</span>
<span class="gi">+            self.add_message(&quot;nonlocal-and-global&quot;, args=(name,), node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;return-outside-function&quot;)</span>
<span class="gi">+    def visit_return(self, node: nodes.Return) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.frame(), nodes.FunctionDef):</span>
<span class="gi">+            self.add_message(&quot;return-outside-function&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;yield-outside-function&quot;)</span>
<span class="gi">+    def visit_yield(self, node: nodes.Yield) -&gt; None:</span>
<span class="gi">+        self._check_yield_outside_func(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;yield-outside-function&quot;)</span>
<span class="gi">+    def visit_yieldfrom(self, node: nodes.YieldFrom) -&gt; None:</span>
<span class="gi">+        self._check_yield_outside_func(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;not-in-loop&quot;, &quot;continue-in-finally&quot;)</span>
<span class="gi">+    def visit_continue(self, node: nodes.Continue) -&gt; None:</span>
<span class="gi">+        self._check_in_loop(node, &quot;continue&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;not-in-loop&quot;)</span>
<span class="gi">+    def visit_break(self, node: nodes.Break) -&gt; None:</span>
<span class="gi">+        self._check_in_loop(node, &quot;break&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;useless-else-on-loop&quot;)</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        self._check_else_on_loop(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;useless-else-on-loop&quot;)</span>
<span class="gi">+    def visit_while(self, node: nodes.While) -&gt; None:</span>
<span class="gi">+        self._check_else_on_loop(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;nonexistent-operator&quot;)</span>
<span class="gi">+    def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check use of the non-existent ++ and -- operators.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            (node.op in &quot;+-&quot;)</span>
<span class="gi">+            and isinstance(node.operand, nodes.UnaryOp)</span>
<span class="gi">+            and (node.operand.op == node.op)</span>
<span class="gi">+            and (node.col_offset + 1 == node.operand.col_offset)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;nonexistent-operator&quot;, node=node, args=node.op * 2)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_nonlocal_without_binding(self, node: nodes.Nonlocal, name: str) -&gt; None:</span>
<span class="gi">+        current_scope = node.scope()</span>
<span class="gi">+        while current_scope.parent is not None:</span>
<span class="gi">+            if not isinstance(current_scope, (nodes.ClassDef, nodes.FunctionDef)):</span>
<span class="gi">+                self.add_message(&quot;nonlocal-without-binding&quot;, args=(name,), node=node)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Search for `name` in the parent scope if:</span>
<span class="gi">+            #  `current_scope` is the same scope in which the `nonlocal` name is declared</span>
<span class="gi">+            #  or `name` is not in `current_scope.locals`.</span>
<span class="gi">+            if current_scope is node.scope() or name not in current_scope.locals:</span>
<span class="gi">+                current_scope = current_scope.parent.scope()</span>
<span class="gi">+                continue</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;abstract-class-instantiated&#39;)</span>
<span class="gd">-    def visit_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+            # Okay, found it.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(current_scope, nodes.FunctionDef):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;nonlocal-without-binding&quot;, args=(name,), node=node, confidence=HIGH</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;nonlocal-without-binding&quot;)</span>
<span class="gi">+    def visit_nonlocal(self, node: nodes.Nonlocal) -&gt; None:</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            self._check_nonlocal_without_binding(node, name)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;abstract-class-instantiated&quot;)</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check instantiating abstract class with
<span class="w"> </span>        abc.ABCMeta as metaclass.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for inferred in infer_all(node.func):</span>
<span class="gi">+            self._check_inferred_class_is_abstract(inferred, node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_inferred_class_is_abstract(</span>
<span class="gi">+        self, inferred: InferenceResult, node: nodes.Call</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if not isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        klass = utils.node_frame_class(node)</span>
<span class="gi">+        if klass is inferred:</span>
<span class="gi">+            # Don&#39;t emit the warning if the class is instantiated</span>
<span class="gi">+            # in its own body or if the call is not an instance</span>
<span class="gi">+            # creation. If the class is instantiated into its own</span>
<span class="gi">+            # body, we&#39;re expecting that it knows what it is doing.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # __init__ was called</span>
<span class="gi">+        abstract_methods = _has_abstract_methods(inferred)</span>
<span class="gi">+</span>
<span class="gi">+        if not abstract_methods:</span>
<span class="gi">+            return</span>

<span class="gd">-    def _check_else_on_loop(self, node: (nodes.For | nodes.While)) -&gt;None:</span>
<span class="gi">+        metaclass = inferred.metaclass()</span>
<span class="gi">+</span>
<span class="gi">+        if metaclass is None:</span>
<span class="gi">+            # Python 3.4 has `abc.ABC`, which won&#39;t be detected</span>
<span class="gi">+            # by ClassNode.metaclass()</span>
<span class="gi">+            for ancestor in inferred.ancestors():</span>
<span class="gi">+                if ancestor.qname() == &quot;abc.ABC&quot;:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;abstract-class-instantiated&quot;, args=(inferred.name,), node=node</span>
<span class="gi">+                    )</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if metaclass.qname() in ABC_METACLASSES:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;abstract-class-instantiated&quot;, args=(inferred.name,), node=node</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_yield_outside_func(self, node: nodes.Yield) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.frame(), (nodes.FunctionDef, nodes.Lambda)):</span>
<span class="gi">+            self.add_message(&quot;yield-outside-function&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_else_on_loop(self, node: nodes.For | nodes.While) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that any loop with an else clause has a break statement.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.orelse and not _loop_exits_early(node):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;useless-else-on-loop&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                # This is not optimal, but the line previous</span>
<span class="gi">+                # to the first statement in the else clause</span>
<span class="gi">+                # will usually be the one that contains the else:.</span>
<span class="gi">+                line=node.orelse[0].lineno - 1,</span>
<span class="gi">+            )</span>

<span class="gd">-    def _check_in_loop(self, node: (nodes.Continue | nodes.Break),</span>
<span class="gd">-        node_name: str) -&gt;None:</span>
<span class="gi">+    def _check_in_loop(</span>
<span class="gi">+        self, node: nodes.Continue | nodes.Break, node_name: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that a node is inside a for or while loop.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for parent in node.node_ancestors():</span>
<span class="gi">+            if isinstance(parent, (nodes.For, nodes.While)):</span>
<span class="gi">+                if node not in parent.orelse:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(parent, (nodes.ClassDef, nodes.FunctionDef)):</span>
<span class="gi">+                break</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(parent, nodes.Try)</span>
<span class="gi">+                and node in parent.finalbody</span>
<span class="gi">+                and isinstance(node, nodes.Continue)</span>
<span class="gi">+                and not self._py38_plus</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;continue-in-finally&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;not-in-loop&quot;, node=node, args=node_name)</span>

<span class="gd">-    def _check_redefinition(self, redeftype: str, node: (nodes.Call | nodes</span>
<span class="gd">-        .FunctionDef)) -&gt;None:</span>
<span class="gi">+    def _check_redefinition(</span>
<span class="gi">+        self, redeftype: str, node: nodes.Call | nodes.FunctionDef</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for redefinition of a function / method / class name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parent_frame = node.parent.frame()</span>
<span class="gi">+</span>
<span class="gi">+        # Ignore function stubs created for type information</span>
<span class="gi">+        redefinitions = [</span>
<span class="gi">+            i</span>
<span class="gi">+            for i in parent_frame.locals[node.name]</span>
<span class="gi">+            if not (isinstance(i.parent, nodes.AnnAssign) and i.parent.simple)</span>
<span class="gi">+        ]</span>
<span class="gi">+        defined_self = next(</span>
<span class="gi">+            (local for local in redefinitions if not utils.is_overload_stub(local)),</span>
<span class="gi">+            node,</span>
<span class="gi">+        )</span>
<span class="gi">+        if defined_self is not node and not astroid.are_exclusive(node, defined_self):</span>
<span class="gi">+            # Additional checks for methods which are not considered</span>
<span class="gi">+            # redefined, since they are already part of the base API.</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(parent_frame, nodes.ClassDef)</span>
<span class="gi">+                and node.name in REDEFINABLE_METHODS</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Skip typing.overload() functions.</span>
<span class="gi">+            if utils.is_overload_stub(node):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Exempt functions redefined on a condition.</span>
<span class="gi">+            if isinstance(node.parent, nodes.If):</span>
<span class="gi">+                # Exempt &quot;if not &lt;func&gt;&quot; cases</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(node.parent.test, nodes.UnaryOp)</span>
<span class="gi">+                    and node.parent.test.op == &quot;not&quot;</span>
<span class="gi">+                    and isinstance(node.parent.test.operand, nodes.Name)</span>
<span class="gi">+                    and node.parent.test.operand.name == node.name</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                # Exempt &quot;if &lt;func&gt; is not None&quot; cases</span>
<span class="gi">+                # pylint: disable=too-many-boolean-expressions</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(node.parent.test, nodes.Compare)</span>
<span class="gi">+                    and isinstance(node.parent.test.left, nodes.Name)</span>
<span class="gi">+                    and node.parent.test.left.name == node.name</span>
<span class="gi">+                    and node.parent.test.ops[0][0] == &quot;is&quot;</span>
<span class="gi">+                    and isinstance(node.parent.test.ops[0][1], nodes.Const)</span>
<span class="gi">+                    and node.parent.test.ops[0][1].value is None</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            # Check if we have forward references for this node.</span>
<span class="gi">+            try:</span>
<span class="gi">+                redefinition_index = redefinitions.index(node)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                for redefinition in redefinitions[:redefinition_index]:</span>
<span class="gi">+                    inferred = utils.safe_infer(redefinition)</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        inferred</span>
<span class="gi">+                        and isinstance(inferred, astroid.Instance)</span>
<span class="gi">+                        and inferred.qname() == TYPING_FORWARD_REF_QNAME</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+            dummy_variables_rgx = self.linter.config.dummy_variables_rgx</span>
<span class="gi">+            if dummy_variables_rgx and dummy_variables_rgx.match(node.name):</span>
<span class="gi">+                return</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;function-redefined&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(redeftype, defined_self.fromlineno),</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/pylint/checkers/base/comparison_checker.py b/pylint/checkers/base/comparison_checker.py</span>
<span class="gh">index 5eefa2387..6fb053e2e 100644</span>
<span class="gd">--- a/pylint/checkers/base/comparison_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/comparison_checker.py</span>
<span class="gu">@@ -1,18 +1,25 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Comparison checker from the basic checker.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.base.basic_checker import _BasicChecker
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gd">-LITERAL_NODE_TYPES = nodes.Const, nodes.Dict, nodes.List, nodes.Set</span>
<span class="gd">-COMPARISON_OPERATORS = frozenset((&#39;==&#39;, &#39;!=&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;))</span>
<span class="gd">-TYPECHECK_COMPARISON_OPERATORS = frozenset((&#39;is&#39;, &#39;is not&#39;, &#39;==&#39;, &#39;!=&#39;))</span>
<span class="gd">-TYPE_QNAME = &#39;builtins.type&#39;</span>
<span class="gi">+</span>
<span class="gi">+LITERAL_NODE_TYPES = (nodes.Const, nodes.Dict, nodes.List, nodes.Set)</span>
<span class="gi">+COMPARISON_OPERATORS = frozenset((&quot;==&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;))</span>
<span class="gi">+TYPECHECK_COMPARISON_OPERATORS = frozenset((&quot;is&quot;, &quot;is not&quot;, &quot;==&quot;, &quot;!=&quot;))</span>
<span class="gi">+TYPE_QNAME = &quot;builtins.type&quot;</span>


<span class="gd">-def _is_one_arg_pos_call(call: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def _is_one_arg_pos_call(call: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is this a call with exactly 1 positional argument ?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(call, nodes.Call) and len(call.args) == 1 and not call.keywords</span>


<span class="w"> </span>class ComparisonChecker(_BasicChecker):
<span class="gu">@@ -23,41 +30,193 @@ class ComparisonChecker(_BasicChecker):</span>
<span class="w"> </span>      &#39;&lt;=&#39;, &#39;&gt;&#39; or &#39;&gt;=&#39;, and right can be a variable, an attribute, a method or
<span class="w"> </span>      a function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    msgs = {&#39;C0121&#39;: (&#39;Comparison %s should be %s&#39;, &#39;singleton-comparison&#39;,</span>
<span class="gd">-        &#39;Used when an expression is compared to singleton values like True, False or None.&#39;</span>
<span class="gd">-        ), &#39;C0123&#39;: (&#39;Use isinstance() rather than type() for a typecheck.&#39;,</span>
<span class="gd">-        &#39;unidiomatic-typecheck&#39;,</span>
<span class="gd">-        &#39;The idiomatic way to perform an explicit typecheck in Python is to use isinstance(x, Y) rather than type(x) == Y, type(x) is Y. Though there are unusual situations where these give different results.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;W0154&#39;, &#39;old-unidiomatic-typecheck&#39;)]}), &#39;R0123&#39;:</span>
<span class="gd">-        (</span>
<span class="gd">-        &quot;In &#39;%s&#39;, use &#39;%s&#39; when comparing constant literals not &#39;%s&#39; (&#39;%s&#39;)&quot;,</span>
<span class="gd">-        &#39;literal-comparison&#39;,</span>
<span class="gd">-        &#39;Used when comparing an object to a literal, which is usually what you do not want to do, since you can compare to a different literal than what was expected altogether.&#39;</span>
<span class="gd">-        ), &#39;R0124&#39;: (&#39;Redundant comparison - %s&#39;, &#39;comparison-with-itself&#39;,</span>
<span class="gd">-        &#39;Used when something is compared against itself.&#39;), &#39;R0133&#39;: (</span>
<span class="gd">-        &quot;Comparison between constants: &#39;%s %s %s&#39; has a constant value&quot;,</span>
<span class="gd">-        &#39;comparison-of-constants&#39;,</span>
<span class="gd">-        &quot;When two literals are compared with each other the result is a constant. Using the constant directly is both easier to read and more performant. Initializing &#39;True&#39; and &#39;False&#39; this way is not required since Python 2.3.&quot;</span>
<span class="gd">-        ), &#39;W0143&#39;: (</span>
<span class="gd">-        &#39;Comparing against a callable, did you omit the parenthesis?&#39;,</span>
<span class="gd">-        &#39;comparison-with-callable&#39;,</span>
<span class="gd">-        &#39;This message is emitted when pylint detects that a comparison with a callable was made, which might suggest that some parenthesis were omitted, resulting in potential unwanted behaviour.&#39;</span>
<span class="gd">-        ), &#39;W0177&#39;: (&#39;Comparison %s should be %s&#39;, &#39;nan-comparison&#39;,</span>
<span class="gd">-        &quot;Used when an expression is compared to NaN values like numpy.NaN and float(&#39;nan&#39;).&quot;</span>
<span class="gd">-        )}</span>
<span class="gd">-</span>
<span class="gd">-    def _check_singleton_comparison(self, left_value: nodes.NodeNG,</span>
<span class="gd">-        right_value: nodes.NodeNG, root_node: nodes.Compare,</span>
<span class="gd">-        checking_for_absence: bool=False) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C0121&quot;: (</span>
<span class="gi">+            &quot;Comparison %s should be %s&quot;,</span>
<span class="gi">+            &quot;singleton-comparison&quot;,</span>
<span class="gi">+            &quot;Used when an expression is compared to singleton &quot;</span>
<span class="gi">+            &quot;values like True, False or None.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0123&quot;: (</span>
<span class="gi">+            &quot;Use isinstance() rather than type() for a typecheck.&quot;,</span>
<span class="gi">+            &quot;unidiomatic-typecheck&quot;,</span>
<span class="gi">+            &quot;The idiomatic way to perform an explicit typecheck in &quot;</span>
<span class="gi">+            &quot;Python is to use isinstance(x, Y) rather than &quot;</span>
<span class="gi">+            &quot;type(x) == Y, type(x) is Y. Though there are unusual &quot;</span>
<span class="gi">+            &quot;situations where these give different results.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W0154&quot;, &quot;old-unidiomatic-typecheck&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0123&quot;: (</span>
<span class="gi">+            &quot;In &#39;%s&#39;, use &#39;%s&#39; when comparing constant literals not &#39;%s&#39; (&#39;%s&#39;)&quot;,</span>
<span class="gi">+            &quot;literal-comparison&quot;,</span>
<span class="gi">+            &quot;Used when comparing an object to a literal, which is usually &quot;</span>
<span class="gi">+            &quot;what you do not want to do, since you can compare to a different &quot;</span>
<span class="gi">+            &quot;literal than what was expected altogether.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0124&quot;: (</span>
<span class="gi">+            &quot;Redundant comparison - %s&quot;,</span>
<span class="gi">+            &quot;comparison-with-itself&quot;,</span>
<span class="gi">+            &quot;Used when something is compared against itself.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0133&quot;: (</span>
<span class="gi">+            &quot;Comparison between constants: &#39;%s %s %s&#39; has a constant value&quot;,</span>
<span class="gi">+            &quot;comparison-of-constants&quot;,</span>
<span class="gi">+            &quot;When two literals are compared with each other the result is a constant. &quot;</span>
<span class="gi">+            &quot;Using the constant directly is both easier to read and more performant. &quot;</span>
<span class="gi">+            &quot;Initializing &#39;True&#39; and &#39;False&#39; this way is not required since Python 2.3.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0143&quot;: (</span>
<span class="gi">+            &quot;Comparing against a callable, did you omit the parenthesis?&quot;,</span>
<span class="gi">+            &quot;comparison-with-callable&quot;,</span>
<span class="gi">+            &quot;This message is emitted when pylint detects that a comparison with a &quot;</span>
<span class="gi">+            &quot;callable was made, which might suggest that some parenthesis were omitted, &quot;</span>
<span class="gi">+            &quot;resulting in potential unwanted behaviour.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W0177&quot;: (</span>
<span class="gi">+            &quot;Comparison %s should be %s&quot;,</span>
<span class="gi">+            &quot;nan-comparison&quot;,</span>
<span class="gi">+            &quot;Used when an expression is compared to NaN &quot;</span>
<span class="gi">+            &quot;values like numpy.NaN and float(&#39;nan&#39;).&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def _check_singleton_comparison(</span>
<span class="gi">+        self,</span>
<span class="gi">+        left_value: nodes.NodeNG,</span>
<span class="gi">+        right_value: nodes.NodeNG,</span>
<span class="gi">+        root_node: nodes.Compare,</span>
<span class="gi">+        checking_for_absence: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if == or != is being used to compare a singleton value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if utils.is_singleton_const(left_value):</span>
<span class="gi">+            singleton, other_value = left_value.value, right_value</span>
<span class="gi">+        elif utils.is_singleton_const(right_value):</span>
<span class="gi">+            singleton, other_value = right_value.value, left_value</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        singleton_comparison_example = {False: &quot;&#39;{} is {}&#39;&quot;, True: &quot;&#39;{} is not {}&#39;&quot;}</span>
<span class="gi">+</span>
<span class="gi">+        # True/False singletons have a special-cased message in case the user is</span>
<span class="gi">+        # mistakenly using == or != to check for truthiness</span>
<span class="gi">+        if singleton in {True, False}:</span>
<span class="gi">+            suggestion_template = (</span>
<span class="gi">+                &quot;{} if checking for the singleton value {}, or {} if testing for {}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            truthiness_example = {False: &quot;not {}&quot;, True: &quot;{}&quot;}</span>
<span class="gi">+            truthiness_phrase = {True: &quot;truthiness&quot;, False: &quot;falsiness&quot;}</span>
<span class="gi">+</span>
<span class="gi">+            # Looks for comparisons like x == True or x != False</span>
<span class="gi">+            checking_truthiness = singleton is not checking_for_absence</span>
<span class="gi">+</span>
<span class="gi">+            suggestion = suggestion_template.format(</span>
<span class="gi">+                singleton_comparison_example[checking_for_absence].format(</span>
<span class="gi">+                    left_value.as_string(), right_value.as_string()</span>
<span class="gi">+                ),</span>
<span class="gi">+                singleton,</span>
<span class="gi">+                (</span>
<span class="gi">+                    &quot;&#39;bool({})&#39;&quot;</span>
<span class="gi">+                    if not utils.is_test_condition(root_node) and checking_truthiness</span>
<span class="gi">+                    else &quot;&#39;{}&#39;&quot;</span>
<span class="gi">+                ).format(</span>
<span class="gi">+                    truthiness_example[checking_truthiness].format(</span>
<span class="gi">+                        other_value.as_string()</span>
<span class="gi">+                    )</span>
<span class="gi">+                ),</span>
<span class="gi">+                truthiness_phrase[checking_truthiness],</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            suggestion = singleton_comparison_example[checking_for_absence].format(</span>
<span class="gi">+                left_value.as_string(), right_value.as_string()</span>
<span class="gi">+            )</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;singleton-comparison&quot;,</span>
<span class="gi">+            node=root_node,</span>
<span class="gi">+            args=(f&quot;&#39;{root_node.as_string()}&#39;&quot;, suggestion),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_nan_comparison(</span>
<span class="gi">+        self,</span>
<span class="gi">+        left_value: nodes.NodeNG,</span>
<span class="gi">+        right_value: nodes.NodeNG,</span>
<span class="gi">+        root_node: nodes.Compare,</span>
<span class="gi">+        checking_for_absence: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        def _is_float_nan(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if isinstance(node, nodes.Call) and len(node.args) == 1:</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        node.args[0].value.lower() == &quot;nan&quot;</span>
<span class="gi">+                        and node.inferred()[0].pytype() == &quot;builtins.float&quot;</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return True</span>
<span class="gi">+                return False</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        def _is_numpy_nan(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+            if isinstance(node, nodes.Attribute) and node.attrname == &quot;NaN&quot;:</span>
<span class="gi">+                if isinstance(node.expr, nodes.Name):</span>
<span class="gi">+                    return node.expr.name in {&quot;numpy&quot;, &quot;nmp&quot;, &quot;np&quot;}</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        def _is_nan(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+            return _is_float_nan(node) or _is_numpy_nan(node)</span>
<span class="gi">+</span>
<span class="gi">+        nan_left = _is_nan(left_value)</span>
<span class="gi">+        if not nan_left and not _is_nan(right_value):</span>
<span class="gi">+            return</span>

<span class="gd">-    def _check_literal_comparison(self, literal: nodes.NodeNG, node: nodes.</span>
<span class="gd">-        Compare) -&gt;None:</span>
<span class="gi">+        absence_text = &quot;&quot;</span>
<span class="gi">+        if checking_for_absence:</span>
<span class="gi">+            absence_text = &quot;not &quot;</span>
<span class="gi">+        if nan_left:</span>
<span class="gi">+            suggestion = f&quot;&#39;{absence_text}math.isnan({right_value.as_string()})&#39;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            suggestion = f&quot;&#39;{absence_text}math.isnan({left_value.as_string()})&#39;&quot;</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;nan-comparison&quot;,</span>
<span class="gi">+            node=root_node,</span>
<span class="gi">+            args=(f&quot;&#39;{root_node.as_string()}&#39;&quot;, suggestion),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_literal_comparison(</span>
<span class="gi">+        self, literal: nodes.NodeNG, node: nodes.Compare</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if we compare to a literal, which is usually what we do not want to do.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        is_other_literal = isinstance(literal, (nodes.List, nodes.Dict, nodes.Set))</span>
<span class="gi">+        is_const = False</span>
<span class="gi">+        if isinstance(literal, nodes.Const):</span>
<span class="gi">+            if isinstance(literal.value, bool) or literal.value is None:</span>
<span class="gi">+                # Not interested in these values.</span>
<span class="gi">+                return</span>
<span class="gi">+            is_const = isinstance(literal.value, (bytes, str, int, float))</span>
<span class="gi">+</span>
<span class="gi">+        if is_const or is_other_literal:</span>
<span class="gi">+            incorrect_node_str = node.as_string()</span>
<span class="gi">+            if &quot;is not&quot; in incorrect_node_str:</span>
<span class="gi">+                equal_or_not_equal = &quot;!=&quot;</span>
<span class="gi">+                is_or_is_not = &quot;is not&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                equal_or_not_equal = &quot;==&quot;</span>
<span class="gi">+                is_or_is_not = &quot;is&quot;</span>
<span class="gi">+            fixed_node_str = incorrect_node_str.replace(</span>
<span class="gi">+                is_or_is_not, equal_or_not_equal</span>
<span class="gi">+            )</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;literal-comparison&quot;,</span>
<span class="gi">+                args=(</span>
<span class="gi">+                    incorrect_node_str,</span>
<span class="gi">+                    equal_or_not_equal,</span>
<span class="gi">+                    is_or_is_not,</span>
<span class="gi">+                    fixed_node_str,</span>
<span class="gi">+                ),</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>

<span class="gd">-    def _check_logical_tautology(self, node: nodes.Compare) -&gt;None:</span>
<span class="gi">+    def _check_logical_tautology(self, node: nodes.Compare) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if identifier is compared against itself.

<span class="w"> </span>        :param node: Compare node
<span class="gu">@@ -66,13 +225,129 @@ class ComparisonChecker(_BasicChecker):</span>
<span class="w"> </span>        if val == val:  # [comparison-with-itself]
<span class="w"> </span>            pass
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        left_operand = node.left</span>
<span class="gi">+        right_operand = node.ops[0][1]</span>
<span class="gi">+        operator = node.ops[0][0]</span>
<span class="gi">+        if isinstance(left_operand, nodes.Const) and isinstance(</span>
<span class="gi">+            right_operand, nodes.Const</span>
<span class="gi">+        ):</span>
<span class="gi">+            left_operand = left_operand.value</span>
<span class="gi">+            right_operand = right_operand.value</span>
<span class="gi">+        elif isinstance(left_operand, nodes.Name) and isinstance(</span>
<span class="gi">+            right_operand, nodes.Name</span>
<span class="gi">+        ):</span>
<span class="gi">+            left_operand = left_operand.name</span>
<span class="gi">+            right_operand = right_operand.name</span>

<span class="gd">-    def _check_constants_comparison(self, node: nodes.Compare) -&gt;None:</span>
<span class="gi">+        if left_operand == right_operand:</span>
<span class="gi">+            suggestion = f&quot;{left_operand} {operator} {right_operand}&quot;</span>
<span class="gi">+            self.add_message(&quot;comparison-with-itself&quot;, node=node, args=(suggestion,))</span>
<span class="gi">+</span>
<span class="gi">+    def _check_constants_comparison(self, node: nodes.Compare) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;When two constants are being compared it is always a logical tautology.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        left_operand = node.left</span>
<span class="gi">+        if not isinstance(left_operand, nodes.Const):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        right_operand = node.ops[0][1]</span>
<span class="gi">+        if not isinstance(right_operand, nodes.Const):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        operator = node.ops[0][0]</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;comparison-of-constants&quot;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=(left_operand.value, operator, right_operand.value),</span>
<span class="gi">+            confidence=HIGH,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_callable_comparison(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        operator = node.ops[0][0]</span>
<span class="gi">+        if operator not in COMPARISON_OPERATORS:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        bare_callables = (nodes.FunctionDef, astroid.BoundMethod)</span>
<span class="gi">+        left_operand, right_operand = node.left, node.ops[0][1]</span>
<span class="gi">+        # this message should be emitted only when there is comparison of bare callable</span>
<span class="gi">+        # with non bare callable.</span>
<span class="gi">+        number_of_bare_callables = 0</span>
<span class="gi">+        for operand in left_operand, right_operand:</span>
<span class="gi">+            inferred = utils.safe_infer(operand)</span>
<span class="gi">+            # Ignore callables that raise, as well as typing constants</span>
<span class="gi">+            # implemented as functions (that raise via their decorator)</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(inferred, bare_callables)</span>
<span class="gi">+                and &quot;typing._SpecialForm&quot; not in inferred.decoratornames()</span>
<span class="gi">+                and not any(isinstance(x, nodes.Raise) for x in inferred.body)</span>
<span class="gi">+            ):</span>
<span class="gi">+                number_of_bare_callables += 1</span>
<span class="gi">+        if number_of_bare_callables == 1:</span>
<span class="gi">+            self.add_message(&quot;comparison-with-callable&quot;, node=node)</span>

<span class="gd">-    def _check_type_x_is_y(self, node: nodes.Compare, left: nodes.NodeNG,</span>
<span class="gd">-        operator: str, right: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;singleton-comparison&quot;,</span>
<span class="gi">+        &quot;unidiomatic-typecheck&quot;,</span>
<span class="gi">+        &quot;literal-comparison&quot;,</span>
<span class="gi">+        &quot;comparison-with-itself&quot;,</span>
<span class="gi">+        &quot;comparison-of-constants&quot;,</span>
<span class="gi">+        &quot;comparison-with-callable&quot;,</span>
<span class="gi">+        &quot;nan-comparison&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_compare(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        self._check_callable_comparison(node)</span>
<span class="gi">+        self._check_logical_tautology(node)</span>
<span class="gi">+        self._check_unidiomatic_typecheck(node)</span>
<span class="gi">+        self._check_constants_comparison(node)</span>
<span class="gi">+        # NOTE: this checker only works with binary comparisons like &#39;x == 42&#39;</span>
<span class="gi">+        # but not &#39;x == y == 42&#39;</span>
<span class="gi">+        if len(node.ops) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        left = node.left</span>
<span class="gi">+        operator, right = node.ops[0]</span>
<span class="gi">+</span>
<span class="gi">+        if operator in {&quot;==&quot;, &quot;!=&quot;}:</span>
<span class="gi">+            self._check_singleton_comparison(</span>
<span class="gi">+                left, right, node, checking_for_absence=operator == &quot;!=&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if operator in {&quot;==&quot;, &quot;!=&quot;, &quot;is&quot;, &quot;is not&quot;}:</span>
<span class="gi">+            self._check_nan_comparison(</span>
<span class="gi">+                left, right, node, checking_for_absence=operator in {&quot;!=&quot;, &quot;is not&quot;}</span>
<span class="gi">+            )</span>
<span class="gi">+        if operator in {&quot;is&quot;, &quot;is not&quot;}:</span>
<span class="gi">+            self._check_literal_comparison(right, node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_unidiomatic_typecheck(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        operator, right = node.ops[0]</span>
<span class="gi">+        if operator in TYPECHECK_COMPARISON_OPERATORS:</span>
<span class="gi">+            left = node.left</span>
<span class="gi">+            if _is_one_arg_pos_call(left):</span>
<span class="gi">+                self._check_type_x_is_y(node, left, operator, right)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_type_x_is_y(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Compare,</span>
<span class="gi">+        left: nodes.NodeNG,</span>
<span class="gi">+        operator: str,</span>
<span class="gi">+        right: nodes.NodeNG,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for expressions like type(x) == Y.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        left_func = utils.safe_infer(left.func)</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(left_func, nodes.ClassDef) and left_func.qname() == TYPE_QNAME</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if operator in {&quot;is&quot;, &quot;is not&quot;} and _is_one_arg_pos_call(right):</span>
<span class="gi">+            right_func = utils.safe_infer(right.func)</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(right_func, nodes.ClassDef)</span>
<span class="gi">+                and right_func.qname() == TYPE_QNAME</span>
<span class="gi">+            ):</span>
<span class="gi">+                # type(x) == type(a)</span>
<span class="gi">+                right_arg = utils.safe_infer(right.args[0])</span>
<span class="gi">+                if not isinstance(right_arg, LITERAL_NODE_TYPES):</span>
<span class="gi">+                    # not e.g. type(x) == type([])</span>
<span class="gi">+                    return</span>
<span class="gi">+        self.add_message(&quot;unidiomatic-typecheck&quot;, node=node)</span>
<span class="gh">diff --git a/pylint/checkers/base/docstring_checker.py b/pylint/checkers/base/docstring_checker.py</span>
<span class="gh">index c691ef0c0..aecfd9b06 100644</span>
<span class="gd">--- a/pylint/checkers/base/docstring_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/docstring_checker.py</span>
<span class="gu">@@ -1,42 +1,208 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Docstring checker from the basic checker.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import Literal
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import interfaces
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.base.basic_checker import _BasicChecker
<span class="gd">-from pylint.checkers.utils import is_overload_stub, is_property_deleter, is_property_setter</span>
<span class="gd">-NO_REQUIRED_DOC_RGX = re.compile(&#39;^_&#39;)</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    is_overload_stub,</span>
<span class="gi">+    is_property_deleter,</span>
<span class="gi">+    is_property_setter,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# do not require a doc string on private/system methods</span>
<span class="gi">+NO_REQUIRED_DOC_RGX = re.compile(&quot;^_&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _infer_dunder_doc_attribute(</span>
<span class="gi">+    node: nodes.Module | nodes.ClassDef | nodes.FunctionDef,</span>
<span class="gi">+) -&gt; str | None:</span>
<span class="gi">+    # Try to see if we have a `__doc__` attribute.</span>
<span class="gi">+    try:</span>
<span class="gi">+        docstring = node[&quot;__doc__&quot;]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    docstring = utils.safe_infer(docstring)</span>
<span class="gi">+    if not docstring:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if not isinstance(docstring, nodes.Const):</span>
<span class="gi">+        return None</span>
<span class="gi">+    return str(docstring.value)</span>


<span class="w"> </span>class DocStringChecker(_BasicChecker):
<span class="gd">-    msgs = {&#39;C0112&#39;: (&#39;Empty %s docstring&#39;, &#39;empty-docstring&#39;,</span>
<span class="gd">-        &#39;Used when a module, function, class or method has an empty docstring (it would be too easy ;).&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;W0132&#39;, &#39;old-empty-docstring&#39;)]}), &#39;C0114&#39;: (</span>
<span class="gd">-        &#39;Missing module docstring&#39;, &#39;missing-module-docstring&#39;,</span>
<span class="gd">-        &#39;Used when a module has no docstring. Empty modules do not require a docstring.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;C0111&#39;, &#39;missing-docstring&#39;)]}), &#39;C0115&#39;: (</span>
<span class="gd">-        &#39;Missing class docstring&#39;, &#39;missing-class-docstring&#39;,</span>
<span class="gd">-        &#39;Used when a class has no docstring. Even an empty class must have a docstring.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;C0111&#39;, &#39;missing-docstring&#39;)]}), &#39;C0116&#39;: (</span>
<span class="gd">-        &#39;Missing function or method docstring&#39;,</span>
<span class="gd">-        &#39;missing-function-docstring&#39;,</span>
<span class="gd">-        &#39;Used when a function or method has no docstring. Some special methods like __init__ do not require a docstring.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;C0111&#39;, &#39;missing-docstring&#39;)]})}</span>
<span class="gd">-    options = (&#39;no-docstring-rgx&#39;, {&#39;default&#39;: NO_REQUIRED_DOC_RGX, &#39;type&#39;:</span>
<span class="gd">-        &#39;regexp&#39;, &#39;metavar&#39;: &#39;&lt;regexp&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Regular expression which should only match function or class names that do not require a docstring.&#39;</span>
<span class="gd">-        }), (&#39;docstring-min-length&#39;, {&#39;default&#39;: -1, &#39;type&#39;: &#39;int&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;int&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Minimum line length for functions/classes that require docstrings, shorter ones are exempt.&#39;</span>
<span class="gd">-        })</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C0112&quot;: (</span>
<span class="gi">+            &quot;Empty %s docstring&quot;,</span>
<span class="gi">+            &quot;empty-docstring&quot;,</span>
<span class="gi">+            &quot;Used when a module, function, class or method has an empty &quot;</span>
<span class="gi">+            &quot;docstring (it would be too easy ;).&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W0132&quot;, &quot;old-empty-docstring&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0114&quot;: (</span>
<span class="gi">+            &quot;Missing module docstring&quot;,</span>
<span class="gi">+            &quot;missing-module-docstring&quot;,</span>
<span class="gi">+            &quot;Used when a module has no docstring. &quot;</span>
<span class="gi">+            &quot;Empty modules do not require a docstring.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;C0111&quot;, &quot;missing-docstring&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0115&quot;: (</span>
<span class="gi">+            &quot;Missing class docstring&quot;,</span>
<span class="gi">+            &quot;missing-class-docstring&quot;,</span>
<span class="gi">+            &quot;Used when a class has no docstring. &quot;</span>
<span class="gi">+            &quot;Even an empty class must have a docstring.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;C0111&quot;, &quot;missing-docstring&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0116&quot;: (</span>
<span class="gi">+            &quot;Missing function or method docstring&quot;,</span>
<span class="gi">+            &quot;missing-function-docstring&quot;,</span>
<span class="gi">+            &quot;Used when a function or method has no docstring. &quot;</span>
<span class="gi">+            &quot;Some special methods like __init__ do not require a &quot;</span>
<span class="gi">+            &quot;docstring.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;C0111&quot;, &quot;missing-docstring&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;no-docstring-rgx&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: NO_REQUIRED_DOC_RGX,</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;regexp&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Regular expression which should only match &quot;</span>
<span class="gi">+                &quot;function or class names that do not require a &quot;</span>
<span class="gi">+                &quot;docstring.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;docstring-min-length&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: -1,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Minimum line length for functions/classes that&quot;</span>
<span class="gi">+                    &quot; require docstrings, shorter ones are exempt.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        self.linter.stats.reset_undocumented()</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;missing-module-docstring&quot;, &quot;empty-docstring&quot;)</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="gi">+        self._check_docstring(&quot;module&quot;, node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;missing-class-docstring&quot;, &quot;empty-docstring&quot;)</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        if self.linter.config.no_docstring_rgx.match(node.name) is None:</span>
<span class="gi">+            self._check_docstring(&quot;class&quot;, node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;missing-function-docstring&quot;, &quot;empty-docstring&quot;)</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        if self.linter.config.no_docstring_rgx.match(node.name) is None:</span>
<span class="gi">+            ftype = &quot;method&quot; if node.is_method() else &quot;function&quot;</span>
<span class="gi">+            if (</span>
<span class="gi">+                is_property_setter(node)</span>
<span class="gi">+                or is_property_deleter(node)</span>
<span class="gi">+                or is_overload_stub(node)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(node.parent.frame(), nodes.ClassDef):</span>
<span class="gi">+                overridden = False</span>
<span class="gi">+                confidence = (</span>
<span class="gi">+                    interfaces.INFERENCE</span>
<span class="gi">+                    if utils.has_known_bases(node.parent.frame())</span>
<span class="gi">+                    else interfaces.INFERENCE_FAILURE</span>
<span class="gi">+                )</span>
<span class="gi">+                # check if node is from a method overridden by its ancestor</span>
<span class="gi">+                for ancestor in node.parent.frame().ancestors():</span>
<span class="gi">+                    if ancestor.qname() == &quot;builtins.object&quot;:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if node.name in ancestor and isinstance(</span>
<span class="gi">+                        ancestor[node.name], nodes.FunctionDef</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        overridden = True</span>
<span class="gi">+                        break</span>
<span class="gi">+                self._check_docstring(</span>
<span class="gi">+                    ftype, node, report_missing=not overridden, confidence=confidence  # type: ignore[arg-type]</span>
<span class="gi">+                )</span>
<span class="gi">+            elif isinstance(node.parent.frame(), nodes.Module):</span>
<span class="gi">+                self._check_docstring(ftype, node)  # type: ignore[arg-type]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    def _check_docstring(self, node_type: Literal[&#39;class&#39;, &#39;function&#39;,</span>
<span class="gd">-        &#39;method&#39;, &#39;module&#39;], node: (nodes.Module | nodes.ClassDef | nodes.</span>
<span class="gd">-        FunctionDef), report_missing: bool=True, confidence: interfaces.</span>
<span class="gd">-        Confidence=interfaces.HIGH) -&gt;None:</span>
<span class="gi">+    def _check_docstring(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node_type: Literal[&quot;class&quot;, &quot;function&quot;, &quot;method&quot;, &quot;module&quot;],</span>
<span class="gi">+        node: nodes.Module | nodes.ClassDef | nodes.FunctionDef,</span>
<span class="gi">+        report_missing: bool = True,</span>
<span class="gi">+        confidence: interfaces.Confidence = interfaces.HIGH,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the node has a non-empty docstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        docstring = node.doc_node.value if node.doc_node else None</span>
<span class="gi">+        if docstring is None:</span>
<span class="gi">+            docstring = _infer_dunder_doc_attribute(node)</span>
<span class="gi">+</span>
<span class="gi">+        if docstring is None:</span>
<span class="gi">+            if not report_missing:</span>
<span class="gi">+                return</span>
<span class="gi">+            lines = utils.get_node_last_lineno(node) - node.lineno</span>
<span class="gi">+</span>
<span class="gi">+            if node_type == &quot;module&quot; and not lines:</span>
<span class="gi">+                # If the module does not have a body, there&#39;s no reason</span>
<span class="gi">+                # to require a docstring.</span>
<span class="gi">+                return</span>
<span class="gi">+            max_lines = self.linter.config.docstring_min_length</span>
<span class="gi">+</span>
<span class="gi">+            if node_type != &quot;module&quot; and max_lines &gt; -1 and lines &lt; max_lines:</span>
<span class="gi">+                return</span>
<span class="gi">+            if node_type == &quot;class&quot;:</span>
<span class="gi">+                self.linter.stats.undocumented[&quot;klass&quot;] += 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.linter.stats.undocumented[node_type] += 1</span>
<span class="gi">+            if (</span>
<span class="gi">+                node.body</span>
<span class="gi">+                and isinstance(node.body[0], nodes.Expr)</span>
<span class="gi">+                and isinstance(node.body[0].value, nodes.Call)</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Most likely a string with a format call. Let&#39;s see.</span>
<span class="gi">+                func = utils.safe_infer(node.body[0].value.func)</span>
<span class="gi">+                if isinstance(func, astroid.BoundMethod) and isinstance(</span>
<span class="gi">+                    func.bound, astroid.Instance</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Strings.</span>
<span class="gi">+                    if func.bound.name in {&quot;str&quot;, &quot;unicode&quot;, &quot;bytes&quot;}:</span>
<span class="gi">+                        return</span>
<span class="gi">+            if node_type == &quot;module&quot;:</span>
<span class="gi">+                message = &quot;missing-module-docstring&quot;</span>
<span class="gi">+            elif node_type == &quot;class&quot;:</span>
<span class="gi">+                message = &quot;missing-class-docstring&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                message = &quot;missing-function-docstring&quot;</span>
<span class="gi">+            self.add_message(message, node=node, confidence=confidence)</span>
<span class="gi">+        elif not docstring.strip():</span>
<span class="gi">+            if node_type == &quot;class&quot;:</span>
<span class="gi">+                self.linter.stats.undocumented[&quot;klass&quot;] += 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.linter.stats.undocumented[node_type] += 1</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;empty-docstring&quot;, node=node, args=(node_type,), confidence=confidence</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/pylint/checkers/base/function_checker.py b/pylint/checkers/base/function_checker.py</span>
<span class="gh">index 8a0108704..f7d92a464 100644</span>
<span class="gd">--- a/pylint/checkers/base/function_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/function_checker.py</span>
<span class="gu">@@ -1,20 +1,42 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Function checker for Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.base.basic_checker import _BasicChecker


<span class="w"> </span>class FunctionChecker(_BasicChecker):
<span class="w"> </span>    &quot;&quot;&quot;Check if a function definition handles possible side effects.&quot;&quot;&quot;
<span class="gd">-    msgs = {&#39;W0135&#39;: (&#39;The context used in function %r will not be exited.&#39;,</span>
<span class="gd">-        &#39;contextmanager-generator-missing-cleanup&#39;,</span>
<span class="gd">-        &#39;Used when a contextmanager is used inside a generator function and the cleanup is not handled.&#39;</span>
<span class="gd">-        )}</span>

<span class="gd">-    def _check_contextmanager_generator_missing_cleanup(self, node: nodes.</span>
<span class="gd">-        FunctionDef) -&gt;None:</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W0135&quot;: (</span>
<span class="gi">+            &quot;The context used in function %r will not be exited.&quot;,</span>
<span class="gi">+            &quot;contextmanager-generator-missing-cleanup&quot;,</span>
<span class="gi">+            &quot;Used when a contextmanager is used inside a generator function&quot;</span>
<span class="gi">+            &quot; and the cleanup is not handled.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;contextmanager-generator-missing-cleanup&quot;)</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        self._check_contextmanager_generator_missing_cleanup(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;contextmanager-generator-missing-cleanup&quot;)</span>
<span class="gi">+    def visit_asyncfunctiondef(self, node: nodes.AsyncFunctionDef) -&gt; None:</span>
<span class="gi">+        self._check_contextmanager_generator_missing_cleanup(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_contextmanager_generator_missing_cleanup(</span>
<span class="gi">+        self, node: nodes.FunctionDef</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check a FunctionDef to find if it is a generator
<span class="w"> </span>        that uses a contextmanager internally.

<span class="gu">@@ -23,11 +45,41 @@ class FunctionChecker(_BasicChecker):</span>
<span class="w"> </span>        :param node: FunctionDef node to check
<span class="w"> </span>        :type node: nodes.FunctionDef
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # if function does not use a Yield statement, it cant be a generator</span>
<span class="gi">+        with_nodes = list(node.nodes_of_class(nodes.With))</span>
<span class="gi">+        if not with_nodes:</span>
<span class="gi">+            return</span>
<span class="gi">+        # check for Yield inside the With statement</span>
<span class="gi">+        yield_nodes = list(</span>
<span class="gi">+            chain.from_iterable(</span>
<span class="gi">+                with_node.nodes_of_class(nodes.Yield) for with_node in with_nodes</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        if not yield_nodes:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # infer the call that yields a value, and check if it is a contextmanager</span>
<span class="gi">+        for with_node in with_nodes:</span>
<span class="gi">+            for call, held in with_node.items:</span>
<span class="gi">+                if held is None:</span>
<span class="gi">+                    # if we discard the value, then we can skip checking it</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # safe infer is a generator</span>
<span class="gi">+                inferred_node = getattr(utils.safe_infer(call), &quot;parent&quot;, None)</span>
<span class="gi">+                if not isinstance(inferred_node, nodes.FunctionDef):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if self._node_fails_contextmanager_cleanup(inferred_node, yield_nodes):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;contextmanager-generator-missing-cleanup&quot;,</span>
<span class="gi">+                        node=with_node,</span>
<span class="gi">+                        args=(node.name,),</span>
<span class="gi">+                    )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _node_fails_contextmanager_cleanup(node: nodes.FunctionDef,</span>
<span class="gd">-        yield_nodes: list[nodes.Yield]) -&gt;bool:</span>
<span class="gi">+    def _node_fails_contextmanager_cleanup(</span>
<span class="gi">+        node: nodes.FunctionDef, yield_nodes: list[nodes.Yield]</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a node fails contextmanager cleanup.

<span class="w"> </span>        Current checks for a contextmanager:
<span class="gu">@@ -42,4 +94,56 @@ class FunctionChecker(_BasicChecker):</span>
<span class="w"> </span>        :type yield_nodes: list[nodes.Yield]
<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def check_handles_generator_exceptions(try_node: nodes.Try) -&gt; bool:</span>
<span class="gi">+            # needs to handle either GeneratorExit, Exception, or bare except</span>
<span class="gi">+            for handler in try_node.handlers:</span>
<span class="gi">+                if handler.type is None:</span>
<span class="gi">+                    # handles all exceptions (bare except)</span>
<span class="gi">+                    return True</span>
<span class="gi">+                inferred = utils.safe_infer(handler.type)</span>
<span class="gi">+                if inferred and inferred.qname() in {</span>
<span class="gi">+                    &quot;builtins.GeneratorExit&quot;,</span>
<span class="gi">+                    &quot;builtins.Exception&quot;,</span>
<span class="gi">+                }:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # if context manager yields a non-constant value, then continue checking</span>
<span class="gi">+        if any(</span>
<span class="gi">+            yield_node.value is None or isinstance(yield_node.value, nodes.Const)</span>
<span class="gi">+            for yield_node in yield_nodes</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Check if yield expression is last statement</span>
<span class="gi">+        yield_nodes = list(node.nodes_of_class(nodes.Yield))</span>
<span class="gi">+        if len(yield_nodes) == 1:</span>
<span class="gi">+            n = yield_nodes[0].parent</span>
<span class="gi">+            while n is not node:</span>
<span class="gi">+                if n.next_sibling() is not None:</span>
<span class="gi">+                    break</span>
<span class="gi">+                n = n.parent</span>
<span class="gi">+            else:</span>
<span class="gi">+                # No next statement found</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        # if function body has multiple Try, filter down to the ones that have a yield node</span>
<span class="gi">+        try_with_yield_nodes = [</span>
<span class="gi">+            try_node</span>
<span class="gi">+            for try_node in node.nodes_of_class(nodes.Try)</span>
<span class="gi">+            if any(try_node.nodes_of_class(nodes.Yield))</span>
<span class="gi">+        ]</span>
<span class="gi">+        if not try_with_yield_nodes:</span>
<span class="gi">+            # no try blocks at all, so checks after this line do not apply</span>
<span class="gi">+            return True</span>
<span class="gi">+        # if the contextmanager has a finally block, then it is fine</span>
<span class="gi">+        if all(try_node.finalbody for try_node in try_with_yield_nodes):</span>
<span class="gi">+            return False</span>
<span class="gi">+        # if the contextmanager catches GeneratorExit, then it is fine</span>
<span class="gi">+        if all(</span>
<span class="gi">+            check_handles_generator_exceptions(try_node)</span>
<span class="gi">+            for try_node in try_with_yield_nodes</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/pylint/checkers/base/name_checker/checker.py b/pylint/checkers/base/name_checker/checker.py</span>
<span class="gh">index 1ef68f6ca..3514829fb 100644</span>
<span class="gd">--- a/pylint/checkers/base/name_checker/checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/name_checker/checker.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Basic checker for Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import collections
<span class="w"> </span>import itertools
<span class="gu">@@ -9,23 +15,44 @@ from collections.abc import Iterable</span>
<span class="w"> </span>from enum import Enum, auto
<span class="w"> </span>from re import Pattern
<span class="w"> </span>from typing import TYPE_CHECKING, Tuple
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import constants, interfaces
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.base.basic_checker import _BasicChecker
<span class="gd">-from pylint.checkers.base.name_checker.naming_style import KNOWN_NAME_TYPES, KNOWN_NAME_TYPES_WITH_STYLE, NAMING_STYLES, _create_naming_options</span>
<span class="gi">+from pylint.checkers.base.name_checker.naming_style import (</span>
<span class="gi">+    KNOWN_NAME_TYPES,</span>
<span class="gi">+    KNOWN_NAME_TYPES_WITH_STYLE,</span>
<span class="gi">+    NAMING_STYLES,</span>
<span class="gi">+    _create_naming_options,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.checkers.utils import is_property_deleter, is_property_setter
<span class="w"> </span>from pylint.typing import Options
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter
<span class="gi">+</span>
<span class="w"> </span>_BadNamesTuple = Tuple[nodes.NodeNG, str, str, interfaces.Confidence]
<span class="gd">-DEFAULT_PATTERNS = {&#39;typevar&#39;: re.compile(</span>
<span class="gd">-    &#39;^_{0,2}(?!T[A-Z])(?:[A-Z]+|(?:[A-Z]+[a-z]+)+T?(?&lt;!Type))(?:_co(?:ntra)?)?$&#39;</span>
<span class="gd">-    ), &#39;typealias&#39;: re.compile(</span>
<span class="gd">-    &#39;^_{0,2}(?!T[A-Z]|Type)[A-Z]+[a-z0-9]+(?:[A-Z][a-z0-9]+)*$&#39;)}</span>
<span class="gd">-BUILTIN_PROPERTY = &#39;builtins.property&#39;</span>
<span class="gd">-TYPE_VAR_QNAME = frozenset((&#39;typing.TypeVar&#39;, &#39;typing_extensions.TypeVar&#39;))</span>
<span class="gi">+</span>
<span class="gi">+# Default patterns for name types that do not have styles</span>
<span class="gi">+DEFAULT_PATTERNS = {</span>
<span class="gi">+    &quot;typevar&quot;: re.compile(</span>
<span class="gi">+        r&quot;^_{0,2}(?!T[A-Z])(?:[A-Z]+|(?:[A-Z]+[a-z]+)+T?(?&lt;!Type))(?:_co(?:ntra)?)?$&quot;</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;typealias&quot;: re.compile(</span>
<span class="gi">+        r&quot;^_{0,2}(?!T[A-Z]|Type)[A-Z]+[a-z0-9]+(?:[A-Z][a-z0-9]+)*$&quot;</span>
<span class="gi">+    ),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+BUILTIN_PROPERTY = &quot;builtins.property&quot;</span>
<span class="gi">+TYPE_VAR_QNAME = frozenset(</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;typing.TypeVar&quot;,</span>
<span class="gi">+        &quot;typing_extensions.TypeVar&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+)</span>


<span class="w"> </span>class TypeVarVariance(Enum):
<span class="gu">@@ -36,26 +63,47 @@ class TypeVarVariance(Enum):</span>
<span class="w"> </span>    inferred = auto()


<span class="gd">-def _get_properties(config: argparse.Namespace) -&gt;tuple[set[str], set[str]]:</span>
<span class="gi">+def _get_properties(config: argparse.Namespace) -&gt; tuple[set[str], set[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a tuple of property classes and names.

<span class="w"> </span>    Property classes are fully qualified, such as &#39;abc.abstractproperty&#39; and
<span class="w"> </span>    property names are the actual names, such as &#39;abstract_property&#39;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    property_classes = {BUILTIN_PROPERTY}</span>
<span class="gi">+    property_names: set[str] = set()  # Not returning &#39;property&#39;, it has its own check.</span>
<span class="gi">+    if config is not None:</span>
<span class="gi">+        property_classes.update(config.property_classes)</span>
<span class="gi">+        property_names.update(</span>
<span class="gi">+            prop.rsplit(&quot;.&quot;, 1)[-1] for prop in config.property_classes</span>
<span class="gi">+        )</span>
<span class="gi">+    return property_classes, property_names</span>


<span class="gd">-def _redefines_import(node: nodes.AssignName) -&gt;bool:</span>
<span class="gi">+def _redefines_import(node: nodes.AssignName) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Detect that the given node (AssignName) is inside an
<span class="w"> </span>    exception handler and redefines an import from the tryexcept body.

<span class="w"> </span>    Returns True if the node redefines an import, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current = node</span>
<span class="gi">+    while current and not isinstance(current.parent, nodes.ExceptHandler):</span>
<span class="gi">+        current = current.parent</span>
<span class="gi">+    if not current or not utils.error_of_type(current.parent, ImportError):</span>
<span class="gi">+        return False</span>
<span class="gi">+    try_block = current.parent.parent</span>
<span class="gi">+    for import_node in try_block.nodes_of_class((nodes.ImportFrom, nodes.Import)):</span>
<span class="gi">+        for name, alias in import_node.names:</span>
<span class="gi">+            if alias:</span>
<span class="gi">+                if alias == node.name:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            elif name == node.name:</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def _determine_function_name_type(node: nodes.FunctionDef, config: argparse</span>
<span class="gd">-    .Namespace) -&gt;str:</span>
<span class="gi">+def _determine_function_name_type(</span>
<span class="gi">+    node: nodes.FunctionDef, config: argparse.Namespace</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine the name type whose regex the function&#39;s name should match.

<span class="w"> </span>    :param node: A function node.
<span class="gu">@@ -63,54 +111,169 @@ def _determine_function_name_type(node: nodes.FunctionDef, config: argparse</span>

<span class="w"> </span>    :returns: One of (&#39;function&#39;, &#39;method&#39;, &#39;attr&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    property_classes, property_names = _get_properties(config)</span>
<span class="gi">+    if not node.is_method():</span>
<span class="gi">+        return &quot;function&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if is_property_setter(node) or is_property_deleter(node):</span>
<span class="gi">+        # If the function is decorated using the prop_method.{setter,getter}</span>
<span class="gi">+        # form, treat it like an attribute as well.</span>
<span class="gi">+        return &quot;attr&quot;</span>
<span class="gi">+</span>
<span class="gi">+    decorators = node.decorators.nodes if node.decorators else []</span>
<span class="gi">+    for decorator in decorators:</span>
<span class="gi">+        # If the function is a property (decorated with @property</span>
<span class="gi">+        # or @abc.abstractproperty), the name type is &#39;attr&#39;.</span>
<span class="gi">+        if isinstance(decorator, nodes.Name) or (</span>
<span class="gi">+            isinstance(decorator, nodes.Attribute)</span>
<span class="gi">+            and decorator.attrname in property_names</span>
<span class="gi">+        ):</span>
<span class="gi">+            inferred = utils.safe_infer(decorator)</span>
<span class="gi">+            if (</span>
<span class="gi">+                inferred</span>
<span class="gi">+                and hasattr(inferred, &quot;qname&quot;)</span>
<span class="gi">+                and inferred.qname() in property_classes</span>
<span class="gi">+            ):</span>
<span class="gi">+                return &quot;attr&quot;</span>
<span class="gi">+    return &quot;method&quot;</span>


<span class="gd">-EXEMPT_NAME_CATEGORIES = {&#39;exempt&#39;, &#39;ignore&#39;}</span>
<span class="gi">+# Name categories that are always consistent with all naming conventions.</span>
<span class="gi">+EXEMPT_NAME_CATEGORIES = {&quot;exempt&quot;, &quot;ignore&quot;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_multi_naming_match(</span>
<span class="gi">+    match: re.Match[str] | None, node_type: str, confidence: interfaces.Confidence</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    return (</span>
<span class="gi">+        match is not None</span>
<span class="gi">+        and match.lastgroup is not None</span>
<span class="gi">+        and match.lastgroup not in EXEMPT_NAME_CATEGORIES</span>
<span class="gi">+        and (node_type != &quot;method&quot; or confidence != interfaces.INFERENCE_FAILURE)</span>
<span class="gi">+    )</span>


<span class="w"> </span>class NameChecker(_BasicChecker):
<span class="gd">-    msgs = {&#39;C0103&#39;: (&#39;%s name &quot;%s&quot; doesn\&#39;t conform to %s&#39;, &#39;invalid-name&#39;,</span>
<span class="gd">-        &quot;Used when the name doesn&#39;t conform to naming rules associated to its type (constant, variable, class...).&quot;</span>
<span class="gd">-        ), &#39;C0104&#39;: (&#39;Disallowed name &quot;%s&quot;&#39;, &#39;disallowed-name&#39;,</span>
<span class="gd">-        &#39;Used when the name matches bad-names or bad-names-rgxs- (unauthorized names).&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;C0102&#39;, &#39;blacklisted-name&#39;)]}), &#39;C0105&#39;: (</span>
<span class="gd">-        &#39;Type variable name does not reflect variance%s&#39;,</span>
<span class="gd">-        &#39;typevar-name-incorrect-variance&#39;,</span>
<span class="gd">-        &quot;Emitted when a TypeVar name doesn&#39;t reflect its type variance. According to PEP8, it is recommended to add suffixes &#39;_co&#39; and &#39;_contra&#39; to the variables used to declare covariant or contravariant behaviour respectively. Invariant (default) variables do not require a suffix. The message is also emitted when invariant variables do have a suffix.&quot;</span>
<span class="gd">-        ), &#39;C0131&#39;: (&#39;TypeVar cannot be both covariant and contravariant&#39;,</span>
<span class="gd">-        &#39;typevar-double-variance&#39;,</span>
<span class="gd">-        &#39;Emitted when both the &quot;covariant&quot; and &quot;contravariant&quot; keyword arguments are set to &quot;True&quot; in a TypeVar.&#39;</span>
<span class="gd">-        ), &#39;C0132&#39;: (</span>
<span class="gd">-        &#39;TypeVar name &quot;%s&quot; does not match assigned variable name &quot;%s&quot;&#39;,</span>
<span class="gd">-        &#39;typevar-name-mismatch&#39;,</span>
<span class="gd">-        &#39;Emitted when a TypeVar is assigned to a variable that does not match its name argument.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-    _options: Options = ((&#39;good-names&#39;, {&#39;default&#39;: (&#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;ex&#39;,</span>
<span class="gd">-        &#39;Run&#39;, &#39;_&#39;), &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Good variable names which should always be accepted, separated by a comma.&#39;</span>
<span class="gd">-        }), (&#39;good-names-rgxs&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;regexp_csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Good variable names regexes, separated by a comma. If names match any regex, they will always be accepted&#39;</span>
<span class="gd">-        }), (&#39;bad-names&#39;, {&#39;default&#39;: (&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;toto&#39;, &#39;tutu&#39;,</span>
<span class="gd">-        &#39;tata&#39;), &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Bad variable names which should always be refused, separated by a comma.&#39;</span>
<span class="gd">-        }), (&#39;bad-names-rgxs&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;regexp_csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Bad variable names regexes, separated by a comma. If names match any regex, they will always be refused&#39;</span>
<span class="gd">-        }), (&#39;name-group&#39;, {&#39;default&#39;: (), &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;name1:name2&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &quot;Colon-delimited sets of names that determine each other&#39;s naming style when the name regexes allow several styles.&quot;</span>
<span class="gd">-        }), (&#39;include-naming-hint&#39;, {&#39;default&#39;: False, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Include a hint for the correct naming format with invalid-name.&#39;}),</span>
<span class="gd">-        (&#39;property-classes&#39;, {&#39;default&#39;: (&#39;abc.abstractproperty&#39;,), &#39;type&#39;:</span>
<span class="gd">-        &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;decorator names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of decorators that produce properties, such as abc.abstractproperty. Add to this list to register other decorators that produce valid properties. These decorators are taken in consideration only for invalid-name.&#39;</span>
<span class="gd">-        }))</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C0103&quot;: (</span>
<span class="gi">+            &#39;%s name &quot;%s&quot; doesn\&#39;t conform to %s&#39;,</span>
<span class="gi">+            &quot;invalid-name&quot;,</span>
<span class="gi">+            &quot;Used when the name doesn&#39;t conform to naming rules &quot;</span>
<span class="gi">+            &quot;associated to its type (constant, variable, class...).&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0104&quot;: (</span>
<span class="gi">+            &#39;Disallowed name &quot;%s&quot;&#39;,</span>
<span class="gi">+            &quot;disallowed-name&quot;,</span>
<span class="gi">+            &quot;Used when the name matches bad-names or bad-names-rgxs- (unauthorized names).&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;old_names&quot;: [</span>
<span class="gi">+                    (&quot;C0102&quot;, &quot;blacklisted-name&quot;),</span>
<span class="gi">+                ]</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0105&quot;: (</span>
<span class="gi">+            &quot;Type variable name does not reflect variance%s&quot;,</span>
<span class="gi">+            &quot;typevar-name-incorrect-variance&quot;,</span>
<span class="gi">+            &quot;Emitted when a TypeVar name doesn&#39;t reflect its type variance. &quot;</span>
<span class="gi">+            &quot;According to PEP8, it is recommended to add suffixes &#39;_co&#39; and &quot;</span>
<span class="gi">+            &quot;&#39;_contra&#39; to the variables used to declare covariant or &quot;</span>
<span class="gi">+            &quot;contravariant behaviour respectively. Invariant (default) variables &quot;</span>
<span class="gi">+            &quot;do not require a suffix. The message is also emitted when invariant &quot;</span>
<span class="gi">+            &quot;variables do have a suffix.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0131&quot;: (</span>
<span class="gi">+            &quot;TypeVar cannot be both covariant and contravariant&quot;,</span>
<span class="gi">+            &quot;typevar-double-variance&quot;,</span>
<span class="gi">+            &#39;Emitted when both the &quot;covariant&quot; and &quot;contravariant&quot; &#39;</span>
<span class="gi">+            &#39;keyword arguments are set to &quot;True&quot; in a TypeVar.&#39;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0132&quot;: (</span>
<span class="gi">+            &#39;TypeVar name &quot;%s&quot; does not match assigned variable name &quot;%s&quot;&#39;,</span>
<span class="gi">+            &quot;typevar-name-mismatch&quot;,</span>
<span class="gi">+            &quot;Emitted when a TypeVar is assigned to a variable &quot;</span>
<span class="gi">+            &quot;that does not match its name argument.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    _options: Options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;good-names&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (&quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;ex&quot;, &quot;Run&quot;, &quot;_&quot;),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Good variable names which should always be accepted,&quot;</span>
<span class="gi">+                &quot; separated by a comma.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;good-names-rgxs&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp_csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Good variable names regexes, separated by a comma. If names match any regex,&quot;</span>
<span class="gi">+                &quot; they will always be accepted&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;bad-names&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;toto&quot;, &quot;tutu&quot;, &quot;tata&quot;),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Bad variable names which should always be refused, &quot;</span>
<span class="gi">+                &quot;separated by a comma.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;bad-names-rgxs&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp_csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Bad variable names regexes, separated by a comma. If names match any regex,&quot;</span>
<span class="gi">+                &quot; they will always be refused&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;name-group&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;name1:name2&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Colon-delimited sets of names that determine each&quot;</span>
<span class="gi">+                    &quot; other&#39;s naming style when the name regexes&quot;</span>
<span class="gi">+                    &quot; allow several styles.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;include-naming-hint&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Include a hint for the correct naming format with invalid-name.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;property-classes&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (&quot;abc.abstractproperty&quot;,),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;decorator names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of decorators that produce properties, such as &quot;</span>
<span class="gi">+                &quot;abc.abstractproperty. Add to this list to register &quot;</span>
<span class="gi">+                &quot;other decorators that produce valid properties. &quot;</span>
<span class="gi">+                &quot;These decorators are taken in consideration only for invalid-name.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="w"> </span>    options: Options = _options + _create_naming_options()

<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="w"> </span>        self._name_group: dict[str, str] = {}
<span class="w"> </span>        self._bad_names: dict[str, dict[str, list[_BadNamesTuple]]] = {}
<span class="gu">@@ -118,35 +281,436 @@ class NameChecker(_BasicChecker):</span>
<span class="w"> </span>        self._name_hints: dict[str, str] = {}
<span class="w"> </span>        self._good_names_rgxs_compiled: list[re.Pattern[str]] = []
<span class="w"> </span>        self._bad_names_rgxs_compiled: list[re.Pattern[str]] = []
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        self.linter.stats.reset_bad_names()</span>
<span class="gi">+        for group in self.linter.config.name_group:</span>
<span class="gi">+            for name_type in group.split(&quot;:&quot;):</span>
<span class="gi">+                self._name_group[name_type] = f&quot;group_{group}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        regexps, hints = self._create_naming_rules()</span>
<span class="gi">+        self._name_regexps = regexps</span>
<span class="gi">+        self._name_hints = hints</span>
<span class="gi">+        self._good_names_rgxs_compiled = [</span>
<span class="gi">+            re.compile(rgxp) for rgxp in self.linter.config.good_names_rgxs</span>
<span class="gi">+        ]</span>
<span class="gi">+        self._bad_names_rgxs_compiled = [</span>
<span class="gi">+            re.compile(rgxp) for rgxp in self.linter.config.bad_names_rgxs</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def _create_naming_rules(self) -&gt; tuple[dict[str, Pattern[str]], dict[str, str]]:</span>
<span class="gi">+        regexps: dict[str, Pattern[str]] = {}</span>
<span class="gi">+        hints: dict[str, str] = {}</span>
<span class="gi">+</span>
<span class="gi">+        for name_type in KNOWN_NAME_TYPES:</span>
<span class="gi">+            if name_type in KNOWN_NAME_TYPES_WITH_STYLE:</span>
<span class="gi">+                naming_style_name = getattr(</span>
<span class="gi">+                    self.linter.config, f&quot;{name_type}_naming_style&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                regexps[name_type] = NAMING_STYLES[naming_style_name].get_regex(</span>
<span class="gi">+                    name_type</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                naming_style_name = &quot;predefined&quot;</span>
<span class="gi">+                regexps[name_type] = DEFAULT_PATTERNS[name_type]</span>
<span class="gi">+</span>
<span class="gi">+            custom_regex_setting_name = f&quot;{name_type}_rgx&quot;</span>
<span class="gi">+            custom_regex = getattr(self.linter.config, custom_regex_setting_name, None)</span>
<span class="gi">+            if custom_regex is not None:</span>
<span class="gi">+                regexps[name_type] = custom_regex</span>
<span class="gi">+</span>
<span class="gi">+            if custom_regex is not None:</span>
<span class="gi">+                hints[name_type] = f&quot;{custom_regex.pattern!r} pattern&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                hints[name_type] = f&quot;{naming_style_name} naming style&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return regexps, hints</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;disallowed-name&quot;, &quot;invalid-name&quot;)</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="gi">+        self._check_name(&quot;module&quot;, node.name.split(&quot;.&quot;)[-1], node)</span>
<span class="gi">+        self._bad_names = {}</span>
<span class="gi">+</span>
<span class="gi">+    def leave_module(self, _: nodes.Module) -&gt; None:</span>
<span class="gi">+        for all_groups in self._bad_names.values():</span>
<span class="gi">+            if len(all_groups) &lt; 2:</span>
<span class="gi">+                continue</span>
<span class="gi">+            groups: collections.defaultdict[int, list[list[_BadNamesTuple]]] = (</span>
<span class="gi">+                collections.defaultdict(list)</span>
<span class="gi">+            )</span>
<span class="gi">+            min_warnings = sys.maxsize</span>
<span class="gi">+            prevalent_group, _ = max(all_groups.items(), key=lambda item: len(item[1]))</span>
<span class="gi">+            for group in all_groups.values():</span>
<span class="gi">+                groups[len(group)].append(group)</span>
<span class="gi">+                min_warnings = min(len(group), min_warnings)</span>
<span class="gi">+            if len(groups[min_warnings]) &gt; 1:</span>
<span class="gi">+                by_line = sorted(</span>
<span class="gi">+                    groups[min_warnings],</span>
<span class="gi">+                    key=lambda group: min(</span>
<span class="gi">+                        warning[0].lineno</span>
<span class="gi">+                        for warning in group</span>
<span class="gi">+                        if warning[0].lineno is not None</span>
<span class="gi">+                    ),</span>
<span class="gi">+                )</span>
<span class="gi">+                warnings: Iterable[_BadNamesTuple] = itertools.chain(*by_line[1:])</span>
<span class="gi">+            else:</span>
<span class="gi">+                warnings = groups[min_warnings][0]</span>
<span class="gi">+            for args in warnings:</span>
<span class="gi">+                self._raise_name_warning(prevalent_group, *args)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;disallowed-name&quot;, &quot;invalid-name&quot;)</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        self._check_name(&quot;class&quot;, node.name, node)</span>
<span class="gi">+        for attr, anodes in node.instance_attrs.items():</span>
<span class="gi">+            if not any(node.instance_attr_ancestors(attr)):</span>
<span class="gi">+                self._check_name(&quot;attr&quot;, attr, anodes[0])</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;disallowed-name&quot;, &quot;invalid-name&quot;)</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        # Do not emit any warnings if the method is just an implementation</span>
<span class="gi">+        # of a base class method.</span>
<span class="gi">+        confidence = interfaces.HIGH</span>
<span class="gi">+        if node.is_method():</span>
<span class="gi">+            if utils.overrides_a_method(node.parent.frame(), node.name):</span>
<span class="gi">+                return</span>
<span class="gi">+            confidence = (</span>
<span class="gi">+                interfaces.INFERENCE</span>
<span class="gi">+                if utils.has_known_bases(node.parent.frame())</span>
<span class="gi">+                else interfaces.INFERENCE_FAILURE</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        self._check_name(</span>
<span class="gi">+            _determine_function_name_type(node, config=self.linter.config),</span>
<span class="gi">+            node.name,</span>
<span class="gi">+            node,</span>
<span class="gi">+            confidence,</span>
<span class="gi">+        )</span>
<span class="gi">+        # Check argument names</span>
<span class="gi">+        args = node.args.args</span>
<span class="gi">+        if args is not None:</span>
<span class="gi">+            self._recursive_check_names(args)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    @utils.only_required_for_messages(&#39;disallowed-name&#39;, &#39;invalid-name&#39;,</span>
<span class="gd">-        &#39;typevar-name-incorrect-variance&#39;, &#39;typevar-double-variance&#39;,</span>
<span class="gd">-        &#39;typevar-name-mismatch&#39;)</span>
<span class="gd">-    def visit_assignname(self, node: nodes.AssignName) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;disallowed-name&quot;,</span>
<span class="gi">+        &quot;invalid-name&quot;,</span>
<span class="gi">+        &quot;typevar-name-incorrect-variance&quot;,</span>
<span class="gi">+        &quot;typevar-double-variance&quot;,</span>
<span class="gi">+        &quot;typevar-name-mismatch&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_assignname(  # pylint: disable=too-many-branches</span>
<span class="gi">+        self, node: nodes.AssignName</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check module level assigned names.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        frame = node.frame()</span>
<span class="gi">+        assign_type = node.assign_type()</span>

<span class="gd">-    def _recursive_check_names(self, args: list[nodes.AssignName]) -&gt;None:</span>
<span class="gi">+        # Check names defined in comprehensions</span>
<span class="gi">+        if isinstance(assign_type, nodes.Comprehension):</span>
<span class="gi">+            self._check_name(&quot;inlinevar&quot;, node.name, node)</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(assign_type, nodes.TypeVar):</span>
<span class="gi">+            self._check_name(&quot;typevar&quot;, node.name, node)</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(assign_type, nodes.TypeAlias):</span>
<span class="gi">+            self._check_name(&quot;typealias&quot;, node.name, node)</span>
<span class="gi">+</span>
<span class="gi">+        # Check names defined in module scope</span>
<span class="gi">+        elif isinstance(frame, nodes.Module):</span>
<span class="gi">+            # Check names defined in Assign nodes</span>
<span class="gi">+            if isinstance(assign_type, nodes.Assign):</span>
<span class="gi">+                inferred_assign_type = utils.safe_infer(assign_type.value)</span>
<span class="gi">+</span>
<span class="gi">+                # Check TypeVar&#39;s and TypeAliases assigned alone or in tuple assignment</span>
<span class="gi">+                if isinstance(node.parent, nodes.Assign):</span>
<span class="gi">+                    if self._assigns_typevar(assign_type.value):</span>
<span class="gi">+                        self._check_name(&quot;typevar&quot;, assign_type.targets[0].name, node)</span>
<span class="gi">+                        return</span>
<span class="gi">+                    if self._assigns_typealias(assign_type.value):</span>
<span class="gi">+                        self._check_name(&quot;typealias&quot;, assign_type.targets[0].name, node)</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(node.parent, nodes.Tuple)</span>
<span class="gi">+                    and isinstance(assign_type.value, nodes.Tuple)</span>
<span class="gi">+                    # protect against unbalanced tuple unpacking</span>
<span class="gi">+                    and node.parent.elts.index(node) &lt; len(assign_type.value.elts)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    assigner = assign_type.value.elts[node.parent.elts.index(node)]</span>
<span class="gi">+                    if self._assigns_typevar(assigner):</span>
<span class="gi">+                        self._check_name(</span>
<span class="gi">+                            &quot;typevar&quot;,</span>
<span class="gi">+                            assign_type.targets[0]</span>
<span class="gi">+                            .elts[node.parent.elts.index(node)]</span>
<span class="gi">+                            .name,</span>
<span class="gi">+                            node,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        return</span>
<span class="gi">+                    if self._assigns_typealias(assigner):</span>
<span class="gi">+                        self._check_name(</span>
<span class="gi">+                            &quot;typealias&quot;,</span>
<span class="gi">+                            assign_type.targets[0]</span>
<span class="gi">+                            .elts[node.parent.elts.index(node)]</span>
<span class="gi">+                            .name,</span>
<span class="gi">+                            node,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                # Check classes (TypeVar&#39;s are classes so they need to be excluded first)</span>
<span class="gi">+                elif isinstance(inferred_assign_type, nodes.ClassDef):</span>
<span class="gi">+                    self._check_name(&quot;class&quot;, node.name, node)</span>
<span class="gi">+</span>
<span class="gi">+                # Don&#39;t emit if the name redefines an import in an ImportError except handler.</span>
<span class="gi">+                elif not _redefines_import(node) and isinstance(</span>
<span class="gi">+                    inferred_assign_type, nodes.Const</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self._check_name(&quot;const&quot;, node.name, node)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._check_name(</span>
<span class="gi">+                        &quot;variable&quot;, node.name, node, disallowed_check_only=True</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            # Check names defined in AnnAssign nodes</span>
<span class="gi">+            elif isinstance(assign_type, nodes.AnnAssign):</span>
<span class="gi">+                if utils.is_assign_name_annotated_with(node, &quot;Final&quot;):</span>
<span class="gi">+                    self._check_name(&quot;const&quot;, node.name, node)</span>
<span class="gi">+                elif self._assigns_typealias(assign_type.annotation):</span>
<span class="gi">+                    self._check_name(&quot;typealias&quot;, node.name, node)</span>
<span class="gi">+</span>
<span class="gi">+        # Check names defined in function scopes</span>
<span class="gi">+        elif isinstance(frame, nodes.FunctionDef):</span>
<span class="gi">+            # global introduced variable aren&#39;t in the function locals</span>
<span class="gi">+            if node.name in frame and node.name not in frame.argnames():</span>
<span class="gi">+                if not _redefines_import(node):</span>
<span class="gi">+                    if isinstance(</span>
<span class="gi">+                        assign_type, nodes.AnnAssign</span>
<span class="gi">+                    ) and self._assigns_typealias(assign_type.annotation):</span>
<span class="gi">+                        self._check_name(&quot;typealias&quot;, node.name, node)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self._check_name(&quot;variable&quot;, node.name, node)</span>
<span class="gi">+</span>
<span class="gi">+        # Check names defined in class scopes</span>
<span class="gi">+        elif isinstance(frame, nodes.ClassDef) and not any(</span>
<span class="gi">+            frame.local_attr_ancestors(node.name)</span>
<span class="gi">+        ):</span>
<span class="gi">+            if utils.is_enum_member(node) or utils.is_assign_name_annotated_with(</span>
<span class="gi">+                node, &quot;Final&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                self._check_name(&quot;class_const&quot;, node.name, node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._check_name(&quot;class_attribute&quot;, node.name, node)</span>
<span class="gi">+</span>
<span class="gi">+    def _recursive_check_names(self, args: list[nodes.AssignName]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check names in a possibly recursive list &lt;arg&gt;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for arg in args:</span>
<span class="gi">+            self._check_name(&quot;argument&quot;, arg.name, arg)</span>
<span class="gi">+</span>
<span class="gi">+    def _find_name_group(self, node_type: str) -&gt; str:</span>
<span class="gi">+        return self._name_group.get(node_type, node_type)</span>
<span class="gi">+</span>
<span class="gi">+    def _raise_name_warning(</span>
<span class="gi">+        self,</span>
<span class="gi">+        prevalent_group: str | None,</span>
<span class="gi">+        node: nodes.NodeNG,</span>
<span class="gi">+        node_type: str,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        confidence: interfaces.Confidence,</span>
<span class="gi">+        warning: str = &quot;invalid-name&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        type_label = constants.HUMAN_READABLE_TYPES[node_type]</span>
<span class="gi">+        hint = self._name_hints[node_type]</span>
<span class="gi">+        if prevalent_group:</span>
<span class="gi">+            # This happens in the multi naming match case. The expected</span>
<span class="gi">+            # prevalent group needs to be spelled out to make the message</span>
<span class="gi">+            # correct.</span>
<span class="gi">+            hint = f&quot;the `{prevalent_group}` group in the {hint}&quot;</span>
<span class="gi">+        if self.linter.config.include_naming_hint:</span>
<span class="gi">+            hint += f&quot; ({self._name_regexps[node_type].pattern!r} pattern)&quot;</span>
<span class="gi">+        args = (</span>
<span class="gi">+            (type_label.capitalize(), name, hint)</span>
<span class="gi">+            if warning == &quot;invalid-name&quot;</span>
<span class="gi">+            else (type_label.capitalize(), name)</span>
<span class="gi">+        )</span>

<span class="gd">-    def _check_name(self, node_type: str, name: str, node: nodes.NodeNG,</span>
<span class="gd">-        confidence: interfaces.Confidence=interfaces.HIGH,</span>
<span class="gd">-        disallowed_check_only: bool=False) -&gt;None:</span>
<span class="gi">+        self.add_message(warning, node=node, args=args, confidence=confidence)</span>
<span class="gi">+        self.linter.stats.increase_bad_name(node_type, 1)</span>
<span class="gi">+</span>
<span class="gi">+    def _name_allowed_by_regex(self, name: str) -&gt; bool:</span>
<span class="gi">+        return name in self.linter.config.good_names or any(</span>
<span class="gi">+            pattern.match(name) for pattern in self._good_names_rgxs_compiled</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _name_disallowed_by_regex(self, name: str) -&gt; bool:</span>
<span class="gi">+        return name in self.linter.config.bad_names or any(</span>
<span class="gi">+            pattern.match(name) for pattern in self._bad_names_rgxs_compiled</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_name(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node_type: str,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        node: nodes.NodeNG,</span>
<span class="gi">+        confidence: interfaces.Confidence = interfaces.HIGH,</span>
<span class="gi">+        disallowed_check_only: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for a name using the type&#39;s regexp.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        def _should_exempt_from_invalid_name(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+            if node_type == &quot;variable&quot;:</span>
<span class="gi">+                inferred = utils.safe_infer(node)</span>
<span class="gi">+                if isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+                    return True</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if self._name_allowed_by_regex(name=name):</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._name_disallowed_by_regex(name=name):</span>
<span class="gi">+            self.linter.stats.increase_bad_name(node_type, 1)</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;disallowed-name&quot;, node=node, args=name, confidence=interfaces.HIGH</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        regexp = self._name_regexps[node_type]</span>
<span class="gi">+        match = regexp.match(name)</span>
<span class="gi">+</span>
<span class="gi">+        if _is_multi_naming_match(match, node_type, confidence):</span>
<span class="gi">+            name_group = self._find_name_group(node_type)</span>
<span class="gi">+            bad_name_group = self._bad_names.setdefault(name_group, {})</span>
<span class="gi">+            # Ignored because this is checked by the if statement</span>
<span class="gi">+            warnings = bad_name_group.setdefault(match.lastgroup, [])  # type: ignore[union-attr, arg-type]</span>
<span class="gi">+            warnings.append((node, node_type, name, confidence))</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            match is None</span>
<span class="gi">+            and not disallowed_check_only</span>
<span class="gi">+            and not _should_exempt_from_invalid_name(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._raise_name_warning(None, node, node_type, name, confidence)</span>
<span class="gi">+</span>
<span class="gi">+        # Check TypeVar names for variance suffixes</span>
<span class="gi">+        if node_type == &quot;typevar&quot;:</span>
<span class="gi">+            self._check_typevar(name, node)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _assigns_typevar(node: (nodes.NodeNG | None)) -&gt;bool:</span>
<span class="gi">+    def _assigns_typevar(node: nodes.NodeNG | None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a node is assigning a TypeVar.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, astroid.Call):</span>
<span class="gi">+            inferred = utils.safe_infer(node.func)</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(inferred, astroid.ClassDef)</span>
<span class="gi">+                and inferred.qname() in TYPE_VAR_QNAME</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _assigns_typealias(node: (nodes.NodeNG | None)) -&gt;bool:</span>
<span class="gi">+    def _assigns_typealias(node: nodes.NodeNG | None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a node is assigning a TypeAlias.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred = utils.safe_infer(node)</span>
<span class="gi">+        if isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+            qname = inferred.qname()</span>
<span class="gi">+            if qname == &quot;typing.TypeAlias&quot;:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if qname == &quot;.Union&quot;:</span>
<span class="gi">+                # Union is a special case because it can be used as a type alias</span>
<span class="gi">+                # or as a type annotation. We only want to check the former.</span>
<span class="gi">+                assert node is not None</span>
<span class="gi">+                return not isinstance(node.parent, nodes.AnnAssign)</span>
<span class="gi">+        elif isinstance(inferred, nodes.FunctionDef):</span>
<span class="gi">+            # TODO: when py3.12 is minimum, remove this condition</span>
<span class="gi">+            # TypeAlias became a class in python 3.12</span>
<span class="gi">+            if inferred.qname() == &quot;typing.TypeAlias&quot;:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="gd">-    def _check_typevar(self, name: str, node: nodes.AssignName) -&gt;None:</span>
<span class="gi">+    def _check_typevar(self, name: str, node: nodes.AssignName) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for TypeVar lint violations.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        variance: TypeVarVariance = TypeVarVariance.invariant</span>
<span class="gi">+        if isinstance(node.parent, nodes.Assign):</span>
<span class="gi">+            keywords = node.assign_type().value.keywords</span>
<span class="gi">+            args = node.assign_type().value.args</span>
<span class="gi">+        elif isinstance(node.parent, nodes.Tuple):</span>
<span class="gi">+            keywords = (</span>
<span class="gi">+                node.assign_type().value.elts[node.parent.elts.index(node)].keywords</span>
<span class="gi">+            )</span>
<span class="gi">+            args = node.assign_type().value.elts[node.parent.elts.index(node)].args</span>
<span class="gi">+        else:  # PEP 695 generic type nodes</span>
<span class="gi">+            keywords = ()</span>
<span class="gi">+            args = ()</span>
<span class="gi">+            variance = TypeVarVariance.inferred</span>
<span class="gi">+</span>
<span class="gi">+        name_arg = None</span>
<span class="gi">+        for kw in keywords:</span>
<span class="gi">+            if variance == TypeVarVariance.double_variant:</span>
<span class="gi">+                pass</span>
<span class="gi">+            elif kw.arg == &quot;covariant&quot; and kw.value.value:</span>
<span class="gi">+                variance = (</span>
<span class="gi">+                    TypeVarVariance.covariant</span>
<span class="gi">+                    if variance != TypeVarVariance.contravariant</span>
<span class="gi">+                    else TypeVarVariance.double_variant</span>
<span class="gi">+                )</span>
<span class="gi">+            elif kw.arg == &quot;contravariant&quot; and kw.value.value:</span>
<span class="gi">+                variance = (</span>
<span class="gi">+                    TypeVarVariance.contravariant</span>
<span class="gi">+                    if variance != TypeVarVariance.covariant</span>
<span class="gi">+                    else TypeVarVariance.double_variant</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if kw.arg == &quot;name&quot; and isinstance(kw.value, nodes.Const):</span>
<span class="gi">+                name_arg = kw.value.value</span>
<span class="gi">+</span>
<span class="gi">+        if name_arg is None and args and isinstance(args[0], nodes.Const):</span>
<span class="gi">+            name_arg = args[0].value</span>
<span class="gi">+</span>
<span class="gi">+        if variance == TypeVarVariance.inferred:</span>
<span class="gi">+            # Ignore variance check for PEP 695 type parameters.</span>
<span class="gi">+            # The variance is inferred by the type checker.</span>
<span class="gi">+            # Adding _co or _contra suffix can help to reason about TypeVar.</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif variance == TypeVarVariance.double_variant:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;typevar-double-variance&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=interfaces.INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;typevar-name-incorrect-variance&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(&quot;&quot;,),</span>
<span class="gi">+                confidence=interfaces.INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif variance == TypeVarVariance.covariant and not name.endswith(&quot;_co&quot;):</span>
<span class="gi">+            suggest_name = f&quot;{re.sub(&#39;_contra$&#39;, &#39;&#39;, name)}_co&quot;</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;typevar-name-incorrect-variance&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(f&#39;. &quot;{name}&quot; is covariant, use &quot;{suggest_name}&quot; instead&#39;),</span>
<span class="gi">+                confidence=interfaces.INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif variance == TypeVarVariance.contravariant and not name.endswith(&quot;_contra&quot;):</span>
<span class="gi">+            suggest_name = f&quot;{re.sub(&#39;_co$&#39;, &#39;&#39;, name)}_contra&quot;</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;typevar-name-incorrect-variance&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(f&#39;. &quot;{name}&quot; is contravariant, use &quot;{suggest_name}&quot; instead&#39;),</span>
<span class="gi">+                confidence=interfaces.INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif variance == TypeVarVariance.invariant and (</span>
<span class="gi">+            name.endswith((&quot;_co&quot;, &quot;_contra&quot;))</span>
<span class="gi">+        ):</span>
<span class="gi">+            suggest_name = re.sub(&quot;_contra$|_co$&quot;, &quot;&quot;, name)</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;typevar-name-incorrect-variance&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(f&#39;. &quot;{name}&quot; is invariant, use &quot;{suggest_name}&quot; instead&#39;),</span>
<span class="gi">+                confidence=interfaces.INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if name_arg is not None and name_arg != name:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;typevar-name-mismatch&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(name_arg, name),</span>
<span class="gi">+                confidence=interfaces.INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/pylint/checkers/base/name_checker/naming_style.py b/pylint/checkers/base/name_checker/naming_style.py</span>
<span class="gh">index 91b831502..0198ae7d1 100644</span>
<span class="gd">--- a/pylint/checkers/base/name_checker/naming_style.py</span>
<span class="gi">+++ b/pylint/checkers/base/name_checker/naming_style.py</span>
<span class="gu">@@ -1,6 +1,12 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from re import Pattern
<span class="gi">+</span>
<span class="w"> </span>from pylint import constants
<span class="w"> </span>from pylint.typing import OptionDict, Options

<span class="gu">@@ -12,7 +18,8 @@ class NamingStyle:</span>
<span class="w"> </span>    forms of regular expressions, but we need to special-case stuff like dunder
<span class="w"> </span>    names in method names.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    ANY: Pattern[str] = re.compile(&#39;.*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    ANY: Pattern[str] = re.compile(&quot;.*&quot;)</span>
<span class="w"> </span>    CLASS_NAME_RGX: Pattern[str] = ANY
<span class="w"> </span>    MOD_NAME_RGX: Pattern[str] = ANY
<span class="w"> </span>    CONST_NAME_RGX: Pattern[str] = ANY
<span class="gu">@@ -20,64 +27,159 @@ class NamingStyle:</span>
<span class="w"> </span>    DEFAULT_NAME_RGX: Pattern[str] = ANY
<span class="w"> </span>    CLASS_ATTRIBUTE_RGX: Pattern[str] = ANY

<span class="gi">+    @classmethod</span>
<span class="gi">+    def get_regex(cls, name_type: str) -&gt; Pattern[str]:</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;module&quot;: cls.MOD_NAME_RGX,</span>
<span class="gi">+            &quot;const&quot;: cls.CONST_NAME_RGX,</span>
<span class="gi">+            &quot;class&quot;: cls.CLASS_NAME_RGX,</span>
<span class="gi">+            &quot;function&quot;: cls.DEFAULT_NAME_RGX,</span>
<span class="gi">+            &quot;method&quot;: cls.DEFAULT_NAME_RGX,</span>
<span class="gi">+            &quot;attr&quot;: cls.DEFAULT_NAME_RGX,</span>
<span class="gi">+            &quot;argument&quot;: cls.DEFAULT_NAME_RGX,</span>
<span class="gi">+            &quot;variable&quot;: cls.DEFAULT_NAME_RGX,</span>
<span class="gi">+            &quot;class_attribute&quot;: cls.CLASS_ATTRIBUTE_RGX,</span>
<span class="gi">+            &quot;class_const&quot;: cls.CONST_NAME_RGX,</span>
<span class="gi">+            &quot;inlinevar&quot;: cls.COMP_VAR_RGX,</span>
<span class="gi">+        }[name_type]</span>
<span class="gi">+</span>

<span class="w"> </span>class SnakeCaseStyle(NamingStyle):
<span class="w"> </span>    &quot;&quot;&quot;Regex rules for snake_case naming style.&quot;&quot;&quot;
<span class="gd">-    CLASS_NAME_RGX = re.compile(&#39;[^\\W\\dA-Z][^\\WA-Z]*$&#39;)</span>
<span class="gd">-    MOD_NAME_RGX = re.compile(&#39;[^\\W\\dA-Z][^\\WA-Z]*$&#39;)</span>
<span class="gd">-    CONST_NAME_RGX = re.compile(&#39;([^\\W\\dA-Z][^\\WA-Z]*|__.*__)$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    CLASS_NAME_RGX = re.compile(r&quot;[^\W\dA-Z][^\WA-Z]*$&quot;)</span>
<span class="gi">+    MOD_NAME_RGX = re.compile(r&quot;[^\W\dA-Z][^\WA-Z]*$&quot;)</span>
<span class="gi">+    CONST_NAME_RGX = re.compile(r&quot;([^\W\dA-Z][^\WA-Z]*|__.*__)$&quot;)</span>
<span class="w"> </span>    COMP_VAR_RGX = CLASS_NAME_RGX
<span class="w"> </span>    DEFAULT_NAME_RGX = re.compile(
<span class="gd">-        &#39;([^\\W\\dA-Z][^\\WA-Z]*|_[^\\WA-Z]*|__[^\\WA-Z\\d_][^\\WA-Z]+__)$&#39;)</span>
<span class="gd">-    CLASS_ATTRIBUTE_RGX = re.compile(&#39;([^\\W\\dA-Z][^\\WA-Z]*|__.*__)$&#39;)</span>
<span class="gi">+        r&quot;([^\W\dA-Z][^\WA-Z]*|_[^\WA-Z]*|__[^\WA-Z\d_][^\WA-Z]+__)$&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    CLASS_ATTRIBUTE_RGX = re.compile(r&quot;([^\W\dA-Z][^\WA-Z]*|__.*__)$&quot;)</span>


<span class="w"> </span>class CamelCaseStyle(NamingStyle):
<span class="w"> </span>    &quot;&quot;&quot;Regex rules for camelCase naming style.&quot;&quot;&quot;
<span class="gd">-    CLASS_NAME_RGX = re.compile(&#39;[^\\W\\dA-Z][^\\W_]*$&#39;)</span>
<span class="gd">-    MOD_NAME_RGX = re.compile(&#39;[^\\W\\dA-Z][^\\W_]*$&#39;)</span>
<span class="gd">-    CONST_NAME_RGX = re.compile(&#39;([^\\W\\dA-Z][^\\W_]*|__.*__)$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    CLASS_NAME_RGX = re.compile(r&quot;[^\W\dA-Z][^\W_]*$&quot;)</span>
<span class="gi">+    MOD_NAME_RGX = re.compile(r&quot;[^\W\dA-Z][^\W_]*$&quot;)</span>
<span class="gi">+    CONST_NAME_RGX = re.compile(r&quot;([^\W\dA-Z][^\W_]*|__.*__)$&quot;)</span>
<span class="w"> </span>    COMP_VAR_RGX = MOD_NAME_RGX
<span class="gd">-    DEFAULT_NAME_RGX = re.compile(</span>
<span class="gd">-        &#39;([^\\W\\dA-Z][^\\W_]*|__[^\\W\\dA-Z_]\\w+__)$&#39;)</span>
<span class="gd">-    CLASS_ATTRIBUTE_RGX = re.compile(&#39;([^\\W\\dA-Z][^\\W_]*|__.*__)$&#39;)</span>
<span class="gi">+    DEFAULT_NAME_RGX = re.compile(r&quot;([^\W\dA-Z][^\W_]*|__[^\W\dA-Z_]\w+__)$&quot;)</span>
<span class="gi">+    CLASS_ATTRIBUTE_RGX = re.compile(r&quot;([^\W\dA-Z][^\W_]*|__.*__)$&quot;)</span>


<span class="w"> </span>class PascalCaseStyle(NamingStyle):
<span class="w"> </span>    &quot;&quot;&quot;Regex rules for PascalCase naming style.&quot;&quot;&quot;
<span class="gd">-    CLASS_NAME_RGX = re.compile(&#39;[^\\W\\da-z][^\\W_]*$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    CLASS_NAME_RGX = re.compile(r&quot;[^\W\da-z][^\W_]*$&quot;)</span>
<span class="w"> </span>    MOD_NAME_RGX = CLASS_NAME_RGX
<span class="gd">-    CONST_NAME_RGX = re.compile(&#39;([^\\W\\da-z][^\\W_]*|__.*__)$&#39;)</span>
<span class="gi">+    CONST_NAME_RGX = re.compile(r&quot;([^\W\da-z][^\W_]*|__.*__)$&quot;)</span>
<span class="w"> </span>    COMP_VAR_RGX = CLASS_NAME_RGX
<span class="gd">-    DEFAULT_NAME_RGX = re.compile(</span>
<span class="gd">-        &#39;([^\\W\\da-z][^\\W_]*|__[^\\W\\dA-Z_]\\w+__)$&#39;)</span>
<span class="gd">-    CLASS_ATTRIBUTE_RGX = re.compile(&#39;[^\\W\\da-z][^\\W_]*$&#39;)</span>
<span class="gi">+    DEFAULT_NAME_RGX = re.compile(r&quot;([^\W\da-z][^\W_]*|__[^\W\dA-Z_]\w+__)$&quot;)</span>
<span class="gi">+    CLASS_ATTRIBUTE_RGX = re.compile(r&quot;[^\W\da-z][^\W_]*$&quot;)</span>


<span class="w"> </span>class UpperCaseStyle(NamingStyle):
<span class="w"> </span>    &quot;&quot;&quot;Regex rules for UPPER_CASE naming style.&quot;&quot;&quot;
<span class="gd">-    CLASS_NAME_RGX = re.compile(&#39;[^\\W\\da-z][^\\Wa-z]*$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    CLASS_NAME_RGX = re.compile(r&quot;[^\W\da-z][^\Wa-z]*$&quot;)</span>
<span class="w"> </span>    MOD_NAME_RGX = CLASS_NAME_RGX
<span class="gd">-    CONST_NAME_RGX = re.compile(&#39;([^\\W\\da-z][^\\Wa-z]*|__.*__)$&#39;)</span>
<span class="gi">+    CONST_NAME_RGX = re.compile(r&quot;([^\W\da-z][^\Wa-z]*|__.*__)$&quot;)</span>
<span class="w"> </span>    COMP_VAR_RGX = CLASS_NAME_RGX
<span class="gd">-    DEFAULT_NAME_RGX = re.compile(</span>
<span class="gd">-        &#39;([^\\W\\da-z][^\\Wa-z]*|__[^\\W\\dA-Z_]\\w+__)$&#39;)</span>
<span class="gd">-    CLASS_ATTRIBUTE_RGX = re.compile(&#39;[^\\W\\da-z][^\\Wa-z]*$&#39;)</span>
<span class="gi">+    DEFAULT_NAME_RGX = re.compile(r&quot;([^\W\da-z][^\Wa-z]*|__[^\W\dA-Z_]\w+__)$&quot;)</span>
<span class="gi">+    CLASS_ATTRIBUTE_RGX = re.compile(r&quot;[^\W\da-z][^\Wa-z]*$&quot;)</span>


<span class="w"> </span>class AnyStyle(NamingStyle):
<span class="w"> </span>    pass


<span class="gd">-NAMING_STYLES = {&#39;snake_case&#39;: SnakeCaseStyle, &#39;camelCase&#39;: CamelCaseStyle,</span>
<span class="gd">-    &#39;PascalCase&#39;: PascalCaseStyle, &#39;UPPER_CASE&#39;: UpperCaseStyle, &#39;any&#39;:</span>
<span class="gd">-    AnyStyle}</span>
<span class="gd">-KNOWN_NAME_TYPES_WITH_STYLE = {&#39;module&#39;, &#39;const&#39;, &#39;class&#39;, &#39;function&#39;,</span>
<span class="gd">-    &#39;method&#39;, &#39;attr&#39;, &#39;argument&#39;, &#39;variable&#39;, &#39;class_attribute&#39;,</span>
<span class="gd">-    &#39;class_const&#39;, &#39;inlinevar&#39;}</span>
<span class="gd">-DEFAULT_NAMING_STYLES = {&#39;module&#39;: &#39;snake_case&#39;, &#39;const&#39;: &#39;UPPER_CASE&#39;,</span>
<span class="gd">-    &#39;class&#39;: &#39;PascalCase&#39;, &#39;function&#39;: &#39;snake_case&#39;, &#39;method&#39;: &#39;snake_case&#39;,</span>
<span class="gd">-    &#39;attr&#39;: &#39;snake_case&#39;, &#39;argument&#39;: &#39;snake_case&#39;, &#39;variable&#39;:</span>
<span class="gd">-    &#39;snake_case&#39;, &#39;class_attribute&#39;: &#39;any&#39;, &#39;class_const&#39;: &#39;UPPER_CASE&#39;,</span>
<span class="gd">-    &#39;inlinevar&#39;: &#39;any&#39;}</span>
<span class="gd">-KNOWN_NAME_TYPES = {*KNOWN_NAME_TYPES_WITH_STYLE, &#39;typevar&#39;, &#39;typealias&#39;}</span>
<span class="gi">+NAMING_STYLES = {</span>
<span class="gi">+    &quot;snake_case&quot;: SnakeCaseStyle,</span>
<span class="gi">+    &quot;camelCase&quot;: CamelCaseStyle,</span>
<span class="gi">+    &quot;PascalCase&quot;: PascalCaseStyle,</span>
<span class="gi">+    &quot;UPPER_CASE&quot;: UpperCaseStyle,</span>
<span class="gi">+    &quot;any&quot;: AnyStyle,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+# Name types that have a style option</span>
<span class="gi">+KNOWN_NAME_TYPES_WITH_STYLE = {</span>
<span class="gi">+    &quot;module&quot;,</span>
<span class="gi">+    &quot;const&quot;,</span>
<span class="gi">+    &quot;class&quot;,</span>
<span class="gi">+    &quot;function&quot;,</span>
<span class="gi">+    &quot;method&quot;,</span>
<span class="gi">+    &quot;attr&quot;,</span>
<span class="gi">+    &quot;argument&quot;,</span>
<span class="gi">+    &quot;variable&quot;,</span>
<span class="gi">+    &quot;class_attribute&quot;,</span>
<span class="gi">+    &quot;class_const&quot;,</span>
<span class="gi">+    &quot;inlinevar&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_NAMING_STYLES = {</span>
<span class="gi">+    &quot;module&quot;: &quot;snake_case&quot;,</span>
<span class="gi">+    &quot;const&quot;: &quot;UPPER_CASE&quot;,</span>
<span class="gi">+    &quot;class&quot;: &quot;PascalCase&quot;,</span>
<span class="gi">+    &quot;function&quot;: &quot;snake_case&quot;,</span>
<span class="gi">+    &quot;method&quot;: &quot;snake_case&quot;,</span>
<span class="gi">+    &quot;attr&quot;: &quot;snake_case&quot;,</span>
<span class="gi">+    &quot;argument&quot;: &quot;snake_case&quot;,</span>
<span class="gi">+    &quot;variable&quot;: &quot;snake_case&quot;,</span>
<span class="gi">+    &quot;class_attribute&quot;: &quot;any&quot;,</span>
<span class="gi">+    &quot;class_const&quot;: &quot;UPPER_CASE&quot;,</span>
<span class="gi">+    &quot;inlinevar&quot;: &quot;any&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Name types that have a &#39;rgx&#39; option</span>
<span class="gi">+KNOWN_NAME_TYPES = {</span>
<span class="gi">+    *KNOWN_NAME_TYPES_WITH_STYLE,</span>
<span class="gi">+    &quot;typevar&quot;,</span>
<span class="gi">+    &quot;typealias&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_naming_options() -&gt; Options:</span>
<span class="gi">+    name_options: list[tuple[str, OptionDict]] = []</span>
<span class="gi">+    for name_type in sorted(KNOWN_NAME_TYPES):</span>
<span class="gi">+        human_readable_name = constants.HUMAN_READABLE_TYPES[name_type]</span>
<span class="gi">+        name_type_hyphened = name_type.replace(&quot;_&quot;, &quot;-&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        help_msg = f&quot;Regular expression matching correct {human_readable_name} names. &quot;</span>
<span class="gi">+        if name_type in KNOWN_NAME_TYPES_WITH_STYLE:</span>
<span class="gi">+            help_msg += f&quot;Overrides {name_type_hyphened}-naming-style. &quot;</span>
<span class="gi">+        help_msg += (</span>
<span class="gi">+            f&quot;If left empty, {human_readable_name} names will be checked &quot;</span>
<span class="gi">+            &quot;with the set naming style.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Add style option for names that support it</span>
<span class="gi">+        if name_type in KNOWN_NAME_TYPES_WITH_STYLE:</span>
<span class="gi">+            default_style = DEFAULT_NAMING_STYLES[name_type]</span>
<span class="gi">+            name_options.append(</span>
<span class="gi">+                (</span>
<span class="gi">+                    f&quot;{name_type_hyphened}-naming-style&quot;,</span>
<span class="gi">+                    {</span>
<span class="gi">+                        &quot;default&quot;: default_style,</span>
<span class="gi">+                        &quot;type&quot;: &quot;choice&quot;,</span>
<span class="gi">+                        &quot;choices&quot;: list(NAMING_STYLES.keys()),</span>
<span class="gi">+                        &quot;metavar&quot;: &quot;&lt;style&gt;&quot;,</span>
<span class="gi">+                        &quot;help&quot;: f&quot;Naming style matching correct {human_readable_name} names.&quot;,</span>
<span class="gi">+                    },</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        name_options.append(</span>
<span class="gi">+            (</span>
<span class="gi">+                f&quot;{name_type_hyphened}-rgx&quot;,</span>
<span class="gi">+                {</span>
<span class="gi">+                    &quot;default&quot;: None,</span>
<span class="gi">+                    &quot;type&quot;: &quot;regexp&quot;,</span>
<span class="gi">+                    &quot;metavar&quot;: &quot;&lt;regexp&gt;&quot;,</span>
<span class="gi">+                    &quot;help&quot;: help_msg,</span>
<span class="gi">+                },</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    return tuple(name_options)</span>
<span class="gh">diff --git a/pylint/checkers/base/pass_checker.py b/pylint/checkers/base/pass_checker.py</span>
<span class="gh">index 145946d00..19952ca4f 100644</span>
<span class="gd">--- a/pylint/checkers/base/pass_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base/pass_checker.py</span>
<span class="gu">@@ -1,10 +1,29 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.base.basic_checker import _BasicChecker


<span class="w"> </span>class PassChecker(_BasicChecker):
<span class="w"> </span>    &quot;&quot;&quot;Check if the pass statement is really necessary.&quot;&quot;&quot;
<span class="gd">-    msgs = {&#39;W0107&#39;: (&#39;Unnecessary pass statement&#39;, &#39;unnecessary-pass&#39;,</span>
<span class="gd">-        &#39;Used when a &quot;pass&quot; statement can be removed without affecting the behaviour of the code.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W0107&quot;: (</span>
<span class="gi">+            &quot;Unnecessary pass statement&quot;,</span>
<span class="gi">+            &quot;unnecessary-pass&quot;,</span>
<span class="gi">+            &#39;Used when a &quot;pass&quot; statement can be removed without affecting &#39;</span>
<span class="gi">+            &quot;the behaviour of the code.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;unnecessary-pass&quot;)</span>
<span class="gi">+    def visit_pass(self, node: nodes.Pass) -&gt; None:</span>
<span class="gi">+        if len(node.parent.child_sequence(node)) &gt; 1 or (</span>
<span class="gi">+            isinstance(node.parent, (nodes.ClassDef, nodes.FunctionDef))</span>
<span class="gi">+            and node.parent.doc_node</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;unnecessary-pass&quot;, node=node)</span>
<span class="gh">diff --git a/pylint/checkers/base_checker.py b/pylint/checkers/base_checker.py</span>
<span class="gh">index 7979baa3b..6d577e0bd 100644</span>
<span class="gd">--- a/pylint/checkers/base_checker.py</span>
<span class="gi">+++ b/pylint/checkers/base_checker.py</span>
<span class="gu">@@ -1,38 +1,57 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>import functools
<span class="w"> </span>from collections.abc import Iterable, Sequence
<span class="w"> </span>from inspect import cleandoc
<span class="w"> </span>from tokenize import TokenInfo
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.config.arguments_provider import _ArgumentsProvider
<span class="w"> </span>from pylint.constants import _MSG_ORDER, MAIN_CHECKER_NAME, WarningScope
<span class="w"> </span>from pylint.exceptions import InvalidMessageError
<span class="w"> </span>from pylint.interfaces import Confidence
<span class="w"> </span>from pylint.message.message_definition import MessageDefinition
<span class="gd">-from pylint.typing import ExtraMessageOptions, MessageDefinitionTuple, OptionDict, Options, ReportsCallable</span>
<span class="gi">+from pylint.typing import (</span>
<span class="gi">+    ExtraMessageOptions,</span>
<span class="gi">+    MessageDefinitionTuple,</span>
<span class="gi">+    OptionDict,</span>
<span class="gi">+    Options,</span>
<span class="gi">+    ReportsCallable,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.utils import get_rst_section, get_rst_title
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>@functools.total_ordering
<span class="w"> </span>class BaseChecker(_ArgumentsProvider):
<span class="gd">-    name: str = &#39;&#39;</span>
<span class="gi">+    # checker name (you may reuse an existing one)</span>
<span class="gi">+    name: str = &quot;&quot;</span>
<span class="gi">+    # ordered list of options to control the checker behaviour</span>
<span class="w"> </span>    options: Options = ()
<span class="gi">+    # messages issued by this checker</span>
<span class="w"> </span>    msgs: dict[str, MessageDefinitionTuple] = {}
<span class="gi">+    # reports issued by this checker</span>
<span class="w"> </span>    reports: tuple[tuple[str, str, ReportsCallable], ...] = ()
<span class="gi">+    # mark this checker as enabled or not.</span>
<span class="w"> </span>    enabled: bool = True

<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checker instances should have the linter as argument.&quot;&quot;&quot;
<span class="w"> </span>        if self.name is not None:
<span class="w"> </span>            self.name = self.name.lower()
<span class="w"> </span>        self.linter = linter
<span class="w"> </span>        _ArgumentsProvider.__init__(self, linter)

<span class="gd">-    def __gt__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __gt__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Permits sorting checkers for stable doc and tests.

<span class="w"> </span>        The main checker is always the first one, then builtin checkers in alphabetical
<span class="gu">@@ -44,37 +63,98 @@ class BaseChecker(_ArgumentsProvider):</span>
<span class="w"> </span>            return False
<span class="w"> </span>        if other.name == MAIN_CHECKER_NAME:
<span class="w"> </span>            return True
<span class="gd">-        self_is_builtin = type(self).__module__.startswith(&#39;pylint.checkers&#39;)</span>
<span class="gd">-        if self_is_builtin ^ type(other).__module__.startswith(</span>
<span class="gd">-            &#39;pylint.checkers&#39;):</span>
<span class="gi">+        self_is_builtin = type(self).__module__.startswith(&quot;pylint.checkers&quot;)</span>
<span class="gi">+        if self_is_builtin ^ type(other).__module__.startswith(&quot;pylint.checkers&quot;):</span>
<span class="w"> </span>            return not self_is_builtin
<span class="w"> </span>        return self.name &gt; other.name

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Permit to assert Checkers are equal.&quot;&quot;&quot;
<span class="w"> </span>        if not isinstance(other, BaseChecker):
<span class="w"> </span>            return False
<span class="gd">-        return f&#39;{self.name}{self.msgs}&#39; == f&#39;{other.name}{other.msgs}&#39;</span>
<span class="gi">+        return f&quot;{self.name}{self.msgs}&quot; == f&quot;{other.name}{other.msgs}&quot;</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Make Checker hashable.&quot;&quot;&quot;
<span class="gd">-        return hash(f&#39;{self.name}{self.msgs}&#39;)</span>
<span class="gi">+        return hash(f&quot;{self.name}{self.msgs}&quot;)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        status = &#39;Checker&#39; if self.enabled else &#39;Disabled checker&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        status = &quot;Checker&quot; if self.enabled else &quot;Disabled checker&quot;</span>
<span class="w"> </span>        msgs = &quot;&#39;, &#39;&quot;.join(self.msgs.keys())
<span class="w"> </span>        return f&quot;{status} &#39;{self.name}&#39; (responsible for &#39;{msgs}&#39;)&quot;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;This might be incomplete because multiple classes inheriting BaseChecker
<span class="w"> </span>        can have the same name.

<span class="w"> </span>        See: MessageHandlerMixIn.get_full_documentation()
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        return self.get_full_documentation(msgs=self.msgs, options=self.</span>
<span class="gd">-            _options_and_values(), reports=self.reports)</span>
<span class="gd">-</span>
<span class="gd">-    def check_consistency(self) -&gt;None:</span>
<span class="gi">+        return self.get_full_documentation(</span>
<span class="gi">+            msgs=self.msgs, options=self._options_and_values(), reports=self.reports</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_full_documentation(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgs: dict[str, MessageDefinitionTuple],</span>
<span class="gi">+        options: Iterable[tuple[str, OptionDict, Any]],</span>
<span class="gi">+        reports: Sequence[tuple[str, str, ReportsCallable]],</span>
<span class="gi">+        doc: str | None = None,</span>
<span class="gi">+        module: str | None = None,</span>
<span class="gi">+        show_options: bool = True,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        result = &quot;&quot;</span>
<span class="gi">+        checker_title = f&quot;{self.name.replace(&#39;_&#39;, &#39; &#39;).title()} checker&quot;</span>
<span class="gi">+        if module:</span>
<span class="gi">+            # Provide anchor to link against</span>
<span class="gi">+            result += f&quot;.. _{module}:\n\n&quot;</span>
<span class="gi">+        result += f&quot;{get_rst_title(checker_title, &#39;~&#39;)}\n&quot;</span>
<span class="gi">+        if module:</span>
<span class="gi">+            result += f&quot;This checker is provided by ``{module}``.\n&quot;</span>
<span class="gi">+        result += f&quot;Verbatim name of the checker is ``{self.name}``.\n\n&quot;</span>
<span class="gi">+        if doc:</span>
<span class="gi">+            # Provide anchor to link against</span>
<span class="gi">+            result += get_rst_title(f&quot;{checker_title} Documentation&quot;, &quot;^&quot;)</span>
<span class="gi">+            result += f&quot;{cleandoc(doc)}\n\n&quot;</span>
<span class="gi">+        # options might be an empty generator and not be False when cast to boolean</span>
<span class="gi">+        options_list = list(options)</span>
<span class="gi">+        if options_list:</span>
<span class="gi">+            if show_options:</span>
<span class="gi">+                result += get_rst_title(f&quot;{checker_title} Options&quot;, &quot;^&quot;)</span>
<span class="gi">+                result += f&quot;{get_rst_section(None, options_list)}\n&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                result += f&quot;See also :ref:`{self.name} checker&#39;s options&#39; documentation &lt;{self.name}-options&gt;`\n\n&quot;</span>
<span class="gi">+        if msgs:</span>
<span class="gi">+            result += get_rst_title(f&quot;{checker_title} Messages&quot;, &quot;^&quot;)</span>
<span class="gi">+            for msgid, msg in sorted(</span>
<span class="gi">+                msgs.items(), key=lambda kv: (_MSG_ORDER.index(kv[0][0]), kv[1])</span>
<span class="gi">+            ):</span>
<span class="gi">+                msg_def = self.create_message_definition_from_tuple(msgid, msg)</span>
<span class="gi">+                result += f&quot;{msg_def.format_help(checkerref=False)}\n&quot;</span>
<span class="gi">+            result += &quot;\n&quot;</span>
<span class="gi">+        if reports:</span>
<span class="gi">+            result += get_rst_title(f&quot;{checker_title} Reports&quot;, &quot;^&quot;)</span>
<span class="gi">+            for report in reports:</span>
<span class="gi">+                result += f&quot;:{report[0]}: {report[1]}\n&quot;</span>
<span class="gi">+            result += &quot;\n&quot;</span>
<span class="gi">+        result += &quot;\n&quot;</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def add_message(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        line: int | None = None,</span>
<span class="gi">+        node: nodes.NodeNG | None = None,</span>
<span class="gi">+        args: Any = None,</span>
<span class="gi">+        confidence: Confidence | None = None,</span>
<span class="gi">+        col_offset: int | None = None,</span>
<span class="gi">+        end_lineno: int | None = None,</span>
<span class="gi">+        end_col_offset: int | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.linter.add_message(</span>
<span class="gi">+            msgid, line, node, args, confidence, col_offset, end_lineno, end_col_offset</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def check_consistency(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check the consistency of msgid.

<span class="w"> </span>        msg ids for a checker should be a string of len 4, where the two first
<span class="gu">@@ -84,33 +164,85 @@ class BaseChecker(_ArgumentsProvider):</span>
<span class="w"> </span>        :raises InvalidMessageError: If the checker id in the messages are not
<span class="w"> </span>        always the same.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def open(self) -&gt;None:</span>
<span class="gi">+        checker_id = None</span>
<span class="gi">+        existing_ids = []</span>
<span class="gi">+        for message in self.messages:</span>
<span class="gi">+            # Id&#39;s for shared messages such as the &#39;deprecated-*&#39; messages</span>
<span class="gi">+            # can be inconsistent with their checker id.</span>
<span class="gi">+            if message.shared:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if checker_id is not None and checker_id != message.msgid[1:3]:</span>
<span class="gi">+                error_msg = &quot;Inconsistent checker part in message id &quot;</span>
<span class="gi">+                error_msg += f&quot;&#39;{message.msgid}&#39; (expected &#39;x{checker_id}xx&#39; &quot;</span>
<span class="gi">+                error_msg += f&quot;because we already had {existing_ids}).&quot;</span>
<span class="gi">+                raise InvalidMessageError(error_msg)</span>
<span class="gi">+            checker_id = message.msgid[1:3]</span>
<span class="gi">+            existing_ids.append(message.msgid)</span>
<span class="gi">+</span>
<span class="gi">+    def create_message_definition_from_tuple(</span>
<span class="gi">+        self, msgid: str, msg_tuple: MessageDefinitionTuple</span>
<span class="gi">+    ) -&gt; MessageDefinition:</span>
<span class="gi">+        if isinstance(self, (BaseTokenChecker, BaseRawFileChecker)):</span>
<span class="gi">+            default_scope = WarningScope.LINE</span>
<span class="gi">+        else:</span>
<span class="gi">+            default_scope = WarningScope.NODE</span>
<span class="gi">+        options: ExtraMessageOptions = {}</span>
<span class="gi">+        if len(msg_tuple) == 4:</span>
<span class="gi">+            (msg, symbol, descr, msg_options) = msg_tuple</span>
<span class="gi">+            options = ExtraMessageOptions(**msg_options)</span>
<span class="gi">+        elif len(msg_tuple) == 3:</span>
<span class="gi">+            (msg, symbol, descr) = msg_tuple</span>
<span class="gi">+        else:</span>
<span class="gi">+            error_msg = &quot;&quot;&quot;Messages should have a msgid, a symbol and a description. Something like this :</span>
<span class="gi">+</span>
<span class="gi">+&quot;W1234&quot;: (</span>
<span class="gi">+    &quot;message&quot;,</span>
<span class="gi">+    &quot;message-symbol&quot;,</span>
<span class="gi">+    &quot;Message description with detail.&quot;,</span>
<span class="gi">+    ...</span>
<span class="gi">+),</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+            raise InvalidMessageError(error_msg)</span>
<span class="gi">+        options.setdefault(&quot;scope&quot;, default_scope)</span>
<span class="gi">+        return MessageDefinition(self, msgid, msg, descr, symbol, **options)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def messages(self) -&gt; list[MessageDefinition]:</span>
<span class="gi">+        return [</span>
<span class="gi">+            self.create_message_definition_from_tuple(msgid, msg_tuple)</span>
<span class="gi">+            for msgid, msg_tuple in sorted(self.msgs.items())</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called before visiting project (i.e. set of modules).&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called after visiting project (i.e set of modules).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_map_data(self) -&gt; Any:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable-next=unused-argument</span>
<span class="gi">+    def reduce_map_data(self, linter: PyLinter, data: list[Any]) -&gt; None:</span>
<span class="gi">+        return None</span>


<span class="w"> </span>class BaseTokenChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Base class for checkers that want to have access to the token stream.&quot;&quot;&quot;

<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def process_tokens(self, tokens: list[TokenInfo]) -&gt;None:</span>
<span class="gi">+    def process_tokens(self, tokens: list[TokenInfo]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Should be overridden by subclasses.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>


<span class="w"> </span>class BaseRawFileChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Base class for checkers which need to parse the raw file.&quot;&quot;&quot;

<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def process_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+    def process_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process a module.

<span class="w"> </span>        The module&#39;s content is accessible via ``astroid.stream``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>
<span class="gh">diff --git a/pylint/checkers/classes/class_checker.py b/pylint/checkers/classes/class_checker.py</span>
<span class="gh">index 01bad6883..c3e1a081c 100644</span>
<span class="gd">--- a/pylint/checkers/classes/class_checker.py</span>
<span class="gi">+++ b/pylint/checkers/classes/class_checker.py</span>
<span class="gu">@@ -1,30 +1,67 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Classes checker for Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from collections.abc import Callable, Sequence
<span class="w"> </span>from functools import cached_property
<span class="w"> </span>from itertools import chain, zip_longest
<span class="w"> </span>from re import Pattern
<span class="w"> </span>from typing import TYPE_CHECKING, Any, NamedTuple, Union
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import bases, nodes, util
<span class="w"> </span>from astroid.nodes import LocalsDictNodeNG
<span class="w"> </span>from astroid.typing import SuccessfulInferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="gd">-from pylint.checkers.utils import PYMETHODS, class_is_abstract, decorated_with, decorated_with_property, get_outer_class, has_known_bases, is_attr_private, is_attr_protected, is_builtin_object, is_comprehension, is_iterable, is_property_setter, is_property_setter_or_deleter, node_frame_class, only_required_for_messages, safe_infer, unimplemented_abstract_methods, uninferable_final_decorators</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    PYMETHODS,</span>
<span class="gi">+    class_is_abstract,</span>
<span class="gi">+    decorated_with,</span>
<span class="gi">+    decorated_with_property,</span>
<span class="gi">+    get_outer_class,</span>
<span class="gi">+    has_known_bases,</span>
<span class="gi">+    is_attr_private,</span>
<span class="gi">+    is_attr_protected,</span>
<span class="gi">+    is_builtin_object,</span>
<span class="gi">+    is_comprehension,</span>
<span class="gi">+    is_iterable,</span>
<span class="gi">+    is_property_setter,</span>
<span class="gi">+    is_property_setter_or_deleter,</span>
<span class="gi">+    node_frame_class,</span>
<span class="gi">+    only_required_for_messages,</span>
<span class="gi">+    safe_infer,</span>
<span class="gi">+    unimplemented_abstract_methods,</span>
<span class="gi">+    uninferable_final_decorators,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.interfaces import HIGH, INFERENCE
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_AccessNodes = Union[nodes.Attribute, nodes.AssignAttr]
<span class="gd">-INVALID_BASE_CLASSES = {&#39;bool&#39;, &#39;range&#39;, &#39;slice&#39;, &#39;memoryview&#39;}</span>
<span class="gd">-ALLOWED_PROPERTIES = {&#39;bultins.property&#39;, &#39;functools.cached_property&#39;}</span>
<span class="gd">-BUILTIN_DECORATORS = {&#39;builtins.property&#39;, &#39;builtins.classmethod&#39;}</span>
<span class="gd">-ASTROID_TYPE_COMPARATORS = {nodes.Const: lambda a, b: a.value == b.value,</span>
<span class="gd">-    nodes.ClassDef: lambda a, b: a.qname == b.qname, nodes.Tuple: lambda a,</span>
<span class="gd">-    b: a.elts == b.elts, nodes.List: lambda a, b: a.elts == b.elts, nodes.</span>
<span class="gd">-    Dict: lambda a, b: a.items == b.items, nodes.Name: lambda a, b: set(a.</span>
<span class="gd">-    infer()) == set(b.infer())}</span>
<span class="gi">+</span>
<span class="gi">+INVALID_BASE_CLASSES = {&quot;bool&quot;, &quot;range&quot;, &quot;slice&quot;, &quot;memoryview&quot;}</span>
<span class="gi">+ALLOWED_PROPERTIES = {&quot;bultins.property&quot;, &quot;functools.cached_property&quot;}</span>
<span class="gi">+BUILTIN_DECORATORS = {&quot;builtins.property&quot;, &quot;builtins.classmethod&quot;}</span>
<span class="gi">+ASTROID_TYPE_COMPARATORS = {</span>
<span class="gi">+    nodes.Const: lambda a, b: a.value == b.value,</span>
<span class="gi">+    nodes.ClassDef: lambda a, b: a.qname == b.qname,</span>
<span class="gi">+    nodes.Tuple: lambda a, b: a.elts == b.elts,</span>
<span class="gi">+    nodes.List: lambda a, b: a.elts == b.elts,</span>
<span class="gi">+    nodes.Dict: lambda a, b: a.items == b.items,</span>
<span class="gi">+    nodes.Name: lambda a, b: set(a.infer()) == set(b.infer()),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+# Dealing with useless override detection, with regard</span>
<span class="gi">+# to parameters vs arguments</span>


<span class="w"> </span>class _CallSignature(NamedTuple):
<span class="gu">@@ -41,17 +78,131 @@ class _ParameterSignature(NamedTuple):</span>
<span class="w"> </span>    kwargs: str


<span class="gd">-def _definition_equivalent_to_call(definition: _ParameterSignature, call:</span>
<span class="gd">-    _CallSignature) -&gt;bool:</span>
<span class="gi">+def _signature_from_call(call: nodes.Call) -&gt; _CallSignature:</span>
<span class="gi">+    kws = {}</span>
<span class="gi">+    args = []</span>
<span class="gi">+    starred_kws = []</span>
<span class="gi">+    starred_args = []</span>
<span class="gi">+    for keyword in call.keywords or []:</span>
<span class="gi">+        arg, value = keyword.arg, keyword.value</span>
<span class="gi">+        if arg is None and isinstance(value, nodes.Name):</span>
<span class="gi">+            # Starred node, and we are interested only in names,</span>
<span class="gi">+            # otherwise some transformation might occur for the parameter.</span>
<span class="gi">+            starred_kws.append(value.name)</span>
<span class="gi">+        elif isinstance(value, nodes.Name):</span>
<span class="gi">+            kws[arg] = value.name</span>
<span class="gi">+        else:</span>
<span class="gi">+            kws[arg] = None</span>
<span class="gi">+</span>
<span class="gi">+    for arg in call.args:</span>
<span class="gi">+        if isinstance(arg, nodes.Starred) and isinstance(arg.value, nodes.Name):</span>
<span class="gi">+            # Positional variadic and a name, otherwise some transformation</span>
<span class="gi">+            # might have occurred.</span>
<span class="gi">+            starred_args.append(arg.value.name)</span>
<span class="gi">+        elif isinstance(arg, nodes.Name):</span>
<span class="gi">+            args.append(arg.name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            args.append(None)</span>
<span class="gi">+</span>
<span class="gi">+    return _CallSignature(args, kws, starred_args, starred_kws)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _signature_from_arguments(arguments: nodes.Arguments) -&gt; _ParameterSignature:</span>
<span class="gi">+    kwarg = arguments.kwarg</span>
<span class="gi">+    vararg = arguments.vararg</span>
<span class="gi">+    args = [</span>
<span class="gi">+        arg.name</span>
<span class="gi">+        for arg in chain(arguments.posonlyargs, arguments.args)</span>
<span class="gi">+        if arg.name != &quot;self&quot;</span>
<span class="gi">+    ]</span>
<span class="gi">+    kwonlyargs = [arg.name for arg in arguments.kwonlyargs]</span>
<span class="gi">+    return _ParameterSignature(args, kwonlyargs, vararg, kwarg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _definition_equivalent_to_call(</span>
<span class="gi">+    definition: _ParameterSignature, call: _CallSignature</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a definition signature is equivalent to a call.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _is_trivial_super_delegation(function: nodes.FunctionDef) -&gt;bool:</span>
<span class="gi">+    if definition.kwargs:</span>
<span class="gi">+        if definition.kwargs not in call.starred_kws:</span>
<span class="gi">+            return False</span>
<span class="gi">+    elif call.starred_kws:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if definition.varargs:</span>
<span class="gi">+        if definition.varargs not in call.starred_args:</span>
<span class="gi">+            return False</span>
<span class="gi">+    elif call.starred_args:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if any(kw not in call.kws for kw in definition.kwonlyargs):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if definition.args != call.args:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # No extra kwargs in call.</span>
<span class="gi">+    return all(kw in call.args or kw in definition.kwonlyargs for kw in call.kws)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_trivial_super_delegation(function: nodes.FunctionDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check whether a function definition is a method consisting only of a
<span class="w"> </span>    call to the same function on the superclass.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (</span>
<span class="gi">+        not function.is_method()</span>
<span class="gi">+        # Adding decorators to a function changes behavior and</span>
<span class="gi">+        # constitutes a non-trivial change.</span>
<span class="gi">+        or function.decorators</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    body = function.body</span>
<span class="gi">+    if len(body) != 1:</span>
<span class="gi">+        # Multiple statements, which means this overridden method</span>
<span class="gi">+        # could do multiple things we are not aware of.</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    statement = body[0]</span>
<span class="gi">+    if not isinstance(statement, (nodes.Expr, nodes.Return)):</span>
<span class="gi">+        # Doing something else than what we are interested in.</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    call = statement.value</span>
<span class="gi">+    if (</span>
<span class="gi">+        not isinstance(call, nodes.Call)</span>
<span class="gi">+        # Not a super() attribute access.</span>
<span class="gi">+        or not isinstance(call.func, nodes.Attribute)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Anything other than a super call is non-trivial.</span>
<span class="gi">+    super_call = safe_infer(call.func.expr)</span>
<span class="gi">+    if not isinstance(super_call, astroid.objects.Super):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # The name should be the same.</span>
<span class="gi">+    if call.func.attrname != function.name:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Should be a super call with the MRO pointer being the</span>
<span class="gi">+    # current class and the type being the current instance.</span>
<span class="gi">+    current_scope = function.parent.scope()</span>
<span class="gi">+    if (</span>
<span class="gi">+        super_call.mro_pointer != current_scope</span>
<span class="gi">+        or not isinstance(super_call.type, astroid.Instance)</span>
<span class="gi">+        or super_call.type.name != current_scope.name</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Deal with parameters overriding in two methods.</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _positional_parameters(method: nodes.FunctionDef) -&gt; list[nodes.AssignName]:</span>
<span class="gi">+    positional = method.args.args</span>
<span class="gi">+    if method.is_bound() and method.type in {&quot;classmethod&quot;, &quot;method&quot;}:</span>
<span class="gi">+        positional = positional[1:]</span>
<span class="gi">+    return positional  # type: ignore[no-any-return]</span>


<span class="w"> </span>class _DefaultMissing:
<span class="gu">@@ -61,8 +212,9 @@ class _DefaultMissing:</span>
<span class="w"> </span>_DEFAULT_MISSING = _DefaultMissing()


<span class="gd">-def _has_different_parameters_default_value(original: nodes.Arguments,</span>
<span class="gd">-    overridden: nodes.Arguments) -&gt;bool:</span>
<span class="gi">+def _has_different_parameters_default_value(</span>
<span class="gi">+    original: nodes.Arguments, overridden: nodes.Arguments</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if original and overridden methods arguments have different default values.

<span class="w"> </span>    Return True if one of the overridden arguments has a default
<span class="gu">@@ -70,17 +222,101 @@ def _has_different_parameters_default_value(original: nodes.Arguments,</span>
<span class="w"> </span>    If one of the method doesn&#39;t have argument (.args is None)
<span class="w"> </span>    return False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if original.args is None or overridden.args is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    for param in chain(original.args, original.kwonlyargs):</span>
<span class="gi">+        try:</span>
<span class="gi">+            original_default = original.default_value(param.name)</span>
<span class="gi">+        except astroid.exceptions.NoDefault:</span>
<span class="gi">+            original_default = _DEFAULT_MISSING</span>
<span class="gi">+        try:</span>
<span class="gi">+            overridden_default = overridden.default_value(param.name)</span>
<span class="gi">+            if original_default is _DEFAULT_MISSING:</span>
<span class="gi">+                # Only the original has a default.</span>
<span class="gi">+                return True</span>
<span class="gi">+        except astroid.exceptions.NoDefault:</span>
<span class="gi">+            if original_default is _DEFAULT_MISSING:</span>
<span class="gi">+                # Both have a default, no difference</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Only the override has a default.</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        original_type = type(original_default)</span>
<span class="gi">+        if not isinstance(overridden_default, original_type):</span>
<span class="gi">+            # Two args with same name but different types</span>
<span class="gi">+            return True</span>
<span class="gi">+        is_same_fn: Callable[[Any, Any], bool] | None = ASTROID_TYPE_COMPARATORS.get(</span>
<span class="gi">+            original_type</span>
<span class="gi">+        )</span>
<span class="gi">+        if is_same_fn is None:</span>
<span class="gi">+            # If the default value comparison is unhandled, assume the value is different</span>
<span class="gi">+            return True</span>
<span class="gi">+        if not is_same_fn(original_default, overridden_default):</span>
<span class="gi">+            # Two args with same type but different values</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def _has_different_keyword_only_parameters(original: list[nodes.AssignName],</span>
<span class="gd">-    overridden: list[nodes.AssignName]) -&gt;list[str]:</span>
<span class="gi">+def _has_different_parameters(</span>
<span class="gi">+    original: list[nodes.AssignName],</span>
<span class="gi">+    overridden: list[nodes.AssignName],</span>
<span class="gi">+    dummy_parameter_regex: Pattern[str],</span>
<span class="gi">+) -&gt; list[str]:</span>
<span class="gi">+    result: list[str] = []</span>
<span class="gi">+    zipped = zip_longest(original, overridden)</span>
<span class="gi">+    for original_param, overridden_param in zipped:</span>
<span class="gi">+        if not overridden_param:</span>
<span class="gi">+            return [&quot;Number of parameters &quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if not original_param:</span>
<span class="gi">+            try:</span>
<span class="gi">+                overridden_param.parent.default_value(overridden_param.name)</span>
<span class="gi">+                continue</span>
<span class="gi">+            except astroid.NoDefault:</span>
<span class="gi">+                return [&quot;Number of parameters &quot;]</span>
<span class="gi">+</span>
<span class="gi">+        # check for the arguments&#39; name</span>
<span class="gi">+        names = [param.name for param in (original_param, overridden_param)]</span>
<span class="gi">+        if any(dummy_parameter_regex.match(name) for name in names):</span>
<span class="gi">+            continue</span>
<span class="gi">+        if original_param.name != overridden_param.name:</span>
<span class="gi">+            result.append(</span>
<span class="gi">+                f&quot;Parameter &#39;{original_param.name}&#39; has been renamed &quot;</span>
<span class="gi">+                f&quot;to &#39;{overridden_param.name}&#39; in&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _has_different_keyword_only_parameters(</span>
<span class="gi">+    original: list[nodes.AssignName],</span>
<span class="gi">+    overridden: list[nodes.AssignName],</span>
<span class="gi">+) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine if the two methods have different keyword only parameters.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    original_names = [i.name for i in original]</span>
<span class="gi">+    overridden_names = [i.name for i in overridden]</span>
<span class="gi">+</span>
<span class="gi">+    if any(name not in overridden_names for name in original_names):</span>
<span class="gi">+        return [&quot;Number of parameters &quot;]</span>
<span class="gi">+</span>
<span class="gi">+    for name in overridden_names:</span>
<span class="gi">+        if name in original_names:</span>
<span class="gi">+            continue</span>

<span class="gi">+        try:</span>
<span class="gi">+            overridden[0].parent.default_value(name)</span>
<span class="gi">+        except astroid.NoDefault:</span>
<span class="gi">+            return [&quot;Number of parameters &quot;]</span>

<span class="gd">-def _different_parameters(original: nodes.FunctionDef, overridden: nodes.</span>
<span class="gd">-    FunctionDef, dummy_parameter_regex: Pattern[str]) -&gt;list[str]:</span>
<span class="gi">+    return []</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _different_parameters(</span>
<span class="gi">+    original: nodes.FunctionDef,</span>
<span class="gi">+    overridden: nodes.FunctionDef,</span>
<span class="gi">+    dummy_parameter_regex: Pattern[str],</span>
<span class="gi">+) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine if the two methods have different parameters.

<span class="w"> </span>    They are considered to have different parameters if:
<span class="gu">@@ -91,20 +327,125 @@ def _different_parameters(original: nodes.FunctionDef, overridden: nodes.</span>

<span class="w"> </span>       * they have different keyword only parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    output_messages = []</span>
<span class="gi">+    original_parameters = _positional_parameters(original)</span>
<span class="gi">+    overridden_parameters = _positional_parameters(overridden)</span>
<span class="gi">+</span>
<span class="gi">+    # Copy kwonlyargs list so that we don&#39;t affect later function linting</span>
<span class="gi">+    original_kwonlyargs = original.args.kwonlyargs</span>
<span class="gi">+</span>
<span class="gi">+    # Allow positional/keyword variadic in overridden to match against any</span>
<span class="gi">+    # positional/keyword argument in original.</span>
<span class="gi">+    # Keep any arguments that are found separately in overridden to satisfy</span>
<span class="gi">+    # later tests</span>
<span class="gi">+    if overridden.args.vararg:</span>
<span class="gi">+        overridden_names = [v.name for v in overridden_parameters]</span>
<span class="gi">+        original_parameters = [</span>
<span class="gi">+            v for v in original_parameters if v.name in overridden_names</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    if overridden.args.kwarg:</span>
<span class="gi">+        overridden_names = [v.name for v in overridden.args.kwonlyargs]</span>
<span class="gi">+        original_kwonlyargs = [</span>
<span class="gi">+            v for v in original.args.kwonlyargs if v.name in overridden_names</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    different_positional = _has_different_parameters(</span>
<span class="gi">+        original_parameters, overridden_parameters, dummy_parameter_regex</span>
<span class="gi">+    )</span>
<span class="gi">+    different_kwonly = _has_different_keyword_only_parameters(</span>
<span class="gi">+        original_kwonlyargs, overridden.args.kwonlyargs</span>
<span class="gi">+    )</span>
<span class="gi">+    if different_kwonly and different_positional:</span>
<span class="gi">+        if &quot;Number &quot; in different_positional[0] and &quot;Number &quot; in different_kwonly[0]:</span>
<span class="gi">+            output_messages.append(&quot;Number of parameters &quot;)</span>
<span class="gi">+            output_messages += different_positional[1:]</span>
<span class="gi">+            output_messages += different_kwonly[1:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            output_messages += different_positional</span>
<span class="gi">+            output_messages += different_kwonly</span>
<span class="gi">+    else:</span>
<span class="gi">+        if different_positional:</span>
<span class="gi">+            output_messages += different_positional</span>
<span class="gi">+        if different_kwonly:</span>
<span class="gi">+            output_messages += different_kwonly</span>
<span class="gi">+</span>
<span class="gi">+    # Arguments will only violate LSP if there are variadics in the original</span>
<span class="gi">+    # that are then removed from the overridden</span>
<span class="gi">+    kwarg_lost = original.args.kwarg and not overridden.args.kwarg</span>
<span class="gi">+    vararg_lost = original.args.vararg and not overridden.args.vararg</span>
<span class="gi">+</span>
<span class="gi">+    if kwarg_lost or vararg_lost:</span>
<span class="gi">+        output_messages += [&quot;Variadics removed in&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    if original.name in PYMETHODS:</span>
<span class="gi">+        # Ignore the difference for special methods. If the parameter</span>
<span class="gi">+        # numbers are different, then that is going to be caught by</span>
<span class="gi">+        # unexpected-special-method-signature.</span>
<span class="gi">+        # If the names are different, it doesn&#39;t matter, since they can&#39;t</span>
<span class="gi">+        # be used as keyword arguments anyway.</span>
<span class="gi">+        output_messages.clear()</span>
<span class="gi">+</span>
<span class="gi">+    return output_messages</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_invalid_base_class(cls: nodes.ClassDef) -&gt; bool:</span>
<span class="gi">+    return cls.name in INVALID_BASE_CLASSES and is_builtin_object(cls)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _has_data_descriptor(cls: nodes.ClassDef, attr: str) -&gt; bool:</span>
<span class="gi">+    attributes = cls.getattr(attr)</span>
<span class="gi">+    for attribute in attributes:</span>
<span class="gi">+        try:</span>
<span class="gi">+            for inferred in attribute.infer():</span>
<span class="gi">+                if isinstance(inferred, astroid.Instance):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        inferred.getattr(&quot;__get__&quot;)</span>
<span class="gi">+                        inferred.getattr(&quot;__set__&quot;)</span>
<span class="gi">+                    except astroid.NotFoundError:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        return True</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            # Can&#39;t infer, avoid emitting a false positive in this case.</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def _called_in_methods(func: LocalsDictNodeNG, klass: nodes.ClassDef,</span>
<span class="gd">-    methods: Sequence[str]) -&gt;bool:</span>
<span class="gi">+def _called_in_methods(</span>
<span class="gi">+    func: LocalsDictNodeNG,</span>
<span class="gi">+    klass: nodes.ClassDef,</span>
<span class="gi">+    methods: Sequence[str],</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the func was called in any of the given methods,
<span class="w"> </span>    belonging to the *klass*.

<span class="w"> </span>    Returns True if so, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(func, nodes.FunctionDef):</span>
<span class="gi">+        return False</span>
<span class="gi">+    for method in methods:</span>
<span class="gi">+        try:</span>
<span class="gi">+            inferred = klass.getattr(method)</span>
<span class="gi">+        except astroid.NotFoundError:</span>
<span class="gi">+            continue</span>
<span class="gi">+        for infer_method in inferred:</span>
<span class="gi">+            for call in infer_method.nodes_of_class(nodes.Call):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    bound = next(call.func.infer())</span>
<span class="gi">+                except (astroid.InferenceError, StopIteration):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if not isinstance(bound, astroid.BoundMethod):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                func_obj = bound._proxied</span>
<span class="gi">+                if isinstance(func_obj, astroid.UnboundMethod):</span>
<span class="gi">+                    func_obj = func_obj._proxied</span>
<span class="gi">+                if func_obj.name == func.name:</span>
<span class="gi">+                    return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def _is_attribute_property(name: str, klass: nodes.ClassDef) -&gt;bool:</span>
<span class="gi">+def _is_attribute_property(name: str, klass: nodes.ClassDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given attribute *name* is a property in the given *klass*.

<span class="w"> </span>    It will look for `property` calls or for functions
<span class="gu">@@ -113,147 +454,308 @@ def _is_attribute_property(name: str, klass: nodes.ClassDef) -&gt;bool:</span>
<span class="w"> </span>    Returns ``True`` if the name is a property in the given klass,
<span class="w"> </span>    ``False`` otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;F0202&#39;: (</span>
<span class="gd">-    &#39;Unable to check methods signature (%s / %s)&#39;, &#39;method-check-failed&#39;,</span>
<span class="gd">-    &quot;Used when Pylint has been unable to check methods signature compatibility for an unexpected reason. Please report this kind if you don&#39;t make sense of it.&quot;</span>
<span class="gd">-    ), &#39;E0202&#39;: (&#39;An attribute defined in %s line %s hides this method&#39;,</span>
<span class="gd">-    &#39;method-hidden&#39;,</span>
<span class="gd">-    &#39;Used when a class defines a method which is hidden by an instance attribute from an ancestor class or set by some client code.&#39;</span>
<span class="gd">-    ), &#39;E0203&#39;: (&#39;Access to member %r before its definition line %s&#39;,</span>
<span class="gd">-    &#39;access-member-before-definition&#39;,</span>
<span class="gd">-    &quot;Used when an instance member is accessed before it&#39;s actually assigned.&quot;</span>
<span class="gd">-    ), &#39;W0201&#39;: (&#39;Attribute %r defined outside __init__&#39;,</span>
<span class="gd">-    &#39;attribute-defined-outside-init&#39;,</span>
<span class="gd">-    &#39;Used when an instance attribute is defined outside the __init__ method.&#39;</span>
<span class="gd">-    ), &#39;W0212&#39;: (&#39;Access to a protected member %s of a client class&#39;,</span>
<span class="gd">-    &#39;protected-access&#39;,</span>
<span class="gd">-    &quot;Used when a protected member (i.e. class member with a name beginning with an underscore) is access outside the class or a descendant of the class where it&#39;s defined.&quot;</span>
<span class="gd">-    ), &#39;W0213&#39;: (</span>
<span class="gd">-    &#39;Flag member %(overlap)s shares bit positions with %(sources)s&#39;,</span>
<span class="gd">-    &#39;implicit-flag-alias&#39;,</span>
<span class="gd">-    &#39;Used when multiple integer values declared within an enum.IntFlag class share a common bit position.&#39;</span>
<span class="gd">-    ), &#39;E0211&#39;: (&#39;Method %r has no argument&#39;, &#39;no-method-argument&#39;,</span>
<span class="gd">-    &#39;Used when a method which should have the bound instance as first argument has no argument defined.&#39;</span>
<span class="gd">-    ), &#39;E0213&#39;: (&#39;Method %r should have &quot;self&quot; as first argument&#39;,</span>
<span class="gd">-    &#39;no-self-argument&#39;,</span>
<span class="gd">-    &#39;Used when a method has an attribute different the &quot;self&quot; as first argument. This is considered as an error since this is a so common convention that you shouldn\&#39;t break it!&#39;</span>
<span class="gd">-    ), &#39;C0202&#39;: (&#39;Class method %s should have %s as first argument&#39;,</span>
<span class="gd">-    &#39;bad-classmethod-argument&#39;,</span>
<span class="gd">-    &#39;Used when a class method has a first argument named differently than the value specified in valid-classmethod-first-arg option (default to &quot;cls&quot;), recommended to easily differentiate them from regular instance methods.&#39;</span>
<span class="gd">-    ), &#39;C0203&#39;: (&#39;Metaclass method %s should have %s as first argument&#39;,</span>
<span class="gd">-    &#39;bad-mcs-method-argument&#39;,</span>
<span class="gd">-    &#39;Used when a metaclass method has a first argument named differently than the value specified in valid-classmethod-first-arg option (default to &quot;cls&quot;), recommended to easily differentiate them from regular instance methods.&#39;</span>
<span class="gd">-    ), &#39;C0204&#39;: (</span>
<span class="gd">-    &#39;Metaclass class method %s should have %s as first argument&#39;,</span>
<span class="gd">-    &#39;bad-mcs-classmethod-argument&#39;,</span>
<span class="gd">-    &#39;Used when a metaclass class method has a first argument named differently than the value specified in valid-metaclass-classmethod-first-arg option (default to &quot;mcs&quot;), recommended to easily differentiate them from regular instance methods.&#39;</span>
<span class="gd">-    ), &#39;W0211&#39;: (&#39;Static method with %r as first argument&#39;,</span>
<span class="gd">-    &#39;bad-staticmethod-argument&#39;,</span>
<span class="gd">-    &#39;Used when a static method has &quot;self&quot; or a value specified in valid-classmethod-first-arg option or valid-metaclass-classmethod-first-arg option as first argument.&#39;</span>
<span class="gd">-    ), &#39;W0221&#39;: (&#39;%s %s %r method&#39;, &#39;arguments-differ&#39;,</span>
<span class="gd">-    &#39;Used when a method has a different number of arguments than in the implemented interface or in an overridden method. Extra arguments with default values are ignored.&#39;</span>
<span class="gd">-    ), &#39;W0222&#39;: (&#39;Signature differs from %s %r method&#39;, &#39;signature-differs&#39;,</span>
<span class="gd">-    &#39;Used when a method signature is different than in the implemented interface or in an overridden method.&#39;</span>
<span class="gd">-    ), &#39;W0223&#39;: (</span>
<span class="gd">-    &#39;Method %r is abstract in class %r but is not overridden in child class %r&#39;</span>
<span class="gd">-    , &#39;abstract-method&#39;,</span>
<span class="gd">-    &#39;Used when an abstract method (i.e. raise NotImplementedError) is not overridden in concrete class.&#39;</span>
<span class="gd">-    ), &#39;W0231&#39;: (&#39;__init__ method from base class %r is not called&#39;,</span>
<span class="gd">-    &#39;super-init-not-called&#39;,</span>
<span class="gd">-    &#39;Used when an ancestor class method has an __init__ method which is not called by a derived class.&#39;</span>
<span class="gd">-    ), &#39;W0233&#39;: (</span>
<span class="gd">-    &#39;__init__ method from a non direct base class %r is called&#39;,</span>
<span class="gd">-    &#39;non-parent-init-called&#39;,</span>
<span class="gd">-    &#39;Used when an __init__ method is called on a class which is not in the direct ancestors for the analysed class.&#39;</span>
<span class="gd">-    ), &#39;W0246&#39;: (&#39;Useless parent or super() delegation in method %r&#39;,</span>
<span class="gd">-    &#39;useless-parent-delegation&#39;,</span>
<span class="gd">-    &#39;Used whenever we can detect that an overridden method is useless, relying on parent or super() delegation to do the same thing as another method from the MRO.&#39;</span>
<span class="gd">-    , {&#39;old_names&#39;: [(&#39;W0235&#39;, &#39;useless-super-delegation&#39;)]}), &#39;W0236&#39;: (</span>
<span class="gd">-    &#39;Method %r was expected to be %r, found it instead as %r&#39;,</span>
<span class="gd">-    &#39;invalid-overridden-method&#39;,</span>
<span class="gd">-    &#39;Used when we detect that a method was overridden in a way that does not match its base class which could result in potential bugs at runtime.&#39;</span>
<span class="gd">-    ), &#39;W0237&#39;: (&#39;%s %s %r method&#39;, &#39;arguments-renamed&#39;,</span>
<span class="gd">-    &#39;Used when a method parameter has a different name than in the implemented interface or in an overridden method.&#39;</span>
<span class="gd">-    ), &#39;W0238&#39;: (&#39;Unused private member `%s.%s`&#39;, &#39;unused-private-member&#39;,</span>
<span class="gd">-    &#39;Emitted when a private member of a class is defined but not used.&#39;),</span>
<span class="gd">-    &#39;W0239&#39;: (</span>
<span class="gd">-    &#39;Method %r overrides a method decorated with typing.final which is defined in class %r&#39;</span>
<span class="gd">-    , &#39;overridden-final-method&#39;,</span>
<span class="gd">-    &#39;Used when a method decorated with typing.final has been overridden.&#39;),</span>
<span class="gd">-    &#39;W0240&#39;: (</span>
<span class="gd">-    &#39;Class %r is a subclass of a class decorated with typing.final: %r&#39;,</span>
<span class="gd">-    &#39;subclassed-final-class&#39;,</span>
<span class="gd">-    &#39;Used when a class decorated with typing.final has been subclassed.&#39;),</span>
<span class="gd">-    &#39;W0244&#39;: (&#39;Redefined slots %r in subclass&#39;,</span>
<span class="gd">-    &#39;redefined-slots-in-subclass&#39;,</span>
<span class="gd">-    &#39;Used when a slot is re-defined in a subclass.&#39;), &#39;W0245&#39;: (</span>
<span class="gd">-    &#39;Super call without brackets&#39;, &#39;super-without-brackets&#39;,</span>
<span class="gd">-    &#39;Used when a call to super does not have brackets and thus is not an actual call and does not work as expected.&#39;</span>
<span class="gd">-    ), &#39;E0236&#39;: (</span>
<span class="gd">-    &#39;Invalid object %r in __slots__, must contain only non empty strings&#39;,</span>
<span class="gd">-    &#39;invalid-slots-object&#39;,</span>
<span class="gd">-    &#39;Used when an invalid (non-string) object occurs in __slots__.&#39;),</span>
<span class="gd">-    &#39;E0237&#39;: (&#39;Assigning to attribute %r not defined in class slots&#39;,</span>
<span class="gd">-    &#39;assigning-non-slot&#39;,</span>
<span class="gd">-    &#39;Used when assigning to an attribute not defined in the class slots.&#39;),</span>
<span class="gd">-    &#39;E0238&#39;: (&#39;Invalid __slots__ object&#39;, &#39;invalid-slots&#39;,</span>
<span class="gd">-    &#39;Used when an invalid __slots__ is found in class. Only a string, an iterable or a sequence is permitted.&#39;</span>
<span class="gd">-    ), &#39;E0239&#39;: (&#39;Inheriting %r, which is not a class.&#39;,</span>
<span class="gd">-    &#39;inherit-non-class&#39;,</span>
<span class="gd">-    &#39;Used when a class inherits from something which is not a class.&#39;),</span>
<span class="gd">-    &#39;E0240&#39;: (&#39;Inconsistent method resolution order for class %r&#39;,</span>
<span class="gd">-    &#39;inconsistent-mro&#39;,</span>
<span class="gd">-    &#39;Used when a class has an inconsistent method resolution order.&#39;),</span>
<span class="gd">-    &#39;E0241&#39;: (&#39;Duplicate bases for class %r&#39;, &#39;duplicate-bases&#39;,</span>
<span class="gd">-    &#39;Duplicate use of base classes in derived classes raise TypeErrors.&#39;),</span>
<span class="gd">-    &#39;E0242&#39;: (&#39;Value %r in slots conflicts with class variable&#39;,</span>
<span class="gd">-    &#39;class-variable-slots-conflict&#39;,</span>
<span class="gd">-    &#39;Used when a value in __slots__ conflicts with a class variable, property or method.&#39;</span>
<span class="gd">-    ), &#39;E0243&#39;: (</span>
<span class="gd">-    &quot;Invalid assignment to &#39;__class__&#39;. Should be a class definition but got a &#39;%s&#39;&quot;</span>
<span class="gd">-    , &#39;invalid-class-object&#39;,</span>
<span class="gd">-    &#39;Used when an invalid object is assigned to a __class__ property. Only a class is permitted.&#39;</span>
<span class="gd">-    ), &#39;E0244&#39;: (&#39;Extending inherited Enum class &quot;%s&quot;&#39;,</span>
<span class="gd">-    &#39;invalid-enum-extension&#39;,</span>
<span class="gd">-    &#39;Used when a class tries to extend an inherited Enum class. Doing so will raise a TypeError at runtime.&#39;</span>
<span class="gd">-    ), &#39;R0202&#39;: (</span>
<span class="gd">-    &#39;Consider using a decorator instead of calling classmethod&#39;,</span>
<span class="gd">-    &#39;no-classmethod-decorator&#39;,</span>
<span class="gd">-    &#39;Used when a class method is defined without using the decorator syntax.&#39;</span>
<span class="gd">-    ), &#39;R0203&#39;: (</span>
<span class="gd">-    &#39;Consider using a decorator instead of calling staticmethod&#39;,</span>
<span class="gd">-    &#39;no-staticmethod-decorator&#39;,</span>
<span class="gd">-    &#39;Used when a static method is defined without using the decorator syntax.&#39;</span>
<span class="gd">-    ), &#39;C0205&#39;: (&#39;Class __slots__ should be a non-string iterable&#39;,</span>
<span class="gd">-    &#39;single-string-used-for-slots&#39;,</span>
<span class="gd">-    &#39;Used when a class __slots__ is a simple string, rather than an iterable.&#39;</span>
<span class="gd">-    ), &#39;R0205&#39;: (</span>
<span class="gd">-    &#39;Class %r inherits from object, can be safely removed from bases in python3&#39;</span>
<span class="gd">-    , &#39;useless-object-inheritance&#39;,</span>
<span class="gd">-    &#39;Used when a class inherit from object, which under python3 is implicit, hence can be safely removed from bases.&#39;</span>
<span class="gd">-    ), &#39;R0206&#39;: (&#39;Cannot have defined parameters for properties&#39;,</span>
<span class="gd">-    &#39;property-with-parameters&#39;,</span>
<span class="gd">-    &#39;Used when we detect that a property also has parameters, which are useless, given that properties cannot be called with additional arguments.&#39;</span>
<span class="gd">-    )}</span>
<span class="gi">+    try:</span>
<span class="gi">+        attributes = klass.getattr(name)</span>
<span class="gi">+    except astroid.NotFoundError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    property_name = &quot;builtins.property&quot;</span>
<span class="gi">+    for attr in attributes:</span>
<span class="gi">+        if isinstance(attr, util.UninferableBase):</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            inferred = next(attr.infer())</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(inferred, nodes.FunctionDef) and decorated_with_property(</span>
<span class="gi">+            inferred</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if inferred.pytype() != property_name:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        cls = node_frame_class(inferred)</span>
<span class="gi">+        if cls == klass.declared_metaclass():</span>
<span class="gi">+            continue</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _has_same_layout_slots(</span>
<span class="gi">+    slots: list[nodes.Const | None], assigned_value: nodes.Name</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    inferred = next(assigned_value.infer())</span>
<span class="gi">+    if isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+        other_slots = inferred.slots()</span>
<span class="gi">+        if all(</span>
<span class="gi">+            first_slot and second_slot and first_slot.value == second_slot.value</span>
<span class="gi">+            for (first_slot, second_slot) in zip_longest(slots, other_slots)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+    &quot;F0202&quot;: (</span>
<span class="gi">+        &quot;Unable to check methods signature (%s / %s)&quot;,</span>
<span class="gi">+        &quot;method-check-failed&quot;,</span>
<span class="gi">+        &quot;Used when Pylint has been unable to check methods signature &quot;</span>
<span class="gi">+        &quot;compatibility for an unexpected reason. Please report this kind &quot;</span>
<span class="gi">+        &quot;if you don&#39;t make sense of it.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0202&quot;: (</span>
<span class="gi">+        &quot;An attribute defined in %s line %s hides this method&quot;,</span>
<span class="gi">+        &quot;method-hidden&quot;,</span>
<span class="gi">+        &quot;Used when a class defines a method which is hidden by an &quot;</span>
<span class="gi">+        &quot;instance attribute from an ancestor class or set by some &quot;</span>
<span class="gi">+        &quot;client code.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0203&quot;: (</span>
<span class="gi">+        &quot;Access to member %r before its definition line %s&quot;,</span>
<span class="gi">+        &quot;access-member-before-definition&quot;,</span>
<span class="gi">+        &quot;Used when an instance member is accessed before it&#39;s actually assigned.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0201&quot;: (</span>
<span class="gi">+        &quot;Attribute %r defined outside __init__&quot;,</span>
<span class="gi">+        &quot;attribute-defined-outside-init&quot;,</span>
<span class="gi">+        &quot;Used when an instance attribute is defined outside the __init__ method.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0212&quot;: (</span>
<span class="gi">+        &quot;Access to a protected member %s of a client class&quot;,  # E0214</span>
<span class="gi">+        &quot;protected-access&quot;,</span>
<span class="gi">+        &quot;Used when a protected member (i.e. class member with a name &quot;</span>
<span class="gi">+        &quot;beginning with an underscore) is access outside the class or a &quot;</span>
<span class="gi">+        &quot;descendant of the class where it&#39;s defined.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0213&quot;: (</span>
<span class="gi">+        &quot;Flag member %(overlap)s shares bit positions with %(sources)s&quot;,</span>
<span class="gi">+        &quot;implicit-flag-alias&quot;,</span>
<span class="gi">+        &quot;Used when multiple integer values declared within an enum.IntFlag &quot;</span>
<span class="gi">+        &quot;class share a common bit position.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0211&quot;: (</span>
<span class="gi">+        &quot;Method %r has no argument&quot;,</span>
<span class="gi">+        &quot;no-method-argument&quot;,</span>
<span class="gi">+        &quot;Used when a method which should have the bound instance as &quot;</span>
<span class="gi">+        &quot;first argument has no argument defined.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0213&quot;: (</span>
<span class="gi">+        &#39;Method %r should have &quot;self&quot; as first argument&#39;,</span>
<span class="gi">+        &quot;no-self-argument&quot;,</span>
<span class="gi">+        &#39;Used when a method has an attribute different the &quot;self&quot; as &#39;</span>
<span class="gi">+        &quot;first argument. This is considered as an error since this is &quot;</span>
<span class="gi">+        &quot;a so common convention that you shouldn&#39;t break it!&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0202&quot;: (</span>
<span class="gi">+        &quot;Class method %s should have %s as first argument&quot;,</span>
<span class="gi">+        &quot;bad-classmethod-argument&quot;,</span>
<span class="gi">+        &quot;Used when a class method has a first argument named differently &quot;</span>
<span class="gi">+        &quot;than the value specified in valid-classmethod-first-arg option &quot;</span>
<span class="gi">+        &#39;(default to &quot;cls&quot;), recommended to easily differentiate them &#39;</span>
<span class="gi">+        &quot;from regular instance methods.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0203&quot;: (</span>
<span class="gi">+        &quot;Metaclass method %s should have %s as first argument&quot;,</span>
<span class="gi">+        &quot;bad-mcs-method-argument&quot;,</span>
<span class="gi">+        &quot;Used when a metaclass method has a first argument named &quot;</span>
<span class="gi">+        &quot;differently than the value specified in valid-classmethod-first&quot;</span>
<span class="gi">+        &#39;-arg option (default to &quot;cls&quot;), recommended to easily &#39;</span>
<span class="gi">+        &quot;differentiate them from regular instance methods.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0204&quot;: (</span>
<span class="gi">+        &quot;Metaclass class method %s should have %s as first argument&quot;,</span>
<span class="gi">+        &quot;bad-mcs-classmethod-argument&quot;,</span>
<span class="gi">+        &quot;Used when a metaclass class method has a first argument named &quot;</span>
<span class="gi">+        &quot;differently than the value specified in valid-metaclass-&quot;</span>
<span class="gi">+        &#39;classmethod-first-arg option (default to &quot;mcs&quot;), recommended to &#39;</span>
<span class="gi">+        &quot;easily differentiate them from regular instance methods.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0211&quot;: (</span>
<span class="gi">+        &quot;Static method with %r as first argument&quot;,</span>
<span class="gi">+        &quot;bad-staticmethod-argument&quot;,</span>
<span class="gi">+        &#39;Used when a static method has &quot;self&quot; or a value specified in &#39;</span>
<span class="gi">+        &quot;valid-classmethod-first-arg option or &quot;</span>
<span class="gi">+        &quot;valid-metaclass-classmethod-first-arg option as first argument.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0221&quot;: (</span>
<span class="gi">+        &quot;%s %s %r method&quot;,</span>
<span class="gi">+        &quot;arguments-differ&quot;,</span>
<span class="gi">+        &quot;Used when a method has a different number of arguments than in &quot;</span>
<span class="gi">+        &quot;the implemented interface or in an overridden method. Extra arguments &quot;</span>
<span class="gi">+        &quot;with default values are ignored.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0222&quot;: (</span>
<span class="gi">+        &quot;Signature differs from %s %r method&quot;,</span>
<span class="gi">+        &quot;signature-differs&quot;,</span>
<span class="gi">+        &quot;Used when a method signature is different than in the &quot;</span>
<span class="gi">+        &quot;implemented interface or in an overridden method.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0223&quot;: (</span>
<span class="gi">+        &quot;Method %r is abstract in class %r but is not overridden in child class %r&quot;,</span>
<span class="gi">+        &quot;abstract-method&quot;,</span>
<span class="gi">+        &quot;Used when an abstract method (i.e. raise NotImplementedError) is &quot;</span>
<span class="gi">+        &quot;not overridden in concrete class.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0231&quot;: (</span>
<span class="gi">+        &quot;__init__ method from base class %r is not called&quot;,</span>
<span class="gi">+        &quot;super-init-not-called&quot;,</span>
<span class="gi">+        &quot;Used when an ancestor class method has an __init__ method &quot;</span>
<span class="gi">+        &quot;which is not called by a derived class.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0233&quot;: (</span>
<span class="gi">+        &quot;__init__ method from a non direct base class %r is called&quot;,</span>
<span class="gi">+        &quot;non-parent-init-called&quot;,</span>
<span class="gi">+        &quot;Used when an __init__ method is called on a class which is not &quot;</span>
<span class="gi">+        &quot;in the direct ancestors for the analysed class.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0246&quot;: (</span>
<span class="gi">+        &quot;Useless parent or super() delegation in method %r&quot;,</span>
<span class="gi">+        &quot;useless-parent-delegation&quot;,</span>
<span class="gi">+        &quot;Used whenever we can detect that an overridden method is useless, &quot;</span>
<span class="gi">+        &quot;relying on parent or super() delegation to do the same thing as another method &quot;</span>
<span class="gi">+        &quot;from the MRO.&quot;,</span>
<span class="gi">+        {&quot;old_names&quot;: [(&quot;W0235&quot;, &quot;useless-super-delegation&quot;)]},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0236&quot;: (</span>
<span class="gi">+        &quot;Method %r was expected to be %r, found it instead as %r&quot;,</span>
<span class="gi">+        &quot;invalid-overridden-method&quot;,</span>
<span class="gi">+        &quot;Used when we detect that a method was overridden in a way &quot;</span>
<span class="gi">+        &quot;that does not match its base class &quot;</span>
<span class="gi">+        &quot;which could result in potential bugs at runtime.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0237&quot;: (</span>
<span class="gi">+        &quot;%s %s %r method&quot;,</span>
<span class="gi">+        &quot;arguments-renamed&quot;,</span>
<span class="gi">+        &quot;Used when a method parameter has a different name than in &quot;</span>
<span class="gi">+        &quot;the implemented interface or in an overridden method.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0238&quot;: (</span>
<span class="gi">+        &quot;Unused private member `%s.%s`&quot;,</span>
<span class="gi">+        &quot;unused-private-member&quot;,</span>
<span class="gi">+        &quot;Emitted when a private member of a class is defined but not used.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0239&quot;: (</span>
<span class="gi">+        &quot;Method %r overrides a method decorated with typing.final which is defined in class %r&quot;,</span>
<span class="gi">+        &quot;overridden-final-method&quot;,</span>
<span class="gi">+        &quot;Used when a method decorated with typing.final has been overridden.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0240&quot;: (</span>
<span class="gi">+        &quot;Class %r is a subclass of a class decorated with typing.final: %r&quot;,</span>
<span class="gi">+        &quot;subclassed-final-class&quot;,</span>
<span class="gi">+        &quot;Used when a class decorated with typing.final has been subclassed.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0244&quot;: (</span>
<span class="gi">+        &quot;Redefined slots %r in subclass&quot;,</span>
<span class="gi">+        &quot;redefined-slots-in-subclass&quot;,</span>
<span class="gi">+        &quot;Used when a slot is re-defined in a subclass.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0245&quot;: (</span>
<span class="gi">+        &quot;Super call without brackets&quot;,</span>
<span class="gi">+        &quot;super-without-brackets&quot;,</span>
<span class="gi">+        &quot;Used when a call to super does not have brackets and thus is not an actual &quot;</span>
<span class="gi">+        &quot;call and does not work as expected.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0236&quot;: (</span>
<span class="gi">+        &quot;Invalid object %r in __slots__, must contain only non empty strings&quot;,</span>
<span class="gi">+        &quot;invalid-slots-object&quot;,</span>
<span class="gi">+        &quot;Used when an invalid (non-string) object occurs in __slots__.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0237&quot;: (</span>
<span class="gi">+        &quot;Assigning to attribute %r not defined in class slots&quot;,</span>
<span class="gi">+        &quot;assigning-non-slot&quot;,</span>
<span class="gi">+        &quot;Used when assigning to an attribute not defined in the class slots.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0238&quot;: (</span>
<span class="gi">+        &quot;Invalid __slots__ object&quot;,</span>
<span class="gi">+        &quot;invalid-slots&quot;,</span>
<span class="gi">+        &quot;Used when an invalid __slots__ is found in class. &quot;</span>
<span class="gi">+        &quot;Only a string, an iterable or a sequence is permitted.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0239&quot;: (</span>
<span class="gi">+        &quot;Inheriting %r, which is not a class.&quot;,</span>
<span class="gi">+        &quot;inherit-non-class&quot;,</span>
<span class="gi">+        &quot;Used when a class inherits from something which is not a class.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0240&quot;: (</span>
<span class="gi">+        &quot;Inconsistent method resolution order for class %r&quot;,</span>
<span class="gi">+        &quot;inconsistent-mro&quot;,</span>
<span class="gi">+        &quot;Used when a class has an inconsistent method resolution order.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0241&quot;: (</span>
<span class="gi">+        &quot;Duplicate bases for class %r&quot;,</span>
<span class="gi">+        &quot;duplicate-bases&quot;,</span>
<span class="gi">+        &quot;Duplicate use of base classes in derived classes raise TypeErrors.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0242&quot;: (</span>
<span class="gi">+        &quot;Value %r in slots conflicts with class variable&quot;,</span>
<span class="gi">+        &quot;class-variable-slots-conflict&quot;,</span>
<span class="gi">+        &quot;Used when a value in __slots__ conflicts with a class variable, property or method.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0243&quot;: (</span>
<span class="gi">+        &quot;Invalid assignment to &#39;__class__&#39;. Should be a class definition but got a &#39;%s&#39;&quot;,</span>
<span class="gi">+        &quot;invalid-class-object&quot;,</span>
<span class="gi">+        &quot;Used when an invalid object is assigned to a __class__ property. &quot;</span>
<span class="gi">+        &quot;Only a class is permitted.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0244&quot;: (</span>
<span class="gi">+        &#39;Extending inherited Enum class &quot;%s&quot;&#39;,</span>
<span class="gi">+        &quot;invalid-enum-extension&quot;,</span>
<span class="gi">+        &quot;Used when a class tries to extend an inherited Enum class. &quot;</span>
<span class="gi">+        &quot;Doing so will raise a TypeError at runtime.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;R0202&quot;: (</span>
<span class="gi">+        &quot;Consider using a decorator instead of calling classmethod&quot;,</span>
<span class="gi">+        &quot;no-classmethod-decorator&quot;,</span>
<span class="gi">+        &quot;Used when a class method is defined without using the decorator syntax.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;R0203&quot;: (</span>
<span class="gi">+        &quot;Consider using a decorator instead of calling staticmethod&quot;,</span>
<span class="gi">+        &quot;no-staticmethod-decorator&quot;,</span>
<span class="gi">+        &quot;Used when a static method is defined without using the decorator syntax.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0205&quot;: (</span>
<span class="gi">+        &quot;Class __slots__ should be a non-string iterable&quot;,</span>
<span class="gi">+        &quot;single-string-used-for-slots&quot;,</span>
<span class="gi">+        &quot;Used when a class __slots__ is a simple string, rather than an iterable.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;R0205&quot;: (</span>
<span class="gi">+        &quot;Class %r inherits from object, can be safely removed from bases in python3&quot;,</span>
<span class="gi">+        &quot;useless-object-inheritance&quot;,</span>
<span class="gi">+        &quot;Used when a class inherit from object, which under python3 is implicit, &quot;</span>
<span class="gi">+        &quot;hence can be safely removed from bases.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;R0206&quot;: (</span>
<span class="gi">+        &quot;Cannot have defined parameters for properties&quot;,</span>
<span class="gi">+        &quot;property-with-parameters&quot;,</span>
<span class="gi">+        &quot;Used when we detect that a property also has parameters, which are useless, &quot;</span>
<span class="gi">+        &quot;given that properties cannot be called with additional arguments.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _scope_default() -&gt; defaultdict[str, list[_AccessNodes]]:</span>
<span class="gi">+    # It&#39;s impossible to nest defaultdicts so we must use a function</span>
<span class="gi">+    return defaultdict(list)</span>


<span class="w"> </span>class ScopeAccessMap:
<span class="w"> </span>    &quot;&quot;&quot;Store the accessed variables per scope.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self._scopes: defaultdict[nodes.ClassDef, defaultdict[str, list[</span>
<span class="gd">-            _AccessNodes]]] = defaultdict(_scope_default)</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self._scopes: defaultdict[</span>
<span class="gi">+            nodes.ClassDef, defaultdict[str, list[_AccessNodes]]</span>
<span class="gi">+        ] = defaultdict(_scope_default)</span>

<span class="gd">-    def set_accessed(self, node: _AccessNodes) -&gt;None:</span>
<span class="gi">+    def set_accessed(self, node: _AccessNodes) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the given node as accessed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        frame = node_frame_class(node)</span>
<span class="gi">+        if frame is None:</span>
<span class="gi">+            # The node does not live in a class.</span>
<span class="gi">+            return</span>
<span class="gi">+        self._scopes[frame][node.attrname].append(node)</span>

<span class="gd">-    def accessed(self, scope: nodes.ClassDef) -&gt;dict[str, list[_AccessNodes]]:</span>
<span class="gi">+    def accessed(self, scope: nodes.ClassDef) -&gt; dict[str, list[_AccessNodes]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the accessed variables for the given scope.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._scopes.get(scope, {})</span>


<span class="w"> </span>class ClassChecker(BaseChecker):
<span class="gu">@@ -266,78 +768,557 @@ class ClassChecker(BaseChecker):</span>
<span class="w"> </span>    * attributes not defined in the __init__ method
<span class="w"> </span>    * unreachable code
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;classes&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;classes&quot;</span>
<span class="gi">+    # messages</span>
<span class="w"> </span>    msgs = MSGS
<span class="gd">-    options = (&#39;defining-attr-methods&#39;, {&#39;default&#39;: (&#39;__init__&#39;, &#39;__new__&#39;,</span>
<span class="gd">-        &#39;setUp&#39;, &#39;asyncSetUp&#39;, &#39;__post_init__&#39;), &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;method names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of method names used to declare (i.e. assign) instance attributes.&#39;</span>
<span class="gd">-        }), (&#39;valid-classmethod-first-arg&#39;, {&#39;default&#39;: (&#39;cls&#39;,), &#39;type&#39;:</span>
<span class="gd">-        &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;argument names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of valid names for the first argument in a class method.&#39;}), (</span>
<span class="gd">-        &#39;valid-metaclass-classmethod-first-arg&#39;, {&#39;default&#39;: (&#39;mcs&#39;,),</span>
<span class="gd">-        &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;argument names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of valid names for the first argument in a metaclass class method.&#39;</span>
<span class="gd">-        }), (&#39;exclude-protected&#39;, {&#39;default&#39;: (&#39;_asdict&#39;, &#39;_fields&#39;,</span>
<span class="gd">-        &#39;_replace&#39;, &#39;_source&#39;, &#39;_make&#39;, &#39;os._exit&#39;), &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;protected access exclusions&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of member names, which should be excluded from the protected access warning.&#39;</span>
<span class="gd">-        }), (&#39;check-protected-access-in-special-methods&#39;, {&#39;default&#39;: False,</span>
<span class="gd">-        &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Warn about protected attribute access inside special methods&#39;})</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    # configuration options</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;defining-attr-methods&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (</span>
<span class="gi">+                    &quot;__init__&quot;,</span>
<span class="gi">+                    &quot;__new__&quot;,</span>
<span class="gi">+                    &quot;setUp&quot;,</span>
<span class="gi">+                    &quot;asyncSetUp&quot;,</span>
<span class="gi">+                    &quot;__post_init__&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;method names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of method names used to declare (i.e. assign) \</span>
<span class="gi">+instance attributes.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;valid-classmethod-first-arg&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (&quot;cls&quot;,),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;argument names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of valid names for the first argument in \</span>
<span class="gi">+a class method.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;valid-metaclass-classmethod-first-arg&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (&quot;mcs&quot;,),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;argument names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of valid names for the first argument in \</span>
<span class="gi">+a metaclass class method.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;exclude-protected&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (</span>
<span class="gi">+                    # namedtuple public API.</span>
<span class="gi">+                    &quot;_asdict&quot;,</span>
<span class="gi">+                    &quot;_fields&quot;,</span>
<span class="gi">+                    &quot;_replace&quot;,</span>
<span class="gi">+                    &quot;_source&quot;,</span>
<span class="gi">+                    &quot;_make&quot;,</span>
<span class="gi">+                    &quot;os._exit&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;protected access exclusions&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;List of member names, which should be excluded &quot;</span>
<span class="gi">+                    &quot;from the protected access warning.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;check-protected-access-in-special-methods&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Warn about protected attribute access inside special methods&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="w"> </span>        self._accessed = ScopeAccessMap()
<span class="w"> </span>        self._first_attrs: list[str | None] = []

<span class="gd">-    @only_required_for_messages(&#39;abstract-method&#39;, &#39;invalid-slots&#39;,</span>
<span class="gd">-        &#39;single-string-used-for-slots&#39;, &#39;invalid-slots-object&#39;,</span>
<span class="gd">-        &#39;class-variable-slots-conflict&#39;, &#39;inherit-non-class&#39;,</span>
<span class="gd">-        &#39;useless-object-inheritance&#39;, &#39;inconsistent-mro&#39;, &#39;duplicate-bases&#39;,</span>
<span class="gd">-        &#39;redefined-slots-in-subclass&#39;, &#39;invalid-enum-extension&#39;,</span>
<span class="gd">-        &#39;subclassed-final-class&#39;, &#39;implicit-flag-alias&#39;)</span>
<span class="gd">-    def visit_classdef(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        self._mixin_class_rgx = self.linter.config.mixin_class_rgx</span>
<span class="gi">+        py_version = self.linter.config.py_version</span>
<span class="gi">+        self._py38_plus = py_version &gt;= (3, 8)</span>
<span class="gi">+</span>
<span class="gi">+    @cached_property</span>
<span class="gi">+    def _dummy_rgx(self) -&gt; Pattern[str]:</span>
<span class="gi">+        return self.linter.config.dummy_variables_rgx  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;abstract-method&quot;,</span>
<span class="gi">+        &quot;invalid-slots&quot;,</span>
<span class="gi">+        &quot;single-string-used-for-slots&quot;,</span>
<span class="gi">+        &quot;invalid-slots-object&quot;,</span>
<span class="gi">+        &quot;class-variable-slots-conflict&quot;,</span>
<span class="gi">+        &quot;inherit-non-class&quot;,</span>
<span class="gi">+        &quot;useless-object-inheritance&quot;,</span>
<span class="gi">+        &quot;inconsistent-mro&quot;,</span>
<span class="gi">+        &quot;duplicate-bases&quot;,</span>
<span class="gi">+        &quot;redefined-slots-in-subclass&quot;,</span>
<span class="gi">+        &quot;invalid-enum-extension&quot;,</span>
<span class="gi">+        &quot;subclassed-final-class&quot;,</span>
<span class="gi">+        &quot;implicit-flag-alias&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Init visit variable _accessed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_bases_classes(node)</span>
<span class="gi">+        self._check_slots(node)</span>
<span class="gi">+        self._check_proper_bases(node)</span>
<span class="gi">+        self._check_typing_final(node)</span>
<span class="gi">+        self._check_consistent_mro(node)</span>

<span class="gd">-    def _check_consistent_mro(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    def _check_consistent_mro(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Detect that a class has a consistent mro or duplicate bases.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_proper_bases(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            node.mro()</span>
<span class="gi">+        except astroid.InconsistentMroError:</span>
<span class="gi">+            self.add_message(&quot;inconsistent-mro&quot;, args=node.name, node=node)</span>
<span class="gi">+        except astroid.DuplicateBasesError:</span>
<span class="gi">+            self.add_message(&quot;duplicate-bases&quot;, args=node.name, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_enum_base(self, node: nodes.ClassDef, ancestor: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        members = ancestor.getattr(&quot;__members__&quot;)</span>
<span class="gi">+        if members and isinstance(members[0], nodes.Dict) and members[0].items:</span>
<span class="gi">+            for _, name_node in members[0].items:</span>
<span class="gi">+                # Exempt type annotations without value assignments</span>
<span class="gi">+                if all(</span>
<span class="gi">+                    isinstance(item.parent, nodes.AnnAssign)</span>
<span class="gi">+                    and item.parent.value is None</span>
<span class="gi">+                    for item in ancestor.getattr(name_node.name)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;invalid-enum-extension&quot;,</span>
<span class="gi">+                    args=ancestor.name,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if ancestor.is_subtype_of(&quot;enum.IntFlag&quot;):</span>
<span class="gi">+            # Collect integer flag assignments present on the class</span>
<span class="gi">+            assignments = defaultdict(list)</span>
<span class="gi">+            for assign_name in node.nodes_of_class(nodes.AssignName):</span>
<span class="gi">+                if isinstance(assign_name.parent, nodes.Assign):</span>
<span class="gi">+                    value = getattr(assign_name.parent.value, &quot;value&quot;, None)</span>
<span class="gi">+                    if isinstance(value, int):</span>
<span class="gi">+                        assignments[value].append(assign_name)</span>
<span class="gi">+</span>
<span class="gi">+            # For each bit position, collect all the flags that set the bit</span>
<span class="gi">+            bit_flags = defaultdict(set)</span>
<span class="gi">+            for flag in assignments:</span>
<span class="gi">+                flag_bits = (i for i, c in enumerate(reversed(bin(flag))) if c == &quot;1&quot;)</span>
<span class="gi">+                for bit in flag_bits:</span>
<span class="gi">+                    bit_flags[bit].add(flag)</span>
<span class="gi">+</span>
<span class="gi">+            # Collect the minimum, unique values that each flag overlaps with</span>
<span class="gi">+            overlaps = defaultdict(list)</span>
<span class="gi">+            for flags in bit_flags.values():</span>
<span class="gi">+                source, *conflicts = sorted(flags)</span>
<span class="gi">+                for conflict in conflicts:</span>
<span class="gi">+                    overlaps[conflict].append(source)</span>
<span class="gi">+</span>
<span class="gi">+            # Report the overlapping values</span>
<span class="gi">+            for overlap in overlaps:</span>
<span class="gi">+                for assignment_node in assignments[overlap]:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;implicit-flag-alias&quot;,</span>
<span class="gi">+                        node=assignment_node,</span>
<span class="gi">+                        args={</span>
<span class="gi">+                            &quot;overlap&quot;: f&quot;&lt;{node.name}.{assignment_node.name}: {overlap}&gt;&quot;,</span>
<span class="gi">+                            &quot;sources&quot;: &quot;, &quot;.join(</span>
<span class="gi">+                                f&quot;&lt;{node.name}.{assignments[source][0].name}: {source}&gt; &quot;</span>
<span class="gi">+                                f&quot;({overlap} &amp; {source} = {overlap &amp; source})&quot;</span>
<span class="gi">+                                for source in overlaps[overlap]</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        },</span>
<span class="gi">+                        confidence=INFERENCE,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_proper_bases(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Detect that a class inherits something which is not
<span class="w"> </span>        a class or a type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_typing_final(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+        for base in node.bases:</span>
<span class="gi">+            ancestor = safe_infer(base)</span>
<span class="gi">+            if not ancestor:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if isinstance(ancestor, astroid.Instance) and (</span>
<span class="gi">+                ancestor.is_subtype_of(&quot;builtins.type&quot;)</span>
<span class="gi">+                or ancestor.is_subtype_of(&quot;.Protocol&quot;)</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not isinstance(ancestor, nodes.ClassDef) or _is_invalid_base_class(</span>
<span class="gi">+                ancestor</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;inherit-non-class&quot;, args=base.as_string(), node=node)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(ancestor, nodes.ClassDef) and ancestor.is_subtype_of(</span>
<span class="gi">+                &quot;enum.Enum&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                self._check_enum_base(node, ancestor)</span>
<span class="gi">+</span>
<span class="gi">+            if ancestor.name == object.__name__:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;useless-object-inheritance&quot;, args=node.name, node=node</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_typing_final(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Detect that a class does not subclass a class decorated with
<span class="w"> </span>        `typing.final`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @only_required_for_messages(&#39;unused-private-member&#39;,</span>
<span class="gd">-        &#39;attribute-defined-outside-init&#39;, &#39;access-member-before-definition&#39;)</span>
<span class="gd">-    def leave_classdef(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+        if not self._py38_plus:</span>
<span class="gi">+            return</span>
<span class="gi">+        for base in node.bases:</span>
<span class="gi">+            ancestor = safe_infer(base)</span>
<span class="gi">+            if not ancestor:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(ancestor, nodes.ClassDef) and (</span>
<span class="gi">+                decorated_with(ancestor, [&quot;typing.final&quot;])</span>
<span class="gi">+                or uninferable_final_decorators(ancestor.decorators)</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;subclassed-final-class&quot;,</span>
<span class="gi">+                    args=(node.name, ancestor.name),</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;unused-private-member&quot;,</span>
<span class="gi">+        &quot;attribute-defined-outside-init&quot;,</span>
<span class="gi">+        &quot;access-member-before-definition&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def leave_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checker for Class nodes.

<span class="w"> </span>        check that instance attributes are defined in __init__ and check
<span class="w"> </span>        access to existent members
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_unused_private_variables(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+        self._check_unused_private_functions(node)</span>
<span class="gi">+        self._check_unused_private_variables(node)</span>
<span class="gi">+        self._check_unused_private_attributes(node)</span>
<span class="gi">+        self._check_attribute_defined_outside_init(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_unused_private_functions(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        for function_def in node.nodes_of_class(nodes.FunctionDef):</span>
<span class="gi">+            if not is_attr_private(function_def.name):</span>
<span class="gi">+                continue</span>
<span class="gi">+            parent_scope = function_def.parent.scope()</span>
<span class="gi">+            if isinstance(parent_scope, nodes.FunctionDef):</span>
<span class="gi">+                # Handle nested functions</span>
<span class="gi">+                if function_def.name in (</span>
<span class="gi">+                    n.name for n in parent_scope.nodes_of_class(nodes.Name)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+            for child in node.nodes_of_class((nodes.Name, nodes.Attribute)):</span>
<span class="gi">+                # Check for cases where the functions are used as a variable instead of as a</span>
<span class="gi">+                # method call</span>
<span class="gi">+                if isinstance(child, nodes.Name) and child.name == function_def.name:</span>
<span class="gi">+                    break</span>
<span class="gi">+                if isinstance(child, nodes.Attribute):</span>
<span class="gi">+                    # Ignore recursive calls</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        child.attrname != function_def.name</span>
<span class="gi">+                        or child.scope() == function_def</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    # Check self.__attrname, cls.__attrname, node_name.__attrname</span>
<span class="gi">+                    if isinstance(child.expr, nodes.Name) and child.expr.name in {</span>
<span class="gi">+                        &quot;self&quot;,</span>
<span class="gi">+                        &quot;cls&quot;,</span>
<span class="gi">+                        node.name,</span>
<span class="gi">+                    }:</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+                    # Check type(self).__attrname</span>
<span class="gi">+                    if isinstance(child.expr, nodes.Call):</span>
<span class="gi">+                        inferred = safe_infer(child.expr)</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            isinstance(inferred, nodes.ClassDef)</span>
<span class="gi">+                            and inferred.name == node.name</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            break</span>
<span class="gi">+            else:</span>
<span class="gi">+                name_stack = []</span>
<span class="gi">+                curr = parent_scope</span>
<span class="gi">+                # Generate proper names for nested functions</span>
<span class="gi">+                while curr != node:</span>
<span class="gi">+                    name_stack.append(curr.name)</span>
<span class="gi">+                    curr = curr.parent.scope()</span>
<span class="gi">+</span>
<span class="gi">+                outer_level_names = f&quot;{&#39;.&#39;.join(reversed(name_stack))}&quot;</span>
<span class="gi">+                function_repr = f&quot;{outer_level_names}.{function_def.name}({function_def.args.as_string()})&quot;</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;unused-private-member&quot;,</span>
<span class="gi">+                    node=function_def,</span>
<span class="gi">+                    args=(node.name, function_repr.lstrip(&quot;.&quot;)),</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_unused_private_variables(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if private variables are never used within a class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+        for assign_name in node.nodes_of_class(nodes.AssignName):</span>
<span class="gi">+            if isinstance(assign_name.parent, nodes.Arguments):</span>
<span class="gi">+                continue  # Ignore function arguments</span>
<span class="gi">+            if not is_attr_private(assign_name.name):</span>
<span class="gi">+                continue</span>
<span class="gi">+            for child in node.nodes_of_class((nodes.Name, nodes.Attribute)):</span>
<span class="gi">+                if isinstance(child, nodes.Name) and child.name == assign_name.name:</span>
<span class="gi">+                    break</span>
<span class="gi">+                if isinstance(child, nodes.Attribute):</span>
<span class="gi">+                    if not isinstance(child.expr, nodes.Name):</span>
<span class="gi">+                        break</span>
<span class="gi">+                    if child.attrname == assign_name.name and child.expr.name in (</span>
<span class="gi">+                        &quot;self&quot;,</span>
<span class="gi">+                        &quot;cls&quot;,</span>
<span class="gi">+                        node.name,</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        break</span>
<span class="gi">+            else:</span>
<span class="gi">+                args = (node.name, assign_name.name)</span>
<span class="gi">+                self.add_message(&quot;unused-private-member&quot;, node=assign_name, args=args)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_unused_private_attributes(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        for assign_attr in node.nodes_of_class(nodes.AssignAttr):</span>
<span class="gi">+            if not is_attr_private(assign_attr.attrname) or not isinstance(</span>
<span class="gi">+                assign_attr.expr, nodes.Name</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Logic for checking false positive when using __new__,</span>
<span class="gi">+            # Get the returned object names of the __new__ magic function</span>
<span class="gi">+            # Then check if the attribute was consumed in other instance methods</span>
<span class="gi">+            acceptable_obj_names: list[str] = [&quot;self&quot;]</span>
<span class="gi">+            scope = assign_attr.scope()</span>
<span class="gi">+            if isinstance(scope, nodes.FunctionDef) and scope.name == &quot;__new__&quot;:</span>
<span class="gi">+                acceptable_obj_names.extend(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        return_node.value.name</span>
<span class="gi">+                        for return_node in scope.nodes_of_class(nodes.Return)</span>
<span class="gi">+                        if isinstance(return_node.value, nodes.Name)</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            for attribute in node.nodes_of_class(nodes.Attribute):</span>
<span class="gi">+                if attribute.attrname != assign_attr.attrname:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if not isinstance(attribute.expr, nodes.Name):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if assign_attr.expr.name in {</span>
<span class="gi">+                    &quot;cls&quot;,</span>
<span class="gi">+                    node.name,</span>
<span class="gi">+                } and attribute.expr.name in {&quot;cls&quot;, &quot;self&quot;, node.name}:</span>
<span class="gi">+                    # If assigned to cls or class name, can be accessed by cls/self/class name</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+                if (</span>
<span class="gi">+                    assign_attr.expr.name in acceptable_obj_names</span>
<span class="gi">+                    and attribute.expr.name == &quot;self&quot;</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # If assigned to self.attrib, can only be accessed by self</span>
<span class="gi">+                    # Or if __new__ was used, the returned object names are acceptable</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+                if assign_attr.expr.name == attribute.expr.name == node.name:</span>
<span class="gi">+                    # Recognise attributes which are accessed via the class name</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                args = (node.name, assign_attr.attrname)</span>
<span class="gi">+                self.add_message(&quot;unused-private-member&quot;, node=assign_attr, args=args)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_attribute_defined_outside_init(self, cnode: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        # check access to existent members on non metaclass classes</span>
<span class="gi">+        if (</span>
<span class="gi">+            &quot;attribute-defined-outside-init&quot;</span>
<span class="gi">+            in self.linter.config.ignored_checks_for_mixins</span>
<span class="gi">+            and self._mixin_class_rgx.match(cnode.name)</span>
<span class="gi">+        ):</span>
<span class="gi">+            # We are in a mixin class. No need to try to figure out if</span>
<span class="gi">+            # something is missing, since it is most likely that it will</span>
<span class="gi">+            # miss.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        accessed = self._accessed.accessed(cnode)</span>
<span class="gi">+        if cnode.type != &quot;metaclass&quot;:</span>
<span class="gi">+            self._check_accessed_members(cnode, accessed)</span>
<span class="gi">+        # checks attributes are defined in an allowed method such as __init__</span>
<span class="gi">+        if not self.linter.is_message_enabled(&quot;attribute-defined-outside-init&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        defining_methods = self.linter.config.defining_attr_methods</span>
<span class="gi">+        current_module = cnode.root()</span>
<span class="gi">+        for attr, nodes_lst in cnode.instance_attrs.items():</span>
<span class="gi">+            # Exclude `__dict__` as it is already defined.</span>
<span class="gi">+            if attr == &quot;__dict__&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Skip nodes which are not in the current module and it may screw up</span>
<span class="gi">+            # the output, while it&#39;s not worth it</span>
<span class="gi">+            nodes_lst = [</span>
<span class="gi">+                n</span>
<span class="gi">+                for n in nodes_lst</span>
<span class="gi">+                if not isinstance(n.statement(), (nodes.Delete, nodes.AugAssign))</span>
<span class="gi">+                and n.root() is current_module</span>
<span class="gi">+            ]</span>
<span class="gi">+            if not nodes_lst:</span>
<span class="gi">+                continue  # error detected by typechecking</span>
<span class="gi">+</span>
<span class="gi">+            # Check if any method attr is defined in is a defining method</span>
<span class="gi">+            # or if we have the attribute defined in a setter.</span>
<span class="gi">+            frames = (node.frame() for node in nodes_lst)</span>
<span class="gi">+            if any(</span>
<span class="gi">+                frame.name in defining_methods or is_property_setter(frame)</span>
<span class="gi">+                for frame in frames</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # check attribute is defined in a parent&#39;s __init__</span>
<span class="gi">+            for parent in cnode.instance_attr_ancestors(attr):</span>
<span class="gi">+                attr_defined = False</span>
<span class="gi">+                # check if any parent method attr is defined in is a defining method</span>
<span class="gi">+                for node in parent.instance_attrs[attr]:</span>
<span class="gi">+                    if node.frame().name in defining_methods:</span>
<span class="gi">+                        attr_defined = True</span>
<span class="gi">+                if attr_defined:</span>
<span class="gi">+                    # we&#39;re done :)</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                # check attribute is defined as a class attribute</span>
<span class="gi">+                try:</span>
<span class="gi">+                    cnode.local_attr(attr)</span>
<span class="gi">+                except astroid.NotFoundError:</span>
<span class="gi">+                    for node in nodes_lst:</span>
<span class="gi">+                        if node.frame().name not in defining_methods:</span>
<span class="gi">+                            # If the attribute was set by a call in any</span>
<span class="gi">+                            # of the defining methods, then don&#39;t emit</span>
<span class="gi">+                            # the warning.</span>
<span class="gi">+                            if _called_in_methods(</span>
<span class="gi">+                                node.frame(), cnode, defining_methods</span>
<span class="gi">+                            ):</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            self.add_message(</span>
<span class="gi">+                                &quot;attribute-defined-outside-init&quot;, args=attr, node=node</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-branches</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check method arguments, overriding.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # ignore actual functions</span>
<span class="gi">+        if not node.is_method():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._check_useless_super_delegation(node)</span>
<span class="gi">+        self._check_property_with_parameters(node)</span>
<span class="gi">+</span>
<span class="gi">+        # &#39;is_method()&#39; is called and makes sure that this is a &#39;nodes.ClassDef&#39;</span>
<span class="gi">+        klass: nodes.ClassDef = node.parent.frame()</span>
<span class="gi">+        # check first argument is self if this is actually a method</span>
<span class="gi">+        self._check_first_arg_for_type(node, klass.type == &quot;metaclass&quot;)</span>
<span class="gi">+        if node.name == &quot;__init__&quot;:</span>
<span class="gi">+            self._check_init(node, klass)</span>
<span class="gi">+            return</span>
<span class="gi">+        # check signature if the method overloads inherited method</span>
<span class="gi">+        for overridden in klass.local_attr_ancestors(node.name):</span>
<span class="gi">+            # get astroid for the searched method</span>
<span class="gi">+            try:</span>
<span class="gi">+                parent_function = overridden[node.name]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # we have found the method but it&#39;s not in the local</span>
<span class="gi">+                # dictionary.</span>
<span class="gi">+                # This may happen with astroid build from living objects</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not isinstance(parent_function, nodes.FunctionDef):</span>
<span class="gi">+                continue</span>
<span class="gi">+            self._check_signature(node, parent_function, klass)</span>
<span class="gi">+            self._check_invalid_overridden_method(node, parent_function)</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        if node.decorators:</span>
<span class="gi">+            for decorator in node.decorators.nodes:</span>
<span class="gi">+                if isinstance(decorator, nodes.Attribute) and decorator.attrname in {</span>
<span class="gi">+                    &quot;getter&quot;,</span>
<span class="gi">+                    &quot;setter&quot;,</span>
<span class="gi">+                    &quot;deleter&quot;,</span>
<span class="gi">+                }:</span>
<span class="gi">+                    # attribute affectation will call this method, not hiding it</span>
<span class="gi">+                    return</span>
<span class="gi">+                if isinstance(decorator, nodes.Name):</span>
<span class="gi">+                    if decorator.name in ALLOWED_PROPERTIES:</span>
<span class="gi">+                        # attribute affectation will either call a setter or raise</span>
<span class="gi">+                        # an attribute error, anyway not hiding the function</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                if isinstance(decorator, nodes.Attribute):</span>
<span class="gi">+                    if self._check_functools_or_not(decorator):</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                # Infer the decorator and see if it returns something useful</span>
<span class="gi">+                inferred = safe_infer(decorator)</span>
<span class="gi">+                if not inferred:</span>
<span class="gi">+                    return</span>
<span class="gi">+                if isinstance(inferred, nodes.FunctionDef):</span>
<span class="gi">+                    # Okay, it&#39;s a decorator, let&#39;s see what it can infer.</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        inferred = next(inferred.infer_call_result(inferred))</span>
<span class="gi">+                    except astroid.InferenceError:</span>
<span class="gi">+                        return</span>
<span class="gi">+                try:</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        isinstance(inferred, (astroid.Instance, nodes.ClassDef))</span>
<span class="gi">+                        and inferred.getattr(&quot;__get__&quot;)</span>
<span class="gi">+                        and inferred.getattr(&quot;__set__&quot;)</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return</span>
<span class="gi">+                except astroid.AttributeInferenceError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+        # check if the method is hidden by an attribute</span>
<span class="gi">+        # pylint: disable = too-many-try-statements</span>
<span class="gi">+        try:</span>
<span class="gi">+            overridden = klass.instance_attr(node.name)[0]</span>
<span class="gi">+            overridden_frame = overridden.frame()</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(overridden_frame, nodes.FunctionDef)</span>
<span class="gi">+                and overridden_frame.type == &quot;method&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                overridden_frame = overridden_frame.parent.frame()</span>
<span class="gi">+            if not (</span>
<span class="gi">+                isinstance(overridden_frame, nodes.ClassDef)</span>
<span class="gi">+                and klass.is_subtype_of(overridden_frame.qname())</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # If a subclass defined the method then it&#39;s not our fault.</span>
<span class="gi">+            for ancestor in klass.ancestors():</span>
<span class="gi">+                if node.name in ancestor.instance_attrs and is_attr_private(node.name):</span>
<span class="gi">+                    return</span>
<span class="gi">+                for obj in ancestor.lookup(node.name)[1]:</span>
<span class="gi">+                    if isinstance(obj, nodes.FunctionDef):</span>
<span class="gi">+                        return</span>
<span class="gi">+            args = (overridden.root().name, overridden.fromlineno)</span>
<span class="gi">+            self.add_message(&quot;method-hidden&quot;, args=args, node=node)</span>
<span class="gi">+        except astroid.NotFoundError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    def _check_useless_super_delegation(self, function: nodes.FunctionDef</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _check_useless_super_delegation(self, function: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the given function node is an useless method override.

<span class="w"> </span>        We consider it *useless* if it uses the super() builtin, but having
<span class="gu">@@ -348,23 +1329,279 @@ class ClassChecker(BaseChecker):</span>
<span class="w"> </span>        this method, then the method could be removed altogether, by letting
<span class="w"> </span>        other implementation to take precedence.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_redefined_slots(self, node: nodes.ClassDef, slots_node:</span>
<span class="gd">-        nodes.NodeNG, slots_list: list[nodes.NodeNG]) -&gt;None:</span>
<span class="gi">+        if not _is_trivial_super_delegation(function):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        call: nodes.Call = function.body[0].value</span>
<span class="gi">+</span>
<span class="gi">+        # Classes that override __eq__ should also override</span>
<span class="gi">+        # __hash__, even a trivial override is meaningful</span>
<span class="gi">+        if function.name == &quot;__hash__&quot;:</span>
<span class="gi">+            for other_method in function.parent.mymethods():</span>
<span class="gi">+                if other_method.name == &quot;__eq__&quot;:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+        # Check values of default args</span>
<span class="gi">+        klass = function.parent.frame()</span>
<span class="gi">+        meth_node = None</span>
<span class="gi">+        for overridden in klass.local_attr_ancestors(function.name):</span>
<span class="gi">+            # get astroid for the searched method</span>
<span class="gi">+            try:</span>
<span class="gi">+                meth_node = overridden[function.name]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # we have found the method but it&#39;s not in the local</span>
<span class="gi">+                # dictionary.</span>
<span class="gi">+                # This may happen with astroid build from living objects</span>
<span class="gi">+                continue</span>
<span class="gi">+            if (</span>
<span class="gi">+                not isinstance(meth_node, nodes.FunctionDef)</span>
<span class="gi">+                # If the method have an ancestor which is not a</span>
<span class="gi">+                # function then it is legitimate to redefine it</span>
<span class="gi">+                or _has_different_parameters_default_value(</span>
<span class="gi">+                    meth_node.args, function.args</span>
<span class="gi">+                )</span>
<span class="gi">+                # arguments to builtins such as Exception.__init__() cannot be inspected</span>
<span class="gi">+                or (meth_node.args.args is None and function.argnames() != [&quot;self&quot;])</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        # Detect if the parameters are the same as the call&#39;s arguments.</span>
<span class="gi">+        params = _signature_from_arguments(function.args)</span>
<span class="gi">+        args = _signature_from_call(call)</span>
<span class="gi">+</span>
<span class="gi">+        if meth_node is not None:</span>
<span class="gi">+            # Detect if the super method uses varargs and the function doesn&#39;t or makes some of those explicit</span>
<span class="gi">+            if meth_node.args.vararg and (</span>
<span class="gi">+                not function.args.vararg</span>
<span class="gi">+                or len(function.args.args) &gt; len(meth_node.args.args)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            def form_annotations(arguments: nodes.Arguments) -&gt; list[str]:</span>
<span class="gi">+                annotations = chain(</span>
<span class="gi">+                    (arguments.posonlyargs_annotations or []), arguments.annotations</span>
<span class="gi">+                )</span>
<span class="gi">+                return [ann.as_string() for ann in annotations if ann is not None]</span>
<span class="gi">+</span>
<span class="gi">+            called_annotations = form_annotations(function.args)</span>
<span class="gi">+            overridden_annotations = form_annotations(meth_node.args)</span>
<span class="gi">+            if called_annotations and overridden_annotations:</span>
<span class="gi">+                if called_annotations != overridden_annotations:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            if (</span>
<span class="gi">+                function.returns is not None</span>
<span class="gi">+                and meth_node.returns is not None</span>
<span class="gi">+                and meth_node.returns.as_string() != function.returns.as_string()</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Override adds typing information to the return type</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        if _definition_equivalent_to_call(params, args):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;useless-parent-delegation&quot;,</span>
<span class="gi">+                node=function,</span>
<span class="gi">+                args=(function.name,),</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_property_with_parameters(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        if (</span>
<span class="gi">+            len(node.args.arguments) &gt; 1</span>
<span class="gi">+            and decorated_with_property(node)</span>
<span class="gi">+            and not is_property_setter(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;property-with-parameters&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_invalid_overridden_method(</span>
<span class="gi">+        self,</span>
<span class="gi">+        function_node: nodes.FunctionDef,</span>
<span class="gi">+        parent_function_node: nodes.FunctionDef,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        parent_is_property = decorated_with_property(</span>
<span class="gi">+            parent_function_node</span>
<span class="gi">+        ) or is_property_setter_or_deleter(parent_function_node)</span>
<span class="gi">+        current_is_property = decorated_with_property(</span>
<span class="gi">+            function_node</span>
<span class="gi">+        ) or is_property_setter_or_deleter(function_node)</span>
<span class="gi">+        if parent_is_property and not current_is_property:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;invalid-overridden-method&quot;,</span>
<span class="gi">+                args=(function_node.name, &quot;property&quot;, function_node.type),</span>
<span class="gi">+                node=function_node,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif not parent_is_property and current_is_property:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;invalid-overridden-method&quot;,</span>
<span class="gi">+                args=(function_node.name, &quot;method&quot;, &quot;property&quot;),</span>
<span class="gi">+                node=function_node,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        parent_is_async = isinstance(parent_function_node, nodes.AsyncFunctionDef)</span>
<span class="gi">+        current_is_async = isinstance(function_node, nodes.AsyncFunctionDef)</span>
<span class="gi">+</span>
<span class="gi">+        if parent_is_async and not current_is_async:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;invalid-overridden-method&quot;,</span>
<span class="gi">+                args=(function_node.name, &quot;async&quot;, &quot;non-async&quot;),</span>
<span class="gi">+                node=function_node,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        elif not parent_is_async and current_is_async:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;invalid-overridden-method&quot;,</span>
<span class="gi">+                args=(function_node.name, &quot;non-async&quot;, &quot;async&quot;),</span>
<span class="gi">+                node=function_node,</span>
<span class="gi">+            )</span>
<span class="gi">+        if (</span>
<span class="gi">+            decorated_with(parent_function_node, [&quot;typing.final&quot;])</span>
<span class="gi">+            or uninferable_final_decorators(parent_function_node.decorators)</span>
<span class="gi">+        ) and self._py38_plus:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;overridden-final-method&quot;,</span>
<span class="gi">+                args=(function_node.name, parent_function_node.parent.frame().name),</span>
<span class="gi">+                node=function_node,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_functools_or_not(self, decorator: nodes.Attribute) -&gt; bool:</span>
<span class="gi">+        if decorator.attrname != &quot;cached_property&quot;:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(decorator.expr, nodes.Name):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        _, import_nodes = decorator.expr.lookup(decorator.expr.name)</span>
<span class="gi">+</span>
<span class="gi">+        if not import_nodes:</span>
<span class="gi">+            return False</span>
<span class="gi">+        import_node = import_nodes[0]</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(import_node, (astroid.Import, astroid.ImportFrom)):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;functools&quot; in dict(import_node.names)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_slots(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        if &quot;__slots__&quot; not in node.locals:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            inferred_slots = tuple(node.ilookup(&quot;__slots__&quot;))</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+        for slots in inferred_slots:</span>
<span class="gi">+            # check if __slots__ is a valid type</span>
<span class="gi">+            if isinstance(slots, util.UninferableBase):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not is_iterable(slots) and not is_comprehension(slots):</span>
<span class="gi">+                self.add_message(&quot;invalid-slots&quot;, node=node)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(slots, nodes.Const):</span>
<span class="gi">+                # a string, ignore the following checks</span>
<span class="gi">+                self.add_message(&quot;single-string-used-for-slots&quot;, node=node)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not hasattr(slots, &quot;itered&quot;):</span>
<span class="gi">+                # we can&#39;t obtain the values, maybe a .deque?</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(slots, nodes.Dict):</span>
<span class="gi">+                values = [item[0] for item in slots.items]</span>
<span class="gi">+            else:</span>
<span class="gi">+                values = slots.itered()</span>
<span class="gi">+            if isinstance(values, util.UninferableBase):</span>
<span class="gi">+                continue</span>
<span class="gi">+            for elt in values:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._check_slots_elt(elt, node)</span>
<span class="gi">+                except astroid.InferenceError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            self._check_redefined_slots(node, slots, values)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_redefined_slots(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.ClassDef,</span>
<span class="gi">+        slots_node: nodes.NodeNG,</span>
<span class="gi">+        slots_list: list[nodes.NodeNG],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if `node` redefines a slot which is defined in an ancestor class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def leave_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+        slots_names: list[str] = []</span>
<span class="gi">+        for slot in slots_list:</span>
<span class="gi">+            if isinstance(slot, nodes.Const):</span>
<span class="gi">+                slots_names.append(slot.value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                inferred_slot = safe_infer(slot)</span>
<span class="gi">+                inferred_slot_value = getattr(inferred_slot, &quot;value&quot;, None)</span>
<span class="gi">+                if isinstance(inferred_slot_value, str):</span>
<span class="gi">+                    slots_names.append(inferred_slot_value)</span>
<span class="gi">+</span>
<span class="gi">+        # Slots of all parent classes</span>
<span class="gi">+        ancestors_slots_names = {</span>
<span class="gi">+            slot.value</span>
<span class="gi">+            for ancestor in node.local_attr_ancestors(&quot;__slots__&quot;)</span>
<span class="gi">+            for slot in ancestor.slots() or []</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # Slots which are common to `node` and its parent classes</span>
<span class="gi">+        redefined_slots = ancestors_slots_names.intersection(slots_names)</span>
<span class="gi">+</span>
<span class="gi">+        if redefined_slots:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;redefined-slots-in-subclass&quot;,</span>
<span class="gi">+                args=([name for name in slots_names if name in redefined_slots],),</span>
<span class="gi">+                node=slots_node,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_slots_elt(</span>
<span class="gi">+        self, elt: SuccessfulInferenceResult, node: nodes.ClassDef</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        for inferred in elt.infer():</span>
<span class="gi">+            if isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not isinstance(inferred, nodes.Const) or not isinstance(</span>
<span class="gi">+                inferred.value, str</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;invalid-slots-object&quot;,</span>
<span class="gi">+                    args=elt.as_string(),</span>
<span class="gi">+                    node=elt,</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not inferred.value:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;invalid-slots-object&quot;,</span>
<span class="gi">+                    args=elt.as_string(),</span>
<span class="gi">+                    node=elt,</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # Check if we have a conflict with a class variable.</span>
<span class="gi">+            class_variable = node.locals.get(inferred.value)</span>
<span class="gi">+            if class_variable:</span>
<span class="gi">+                # Skip annotated assignments which don&#39;t conflict at all with slots.</span>
<span class="gi">+                if len(class_variable) == 1:</span>
<span class="gi">+                    parent = class_variable[0].parent</span>
<span class="gi">+                    if isinstance(parent, nodes.AnnAssign) and parent.value is None:</span>
<span class="gi">+                        return</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;class-variable-slots-conflict&quot;, args=(inferred.value,), node=elt</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def leave_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;On method node, check if this method couldn&#39;t be a function.

<span class="w"> </span>        ignore class, static and abstract methods, initializer,
<span class="w"> </span>        methods overridden from a parent class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.is_method():</span>
<span class="gi">+            if node.args.args is not None:</span>
<span class="gi">+                self._first_attrs.pop()</span>
<span class="gi">+</span>
<span class="w"> </span>    leave_asyncfunctiondef = leave_functiondef

<span class="gd">-    def visit_attribute(self, node: nodes.Attribute) -&gt;None:</span>
<span class="gi">+    def visit_attribute(self, node: nodes.Attribute) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the getattr is an access to a class member
<span class="w"> </span>        if so, register it.

<span class="gu">@@ -372,19 +1609,160 @@ class ClassChecker(BaseChecker):</span>
<span class="w"> </span>        class member from outside its class (but ignore __special__
<span class="w"> </span>        methods)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_super_without_brackets(node)</span>

<span class="gd">-    def _check_super_without_brackets(self, node: nodes.Attribute) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Check if there is a function call on a super call without brackets.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        # Check self</span>
<span class="gi">+        if self._uses_mandatory_method_param(node):</span>
<span class="gi">+            self._accessed.set_accessed(node)</span>
<span class="gi">+            return</span>
<span class="gi">+        if not self.linter.is_message_enabled(&quot;protected-access&quot;):</span>
<span class="gi">+            return</span>

<span class="gd">-    def _check_in_slots(self, node: nodes.AssignAttr) -&gt;None:</span>
<span class="gi">+        self._check_protected_attribute_access(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_super_without_brackets(self, node: nodes.Attribute) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Check if there is a function call on a super call without brackets.&quot;&quot;&quot;</span>
<span class="gi">+        # Check if attribute call is in frame definition in class definition</span>
<span class="gi">+        frame = node.frame()</span>
<span class="gi">+        if not isinstance(frame, nodes.FunctionDef):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(frame.parent.frame(), nodes.ClassDef):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(node.parent, nodes.Call):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(node.expr, nodes.Name):</span>
<span class="gi">+            return</span>
<span class="gi">+        if node.expr.name == &quot;super&quot;:</span>
<span class="gi">+            self.add_message(&quot;super-without-brackets&quot;, node=node.expr, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;assigning-non-slot&quot;, &quot;invalid-class-object&quot;, &quot;access-member-before-definition&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_assignattr(self, node: nodes.AssignAttr) -&gt; None:</span>
<span class="gi">+        if isinstance(</span>
<span class="gi">+            node.assign_type(), nodes.AugAssign</span>
<span class="gi">+        ) and self._uses_mandatory_method_param(node):</span>
<span class="gi">+            self._accessed.set_accessed(node)</span>
<span class="gi">+        self._check_in_slots(node)</span>
<span class="gi">+        self._check_invalid_class_object(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_invalid_class_object(self, node: nodes.AssignAttr) -&gt; None:</span>
<span class="gi">+        if not node.attrname == &quot;__class__&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node.parent, nodes.Tuple):</span>
<span class="gi">+            class_index = -1</span>
<span class="gi">+            for i, elt in enumerate(node.parent.elts):</span>
<span class="gi">+                if hasattr(elt, &quot;attrname&quot;) and elt.attrname == &quot;__class__&quot;:</span>
<span class="gi">+                    class_index = i</span>
<span class="gi">+            if class_index == -1:</span>
<span class="gi">+                # This should not happen because we checked that the node name</span>
<span class="gi">+                # is &#39;__class__&#39; earlier, but let&#39;s not be too confident here</span>
<span class="gi">+                return  # pragma: no cover</span>
<span class="gi">+            inferred = safe_infer(node.parent.parent.value.elts[class_index])</span>
<span class="gi">+        else:</span>
<span class="gi">+            inferred = safe_infer(node.parent.value)</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(inferred, (nodes.ClassDef, util.UninferableBase))</span>
<span class="gi">+            or inferred is None</span>
<span class="gi">+        ):</span>
<span class="gi">+            # If is uninferable, we allow it to prevent false positives</span>
<span class="gi">+            return</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;invalid-class-object&quot;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=inferred.__class__.__name__,</span>
<span class="gi">+            confidence=INFERENCE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_in_slots(self, node: nodes.AssignAttr) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that the given AssignAttr node
<span class="w"> </span>        is defined in the class slots.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_classmethod_declaration(self, node: nodes.Assign) -&gt;None:</span>
<span class="gi">+        inferred = safe_infer(node.expr)</span>
<span class="gi">+        if not isinstance(inferred, astroid.Instance):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        klass = inferred._proxied</span>
<span class="gi">+        if not has_known_bases(klass):</span>
<span class="gi">+            return</span>
<span class="gi">+        if &quot;__slots__&quot; not in klass.locals or not klass.newstyle:</span>
<span class="gi">+            return</span>
<span class="gi">+        # If `__setattr__` is defined on the class, then we can&#39;t reason about</span>
<span class="gi">+        # what will happen when assigning to an attribute.</span>
<span class="gi">+        if any(</span>
<span class="gi">+            base.locals.get(&quot;__setattr__&quot;)</span>
<span class="gi">+            for base in klass.mro()</span>
<span class="gi">+            if base.qname() != &quot;builtins.object&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # If &#39;typing.Generic&#39; is a base of bases of klass, the cached version</span>
<span class="gi">+        # of &#39;slots()&#39; might have been evaluated incorrectly, thus deleted cache entry.</span>
<span class="gi">+        if any(base.qname() == &quot;typing.Generic&quot; for base in klass.mro()):</span>
<span class="gi">+            cache = getattr(klass, &quot;__cache&quot;, None)</span>
<span class="gi">+            if cache and cache.get(klass.slots) is not None:</span>
<span class="gi">+                del cache[klass.slots]</span>
<span class="gi">+</span>
<span class="gi">+        slots = klass.slots()</span>
<span class="gi">+        if slots is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        # If any ancestor doesn&#39;t use slots, the slots</span>
<span class="gi">+        # defined for this class are superfluous.</span>
<span class="gi">+        if any(</span>
<span class="gi">+            &quot;__slots__&quot; not in ancestor.locals</span>
<span class="gi">+            and ancestor.name not in (&quot;Generic&quot;, &quot;object&quot;)</span>
<span class="gi">+            for ancestor in klass.ancestors()</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not any(slot.value == node.attrname for slot in slots):</span>
<span class="gi">+            # If we have a &#39;__dict__&#39; in slots, then</span>
<span class="gi">+            # assigning any name is valid.</span>
<span class="gi">+            if not any(slot.value == &quot;__dict__&quot; for slot in slots):</span>
<span class="gi">+                if _is_attribute_property(node.attrname, klass):</span>
<span class="gi">+                    # Properties circumvent the slots mechanism,</span>
<span class="gi">+                    # so we should not emit a warning for them.</span>
<span class="gi">+                    return</span>
<span class="gi">+                if node.attrname != &quot;__class__&quot; and utils.is_class_attr(</span>
<span class="gi">+                    node.attrname, klass</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+                if node.attrname in klass.locals:</span>
<span class="gi">+                    for local_name in klass.locals.get(node.attrname):</span>
<span class="gi">+                        statement = local_name.statement()</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            isinstance(statement, nodes.AnnAssign)</span>
<span class="gi">+                            and not statement.value</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            return</span>
<span class="gi">+                    if _has_data_descriptor(klass, node.attrname):</span>
<span class="gi">+                        # Descriptors circumvent the slots mechanism as well.</span>
<span class="gi">+                        return</span>
<span class="gi">+                if node.attrname == &quot;__class__&quot; and _has_same_layout_slots(</span>
<span class="gi">+                    slots, node.parent.value</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;assigning-non-slot&quot;,</span>
<span class="gi">+                    args=(node.attrname,),</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;protected-access&quot;, &quot;no-classmethod-decorator&quot;, &quot;no-staticmethod-decorator&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_assign(self, assign_node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        self._check_classmethod_declaration(assign_node)</span>
<span class="gi">+        node = assign_node.targets[0]</span>
<span class="gi">+        if not isinstance(node, nodes.AssignAttr):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self._uses_mandatory_method_param(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        self._check_protected_attribute_access(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_classmethod_declaration(self, node: nodes.Assign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks for uses of classmethod() or staticmethod().

<span class="w"> </span>        When a @classmethod or @staticmethod decorator should be used instead.
<span class="gu">@@ -393,10 +1771,39 @@ class ClassChecker(BaseChecker):</span>
<span class="w"> </span>        is defined.
<span class="w"> </span>        `node` is an assign node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_protected_attribute_access(self, node: (nodes.Attribute |</span>
<span class="gd">-        nodes.AssignAttr)) -&gt;None:</span>
<span class="gi">+        if not isinstance(node.value, nodes.Call):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # check the function called is &quot;classmethod&quot; or &quot;staticmethod&quot;</span>
<span class="gi">+        func = node.value.func</span>
<span class="gi">+        if not isinstance(func, nodes.Name) or func.name not in (</span>
<span class="gi">+            &quot;classmethod&quot;,</span>
<span class="gi">+            &quot;staticmethod&quot;,</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;no-classmethod-decorator&quot;</span>
<span class="gi">+            if func.name == &quot;classmethod&quot;</span>
<span class="gi">+            else &quot;no-staticmethod-decorator&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        # assignment must be at a class scope</span>
<span class="gi">+        parent_class = node.scope()</span>
<span class="gi">+        if not isinstance(parent_class, nodes.ClassDef):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Check if the arg passed to classmethod is a class member</span>
<span class="gi">+        classmeth_arg = node.value.args[0]</span>
<span class="gi">+        if not isinstance(classmeth_arg, nodes.Name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        method_name = classmeth_arg.name</span>
<span class="gi">+        if any(method_name == member.name for member in parent_class.mymethods()):</span>
<span class="gi">+            self.add_message(msg, node=node.targets[0])</span>
<span class="gi">+</span>
<span class="gi">+    def _check_protected_attribute_access(</span>
<span class="gi">+        self, node: nodes.Attribute | nodes.AssignAttr</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given an attribute access node (set or get), check if attribute
<span class="w"> </span>        access is legitimate.

<span class="gu">@@ -408,44 +1815,213 @@ class ClassChecker(BaseChecker):</span>
<span class="w"> </span>        * Klass2._attr inside &quot;Klass&quot; class when Klass2 is a base class of
<span class="w"> </span>            Klass.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attrname = node.attrname</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            not is_attr_protected(attrname)</span>
<span class="gi">+            or attrname in self.linter.config.exclude_protected</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Typing annotations in function definitions can include protected members</span>
<span class="gi">+        if utils.is_node_in_type_annotation_context(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Return if `attrname` is defined at the module-level or as a class attribute</span>
<span class="gi">+        # and is listed in `exclude-protected`.</span>
<span class="gi">+        inferred = safe_infer(node.expr)</span>
<span class="gi">+        if (</span>
<span class="gi">+            inferred</span>
<span class="gi">+            and isinstance(inferred, (nodes.ClassDef, nodes.Module))</span>
<span class="gi">+            and f&quot;{inferred.name}.{attrname}&quot; in self.linter.config.exclude_protected</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        klass = node_frame_class(node)</span>
<span class="gi">+        if klass is None:</span>
<span class="gi">+            # We are not in a class, no remaining valid case</span>
<span class="gi">+            self.add_message(&quot;protected-access&quot;, node=node, args=attrname)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # In classes, check we are not getting a parent method</span>
<span class="gi">+        # through the class object or through super</span>
<span class="gi">+</span>
<span class="gi">+        # If the expression begins with a call to super, that&#39;s ok.</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.expr, nodes.Call)</span>
<span class="gi">+            and isinstance(node.expr.func, nodes.Name)</span>
<span class="gi">+            and node.expr.func.name == &quot;super&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # If the expression begins with a call to type(self), that&#39;s ok.</span>
<span class="gi">+        if self._is_type_self_call(node.expr):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Check if we are inside the scope of a class or nested inner class</span>
<span class="gi">+        inside_klass = True</span>
<span class="gi">+        outer_klass = klass</span>
<span class="gi">+        callee = node.expr.as_string()</span>
<span class="gi">+        parents_callee = callee.split(&quot;.&quot;)</span>
<span class="gi">+        parents_callee.reverse()</span>
<span class="gi">+        for callee in parents_callee:</span>
<span class="gi">+            if not outer_klass or callee != outer_klass.name:</span>
<span class="gi">+                inside_klass = False</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            # Move up one level within the nested classes</span>
<span class="gi">+            outer_klass = get_outer_class(outer_klass)</span>
<span class="gi">+</span>
<span class="gi">+        # We are in a class, one remaining valid cases, Klass._attr inside</span>
<span class="gi">+        # Klass</span>
<span class="gi">+        if not (inside_klass or callee in klass.basenames):</span>
<span class="gi">+            # Detect property assignments in the body of the class.</span>
<span class="gi">+            # This is acceptable:</span>
<span class="gi">+            #</span>
<span class="gi">+            # class A:</span>
<span class="gi">+            #     b = property(lambda: self._b)</span>
<span class="gi">+</span>
<span class="gi">+            stmt = node.parent.statement()</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(stmt, nodes.Assign)</span>
<span class="gi">+                and len(stmt.targets) == 1</span>
<span class="gi">+                and isinstance(stmt.targets[0], nodes.AssignName)</span>
<span class="gi">+            ):</span>
<span class="gi">+                name = stmt.targets[0].name</span>
<span class="gi">+                if _is_attribute_property(name, klass):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            if (</span>
<span class="gi">+                self._is_classmethod(node.frame())</span>
<span class="gi">+                and self._is_inferred_instance(node.expr, klass)</span>
<span class="gi">+                and self._is_class_or_instance_attribute(attrname, klass)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            licit_protected_member = not attrname.startswith(&quot;__&quot;)</span>
<span class="gi">+            if (</span>
<span class="gi">+                not self.linter.config.check_protected_access_in_special_methods</span>
<span class="gi">+                and licit_protected_member</span>
<span class="gi">+                and self._is_called_inside_special_method(node)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(&quot;protected-access&quot;, node=node, args=attrname)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_called_inside_special_method(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    def _is_called_inside_special_method(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns true if the node is located inside a special (aka dunder) method.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        frame_name = node.frame().name</span>
<span class="gi">+        return frame_name and frame_name in PYMETHODS</span>
<span class="gi">+</span>
<span class="gi">+    def _is_type_self_call(self, expr: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(expr, nodes.Call)</span>
<span class="gi">+            and isinstance(expr.func, nodes.Name)</span>
<span class="gi">+            and expr.func.name == &quot;type&quot;</span>
<span class="gi">+            and len(expr.args) == 1</span>
<span class="gi">+            and self._is_mandatory_method_param(expr.args[0])</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_classmethod(func: LocalsDictNodeNG) -&gt;bool:</span>
<span class="gi">+    def _is_classmethod(func: LocalsDictNodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the given *func* node is a class method.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return isinstance(func, nodes.FunctionDef) and (</span>
<span class="gi">+            func.type == &quot;classmethod&quot; or func.name == &quot;__class_getitem__&quot;</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_inferred_instance(expr: nodes.NodeNG, klass: nodes.ClassDef</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def _is_inferred_instance(expr: nodes.NodeNG, klass: nodes.ClassDef) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the inferred value of the given *expr* is an instance of
<span class="w"> </span>        *klass*.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred = safe_infer(expr)</span>
<span class="gi">+        if not isinstance(inferred, astroid.Instance):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return inferred._proxied is klass</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_class_or_instance_attribute(name: str, klass: nodes.ClassDef</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def _is_class_or_instance_attribute(name: str, klass: nodes.ClassDef) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the given attribute *name* is a class or instance member of the
<span class="w"> </span>        given *klass*.

<span class="w"> </span>        Returns ``True`` if the name is a property in the given klass,
<span class="w"> </span>        ``False`` otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_accessed_members(self, node: nodes.ClassDef, accessed: dict[</span>
<span class="gd">-        str, list[_AccessNodes]]) -&gt;None:</span>
<span class="gi">+        if utils.is_class_attr(name, klass):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            klass.instance_attr(name)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except astroid.NotFoundError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def _check_accessed_members(</span>
<span class="gi">+        self, node: nodes.ClassDef, accessed: dict[str, list[_AccessNodes]]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that accessed members are defined.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_first_arg_for_type(self, node: nodes.FunctionDef, metaclass:</span>
<span class="gd">-        bool) -&gt;None:</span>
<span class="gi">+        excs = (&quot;AttributeError&quot;, &quot;Exception&quot;, &quot;BaseException&quot;)</span>
<span class="gi">+        for attr, nodes_lst in accessed.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                # is it a class attribute ?</span>
<span class="gi">+                node.local_attr(attr)</span>
<span class="gi">+                # yes, stop here</span>
<span class="gi">+                continue</span>
<span class="gi">+            except astroid.NotFoundError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            # is it an instance attribute of a parent class ?</span>
<span class="gi">+            try:</span>
<span class="gi">+                next(node.instance_attr_ancestors(attr))</span>
<span class="gi">+                # yes, stop here</span>
<span class="gi">+                continue</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                pass</span>
<span class="gi">+            # is it an instance attribute ?</span>
<span class="gi">+            try:</span>
<span class="gi">+                defstmts = node.instance_attr(attr)</span>
<span class="gi">+            except astroid.NotFoundError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                # filter out augment assignment nodes</span>
<span class="gi">+                defstmts = [stmt for stmt in defstmts if stmt not in nodes_lst]</span>
<span class="gi">+                if not defstmts:</span>
<span class="gi">+                    # only augment assignment for this node, no-member should be</span>
<span class="gi">+                    # triggered by the typecheck checker</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # filter defstmts to only pick the first one when there are</span>
<span class="gi">+                # several assignments in the same scope</span>
<span class="gi">+                scope = defstmts[0].scope()</span>
<span class="gi">+                defstmts = [</span>
<span class="gi">+                    stmt</span>
<span class="gi">+                    for i, stmt in enumerate(defstmts)</span>
<span class="gi">+                    if i == 0 or stmt.scope() is not scope</span>
<span class="gi">+                ]</span>
<span class="gi">+                # if there are still more than one, don&#39;t attempt to be smarter</span>
<span class="gi">+                # than we can be</span>
<span class="gi">+                if len(defstmts) == 1:</span>
<span class="gi">+                    defstmt = defstmts[0]</span>
<span class="gi">+                    # check that if the node is accessed in the same method as</span>
<span class="gi">+                    # it&#39;s defined, it&#39;s accessed after the initial assignment</span>
<span class="gi">+                    frame = defstmt.frame()</span>
<span class="gi">+                    lno = defstmt.fromlineno</span>
<span class="gi">+                    for _node in nodes_lst:</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            _node.frame() is frame</span>
<span class="gi">+                            and _node.fromlineno &lt; lno</span>
<span class="gi">+                            and not astroid.are_exclusive(</span>
<span class="gi">+                                _node.statement(), defstmt, excs</span>
<span class="gi">+                            )</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            self.add_message(</span>
<span class="gi">+                                &quot;access-member-before-definition&quot;,</span>
<span class="gi">+                                node=_node,</span>
<span class="gi">+                                args=(attr, lno),</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_first_arg_for_type(</span>
<span class="gi">+        self, node: nodes.FunctionDef, metaclass: bool</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check the name of first argument, expect:.

<span class="w"> </span>        * &#39;self&#39; for a regular method
<span class="gu">@@ -455,46 +2031,327 @@ class ClassChecker(BaseChecker):</span>
<span class="w"> </span>          valid-metaclass-classmethod-first-arg)
<span class="w"> </span>        * not one of the above for a static method
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_bases_classes(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+        # don&#39;t care about functions with unknown argument (builtins)</span>
<span class="gi">+        if node.args.args is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        if node.args.posonlyargs:</span>
<span class="gi">+            first_arg = node.args.posonlyargs[0].name</span>
<span class="gi">+        elif node.args.args:</span>
<span class="gi">+            first_arg = node.argnames()[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            first_arg = None</span>
<span class="gi">+        self._first_attrs.append(first_arg)</span>
<span class="gi">+        first = self._first_attrs[-1]</span>
<span class="gi">+        # static method</span>
<span class="gi">+        if node.type == &quot;staticmethod&quot;:</span>
<span class="gi">+            if (</span>
<span class="gi">+                first_arg == &quot;self&quot;</span>
<span class="gi">+                or first_arg in self.linter.config.valid_classmethod_first_arg</span>
<span class="gi">+                or first_arg in self.linter.config.valid_metaclass_classmethod_first_arg</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;bad-staticmethod-argument&quot;, args=first, node=node)</span>
<span class="gi">+                return</span>
<span class="gi">+            self._first_attrs[-1] = None</span>
<span class="gi">+        elif &quot;builtins.staticmethod&quot; in node.decoratornames():</span>
<span class="gi">+            # Check if there is a decorator which is not named `staticmethod`</span>
<span class="gi">+            # but is assigned to one.</span>
<span class="gi">+            return</span>
<span class="gi">+        # class / regular method with no args</span>
<span class="gi">+        elif not (</span>
<span class="gi">+            node.args.args</span>
<span class="gi">+            or node.args.posonlyargs</span>
<span class="gi">+            or node.args.vararg</span>
<span class="gi">+            or node.args.kwarg</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;no-method-argument&quot;, node=node, args=node.name)</span>
<span class="gi">+        # metaclass</span>
<span class="gi">+        elif metaclass:</span>
<span class="gi">+            # metaclass __new__ or classmethod</span>
<span class="gi">+            if node.type == &quot;classmethod&quot;:</span>
<span class="gi">+                self._check_first_arg_config(</span>
<span class="gi">+                    first,</span>
<span class="gi">+                    self.linter.config.valid_metaclass_classmethod_first_arg,</span>
<span class="gi">+                    node,</span>
<span class="gi">+                    &quot;bad-mcs-classmethod-argument&quot;,</span>
<span class="gi">+                    node.name,</span>
<span class="gi">+                )</span>
<span class="gi">+            # metaclass regular method</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._check_first_arg_config(</span>
<span class="gi">+                    first,</span>
<span class="gi">+                    self.linter.config.valid_classmethod_first_arg,</span>
<span class="gi">+                    node,</span>
<span class="gi">+                    &quot;bad-mcs-method-argument&quot;,</span>
<span class="gi">+                    node.name,</span>
<span class="gi">+                )</span>
<span class="gi">+        # regular class with class method</span>
<span class="gi">+        elif node.type == &quot;classmethod&quot; or node.name == &quot;__class_getitem__&quot;:</span>
<span class="gi">+            self._check_first_arg_config(</span>
<span class="gi">+                first,</span>
<span class="gi">+                self.linter.config.valid_classmethod_first_arg,</span>
<span class="gi">+                node,</span>
<span class="gi">+                &quot;bad-classmethod-argument&quot;,</span>
<span class="gi">+                node.name,</span>
<span class="gi">+            )</span>
<span class="gi">+        # regular class with regular method without self as argument</span>
<span class="gi">+        elif first != &quot;self&quot;:</span>
<span class="gi">+            self.add_message(&quot;no-self-argument&quot;, node=node, args=node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_first_arg_config(</span>
<span class="gi">+        self,</span>
<span class="gi">+        first: str | None,</span>
<span class="gi">+        config: Sequence[str],</span>
<span class="gi">+        node: nodes.FunctionDef,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        method_name: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if first not in config:</span>
<span class="gi">+            if len(config) == 1:</span>
<span class="gi">+                valid = repr(config[0])</span>
<span class="gi">+            else:</span>
<span class="gi">+                valid = &quot;, &quot;.join(repr(v) for v in config[:-1])</span>
<span class="gi">+                valid = f&quot;{valid} or {config[-1]!r}&quot;</span>
<span class="gi">+            self.add_message(message, args=(method_name, valid), node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_bases_classes(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that the given class node implements abstract methods from
<span class="w"> </span>        base classes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _check_init(self, node: nodes.FunctionDef, klass_node: nodes.ClassDef</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        def is_abstract(method: nodes.FunctionDef) -&gt; bool:</span>
<span class="gi">+            return method.is_abstract(pass_is_abstract=False)  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+        # check if this class abstract</span>
<span class="gi">+        if class_is_abstract(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        methods = sorted(</span>
<span class="gi">+            unimplemented_abstract_methods(node, is_abstract).items(),</span>
<span class="gi">+            key=lambda item: item[0],</span>
<span class="gi">+        )</span>
<span class="gi">+        for name, method in methods:</span>
<span class="gi">+            owner = method.parent.frame()</span>
<span class="gi">+            if owner is node:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # owner is not this class, it must be a parent class</span>
<span class="gi">+            # check that the ancestor&#39;s method is not abstract</span>
<span class="gi">+            if name in node.locals:</span>
<span class="gi">+                # it is redefined as an attribute or with a descriptor</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;abstract-method&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(name, owner.name, node.name),</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_init(self, node: nodes.FunctionDef, klass_node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that the __init__ method call super or ancestors&#39;__init__
<span class="w"> </span>        method (unless it is used for type hinting with `typing.overload`).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_signature(self, method1: nodes.FunctionDef, refmethod: nodes</span>
<span class="gd">-        .FunctionDef, cls: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+        if not self.linter.is_message_enabled(</span>
<span class="gi">+            &quot;super-init-not-called&quot;</span>
<span class="gi">+        ) and not self.linter.is_message_enabled(&quot;non-parent-init-called&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        to_call = _ancestors_to_call(klass_node)</span>
<span class="gi">+        not_called_yet = dict(to_call)</span>
<span class="gi">+        parents_with_called_inits: set[bases.UnboundMethod] = set()</span>
<span class="gi">+        for stmt in node.nodes_of_class(nodes.Call):</span>
<span class="gi">+            expr = stmt.func</span>
<span class="gi">+            if not isinstance(expr, nodes.Attribute) or expr.attrname != &quot;__init__&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # skip the test if using super</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(expr.expr, nodes.Call)</span>
<span class="gi">+                and isinstance(expr.expr.func, nodes.Name)</span>
<span class="gi">+                and expr.expr.func.name == &quot;super&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+            # pylint: disable = too-many-try-statements</span>
<span class="gi">+            try:</span>
<span class="gi">+                for klass in expr.expr.infer():</span>
<span class="gi">+                    if isinstance(klass, util.UninferableBase):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    # The inferred klass can be super(), which was</span>
<span class="gi">+                    # assigned to a variable and the `__init__`</span>
<span class="gi">+                    # was called later.</span>
<span class="gi">+                    #</span>
<span class="gi">+                    # base = super()</span>
<span class="gi">+                    # base.__init__(...)</span>
<span class="gi">+</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        isinstance(klass, astroid.Instance)</span>
<span class="gi">+                        and isinstance(klass._proxied, nodes.ClassDef)</span>
<span class="gi">+                        and is_builtin_object(klass._proxied)</span>
<span class="gi">+                        and klass._proxied.name == &quot;super&quot;</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return</span>
<span class="gi">+                    if isinstance(klass, astroid.objects.Super):</span>
<span class="gi">+                        return</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        method = not_called_yet.pop(klass)</span>
<span class="gi">+                        # Record that the class&#39; init has been called</span>
<span class="gi">+                        parents_with_called_inits.add(node_frame_class(method))</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        if klass not in klass_node.ancestors(recurs=False):</span>
<span class="gi">+                            self.add_message(</span>
<span class="gi">+                                &quot;non-parent-init-called&quot;, node=expr, args=klass.name</span>
<span class="gi">+                            )</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                continue</span>
<span class="gi">+        for klass, method in not_called_yet.items():</span>
<span class="gi">+            # Check if the init of the class that defines this init has already</span>
<span class="gi">+            # been called.</span>
<span class="gi">+            if node_frame_class(method) in parents_with_called_inits:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if utils.is_protocol_class(klass):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if decorated_with(node, [&quot;typing.overload&quot;]):</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;super-init-not-called&quot;,</span>
<span class="gi">+                args=klass.name,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_signature(</span>
<span class="gi">+        self,</span>
<span class="gi">+        method1: nodes.FunctionDef,</span>
<span class="gi">+        refmethod: nodes.FunctionDef,</span>
<span class="gi">+        cls: nodes.ClassDef,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that the signature of the two given methods match.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _uses_mandatory_method_param(self, node: (nodes.Attribute | nodes.</span>
<span class="gd">-        Assign | nodes.AssignAttr)) -&gt;bool:</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(method1, nodes.FunctionDef)</span>
<span class="gi">+            and isinstance(refmethod, nodes.FunctionDef)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;method-check-failed&quot;, args=(method1, refmethod), node=method1</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        instance = cls.instantiate_class()</span>
<span class="gi">+        method1 = astroid.scoped_nodes.function_to_method(method1, instance)</span>
<span class="gi">+        refmethod = astroid.scoped_nodes.function_to_method(refmethod, instance)</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t care about functions with unknown argument (builtins).</span>
<span class="gi">+        if method1.args.args is None or refmethod.args.args is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Ignore private to class methods.</span>
<span class="gi">+        if is_attr_private(method1.name):</span>
<span class="gi">+            return</span>
<span class="gi">+        # Ignore setters, they have an implicit extra argument,</span>
<span class="gi">+        # which shouldn&#39;t be taken in consideration.</span>
<span class="gi">+        if is_property_setter(method1):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        arg_differ_output = _different_parameters(</span>
<span class="gi">+            refmethod, method1, dummy_parameter_regex=self._dummy_rgx</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        class_type = &quot;overriding&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if len(arg_differ_output) &gt; 0:</span>
<span class="gi">+            for msg in arg_differ_output:</span>
<span class="gi">+                if &quot;Number&quot; in msg:</span>
<span class="gi">+                    total_args_method1 = len(method1.args.args)</span>
<span class="gi">+                    if method1.args.vararg:</span>
<span class="gi">+                        total_args_method1 += 1</span>
<span class="gi">+                    if method1.args.kwarg:</span>
<span class="gi">+                        total_args_method1 += 1</span>
<span class="gi">+                    if method1.args.kwonlyargs:</span>
<span class="gi">+                        total_args_method1 += len(method1.args.kwonlyargs)</span>
<span class="gi">+                    total_args_refmethod = len(refmethod.args.args)</span>
<span class="gi">+                    if refmethod.args.vararg:</span>
<span class="gi">+                        total_args_refmethod += 1</span>
<span class="gi">+                    if refmethod.args.kwarg:</span>
<span class="gi">+                        total_args_refmethod += 1</span>
<span class="gi">+                    if refmethod.args.kwonlyargs:</span>
<span class="gi">+                        total_args_refmethod += len(refmethod.args.kwonlyargs)</span>
<span class="gi">+                    error_type = &quot;arguments-differ&quot;</span>
<span class="gi">+                    msg_args = (</span>
<span class="gi">+                        msg</span>
<span class="gi">+                        + f&quot;was {total_args_refmethod} in &#39;{refmethod.parent.frame().name}.{refmethod.name}&#39; and &quot;</span>
<span class="gi">+                        f&quot;is now {total_args_method1} in&quot;,</span>
<span class="gi">+                        class_type,</span>
<span class="gi">+                        f&quot;{method1.parent.frame().name}.{method1.name}&quot;,</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif &quot;renamed&quot; in msg:</span>
<span class="gi">+                    error_type = &quot;arguments-renamed&quot;</span>
<span class="gi">+                    msg_args = (</span>
<span class="gi">+                        msg,</span>
<span class="gi">+                        class_type,</span>
<span class="gi">+                        f&quot;{method1.parent.frame().name}.{method1.name}&quot;,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    error_type = &quot;arguments-differ&quot;</span>
<span class="gi">+                    msg_args = (</span>
<span class="gi">+                        msg,</span>
<span class="gi">+                        class_type,</span>
<span class="gi">+                        f&quot;{method1.parent.frame().name}.{method1.name}&quot;,</span>
<span class="gi">+                    )</span>
<span class="gi">+                self.add_message(error_type, args=msg_args, node=method1)</span>
<span class="gi">+        elif (</span>
<span class="gi">+            len(method1.args.defaults) &lt; len(refmethod.args.defaults)</span>
<span class="gi">+            and not method1.args.vararg</span>
<span class="gi">+        ):</span>
<span class="gi">+            class_type = &quot;overridden&quot;</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;signature-differs&quot;, args=(class_type, method1.name), node=method1</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _uses_mandatory_method_param(</span>
<span class="gi">+        self, node: nodes.Attribute | nodes.Assign | nodes.AssignAttr</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that attribute lookup name use first attribute variable name.

<span class="w"> </span>        Name is `self` for method, `cls` for classmethod and `mcs` for metaclass.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._is_mandatory_method_param(node.expr)</span>

<span class="gd">-    def _is_mandatory_method_param(self, node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    def _is_mandatory_method_param(self, node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if nodes.Name corresponds to first attribute variable name.

<span class="w"> </span>        Name is `self` for method, `cls` for classmethod and `mcs` for metaclass.
<span class="w"> </span>        Static methods return False.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _ancestors_to_call(klass_node: nodes.ClassDef, method_name: str=&#39;__init__&#39;</span>
<span class="gd">-    ) -&gt;dict[nodes.ClassDef, bases.UnboundMethod]:</span>
<span class="gi">+        if self._first_attrs:</span>
<span class="gi">+            first_attr = self._first_attrs[-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # It&#39;s possible the function was already unregistered.</span>
<span class="gi">+            closest_func = utils.get_node_first_ancestor_of_type(</span>
<span class="gi">+                node, nodes.FunctionDef</span>
<span class="gi">+            )</span>
<span class="gi">+            if closest_func is None:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if not closest_func.is_bound():</span>
<span class="gi">+                return False</span>
<span class="gi">+            if not closest_func.args.args:</span>
<span class="gi">+                return False</span>
<span class="gi">+            first_attr = closest_func.args.args[0].name</span>
<span class="gi">+        return isinstance(node, nodes.Name) and node.name == first_attr</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _ancestors_to_call(</span>
<span class="gi">+    klass_node: nodes.ClassDef, method_name: str = &quot;__init__&quot;</span>
<span class="gi">+) -&gt; dict[nodes.ClassDef, bases.UnboundMethod]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a dictionary where keys are the list of base classes providing
<span class="w"> </span>    the queried method, and so that should/may be called from the method node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    to_call: dict[nodes.ClassDef, bases.UnboundMethod] = {}</span>
<span class="gi">+    for base_node in klass_node.ancestors(recurs=False):</span>
<span class="gi">+        try:</span>
<span class="gi">+            init_node = next(base_node.igetattr(method_name))</span>
<span class="gi">+            if not isinstance(init_node, astroid.UnboundMethod):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if init_node.is_abstract():</span>
<span class="gi">+                continue</span>
<span class="gi">+            to_call[base_node] = init_node</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            continue</span>
<span class="gi">+    return to_call</span>
<span class="gh">diff --git a/pylint/checkers/classes/special_methods_checker.py b/pylint/checkers/classes/special_methods_checker.py</span>
<span class="gh">index 98a772892..025f28562 100644</span>
<span class="gd">--- a/pylint/checkers/classes/special_methods_checker.py</span>
<span class="gi">+++ b/pylint/checkers/classes/special_methods_checker.py</span>
<span class="gu">@@ -1,85 +1,403 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Special methods checker and helper function&#39;s module.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Callable
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import bases, nodes, util
<span class="w"> </span>from astroid.context import InferenceContext
<span class="w"> </span>from astroid.typing import InferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="gd">-from pylint.checkers.utils import PYMETHODS, SPECIAL_METHODS_PARAMS, decorated_with, is_function_body_ellipsis, only_required_for_messages, safe_infer</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    PYMETHODS,</span>
<span class="gi">+    SPECIAL_METHODS_PARAMS,</span>
<span class="gi">+    decorated_with,</span>
<span class="gi">+    is_function_body_ellipsis,</span>
<span class="gi">+    only_required_for_messages,</span>
<span class="gi">+    safe_infer,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.lint.pylinter import PyLinter
<span class="gd">-NEXT_METHOD = &#39;__next__&#39;</span>
<span class="gi">+</span>
<span class="gi">+NEXT_METHOD = &quot;__next__&quot;</span>


<span class="gd">-def _safe_infer_call_result(node: nodes.FunctionDef, caller: nodes.</span>
<span class="gd">-    FunctionDef, context: (InferenceContext | None)=None) -&gt;(InferenceResult |</span>
<span class="gd">-    None):</span>
<span class="gi">+def _safe_infer_call_result(</span>
<span class="gi">+    node: nodes.FunctionDef,</span>
<span class="gi">+    caller: nodes.FunctionDef,</span>
<span class="gi">+    context: InferenceContext | None = None,</span>
<span class="gi">+) -&gt; InferenceResult | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Safely infer the return value of a function.

<span class="w"> </span>    Returns None if inference failed or if there is some ambiguity (more than
<span class="w"> </span>    one node has been inferred). Otherwise, returns inferred value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        inferit = node.infer_call_result(caller, context=context)</span>
<span class="gi">+        value = next(inferit)</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return None  # inference failed</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return None  # no values inferred</span>
<span class="gi">+    try:</span>
<span class="gi">+        next(inferit)</span>
<span class="gi">+        return None  # there is ambiguity on the inferred node</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return None  # there is some kind of ambiguity</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return value</span>


<span class="w"> </span>class SpecialMethodsChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checker which verifies that special methods
<span class="w"> </span>    are implemented correctly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;classes&#39;</span>
<span class="gd">-    msgs = {&#39;E0301&#39;: (&#39;__iter__ returns non-iterator&#39;,</span>
<span class="gd">-        &#39;non-iterator-returned&#39;,</span>
<span class="gd">-        f&#39;Used when an __iter__ method returns something which is not an iterable (i.e. has no `{NEXT_METHOD}` method)&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;W0234&#39;, &#39;old-non-iterator-returned-1&#39;), (&#39;E0234&#39;,</span>
<span class="gd">-        &#39;old-non-iterator-returned-2&#39;)]}), &#39;E0302&#39;: (</span>
<span class="gd">-        &#39;The special method %r expects %s param(s), %d %s given&#39;,</span>
<span class="gd">-        &#39;unexpected-special-method-signature&#39;,</span>
<span class="gd">-        &#39;Emitted when a special method was defined with an invalid number of parameters. If it has too few or too many, it might not work at all.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;E0235&#39;, &#39;bad-context-manager&#39;)]}), &#39;E0303&#39;: (</span>
<span class="gd">-        &#39;__len__ does not return non-negative integer&#39;,</span>
<span class="gd">-        &#39;invalid-length-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __len__ method returns something which is not a non-negative integer&#39;</span>
<span class="gd">-        ), &#39;E0304&#39;: (&#39;__bool__ does not return bool&#39;,</span>
<span class="gd">-        &#39;invalid-bool-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __bool__ method returns something which is not a bool&#39;</span>
<span class="gd">-        ), &#39;E0305&#39;: (&#39;__index__ does not return int&#39;,</span>
<span class="gd">-        &#39;invalid-index-returned&#39;,</span>
<span class="gd">-        &#39;Used when an __index__ method returns something which is not an integer&#39;</span>
<span class="gd">-        ), &#39;E0306&#39;: (&#39;__repr__ does not return str&#39;,</span>
<span class="gd">-        &#39;invalid-repr-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __repr__ method returns something which is not a string&#39;</span>
<span class="gd">-        ), &#39;E0307&#39;: (&#39;__str__ does not return str&#39;, &#39;invalid-str-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __str__ method returns something which is not a string&#39;</span>
<span class="gd">-        ), &#39;E0308&#39;: (&#39;__bytes__ does not return bytes&#39;,</span>
<span class="gd">-        &#39;invalid-bytes-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __bytes__ method returns something which is not bytes&#39;</span>
<span class="gd">-        ), &#39;E0309&#39;: (&#39;__hash__ does not return int&#39;,</span>
<span class="gd">-        &#39;invalid-hash-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __hash__ method returns something which is not an integer&#39;</span>
<span class="gd">-        ), &#39;E0310&#39;: (&#39;__length_hint__ does not return non-negative integer&#39;,</span>
<span class="gd">-        &#39;invalid-length-hint-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __length_hint__ method returns something which is not a non-negative integer&#39;</span>
<span class="gd">-        ), &#39;E0311&#39;: (&#39;__format__ does not return str&#39;,</span>
<span class="gd">-        &#39;invalid-format-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __format__ method returns something which is not a string&#39;</span>
<span class="gd">-        ), &#39;E0312&#39;: (&#39;__getnewargs__ does not return a tuple&#39;,</span>
<span class="gd">-        &#39;invalid-getnewargs-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __getnewargs__ method returns something which is not a tuple&#39;</span>
<span class="gd">-        ), &#39;E0313&#39;: (</span>
<span class="gd">-        &#39;__getnewargs_ex__ does not return a tuple containing (tuple, dict)&#39;,</span>
<span class="gd">-        &#39;invalid-getnewargs-ex-returned&#39;,</span>
<span class="gd">-        &#39;Used when a __getnewargs_ex__ method returns something which is not of the form tuple(tuple, dict)&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;classes&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;E0301&quot;: (</span>
<span class="gi">+            &quot;__iter__ returns non-iterator&quot;,</span>
<span class="gi">+            &quot;non-iterator-returned&quot;,</span>
<span class="gi">+            &quot;Used when an __iter__ method returns something which is not an &quot;</span>
<span class="gi">+            f&quot;iterable (i.e. has no `{NEXT_METHOD}` method)&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;old_names&quot;: [</span>
<span class="gi">+                    (&quot;W0234&quot;, &quot;old-non-iterator-returned-1&quot;),</span>
<span class="gi">+                    (&quot;E0234&quot;, &quot;old-non-iterator-returned-2&quot;),</span>
<span class="gi">+                ]</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0302&quot;: (</span>
<span class="gi">+            &quot;The special method %r expects %s param(s), %d %s given&quot;,</span>
<span class="gi">+            &quot;unexpected-special-method-signature&quot;,</span>
<span class="gi">+            &quot;Emitted when a special method was defined with an &quot;</span>
<span class="gi">+            &quot;invalid number of parameters. If it has too few or &quot;</span>
<span class="gi">+            &quot;too many, it might not work at all.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;E0235&quot;, &quot;bad-context-manager&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0303&quot;: (</span>
<span class="gi">+            &quot;__len__ does not return non-negative integer&quot;,</span>
<span class="gi">+            &quot;invalid-length-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __len__ method returns something which is not a &quot;</span>
<span class="gi">+            &quot;non-negative integer&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0304&quot;: (</span>
<span class="gi">+            &quot;__bool__ does not return bool&quot;,</span>
<span class="gi">+            &quot;invalid-bool-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __bool__ method returns something which is not a bool&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0305&quot;: (</span>
<span class="gi">+            &quot;__index__ does not return int&quot;,</span>
<span class="gi">+            &quot;invalid-index-returned&quot;,</span>
<span class="gi">+            &quot;Used when an __index__ method returns something which is not &quot;</span>
<span class="gi">+            &quot;an integer&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0306&quot;: (</span>
<span class="gi">+            &quot;__repr__ does not return str&quot;,</span>
<span class="gi">+            &quot;invalid-repr-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __repr__ method returns something which is not a string&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0307&quot;: (</span>
<span class="gi">+            &quot;__str__ does not return str&quot;,</span>
<span class="gi">+            &quot;invalid-str-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __str__ method returns something which is not a string&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0308&quot;: (</span>
<span class="gi">+            &quot;__bytes__ does not return bytes&quot;,</span>
<span class="gi">+            &quot;invalid-bytes-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __bytes__ method returns something which is not bytes&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0309&quot;: (</span>
<span class="gi">+            &quot;__hash__ does not return int&quot;,</span>
<span class="gi">+            &quot;invalid-hash-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __hash__ method returns something which is not an integer&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0310&quot;: (</span>
<span class="gi">+            &quot;__length_hint__ does not return non-negative integer&quot;,</span>
<span class="gi">+            &quot;invalid-length-hint-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __length_hint__ method returns something which is not a &quot;</span>
<span class="gi">+            &quot;non-negative integer&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0311&quot;: (</span>
<span class="gi">+            &quot;__format__ does not return str&quot;,</span>
<span class="gi">+            &quot;invalid-format-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __format__ method returns something which is not a string&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0312&quot;: (</span>
<span class="gi">+            &quot;__getnewargs__ does not return a tuple&quot;,</span>
<span class="gi">+            &quot;invalid-getnewargs-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __getnewargs__ method returns something which is not &quot;</span>
<span class="gi">+            &quot;a tuple&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E0313&quot;: (</span>
<span class="gi">+            &quot;__getnewargs_ex__ does not return a tuple containing (tuple, dict)&quot;,</span>
<span class="gi">+            &quot;invalid-getnewargs-ex-returned&quot;,</span>
<span class="gi">+            &quot;Used when a __getnewargs_ex__ method returns something which is not &quot;</span>
<span class="gi">+            &quot;of the form tuple(tuple, dict)&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="gd">-        self._protocol_map: dict[str, Callable[[nodes.FunctionDef,</span>
<span class="gd">-            InferenceResult], None]] = {&#39;__iter__&#39;: self._check_iter,</span>
<span class="gd">-            &#39;__len__&#39;: self._check_len, &#39;__bool__&#39;: self._check_bool,</span>
<span class="gd">-            &#39;__index__&#39;: self._check_index, &#39;__repr__&#39;: self._check_repr,</span>
<span class="gd">-            &#39;__str__&#39;: self._check_str, &#39;__bytes__&#39;: self._check_bytes,</span>
<span class="gd">-            &#39;__hash__&#39;: self._check_hash, &#39;__length_hint__&#39;: self.</span>
<span class="gd">-            _check_length_hint, &#39;__format__&#39;: self._check_format,</span>
<span class="gd">-            &#39;__getnewargs__&#39;: self._check_getnewargs, &#39;__getnewargs_ex__&#39;:</span>
<span class="gd">-            self._check_getnewargs_ex}</span>
<span class="gi">+        self._protocol_map: dict[</span>
<span class="gi">+            str, Callable[[nodes.FunctionDef, InferenceResult], None]</span>
<span class="gi">+        ] = {</span>
<span class="gi">+            &quot;__iter__&quot;: self._check_iter,</span>
<span class="gi">+            &quot;__len__&quot;: self._check_len,</span>
<span class="gi">+            &quot;__bool__&quot;: self._check_bool,</span>
<span class="gi">+            &quot;__index__&quot;: self._check_index,</span>
<span class="gi">+            &quot;__repr__&quot;: self._check_repr,</span>
<span class="gi">+            &quot;__str__&quot;: self._check_str,</span>
<span class="gi">+            &quot;__bytes__&quot;: self._check_bytes,</span>
<span class="gi">+            &quot;__hash__&quot;: self._check_hash,</span>
<span class="gi">+            &quot;__length_hint__&quot;: self._check_length_hint,</span>
<span class="gi">+            &quot;__format__&quot;: self._check_format,</span>
<span class="gi">+            &quot;__getnewargs__&quot;: self._check_getnewargs,</span>
<span class="gi">+            &quot;__getnewargs_ex__&quot;: self._check_getnewargs_ex,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;unexpected-special-method-signature&quot;,</span>
<span class="gi">+        &quot;non-iterator-returned&quot;,</span>
<span class="gi">+        &quot;invalid-length-returned&quot;,</span>
<span class="gi">+        &quot;invalid-bool-returned&quot;,</span>
<span class="gi">+        &quot;invalid-index-returned&quot;,</span>
<span class="gi">+        &quot;invalid-repr-returned&quot;,</span>
<span class="gi">+        &quot;invalid-str-returned&quot;,</span>
<span class="gi">+        &quot;invalid-bytes-returned&quot;,</span>
<span class="gi">+        &quot;invalid-hash-returned&quot;,</span>
<span class="gi">+        &quot;invalid-length-hint-returned&quot;,</span>
<span class="gi">+        &quot;invalid-format-returned&quot;,</span>
<span class="gi">+        &quot;invalid-getnewargs-returned&quot;,</span>
<span class="gi">+        &quot;invalid-getnewargs-ex-returned&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        if not node.is_method():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        inferred = _safe_infer_call_result(node, node)</span>
<span class="gi">+        # Only want to check types that we are able to infer</span>
<span class="gi">+        if (</span>
<span class="gi">+            inferred</span>
<span class="gi">+            and node.name in self._protocol_map</span>
<span class="gi">+            and not is_function_body_ellipsis(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._protocol_map[node.name](node, inferred)</span>
<span class="gi">+</span>
<span class="gi">+        if node.name in PYMETHODS:</span>
<span class="gi">+            self._check_unexpected_method_signature(node)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef
<span class="gi">+</span>
<span class="gi">+    def _check_unexpected_method_signature(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        expected_params = SPECIAL_METHODS_PARAMS[node.name]</span>
<span class="gi">+</span>
<span class="gi">+        if expected_params is None:</span>
<span class="gi">+            # This can support a variable number of parameters.</span>
<span class="gi">+            return</span>
<span class="gi">+        if not node.args.args and not node.args.vararg:</span>
<span class="gi">+            # Method has no parameter, will be caught</span>
<span class="gi">+            # by no-method-argument.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if decorated_with(node, [&quot;builtins.staticmethod&quot;]):</span>
<span class="gi">+            # We expect to not take in consideration self.</span>
<span class="gi">+            all_args = node.args.args</span>
<span class="gi">+        else:</span>
<span class="gi">+            all_args = node.args.args[1:]</span>
<span class="gi">+        mandatory = len(all_args) - len(node.args.defaults)</span>
<span class="gi">+        optional = len(node.args.defaults)</span>
<span class="gi">+        current_params = mandatory + optional</span>
<span class="gi">+</span>
<span class="gi">+        emit = False  # If we don&#39;t know we choose a false negative</span>
<span class="gi">+        if isinstance(expected_params, tuple):</span>
<span class="gi">+            # The expected number of parameters can be any value from this</span>
<span class="gi">+            # tuple, although the user should implement the method</span>
<span class="gi">+            # to take all of them in consideration.</span>
<span class="gi">+            emit = mandatory not in expected_params</span>
<span class="gi">+            # mypy thinks that expected_params has type tuple[int, int] | int | None</span>
<span class="gi">+            # But at this point it must be &#39;tuple[int, int]&#39; because of the type check</span>
<span class="gi">+            expected_params = f&quot;between {expected_params[0]} or {expected_params[1]}&quot;  # type: ignore[assignment]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If the number of mandatory parameters doesn&#39;t</span>
<span class="gi">+            # suffice, the expected parameters for this</span>
<span class="gi">+            # function will be deduced from the optional</span>
<span class="gi">+            # parameters.</span>
<span class="gi">+            rest = expected_params - mandatory</span>
<span class="gi">+            if rest == 0:</span>
<span class="gi">+                emit = False</span>
<span class="gi">+            elif rest &lt; 0:</span>
<span class="gi">+                emit = True</span>
<span class="gi">+            elif rest &gt; 0:</span>
<span class="gi">+                emit = not ((optional - rest) &gt;= 0 or node.args.vararg)</span>
<span class="gi">+</span>
<span class="gi">+        if emit:</span>
<span class="gi">+            verb = &quot;was&quot; if current_params &lt;= 1 else &quot;were&quot;</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unexpected-special-method-signature&quot;,</span>
<span class="gi">+                args=(node.name, expected_params, current_params, verb),</span>
<span class="gi">+                node=node,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_wrapped_type(node: InferenceResult, type_: str) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(node, bases.Instance)</span>
<span class="gi">+            and node.name == type_</span>
<span class="gi">+            and not isinstance(node, nodes.Const)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_int(node: InferenceResult) -&gt; bool:</span>
<span class="gi">+        if SpecialMethodsChecker._is_wrapped_type(node, &quot;int&quot;):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return isinstance(node, nodes.Const) and isinstance(node.value, int)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_str(node: InferenceResult) -&gt; bool:</span>
<span class="gi">+        if SpecialMethodsChecker._is_wrapped_type(node, &quot;str&quot;):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return isinstance(node, nodes.Const) and isinstance(node.value, str)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_bool(node: InferenceResult) -&gt; bool:</span>
<span class="gi">+        if SpecialMethodsChecker._is_wrapped_type(node, &quot;bool&quot;):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return isinstance(node, nodes.Const) and isinstance(node.value, bool)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_bytes(node: InferenceResult) -&gt; bool:</span>
<span class="gi">+        if SpecialMethodsChecker._is_wrapped_type(node, &quot;bytes&quot;):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return isinstance(node, nodes.Const) and isinstance(node.value, bytes)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_tuple(node: InferenceResult) -&gt; bool:</span>
<span class="gi">+        if SpecialMethodsChecker._is_wrapped_type(node, &quot;tuple&quot;):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return isinstance(node, nodes.Const) and isinstance(node.value, tuple)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_dict(node: InferenceResult) -&gt; bool:</span>
<span class="gi">+        if SpecialMethodsChecker._is_wrapped_type(node, &quot;dict&quot;):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return isinstance(node, nodes.Const) and isinstance(node.value, dict)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_iterator(node: InferenceResult) -&gt; bool:</span>
<span class="gi">+        if isinstance(node, bases.Generator):</span>
<span class="gi">+            # Generators can be iterated.</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(node, nodes.ComprehensionScope):</span>
<span class="gi">+            # Comprehensions can be iterated.</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node, bases.Instance):</span>
<span class="gi">+            try:</span>
<span class="gi">+                node.local_attr(NEXT_METHOD)</span>
<span class="gi">+                return True</span>
<span class="gi">+            except astroid.NotFoundError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        elif isinstance(node, nodes.ClassDef):</span>
<span class="gi">+            metaclass = node.metaclass()</span>
<span class="gi">+            if metaclass and isinstance(metaclass, nodes.ClassDef):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    metaclass.local_attr(NEXT_METHOD)</span>
<span class="gi">+                    return True</span>
<span class="gi">+                except astroid.NotFoundError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _check_iter(self, node: nodes.FunctionDef, inferred: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not self._is_iterator(inferred):</span>
<span class="gi">+            self.add_message(&quot;non-iterator-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_len(self, node: nodes.FunctionDef, inferred: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not self._is_int(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-length-returned&quot;, node=node)</span>
<span class="gi">+        elif isinstance(inferred, nodes.Const) and inferred.value &lt; 0:</span>
<span class="gi">+            self.add_message(&quot;invalid-length-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_bool(self, node: nodes.FunctionDef, inferred: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not self._is_bool(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-bool-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_index(self, node: nodes.FunctionDef, inferred: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not self._is_int(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-index-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_repr(self, node: nodes.FunctionDef, inferred: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not self._is_str(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-repr-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_str(self, node: nodes.FunctionDef, inferred: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not self._is_str(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-str-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_bytes(self, node: nodes.FunctionDef, inferred: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not self._is_bytes(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-bytes-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_hash(self, node: nodes.FunctionDef, inferred: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not self._is_int(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-hash-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_length_hint(</span>
<span class="gi">+        self, node: nodes.FunctionDef, inferred: InferenceResult</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if not self._is_int(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-length-hint-returned&quot;, node=node)</span>
<span class="gi">+        elif isinstance(inferred, nodes.Const) and inferred.value &lt; 0:</span>
<span class="gi">+            self.add_message(&quot;invalid-length-hint-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_format(self, node: nodes.FunctionDef, inferred: InferenceResult) -&gt; None:</span>
<span class="gi">+        if not self._is_str(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-format-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_getnewargs(</span>
<span class="gi">+        self, node: nodes.FunctionDef, inferred: InferenceResult</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if not self._is_tuple(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-getnewargs-returned&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_getnewargs_ex(</span>
<span class="gi">+        self, node: nodes.FunctionDef, inferred: InferenceResult</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if not self._is_tuple(inferred):</span>
<span class="gi">+            self.add_message(&quot;invalid-getnewargs-ex-returned&quot;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(inferred, nodes.Tuple):</span>
<span class="gi">+            # If it&#39;s not an astroid.Tuple we can&#39;t analyze it further</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        found_error = False</span>
<span class="gi">+</span>
<span class="gi">+        if len(inferred.elts) != 2:</span>
<span class="gi">+            found_error = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            for arg, check in (</span>
<span class="gi">+                (inferred.elts[0], self._is_tuple),</span>
<span class="gi">+                (inferred.elts[1], self._is_dict),</span>
<span class="gi">+            ):</span>
<span class="gi">+                if isinstance(arg, nodes.Call):</span>
<span class="gi">+                    arg = safe_infer(arg)</span>
<span class="gi">+</span>
<span class="gi">+                if arg and not isinstance(arg, util.UninferableBase):</span>
<span class="gi">+                    if not check(arg):</span>
<span class="gi">+                        found_error = True</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+        if found_error:</span>
<span class="gi">+            self.add_message(&quot;invalid-getnewargs-ex-returned&quot;, node=node)</span>
<span class="gh">diff --git a/pylint/checkers/dataclass_checker.py b/pylint/checkers/dataclass_checker.py</span>
<span class="gh">index bf68dc00a..60b1b23cd 100644</span>
<span class="gd">--- a/pylint/checkers/dataclass_checker.py</span>
<span class="gi">+++ b/pylint/checkers/dataclass_checker.py</span>
<span class="gu">@@ -1,25 +1,37 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Dataclass checkers for Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="w"> </span>from astroid.brain.brain_dataclasses import DATACLASS_MODULES
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="w"> </span>from pylint.interfaces import INFERENCE
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="gd">-def _is_dataclasses_module(node: nodes.Module) -&gt;bool:</span>
<span class="gi">+def _is_dataclasses_module(node: nodes.Module) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Utility function to check if node is from dataclasses_module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return node.name in DATACLASS_MODULES</span>


<span class="gd">-def _check_name_or_attrname_eq_to(node: (nodes.Name | nodes.Attribute),</span>
<span class="gd">-    check_with: str) -&gt;bool:</span>
<span class="gi">+def _check_name_or_attrname_eq_to(</span>
<span class="gi">+    node: nodes.Name | nodes.Attribute, check_with: str</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Utility function to check either a Name/Attribute node&#39;s name/attrname with a
<span class="w"> </span>    given string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, nodes.Name):</span>
<span class="gi">+        return str(node.name) == check_with</span>
<span class="gi">+    return str(node.attrname) == check_with</span>


<span class="w"> </span>class DataclassChecker(BaseChecker):
<span class="gu">@@ -28,12 +40,22 @@ class DataclassChecker(BaseChecker):</span>
<span class="w"> </span>    Checks for
<span class="w"> </span>    * invalid-field-call
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;dataclass&#39;</span>
<span class="gd">-    msgs = {&#39;E3701&#39;: (&#39;Invalid usage of field(), %s&#39;, &#39;invalid-field-call&#39;,</span>
<span class="gd">-        &#39;The dataclasses.field() specifier should only be used as the value of an assignment within a dataclass, or within the make_dataclass() function.&#39;</span>
<span class="gd">-        )}</span>

<span class="gd">-    def _check_invalid_field_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    name = &quot;dataclass&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;E3701&quot;: (</span>
<span class="gi">+            &quot;Invalid usage of field(), %s&quot;,</span>
<span class="gi">+            &quot;invalid-field-call&quot;,</span>
<span class="gi">+            &quot;The dataclasses.field() specifier should only be used as the value of &quot;</span>
<span class="gi">+            &quot;an assignment within a dataclass, or within the make_dataclass() function.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;invalid-field-call&quot;)</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        self._check_invalid_field_call(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_invalid_field_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks for correct usage of the dataclasses.field() specifier in
<span class="w"> </span>        dataclasses or within the make_dataclass() function.

<span class="gu">@@ -42,11 +64,66 @@ class DataclassChecker(BaseChecker):</span>
<span class="w"> </span>        @dataclass decorator and outside make_dataclass() function, or when it
<span class="w"> </span>        is used improperly within a dataclass.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.func, (nodes.Name, nodes.Attribute)):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not _check_name_or_attrname_eq_to(node.func, &quot;field&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        inferred_func = utils.safe_infer(node.func)</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(inferred_func, nodes.FunctionDef)</span>
<span class="gi">+            and _is_dataclasses_module(inferred_func.root())</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        scope_node = node.parent</span>
<span class="gi">+        while scope_node and not isinstance(scope_node, (nodes.ClassDef, nodes.Call)):</span>
<span class="gi">+            scope_node = scope_node.parent</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(scope_node, nodes.Call):</span>
<span class="gi">+            self._check_invalid_field_call_within_call(node, scope_node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not scope_node or not scope_node.is_dataclass:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;invalid-field-call&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(</span>
<span class="gi">+                    &quot;it should be used within a dataclass or the make_dataclass() function.&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>

<span class="gd">-    def _check_invalid_field_call_within_call(self, node: nodes.Call,</span>
<span class="gd">-        scope_node: nodes.Call) -&gt;None:</span>
<span class="gi">+        if not (isinstance(node.parent, nodes.AnnAssign) and node == node.parent.value):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;invalid-field-call&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(&quot;it should be the value of an assignment within a dataclass.&quot;,),</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_invalid_field_call_within_call(</span>
<span class="gi">+        self, node: nodes.Call, scope_node: nodes.Call</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks for special case where calling field is valid as an argument of the
<span class="w"> </span>        make_dataclass() function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred_func = utils.safe_infer(scope_node.func)</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(scope_node.func, (nodes.Name, nodes.AssignName))</span>
<span class="gi">+            and scope_node.func.name == &quot;make_dataclass&quot;</span>
<span class="gi">+            and isinstance(inferred_func, nodes.FunctionDef)</span>
<span class="gi">+            and _is_dataclasses_module(inferred_func.root())</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;invalid-field-call&quot;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=(</span>
<span class="gi">+                &quot;it should be used within a dataclass or the make_dataclass() function.&quot;,</span>
<span class="gi">+            ),</span>
<span class="gi">+            confidence=INFERENCE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(DataclassChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/deprecated.py b/pylint/checkers/deprecated.py</span>
<span class="gh">index fbe3222fa..028dc13f3 100644</span>
<span class="gd">--- a/pylint/checkers/deprecated.py</span>
<span class="gi">+++ b/pylint/checkers/deprecated.py</span>
<span class="gu">@@ -1,17 +1,31 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checker mixin for deprecated functionality.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Container, Iterable
<span class="w"> </span>from itertools import chain
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="w"> </span>from astroid.bases import Instance
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.base_checker import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import get_import_name, infer_all, safe_infer
<span class="w"> </span>from pylint.interfaces import INFERENCE
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gd">-ACCEPTABLE_NODES = (astroid.BoundMethod, astroid.UnboundMethod, nodes.</span>
<span class="gd">-    FunctionDef, nodes.ClassDef, astroid.Attribute)</span>
<span class="gi">+</span>
<span class="gi">+ACCEPTABLE_NODES = (</span>
<span class="gi">+    astroid.BoundMethod,</span>
<span class="gi">+    astroid.UnboundMethod,</span>
<span class="gi">+    nodes.FunctionDef,</span>
<span class="gi">+    nodes.ClassDef,</span>
<span class="gi">+    astroid.Attribute,</span>
<span class="gi">+)</span>


<span class="w"> </span>class DeprecatedMixin(BaseChecker):
<span class="gu">@@ -19,78 +33,134 @@ class DeprecatedMixin(BaseChecker):</span>

<span class="w"> </span>    A class implementing mixin must define &quot;deprecated-method&quot; Message.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    DEPRECATED_ATTRIBUTE_MESSAGE: dict[str, MessageDefinitionTuple] = {&#39;W4906&#39;:</span>
<span class="gd">-        (&#39;Using deprecated attribute %r&#39;, &#39;deprecated-attribute&#39;,</span>
<span class="gd">-        &#39;The attribute is marked as deprecated and will be removed in the future.&#39;</span>
<span class="gd">-        , {&#39;shared&#39;: True})}</span>
<span class="gd">-    DEPRECATED_MODULE_MESSAGE: dict[str, MessageDefinitionTuple] = {&#39;W4901&#39;:</span>
<span class="gd">-        (&#39;Deprecated module %r&#39;, &#39;deprecated-module&#39;,</span>
<span class="gd">-        &#39;A module marked as deprecated is imported.&#39;, {&#39;old_names&#39;: [(</span>
<span class="gd">-        &#39;W0402&#39;, &#39;old-deprecated-module&#39;)], &#39;shared&#39;: True})}</span>
<span class="gd">-    DEPRECATED_METHOD_MESSAGE: dict[str, MessageDefinitionTuple] = {&#39;W4902&#39;:</span>
<span class="gd">-        (&#39;Using deprecated method %s()&#39;, &#39;deprecated-method&#39;,</span>
<span class="gd">-        &#39;The method is marked as deprecated and will be removed in the future.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;W1505&#39;, &#39;old-deprecated-method&#39;)], &#39;shared&#39;: True})}</span>
<span class="gd">-    DEPRECATED_ARGUMENT_MESSAGE: dict[str, MessageDefinitionTuple] = {&#39;W4903&#39;:</span>
<span class="gd">-        (&#39;Using deprecated argument %s of method %s()&#39;,</span>
<span class="gd">-        &#39;deprecated-argument&#39;,</span>
<span class="gd">-        &#39;The argument is marked as deprecated and will be removed in the future.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;W1511&#39;, &#39;old-deprecated-argument&#39;)], &#39;shared&#39;: </span>
<span class="gd">-        True})}</span>
<span class="gd">-    DEPRECATED_CLASS_MESSAGE: dict[str, MessageDefinitionTuple] = {&#39;W4904&#39;:</span>
<span class="gd">-        (&#39;Using deprecated class %s of module %s&#39;, &#39;deprecated-class&#39;,</span>
<span class="gd">-        &#39;The class is marked as deprecated and will be removed in the future.&#39;,</span>
<span class="gd">-        {&#39;old_names&#39;: [(&#39;W1512&#39;, &#39;old-deprecated-class&#39;)], &#39;shared&#39;: True})}</span>
<span class="gd">-    DEPRECATED_DECORATOR_MESSAGE: dict[str, MessageDefinitionTuple] = {&#39;W4905&#39;:</span>
<span class="gd">-        (&#39;Using deprecated decorator %s()&#39;, &#39;deprecated-decorator&#39;,</span>
<span class="gd">-        &#39;The decorator is marked as deprecated and will be removed in the future.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;W1513&#39;, &#39;old-deprecated-decorator&#39;)], &#39;shared&#39;: </span>
<span class="gd">-        True})}</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;deprecated-attribute&#39;)</span>
<span class="gd">-    def visit_attribute(self, node: astroid.Attribute) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    DEPRECATED_ATTRIBUTE_MESSAGE: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+        &quot;W4906&quot;: (</span>
<span class="gi">+            &quot;Using deprecated attribute %r&quot;,</span>
<span class="gi">+            &quot;deprecated-attribute&quot;,</span>
<span class="gi">+            &quot;The attribute is marked as deprecated and will be removed in the future.&quot;,</span>
<span class="gi">+            {&quot;shared&quot;: True},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    DEPRECATED_MODULE_MESSAGE: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+        &quot;W4901&quot;: (</span>
<span class="gi">+            &quot;Deprecated module %r&quot;,</span>
<span class="gi">+            &quot;deprecated-module&quot;,</span>
<span class="gi">+            &quot;A module marked as deprecated is imported.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W0402&quot;, &quot;old-deprecated-module&quot;)], &quot;shared&quot;: True},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    DEPRECATED_METHOD_MESSAGE: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+        &quot;W4902&quot;: (</span>
<span class="gi">+            &quot;Using deprecated method %s()&quot;,</span>
<span class="gi">+            &quot;deprecated-method&quot;,</span>
<span class="gi">+            &quot;The method is marked as deprecated and will be removed in the future.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W1505&quot;, &quot;old-deprecated-method&quot;)], &quot;shared&quot;: True},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    DEPRECATED_ARGUMENT_MESSAGE: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+        &quot;W4903&quot;: (</span>
<span class="gi">+            &quot;Using deprecated argument %s of method %s()&quot;,</span>
<span class="gi">+            &quot;deprecated-argument&quot;,</span>
<span class="gi">+            &quot;The argument is marked as deprecated and will be removed in the future.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W1511&quot;, &quot;old-deprecated-argument&quot;)], &quot;shared&quot;: True},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    DEPRECATED_CLASS_MESSAGE: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+        &quot;W4904&quot;: (</span>
<span class="gi">+            &quot;Using deprecated class %s of module %s&quot;,</span>
<span class="gi">+            &quot;deprecated-class&quot;,</span>
<span class="gi">+            &quot;The class is marked as deprecated and will be removed in the future.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W1512&quot;, &quot;old-deprecated-class&quot;)], &quot;shared&quot;: True},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    DEPRECATED_DECORATOR_MESSAGE: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+        &quot;W4905&quot;: (</span>
<span class="gi">+            &quot;Using deprecated decorator %s()&quot;,</span>
<span class="gi">+            &quot;deprecated-decorator&quot;,</span>
<span class="gi">+            &quot;The decorator is marked as deprecated and will be removed in the future.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W1513&quot;, &quot;old-deprecated-decorator&quot;)], &quot;shared&quot;: True},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;deprecated-attribute&quot;)</span>
<span class="gi">+    def visit_attribute(self, node: astroid.Attribute) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called when an `astroid.Attribute` node is visited.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.check_deprecated_attribute(node)</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;deprecated-method&#39;,</span>
<span class="gd">-        &#39;deprecated-argument&#39;, &#39;deprecated-class&#39;)</span>
<span class="gd">-    def visit_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;deprecated-method&quot;,</span>
<span class="gi">+        &quot;deprecated-argument&quot;,</span>
<span class="gi">+        &quot;deprecated-class&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called when a :class:`nodes.Call` node is visited.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.check_deprecated_class_in_call(node)</span>
<span class="gi">+        for inferred in infer_all(node.func):</span>
<span class="gi">+            # Calling entry point for deprecation check logic.</span>
<span class="gi">+            self.check_deprecated_method(node, inferred)</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;deprecated-module&#39;, &#39;deprecated-class&#39;)</span>
<span class="gd">-    def visit_import(self, node: nodes.Import) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;deprecated-module&quot;,</span>
<span class="gi">+        &quot;deprecated-class&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_import(self, node: nodes.Import) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Triggered when an import statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name in (name for name, _ in node.names):</span>
<span class="gi">+            self.check_deprecated_module(node, name)</span>
<span class="gi">+            if &quot;.&quot; in name:</span>
<span class="gi">+                # Checking deprecation for import module with class</span>
<span class="gi">+                mod_name, class_name = name.split(&quot;.&quot;, 1)</span>
<span class="gi">+                self.check_deprecated_class(node, mod_name, (class_name,))</span>

<span class="gd">-    def deprecated_decorators(self) -&gt;Iterable[str]:</span>
<span class="gi">+    def deprecated_decorators(self) -&gt; Iterable[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated decorators.

<span class="w"> </span>        Returns:
<span class="w"> </span>            collections.abc.Container of deprecated decorator names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ()</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;deprecated-decorator&#39;)</span>
<span class="gd">-    def visit_decorators(self, node: nodes.Decorators) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;deprecated-decorator&quot;)</span>
<span class="gi">+    def visit_decorators(self, node: nodes.Decorators) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Triggered when a decorator statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        children = list(node.get_children())</span>
<span class="gi">+        if not children:</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(children[0], nodes.Call):</span>
<span class="gi">+            inf = safe_infer(children[0].func)</span>
<span class="gi">+        else:</span>
<span class="gi">+            inf = safe_infer(children[0])</span>
<span class="gi">+        qname = inf.qname() if inf else None</span>
<span class="gi">+        if qname in self.deprecated_decorators():</span>
<span class="gi">+            self.add_message(&quot;deprecated-decorator&quot;, node=node, args=qname)</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;deprecated-module&#39;, &#39;deprecated-class&#39;)</span>
<span class="gd">-    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;deprecated-module&quot;,</span>
<span class="gi">+        &quot;deprecated-class&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Triggered when a from statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        basename = node.modname</span>
<span class="gi">+        basename = get_import_name(node, basename)</span>
<span class="gi">+        self.check_deprecated_module(node, basename)</span>
<span class="gi">+        class_names = (name for name, _ in node.names)</span>
<span class="gi">+        self.check_deprecated_class(node, basename, class_names)</span>

<span class="gd">-    def deprecated_methods(self) -&gt;Container[str]:</span>
<span class="gi">+    def deprecated_methods(self) -&gt; Container[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated methods/functions.

<span class="w"> </span>        Returns:
<span class="w"> </span>            collections.abc.Container of deprecated function/method names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ()</span>

<span class="gd">-    def deprecated_arguments(self, method: str) -&gt;Iterable[tuple[int | None,</span>
<span class="gd">-        str]]:</span>
<span class="gi">+    def deprecated_arguments(self, method: str) -&gt; Iterable[tuple[int | None, str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated arguments of method/function.

<span class="w"> </span>        Args:
<span class="gu">@@ -113,17 +183,18 @@ class DeprecatedMixin(BaseChecker):</span>
<span class="w"> </span>            .. code-block:: python
<span class="w"> </span>                ((1, &#39;arg2&#39;), (3, &#39;arg4&#39;))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # pylint: disable=unused-argument</span>
<span class="gi">+        return ()</span>

<span class="gd">-    def deprecated_modules(self) -&gt;Iterable[str]:</span>
<span class="gi">+    def deprecated_modules(self) -&gt; Iterable[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated modules.

<span class="w"> </span>        Returns:
<span class="w"> </span>            collections.abc.Container of deprecated module names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ()</span>

<span class="gd">-    def deprecated_classes(self, module: str) -&gt;Iterable[str]:</span>
<span class="gi">+    def deprecated_classes(self, module: str) -&gt; Iterable[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated classes of module.

<span class="w"> </span>        Args:
<span class="gu">@@ -132,34 +203,85 @@ class DeprecatedMixin(BaseChecker):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            collections.abc.Container of deprecated class names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # pylint: disable=unused-argument</span>
<span class="gi">+        return ()</span>

<span class="gd">-    def deprecated_attributes(self) -&gt;Iterable[str]:</span>
<span class="gi">+    def deprecated_attributes(self) -&gt; Iterable[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated attributes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ()</span>

<span class="gd">-    def check_deprecated_attribute(self, node: astroid.Attribute) -&gt;None:</span>
<span class="gi">+    def check_deprecated_attribute(self, node: astroid.Attribute) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks if the attribute is deprecated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred_expr = safe_infer(node.expr)</span>
<span class="gi">+        if not isinstance(inferred_expr, (nodes.ClassDef, Instance, nodes.Module)):</span>
<span class="gi">+            return</span>
<span class="gi">+        attribute_qname = &quot;.&quot;.join((inferred_expr.qname(), node.attrname))</span>
<span class="gi">+        for deprecated_name in self.deprecated_attributes():</span>
<span class="gi">+            if attribute_qname == deprecated_name:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;deprecated-attribute&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(attribute_qname,),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>

<span class="gd">-    def check_deprecated_module(self, node: nodes.Import, mod_path: (str |</span>
<span class="gd">-        None)) -&gt;None:</span>
<span class="gi">+    def check_deprecated_module(self, node: nodes.Import, mod_path: str | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks if the module is deprecated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for mod_name in self.deprecated_modules():</span>
<span class="gi">+            if mod_path == mod_name or mod_path and mod_path.startswith(mod_name + &quot;.&quot;):</span>
<span class="gi">+                self.add_message(&quot;deprecated-module&quot;, node=node, args=mod_path)</span>

<span class="gd">-    def check_deprecated_method(self, node: nodes.Call, inferred: nodes.NodeNG</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def check_deprecated_method(self, node: nodes.Call, inferred: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Executes the checker for the given node.

<span class="w"> </span>        This method should be called from the checker implementing this mixin.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Reject nodes which aren&#39;t of interest to us.</span>
<span class="gi">+        if not isinstance(inferred, ACCEPTABLE_NODES):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+            func_name = node.func.attrname</span>
<span class="gi">+        elif isinstance(node.func, nodes.Name):</span>
<span class="gi">+            func_name = node.func.name</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Not interested in other nodes.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        qnames = {inferred.qname(), func_name}</span>
<span class="gi">+        if any(name in self.deprecated_methods() for name in qnames):</span>
<span class="gi">+            self.add_message(&quot;deprecated-method&quot;, node=node, args=(func_name,))</span>
<span class="gi">+            return</span>
<span class="gi">+        num_of_args = len(node.args)</span>
<span class="gi">+        kwargs = {kw.arg for kw in node.keywords} if node.keywords else {}</span>
<span class="gi">+        deprecated_arguments = (self.deprecated_arguments(qn) for qn in qnames)</span>
<span class="gi">+        for position, arg_name in chain(*deprecated_arguments):</span>
<span class="gi">+            if arg_name in kwargs:</span>
<span class="gi">+                # function was called with deprecated argument as keyword argument</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;deprecated-argument&quot;, node=node, args=(arg_name, func_name)</span>
<span class="gi">+                )</span>
<span class="gi">+            elif position is not None and position &lt; num_of_args:</span>
<span class="gi">+                # function was called with deprecated argument as positional argument</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;deprecated-argument&quot;, node=node, args=(arg_name, func_name)</span>
<span class="gi">+                )</span>

<span class="gd">-    def check_deprecated_class(self, node: nodes.NodeNG, mod_name: str,</span>
<span class="gd">-        class_names: Iterable[str]) -&gt;None:</span>
<span class="gi">+    def check_deprecated_class(</span>
<span class="gi">+        self, node: nodes.NodeNG, mod_name: str, class_names: Iterable[str]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks if the class is deprecated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for class_name in class_names:</span>
<span class="gi">+            if class_name in self.deprecated_classes(mod_name):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;deprecated-class&quot;, node=node, args=(class_name, mod_name)</span>
<span class="gi">+                )</span>

<span class="gd">-    def check_deprecated_class_in_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    def check_deprecated_class_in_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks if call the deprecated class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Attribute) and isinstance(</span>
<span class="gi">+            node.func.expr, nodes.Name</span>
<span class="gi">+        ):</span>
<span class="gi">+            mod_name = node.func.expr.name</span>
<span class="gi">+            class_name = node.func.attrname</span>
<span class="gi">+            self.check_deprecated_class(node, mod_name, (class_name,))</span>
<span class="gh">diff --git a/pylint/checkers/design_analysis.py b/pylint/checkers/design_analysis.py</span>
<span class="gh">index 0c785dc35..78378e92c 100644</span>
<span class="gd">--- a/pylint/checkers/design_analysis.py</span>
<span class="gi">+++ b/pylint/checkers/design_analysis.py</span>
<span class="gu">@@ -1,117 +1,291 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Check for signs of poor design.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from collections.abc import Iterator
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import is_enum, only_required_for_messages
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;R0901&#39;: (</span>
<span class="gd">-    &#39;Too many ancestors (%s/%s)&#39;, &#39;too-many-ancestors&#39;,</span>
<span class="gd">-    &#39;Used when class has too many parent classes, try to reduce this to get a simpler (and so easier to use) class.&#39;</span>
<span class="gd">-    ), &#39;R0902&#39;: (&#39;Too many instance attributes (%s/%s)&#39;,</span>
<span class="gd">-    &#39;too-many-instance-attributes&#39;,</span>
<span class="gd">-    &#39;Used when class has too many instance attributes, try to reduce this to get a simpler (and so easier to use) class.&#39;</span>
<span class="gd">-    ), &#39;R0903&#39;: (&#39;Too few public methods (%s/%s)&#39;, &#39;too-few-public-methods&#39;,</span>
<span class="gd">-    &quot;Used when class has too few public methods, so be sure it&#39;s really worth it.&quot;</span>
<span class="gd">-    ), &#39;R0904&#39;: (&#39;Too many public methods (%s/%s)&#39;,</span>
<span class="gd">-    &#39;too-many-public-methods&#39;,</span>
<span class="gd">-    &#39;Used when class has too many public methods, try to reduce this to get a simpler (and so easier to use) class.&#39;</span>
<span class="gd">-    ), &#39;R0911&#39;: (&#39;Too many return statements (%s/%s)&#39;,</span>
<span class="gd">-    &#39;too-many-return-statements&#39;,</span>
<span class="gd">-    &#39;Used when a function or method has too many return statement, making it hard to follow.&#39;</span>
<span class="gd">-    ), &#39;R0912&#39;: (&#39;Too many branches (%s/%s)&#39;, &#39;too-many-branches&#39;,</span>
<span class="gd">-    &#39;Used when a function or method has too many branches, making it hard to follow.&#39;</span>
<span class="gd">-    ), &#39;R0913&#39;: (&#39;Too many arguments (%s/%s)&#39;, &#39;too-many-arguments&#39;,</span>
<span class="gd">-    &#39;Used when a function or method takes too many arguments.&#39;), &#39;R0914&#39;: (</span>
<span class="gd">-    &#39;Too many local variables (%s/%s)&#39;, &#39;too-many-locals&#39;,</span>
<span class="gd">-    &#39;Used when a function or method has too many local variables.&#39;),</span>
<span class="gd">-    &#39;R0915&#39;: (&#39;Too many statements (%s/%s)&#39;, &#39;too-many-statements&#39;,</span>
<span class="gd">-    &#39;Used when a function or method has too many statements. You should then split it in smaller functions / methods.&#39;</span>
<span class="gd">-    ), &#39;R0916&#39;: (&#39;Too many boolean expressions in if statement (%s/%s)&#39;,</span>
<span class="gd">-    &#39;too-many-boolean-expressions&#39;,</span>
<span class="gd">-    &#39;Used when an if statement contains too many boolean expressions.&#39;),</span>
<span class="gd">-    &#39;R0917&#39;: (&#39;Too many positional arguments in a function call.&#39;,</span>
<span class="gd">-    &#39;too-many-positional&#39;,</span>
<span class="gd">-    &#39;Will be implemented in https://github.com/pylint-dev/pylint/issues/9099,msgid/symbol pair reserved for compatibility with ruff, see https://github.com/astral-sh/ruff/issues/8946.&#39;</span>
<span class="gd">-    )}</span>
<span class="gd">-SPECIAL_OBJ = re.compile(&#39;^_{2}[a-z]+_{2}$&#39;)</span>
<span class="gd">-DATACLASSES_DECORATORS = frozenset({&#39;dataclass&#39;, &#39;attrs&#39;})</span>
<span class="gd">-DATACLASS_IMPORT = &#39;dataclasses&#39;</span>
<span class="gd">-ATTRS_DECORATORS = frozenset({&#39;define&#39;, &#39;frozen&#39;})</span>
<span class="gd">-ATTRS_IMPORT = &#39;attrs&#39;</span>
<span class="gd">-TYPING_NAMEDTUPLE = &#39;typing.NamedTuple&#39;</span>
<span class="gd">-TYPING_TYPEDDICT = &#39;typing.TypedDict&#39;</span>
<span class="gd">-TYPING_EXTENSIONS_TYPEDDICT = &#39;typing_extensions.TypedDict&#39;</span>
<span class="gd">-STDLIB_CLASSES_IGNORE_ANCESTOR = frozenset((&#39;builtins.object&#39;,</span>
<span class="gd">-    &#39;builtins.tuple&#39;, &#39;builtins.dict&#39;, &#39;builtins.list&#39;, &#39;builtins.set&#39;,</span>
<span class="gd">-    &#39;bulitins.frozenset&#39;, &#39;collections.ChainMap&#39;, &#39;collections.Counter&#39;,</span>
<span class="gd">-    &#39;collections.OrderedDict&#39;, &#39;collections.UserDict&#39;,</span>
<span class="gd">-    &#39;collections.UserList&#39;, &#39;collections.UserString&#39;,</span>
<span class="gd">-    &#39;collections.defaultdict&#39;, &#39;collections.deque&#39;,</span>
<span class="gd">-    &#39;collections.namedtuple&#39;, &#39;_collections_abc.Awaitable&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Coroutine&#39;, &#39;_collections_abc.AsyncIterable&#39;,</span>
<span class="gd">-    &#39;_collections_abc.AsyncIterator&#39;, &#39;_collections_abc.AsyncGenerator&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Hashable&#39;, &#39;_collections_abc.Iterable&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Iterator&#39;, &#39;_collections_abc.Generator&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Reversible&#39;, &#39;_collections_abc.Sized&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Container&#39;, &#39;_collections_abc.Collection&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Set&#39;, &#39;_collections_abc.MutableSet&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Mapping&#39;, &#39;_collections_abc.MutableMapping&#39;,</span>
<span class="gd">-    &#39;_collections_abc.MappingView&#39;, &#39;_collections_abc.KeysView&#39;,</span>
<span class="gd">-    &#39;_collections_abc.ItemsView&#39;, &#39;_collections_abc.ValuesView&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Sequence&#39;, &#39;_collections_abc.MutableSequence&#39;,</span>
<span class="gd">-    &#39;_collections_abc.ByteString&#39;, &#39;typing.Tuple&#39;, &#39;typing.List&#39;,</span>
<span class="gd">-    &#39;typing.Dict&#39;, &#39;typing.Set&#39;, &#39;typing.FrozenSet&#39;, &#39;typing.Deque&#39;,</span>
<span class="gd">-    &#39;typing.DefaultDict&#39;, &#39;typing.OrderedDict&#39;, &#39;typing.Counter&#39;,</span>
<span class="gd">-    &#39;typing.ChainMap&#39;, &#39;typing.Awaitable&#39;, &#39;typing.Coroutine&#39;,</span>
<span class="gd">-    &#39;typing.AsyncIterable&#39;, &#39;typing.AsyncIterator&#39;, &#39;typing.AsyncGenerator&#39;,</span>
<span class="gd">-    &#39;typing.Iterable&#39;, &#39;typing.Iterator&#39;, &#39;typing.Generator&#39;,</span>
<span class="gd">-    &#39;typing.Reversible&#39;, &#39;typing.Container&#39;, &#39;typing.Collection&#39;,</span>
<span class="gd">-    &#39;typing.AbstractSet&#39;, &#39;typing.MutableSet&#39;, &#39;typing.Mapping&#39;,</span>
<span class="gd">-    &#39;typing.MutableMapping&#39;, &#39;typing.Sequence&#39;, &#39;typing.MutableSequence&#39;,</span>
<span class="gd">-    &#39;typing.ByteString&#39;, &#39;typing.MappingView&#39;, &#39;typing.KeysView&#39;,</span>
<span class="gd">-    &#39;typing.ItemsView&#39;, &#39;typing.ValuesView&#39;, &#39;typing.ContextManager&#39;,</span>
<span class="gd">-    &#39;typing.AsyncContextManager&#39;, &#39;typing.Hashable&#39;, &#39;typing.Sized&#39;,</span>
<span class="gd">-    TYPING_NAMEDTUPLE, TYPING_TYPEDDICT, TYPING_EXTENSIONS_TYPEDDICT))</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _is_exempt_from_public_methods(node: astroid.ClassDef) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = (</span>
<span class="gi">+    {  # pylint: disable=consider-using-namedtuple-or-dataclass</span>
<span class="gi">+        &quot;R0901&quot;: (</span>
<span class="gi">+            &quot;Too many ancestors (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-ancestors&quot;,</span>
<span class="gi">+            &quot;Used when class has too many parent classes, try to reduce &quot;</span>
<span class="gi">+            &quot;this to get a simpler (and so easier to use) class.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0902&quot;: (</span>
<span class="gi">+            &quot;Too many instance attributes (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-instance-attributes&quot;,</span>
<span class="gi">+            &quot;Used when class has too many instance attributes, try to reduce &quot;</span>
<span class="gi">+            &quot;this to get a simpler (and so easier to use) class.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0903&quot;: (</span>
<span class="gi">+            &quot;Too few public methods (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-few-public-methods&quot;,</span>
<span class="gi">+            &quot;Used when class has too few public methods, so be sure it&#39;s &quot;</span>
<span class="gi">+            &quot;really worth it.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0904&quot;: (</span>
<span class="gi">+            &quot;Too many public methods (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-public-methods&quot;,</span>
<span class="gi">+            &quot;Used when class has too many public methods, try to reduce &quot;</span>
<span class="gi">+            &quot;this to get a simpler (and so easier to use) class.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0911&quot;: (</span>
<span class="gi">+            &quot;Too many return statements (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-return-statements&quot;,</span>
<span class="gi">+            &quot;Used when a function or method has too many return statement, &quot;</span>
<span class="gi">+            &quot;making it hard to follow.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0912&quot;: (</span>
<span class="gi">+            &quot;Too many branches (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-branches&quot;,</span>
<span class="gi">+            &quot;Used when a function or method has too many branches, &quot;</span>
<span class="gi">+            &quot;making it hard to follow.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0913&quot;: (</span>
<span class="gi">+            &quot;Too many arguments (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-arguments&quot;,</span>
<span class="gi">+            &quot;Used when a function or method takes too many arguments.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0914&quot;: (</span>
<span class="gi">+            &quot;Too many local variables (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-locals&quot;,</span>
<span class="gi">+            &quot;Used when a function or method has too many local variables.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0915&quot;: (</span>
<span class="gi">+            &quot;Too many statements (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-statements&quot;,</span>
<span class="gi">+            &quot;Used when a function or method has too many statements. You &quot;</span>
<span class="gi">+            &quot;should then split it in smaller functions / methods.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0916&quot;: (</span>
<span class="gi">+            &quot;Too many boolean expressions in if statement (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-boolean-expressions&quot;,</span>
<span class="gi">+            &quot;Used when an if statement contains too many boolean expressions.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R0917&quot;: (</span>
<span class="gi">+            &quot;Too many positional arguments in a function call.&quot;,</span>
<span class="gi">+            &quot;too-many-positional&quot;,</span>
<span class="gi">+            &quot;Will be implemented in https://github.com/pylint-dev/pylint/issues/9099,&quot;</span>
<span class="gi">+            &quot;msgid/symbol pair reserved for compatibility with ruff, &quot;</span>
<span class="gi">+            &quot;see https://github.com/astral-sh/ruff/issues/8946.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+)</span>
<span class="gi">+SPECIAL_OBJ = re.compile(&quot;^_{2}[a-z]+_{2}$&quot;)</span>
<span class="gi">+DATACLASSES_DECORATORS = frozenset({&quot;dataclass&quot;, &quot;attrs&quot;})</span>
<span class="gi">+DATACLASS_IMPORT = &quot;dataclasses&quot;</span>
<span class="gi">+ATTRS_DECORATORS = frozenset({&quot;define&quot;, &quot;frozen&quot;})</span>
<span class="gi">+ATTRS_IMPORT = &quot;attrs&quot;</span>
<span class="gi">+TYPING_NAMEDTUPLE = &quot;typing.NamedTuple&quot;</span>
<span class="gi">+TYPING_TYPEDDICT = &quot;typing.TypedDict&quot;</span>
<span class="gi">+TYPING_EXTENSIONS_TYPEDDICT = &quot;typing_extensions.TypedDict&quot;</span>
<span class="gi">+</span>
<span class="gi">+# Set of stdlib classes to ignore when calculating number of ancestors</span>
<span class="gi">+STDLIB_CLASSES_IGNORE_ANCESTOR = frozenset(</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;builtins.object&quot;,</span>
<span class="gi">+        &quot;builtins.tuple&quot;,</span>
<span class="gi">+        &quot;builtins.dict&quot;,</span>
<span class="gi">+        &quot;builtins.list&quot;,</span>
<span class="gi">+        &quot;builtins.set&quot;,</span>
<span class="gi">+        &quot;bulitins.frozenset&quot;,</span>
<span class="gi">+        &quot;collections.ChainMap&quot;,</span>
<span class="gi">+        &quot;collections.Counter&quot;,</span>
<span class="gi">+        &quot;collections.OrderedDict&quot;,</span>
<span class="gi">+        &quot;collections.UserDict&quot;,</span>
<span class="gi">+        &quot;collections.UserList&quot;,</span>
<span class="gi">+        &quot;collections.UserString&quot;,</span>
<span class="gi">+        &quot;collections.defaultdict&quot;,</span>
<span class="gi">+        &quot;collections.deque&quot;,</span>
<span class="gi">+        &quot;collections.namedtuple&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Awaitable&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Coroutine&quot;,</span>
<span class="gi">+        &quot;_collections_abc.AsyncIterable&quot;,</span>
<span class="gi">+        &quot;_collections_abc.AsyncIterator&quot;,</span>
<span class="gi">+        &quot;_collections_abc.AsyncGenerator&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Hashable&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Iterable&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Iterator&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Generator&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Reversible&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Sized&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Container&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Collection&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Set&quot;,</span>
<span class="gi">+        &quot;_collections_abc.MutableSet&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Mapping&quot;,</span>
<span class="gi">+        &quot;_collections_abc.MutableMapping&quot;,</span>
<span class="gi">+        &quot;_collections_abc.MappingView&quot;,</span>
<span class="gi">+        &quot;_collections_abc.KeysView&quot;,</span>
<span class="gi">+        &quot;_collections_abc.ItemsView&quot;,</span>
<span class="gi">+        &quot;_collections_abc.ValuesView&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Sequence&quot;,</span>
<span class="gi">+        &quot;_collections_abc.MutableSequence&quot;,</span>
<span class="gi">+        &quot;_collections_abc.ByteString&quot;,</span>
<span class="gi">+        &quot;typing.Tuple&quot;,</span>
<span class="gi">+        &quot;typing.List&quot;,</span>
<span class="gi">+        &quot;typing.Dict&quot;,</span>
<span class="gi">+        &quot;typing.Set&quot;,</span>
<span class="gi">+        &quot;typing.FrozenSet&quot;,</span>
<span class="gi">+        &quot;typing.Deque&quot;,</span>
<span class="gi">+        &quot;typing.DefaultDict&quot;,</span>
<span class="gi">+        &quot;typing.OrderedDict&quot;,</span>
<span class="gi">+        &quot;typing.Counter&quot;,</span>
<span class="gi">+        &quot;typing.ChainMap&quot;,</span>
<span class="gi">+        &quot;typing.Awaitable&quot;,</span>
<span class="gi">+        &quot;typing.Coroutine&quot;,</span>
<span class="gi">+        &quot;typing.AsyncIterable&quot;,</span>
<span class="gi">+        &quot;typing.AsyncIterator&quot;,</span>
<span class="gi">+        &quot;typing.AsyncGenerator&quot;,</span>
<span class="gi">+        &quot;typing.Iterable&quot;,</span>
<span class="gi">+        &quot;typing.Iterator&quot;,</span>
<span class="gi">+        &quot;typing.Generator&quot;,</span>
<span class="gi">+        &quot;typing.Reversible&quot;,</span>
<span class="gi">+        &quot;typing.Container&quot;,</span>
<span class="gi">+        &quot;typing.Collection&quot;,</span>
<span class="gi">+        &quot;typing.AbstractSet&quot;,</span>
<span class="gi">+        &quot;typing.MutableSet&quot;,</span>
<span class="gi">+        &quot;typing.Mapping&quot;,</span>
<span class="gi">+        &quot;typing.MutableMapping&quot;,</span>
<span class="gi">+        &quot;typing.Sequence&quot;,</span>
<span class="gi">+        &quot;typing.MutableSequence&quot;,</span>
<span class="gi">+        &quot;typing.ByteString&quot;,</span>
<span class="gi">+        &quot;typing.MappingView&quot;,</span>
<span class="gi">+        &quot;typing.KeysView&quot;,</span>
<span class="gi">+        &quot;typing.ItemsView&quot;,</span>
<span class="gi">+        &quot;typing.ValuesView&quot;,</span>
<span class="gi">+        &quot;typing.ContextManager&quot;,</span>
<span class="gi">+        &quot;typing.AsyncContextManager&quot;,</span>
<span class="gi">+        &quot;typing.Hashable&quot;,</span>
<span class="gi">+        &quot;typing.Sized&quot;,</span>
<span class="gi">+        TYPING_NAMEDTUPLE,</span>
<span class="gi">+        TYPING_TYPEDDICT,</span>
<span class="gi">+        TYPING_EXTENSIONS_TYPEDDICT,</span>
<span class="gi">+    )</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_exempt_from_public_methods(node: astroid.ClassDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a class is exempt from too-few-public-methods.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # If it&#39;s a typing.Namedtuple, typing.TypedDict or an Enum</span>
<span class="gi">+    for ancestor in node.ancestors():</span>
<span class="gi">+        if is_enum(ancestor):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if ancestor.qname() in (</span>
<span class="gi">+            TYPING_NAMEDTUPLE,</span>
<span class="gi">+            TYPING_TYPEDDICT,</span>
<span class="gi">+            TYPING_EXTENSIONS_TYPEDDICT,</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    # Or if it&#39;s a dataclass</span>
<span class="gi">+    if not node.decorators:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    root_locals = set(node.root().locals)</span>
<span class="gi">+    for decorator in node.decorators.nodes:</span>
<span class="gi">+        if isinstance(decorator, astroid.Call):</span>
<span class="gi">+            decorator = decorator.func</span>
<span class="gi">+        if not isinstance(decorator, (astroid.Name, astroid.Attribute)):</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(decorator, astroid.Name):</span>
<span class="gi">+            name = decorator.name</span>
<span class="gi">+        else:</span>
<span class="gi">+            name = decorator.attrname</span>
<span class="gi">+        if name in DATACLASSES_DECORATORS and (</span>
<span class="gi">+            root_locals.intersection(DATACLASSES_DECORATORS)</span>
<span class="gi">+            or DATACLASS_IMPORT in root_locals</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if name in ATTRS_DECORATORS and (</span>
<span class="gi">+            root_locals.intersection(ATTRS_DECORATORS) or ATTRS_IMPORT in root_locals</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def _count_boolean_expressions(bool_op: nodes.BoolOp) -&gt;int:</span>
<span class="gi">+def _count_boolean_expressions(bool_op: nodes.BoolOp) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Counts the number of boolean expressions in BoolOp `bool_op` (recursive).

<span class="w"> </span>    example: a and (b or c or (d and e)) ==&gt; 5 boolean expressions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nb_bool_expr = 0</span>
<span class="gi">+    for bool_expr in bool_op.get_children():</span>
<span class="gi">+        if isinstance(bool_expr, astroid.BoolOp):</span>
<span class="gi">+            nb_bool_expr += _count_boolean_expressions(bool_expr)</span>
<span class="gi">+        else:</span>
<span class="gi">+            nb_bool_expr += 1</span>
<span class="gi">+    return nb_bool_expr</span>


<span class="gd">-def _get_parents_iter(node: nodes.ClassDef, ignored_parents: frozenset[str]</span>
<span class="gd">-    ) -&gt;Iterator[nodes.ClassDef]:</span>
<span class="gd">-    &quot;&quot;&quot;Get parents of ``node``, excluding ancestors of ``ignored_parents``.</span>
<span class="gi">+def _count_methods_in_class(node: nodes.ClassDef) -&gt; int:</span>
<span class="gi">+    all_methods = sum(1 for method in node.methods() if not method.name.startswith(&quot;_&quot;))</span>
<span class="gi">+    # Special methods count towards the number of public methods,</span>
<span class="gi">+    # but don&#39;t count towards there being too many methods.</span>
<span class="gi">+    for method in node.mymethods():</span>
<span class="gi">+        if SPECIAL_OBJ.search(method.name) and method.name != &quot;__init__&quot;:</span>
<span class="gi">+            all_methods += 1</span>
<span class="gi">+    return all_methods</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_parents_iter(</span>
<span class="gi">+    node: nodes.ClassDef, ignored_parents: frozenset[str]</span>
<span class="gi">+) -&gt; Iterator[nodes.ClassDef]:</span>
<span class="gi">+    r&quot;&quot;&quot;Get parents of ``node``, excluding ancestors of ``ignored_parents``.</span>

<span class="w"> </span>    If we have the following inheritance diagram:

<span class="w"> </span>             F
<span class="w"> </span>            /
<span class="w"> </span>        D  E
<span class="gd">-         \\/</span>
<span class="gi">+         \/</span>
<span class="w"> </span>          B  C
<span class="gd">-           \\/</span>
<span class="gi">+           \/</span>
<span class="w"> </span>            A      # class A(B, C): ...

<span class="w"> </span>    And ``ignored_parents`` is ``{&quot;E&quot;}``, then this function will return
<span class="w"> </span>    ``{A, B, C, D}`` -- both ``E`` and its ancestors are excluded.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parents: set[nodes.ClassDef] = set()</span>
<span class="gi">+    to_explore = list(node.ancestors(recurs=False))</span>
<span class="gi">+    while to_explore:</span>
<span class="gi">+        parent = to_explore.pop()</span>
<span class="gi">+        if parent.qname() in ignored_parents:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if parent not in parents:</span>
<span class="gi">+            # This guard might appear to be performing the same function as</span>
<span class="gi">+            # adding the resolved parents to a set to eliminate duplicates</span>
<span class="gi">+            # (legitimate due to diamond inheritance patterns), but its</span>
<span class="gi">+            # additional purpose is to prevent cycles (not normally possible,</span>
<span class="gi">+            # but potential due to inference) and thus guarantee termination</span>
<span class="gi">+            # of the while-loop</span>
<span class="gi">+            yield parent</span>
<span class="gi">+            parents.add(parent)</span>
<span class="gi">+            to_explore.extend(parent.ancestors(recurs=False))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_parents(</span>
<span class="gi">+    node: nodes.ClassDef, ignored_parents: frozenset[str]</span>
<span class="gi">+) -&gt; set[nodes.ClassDef]:</span>
<span class="gi">+    return set(_get_parents_iter(node, ignored_parents))</span>


<span class="w"> </span>class MisdesignChecker(BaseChecker):
<span class="gu">@@ -121,115 +295,382 @@ class MisdesignChecker(BaseChecker):</span>
<span class="w"> </span>    * number of methods, attributes, local variables...
<span class="w"> </span>    * size, complexity of functions, methods
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;design&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;design&quot;</span>
<span class="gi">+    # messages</span>
<span class="w"> </span>    msgs = MSGS
<span class="gd">-    options = (&#39;max-args&#39;, {&#39;default&#39;: 5, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;: &#39;&lt;int&gt;&#39;,</span>
<span class="gd">-        &#39;help&#39;: &#39;Maximum number of arguments for function / method.&#39;}), (</span>
<span class="gd">-        &#39;max-locals&#39;, {&#39;default&#39;: 15, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;: &#39;&lt;int&gt;&#39;,</span>
<span class="gd">-        &#39;help&#39;: &#39;Maximum number of locals for function / method body.&#39;}), (</span>
<span class="gd">-        &#39;max-returns&#39;, {&#39;default&#39;: 6, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;: &#39;&lt;int&gt;&#39;,</span>
<span class="gd">-        &#39;help&#39;: &#39;Maximum number of return / yield for function / method body.&#39;}</span>
<span class="gd">-        ), (&#39;max-branches&#39;, {&#39;default&#39;: 12, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;int&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Maximum number of branch for function / method body.&#39;}), (</span>
<span class="gd">-        &#39;max-statements&#39;, {&#39;default&#39;: 50, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;: &#39;&lt;int&gt;&#39;,</span>
<span class="gd">-        &#39;help&#39;: &#39;Maximum number of statements in function / method body.&#39;}), (</span>
<span class="gd">-        &#39;max-parents&#39;, {&#39;default&#39;: 7, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;: &#39;&lt;num&gt;&#39;,</span>
<span class="gd">-        &#39;help&#39;: &#39;Maximum number of parents for a class (see R0901).&#39;}), (</span>
<span class="gd">-        &#39;ignored-parents&#39;, {&#39;default&#39;: (), &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;comma separated list of class names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of qualified class names to ignore when counting class parents (see R0901)&#39;</span>
<span class="gd">-        }), (&#39;max-attributes&#39;, {&#39;default&#39;: 7, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;num&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Maximum number of attributes for a class (see R0902).&#39;}), (</span>
<span class="gd">-        &#39;min-public-methods&#39;, {&#39;default&#39;: 2, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;num&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Minimum number of public methods for a class (see R0903).&#39;}), (</span>
<span class="gd">-        &#39;max-public-methods&#39;, {&#39;default&#39;: 20, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;num&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Maximum number of public methods for a class (see R0904).&#39;}), (</span>
<span class="gd">-        &#39;max-bool-expr&#39;, {&#39;default&#39;: 5, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;: &#39;&lt;num&gt;&#39;,</span>
<span class="gd">-        &#39;help&#39;:</span>
<span class="gd">-        &#39;Maximum number of boolean expressions in an if statement (see R0916).&#39;</span>
<span class="gd">-        }), (&#39;exclude-too-few-public-methods&#39;, {&#39;default&#39;: [], &#39;type&#39;:</span>
<span class="gd">-        &#39;regexp_csv&#39;, &#39;metavar&#39;: &#39;&lt;pattern&gt;[,&lt;pattern&gt;...]&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of regular expressions of class ancestor names to ignore when counting public methods (see R0903)&#39;</span>
<span class="gd">-        })</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    # configuration options</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-args&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 5,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of arguments for function / method.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-locals&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 15,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of locals for function / method body.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-returns&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 6,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of return / yield for function / &quot;</span>
<span class="gi">+                &quot;method body.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-branches&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 12,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of branch for function / method body.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-statements&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 50,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of statements in function / method body.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-parents&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 7,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;num&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of parents for a class (see R0901).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignored-parents&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma separated list of class names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of qualified class names to ignore when counting class parents (see R0901)&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-attributes&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 7,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;num&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of attributes for a class \</span>
<span class="gi">+(see R0902).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;min-public-methods&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 2,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;num&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Minimum number of public methods for a class \</span>
<span class="gi">+(see R0903).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-public-methods&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 20,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;num&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of public methods for a class \</span>
<span class="gi">+(see R0904).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-bool-expr&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 5,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;num&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of boolean expressions in an if &quot;</span>
<span class="gi">+                &quot;statement (see R0916).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;exclude-too-few-public-methods&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: [],</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp_csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;pattern&gt;[,&lt;pattern&gt;...]&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of regular expressions of class ancestor names &quot;</span>
<span class="gi">+                &quot;to ignore when counting public methods (see R0903)&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="w"> </span>        self._returns: list[int]
<span class="w"> </span>        self._branches: defaultdict[nodes.LocalsDictNodeNG, int]
<span class="w"> </span>        self._stmts: list[int]

<span class="gd">-    def open(self) -&gt;None:</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize visit variables.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.linter.stats.reset_node_count()</span>
<span class="gi">+        self._returns = []</span>
<span class="gi">+        self._branches = defaultdict(int)</span>
<span class="gi">+        self._stmts = []</span>
<span class="gi">+        self._exclude_too_few_public_methods = (</span>
<span class="gi">+            self.linter.config.exclude_too_few_public_methods</span>
<span class="gi">+        )</span>

<span class="gd">-    @only_required_for_messages(&#39;too-many-ancestors&#39;,</span>
<span class="gd">-        &#39;too-many-instance-attributes&#39;, &#39;too-few-public-methods&#39;,</span>
<span class="gd">-        &#39;too-many-public-methods&#39;)</span>
<span class="gd">-    def visit_classdef(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    def _inc_all_stmts(self, amount: int) -&gt; None:</span>
<span class="gi">+        for i, _ in enumerate(self._stmts):</span>
<span class="gi">+            self._stmts[i] += amount</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;too-many-ancestors&quot;,</span>
<span class="gi">+        &quot;too-many-instance-attributes&quot;,</span>
<span class="gi">+        &quot;too-few-public-methods&quot;,</span>
<span class="gi">+        &quot;too-many-public-methods&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check size of inheritance hierarchy and number of instance attributes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parents = _get_parents(</span>
<span class="gi">+            node,</span>
<span class="gi">+            STDLIB_CLASSES_IGNORE_ANCESTOR.union(self.linter.config.ignored_parents),</span>
<span class="gi">+        )</span>
<span class="gi">+        nb_parents = len(parents)</span>
<span class="gi">+        if nb_parents &gt; self.linter.config.max_parents:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-ancestors&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(nb_parents, self.linter.config.max_parents),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Something at inference time is modifying instance_attrs to add</span>
<span class="gi">+        # properties from parent classes. Given how much we cache inference</span>
<span class="gi">+        # results, mutating instance_attrs can become a real mess. Filter</span>
<span class="gi">+        # them out here until the root cause is solved.</span>
<span class="gi">+        # https://github.com/pylint-dev/astroid/issues/2273</span>
<span class="gi">+        root = node.root()</span>
<span class="gi">+        filtered_attrs = [</span>
<span class="gi">+            k for (k, v) in node.instance_attrs.items() if v[0].root() is root</span>
<span class="gi">+        ]</span>
<span class="gi">+        if len(filtered_attrs) &gt; self.linter.config.max_attributes:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-instance-attributes&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(len(filtered_attrs), self.linter.config.max_attributes),</span>
<span class="gi">+            )</span>

<span class="gd">-    @only_required_for_messages(&#39;too-few-public-methods&#39;,</span>
<span class="gd">-        &#39;too-many-public-methods&#39;)</span>
<span class="gd">-    def leave_classdef(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;too-few-public-methods&quot;, &quot;too-many-public-methods&quot;)</span>
<span class="gi">+    def leave_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check number of public methods.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        my_methods = sum(</span>
<span class="gi">+            1 for method in node.mymethods() if not method.name.startswith(&quot;_&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Does the class contain less than n public methods ?</span>
<span class="gi">+        # This checks only the methods defined in the current class,</span>
<span class="gi">+        # since the user might not have control over the classes</span>
<span class="gi">+        # from the ancestors. It avoids some false positives</span>
<span class="gi">+        # for classes such as unittest.TestCase, which provides</span>
<span class="gi">+        # a lot of assert methods. It doesn&#39;t make sense to warn</span>
<span class="gi">+        # when the user subclasses TestCase to add his own tests.</span>
<span class="gi">+        if my_methods &gt; self.linter.config.max_public_methods:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-public-methods&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(my_methods, self.linter.config.max_public_methods),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Stop here if the class is excluded via configuration.</span>
<span class="gi">+        if node.type == &quot;class&quot; and self._exclude_too_few_public_methods:</span>
<span class="gi">+            for ancestor in node.ancestors():</span>
<span class="gi">+                if any(</span>
<span class="gi">+                    pattern.match(ancestor.qname())</span>
<span class="gi">+                    for pattern in self._exclude_too_few_public_methods</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+        # Stop here for exception, metaclass, interface classes and other</span>
<span class="gi">+        # classes for which we don&#39;t need to count the methods.</span>
<span class="gi">+        if node.type != &quot;class&quot; or _is_exempt_from_public_methods(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Does the class contain more than n public methods ?</span>
<span class="gi">+        # This checks all the methods defined by ancestors and</span>
<span class="gi">+        # by the current class.</span>
<span class="gi">+        all_methods = _count_methods_in_class(node)</span>
<span class="gi">+        if all_methods &lt; self.linter.config.min_public_methods:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-few-public-methods&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(all_methods, self.linter.config.min_public_methods),</span>
<span class="gi">+            )</span>

<span class="gd">-    @only_required_for_messages(&#39;too-many-return-statements&#39;,</span>
<span class="gd">-        &#39;too-many-branches&#39;, &#39;too-many-arguments&#39;, &#39;too-many-locals&#39;,</span>
<span class="gd">-        &#39;too-many-statements&#39;, &#39;keyword-arg-before-vararg&#39;)</span>
<span class="gd">-    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;too-many-return-statements&quot;,</span>
<span class="gi">+        &quot;too-many-branches&quot;,</span>
<span class="gi">+        &quot;too-many-arguments&quot;,</span>
<span class="gi">+        &quot;too-many-locals&quot;,</span>
<span class="gi">+        &quot;too-many-statements&quot;,</span>
<span class="gi">+        &quot;keyword-arg-before-vararg&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check function name, docstring, arguments, redefinition,
<span class="w"> </span>        variable names, max locals.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # init branch and returns counters</span>
<span class="gi">+        self._returns.append(0)</span>
<span class="gi">+        # check number of arguments</span>
<span class="gi">+        args = node.args.args + node.args.posonlyargs + node.args.kwonlyargs</span>
<span class="gi">+        ignored_argument_names = self.linter.config.ignored_argument_names</span>
<span class="gi">+        if args is not None:</span>
<span class="gi">+            ignored_args_num = 0</span>
<span class="gi">+            if ignored_argument_names:</span>
<span class="gi">+                ignored_args_num = sum(</span>
<span class="gi">+                    1 for arg in args if ignored_argument_names.match(arg.name)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            argnum = len(args) - ignored_args_num</span>
<span class="gi">+            if argnum &gt; self.linter.config.max_args:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;too-many-arguments&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(len(args), self.linter.config.max_args),</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            ignored_args_num = 0</span>
<span class="gi">+        # check number of local variables</span>
<span class="gi">+        locnum = len(node.locals) - ignored_args_num</span>
<span class="gi">+</span>
<span class="gi">+        # decrement number of local variables if &#39;_&#39; is one of them</span>
<span class="gi">+        if &quot;_&quot; in node.locals:</span>
<span class="gi">+            locnum -= 1</span>
<span class="gi">+</span>
<span class="gi">+        if locnum &gt; self.linter.config.max_locals:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-locals&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(locnum, self.linter.config.max_locals),</span>
<span class="gi">+            )</span>
<span class="gi">+        # init new statements counter</span>
<span class="gi">+        self._stmts.append(1)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    @only_required_for_messages(&#39;too-many-return-statements&#39;,</span>
<span class="gd">-        &#39;too-many-branches&#39;, &#39;too-many-arguments&#39;, &#39;too-many-locals&#39;,</span>
<span class="gd">-        &#39;too-many-statements&#39;)</span>
<span class="gd">-    def leave_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;too-many-return-statements&quot;,</span>
<span class="gi">+        &quot;too-many-branches&quot;,</span>
<span class="gi">+        &quot;too-many-arguments&quot;,</span>
<span class="gi">+        &quot;too-many-locals&quot;,</span>
<span class="gi">+        &quot;too-many-statements&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def leave_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Most of the work is done here on close:
<span class="w"> </span>        checks for max returns, branch, return in __init__.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        returns = self._returns.pop()</span>
<span class="gi">+        if returns &gt; self.linter.config.max_returns:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-return-statements&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(returns, self.linter.config.max_returns),</span>
<span class="gi">+            )</span>
<span class="gi">+        branches = self._branches[node]</span>
<span class="gi">+        if branches &gt; self.linter.config.max_branches:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-branches&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(branches, self.linter.config.max_branches),</span>
<span class="gi">+            )</span>
<span class="gi">+        # check number of statements</span>
<span class="gi">+        stmts = self._stmts.pop()</span>
<span class="gi">+        if stmts &gt; self.linter.config.max_statements:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-statements&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(stmts, self.linter.config.max_statements),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>    leave_asyncfunctiondef = leave_functiondef

<span class="gd">-    def visit_return(self, _: nodes.Return) -&gt;None:</span>
<span class="gi">+    def visit_return(self, _: nodes.Return) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Count number of returns.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._returns:</span>
<span class="gi">+            return  # return outside function, reported by the base checker</span>
<span class="gi">+        self._returns[-1] += 1</span>

<span class="gd">-    def visit_default(self, node: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+    def visit_default(self, node: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Default visit method -&gt; increments the statements counter if
<span class="w"> </span>        necessary.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.is_statement:</span>
<span class="gi">+            self._inc_all_stmts(1)</span>

<span class="gd">-    def visit_try(self, node: nodes.Try) -&gt;None:</span>
<span class="gi">+    def visit_try(self, node: nodes.Try) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increments the branches counter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        branches = len(node.handlers)</span>
<span class="gi">+        if node.orelse:</span>
<span class="gi">+            branches += 1</span>
<span class="gi">+        if node.finalbody:</span>
<span class="gi">+            branches += 1</span>
<span class="gi">+        self._inc_branch(node, branches)</span>
<span class="gi">+        self._inc_all_stmts(branches)</span>

<span class="gd">-    @only_required_for_messages(&#39;too-many-boolean-expressions&#39;,</span>
<span class="gd">-        &#39;too-many-branches&#39;)</span>
<span class="gd">-    def visit_if(self, node: nodes.If) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;too-many-boolean-expressions&quot;, &quot;too-many-branches&quot;)</span>
<span class="gi">+    def visit_if(self, node: nodes.If) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increments the branches counter and checks boolean expressions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_boolean_expressions(node)</span>
<span class="gi">+        branches = 1</span>
<span class="gi">+        # don&#39;t double count If nodes coming from some &#39;elif&#39;</span>
<span class="gi">+        if node.orelse and (</span>
<span class="gi">+            len(node.orelse) &gt; 1 or not isinstance(node.orelse[0], astroid.If)</span>
<span class="gi">+        ):</span>
<span class="gi">+            branches += 1</span>
<span class="gi">+        self._inc_branch(node, branches)</span>
<span class="gi">+        self._inc_all_stmts(branches)</span>

<span class="gd">-    def _check_boolean_expressions(self, node: nodes.If) -&gt;None:</span>
<span class="gi">+    def _check_boolean_expressions(self, node: nodes.If) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Go through &quot;if&quot; node `node` and count its boolean expressions
<span class="w"> </span>        if the &#39;if&#39; node test is a BoolOp node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        condition = node.test</span>
<span class="gi">+        if not isinstance(condition, astroid.BoolOp):</span>
<span class="gi">+            return</span>
<span class="gi">+        nb_bool_expr = _count_boolean_expressions(condition)</span>
<span class="gi">+        if nb_bool_expr &gt; self.linter.config.max_bool_expr:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-boolean-expressions&quot;,</span>
<span class="gi">+                node=condition,</span>
<span class="gi">+                args=(nb_bool_expr, self.linter.config.max_bool_expr),</span>
<span class="gi">+            )</span>

<span class="gd">-    def visit_while(self, node: nodes.While) -&gt;None:</span>
<span class="gi">+    def visit_while(self, node: nodes.While) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increments the branches counter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        branches = 1</span>
<span class="gi">+        if node.orelse:</span>
<span class="gi">+            branches += 1</span>
<span class="gi">+        self._inc_branch(node, branches)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_for = visit_while

<span class="gd">-    def _inc_branch(self, node: nodes.NodeNG, branchesnum: int=1) -&gt;None:</span>
<span class="gi">+    def _inc_branch(self, node: nodes.NodeNG, branchesnum: int = 1) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increments the branches counter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._branches[node.scope()] += branchesnum</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(MisdesignChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/dunder_methods.py b/pylint/checkers/dunder_methods.py</span>
<span class="gh">index 461ad9d7e..4bd89c2a1 100644</span>
<span class="gd">--- a/pylint/checkers/dunder_methods.py</span>
<span class="gi">+++ b/pylint/checkers/dunder_methods.py</span>
<span class="gu">@@ -1,11 +1,19 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import Instance, nodes
<span class="w"> </span>from astroid.util import UninferableBase
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import safe_infer
<span class="w"> </span>from pylint.constants import DUNDER_METHODS, UNNECESSARY_DUNDER_CALL_LAMBDA_EXCEPTIONS
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -24,18 +32,72 @@ class DunderCallChecker(BaseChecker):</span>
<span class="w"> </span>    We also exclude dunder method calls on super() since
<span class="w"> </span>    these can&#39;t be written in an alternative manner.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;unnecessary-dunder-call&#39;</span>
<span class="gd">-    msgs = {&#39;C2801&#39;: (&#39;Unnecessarily calls dunder method %s. %s.&#39;,</span>
<span class="gd">-        &#39;unnecessary-dunder-call&#39;,</span>
<span class="gd">-        &#39;Used when a dunder method is manually called instead of using the corresponding function/method/operator.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;unnecessary-dunder-call&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C2801&quot;: (</span>
<span class="gi">+            &quot;Unnecessarily calls dunder method %s. %s.&quot;,</span>
<span class="gi">+            &quot;unnecessary-dunder-call&quot;,</span>
<span class="gi">+            &quot;Used when a dunder method is manually called instead &quot;</span>
<span class="gi">+            &quot;of using the corresponding function/method/operator.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="w"> </span>    options = ()

<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        self._dunder_methods: dict[str, str] = {}</span>
<span class="gi">+        for since_vers, dunder_methods in DUNDER_METHODS.items():</span>
<span class="gi">+            if since_vers &lt;= self.linter.config.py_version:</span>
<span class="gi">+                self._dunder_methods.update(dunder_methods)</span>
<span class="gi">+</span>
<span class="w"> </span>    @staticmethod
<span class="gd">-    def within_dunder_or_lambda_def(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    def within_dunder_or_lambda_def(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if dunder method call is within a dunder method definition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        while parent is not None:</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(parent, nodes.FunctionDef)</span>
<span class="gi">+                and parent.name.startswith(&quot;__&quot;)</span>
<span class="gi">+                and parent.name.endswith(&quot;__&quot;)</span>
<span class="gi">+                or DunderCallChecker.is_lambda_rule_exception(parent, node)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def is_lambda_rule_exception(ancestor: nodes.NodeNG, node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(ancestor, nodes.Lambda)</span>
<span class="gi">+            and node.func.attrname in UNNECESSARY_DUNDER_CALL_LAMBDA_EXCEPTIONS</span>
<span class="gi">+        )</span>

<span class="gd">-    def visit_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if method being called is an unnecessary dunder method.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.func, nodes.Attribute)</span>
<span class="gi">+            and node.func.attrname in self._dunder_methods</span>
<span class="gi">+            and not self.within_dunder_or_lambda_def(node)</span>
<span class="gi">+            and not (</span>
<span class="gi">+                isinstance(node.func.expr, nodes.Call)</span>
<span class="gi">+                and isinstance(node.func.expr.func, nodes.Name)</span>
<span class="gi">+                and node.func.expr.func.name == &quot;super&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        ):</span>
<span class="gi">+            inf_expr = safe_infer(node.func.expr)</span>
<span class="gi">+            if not (</span>
<span class="gi">+                inf_expr is None or isinstance(inf_expr, (Instance, UninferableBase))</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Skip dunder calls to non instantiated classes.</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unnecessary-dunder-call&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(node.func.attrname, self._dunder_methods[node.func.attrname]),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(DunderCallChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/ellipsis_checker.py b/pylint/checkers/ellipsis_checker.py</span>
<span class="gh">index 95b4666d6..4e7e3bd35 100644</span>
<span class="gd">--- a/pylint/checkers/ellipsis_checker.py</span>
<span class="gi">+++ b/pylint/checkers/ellipsis_checker.py</span>
<span class="gu">@@ -1,22 +1,37 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Ellipsis checker for Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class EllipsisChecker(BaseChecker):
<span class="gd">-    name = &#39;unnecessary_ellipsis&#39;</span>
<span class="gd">-    msgs = {&#39;W2301&#39;: (&#39;Unnecessary ellipsis constant&#39;,</span>
<span class="gd">-        &#39;unnecessary-ellipsis&#39;,</span>
<span class="gd">-        &#39;Used when the ellipsis constant is encountered and can be avoided. A line of code consisting of an ellipsis is unnecessary if there is a docstring on the preceding line or if there is a statement in the same scope.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-</span>
<span class="gd">-    @only_required_for_messages(&#39;unnecessary-ellipsis&#39;)</span>
<span class="gd">-    def visit_const(self, node: nodes.Const) -&gt;None:</span>
<span class="gi">+    name = &quot;unnecessary_ellipsis&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W2301&quot;: (</span>
<span class="gi">+            &quot;Unnecessary ellipsis constant&quot;,</span>
<span class="gi">+            &quot;unnecessary-ellipsis&quot;,</span>
<span class="gi">+            &quot;Used when the ellipsis constant is encountered and can be avoided. &quot;</span>
<span class="gi">+            &quot;A line of code consisting of an ellipsis is unnecessary if &quot;</span>
<span class="gi">+            &quot;there is a docstring on the preceding line or if there is a &quot;</span>
<span class="gi">+            &quot;statement in the same scope.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;unnecessary-ellipsis&quot;)</span>
<span class="gi">+    def visit_const(self, node: nodes.Const) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the ellipsis constant is used unnecessarily.

<span class="w"> </span>        Emits a warning when:
<span class="gu">@@ -25,4 +40,19 @@ class EllipsisChecker(BaseChecker):</span>
<span class="w"> </span>           For example: A function consisting of an ellipsis followed by a
<span class="w"> </span>           return statement on the next line.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            node.pytype() == &quot;builtins.Ellipsis&quot;</span>
<span class="gi">+            and isinstance(node.parent, nodes.Expr)</span>
<span class="gi">+            and (</span>
<span class="gi">+                (</span>
<span class="gi">+                    isinstance(node.parent.parent, (nodes.ClassDef, nodes.FunctionDef))</span>
<span class="gi">+                    and node.parent.parent.doc_node</span>
<span class="gi">+                )</span>
<span class="gi">+                or len(node.parent.parent.body) &gt; 1</span>
<span class="gi">+            )</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;unnecessary-ellipsis&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(EllipsisChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/exceptions.py b/pylint/checkers/exceptions.py</span>
<span class="gh">index fe18d2c24..688dc829a 100644</span>
<span class="gd">--- a/pylint/checkers/exceptions.py</span>
<span class="gi">+++ b/pylint/checkers/exceptions.py</span>
<span class="gu">@@ -1,137 +1,656 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checks for various exception related errors.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import builtins
<span class="w"> </span>import inspect
<span class="w"> </span>from collections.abc import Generator
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes, objects, util
<span class="w"> </span>from astroid.context import InferenceContext
<span class="w"> </span>from astroid.typing import InferenceResult, SuccessfulInferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.interfaces import HIGH, INFERENCE
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="gd">-def _annotated_unpack_infer(stmt: nodes.NodeNG, context: (InferenceContext |</span>
<span class="gd">-    None)=None) -&gt;Generator[tuple[nodes.NodeNG, SuccessfulInferenceResult],</span>
<span class="gd">-    None, None]:</span>
<span class="gi">+def _builtin_exceptions() -&gt; set[str]:</span>
<span class="gi">+    def predicate(obj: Any) -&gt; bool:</span>
<span class="gi">+        return isinstance(obj, type) and issubclass(obj, BaseException)</span>
<span class="gi">+</span>
<span class="gi">+    members = inspect.getmembers(builtins, predicate)</span>
<span class="gi">+    return {exc.__name__ for (_, exc) in members}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _annotated_unpack_infer(</span>
<span class="gi">+    stmt: nodes.NodeNG, context: InferenceContext | None = None</span>
<span class="gi">+) -&gt; Generator[tuple[nodes.NodeNG, SuccessfulInferenceResult], None, None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Recursively generate nodes inferred by the given statement.

<span class="w"> </span>    If the inferred value is a list or a tuple, recurse on the elements.
<span class="w"> </span>    Returns an iterator which yields tuples in the format
<span class="w"> </span>    (&#39;original node&#39;, &#39;inferred node&#39;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(stmt, (nodes.List, nodes.Tuple)):</span>
<span class="gi">+        for elt in stmt.elts:</span>
<span class="gi">+            inferred = utils.safe_infer(elt)</span>
<span class="gi">+            if inferred and not isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+                yield elt, inferred</span>
<span class="gi">+        return</span>
<span class="gi">+    for inferred in stmt.infer(context):</span>
<span class="gi">+        if isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+            continue</span>
<span class="gi">+        yield stmt, inferred</span>


<span class="gd">-def _is_raising(body: list[nodes.NodeNG]) -&gt;bool:</span>
<span class="gi">+def _is_raising(body: list[nodes.NodeNG]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return whether the given statement node raises an exception.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;E0701&#39;: (</span>
<span class="gd">-    &#39;Bad except clauses order (%s)&#39;, &#39;bad-except-order&#39;,</span>
<span class="gd">-    &quot;Used when except clauses are not in the correct order (from the more specific to the more generic). If you don&#39;t fix the order, some exceptions may not be caught by the most specific handler.&quot;</span>
<span class="gd">-    ), &#39;E0702&#39;: (&#39;Raising %s while only classes or instances are allowed&#39;,</span>
<span class="gd">-    &#39;raising-bad-type&#39;,</span>
<span class="gd">-    &#39;Used when something which is neither a class nor an instance is raised (i.e. a `TypeError` will be raised).&#39;</span>
<span class="gd">-    ), &#39;E0704&#39;: (&#39;The raise statement is not inside an except clause&#39;,</span>
<span class="gd">-    &#39;misplaced-bare-raise&#39;,</span>
<span class="gd">-    &#39;Used when a bare raise is not used inside an except clause. This generates an error, since there are no active exceptions to be reraised. An exception to this rule is represented by a bare raise inside a finally clause, which might work, as long as an exception is raised inside the try block, but it is nevertheless a code smell that must not be relied upon.&#39;</span>
<span class="gd">-    ), &#39;E0705&#39;: (</span>
<span class="gd">-    &#39;Exception cause set to something which is not an exception, nor None&#39;,</span>
<span class="gd">-    &#39;bad-exception-cause&#39;,</span>
<span class="gd">-    &#39;Used when using the syntax &quot;raise ... from ...&quot;, where the exception cause is not an exception, nor None.&#39;</span>
<span class="gd">-    , {&#39;old_names&#39;: [(&#39;E0703&#39;, &#39;bad-exception-context&#39;)]}), &#39;E0710&#39;: (</span>
<span class="gd">-    &quot;Raising a new style class which doesn&#39;t inherit from BaseException&quot;,</span>
<span class="gd">-    &#39;raising-non-exception&#39;,</span>
<span class="gd">-    &quot;Used when a new style class which doesn&#39;t inherit from BaseException is raised.&quot;</span>
<span class="gd">-    ), &#39;E0711&#39;: (&#39;NotImplemented raised - should raise NotImplementedError&#39;,</span>
<span class="gd">-    &#39;notimplemented-raised&#39;,</span>
<span class="gd">-    &#39;Used when NotImplemented is raised instead of NotImplementedError&#39;),</span>
<span class="gd">-    &#39;E0712&#39;: (</span>
<span class="gd">-    &quot;Catching an exception which doesn&#39;t inherit from Exception: %s&quot;,</span>
<span class="gd">-    &#39;catching-non-exception&#39;,</span>
<span class="gd">-    &quot;Used when a class which doesn&#39;t inherit from Exception is used as an exception in an except clause.&quot;</span>
<span class="gd">-    ), &#39;W0702&#39;: (&#39;No exception type(s) specified&#39;, &#39;bare-except&#39;,</span>
<span class="gd">-    &#39;A bare ``except:`` clause will catch ``SystemExit`` and ``KeyboardInterrupt`` exceptions, making it harder to interrupt a program with ``Control-C``, and can disguise other problems. If you want to catch all exceptions that signal program errors, use ``except Exception:`` (bare except is equivalent to ``except BaseException:``).&#39;</span>
<span class="gd">-    ), &#39;W0718&#39;: (&#39;Catching too general exception %s&#39;,</span>
<span class="gd">-    &#39;broad-exception-caught&#39;,</span>
<span class="gd">-    &#39;If you use a naked ``except Exception:`` clause, you might end up catching exceptions other than the ones you expect to catch. This can hide bugs or make it harder to debug programs when unrelated errors are hidden.&#39;</span>
<span class="gd">-    , {&#39;old_names&#39;: [(&#39;W0703&#39;, &#39;broad-except&#39;)]}), &#39;W0705&#39;: (</span>
<span class="gd">-    &#39;Catching previously caught exception type %s&#39;, &#39;duplicate-except&#39;,</span>
<span class="gd">-    &#39;Used when an except catches a type that was already caught by a previous handler.&#39;</span>
<span class="gd">-    ), &#39;W0706&#39;: (&#39;The except handler raises immediately&#39;,</span>
<span class="gd">-    &#39;try-except-raise&#39;,</span>
<span class="gd">-    &#39;Used when an except handler uses raise as its first or only operator. This is useless because it raises back the exception immediately. Remove the raise operator or the entire try-except-raise block!&#39;</span>
<span class="gd">-    ), &#39;W0707&#39;: (&quot;Consider explicitly re-raising using %s&#39;%s from %s&#39;&quot;,</span>
<span class="gd">-    &#39;raise-missing-from&#39;,</span>
<span class="gd">-    &quot;Python&#39;s exception chaining shows the traceback of the current exception, but also of the original exception. When you raise a new exception after another exception was caught it&#39;s likely that the second exception is a friendly re-wrapping of the first exception. In such cases `raise from` provides a better link between the two tracebacks in the final error.&quot;</span>
<span class="gd">-    ), &#39;W0711&#39;: (</span>
<span class="gd">-    &#39;Exception to catch is the result of a binary &quot;%s&quot; operation&#39;,</span>
<span class="gd">-    &#39;binary-op-exception&#39;,</span>
<span class="gd">-    &#39;Used when the exception to catch is of the form &quot;except A or B:&quot;.  If intending to catch multiple, rewrite as &quot;except (A, B):&quot;&#39;</span>
<span class="gd">-    ), &#39;W0715&#39;: (</span>
<span class="gd">-    &#39;Exception arguments suggest string formatting might be intended&#39;,</span>
<span class="gd">-    &#39;raising-format-tuple&#39;,</span>
<span class="gd">-    &#39;Used when passing multiple arguments to an exception constructor, the first of them a string literal containing what appears to be placeholders intended for formatting&#39;</span>
<span class="gd">-    ), &#39;W0716&#39;: (&#39;Invalid exception operation. %s&#39;,</span>
<span class="gd">-    &#39;wrong-exception-operation&#39;,</span>
<span class="gd">-    &#39;Used when an operation is done against an exception, but the operation is not valid for the exception in question. Usually emitted when having binary operations between exceptions in except handlers.&#39;</span>
<span class="gd">-    ), &#39;W0719&#39;: (&#39;Raising too general exception: %s&#39;,</span>
<span class="gd">-    &#39;broad-exception-raised&#39;,</span>
<span class="gd">-    &#39;Raising exceptions that are too generic force you to catch exceptions generically too. It will force you to use a naked ``except Exception:`` clause. You might then end up catching exceptions other than the ones you expect to catch. This can hide bugs or make it harder to debug programs when unrelated errors are hidden.&#39;</span>
<span class="gd">-    )}</span>
<span class="gi">+    return any(isinstance(node, nodes.Raise) for node in body)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+    &quot;E0701&quot;: (</span>
<span class="gi">+        &quot;Bad except clauses order (%s)&quot;,</span>
<span class="gi">+        &quot;bad-except-order&quot;,</span>
<span class="gi">+        &quot;Used when except clauses are not in the correct order (from the &quot;</span>
<span class="gi">+        &quot;more specific to the more generic). If you don&#39;t fix the order, &quot;</span>
<span class="gi">+        &quot;some exceptions may not be caught by the most specific handler.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0702&quot;: (</span>
<span class="gi">+        &quot;Raising %s while only classes or instances are allowed&quot;,</span>
<span class="gi">+        &quot;raising-bad-type&quot;,</span>
<span class="gi">+        &quot;Used when something which is neither a class nor an instance &quot;</span>
<span class="gi">+        &quot;is raised (i.e. a `TypeError` will be raised).&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0704&quot;: (</span>
<span class="gi">+        &quot;The raise statement is not inside an except clause&quot;,</span>
<span class="gi">+        &quot;misplaced-bare-raise&quot;,</span>
<span class="gi">+        &quot;Used when a bare raise is not used inside an except clause. &quot;</span>
<span class="gi">+        &quot;This generates an error, since there are no active exceptions &quot;</span>
<span class="gi">+        &quot;to be reraised. An exception to this rule is represented by &quot;</span>
<span class="gi">+        &quot;a bare raise inside a finally clause, which might work, as long &quot;</span>
<span class="gi">+        &quot;as an exception is raised inside the try block, but it is &quot;</span>
<span class="gi">+        &quot;nevertheless a code smell that must not be relied upon.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0705&quot;: (</span>
<span class="gi">+        &quot;Exception cause set to something which is not an exception, nor None&quot;,</span>
<span class="gi">+        &quot;bad-exception-cause&quot;,</span>
<span class="gi">+        &#39;Used when using the syntax &quot;raise ... from ...&quot;, &#39;</span>
<span class="gi">+        &quot;where the exception cause is not an exception, &quot;</span>
<span class="gi">+        &quot;nor None.&quot;,</span>
<span class="gi">+        {&quot;old_names&quot;: [(&quot;E0703&quot;, &quot;bad-exception-context&quot;)]},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0710&quot;: (</span>
<span class="gi">+        &quot;Raising a new style class which doesn&#39;t inherit from BaseException&quot;,</span>
<span class="gi">+        &quot;raising-non-exception&quot;,</span>
<span class="gi">+        &quot;Used when a new style class which doesn&#39;t inherit from &quot;</span>
<span class="gi">+        &quot;BaseException is raised.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0711&quot;: (</span>
<span class="gi">+        &quot;NotImplemented raised - should raise NotImplementedError&quot;,</span>
<span class="gi">+        &quot;notimplemented-raised&quot;,</span>
<span class="gi">+        &quot;Used when NotImplemented is raised instead of NotImplementedError&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0712&quot;: (</span>
<span class="gi">+        &quot;Catching an exception which doesn&#39;t inherit from Exception: %s&quot;,</span>
<span class="gi">+        &quot;catching-non-exception&quot;,</span>
<span class="gi">+        &quot;Used when a class which doesn&#39;t inherit from &quot;</span>
<span class="gi">+        &quot;Exception is used as an exception in an except clause.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0702&quot;: (</span>
<span class="gi">+        &quot;No exception type(s) specified&quot;,</span>
<span class="gi">+        &quot;bare-except&quot;,</span>
<span class="gi">+        &quot;A bare ``except:`` clause will catch ``SystemExit`` and &quot;</span>
<span class="gi">+        &quot;``KeyboardInterrupt`` exceptions, making it harder to interrupt a program &quot;</span>
<span class="gi">+        &quot;with ``Control-C``, and can disguise other problems. If you want to catch &quot;</span>
<span class="gi">+        &quot;all exceptions that signal program errors, use ``except Exception:`` (bare &quot;</span>
<span class="gi">+        &quot;except is equivalent to ``except BaseException:``).&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0718&quot;: (</span>
<span class="gi">+        &quot;Catching too general exception %s&quot;,</span>
<span class="gi">+        &quot;broad-exception-caught&quot;,</span>
<span class="gi">+        &quot;If you use a naked ``except Exception:`` clause, you might end up catching &quot;</span>
<span class="gi">+        &quot;exceptions other than the ones you expect to catch. This can hide bugs or &quot;</span>
<span class="gi">+        &quot;make it harder to debug programs when unrelated errors are hidden.&quot;,</span>
<span class="gi">+        {&quot;old_names&quot;: [(&quot;W0703&quot;, &quot;broad-except&quot;)]},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0705&quot;: (</span>
<span class="gi">+        &quot;Catching previously caught exception type %s&quot;,</span>
<span class="gi">+        &quot;duplicate-except&quot;,</span>
<span class="gi">+        &quot;Used when an except catches a type that was already caught by &quot;</span>
<span class="gi">+        &quot;a previous handler.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0706&quot;: (</span>
<span class="gi">+        &quot;The except handler raises immediately&quot;,</span>
<span class="gi">+        &quot;try-except-raise&quot;,</span>
<span class="gi">+        &quot;Used when an except handler uses raise as its first or only &quot;</span>
<span class="gi">+        &quot;operator. This is useless because it raises back the exception &quot;</span>
<span class="gi">+        &quot;immediately. Remove the raise operator or the entire &quot;</span>
<span class="gi">+        &quot;try-except-raise block!&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0707&quot;: (</span>
<span class="gi">+        &quot;Consider explicitly re-raising using %s&#39;%s from %s&#39;&quot;,</span>
<span class="gi">+        &quot;raise-missing-from&quot;,</span>
<span class="gi">+        &quot;Python&#39;s exception chaining shows the traceback of the current exception, &quot;</span>
<span class="gi">+        &quot;but also of the original exception. When you raise a new exception after &quot;</span>
<span class="gi">+        &quot;another exception was caught it&#39;s likely that the second exception is a &quot;</span>
<span class="gi">+        &quot;friendly re-wrapping of the first exception. In such cases `raise from` &quot;</span>
<span class="gi">+        &quot;provides a better link between the two tracebacks in the final error.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0711&quot;: (</span>
<span class="gi">+        &#39;Exception to catch is the result of a binary &quot;%s&quot; operation&#39;,</span>
<span class="gi">+        &quot;binary-op-exception&quot;,</span>
<span class="gi">+        &quot;Used when the exception to catch is of the form &quot;</span>
<span class="gi">+        &#39;&quot;except A or B:&quot;.  If intending to catch multiple, &#39;</span>
<span class="gi">+        &#39;rewrite as &quot;except (A, B):&quot;&#39;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0715&quot;: (</span>
<span class="gi">+        &quot;Exception arguments suggest string formatting might be intended&quot;,</span>
<span class="gi">+        &quot;raising-format-tuple&quot;,</span>
<span class="gi">+        &quot;Used when passing multiple arguments to an exception &quot;</span>
<span class="gi">+        &quot;constructor, the first of them a string literal containing what &quot;</span>
<span class="gi">+        &quot;appears to be placeholders intended for formatting&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0716&quot;: (</span>
<span class="gi">+        &quot;Invalid exception operation. %s&quot;,</span>
<span class="gi">+        &quot;wrong-exception-operation&quot;,</span>
<span class="gi">+        &quot;Used when an operation is done against an exception, but the operation &quot;</span>
<span class="gi">+        &quot;is not valid for the exception in question. Usually emitted when having &quot;</span>
<span class="gi">+        &quot;binary operations between exceptions in except handlers.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0719&quot;: (</span>
<span class="gi">+        &quot;Raising too general exception: %s&quot;,</span>
<span class="gi">+        &quot;broad-exception-raised&quot;,</span>
<span class="gi">+        &quot;Raising exceptions that are too generic force you to catch exceptions &quot;</span>
<span class="gi">+        &quot;generically too. It will force you to use a naked ``except Exception:`` &quot;</span>
<span class="gi">+        &quot;clause. You might then end up catching exceptions other than the ones &quot;</span>
<span class="gi">+        &quot;you expect to catch. This can hide bugs or make it harder to debug programs &quot;</span>
<span class="gi">+        &quot;when unrelated errors are hidden.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+}</span>


<span class="w"> </span>class BaseVisitor:
<span class="w"> </span>    &quot;&quot;&quot;Base class for visitors defined in this module.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, checker: ExceptionsChecker, node: nodes.Raise) -&gt;None:</span>
<span class="gi">+    def __init__(self, checker: ExceptionsChecker, node: nodes.Raise) -&gt; None:</span>
<span class="w"> </span>        self._checker = checker
<span class="w"> </span>        self._node = node

<span class="gd">-    def visit_default(self, _: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+    def visit(self, node: SuccessfulInferenceResult) -&gt; None:</span>
<span class="gi">+        name = node.__class__.__name__.lower()</span>
<span class="gi">+        dispatch_meth = getattr(self, &quot;visit_&quot; + name, None)</span>
<span class="gi">+        if dispatch_meth:</span>
<span class="gi">+            dispatch_meth(node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.visit_default(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_default(self, _: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Default implementation for all the nodes.&quot;&quot;&quot;
<span class="gd">-        pass</span>


<span class="w"> </span>class ExceptionRaiseRefVisitor(BaseVisitor):
<span class="w"> </span>    &quot;&quot;&quot;Visit references (anything that is not an AST leaf).&quot;&quot;&quot;

<span class="gi">+    def visit_name(self, node: nodes.Name) -&gt; None:</span>
<span class="gi">+        if node.name == &quot;NotImplemented&quot;:</span>
<span class="gi">+            self._checker.add_message(</span>
<span class="gi">+                &quot;notimplemented-raised&quot;, node=self._node, confidence=HIGH</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            exceptions = [</span>
<span class="gi">+                c</span>
<span class="gi">+                for _, c in _annotated_unpack_infer(node)</span>
<span class="gi">+                if isinstance(c, nodes.ClassDef)</span>
<span class="gi">+            ]</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for exception in exceptions:</span>
<span class="gi">+            if self._checker._is_overgeneral_exception(exception):</span>
<span class="gi">+                self._checker.add_message(</span>
<span class="gi">+                    &quot;broad-exception-raised&quot;,</span>
<span class="gi">+                    args=exception.name,</span>
<span class="gi">+                    node=self._node,</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if isinstance(node.func, nodes.Name):</span>
<span class="gi">+            self.visit_name(node.func)</span>
<span class="gi">+        if (</span>
<span class="gi">+            len(node.args) &gt; 1</span>
<span class="gi">+            and isinstance(node.args[0], nodes.Const)</span>
<span class="gi">+            and isinstance(node.args[0].value, str)</span>
<span class="gi">+        ):</span>
<span class="gi">+            msg = node.args[0].value</span>
<span class="gi">+            if &quot;%&quot; in msg or (&quot;{&quot; in msg and &quot;}&quot; in msg):</span>
<span class="gi">+                self._checker.add_message(</span>
<span class="gi">+                    &quot;raising-format-tuple&quot;, node=self._node, confidence=HIGH</span>
<span class="gi">+                )</span>
<span class="gi">+</span>

<span class="w"> </span>class ExceptionRaiseLeafVisitor(BaseVisitor):
<span class="w"> </span>    &quot;&quot;&quot;Visitor for handling leaf kinds of a raise value.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def visit_const(self, node: nodes.Const) -&gt; None:</span>
<span class="gi">+        self._checker.add_message(</span>
<span class="gi">+            &quot;raising-bad-type&quot;,</span>
<span class="gi">+            node=self._node,</span>
<span class="gi">+            args=node.value.__class__.__name__,</span>
<span class="gi">+            confidence=INFERENCE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_instance(self, instance: objects.ExceptionInstance) -&gt; None:</span>
<span class="gi">+        cls = instance._proxied</span>
<span class="gi">+        self.visit_classdef(cls)</span>
<span class="gi">+</span>
<span class="gi">+    # Exception instances have a particular class type</span>
<span class="w"> </span>    visit_exceptioninstance = visit_instance

<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        if not utils.inherit_from_std_ex(node) and utils.has_known_bases(node):</span>
<span class="gi">+            if node.newstyle:</span>
<span class="gi">+                self._checker.add_message(</span>
<span class="gi">+                    &quot;raising-non-exception&quot;,</span>
<span class="gi">+                    node=self._node,</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tuple(self, _: nodes.Tuple) -&gt; None:</span>
<span class="gi">+        self._checker.add_message(</span>
<span class="gi">+            &quot;raising-bad-type&quot;,</span>
<span class="gi">+            node=self._node,</span>
<span class="gi">+            args=&quot;tuple&quot;,</span>
<span class="gi">+            confidence=INFERENCE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_default(self, node: nodes.NodeNG) -&gt; None:</span>
<span class="gi">+        name = getattr(node, &quot;name&quot;, node.__class__.__name__)</span>
<span class="gi">+        self._checker.add_message(</span>
<span class="gi">+            &quot;raising-bad-type&quot;,</span>
<span class="gi">+            node=self._node,</span>
<span class="gi">+            args=name,</span>
<span class="gi">+            confidence=INFERENCE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="w"> </span>class ExceptionsChecker(checkers.BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Exception related checks.&quot;&quot;&quot;
<span class="gd">-    name = &#39;exceptions&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;exceptions&quot;</span>
<span class="w"> </span>    msgs = MSGS
<span class="gd">-    options = (&#39;overgeneral-exceptions&#39;, {&#39;default&#39;: (</span>
<span class="gd">-        &#39;builtins.BaseException&#39;, &#39;builtins.Exception&#39;), &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;comma-separated class names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Exceptions that will emit a warning when caught.&#39;}),</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;overgeneral-exceptions&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (&quot;builtins.BaseException&quot;, &quot;builtins.Exception&quot;),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma-separated class names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Exceptions that will emit a warning when caught.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        self._builtin_exceptions = _builtin_exceptions()</span>
<span class="gi">+        super().open()</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;misplaced-bare-raise&quot;,</span>
<span class="gi">+        &quot;raising-bad-type&quot;,</span>
<span class="gi">+        &quot;raising-non-exception&quot;,</span>
<span class="gi">+        &quot;notimplemented-raised&quot;,</span>
<span class="gi">+        &quot;bad-exception-cause&quot;,</span>
<span class="gi">+        &quot;raising-format-tuple&quot;,</span>
<span class="gi">+        &quot;raise-missing-from&quot;,</span>
<span class="gi">+        &quot;broad-exception-raised&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_raise(self, node: nodes.Raise) -&gt; None:</span>
<span class="gi">+        if node.exc is None:</span>
<span class="gi">+            self._check_misplaced_bare_raise(node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if node.cause is None:</span>
<span class="gi">+            self._check_raise_missing_from(node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._check_bad_exception_cause(node)</span>
<span class="gi">+</span>
<span class="gi">+        expr = node.exc</span>
<span class="gi">+        ExceptionRaiseRefVisitor(self, node).visit(expr)</span>
<span class="gi">+</span>
<span class="gi">+        inferred = utils.safe_infer(expr)</span>
<span class="gi">+        if inferred is None or isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+        ExceptionRaiseLeafVisitor(self, node).visit(inferred)</span>

<span class="gd">-    def _check_bad_exception_cause(self, node: nodes.Raise) -&gt;None:</span>
<span class="gi">+    def _check_misplaced_bare_raise(self, node: nodes.Raise) -&gt; None:</span>
<span class="gi">+        # Filter out if it&#39;s present in __exit__.</span>
<span class="gi">+        scope = node.scope()</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(scope, nodes.FunctionDef)</span>
<span class="gi">+            and scope.is_method()</span>
<span class="gi">+            and scope.name == &quot;__exit__&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        current = node</span>
<span class="gi">+        # Stop when a new scope is generated or when the raise</span>
<span class="gi">+        # statement is found inside a Try.</span>
<span class="gi">+        ignores = (nodes.ExceptHandler, nodes.FunctionDef)</span>
<span class="gi">+        while current and not isinstance(current.parent, ignores):</span>
<span class="gi">+            current = current.parent</span>
<span class="gi">+</span>
<span class="gi">+        expected = (nodes.ExceptHandler,)</span>
<span class="gi">+        if not current or not isinstance(current.parent, expected):</span>
<span class="gi">+            self.add_message(&quot;misplaced-bare-raise&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_bad_exception_cause(self, node: nodes.Raise) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Verify that the exception cause is properly set.

<span class="w"> </span>        An exception cause can be only `None` or an exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cause = utils.safe_infer(node.cause)</span>
<span class="gi">+        if cause is None or isinstance(cause, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(cause, nodes.Const):</span>
<span class="gi">+            if cause.value is not None:</span>
<span class="gi">+                self.add_message(&quot;bad-exception-cause&quot;, node=node, confidence=INFERENCE)</span>
<span class="gi">+        elif not isinstance(cause, nodes.ClassDef) and not utils.inherit_from_std_ex(</span>
<span class="gi">+            cause</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;bad-exception-cause&quot;, node=node, confidence=INFERENCE)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_raise_missing_from(self, node: nodes.Raise) -&gt; None:</span>
<span class="gi">+        if node.exc is None:</span>
<span class="gi">+            # This is a plain `raise`, raising the previously-caught exception. No need for a</span>
<span class="gi">+            # cause.</span>
<span class="gi">+            return</span>
<span class="gi">+        # We&#39;d like to check whether we&#39;re inside an `except` clause:</span>
<span class="gi">+        containing_except_node = utils.find_except_wrapper_node_in_scope(node)</span>
<span class="gi">+        if not containing_except_node:</span>
<span class="gi">+            return</span>
<span class="gi">+        # We found a surrounding `except`! We&#39;re almost done proving there&#39;s a</span>
<span class="gi">+        # `raise-missing-from` here. The only thing we need to protect against is that maybe</span>
<span class="gi">+        # the `raise` is raising the exception that was caught, possibly with some shenanigans</span>
<span class="gi">+        # like `exc.with_traceback(whatever)`. We won&#39;t analyze these, we&#39;ll just assume</span>
<span class="gi">+        # there&#39;s a violation on two simple cases: `raise SomeException(whatever)` and `raise</span>
<span class="gi">+        # SomeException`.</span>
<span class="gi">+        if containing_except_node.name is None:</span>
<span class="gi">+            # The `except` doesn&#39;t have an `as exception:` part, meaning there&#39;s no way that</span>
<span class="gi">+            # the `raise` is raising the same exception.</span>
<span class="gi">+            class_of_old_error = &quot;Exception&quot;</span>
<span class="gi">+            if isinstance(containing_except_node.type, (nodes.Name, nodes.Tuple)):</span>
<span class="gi">+                # &#39;except ZeroDivisionError&#39; or &#39;except (ZeroDivisionError, ValueError)&#39;</span>
<span class="gi">+                class_of_old_error = containing_except_node.type.as_string()</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;raise-missing-from&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(</span>
<span class="gi">+                    f&quot;&#39;except {class_of_old_error} as exc&#39; and &quot;,</span>
<span class="gi">+                    node.as_string(),</span>
<span class="gi">+                    &quot;exc&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif (</span>
<span class="gi">+            isinstance(node.exc, nodes.Call)</span>
<span class="gi">+            and isinstance(node.exc.func, nodes.Name)</span>
<span class="gi">+            or isinstance(node.exc, nodes.Name)</span>
<span class="gi">+            and node.exc.name != containing_except_node.name.name</span>
<span class="gi">+        ):</span>
<span class="gi">+            # We have a `raise SomeException(whatever)` or a `raise SomeException`</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;raise-missing-from&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(&quot;&quot;, node.as_string(), containing_except_node.name.name),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_catching_non_exception(</span>
<span class="gi">+        self,</span>
<span class="gi">+        handler: nodes.ExceptHandler,</span>
<span class="gi">+        exc: SuccessfulInferenceResult,</span>
<span class="gi">+        part: nodes.NodeNG,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if isinstance(exc, nodes.Tuple):</span>
<span class="gi">+            # Check if it is a tuple of exceptions.</span>
<span class="gi">+            inferred = [utils.safe_infer(elt) for elt in exc.elts]</span>
<span class="gi">+            if any(isinstance(node, util.UninferableBase) for node in inferred):</span>
<span class="gi">+                # Don&#39;t emit if we don&#39;t know every component.</span>
<span class="gi">+                return</span>
<span class="gi">+            if all(</span>
<span class="gi">+                node</span>
<span class="gi">+                and (utils.inherit_from_std_ex(node) or not utils.has_known_bases(node))</span>
<span class="gi">+                for node in inferred</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(exc, nodes.ClassDef):</span>
<span class="gi">+            # Don&#39;t emit the warning if the inferred stmt</span>
<span class="gi">+            # is None, but the exception handler is something else,</span>
<span class="gi">+            # maybe it was redefined.</span>
<span class="gi">+            if isinstance(exc, nodes.Const) and exc.value is None:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(handler.type, nodes.Const) and handler.type.value is None</span>
<span class="gi">+                ) or handler.type.parent_of(exc):</span>
<span class="gi">+                    # If the exception handler catches None or</span>
<span class="gi">+                    # the exception component, which is None, is</span>
<span class="gi">+                    # defined by the entire exception handler, then</span>
<span class="gi">+                    # emit a warning.</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;catching-non-exception&quot;,</span>
<span class="gi">+                        node=handler.type,</span>
<span class="gi">+                        args=(part.as_string(),),</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;catching-non-exception&quot;,</span>
<span class="gi">+                    node=handler.type,</span>
<span class="gi">+                    args=(part.as_string(),),</span>
<span class="gi">+                )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            not utils.inherit_from_std_ex(exc)</span>
<span class="gi">+            and exc.name not in self._builtin_exceptions</span>
<span class="gi">+        ):</span>
<span class="gi">+            if utils.has_known_bases(exc):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;catching-non-exception&quot;, node=handler.type, args=(exc.name,)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_try_except_raise(self, node: nodes.Try) -&gt; None:</span>
<span class="gi">+        def gather_exceptions_from_handler(</span>
<span class="gi">+            handler: nodes.ExceptHandler,</span>
<span class="gi">+        ) -&gt; list[InferenceResult] | None:</span>
<span class="gi">+            exceptions: list[InferenceResult] = []</span>
<span class="gi">+            if handler.type:</span>
<span class="gi">+                exceptions_in_handler = utils.safe_infer(handler.type)</span>
<span class="gi">+                if isinstance(exceptions_in_handler, nodes.Tuple):</span>
<span class="gi">+                    exceptions = list(</span>
<span class="gi">+                        {</span>
<span class="gi">+                            exception</span>
<span class="gi">+                            for exception in exceptions_in_handler.elts</span>
<span class="gi">+                            if isinstance(exception, (nodes.Name, nodes.Attribute))</span>
<span class="gi">+                        }</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif exceptions_in_handler:</span>
<span class="gi">+                    exceptions = [exceptions_in_handler]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Break when we cannot infer anything reliably.</span>
<span class="gi">+                    return None</span>
<span class="gi">+            return exceptions</span>
<span class="gi">+</span>
<span class="gi">+        bare_raise = False</span>
<span class="gi">+        handler_having_bare_raise = None</span>
<span class="gi">+        exceptions_in_bare_handler: list[InferenceResult] | None = []</span>
<span class="gi">+        for handler in node.handlers:</span>
<span class="gi">+            if bare_raise:</span>
<span class="gi">+                # check that subsequent handler is not parent of handler which had bare raise.</span>
<span class="gi">+                # since utils.safe_infer can fail for bare except, check it before.</span>
<span class="gi">+                # also break early if bare except is followed by bare except.</span>
<span class="gi">+</span>
<span class="gi">+                excs_in_current_handler = gather_exceptions_from_handler(handler)</span>
<span class="gi">+                if not excs_in_current_handler:</span>
<span class="gi">+                    break</span>
<span class="gi">+                if exceptions_in_bare_handler is None:</span>
<span class="gi">+                    # It can be `None` when the inference failed</span>
<span class="gi">+                    break</span>
<span class="gi">+                for exc_in_current_handler in excs_in_current_handler:</span>
<span class="gi">+                    inferred_current = utils.safe_infer(exc_in_current_handler)</span>
<span class="gi">+                    if any(</span>
<span class="gi">+                        utils.is_subclass_of(utils.safe_infer(e), inferred_current)</span>
<span class="gi">+                        for e in exceptions_in_bare_handler</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        bare_raise = False</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+            # `raise` as the first operator inside the except handler</span>
<span class="gi">+            if _is_raising([handler.body[0]]):</span>
<span class="gi">+                # flags when there is a bare raise</span>
<span class="gi">+                if handler.body[0].exc is None:</span>
<span class="gi">+                    bare_raise = True</span>
<span class="gi">+                    handler_having_bare_raise = handler</span>
<span class="gi">+                    exceptions_in_bare_handler = gather_exceptions_from_handler(handler)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if bare_raise:</span>
<span class="gi">+                self.add_message(&quot;try-except-raise&quot;, node=handler_having_bare_raise)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;wrong-exception-operation&quot;)</span>
<span class="gi">+    def visit_binop(self, node: nodes.BinOp) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.ExceptHandler):</span>
<span class="gi">+            both_sides_tuple_or_uninferable = isinstance(</span>
<span class="gi">+                utils.safe_infer(node.left), (nodes.Tuple, util.UninferableBase)</span>
<span class="gi">+            ) and isinstance(</span>
<span class="gi">+                utils.safe_infer(node.right), (nodes.Tuple, util.UninferableBase)</span>
<span class="gi">+            )</span>
<span class="gi">+            # Tuple concatenation allowed</span>
<span class="gi">+            if both_sides_tuple_or_uninferable:</span>
<span class="gi">+                if node.op == &quot;+&quot;:</span>
<span class="gi">+                    return</span>
<span class="gi">+                suggestion = f&quot;Did you mean &#39;({node.left.as_string()} + {node.right.as_string()})&#39; instead?&quot;</span>
<span class="gi">+            # except (V | A)</span>
<span class="gi">+            else:</span>
<span class="gi">+                suggestion = f&quot;Did you mean &#39;({node.left.as_string()}, {node.right.as_string()})&#39; instead?&quot;</span>
<span class="gi">+            self.add_message(&quot;wrong-exception-operation&quot;, node=node, args=(suggestion,))</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;bare-except&#39;,</span>
<span class="gd">-        &#39;broad-exception-caught&#39;, &#39;try-except-raise&#39;, &#39;binary-op-exception&#39;,</span>
<span class="gd">-        &#39;bad-except-order&#39;, &#39;catching-non-exception&#39;, &#39;duplicate-except&#39;)</span>
<span class="gd">-    def visit_trystar(self, node: nodes.TryStar) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;wrong-exception-operation&quot;)</span>
<span class="gi">+    def visit_compare(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.ExceptHandler):</span>
<span class="gi">+            # except (V &lt; A)</span>
<span class="gi">+            suggestion = (</span>
<span class="gi">+                f&quot;Did you mean &#39;({node.left.as_string()}, &quot;</span>
<span class="gi">+                f&quot;{&#39;, &#39;.join(o.as_string() for _, o in node.ops)})&#39; instead?&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.add_message(&quot;wrong-exception-operation&quot;, node=node, args=(suggestion,))</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;bare-except&quot;,</span>
<span class="gi">+        &quot;broad-exception-caught&quot;,</span>
<span class="gi">+        &quot;try-except-raise&quot;,</span>
<span class="gi">+        &quot;binary-op-exception&quot;,</span>
<span class="gi">+        &quot;bad-except-order&quot;,</span>
<span class="gi">+        &quot;catching-non-exception&quot;,</span>
<span class="gi">+        &quot;duplicate-except&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_trystar(self, node: nodes.TryStar) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for empty except*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit_try(node)</span>

<span class="gd">-    def visit_try(self, node: nodes.Try) -&gt;None:</span>
<span class="gi">+    def visit_try(self, node: nodes.Try) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for empty except.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_try_except_raise(node)</span>
<span class="gi">+        exceptions_classes: list[Any] = []</span>
<span class="gi">+        nb_handlers = len(node.handlers)</span>
<span class="gi">+        for index, handler in enumerate(node.handlers):</span>
<span class="gi">+            if handler.type is None:</span>
<span class="gi">+                if not _is_raising(handler.body):</span>
<span class="gi">+                    self.add_message(&quot;bare-except&quot;, node=handler, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+                # check if an &quot;except:&quot; is followed by some other</span>
<span class="gi">+                # except</span>
<span class="gi">+                if index &lt; (nb_handlers - 1):</span>
<span class="gi">+                    msg = &quot;empty except clause should always appear last&quot;</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;bad-except-order&quot;, node=node, args=msg, confidence=HIGH</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            elif isinstance(handler.type, nodes.BoolOp):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;binary-op-exception&quot;,</span>
<span class="gi">+                    node=handler,</span>
<span class="gi">+                    args=handler.type.op,</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    exceptions = list(_annotated_unpack_infer(handler.type))</span>
<span class="gi">+                except astroid.InferenceError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                for part, exception in exceptions:</span>
<span class="gi">+                    if isinstance(</span>
<span class="gi">+                        exception, astroid.Instance</span>
<span class="gi">+                    ) and utils.inherit_from_std_ex(exception):</span>
<span class="gi">+                        exception = exception._proxied</span>
<span class="gi">+</span>
<span class="gi">+                    self._check_catching_non_exception(handler, exception, part)</span>
<span class="gi">+</span>
<span class="gi">+                    if not isinstance(exception, nodes.ClassDef):</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    exc_ancestors = [</span>
<span class="gi">+                        anc</span>
<span class="gi">+                        for anc in exception.ancestors()</span>
<span class="gi">+                        if isinstance(anc, nodes.ClassDef)</span>
<span class="gi">+                    ]</span>
<span class="gi">+</span>
<span class="gi">+                    for previous_exc in exceptions_classes:</span>
<span class="gi">+                        if previous_exc in exc_ancestors:</span>
<span class="gi">+                            msg = f&quot;{previous_exc.name} is an ancestor class of {exception.name}&quot;</span>
<span class="gi">+                            self.add_message(</span>
<span class="gi">+                                &quot;bad-except-order&quot;,</span>
<span class="gi">+                                node=handler.type,</span>
<span class="gi">+                                args=msg,</span>
<span class="gi">+                                confidence=INFERENCE,</span>
<span class="gi">+                            )</span>
<span class="gi">+                    if self._is_overgeneral_exception(exception) and not _is_raising(</span>
<span class="gi">+                        handler.body</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;broad-exception-caught&quot;,</span>
<span class="gi">+                            args=exception.name,</span>
<span class="gi">+                            node=handler.type,</span>
<span class="gi">+                            confidence=INFERENCE,</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+                    if exception in exceptions_classes:</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;duplicate-except&quot;,</span>
<span class="gi">+                            args=exception.name,</span>
<span class="gi">+                            node=handler.type,</span>
<span class="gi">+                            confidence=INFERENCE,</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+                exceptions_classes += [exc for _, exc in exceptions]</span>
<span class="gi">+</span>
<span class="gi">+    def _is_overgeneral_exception(self, exception: nodes.ClassDef) -&gt; bool:</span>
<span class="gi">+        return exception.qname() in self.linter.config.overgeneral_exceptions</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(ExceptionsChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/format.py b/pylint/checkers/format.py</span>
<span class="gh">index 1b31de075..f8aecbda6 100644</span>
<span class="gd">--- a/pylint/checkers/format.py</span>
<span class="gi">+++ b/pylint/checkers/format.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Python code format&#39;s checker.

<span class="w"> </span>By default, try to follow Guido&#39;s style guide :
<span class="gu">@@ -6,58 +10,141 @@ https://www.python.org/doc/essays/styleguide/</span>

<span class="w"> </span>Some parts of the process_token method is based from The Tab Nanny std module.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import tokenize
<span class="w"> </span>from functools import reduce
<span class="w"> </span>from re import Match
<span class="w"> </span>from typing import TYPE_CHECKING, Literal
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseRawFileChecker, BaseTokenChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="w"> </span>from pylint.constants import WarningScope
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="w"> </span>from pylint.utils.pragma_parser import OPTION_PO, PragmaParserError, parse_pragma
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-_KEYWORD_TOKENS = {&#39;assert&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;except&#39;, &#39;for&#39;, &#39;if&#39;, &#39;in&#39;,</span>
<span class="gd">-    &#39;not&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;while&#39;, &#39;yield&#39;, &#39;with&#39;, &#39;=&#39;, &#39;:=&#39;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_KEYWORD_TOKENS = {</span>
<span class="gi">+    &quot;assert&quot;,</span>
<span class="gi">+    &quot;del&quot;,</span>
<span class="gi">+    &quot;elif&quot;,</span>
<span class="gi">+    &quot;except&quot;,</span>
<span class="gi">+    &quot;for&quot;,</span>
<span class="gi">+    &quot;if&quot;,</span>
<span class="gi">+    &quot;in&quot;,</span>
<span class="gi">+    &quot;not&quot;,</span>
<span class="gi">+    &quot;raise&quot;,</span>
<span class="gi">+    &quot;return&quot;,</span>
<span class="gi">+    &quot;while&quot;,</span>
<span class="gi">+    &quot;yield&quot;,</span>
<span class="gi">+    &quot;with&quot;,</span>
<span class="gi">+    &quot;=&quot;,</span>
<span class="gi">+    &quot;:=&quot;,</span>
<span class="gi">+}</span>
<span class="w"> </span>_JUNK_TOKENS = {tokenize.COMMENT, tokenize.NL}
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;C0301&#39;: (</span>
<span class="gd">-    &#39;Line too long (%s/%s)&#39;, &#39;line-too-long&#39;,</span>
<span class="gd">-    &#39;Used when a line is longer than a given number of characters.&#39;),</span>
<span class="gd">-    &#39;C0302&#39;: (&#39;Too many lines in module (%s/%s)&#39;, &#39;too-many-lines&#39;,</span>
<span class="gd">-    &#39;Used when a module has too many lines, reducing its readability.&#39;),</span>
<span class="gd">-    &#39;C0303&#39;: (&#39;Trailing whitespace&#39;, &#39;trailing-whitespace&#39;,</span>
<span class="gd">-    &#39;Used when there is whitespace between the end of a line and the newline.&#39;</span>
<span class="gd">-    ), &#39;C0304&#39;: (&#39;Final newline missing&#39;, &#39;missing-final-newline&#39;,</span>
<span class="gd">-    &#39;Used when the last line in a file is missing a newline.&#39;), &#39;C0305&#39;: (</span>
<span class="gd">-    &#39;Trailing newlines&#39;, &#39;trailing-newlines&#39;,</span>
<span class="gd">-    &#39;Used when there are trailing blank lines in a file.&#39;), &#39;W0311&#39;: (</span>
<span class="gd">-    &#39;Bad indentation. Found %s %s, expected %s&#39;, &#39;bad-indentation&#39;,</span>
<span class="gd">-    &quot;Used when an unexpected number of indentation&#39;s tabulations or spaces has been found.&quot;</span>
<span class="gd">-    ), &#39;W0301&#39;: (&#39;Unnecessary semicolon&#39;, &#39;unnecessary-semicolon&#39;,</span>
<span class="gd">-    &#39;Used when a statement is ended by a semi-colon (&quot;;&quot;), which isn\&#39;t necessary (that\&#39;s python, not C ;).&#39;</span>
<span class="gd">-    ), &#39;C0321&#39;: (&#39;More than one statement on a single line&#39;,</span>
<span class="gd">-    &#39;multiple-statements&#39;,</span>
<span class="gd">-    &#39;Used when more than on statement are found on the same line.&#39;, {</span>
<span class="gd">-    &#39;scope&#39;: WarningScope.NODE}), &#39;C0325&#39;: (</span>
<span class="gd">-    &#39;Unnecessary parens after %r keyword&#39;, &#39;superfluous-parens&#39;,</span>
<span class="gd">-    &#39;Used when a single item in parentheses follows an if, for, or other keyword.&#39;</span>
<span class="gd">-    ), &#39;C0327&#39;: (&#39;Mixed line endings LF and CRLF&#39;, &#39;mixed-line-endings&#39;,</span>
<span class="gd">-    &#39;Used when there are mixed (LF and CRLF) newline signs in a file.&#39;),</span>
<span class="gd">-    &#39;C0328&#39;: (</span>
<span class="gd">-    &quot;Unexpected line ending format. There is &#39;%s&#39; while it should be &#39;%s&#39;.&quot;,</span>
<span class="gd">-    &#39;unexpected-line-ending-format&#39;,</span>
<span class="gd">-    &#39;Used when there is different newline than expected.&#39;)}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+    &quot;C0301&quot;: (</span>
<span class="gi">+        &quot;Line too long (%s/%s)&quot;,</span>
<span class="gi">+        &quot;line-too-long&quot;,</span>
<span class="gi">+        &quot;Used when a line is longer than a given number of characters.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0302&quot;: (</span>
<span class="gi">+        &quot;Too many lines in module (%s/%s)&quot;,  # was W0302</span>
<span class="gi">+        &quot;too-many-lines&quot;,</span>
<span class="gi">+        &quot;Used when a module has too many lines, reducing its readability.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0303&quot;: (</span>
<span class="gi">+        &quot;Trailing whitespace&quot;,</span>
<span class="gi">+        &quot;trailing-whitespace&quot;,</span>
<span class="gi">+        &quot;Used when there is whitespace between the end of a line and the newline.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0304&quot;: (</span>
<span class="gi">+        &quot;Final newline missing&quot;,</span>
<span class="gi">+        &quot;missing-final-newline&quot;,</span>
<span class="gi">+        &quot;Used when the last line in a file is missing a newline.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0305&quot;: (</span>
<span class="gi">+        &quot;Trailing newlines&quot;,</span>
<span class="gi">+        &quot;trailing-newlines&quot;,</span>
<span class="gi">+        &quot;Used when there are trailing blank lines in a file.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0311&quot;: (</span>
<span class="gi">+        &quot;Bad indentation. Found %s %s, expected %s&quot;,</span>
<span class="gi">+        &quot;bad-indentation&quot;,</span>
<span class="gi">+        &quot;Used when an unexpected number of indentation&#39;s tabulations or &quot;</span>
<span class="gi">+        &quot;spaces has been found.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0301&quot;: (</span>
<span class="gi">+        &quot;Unnecessary semicolon&quot;,  # was W0106</span>
<span class="gi">+        &quot;unnecessary-semicolon&quot;,</span>
<span class="gi">+        &#39;Used when a statement is ended by a semi-colon (&quot;;&quot;), which &#39;</span>
<span class="gi">+        &quot;isn&#39;t necessary (that&#39;s python, not C ;).&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0321&quot;: (</span>
<span class="gi">+        &quot;More than one statement on a single line&quot;,</span>
<span class="gi">+        &quot;multiple-statements&quot;,</span>
<span class="gi">+        &quot;Used when more than on statement are found on the same line.&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.NODE},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0325&quot;: (</span>
<span class="gi">+        &quot;Unnecessary parens after %r keyword&quot;,</span>
<span class="gi">+        &quot;superfluous-parens&quot;,</span>
<span class="gi">+        &quot;Used when a single item in parentheses follows an if, for, or &quot;</span>
<span class="gi">+        &quot;other keyword.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0327&quot;: (</span>
<span class="gi">+        &quot;Mixed line endings LF and CRLF&quot;,</span>
<span class="gi">+        &quot;mixed-line-endings&quot;,</span>
<span class="gi">+        &quot;Used when there are mixed (LF and CRLF) newline signs in a file.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0328&quot;: (</span>
<span class="gi">+        &quot;Unexpected line ending format. There is &#39;%s&#39; while it should be &#39;%s&#39;.&quot;,</span>
<span class="gi">+        &quot;unexpected-line-ending-format&quot;,</span>
<span class="gi">+        &quot;Used when there is different newline than expected.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _last_token_on_line_is(tokens: TokenWrapper, line_end: int, token: str) -&gt; bool:</span>
<span class="gi">+    return (</span>
<span class="gi">+        line_end &gt; 0</span>
<span class="gi">+        and tokens.token(line_end - 1) == token</span>
<span class="gi">+        or line_end &gt; 1</span>
<span class="gi">+        and tokens.token(line_end - 2) == token</span>
<span class="gi">+        and tokens.type(line_end - 1) == tokenize.COMMENT</span>
<span class="gi">+    )</span>


<span class="w"> </span>class TokenWrapper:
<span class="w"> </span>    &quot;&quot;&quot;A wrapper for readable access to token information.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, tokens: list[tokenize.TokenInfo]) -&gt;None:</span>
<span class="gi">+    def __init__(self, tokens: list[tokenize.TokenInfo]) -&gt; None:</span>
<span class="w"> </span>        self._tokens = tokens

<span class="gi">+    def token(self, idx: int) -&gt; str:</span>
<span class="gi">+        return self._tokens[idx][1]</span>
<span class="gi">+</span>
<span class="gi">+    def type(self, idx: int) -&gt; int:</span>
<span class="gi">+        return self._tokens[idx][0]</span>
<span class="gi">+</span>
<span class="gi">+    def start_line(self, idx: int) -&gt; int:</span>
<span class="gi">+        return self._tokens[idx][2][0]</span>
<span class="gi">+</span>
<span class="gi">+    def start_col(self, idx: int) -&gt; int:</span>
<span class="gi">+        return self._tokens[idx][2][1]</span>
<span class="gi">+</span>
<span class="gi">+    def line(self, idx: int) -&gt; str:</span>
<span class="gi">+        return self._tokens[idx][4]</span>
<span class="gi">+</span>

<span class="w"> </span>class FormatChecker(BaseTokenChecker, BaseRawFileChecker):
<span class="w"> </span>    &quot;&quot;&quot;Formatting checker.
<span class="gu">@@ -67,45 +154,126 @@ class FormatChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>    * strict indentation
<span class="w"> </span>    * line length
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;format&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;format&quot;</span>
<span class="gi">+    # messages</span>
<span class="w"> </span>    msgs = MSGS
<span class="gd">-    options = (&#39;max-line-length&#39;, {&#39;default&#39;: 100, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;int&gt;&#39;, &#39;help&#39;: &#39;Maximum number of characters on a single line.&#39;}), (</span>
<span class="gd">-        &#39;ignore-long-lines&#39;, {&#39;type&#39;: &#39;regexp&#39;, &#39;metavar&#39;: &#39;&lt;regexp&gt;&#39;,</span>
<span class="gd">-        &#39;default&#39;: &#39;^\\s*(# )?&lt;?https?://\\S+&gt;?$&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Regexp for a line that is allowed to be longer than the limit.&#39;}), (</span>
<span class="gd">-        &#39;single-line-if-stmt&#39;, {&#39;default&#39;: False, &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Allow the body of an if to be on the same line as the test if there is no else.&#39;</span>
<span class="gd">-        }), (&#39;single-line-class-stmt&#39;, {&#39;default&#39;: False, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Allow the body of a class to be on the same line as the declaration if body contains single statement.&#39;</span>
<span class="gd">-        }), (&#39;max-module-lines&#39;, {&#39;default&#39;: 1000, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;int&gt;&#39;, &#39;help&#39;: &#39;Maximum number of lines in a module.&#39;}), (</span>
<span class="gd">-        &#39;indent-string&#39;, {&#39;default&#39;: &#39;    &#39;, &#39;type&#39;: &#39;non_empty_string&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;string&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;String used as indentation unit. This is usually &quot;    &quot; (4 spaces) or &quot;\\t&quot; (1 tab).&#39;</span>
<span class="gd">-        }), (&#39;indent-after-paren&#39;, {&#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;: &#39;&lt;int&gt;&#39;,</span>
<span class="gd">-        &#39;default&#39;: 4, &#39;help&#39;:</span>
<span class="gd">-        &#39;Number of spaces of indent required inside a hanging or continued line.&#39;</span>
<span class="gd">-        }), (&#39;expected-line-ending-format&#39;, {&#39;type&#39;: &#39;choice&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;empty or LF or CRLF&gt;&#39;, &#39;default&#39;: &#39;&#39;, &#39;choices&#39;: [&#39;&#39;, &#39;LF&#39;,</span>
<span class="gd">-        &#39;CRLF&#39;], &#39;help&#39;:</span>
<span class="gd">-        &#39;Expected format of line ending, e.g. empty (any line ending), LF or CRLF.&#39;</span>
<span class="gd">-        })</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    # configuration options</span>
<span class="gi">+    # for available dict keys/values see the optik parser &#39;add_option&#39; method</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-line-length&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 100,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of characters on a single line.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-long-lines&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;regexp&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: r&quot;^\s*(# )?&lt;?https?://\S+&gt;?$&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Regexp for a line that is allowed to be longer than the limit.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;single-line-if-stmt&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Allow the body of an if to be on the same &quot;</span>
<span class="gi">+                    &quot;line as the test if there is no else.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;single-line-class-stmt&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Allow the body of a class to be on the same &quot;</span>
<span class="gi">+                    &quot;line as the declaration if body contains &quot;</span>
<span class="gi">+                    &quot;single statement.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-module-lines&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 1000,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of lines in a module.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;indent-string&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;    &quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;non_empty_string&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;string&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;String used as indentation unit. This is usually &quot;</span>
<span class="gi">+                &#39;&quot;    &quot; (4 spaces) or &quot;\\t&quot; (1 tab).&#39;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;indent-after-paren&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: 4,</span>
<span class="gi">+                &quot;help&quot;: &quot;Number of spaces of indent required inside a hanging &quot;</span>
<span class="gi">+                &quot;or continued line.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;expected-line-ending-format&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;choice&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;empty or LF or CRLF&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;choices&quot;: [&quot;&quot;, &quot;LF&quot;, &quot;CRLF&quot;],</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Expected format of line ending, &quot;</span>
<span class="gi">+                    &quot;e.g. empty (any line ending), LF or CRLF.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="w"> </span>        self._lines: dict[int, str] = {}
<span class="w"> </span>        self._visited_lines: dict[int, Literal[1, 2]] = {}

<span class="gd">-    def new_line(self, tokens: TokenWrapper, line_end: int, line_start: int</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def new_line(self, tokens: TokenWrapper, line_end: int, line_start: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;A new line has been encountered, process it if necessary.&quot;&quot;&quot;
<span class="gi">+        if _last_token_on_line_is(tokens, line_end, &quot;;&quot;):</span>
<span class="gi">+            self.add_message(&quot;unnecessary-semicolon&quot;, line=tokens.start_line(line_end))</span>
<span class="gi">+</span>
<span class="gi">+        line_num = tokens.start_line(line_start)</span>
<span class="gi">+        line = tokens.line(line_start)</span>
<span class="gi">+        if tokens.type(line_start) not in _JUNK_TOKENS:</span>
<span class="gi">+            self._lines[line_num] = line.split(&quot;\n&quot;)[0]</span>
<span class="gi">+        self.check_lines(tokens, line_start, line, line_num)</span>
<span class="gi">+</span>
<span class="gi">+    def process_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    def _check_keyword_parentheses(self, tokens: list[tokenize.TokenInfo],</span>
<span class="gd">-        start: int) -&gt;None:</span>
<span class="gi">+    # pylint: disable-next = too-many-return-statements, too-many-branches</span>
<span class="gi">+    def _check_keyword_parentheses(</span>
<span class="gi">+        self, tokens: list[tokenize.TokenInfo], start: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that there are not unnecessary parentheses after a keyword.

<span class="w"> </span>        Parens are unnecessary if there is exactly one balanced outer pair on a
<span class="gu">@@ -115,55 +283,346 @@ class FormatChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>        tokens: The entire list of Tokens.
<span class="w"> </span>        start: The position of the keyword in the token list.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # If the next token is not a paren, we&#39;re fine.</span>
<span class="gi">+        if tokens[start + 1].string != &quot;(&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+        if (</span>
<span class="gi">+            tokens[start].string == &quot;not&quot;</span>
<span class="gi">+            and start &gt; 0</span>
<span class="gi">+            and tokens[start - 1].string == &quot;is&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            # If this is part of an `is not` expression, we have a binary operator</span>
<span class="gi">+            # so the parentheses are not necessarily redundant.</span>
<span class="gi">+            return</span>
<span class="gi">+        found_and_or = False</span>
<span class="gi">+        contains_walrus_operator = False</span>
<span class="gi">+        walrus_operator_depth = 0</span>
<span class="gi">+        contains_double_parens = 0</span>
<span class="gi">+        depth = 0</span>
<span class="gi">+        keyword_token = str(tokens[start].string)</span>
<span class="gi">+        line_num = tokens[start].start[0]</span>
<span class="gi">+        for i in range(start, len(tokens) - 1):</span>
<span class="gi">+            token = tokens[i]</span>
<span class="gi">+</span>
<span class="gi">+            # If we hit a newline, then assume any parens were for continuation.</span>
<span class="gi">+            if token.type == tokenize.NL:</span>
<span class="gi">+                return</span>
<span class="gi">+            # Since the walrus operator doesn&#39;t exist below python3.8, the tokenizer</span>
<span class="gi">+            # generates independent tokens</span>
<span class="gi">+            if (</span>
<span class="gi">+                token.string == &quot;:=&quot;  # &lt;-- python3.8+ path</span>
<span class="gi">+                or token.string + tokens[i + 1].string == &quot;:=&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                contains_walrus_operator = True</span>
<span class="gi">+                walrus_operator_depth = depth</span>
<span class="gi">+            if token.string == &quot;(&quot;:</span>
<span class="gi">+                depth += 1</span>
<span class="gi">+                if tokens[i + 1].string == &quot;(&quot;:</span>
<span class="gi">+                    contains_double_parens = 1</span>
<span class="gi">+            elif token.string == &quot;)&quot;:</span>
<span class="gi">+                depth -= 1</span>
<span class="gi">+                if depth:</span>
<span class="gi">+                    if contains_double_parens and tokens[i + 1].string == &quot;)&quot;:</span>
<span class="gi">+                        # For walrus operators in `if (not)` conditions and comprehensions</span>
<span class="gi">+                        if keyword_token in {&quot;in&quot;, &quot;if&quot;, &quot;not&quot;}:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        return</span>
<span class="gi">+                    contains_double_parens -= 1</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # &#39;)&#39; can&#39;t happen after if (foo), since it would be a syntax error.</span>
<span class="gi">+                if tokens[i + 1].string in {&quot;:&quot;, &quot;)&quot;, &quot;]&quot;, &quot;}&quot;, &quot;in&quot;} or tokens[</span>
<span class="gi">+                    i + 1</span>
<span class="gi">+                ].type in {tokenize.NEWLINE, tokenize.ENDMARKER, tokenize.COMMENT}:</span>
<span class="gi">+                    if contains_walrus_operator and walrus_operator_depth - 1 == depth:</span>
<span class="gi">+                        return</span>
<span class="gi">+                    # The empty tuple () is always accepted.</span>
<span class="gi">+                    if i == start + 2:</span>
<span class="gi">+                        return</span>
<span class="gi">+                    if found_and_or:</span>
<span class="gi">+                        return</span>
<span class="gi">+                    if keyword_token == &quot;in&quot;:</span>
<span class="gi">+                        # This special case was added in https://github.com/pylint-dev/pylint/pull/4948</span>
<span class="gi">+                        # but it could be removed in the future. Avoid churn for now.</span>
<span class="gi">+                        return</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;superfluous-parens&quot;, line=line_num, args=keyword_token</span>
<span class="gi">+                    )</span>
<span class="gi">+                return</span>
<span class="gi">+            elif depth == 1:</span>
<span class="gi">+                # This is a tuple, which is always acceptable.</span>
<span class="gi">+                if token[1] == &quot;,&quot;:</span>
<span class="gi">+                    return</span>
<span class="gi">+                # &#39;and&#39; and &#39;or&#39; are the only boolean operators with lower precedence</span>
<span class="gi">+                # than &#39;not&#39;, so parens are only required when they are found.</span>
<span class="gi">+                if token[1] in {&quot;and&quot;, &quot;or&quot;}:</span>
<span class="gi">+                    found_and_or = True</span>
<span class="gi">+                # A yield inside an expression must always be in parentheses,</span>
<span class="gi">+                # quit early without error.</span>
<span class="gi">+                elif token[1] == &quot;yield&quot;:</span>
<span class="gi">+                    return</span>
<span class="gi">+                # A generator expression always has a &#39;for&#39; token in it, and</span>
<span class="gi">+                # the &#39;for&#39; token is only legal inside parens when it is in a</span>
<span class="gi">+                # generator expression.  The parens are necessary here, so bail</span>
<span class="gi">+                # without an error.</span>
<span class="gi">+                elif token[1] == &quot;for&quot;:</span>
<span class="gi">+                    return</span>
<span class="gi">+                # A generator expression can have an &#39;else&#39; token in it.</span>
<span class="gi">+                # We check the rest of the tokens to see if any problems occur after</span>
<span class="gi">+                # the &#39;else&#39;.</span>
<span class="gi">+                elif token[1] == &quot;else&quot;:</span>
<span class="gi">+                    if &quot;(&quot; in (i.string for i in tokens[i:]):</span>
<span class="gi">+                        self._check_keyword_parentheses(tokens[i:], 0)</span>
<span class="gi">+                    return</span>

<span class="gd">-    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt;None:</span>
<span class="gi">+    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process tokens and search for:

<span class="w"> </span>        - too long lines (i.e. longer than &lt;max_chars&gt;)
<span class="w"> </span>        - optionally bad construct (if given, bad_construct must be a compiled
<span class="w"> </span>          regular expression).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indents = [0]</span>
<span class="gi">+        check_equal = False</span>
<span class="gi">+        line_num = 0</span>
<span class="gi">+        self._lines = {}</span>
<span class="gi">+        self._visited_lines = {}</span>
<span class="gi">+        self._last_line_ending: str | None = None</span>
<span class="gi">+        last_blank_line_num = 0</span>
<span class="gi">+        for idx, (tok_type, string, start, _, line) in enumerate(tokens):</span>
<span class="gi">+            if start[0] != line_num:</span>
<span class="gi">+                line_num = start[0]</span>
<span class="gi">+                # A tokenizer oddity: if an indented line contains a multi-line</span>
<span class="gi">+                # docstring, the line member of the INDENT token does not contain</span>
<span class="gi">+                # the full line; therefore we check the next token on the line.</span>
<span class="gi">+                if tok_type == tokenize.INDENT:</span>
<span class="gi">+                    self.new_line(TokenWrapper(tokens), idx - 1, idx + 1)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.new_line(TokenWrapper(tokens), idx - 1, idx)</span>
<span class="gi">+</span>
<span class="gi">+            if tok_type == tokenize.NEWLINE:</span>
<span class="gi">+                # a program statement, or ENDMARKER, will eventually follow,</span>
<span class="gi">+                # after some (possibly empty) run of tokens of the form</span>
<span class="gi">+                #     (NL | COMMENT)* (INDENT | DEDENT+)?</span>
<span class="gi">+                # If an INDENT appears, setting check_equal is wrong, and will</span>
<span class="gi">+                # be undone when we see the INDENT.</span>
<span class="gi">+                check_equal = True</span>
<span class="gi">+                self._check_line_ending(string, line_num)</span>
<span class="gi">+            elif tok_type == tokenize.INDENT:</span>
<span class="gi">+                check_equal = False</span>
<span class="gi">+                self.check_indent_level(string, indents[-1] + 1, line_num)</span>
<span class="gi">+                indents.append(indents[-1] + 1)</span>
<span class="gi">+            elif tok_type == tokenize.DEDENT:</span>
<span class="gi">+                # there&#39;s nothing we need to check here!  what&#39;s important is</span>
<span class="gi">+                # that when the run of DEDENTs ends, the indentation of the</span>
<span class="gi">+                # program statement (or ENDMARKER) that triggered the run is</span>
<span class="gi">+                # equal to what&#39;s left at the top of the indents stack</span>
<span class="gi">+                check_equal = True</span>
<span class="gi">+                if len(indents) &gt; 1:</span>
<span class="gi">+                    del indents[-1]</span>
<span class="gi">+            elif tok_type == tokenize.NL:</span>
<span class="gi">+                if not line.strip(&quot;\r\n&quot;):</span>
<span class="gi">+                    last_blank_line_num = line_num</span>
<span class="gi">+            elif tok_type not in (tokenize.COMMENT, tokenize.ENCODING):</span>
<span class="gi">+                # This is the first concrete token following a NEWLINE, so it</span>
<span class="gi">+                # must be the first token of the next program statement, or an</span>
<span class="gi">+                # ENDMARKER; the &quot;line&quot; argument exposes the leading white-space</span>
<span class="gi">+                # for this statement; in the case of ENDMARKER, line is an empty</span>
<span class="gi">+                # string, so will properly match the empty string with which the</span>
<span class="gi">+                # &quot;indents&quot; stack was seeded</span>
<span class="gi">+                if check_equal:</span>
<span class="gi">+                    check_equal = False</span>
<span class="gi">+                    self.check_indent_level(line, indents[-1], line_num)</span>
<span class="gi">+</span>
<span class="gi">+            if tok_type == tokenize.NUMBER and string.endswith(&quot;l&quot;):</span>
<span class="gi">+                self.add_message(&quot;lowercase-l-suffix&quot;, line=line_num)</span>
<span class="gi">+</span>
<span class="gi">+            if string in _KEYWORD_TOKENS:</span>
<span class="gi">+                self._check_keyword_parentheses(tokens, idx)</span>

<span class="gd">-    @only_required_for_messages(&#39;multiple-statements&#39;)</span>
<span class="gd">-    def visit_default(self, node: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+        line_num -= 1  # to be ok with &quot;wc -l&quot;</span>
<span class="gi">+        if line_num &gt; self.linter.config.max_module_lines:</span>
<span class="gi">+            # Get the line where the too-many-lines (or its message id)</span>
<span class="gi">+            # was disabled or default to 1.</span>
<span class="gi">+            message_definition = self.linter.msgs_store.get_message_definitions(</span>
<span class="gi">+                &quot;too-many-lines&quot;</span>
<span class="gi">+            )[0]</span>
<span class="gi">+            names = (message_definition.msgid, &quot;too-many-lines&quot;)</span>
<span class="gi">+            lineno = next(</span>
<span class="gi">+                filter(None, (self.linter._pragma_lineno.get(name) for name in names)),</span>
<span class="gi">+                1,</span>
<span class="gi">+            )</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-lines&quot;,</span>
<span class="gi">+                args=(line_num, self.linter.config.max_module_lines),</span>
<span class="gi">+                line=lineno,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # See if there are any trailing lines.  Do not complain about empty</span>
<span class="gi">+        # files like __init__.py markers.</span>
<span class="gi">+        if line_num == last_blank_line_num and line_num &gt; 0:</span>
<span class="gi">+            self.add_message(&quot;trailing-newlines&quot;, line=line_num)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_line_ending(self, line_ending: str, line_num: int) -&gt; None:</span>
<span class="gi">+        # check if line endings are mixed</span>
<span class="gi">+        if self._last_line_ending is not None:</span>
<span class="gi">+            # line_ending == &quot;&quot; indicates a synthetic newline added at</span>
<span class="gi">+            # the end of a file that does not, in fact, end with a</span>
<span class="gi">+            # newline.</span>
<span class="gi">+            if line_ending and line_ending != self._last_line_ending:</span>
<span class="gi">+                self.add_message(&quot;mixed-line-endings&quot;, line=line_num)</span>
<span class="gi">+</span>
<span class="gi">+        self._last_line_ending = line_ending</span>
<span class="gi">+</span>
<span class="gi">+        # check if line ending is as expected</span>
<span class="gi">+        expected = self.linter.config.expected_line_ending_format</span>
<span class="gi">+        if expected:</span>
<span class="gi">+            # reduce multiple \n\n\n\n to one \n</span>
<span class="gi">+            line_ending = reduce(lambda x, y: x + y if x != y else x, line_ending, &quot;&quot;)</span>
<span class="gi">+            line_ending = &quot;LF&quot; if line_ending == &quot;\n&quot; else &quot;CRLF&quot;</span>
<span class="gi">+            if line_ending != expected:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;unexpected-line-ending-format&quot;,</span>
<span class="gi">+                    args=(line_ending, expected),</span>
<span class="gi">+                    line=line_num,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;multiple-statements&quot;)</span>
<span class="gi">+    def visit_default(self, node: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check the node line number and check it if not yet done.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not node.is_statement:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not node.root().pure_python:</span>
<span class="gi">+            return</span>
<span class="gi">+        prev_sibl = node.previous_sibling()</span>
<span class="gi">+        if prev_sibl is not None:</span>
<span class="gi">+            prev_line = prev_sibl.fromlineno</span>
<span class="gi">+        elif isinstance(node.parent, nodes.Module):</span>
<span class="gi">+            prev_line = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            prev_line = node.parent.statement().fromlineno</span>
<span class="gi">+        line = node.fromlineno</span>
<span class="gi">+        assert line, node</span>
<span class="gi">+        if prev_line == line and self._visited_lines.get(line) != 2:</span>
<span class="gi">+            self._check_multi_statement_line(node, line)</span>
<span class="gi">+            return</span>
<span class="gi">+        if line in self._visited_lines:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            tolineno = node.blockstart_tolineno</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            tolineno = node.tolineno</span>
<span class="gi">+        assert tolineno, node</span>
<span class="gi">+        lines: list[str] = []</span>
<span class="gi">+        for line in range(line, tolineno + 1):  # noqa: B020</span>
<span class="gi">+            self._visited_lines[line] = 1</span>
<span class="gi">+            try:</span>
<span class="gi">+                lines.append(self._lines[line].rstrip())</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                lines.append(&quot;&quot;)</span>

<span class="gd">-    def _check_multi_statement_line(self, node: nodes.NodeNG, line: int</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _check_multi_statement_line(self, node: nodes.NodeNG, line: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for lines containing multiple statements.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, nodes.With):</span>
<span class="gi">+            # Do not warn about multiple nested context managers in with statements.</span>
<span class="gi">+            return</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.parent, nodes.If)</span>
<span class="gi">+            and not node.parent.orelse</span>
<span class="gi">+            and self.linter.config.single_line_if_stmt</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.parent, nodes.ClassDef)</span>
<span class="gi">+            and len(node.parent.body) == 1</span>
<span class="gi">+            and self.linter.config.single_line_class_stmt</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>

<span class="gd">-    def check_trailing_whitespace_ending(self, line: str, i: int) -&gt;None:</span>
<span class="gi">+        # Functions stubs and class with ``Ellipsis`` as body are exempted.</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, nodes.Expr)</span>
<span class="gi">+            and isinstance(node.parent, (nodes.FunctionDef, nodes.ClassDef))</span>
<span class="gi">+            and isinstance(node.value, nodes.Const)</span>
<span class="gi">+            and node.value.value is Ellipsis</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;multiple-statements&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+        self._visited_lines[line] = 2</span>
<span class="gi">+</span>
<span class="gi">+    def check_trailing_whitespace_ending(self, line: str, i: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that there is no trailing white-space.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # exclude \f (formfeed) from the rstrip</span>
<span class="gi">+        stripped_line = line.rstrip(&quot;\t\n\r\v &quot;)</span>
<span class="gi">+        if line[len(stripped_line) :] not in (&quot;\n&quot;, &quot;\r\n&quot;):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;trailing-whitespace&quot;,</span>
<span class="gi">+                line=i,</span>
<span class="gi">+                col_offset=len(stripped_line),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>

<span class="gd">-    def check_line_length(self, line: str, i: int, checker_off: bool) -&gt;None:</span>
<span class="gi">+    def check_line_length(self, line: str, i: int, checker_off: bool) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that the line length is less than the authorized value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        max_chars = self.linter.config.max_line_length</span>
<span class="gi">+        ignore_long_line = self.linter.config.ignore_long_lines</span>
<span class="gi">+        line = line.rstrip()</span>
<span class="gi">+        if len(line) &gt; max_chars and not ignore_long_line.search(line):</span>
<span class="gi">+            if checker_off:</span>
<span class="gi">+                self.linter.add_ignored_message(&quot;line-too-long&quot;, i)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.add_message(&quot;line-too-long&quot;, line=i, args=(len(line), max_chars))</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def remove_pylint_option_from_lines(options_pattern_obj: Match[str]) -&gt;str:</span>
<span class="gi">+    def remove_pylint_option_from_lines(options_pattern_obj: Match[str]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove the `# pylint ...` pattern from lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines = options_pattern_obj.string</span>
<span class="gi">+        purged_lines = (</span>
<span class="gi">+            lines[: options_pattern_obj.start(1)].rstrip()</span>
<span class="gi">+            + lines[options_pattern_obj.end(1) :]</span>
<span class="gi">+        )</span>
<span class="gi">+        return purged_lines</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def is_line_length_check_activated(pylint_pattern_match_object: Match[str]</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def is_line_length_check_activated(pylint_pattern_match_object: Match[str]) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if the line length check is activated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            for pragma in parse_pragma(pylint_pattern_match_object.group(2)):</span>
<span class="gi">+                if pragma.action == &quot;disable&quot; and &quot;line-too-long&quot; in pragma.messages:</span>
<span class="gi">+                    return False</span>
<span class="gi">+        except PragmaParserError:</span>
<span class="gi">+            # Printing useful information dealing with this error is done in the lint package</span>
<span class="gi">+            pass</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def specific_splitlines(lines: str) -&gt;list[str]:</span>
<span class="gi">+    def specific_splitlines(lines: str) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Split lines according to universal newlines except those in a specific
<span class="w"> </span>        sets.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        unsplit_ends = {</span>
<span class="gi">+            &quot;\x0b&quot;,  # synonym of \v</span>
<span class="gi">+            &quot;\x0c&quot;,  # synonym of \f</span>
<span class="gi">+            &quot;\x1c&quot;,</span>
<span class="gi">+            &quot;\x1d&quot;,</span>
<span class="gi">+            &quot;\x1e&quot;,</span>
<span class="gi">+            &quot;\x85&quot;,</span>
<span class="gi">+            &quot;\u2028&quot;,</span>
<span class="gi">+            &quot;\u2029&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+        res: list[str] = []</span>
<span class="gi">+        buffer = &quot;&quot;</span>
<span class="gi">+        for atomic_line in lines.splitlines(True):</span>
<span class="gi">+            if atomic_line[-1] not in unsplit_ends:</span>
<span class="gi">+                res.append(buffer + atomic_line)</span>
<span class="gi">+                buffer = &quot;&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                buffer += atomic_line</span>
<span class="gi">+        return res</span>

<span class="gd">-    def check_lines(self, tokens: TokenWrapper, line_start: int, lines: str,</span>
<span class="gd">-        lineno: int) -&gt;None:</span>
<span class="gi">+    def check_lines(</span>
<span class="gi">+        self, tokens: TokenWrapper, line_start: int, lines: str, lineno: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check given lines for potential messages.

<span class="w"> </span>        Check if lines have:
<span class="gu">@@ -171,9 +630,76 @@ class FormatChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>        - no trailing white-space
<span class="w"> </span>        - less than a maximum number of characters
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # we&#39;re first going to do a rough check whether any lines in this set</span>
<span class="gi">+        # go over the line limit. If none of them do, then we don&#39;t need to</span>
<span class="gi">+        # parse out the pylint options later on and can just assume that these</span>
<span class="gi">+        # lines are clean</span>
<span class="gi">+</span>
<span class="gi">+        # we&#39;ll also handle the line ending check here to avoid double-iteration</span>
<span class="gi">+        # unless the line lengths are suspect</span>
<span class="gi">+</span>
<span class="gi">+        max_chars = self.linter.config.max_line_length</span>
<span class="gi">+</span>
<span class="gi">+        split_lines = self.specific_splitlines(lines)</span>
<span class="gi">+</span>
<span class="gi">+        for offset, line in enumerate(split_lines):</span>
<span class="gi">+            if not line.endswith(&quot;\n&quot;):</span>
<span class="gi">+                self.add_message(&quot;missing-final-newline&quot;, line=lineno + offset)</span>
<span class="gi">+                continue</span>
<span class="gi">+            # We don&#39;t test for trailing whitespaces in strings</span>
<span class="gi">+            # See https://github.com/pylint-dev/pylint/issues/6936</span>
<span class="gi">+            # and https://github.com/pylint-dev/pylint/issues/3822</span>
<span class="gi">+            if tokens.type(line_start) != tokenize.STRING:</span>
<span class="gi">+                self.check_trailing_whitespace_ending(line, lineno + offset)</span>
<span class="gi">+</span>
<span class="gi">+        # This check is purposefully simple and doesn&#39;t rstrip since this is running</span>
<span class="gi">+        # on every line you&#39;re checking it&#39;s advantageous to avoid doing a lot of work</span>
<span class="gi">+        potential_line_length_warning = any(</span>
<span class="gi">+            len(line) &gt; max_chars for line in split_lines</span>
<span class="gi">+        )</span>

<span class="gd">-    def check_indent_level(self, string: str, expected: int, line_num: int</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        # if there were no lines passing the max_chars config, we don&#39;t bother</span>
<span class="gi">+        # running the full line check (as we&#39;ve met an even more strict condition)</span>
<span class="gi">+        if not potential_line_length_warning:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Line length check may be deactivated through `pylint: disable` comment</span>
<span class="gi">+        mobj = OPTION_PO.search(lines)</span>
<span class="gi">+        checker_off = False</span>
<span class="gi">+        if mobj:</span>
<span class="gi">+            if not self.is_line_length_check_activated(mobj):</span>
<span class="gi">+                checker_off = True</span>
<span class="gi">+            # The &#39;pylint: disable whatever&#39; should not be taken into account for line length count</span>
<span class="gi">+            lines = self.remove_pylint_option_from_lines(mobj)</span>
<span class="gi">+</span>
<span class="gi">+        # here we re-run specific_splitlines since we have filtered out pylint options above</span>
<span class="gi">+        for offset, line in enumerate(self.specific_splitlines(lines)):</span>
<span class="gi">+            self.check_line_length(line, lineno + offset, checker_off)</span>
<span class="gi">+</span>
<span class="gi">+    def check_indent_level(self, string: str, expected: int, line_num: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the indent level of the string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        indent = self.linter.config.indent_string</span>
<span class="gi">+        if indent == &quot;\\t&quot;:  # \t is not interpreted in the configuration file</span>
<span class="gi">+            indent = &quot;\t&quot;</span>
<span class="gi">+        level = 0</span>
<span class="gi">+        unit_size = len(indent)</span>
<span class="gi">+        while string[:unit_size] == indent:</span>
<span class="gi">+            string = string[unit_size:]</span>
<span class="gi">+            level += 1</span>
<span class="gi">+        suppl = &quot;&quot;</span>
<span class="gi">+        while string and string[0] in &quot; \t&quot;:</span>
<span class="gi">+            suppl += string[0]</span>
<span class="gi">+            string = string[1:]</span>
<span class="gi">+        if level != expected or suppl:</span>
<span class="gi">+            i_type = &quot;spaces&quot;</span>
<span class="gi">+            if indent[0] == &quot;\t&quot;:</span>
<span class="gi">+                i_type = &quot;tabs&quot;</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;bad-indentation&quot;,</span>
<span class="gi">+                line=line_num,</span>
<span class="gi">+                args=(level * unit_size + len(suppl), i_type, expected * unit_size),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(FormatChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/imports.py b/pylint/checkers/imports.py</span>
<span class="gh">index 14add5d0f..afef0277e 100644</span>
<span class="gd">--- a/pylint/checkers/imports.py</span>
<span class="gi">+++ b/pylint/checkers/imports.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Imports checkers for Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import copy
<span class="w"> </span>import os
<span class="gu">@@ -8,11 +14,20 @@ from collections import defaultdict</span>
<span class="w"> </span>from collections.abc import ItemsView, Sequence
<span class="w"> </span>from functools import cached_property
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Dict, List, Union
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="w"> </span>from astroid.nodes._base_nodes import ImportNode
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, DeprecatedMixin
<span class="gd">-from pylint.checkers.utils import get_import_name, in_type_checking_block, is_from_fallback_block, is_module_ignored, is_sys_guard, node_ignores_exception</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    get_import_name,</span>
<span class="gi">+    in_type_checking_block,</span>
<span class="gi">+    is_from_fallback_block,</span>
<span class="gi">+    is_module_ignored,</span>
<span class="gi">+    is_sys_guard,</span>
<span class="gi">+    node_ignores_exception,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.constants import MAX_NUMBER_OF_IMPORT_SHOWN
<span class="w"> </span>from pylint.exceptions import EmptyReportError
<span class="w"> </span>from pylint.graph import DotBackend, get_cycles
<span class="gu">@@ -21,91 +36,289 @@ from pylint.reporters.ureports.nodes import Paragraph, Section, VerbatimText</span>
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="w"> </span>from pylint.utils import IsortDriver
<span class="w"> </span>from pylint.utils.linterstats import LinterStats
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# The dictionary with Any should actually be a _ImportTree again</span>
<span class="gi">+# but mypy doesn&#39;t support recursive types yet</span>
<span class="w"> </span>_ImportTree = Dict[str, Union[List[Dict[str, Any]], List[str]]]
<span class="gd">-DEPRECATED_MODULES = {(0, 0, 0): {&#39;tkinter.tix&#39;, &#39;fpectl&#39;}, (3, 2, 0): {</span>
<span class="gd">-    &#39;optparse&#39;}, (3, 3, 0): {&#39;xml.etree.cElementTree&#39;}, (3, 4, 0): {&#39;imp&#39;},</span>
<span class="gd">-    (3, 5, 0): {&#39;formatter&#39;}, (3, 6, 0): {&#39;asynchat&#39;, &#39;asyncore&#39;, &#39;smtpd&#39;},</span>
<span class="gd">-    (3, 7, 0): {&#39;macpath&#39;}, (3, 9, 0): {&#39;lib2to3&#39;, &#39;parser&#39;, &#39;symbol&#39;,</span>
<span class="gd">-    &#39;binhex&#39;}, (3, 10, 0): {&#39;distutils&#39;, &#39;typing.io&#39;, &#39;typing.re&#39;}, (3, 11,</span>
<span class="gd">-    0): {&#39;aifc&#39;, &#39;audioop&#39;, &#39;cgi&#39;, &#39;cgitb&#39;, &#39;chunk&#39;, &#39;crypt&#39;, &#39;imghdr&#39;,</span>
<span class="gd">-    &#39;msilib&#39;, &#39;mailcap&#39;, &#39;nis&#39;, &#39;nntplib&#39;, &#39;ossaudiodev&#39;, &#39;pipes&#39;, &#39;sndhdr&#39;,</span>
<span class="gd">-    &#39;spwd&#39;, &#39;sunau&#39;, &#39;sre_compile&#39;, &#39;sre_constants&#39;, &#39;sre_parse&#39;,</span>
<span class="gd">-    &#39;telnetlib&#39;, &#39;uu&#39;, &#39;xdrlib&#39;}}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _get_first_import(node: ImportNode, context: nodes.LocalsDictNodeNG,</span>
<span class="gd">-    name: str, base: (str | None), level: (int | None), alias: (str | None)</span>
<span class="gd">-    ) -&gt;tuple[nodes.Import | nodes.ImportFrom | None, str | None]:</span>
<span class="gi">+</span>
<span class="gi">+DEPRECATED_MODULES = {</span>
<span class="gi">+    (0, 0, 0): {&quot;tkinter.tix&quot;, &quot;fpectl&quot;},</span>
<span class="gi">+    (3, 2, 0): {&quot;optparse&quot;},</span>
<span class="gi">+    (3, 3, 0): {&quot;xml.etree.cElementTree&quot;},</span>
<span class="gi">+    (3, 4, 0): {&quot;imp&quot;},</span>
<span class="gi">+    (3, 5, 0): {&quot;formatter&quot;},</span>
<span class="gi">+    (3, 6, 0): {&quot;asynchat&quot;, &quot;asyncore&quot;, &quot;smtpd&quot;},</span>
<span class="gi">+    (3, 7, 0): {&quot;macpath&quot;},</span>
<span class="gi">+    (3, 9, 0): {&quot;lib2to3&quot;, &quot;parser&quot;, &quot;symbol&quot;, &quot;binhex&quot;},</span>
<span class="gi">+    (3, 10, 0): {&quot;distutils&quot;, &quot;typing.io&quot;, &quot;typing.re&quot;},</span>
<span class="gi">+    (3, 11, 0): {</span>
<span class="gi">+        &quot;aifc&quot;,</span>
<span class="gi">+        &quot;audioop&quot;,</span>
<span class="gi">+        &quot;cgi&quot;,</span>
<span class="gi">+        &quot;cgitb&quot;,</span>
<span class="gi">+        &quot;chunk&quot;,</span>
<span class="gi">+        &quot;crypt&quot;,</span>
<span class="gi">+        &quot;imghdr&quot;,</span>
<span class="gi">+        &quot;msilib&quot;,</span>
<span class="gi">+        &quot;mailcap&quot;,</span>
<span class="gi">+        &quot;nis&quot;,</span>
<span class="gi">+        &quot;nntplib&quot;,</span>
<span class="gi">+        &quot;ossaudiodev&quot;,</span>
<span class="gi">+        &quot;pipes&quot;,</span>
<span class="gi">+        &quot;sndhdr&quot;,</span>
<span class="gi">+        &quot;spwd&quot;,</span>
<span class="gi">+        &quot;sunau&quot;,</span>
<span class="gi">+        &quot;sre_compile&quot;,</span>
<span class="gi">+        &quot;sre_constants&quot;,</span>
<span class="gi">+        &quot;sre_parse&quot;,</span>
<span class="gi">+        &quot;telnetlib&quot;,</span>
<span class="gi">+        &quot;uu&quot;,</span>
<span class="gi">+        &quot;xdrlib&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_first_import(</span>
<span class="gi">+    node: ImportNode,</span>
<span class="gi">+    context: nodes.LocalsDictNodeNG,</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    base: str | None,</span>
<span class="gi">+    level: int | None,</span>
<span class="gi">+    alias: str | None,</span>
<span class="gi">+) -&gt; tuple[nodes.Import | nodes.ImportFrom | None, str | None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the node where [base.]&lt;name&gt; is imported or None if not found.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fullname = f&quot;{base}.{name}&quot; if base else name</span>

<span class="gi">+    first = None</span>
<span class="gi">+    found = False</span>
<span class="gi">+    msg = &quot;reimported&quot;</span>

<span class="gd">-def _make_tree_defs(mod_files_list: ItemsView[str, set[str]]) -&gt;_ImportTree:</span>
<span class="gi">+    for first in context.body:</span>
<span class="gi">+        if first is node:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if first.scope() is node.scope() and first.fromlineno &gt; node.fromlineno:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(first, nodes.Import):</span>
<span class="gi">+            if any(fullname == iname[0] for iname in first.names):</span>
<span class="gi">+                found = True</span>
<span class="gi">+                break</span>
<span class="gi">+            for imported_name, imported_alias in first.names:</span>
<span class="gi">+                if not imported_alias and imported_name == alias:</span>
<span class="gi">+                    found = True</span>
<span class="gi">+                    msg = &quot;shadowed-import&quot;</span>
<span class="gi">+                    break</span>
<span class="gi">+            if found:</span>
<span class="gi">+                break</span>
<span class="gi">+        elif isinstance(first, nodes.ImportFrom):</span>
<span class="gi">+            if level == first.level:</span>
<span class="gi">+                for imported_name, imported_alias in first.names:</span>
<span class="gi">+                    if fullname == f&quot;{first.modname}.{imported_name}&quot;:</span>
<span class="gi">+                        found = True</span>
<span class="gi">+                        break</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        name != &quot;*&quot;</span>
<span class="gi">+                        and name == imported_name</span>
<span class="gi">+                        and not (alias or imported_alias)</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        found = True</span>
<span class="gi">+                        break</span>
<span class="gi">+                    if not imported_alias and imported_name == alias:</span>
<span class="gi">+                        found = True</span>
<span class="gi">+                        msg = &quot;shadowed-import&quot;</span>
<span class="gi">+                        break</span>
<span class="gi">+                if found:</span>
<span class="gi">+                    break</span>
<span class="gi">+    if found and not astroid.are_exclusive(first, node):</span>
<span class="gi">+        return first, msg</span>
<span class="gi">+    return None, None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _ignore_import_failure(</span>
<span class="gi">+    node: ImportNode,</span>
<span class="gi">+    modname: str,</span>
<span class="gi">+    ignored_modules: Sequence[str],</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    if is_module_ignored(modname, ignored_modules):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Ignore import failure if part of guarded import block</span>
<span class="gi">+    # I.e. `sys.version_info` or `typing.TYPE_CHECKING`</span>
<span class="gi">+    if in_type_checking_block(node):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if isinstance(node.parent, nodes.If) and is_sys_guard(node.parent):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    return node_ignores_exception(node, ImportError)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# utilities to represents import dependencies as tree and dot graph ###########</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_tree_defs(mod_files_list: ItemsView[str, set[str]]) -&gt; _ImportTree:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get a list of 2-uple (module, list_of_files_which_import_this_module),
<span class="w"> </span>    it will return a dictionary to represent this as a tree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tree_defs: _ImportTree = {}</span>
<span class="gi">+    for mod, files in mod_files_list:</span>
<span class="gi">+        node: list[_ImportTree | list[str]] = [tree_defs, []]</span>
<span class="gi">+        for prefix in mod.split(&quot;.&quot;):</span>
<span class="gi">+            assert isinstance(node[0], dict)</span>
<span class="gi">+            node = node[0].setdefault(prefix, ({}, []))  # type: ignore[arg-type,assignment]</span>
<span class="gi">+        assert isinstance(node[1], list)</span>
<span class="gi">+        node[1].extend(files)</span>
<span class="gi">+    return tree_defs</span>


<span class="gd">-def _repr_tree_defs(data: _ImportTree, indent_str: (str | None)=None) -&gt;str:</span>
<span class="gi">+def _repr_tree_defs(data: _ImportTree, indent_str: str | None = None) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a string which represents imports as a tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = []</span>
<span class="gi">+    nodes_items = data.items()</span>
<span class="gi">+    for i, (mod, (sub, files)) in enumerate(sorted(nodes_items, key=lambda x: x[0])):</span>
<span class="gi">+        files_list = &quot;&quot; if not files else f&quot;({&#39;,&#39;.join(sorted(files))})&quot;</span>
<span class="gi">+        if indent_str is None:</span>
<span class="gi">+            lines.append(f&quot;{mod} {files_list}&quot;)</span>
<span class="gi">+            sub_indent_str = &quot;  &quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            lines.append(rf&quot;{indent_str}\-{mod} {files_list}&quot;)</span>
<span class="gi">+            if i == len(nodes_items) - 1:</span>
<span class="gi">+                sub_indent_str = f&quot;{indent_str}  &quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                sub_indent_str = f&quot;{indent_str}| &quot;</span>
<span class="gi">+        if sub and isinstance(sub, dict):</span>
<span class="gi">+            lines.append(_repr_tree_defs(sub, sub_indent_str))</span>
<span class="gi">+    return &quot;\n&quot;.join(lines)</span>


<span class="gd">-def _dependencies_graph(filename: str, dep_info: dict[str, set[str]]) -&gt;str:</span>
<span class="gi">+def _dependencies_graph(filename: str, dep_info: dict[str, set[str]]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Write dependencies as a dot (graphviz) file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    done = {}</span>
<span class="gi">+    printer = DotBackend(os.path.splitext(os.path.basename(filename))[0], rankdir=&quot;LR&quot;)</span>
<span class="gi">+    printer.emit(&#39;URL=&quot;.&quot; node[shape=&quot;box&quot;]&#39;)</span>
<span class="gi">+    for modname, dependencies in sorted(dep_info.items()):</span>
<span class="gi">+        sorted_dependencies = sorted(dependencies)</span>
<span class="gi">+        done[modname] = 1</span>
<span class="gi">+        printer.emit_node(modname)</span>
<span class="gi">+        for depmodname in sorted_dependencies:</span>
<span class="gi">+            if depmodname not in done:</span>
<span class="gi">+                done[depmodname] = 1</span>
<span class="gi">+                printer.emit_node(depmodname)</span>
<span class="gi">+    for depmodname, dependencies in sorted(dep_info.items()):</span>
<span class="gi">+        for modname in sorted(dependencies):</span>
<span class="gi">+            printer.emit_edge(modname, depmodname)</span>
<span class="gi">+    return printer.generate(filename)</span>


<span class="gd">-def _make_graph(filename: str, dep_info: dict[str, set[str]], sect: Section,</span>
<span class="gd">-    gtype: str) -&gt;None:</span>
<span class="gi">+def _make_graph(</span>
<span class="gi">+    filename: str, dep_info: dict[str, set[str]], sect: Section, gtype: str</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate a dependencies graph and add some information about it in the
<span class="w"> </span>    report&#39;s section.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;E0401&#39;: (&#39;Unable to import %s&#39;,</span>
<span class="gd">-    &#39;import-error&#39;, &#39;Used when pylint has been unable to import a module.&#39;,</span>
<span class="gd">-    {&#39;old_names&#39;: [(&#39;F0401&#39;, &#39;old-import-error&#39;)]}), &#39;E0402&#39;: (</span>
<span class="gd">-    &#39;Attempted relative import beyond top-level package&#39;,</span>
<span class="gd">-    &#39;relative-beyond-top-level&#39;,</span>
<span class="gd">-    &#39;Used when a relative import tries to access too many levels in the current package.&#39;</span>
<span class="gd">-    ), &#39;R0401&#39;: (&#39;Cyclic import (%s)&#39;, &#39;cyclic-import&#39;,</span>
<span class="gd">-    &#39;Used when a cyclic import between two or more modules is detected.&#39;),</span>
<span class="gd">-    &#39;R0402&#39;: (&quot;Use &#39;from %s import %s&#39; instead&quot;,</span>
<span class="gd">-    &#39;consider-using-from-import&#39;,</span>
<span class="gd">-    &#39;Emitted when a submodule of a package is imported and aliased with the same name, e.g., instead of ``import concurrent.futures as futures`` use ``from concurrent import futures``.&#39;</span>
<span class="gd">-    ), &#39;W0401&#39;: (&#39;Wildcard import %s&#39;, &#39;wildcard-import&#39;,</span>
<span class="gd">-    &#39;Used when `from module import *` is detected.&#39;), &#39;W0404&#39;: (</span>
<span class="gd">-    &#39;Reimport %r (imported line %s)&#39;, &#39;reimported&#39;,</span>
<span class="gd">-    &#39;Used when a module is imported more than once.&#39;), &#39;W0406&#39;: (</span>
<span class="gd">-    &#39;Module import itself&#39;, &#39;import-self&#39;,</span>
<span class="gd">-    &#39;Used when a module is importing itself.&#39;), &#39;W0407&#39;: (</span>
<span class="gd">-    &#39;Prefer importing %r instead of %r&#39;, &#39;preferred-module&#39;,</span>
<span class="gd">-    &#39;Used when a module imported has a preferred replacement module.&#39;),</span>
<span class="gd">-    &#39;W0410&#39;: (&#39;__future__ import is not the first non docstring statement&#39;,</span>
<span class="gd">-    &#39;misplaced-future&#39;,</span>
<span class="gd">-    &#39;Python 2.5 and greater require __future__ import to be the first non docstring statement in the module.&#39;</span>
<span class="gd">-    ), &#39;C0410&#39;: (&#39;Multiple imports on one line (%s)&#39;, &#39;multiple-imports&#39;,</span>
<span class="gd">-    &#39;Used when import statement importing multiple modules is detected.&#39;),</span>
<span class="gd">-    &#39;C0411&#39;: (&#39;%s should be placed before %s&#39;, &#39;wrong-import-order&#39;,</span>
<span class="gd">-    &#39;Used when PEP8 import order is not respected (standard imports first, then third-party libraries, then local imports).&#39;</span>
<span class="gd">-    ), &#39;C0412&#39;: (&#39;Imports from package %s are not grouped&#39;,</span>
<span class="gd">-    &#39;ungrouped-imports&#39;, &#39;Used when imports are not grouped by packages.&#39;),</span>
<span class="gd">-    &#39;C0413&#39;: (&#39;Import &quot;%s&quot; should be placed at the top of the module&#39;,</span>
<span class="gd">-    &#39;wrong-import-position&#39;, &#39;Used when code and imports are mixed.&#39;),</span>
<span class="gd">-    &#39;C0414&#39;: (&#39;Import alias does not rename original package&#39;,</span>
<span class="gd">-    &#39;useless-import-alias&#39;,</span>
<span class="gd">-    &#39;Used when an import alias is same as original package, e.g., using import numpy as numpy instead of import numpy as np.&#39;</span>
<span class="gd">-    ), &#39;C0415&#39;: (&#39;Import outside toplevel (%s)&#39;, &#39;import-outside-toplevel&#39;,</span>
<span class="gd">-    &#39;Used when an import statement is used anywhere other than the module toplevel. Move this import to the top of the file.&#39;</span>
<span class="gd">-    ), &#39;W0416&#39;: (&#39;Shadowed %r (imported line %s)&#39;, &#39;shadowed-import&#39;,</span>
<span class="gd">-    &#39;Used when a module is aliased with a name that shadows another import.&#39;)}</span>
<span class="gi">+    outputfile = _dependencies_graph(filename, dep_info)</span>
<span class="gi">+    sect.append(Paragraph((f&quot;{gtype}imports graph has been written to {outputfile}&quot;,)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# the import checker itself ###################################################</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+    &quot;E0401&quot;: (</span>
<span class="gi">+        &quot;Unable to import %s&quot;,</span>
<span class="gi">+        &quot;import-error&quot;,</span>
<span class="gi">+        &quot;Used when pylint has been unable to import a module.&quot;,</span>
<span class="gi">+        {&quot;old_names&quot;: [(&quot;F0401&quot;, &quot;old-import-error&quot;)]},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0402&quot;: (</span>
<span class="gi">+        &quot;Attempted relative import beyond top-level package&quot;,</span>
<span class="gi">+        &quot;relative-beyond-top-level&quot;,</span>
<span class="gi">+        &quot;Used when a relative import tries to access too many levels &quot;</span>
<span class="gi">+        &quot;in the current package.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;R0401&quot;: (</span>
<span class="gi">+        &quot;Cyclic import (%s)&quot;,</span>
<span class="gi">+        &quot;cyclic-import&quot;,</span>
<span class="gi">+        &quot;Used when a cyclic import between two or more modules is detected.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;R0402&quot;: (</span>
<span class="gi">+        &quot;Use &#39;from %s import %s&#39; instead&quot;,</span>
<span class="gi">+        &quot;consider-using-from-import&quot;,</span>
<span class="gi">+        &quot;Emitted when a submodule of a package is imported and &quot;</span>
<span class="gi">+        &quot;aliased with the same name, &quot;</span>
<span class="gi">+        &quot;e.g., instead of ``import concurrent.futures as futures`` use &quot;</span>
<span class="gi">+        &quot;``from concurrent import futures``.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0401&quot;: (</span>
<span class="gi">+        &quot;Wildcard import %s&quot;,</span>
<span class="gi">+        &quot;wildcard-import&quot;,</span>
<span class="gi">+        &quot;Used when `from module import *` is detected.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0404&quot;: (</span>
<span class="gi">+        &quot;Reimport %r (imported line %s)&quot;,</span>
<span class="gi">+        &quot;reimported&quot;,</span>
<span class="gi">+        &quot;Used when a module is imported more than once.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0406&quot;: (</span>
<span class="gi">+        &quot;Module import itself&quot;,</span>
<span class="gi">+        &quot;import-self&quot;,</span>
<span class="gi">+        &quot;Used when a module is importing itself.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0407&quot;: (</span>
<span class="gi">+        &quot;Prefer importing %r instead of %r&quot;,</span>
<span class="gi">+        &quot;preferred-module&quot;,</span>
<span class="gi">+        &quot;Used when a module imported has a preferred replacement module.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0410&quot;: (</span>
<span class="gi">+        &quot;__future__ import is not the first non docstring statement&quot;,</span>
<span class="gi">+        &quot;misplaced-future&quot;,</span>
<span class="gi">+        &quot;Python 2.5 and greater require __future__ import to be the &quot;</span>
<span class="gi">+        &quot;first non docstring statement in the module.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0410&quot;: (</span>
<span class="gi">+        &quot;Multiple imports on one line (%s)&quot;,</span>
<span class="gi">+        &quot;multiple-imports&quot;,</span>
<span class="gi">+        &quot;Used when import statement importing multiple modules is detected.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0411&quot;: (</span>
<span class="gi">+        &quot;%s should be placed before %s&quot;,</span>
<span class="gi">+        &quot;wrong-import-order&quot;,</span>
<span class="gi">+        &quot;Used when PEP8 import order is not respected (standard imports &quot;</span>
<span class="gi">+        &quot;first, then third-party libraries, then local imports).&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0412&quot;: (</span>
<span class="gi">+        &quot;Imports from package %s are not grouped&quot;,</span>
<span class="gi">+        &quot;ungrouped-imports&quot;,</span>
<span class="gi">+        &quot;Used when imports are not grouped by packages.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0413&quot;: (</span>
<span class="gi">+        &#39;Import &quot;%s&quot; should be placed at the top of the module&#39;,</span>
<span class="gi">+        &quot;wrong-import-position&quot;,</span>
<span class="gi">+        &quot;Used when code and imports are mixed.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0414&quot;: (</span>
<span class="gi">+        &quot;Import alias does not rename original package&quot;,</span>
<span class="gi">+        &quot;useless-import-alias&quot;,</span>
<span class="gi">+        &quot;Used when an import alias is same as original package, &quot;</span>
<span class="gi">+        &quot;e.g., using import numpy as numpy instead of import numpy as np.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;C0415&quot;: (</span>
<span class="gi">+        &quot;Import outside toplevel (%s)&quot;,</span>
<span class="gi">+        &quot;import-outside-toplevel&quot;,</span>
<span class="gi">+        &quot;Used when an import statement is used anywhere other than the module &quot;</span>
<span class="gi">+        &quot;toplevel. Move this import to the top of the file.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0416&quot;: (</span>
<span class="gi">+        &quot;Shadowed %r (imported line %s)&quot;,</span>
<span class="gi">+        &quot;shadowed-import&quot;,</span>
<span class="gi">+        &quot;Used when a module is aliased with a name that shadows another import.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_STANDARD_LIBRARY = ()
<span class="gd">-DEFAULT_KNOWN_THIRD_PARTY = &#39;enchant&#39;,</span>
<span class="gi">+DEFAULT_KNOWN_THIRD_PARTY = (&quot;enchant&quot;,)</span>
<span class="w"> </span>DEFAULT_PREFERRED_MODULES = ()


<span class="gu">@@ -119,144 +332,931 @@ class ImportsChecker(DeprecatedMixin, BaseChecker):</span>
<span class="w"> </span>    * uses of deprecated modules
<span class="w"> </span>    * uses of modules instead of preferred modules
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;imports&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;imports&quot;</span>
<span class="w"> </span>    msgs = {**DeprecatedMixin.DEPRECATED_MODULE_MESSAGE, **MSGS}
<span class="w"> </span>    default_deprecated_modules = ()
<span class="gd">-    options = (&#39;deprecated-modules&#39;, {&#39;default&#39;: default_deprecated_modules,</span>
<span class="gd">-        &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;modules&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Deprecated modules which should not be used, separated by a comma.&#39;}</span>
<span class="gd">-        ), (&#39;preferred-modules&#39;, {&#39;default&#39;: DEFAULT_PREFERRED_MODULES,</span>
<span class="gd">-        &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;module:preferred-module&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Couples of modules and preferred modules, separated by a comma.&#39;}), (</span>
<span class="gd">-        &#39;import-graph&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;path&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;file.gv&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Output a graph (.gv or any supported image format) of all (i.e. internal and external) dependencies to the given file (report RP0402 must not be disabled).&#39;</span>
<span class="gd">-        }), (&#39;ext-import-graph&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;path&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;file.gv&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Output a graph (.gv or any supported image format) of external dependencies to the given file (report RP0402 must not be disabled).&#39;</span>
<span class="gd">-        }), (&#39;int-import-graph&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;path&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;file.gv&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Output a graph (.gv or any supported image format) of internal dependencies to the given file (report RP0402 must not be disabled).&#39;</span>
<span class="gd">-        }), (&#39;known-standard-library&#39;, {&#39;default&#39;: DEFAULT_STANDARD_LIBRARY,</span>
<span class="gd">-        &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;modules&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Force import order to recognize a module as part of the standard compatibility libraries.&#39;</span>
<span class="gd">-        }), (&#39;known-third-party&#39;, {&#39;default&#39;: DEFAULT_KNOWN_THIRD_PARTY,</span>
<span class="gd">-        &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;modules&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Force import order to recognize a module as part of a third party library.&#39;</span>
<span class="gd">-        }), (&#39;allow-any-import-level&#39;, {&#39;default&#39;: (), &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;modules&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of modules that can be imported at any level, not just the top level one.&#39;</span>
<span class="gd">-        }), (&#39;allow-wildcard-with-all&#39;, {&#39;default&#39;: False, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Allow wildcard imports from modules that define __all__.&#39;}), (</span>
<span class="gd">-        &#39;allow-reexport-from-package&#39;, {&#39;default&#39;: False, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Allow explicit reexports by alias from a package __init__.&#39;})</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;deprecated-modules&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: default_deprecated_modules,</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;modules&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Deprecated modules which should not be used,&quot;</span>
<span class="gi">+                &quot; separated by a comma.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;preferred-modules&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: DEFAULT_PREFERRED_MODULES,</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;module:preferred-module&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Couples of modules and preferred modules,&quot;</span>
<span class="gi">+                &quot; separated by a comma.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;import-graph&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;path&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;file.gv&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Output a graph (.gv or any supported image format) of&quot;</span>
<span class="gi">+                &quot; all (i.e. internal and external) dependencies to the given file&quot;</span>
<span class="gi">+                &quot; (report RP0402 must not be disabled).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ext-import-graph&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;path&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;file.gv&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Output a graph (.gv or any supported image format)&quot;</span>
<span class="gi">+                &quot; of external dependencies to the given file&quot;</span>
<span class="gi">+                &quot; (report RP0402 must not be disabled).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;int-import-graph&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;path&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;file.gv&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Output a graph (.gv or any supported image format)&quot;</span>
<span class="gi">+                &quot; of internal dependencies to the given file&quot;</span>
<span class="gi">+                &quot; (report RP0402 must not be disabled).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;known-standard-library&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: DEFAULT_STANDARD_LIBRARY,</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;modules&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Force import order to recognize a module as part of &quot;</span>
<span class="gi">+                &quot;the standard compatibility libraries.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;known-third-party&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: DEFAULT_KNOWN_THIRD_PARTY,</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;modules&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Force import order to recognize a module as part of &quot;</span>
<span class="gi">+                &quot;a third party library.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;allow-any-import-level&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;modules&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;List of modules that can be imported at any level, not just &quot;</span>
<span class="gi">+                    &quot;the top level one.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;allow-wildcard-with-all&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Allow wildcard imports from modules that define __all__.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;allow-reexport-from-package&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Allow explicit reexports by alias from a package __init__.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        BaseChecker.__init__(self, linter)
<span class="w"> </span>        self.import_graph: defaultdict[str, set[str]] = defaultdict(set)
<span class="w"> </span>        self._imports_stack: list[tuple[ImportNode, str]] = []
<span class="w"> </span>        self._first_non_import_node = None
<span class="gd">-        self._module_pkg: dict[Any, Any] = {}</span>
<span class="gi">+        self._module_pkg: dict[Any, Any] = (</span>
<span class="gi">+            {}</span>
<span class="gi">+        )  # mapping of modules to the pkg they belong in</span>
<span class="w"> </span>        self._allow_any_import_level: set[Any] = set()
<span class="gd">-        self.reports = (&#39;RP0401&#39;, &#39;External dependencies&#39;, self.</span>
<span class="gd">-            _report_external_dependencies), (&#39;RP0402&#39;,</span>
<span class="gd">-            &#39;Modules dependencies graph&#39;, self._report_dependencies_graph)</span>
<span class="gi">+        self.reports = (</span>
<span class="gi">+            (&quot;RP0401&quot;, &quot;External dependencies&quot;, self._report_external_dependencies),</span>
<span class="gi">+            (&quot;RP0402&quot;, &quot;Modules dependencies graph&quot;, self._report_dependencies_graph),</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._excluded_edges: defaultdict[str, set[str]] = defaultdict(set)

<span class="gd">-    def open(self) -&gt;None:</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called before visiting project (i.e set of modules).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.linter.stats.dependencies = {}</span>
<span class="gi">+        self.linter.stats = self.linter.stats</span>
<span class="gi">+        self.import_graph = defaultdict(set)</span>
<span class="gi">+        self._module_pkg = {}  # mapping of modules to the pkg they belong in</span>
<span class="gi">+        self._current_module_package = False</span>
<span class="gi">+        self._ignored_modules: Sequence[str] = self.linter.config.ignored_modules</span>
<span class="gi">+        # Build a mapping {&#39;module&#39;: &#39;preferred-module&#39;}</span>
<span class="gi">+        self.preferred_modules = dict(</span>
<span class="gi">+            module.split(&quot;:&quot;)</span>
<span class="gi">+            for module in self.linter.config.preferred_modules</span>
<span class="gi">+            if &quot;:&quot; in module</span>
<span class="gi">+        )</span>
<span class="gi">+        self._allow_any_import_level = set(self.linter.config.allow_any_import_level)</span>
<span class="gi">+        self._allow_reexport_package = self.linter.config.allow_reexport_from_package</span>
<span class="gi">+</span>
<span class="gi">+    def _import_graph_without_ignored_edges(self) -&gt; defaultdict[str, set[str]]:</span>
<span class="gi">+        filtered_graph = copy.deepcopy(self.import_graph)</span>
<span class="gi">+        for node in filtered_graph:</span>
<span class="gi">+            filtered_graph[node].difference_update(self._excluded_edges[node])</span>
<span class="gi">+        return filtered_graph</span>

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called before visiting project (i.e set of modules).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.linter.is_message_enabled(&quot;cyclic-import&quot;):</span>
<span class="gi">+            graph = self._import_graph_without_ignored_edges()</span>
<span class="gi">+            vertices = list(graph)</span>
<span class="gi">+            for cycle in get_cycles(graph, vertices=vertices):</span>
<span class="gi">+                self.add_message(&quot;cyclic-import&quot;, args=&quot; -&gt; &quot;.join(cycle))</span>

<span class="gd">-    def deprecated_modules(self) -&gt;set[str]:</span>
<span class="gi">+    def get_map_data(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; tuple[defaultdict[str, set[str]], defaultdict[str, set[str]]]:</span>
<span class="gi">+        if self.linter.is_message_enabled(&quot;cyclic-import&quot;):</span>
<span class="gi">+            return (self.import_graph, self._excluded_edges)</span>
<span class="gi">+        return (defaultdict(set), defaultdict(set))</span>
<span class="gi">+</span>
<span class="gi">+    def reduce_map_data(</span>
<span class="gi">+        self,</span>
<span class="gi">+        linter: PyLinter,</span>
<span class="gi">+        data: list[tuple[defaultdict[str, set[str]], defaultdict[str, set[str]]]],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if self.linter.is_message_enabled(&quot;cyclic-import&quot;):</span>
<span class="gi">+            self.import_graph = defaultdict(set)</span>
<span class="gi">+            self._excluded_edges = defaultdict(set)</span>
<span class="gi">+            for to_update in data:</span>
<span class="gi">+                graph, excluded_edges = to_update</span>
<span class="gi">+                self.import_graph.update(graph)</span>
<span class="gi">+                self._excluded_edges.update(excluded_edges)</span>
<span class="gi">+</span>
<span class="gi">+            self.close()</span>
<span class="gi">+</span>
<span class="gi">+    def deprecated_modules(self) -&gt; set[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Callback returning the deprecated modules.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # First get the modules the user indicated</span>
<span class="gi">+        all_deprecated_modules = set(self.linter.config.deprecated_modules)</span>
<span class="gi">+        # Now get the hard-coded ones from the stdlib</span>
<span class="gi">+        for since_vers, mod_set in DEPRECATED_MODULES.items():</span>
<span class="gi">+            if since_vers &lt;= sys.version_info:</span>
<span class="gi">+                all_deprecated_modules = all_deprecated_modules.union(mod_set)</span>
<span class="gi">+        return all_deprecated_modules</span>

<span class="gd">-    def visit_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Store if current module is a package, i.e. an __init__ file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._current_module_package = node.package</span>

<span class="gd">-    def visit_import(self, node: nodes.Import) -&gt;None:</span>
<span class="gi">+    def visit_import(self, node: nodes.Import) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Triggered when an import statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_reimport(node)</span>
<span class="gi">+        self._check_import_as_rename(node)</span>
<span class="gi">+        self._check_toplevel(node)</span>
<span class="gi">+</span>
<span class="gi">+        names = [name for name, _ in node.names]</span>
<span class="gi">+        if len(names) &gt;= 2:</span>
<span class="gi">+            self.add_message(&quot;multiple-imports&quot;, args=&quot;, &quot;.join(names), node=node)</span>
<span class="gi">+</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            self.check_deprecated_module(node, name)</span>
<span class="gi">+            self._check_preferred_module(node, name)</span>
<span class="gi">+            imported_module = self._get_imported_module(node, name)</span>
<span class="gi">+            if isinstance(node.parent, nodes.Module):</span>
<span class="gi">+                # Allow imports nested</span>
<span class="gi">+                self._check_position(node)</span>
<span class="gi">+            if isinstance(node.scope(), nodes.Module):</span>
<span class="gi">+                self._record_import(node, imported_module)</span>

<span class="gd">-    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:</span>
<span class="gi">+            if imported_module is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            self._add_imported_module(node, imported_module.name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Triggered when a from statement is seen.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    (visit_try) = (visit_assignattr) = (visit_assign) = (visit_ifexp) = (</span>
<span class="gd">-        visit_comprehension) = (visit_expr) = (visit_if</span>
<span class="gd">-        ) = compute_first_non_import_node</span>
<span class="gi">+        basename = node.modname</span>
<span class="gi">+        imported_module = self._get_imported_module(node, basename)</span>
<span class="gi">+        absolute_name = get_import_name(node, basename)</span>
<span class="gi">+</span>
<span class="gi">+        self._check_import_as_rename(node)</span>
<span class="gi">+        self._check_misplaced_future(node)</span>
<span class="gi">+        self.check_deprecated_module(node, absolute_name)</span>
<span class="gi">+        self._check_preferred_module(node, basename)</span>
<span class="gi">+        self._check_wildcard_imports(node, imported_module)</span>
<span class="gi">+        self._check_same_line_imports(node)</span>
<span class="gi">+        self._check_reimport(node, basename=basename, level=node.level)</span>
<span class="gi">+        self._check_toplevel(node)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.parent, nodes.Module):</span>
<span class="gi">+            # Allow imports nested</span>
<span class="gi">+            self._check_position(node)</span>
<span class="gi">+        if isinstance(node.scope(), nodes.Module):</span>
<span class="gi">+            self._record_import(node, imported_module)</span>
<span class="gi">+        if imported_module is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        for name, _ in node.names:</span>
<span class="gi">+            if name != &quot;*&quot;:</span>
<span class="gi">+                self._add_imported_module(node, f&quot;{imported_module.name}.{name}&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._add_imported_module(node, imported_module.name)</span>
<span class="gi">+</span>
<span class="gi">+    def leave_module(self, node: nodes.Module) -&gt; None:</span>
<span class="gi">+        # Check imports are grouped by category (standard, 3rd party, local)</span>
<span class="gi">+        std_imports, ext_imports, loc_imports = self._check_imports_order(node)</span>
<span class="gi">+</span>
<span class="gi">+        # Check that imports are grouped by package within a given category</span>
<span class="gi">+        met_import: set[str] = set()  # set for &#39;import x&#39; style</span>
<span class="gi">+        met_from: set[str] = set()  # set for &#39;from x import y&#39; style</span>
<span class="gi">+        current_package = None</span>
<span class="gi">+        for import_node, import_name in std_imports + ext_imports + loc_imports:</span>
<span class="gi">+            met = met_from if isinstance(import_node, nodes.ImportFrom) else met_import</span>
<span class="gi">+            package, _, _ = import_name.partition(&quot;.&quot;)</span>
<span class="gi">+            if (</span>
<span class="gi">+                current_package</span>
<span class="gi">+                and current_package != package</span>
<span class="gi">+                and package in met</span>
<span class="gi">+                and not in_type_checking_block(import_node)</span>
<span class="gi">+                and not (</span>
<span class="gi">+                    isinstance(import_node.parent, nodes.If)</span>
<span class="gi">+                    and is_sys_guard(import_node.parent)</span>
<span class="gi">+                )</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;ungrouped-imports&quot;, node=import_node, args=package)</span>
<span class="gi">+            current_package = package</span>
<span class="gi">+            if not self.linter.is_message_enabled(</span>
<span class="gi">+                &quot;ungrouped-imports&quot;, import_node.fromlineno</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            met.add(package)</span>
<span class="gi">+</span>
<span class="gi">+        self._imports_stack = []</span>
<span class="gi">+        self._first_non_import_node = None</span>
<span class="gi">+</span>
<span class="gi">+    def compute_first_non_import_node(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: (</span>
<span class="gi">+            nodes.If</span>
<span class="gi">+            | nodes.Expr</span>
<span class="gi">+            | nodes.Comprehension</span>
<span class="gi">+            | nodes.IfExp</span>
<span class="gi">+            | nodes.Assign</span>
<span class="gi">+            | nodes.AssignAttr</span>
<span class="gi">+            | nodes.Try</span>
<span class="gi">+        ),</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # if the node does not contain an import instruction, and if it is the</span>
<span class="gi">+        # first node of the module, keep a track of it (all the import positions</span>
<span class="gi">+        # of the module will be compared to the position of this first</span>
<span class="gi">+        # instruction)</span>
<span class="gi">+        if self._first_non_import_node:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(node.parent, nodes.Module):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node, nodes.Try) and any(</span>
<span class="gi">+            node.nodes_of_class((nodes.Import, nodes.ImportFrom))</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node, nodes.Assign):</span>
<span class="gi">+            # Add compatibility for module level dunder names</span>
<span class="gi">+            # https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names</span>
<span class="gi">+            valid_targets = [</span>
<span class="gi">+                isinstance(target, nodes.AssignName)</span>
<span class="gi">+                and target.name.startswith(&quot;__&quot;)</span>
<span class="gi">+                and target.name.endswith(&quot;__&quot;)</span>
<span class="gi">+                for target in node.targets</span>
<span class="gi">+            ]</span>
<span class="gi">+            if all(valid_targets):</span>
<span class="gi">+                return</span>
<span class="gi">+        self._first_non_import_node = node</span>
<span class="gi">+</span>
<span class="gi">+    visit_try = visit_assignattr = visit_assign = visit_ifexp = visit_comprehension = (</span>
<span class="gi">+        visit_expr</span>
<span class="gi">+    ) = visit_if = compute_first_non_import_node</span>
<span class="gi">+</span>
<span class="gi">+    def visit_functiondef(</span>
<span class="gi">+        self, node: nodes.FunctionDef | nodes.While | nodes.For | nodes.ClassDef</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # If it is the first non import instruction of the module, record it.</span>
<span class="gi">+        if self._first_non_import_node:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Check if the node belongs to an `If` or a `Try` block. If they</span>
<span class="gi">+        # contain imports, skip recording this node.</span>
<span class="gi">+        if not isinstance(node.parent.scope(), nodes.Module):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        root = node</span>
<span class="gi">+        while not isinstance(root.parent, nodes.Module):</span>
<span class="gi">+            root = root.parent</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(root, (nodes.If, nodes.Try)):</span>
<span class="gi">+            if any(root.nodes_of_class((nodes.Import, nodes.ImportFrom))):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        self._first_non_import_node = node</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_classdef = visit_for = visit_while = visit_functiondef

<span class="gd">-    def _check_position(self, node: ImportNode) -&gt;None:</span>
<span class="gi">+    def _check_misplaced_future(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="gi">+        basename = node.modname</span>
<span class="gi">+        if basename == &quot;__future__&quot;:</span>
<span class="gi">+            # check if this is the first non-docstring statement in the module</span>
<span class="gi">+            prev = node.previous_sibling()</span>
<span class="gi">+            if prev:</span>
<span class="gi">+                # consecutive future statements are possible</span>
<span class="gi">+                if not (</span>
<span class="gi">+                    isinstance(prev, nodes.ImportFrom) and prev.modname == &quot;__future__&quot;</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(&quot;misplaced-future&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_same_line_imports(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="gi">+        # Detect duplicate imports on the same line.</span>
<span class="gi">+        names = (name for name, _ in node.names)</span>
<span class="gi">+        counter = collections.Counter(names)</span>
<span class="gi">+        for name, count in counter.items():</span>
<span class="gi">+            if count &gt; 1:</span>
<span class="gi">+                self.add_message(&quot;reimported&quot;, node=node, args=(name, node.fromlineno))</span>
<span class="gi">+</span>
<span class="gi">+    def _check_position(self, node: ImportNode) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check `node` import or importfrom node position is correct.

<span class="w"> </span>        Send a message  if `node` comes before another instruction
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # if a first non-import instruction has already been encountered,</span>
<span class="gi">+        # it means the import comes after it and therefore is not well placed</span>
<span class="gi">+        if self._first_non_import_node:</span>
<span class="gi">+            if self.linter.is_message_enabled(</span>
<span class="gi">+                &quot;wrong-import-position&quot;, self._first_non_import_node.fromlineno</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;wrong-import-position&quot;, node=node, args=node.as_string()</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.linter.add_ignored_message(</span>
<span class="gi">+                    &quot;wrong-import-position&quot;, node.fromlineno, node</span>
<span class="gi">+                )</span>

<span class="gd">-    def _record_import(self, node: ImportNode, importedmodnode: (nodes.</span>
<span class="gd">-        Module | None)) -&gt;None:</span>
<span class="gi">+    def _record_import(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: ImportNode,</span>
<span class="gi">+        importedmodnode: nodes.Module | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Record the package `node` imports from.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, nodes.ImportFrom):</span>
<span class="gi">+            importedname = node.modname</span>
<span class="gi">+        else:</span>
<span class="gi">+            importedname = importedmodnode.name if importedmodnode else None</span>
<span class="gi">+        if not importedname:</span>
<span class="gi">+            importedname = node.names[0][0].split(&quot;.&quot;)[0]</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node, nodes.ImportFrom) and (node.level or 0) &gt;= 1:</span>
<span class="gi">+            # We need the importedname with first point to detect local package</span>
<span class="gi">+            # Example of node:</span>
<span class="gi">+            #  &#39;from .my_package1 import MyClass1&#39;</span>
<span class="gi">+            #  the output should be &#39;.my_package1&#39; instead of &#39;my_package1&#39;</span>
<span class="gi">+            # Example of node:</span>
<span class="gi">+            #  &#39;from . import my_package2&#39;</span>
<span class="gi">+            #  the output should be &#39;.my_package2&#39; instead of &#39;{pyfile}&#39;</span>
<span class="gi">+            importedname = &quot;.&quot; + importedname</span>
<span class="gi">+</span>
<span class="gi">+        self._imports_stack.append((node, importedname))</span>

<span class="gd">-    def _check_imports_order(self, _module_node: nodes.Module) -&gt;tuple[list</span>
<span class="gd">-        [tuple[ImportNode, str]], list[tuple[ImportNode, str]], list[tuple[</span>
<span class="gd">-        ImportNode, str]]]:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_fallback_import(</span>
<span class="gi">+        node: ImportNode, imports: list[tuple[ImportNode, str]]</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        imports = [import_node for (import_node, _) in imports]</span>
<span class="gi">+        return any(astroid.are_exclusive(import_node, node) for import_node in imports)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-statements</span>
<span class="gi">+    def _check_imports_order(self, _module_node: nodes.Module) -&gt; tuple[</span>
<span class="gi">+        list[tuple[ImportNode, str]],</span>
<span class="gi">+        list[tuple[ImportNode, str]],</span>
<span class="gi">+        list[tuple[ImportNode, str]],</span>
<span class="gi">+    ]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks imports of module `node` are grouped by category.

<span class="w"> </span>        Imports must follow this order: standard, 3rd party, local
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        std_imports: list[tuple[ImportNode, str]] = []</span>
<span class="gi">+        third_party_imports: list[tuple[ImportNode, str]] = []</span>
<span class="gi">+        first_party_imports: list[tuple[ImportNode, str]] = []</span>
<span class="gi">+        # need of a list that holds third or first party ordered import</span>
<span class="gi">+        external_imports: list[tuple[ImportNode, str]] = []</span>
<span class="gi">+        local_imports: list[tuple[ImportNode, str]] = []</span>
<span class="gi">+        third_party_not_ignored: list[tuple[ImportNode, str]] = []</span>
<span class="gi">+        first_party_not_ignored: list[tuple[ImportNode, str]] = []</span>
<span class="gi">+        local_not_ignored: list[tuple[ImportNode, str]] = []</span>
<span class="gi">+        isort_driver = IsortDriver(self.linter.config)</span>
<span class="gi">+        for node, modname in self._imports_stack:</span>
<span class="gi">+            if modname.startswith(&quot;.&quot;):</span>
<span class="gi">+                package = &quot;.&quot; + modname.split(&quot;.&quot;)[1]</span>
<span class="gi">+            else:</span>
<span class="gi">+                package = modname.split(&quot;.&quot;)[0]</span>
<span class="gi">+            nested = not isinstance(node.parent, nodes.Module)</span>
<span class="gi">+            ignore_for_import_order = not self.linter.is_message_enabled(</span>
<span class="gi">+                &quot;wrong-import-order&quot;, node.fromlineno</span>
<span class="gi">+            )</span>
<span class="gi">+            import_category = isort_driver.place_module(package)</span>
<span class="gi">+            node_and_package_import = (node, package)</span>
<span class="gi">+</span>
<span class="gi">+            if import_category in {&quot;FUTURE&quot;, &quot;STDLIB&quot;}:</span>
<span class="gi">+                std_imports.append(node_and_package_import)</span>
<span class="gi">+                wrong_import = (</span>
<span class="gi">+                    third_party_not_ignored</span>
<span class="gi">+                    or first_party_not_ignored</span>
<span class="gi">+                    or local_not_ignored</span>
<span class="gi">+                )</span>
<span class="gi">+                if self._is_fallback_import(node, wrong_import):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if wrong_import and not nested:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;wrong-import-order&quot;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=(  ## TODO - this isn&#39;t right for multiple on the same line...</span>
<span class="gi">+                            f&#39;standard import &quot;{self._get_full_import_name((node, package))}&quot;&#39;,</span>
<span class="gi">+                            self._get_out_of_order_string(</span>
<span class="gi">+                                third_party_not_ignored,</span>
<span class="gi">+                                first_party_not_ignored,</span>
<span class="gi">+                                local_not_ignored,</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    )</span>
<span class="gi">+            elif import_category == &quot;THIRDPARTY&quot;:</span>
<span class="gi">+                third_party_imports.append(node_and_package_import)</span>
<span class="gi">+                external_imports.append(node_and_package_import)</span>
<span class="gi">+                if not nested:</span>
<span class="gi">+                    if not ignore_for_import_order:</span>
<span class="gi">+                        third_party_not_ignored.append(node_and_package_import)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.linter.add_ignored_message(</span>
<span class="gi">+                            &quot;wrong-import-order&quot;, node.fromlineno, node</span>
<span class="gi">+                        )</span>
<span class="gi">+                wrong_import = first_party_not_ignored or local_not_ignored</span>
<span class="gi">+                if wrong_import and not nested:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;wrong-import-order&quot;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=(</span>
<span class="gi">+                            f&#39;third party import &quot;{self._get_full_import_name((node, package))}&quot;&#39;,</span>
<span class="gi">+                            self._get_out_of_order_string(</span>
<span class="gi">+                                None, first_party_not_ignored, local_not_ignored</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    )</span>
<span class="gi">+            elif import_category == &quot;FIRSTPARTY&quot;:</span>
<span class="gi">+                first_party_imports.append(node_and_package_import)</span>
<span class="gi">+                external_imports.append(node_and_package_import)</span>
<span class="gi">+                if not nested:</span>
<span class="gi">+                    if not ignore_for_import_order:</span>
<span class="gi">+                        first_party_not_ignored.append(node_and_package_import)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.linter.add_ignored_message(</span>
<span class="gi">+                            &quot;wrong-import-order&quot;, node.fromlineno, node</span>
<span class="gi">+                        )</span>
<span class="gi">+                wrong_import = local_not_ignored</span>
<span class="gi">+                if wrong_import and not nested:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;wrong-import-order&quot;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=(</span>
<span class="gi">+                            f&#39;first party import &quot;{self._get_full_import_name((node, package))}&quot;&#39;,</span>
<span class="gi">+                            self._get_out_of_order_string(</span>
<span class="gi">+                                None, None, local_not_ignored</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        ),</span>
<span class="gi">+                    )</span>
<span class="gi">+            elif import_category == &quot;LOCALFOLDER&quot;:</span>
<span class="gi">+                local_imports.append((node, package))</span>
<span class="gi">+                if not nested:</span>
<span class="gi">+                    if not ignore_for_import_order:</span>
<span class="gi">+                        local_not_ignored.append((node, package))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.linter.add_ignored_message(</span>
<span class="gi">+                            &quot;wrong-import-order&quot;, node.fromlineno, node</span>
<span class="gi">+                        )</span>
<span class="gi">+        return std_imports, external_imports, local_imports</span>
<span class="gi">+</span>
<span class="gi">+    def _get_out_of_order_string(</span>
<span class="gi">+        self,</span>
<span class="gi">+        third_party_imports: list[tuple[ImportNode, str]] | None,</span>
<span class="gi">+        first_party_imports: list[tuple[ImportNode, str]] | None,</span>
<span class="gi">+        local_imports: list[tuple[ImportNode, str]] | None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        # construct the string listing out of order imports used in the message</span>
<span class="gi">+        # for wrong-import-order</span>
<span class="gi">+        if third_party_imports:</span>
<span class="gi">+            plural = &quot;s&quot; if len(third_party_imports) &gt; 1 else &quot;&quot;</span>
<span class="gi">+            if len(third_party_imports) &gt; MAX_NUMBER_OF_IMPORT_SHOWN:</span>
<span class="gi">+                imports_list = (</span>
<span class="gi">+                    &quot;, &quot;.join(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            f&#39;&quot;{self._get_full_import_name(tpi)}&quot;&#39;</span>
<span class="gi">+                            for tpi in third_party_imports[</span>
<span class="gi">+                                : int(MAX_NUMBER_OF_IMPORT_SHOWN // 2)</span>
<span class="gi">+                            ]</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    )</span>
<span class="gi">+                    + &quot; (...) &quot;</span>
<span class="gi">+                    + &quot;, &quot;.join(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            f&#39;&quot;{self._get_full_import_name(tpi)}&quot;&#39;</span>
<span class="gi">+                            for tpi in third_party_imports[</span>
<span class="gi">+                                int(-MAX_NUMBER_OF_IMPORT_SHOWN // 2) :</span>
<span class="gi">+                            ]</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                imports_list = &quot;, &quot;.join(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        f&#39;&quot;{self._get_full_import_name(tpi)}&quot;&#39;</span>
<span class="gi">+                        for tpi in third_party_imports</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="gi">+            third_party = f&quot;third party import{plural} {imports_list}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            third_party = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if first_party_imports:</span>
<span class="gi">+            plural = &quot;s&quot; if len(first_party_imports) &gt; 1 else &quot;&quot;</span>
<span class="gi">+            if len(first_party_imports) &gt; MAX_NUMBER_OF_IMPORT_SHOWN:</span>
<span class="gi">+                imports_list = (</span>
<span class="gi">+                    &quot;, &quot;.join(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            f&#39;&quot;{self._get_full_import_name(tpi)}&quot;&#39;</span>
<span class="gi">+                            for tpi in first_party_imports[</span>
<span class="gi">+                                : int(MAX_NUMBER_OF_IMPORT_SHOWN // 2)</span>
<span class="gi">+                            ]</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    )</span>
<span class="gi">+                    + &quot; (...) &quot;</span>
<span class="gi">+                    + &quot;, &quot;.join(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            f&#39;&quot;{self._get_full_import_name(tpi)}&quot;&#39;</span>
<span class="gi">+                            for tpi in first_party_imports[</span>
<span class="gi">+                                int(-MAX_NUMBER_OF_IMPORT_SHOWN // 2) :</span>
<span class="gi">+                            ]</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                imports_list = &quot;, &quot;.join(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        f&#39;&quot;{self._get_full_import_name(fpi)}&quot;&#39;</span>
<span class="gi">+                        for fpi in first_party_imports</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="gi">+            first_party = f&quot;first party import{plural} {imports_list}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            first_party = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if local_imports:</span>
<span class="gi">+            plural = &quot;s&quot; if len(local_imports) &gt; 1 else &quot;&quot;</span>
<span class="gi">+            if len(local_imports) &gt; MAX_NUMBER_OF_IMPORT_SHOWN:</span>
<span class="gi">+                imports_list = (</span>
<span class="gi">+                    &quot;, &quot;.join(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            f&#39;&quot;{self._get_full_import_name(tpi)}&quot;&#39;</span>
<span class="gi">+                            for tpi in local_imports[</span>
<span class="gi">+                                : int(MAX_NUMBER_OF_IMPORT_SHOWN // 2)</span>
<span class="gi">+                            ]</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    )</span>
<span class="gi">+                    + &quot; (...) &quot;</span>
<span class="gi">+                    + &quot;, &quot;.join(</span>
<span class="gi">+                        [</span>
<span class="gi">+                            f&#39;&quot;{self._get_full_import_name(tpi)}&quot;&#39;</span>
<span class="gi">+                            for tpi in local_imports[</span>
<span class="gi">+                                int(-MAX_NUMBER_OF_IMPORT_SHOWN // 2) :</span>
<span class="gi">+                            ]</span>
<span class="gi">+                        ]</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                imports_list = &quot;, &quot;.join(</span>
<span class="gi">+                    [f&#39;&quot;{self._get_full_import_name(li)}&quot;&#39; for li in local_imports]</span>
<span class="gi">+                )</span>
<span class="gi">+            local = f&quot;local import{plural} {imports_list}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            local = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        delimiter_third_party = (</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;, &quot;</span>
<span class="gi">+                if (first_party and local)</span>
<span class="gi">+                else (&quot; and &quot; if (first_party or local) else &quot;&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+            if third_party</span>
<span class="gi">+            else &quot;&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        delimiter_first_party1 = (</span>
<span class="gi">+            (&quot;, &quot; if (third_party and local) else &quot; &quot;) if first_party else &quot;&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        delimiter_first_party2 = (&quot;and &quot; if local else &quot;&quot;) if first_party else &quot;&quot;</span>
<span class="gi">+        delimiter_first_party = f&quot;{delimiter_first_party1}{delimiter_first_party2}&quot;</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            f&quot;{third_party}{delimiter_third_party}&quot;</span>
<span class="gi">+            f&quot;{first_party}{delimiter_first_party}&quot;</span>
<span class="gi">+            f&#39;{local if local else &quot;&quot;}&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return msg</span>
<span class="gi">+</span>
<span class="gi">+    def _get_full_import_name(self, importNode: ImportNode) -&gt; str:</span>
<span class="gi">+        # construct a more descriptive name of the import</span>
<span class="gi">+        # for: import X, this returns X</span>
<span class="gi">+        # for: import X.Y this returns X.Y</span>
<span class="gi">+        # for: from X import Y, this returns X.Y</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # this will only succeed for ImportFrom nodes, which in themselves</span>
<span class="gi">+            # contain the information needed to reconstruct the package</span>
<span class="gi">+            return f&quot;{importNode[0].modname}.{importNode[0].names[0][0]}&quot;</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # in all other cases, the import will either be X or X.Y</span>
<span class="gi">+            node: str = importNode[0].names[0][0]</span>
<span class="gi">+            package: str = importNode[1]</span>
<span class="gi">+</span>
<span class="gi">+            if node.split(&quot;.&quot;)[0] == package:</span>
<span class="gi">+                # this is sufficient with one import per line, since package = X</span>
<span class="gi">+                # and node = X.Y or X</span>
<span class="gi">+                return node</span>
<span class="gi">+</span>
<span class="gi">+            # when there is a node that contains multiple imports, the &quot;current&quot;</span>
<span class="gi">+            # import being analyzed is specified by package (node is the first</span>
<span class="gi">+            # import on the line and therefore != package in this case)</span>
<span class="gi">+            return package</span>
<span class="gi">+</span>
<span class="gi">+    def _get_imported_module(</span>
<span class="gi">+        self, importnode: ImportNode, modname: str</span>
<span class="gi">+    ) -&gt; nodes.Module | None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return importnode.do_import_module(modname)</span>
<span class="gi">+        except astroid.TooManyLevelsError:</span>
<span class="gi">+            if _ignore_import_failure(importnode, modname, self._ignored_modules):</span>
<span class="gi">+                return None</span>
<span class="gi">+            self.add_message(&quot;relative-beyond-top-level&quot;, node=importnode)</span>
<span class="gi">+        except astroid.AstroidSyntaxError as exc:</span>
<span class="gi">+            message = f&quot;Cannot import {modname!r} due to &#39;{exc.error}&#39;&quot;</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;syntax-error&quot;, line=importnode.lineno, args=message, confidence=HIGH</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        except astroid.AstroidBuildingError:</span>
<span class="gi">+            if not self.linter.is_message_enabled(&quot;import-error&quot;):</span>
<span class="gi">+                return None</span>
<span class="gi">+            if _ignore_import_failure(importnode, modname, self._ignored_modules):</span>
<span class="gi">+                return None</span>
<span class="gi">+            if (</span>
<span class="gi">+                not self.linter.config.analyse_fallback_blocks</span>
<span class="gi">+                and is_from_fallback_block(importnode)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return None</span>

<span class="gd">-    def _add_imported_module(self, node: ImportNode, importedmodname: str</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+            dotted_modname = get_import_name(importnode, modname)</span>
<span class="gi">+            self.add_message(&quot;import-error&quot;, args=repr(dotted_modname), node=importnode)</span>
<span class="gi">+        except Exception as e:  # pragma: no cover</span>
<span class="gi">+            raise astroid.AstroidError from e</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _add_imported_module(self, node: ImportNode, importedmodname: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Notify an imported module, used to analyze dependencies.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        module_file = node.root().file</span>
<span class="gi">+        context_name = node.root().name</span>
<span class="gi">+        base = os.path.splitext(os.path.basename(module_file))[0]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if isinstance(node, nodes.ImportFrom) and node.level:</span>
<span class="gi">+                importedmodname = astroid.modutils.get_module_part(</span>
<span class="gi">+                    importedmodname, module_file</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                importedmodname = astroid.modutils.get_module_part(importedmodname)</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        if context_name == importedmodname:</span>
<span class="gi">+            self.add_message(&quot;import-self&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+        elif not astroid.modutils.is_stdlib_module(importedmodname):</span>
<span class="gi">+            # if this is not a package __init__ module</span>
<span class="gi">+            if base != &quot;__init__&quot; and context_name not in self._module_pkg:</span>
<span class="gi">+                # record the module&#39;s parent, or the module itself if this is</span>
<span class="gi">+                # a top level module, as the package it belongs to</span>
<span class="gi">+                self._module_pkg[context_name] = context_name.rsplit(&quot;.&quot;, 1)[0]</span>
<span class="gi">+</span>
<span class="gi">+            # handle dependencies</span>
<span class="gi">+            dependencies_stat: dict[str, set[str]] = self.linter.stats.dependencies</span>
<span class="gi">+            importedmodnames = dependencies_stat.setdefault(importedmodname, set())</span>
<span class="gi">+            if context_name not in importedmodnames:</span>
<span class="gi">+                importedmodnames.add(context_name)</span>
<span class="gi">+</span>
<span class="gi">+            # update import graph</span>
<span class="gi">+            self.import_graph[context_name].add(importedmodname)</span>
<span class="gi">+            if not self.linter.is_message_enabled(</span>
<span class="gi">+                &quot;cyclic-import&quot;, line=node.lineno</span>
<span class="gi">+            ) or in_type_checking_block(node):</span>
<span class="gi">+                self._excluded_edges[context_name].add(importedmodname)</span>

<span class="gd">-    def _check_preferred_module(self, node: ImportNode, mod_path: str) -&gt;None:</span>
<span class="gi">+    def _check_preferred_module(self, node: ImportNode, mod_path: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the module has a preferred replacement.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mod_compare = [mod_path]</span>
<span class="gi">+        # build a comparison list of possible names using importfrom</span>
<span class="gi">+        if isinstance(node, astroid.nodes.node_classes.ImportFrom):</span>
<span class="gi">+            mod_compare = [f&quot;{node.modname}.{name[0]}&quot; for name in node.names]</span>
<span class="gi">+</span>
<span class="gi">+        # find whether there are matches with the import vs preferred_modules keys</span>
<span class="gi">+        matches = [</span>
<span class="gi">+            k</span>
<span class="gi">+            for k in self.preferred_modules</span>
<span class="gi">+            for mod in mod_compare</span>
<span class="gi">+            # exact match</span>
<span class="gi">+            if k == mod</span>
<span class="gi">+            # checks for base module matches</span>
<span class="gi">+            or k in mod.split(&quot;.&quot;)[0]</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # if we have matches, add message</span>
<span class="gi">+        if matches:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;preferred-module&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(self.preferred_modules[matches[0]], matches[0]),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_import_as_rename(self, node: ImportNode) -&gt; None:</span>
<span class="gi">+        names = node.names</span>
<span class="gi">+        for name in names:</span>
<span class="gi">+            if not all(name):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            splitted_packages = name[0].rsplit(&quot;.&quot;, maxsplit=1)</span>
<span class="gi">+            import_name = splitted_packages[-1]</span>
<span class="gi">+            aliased_name = name[1]</span>
<span class="gi">+            if import_name != aliased_name:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if len(splitted_packages) == 1 and (</span>
<span class="gi">+                self._allow_reexport_package is False</span>
<span class="gi">+                or self._current_module_package is False</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;useless-import-alias&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+            elif len(splitted_packages) == 2:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;consider-using-from-import&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(splitted_packages[0], import_name),</span>
<span class="gi">+                )</span>

<span class="gd">-    def _check_reimport(self, node: ImportNode, basename: (str | None)=None,</span>
<span class="gd">-        level: (int | None)=None) -&gt;None:</span>
<span class="gi">+    def _check_reimport(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: ImportNode,</span>
<span class="gi">+        basename: str | None = None,</span>
<span class="gi">+        level: int | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a module with the same name is already imported or aliased.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.linter.is_message_enabled(</span>
<span class="gi">+            &quot;reimported&quot;</span>
<span class="gi">+        ) and not self.linter.is_message_enabled(&quot;shadowed-import&quot;):</span>
<span class="gi">+            return</span>

<span class="gd">-    def _report_external_dependencies(self, sect: Section, _: LinterStats,</span>
<span class="gd">-        _dummy: (LinterStats | None)) -&gt;None:</span>
<span class="gi">+        frame = node.frame()</span>
<span class="gi">+        root = node.root()</span>
<span class="gi">+        contexts = [(frame, level)]</span>
<span class="gi">+        if root is not frame:</span>
<span class="gi">+            contexts.append((root, None))</span>
<span class="gi">+</span>
<span class="gi">+        for known_context, known_level in contexts:</span>
<span class="gi">+            for name, alias in node.names:</span>
<span class="gi">+                first, msg = _get_first_import(</span>
<span class="gi">+                    node, known_context, name, basename, known_level, alias</span>
<span class="gi">+                )</span>
<span class="gi">+                if first is not None and msg is not None:</span>
<span class="gi">+                    name = name if msg == &quot;reimported&quot; else alias</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        msg, node=node, args=(name, first.fromlineno), confidence=HIGH</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def _report_external_dependencies(</span>
<span class="gi">+        self, sect: Section, _: LinterStats, _dummy: LinterStats | None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a verbatim layout for displaying dependencies.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dep_info = _make_tree_defs(self._external_dependencies_info.items())</span>
<span class="gi">+        if not dep_info:</span>
<span class="gi">+            raise EmptyReportError()</span>
<span class="gi">+        tree_str = _repr_tree_defs(dep_info)</span>
<span class="gi">+        sect.append(VerbatimText(tree_str))</span>

<span class="gd">-    def _report_dependencies_graph(self, sect: Section, _: LinterStats,</span>
<span class="gd">-        _dummy: (LinterStats | None)) -&gt;None:</span>
<span class="gi">+    def _report_dependencies_graph(</span>
<span class="gi">+        self, sect: Section, _: LinterStats, _dummy: LinterStats | None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write dependencies as a dot (graphviz) file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dep_info = self.linter.stats.dependencies</span>
<span class="gi">+        if not dep_info or not (</span>
<span class="gi">+            self.linter.config.import_graph</span>
<span class="gi">+            or self.linter.config.ext_import_graph</span>
<span class="gi">+            or self.linter.config.int_import_graph</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise EmptyReportError()</span>
<span class="gi">+        filename = self.linter.config.import_graph</span>
<span class="gi">+        if filename:</span>
<span class="gi">+            _make_graph(filename, dep_info, sect, &quot;&quot;)</span>
<span class="gi">+        filename = self.linter.config.ext_import_graph</span>
<span class="gi">+        if filename:</span>
<span class="gi">+            _make_graph(filename, self._external_dependencies_info, sect, &quot;external &quot;)</span>
<span class="gi">+        filename = self.linter.config.int_import_graph</span>
<span class="gi">+        if filename:</span>
<span class="gi">+            _make_graph(filename, self._internal_dependencies_info, sect, &quot;internal &quot;)</span>

<span class="gd">-    def _filter_dependencies_graph(self, internal: bool) -&gt;defaultdict[str,</span>
<span class="gd">-        set[str]]:</span>
<span class="gi">+    def _filter_dependencies_graph(self, internal: bool) -&gt; defaultdict[str, set[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build the internal or the external dependency graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        graph: defaultdict[str, set[str]] = defaultdict(set)</span>
<span class="gi">+        for importee, importers in self.linter.stats.dependencies.items():</span>
<span class="gi">+            for importer in importers:</span>
<span class="gi">+                package = self._module_pkg.get(importer, importer)</span>
<span class="gi">+                is_inside = importee.startswith(package)</span>
<span class="gi">+                if is_inside and internal or not is_inside and not internal:</span>
<span class="gi">+                    graph[importee].add(importer)</span>
<span class="gi">+        return graph</span>

<span class="w"> </span>    @cached_property
<span class="gd">-    def _external_dependencies_info(self) -&gt;defaultdict[str, set[str]]:</span>
<span class="gi">+    def _external_dependencies_info(self) -&gt; defaultdict[str, set[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return cached external dependencies information or build and
<span class="w"> </span>        cache them.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._filter_dependencies_graph(internal=False)</span>

<span class="w"> </span>    @cached_property
<span class="gd">-    def _internal_dependencies_info(self) -&gt;defaultdict[str, set[str]]:</span>
<span class="gi">+    def _internal_dependencies_info(self) -&gt; defaultdict[str, set[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return cached internal dependencies information or build and
<span class="w"> </span>        cache them.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._filter_dependencies_graph(internal=True)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_wildcard_imports(</span>
<span class="gi">+        self, node: nodes.ImportFrom, imported_module: nodes.Module | None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if node.root().package:</span>
<span class="gi">+            # Skip the check if in __init__.py issue #2026</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        wildcard_import_is_allowed = self._wildcard_import_is_allowed(imported_module)</span>
<span class="gi">+        for name, _ in node.names:</span>
<span class="gi">+            if name == &quot;*&quot; and not wildcard_import_is_allowed:</span>
<span class="gi">+                self.add_message(&quot;wildcard-import&quot;, args=node.modname, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _wildcard_import_is_allowed(self, imported_module: nodes.Module | None) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.linter.config.allow_wildcard_with_all</span>
<span class="gi">+            and imported_module is not None</span>
<span class="gi">+            and &quot;__all__&quot; in imported_module.locals</span>
<span class="gi">+        )</span>

<span class="gd">-    def _check_toplevel(self, node: ImportNode) -&gt;None:</span>
<span class="gi">+    def _check_toplevel(self, node: ImportNode) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether the import is made outside the module toplevel.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # If the scope of the import is a module, then obviously it is</span>
<span class="gi">+        # not outside the module toplevel.</span>
<span class="gi">+        if isinstance(node.scope(), nodes.Module):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        module_names = [</span>
<span class="gi">+            (</span>
<span class="gi">+                f&quot;{node.modname}.{name[0]}&quot;</span>
<span class="gi">+                if isinstance(node, nodes.ImportFrom)</span>
<span class="gi">+                else name[0]</span>
<span class="gi">+            )</span>
<span class="gi">+            for name in node.names</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        # Get the full names of all the imports that are only allowed at the module level</span>
<span class="gi">+        scoped_imports = [</span>
<span class="gi">+            name for name in module_names if name not in self._allow_any_import_level</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        if scoped_imports:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;import-outside-toplevel&quot;, args=&quot;, &quot;.join(scoped_imports), node=node</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(ImportsChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/lambda_expressions.py b/pylint/checkers/lambda_expressions.py</span>
<span class="gh">index a4466072b..18c03060d 100644</span>
<span class="gd">--- a/pylint/checkers/lambda_expressions.py</span>
<span class="gi">+++ b/pylint/checkers/lambda_expressions.py</span>
<span class="gu">@@ -1,31 +1,93 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from itertools import zip_longest
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class LambdaExpressionChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Check for unnecessary usage of lambda expressions.&quot;&quot;&quot;
<span class="gd">-    name = &#39;lambda-expressions&#39;</span>
<span class="gd">-    msgs = {&#39;C3001&#39;: (</span>
<span class="gd">-        &#39;Lambda expression assigned to a variable. Define a function using the &quot;def&quot; keyword instead.&#39;</span>
<span class="gd">-        , &#39;unnecessary-lambda-assignment&#39;,</span>
<span class="gd">-        &#39;Used when a lambda expression is assigned to variable rather than defining a standard function with the &quot;def&quot; keyword.&#39;</span>
<span class="gd">-        ), &#39;C3002&#39;: (</span>
<span class="gd">-        &#39;Lambda expression called directly. Execute the expression inline instead.&#39;</span>
<span class="gd">-        , &#39;unnecessary-direct-lambda-call&#39;,</span>
<span class="gd">-        &#39;Used when a lambda expression is directly called rather than executing its contents inline.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;lambda-expressions&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C3001&quot;: (</span>
<span class="gi">+            &quot;Lambda expression assigned to a variable. &quot;</span>
<span class="gi">+            &#39;Define a function using the &quot;def&quot; keyword instead.&#39;,</span>
<span class="gi">+            &quot;unnecessary-lambda-assignment&quot;,</span>
<span class="gi">+            &quot;Used when a lambda expression is assigned to variable &quot;</span>
<span class="gi">+            &#39;rather than defining a standard function with the &quot;def&quot; keyword.&#39;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C3002&quot;: (</span>
<span class="gi">+            &quot;Lambda expression called directly. Execute the expression inline instead.&quot;,</span>
<span class="gi">+            &quot;unnecessary-direct-lambda-call&quot;,</span>
<span class="gi">+            &quot;Used when a lambda expression is directly called &quot;</span>
<span class="gi">+            &quot;rather than executing its contents inline.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="w"> </span>    options = ()

<span class="gd">-    def visit_assign(self, node: nodes.Assign) -&gt;None:</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if lambda expression is assigned to a variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.targets[0], nodes.AssignName) and isinstance(</span>
<span class="gi">+            node.value, nodes.Lambda</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unnecessary-lambda-assignment&quot;,</span>
<span class="gi">+                node=node.value,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(node.targets[0], nodes.Tuple) and isinstance(</span>
<span class="gi">+            node.value, (nodes.Tuple, nodes.List)</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Iterate over tuple unpacking assignment elements and</span>
<span class="gi">+            # see if any lambdas are assigned to a variable.</span>
<span class="gi">+            # N.B. We may encounter W0632 (unbalanced-tuple-unpacking)</span>
<span class="gi">+            # and still need to flag the lambdas that are being assigned.</span>
<span class="gi">+            for lhs_elem, rhs_elem in zip_longest(</span>
<span class="gi">+                node.targets[0].elts, node.value.elts</span>
<span class="gi">+            ):</span>
<span class="gi">+                if lhs_elem is None or rhs_elem is None:</span>
<span class="gi">+                    # unbalanced tuple unpacking. stop checking.</span>
<span class="gi">+                    break</span>
<span class="gi">+                if isinstance(lhs_elem, nodes.AssignName) and isinstance(</span>
<span class="gi">+                    rhs_elem, nodes.Lambda</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;unnecessary-lambda-assignment&quot;,</span>
<span class="gi">+                        node=rhs_elem,</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_namedexpr(self, node: nodes.NamedExpr) -&gt; None:</span>
<span class="gi">+        if isinstance(node.target, nodes.AssignName) and isinstance(</span>
<span class="gi">+            node.value, nodes.Lambda</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unnecessary-lambda-assignment&quot;,</span>
<span class="gi">+                node=node.value,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>

<span class="gd">-    def visit_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if lambda expression is called directly.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.func, nodes.Lambda):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unnecessary-direct-lambda-call&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(LambdaExpressionChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/logging.py b/pylint/checkers/logging.py</span>
<span class="gh">index e7eeb4359..8a02d662b 100644</span>
<span class="gd">--- a/pylint/checkers/logging.py</span>
<span class="gi">+++ b/pylint/checkers/logging.py</span>
<span class="gu">@@ -1,46 +1,110 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checker for use of Python logging.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import string
<span class="w"> </span>from typing import TYPE_CHECKING, Literal
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import bases, nodes
<span class="w"> </span>from astroid.typing import InferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.utils import infer_all
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;W1201&#39;: (</span>
<span class="gd">-    &#39;Use %s formatting in logging functions&#39;, &#39;logging-not-lazy&#39;,</span>
<span class="gd">-    &#39;Used when a logging statement has a call form of &quot;logging.&lt;logging method&gt;(format_string % (format_args...))&quot;. Use another type of string formatting instead. You can use % formatting but leave interpolation to the logging function by passing the parameters as arguments. If logging-fstring-interpolation is disabled then you can use fstring formatting. If logging-format-interpolation is disabled then you can use str.format.&#39;</span>
<span class="gd">-    ), &#39;W1202&#39;: (&#39;Use %s formatting in logging functions&#39;,</span>
<span class="gd">-    &#39;logging-format-interpolation&#39;,</span>
<span class="gd">-    &#39;Used when a logging statement has a call form of &quot;logging.&lt;logging method&gt;(format_string.format(format_args...))&quot;. Use another type of string formatting instead. You can use % formatting but leave interpolation to the logging function by passing the parameters as arguments. If logging-fstring-interpolation is disabled then you can use fstring formatting. If logging-not-lazy is disabled then you can use % formatting as normal.&#39;</span>
<span class="gd">-    ), &#39;W1203&#39;: (&#39;Use %s formatting in logging functions&#39;,</span>
<span class="gd">-    &#39;logging-fstring-interpolation&#39;,</span>
<span class="gd">-    &#39;Used when a logging statement has a call form of &quot;logging.&lt;logging method&gt;(f&quot;...&quot;)&quot;.Use another type of string formatting instead. You can use % formatting but leave interpolation to the logging function by passing the parameters as arguments. If logging-format-interpolation is disabled then you can use str.format. If logging-not-lazy is disabled then you can use % formatting as normal.&#39;</span>
<span class="gd">-    ), &#39;E1200&#39;: (</span>
<span class="gd">-    &#39;Unsupported logging format character %r (%#02x) at index %d&#39;,</span>
<span class="gd">-    &#39;logging-unsupported-format&#39;,</span>
<span class="gd">-    &#39;Used when an unsupported format character is used in a logging statement format string.&#39;</span>
<span class="gd">-    ), &#39;E1201&#39;: (</span>
<span class="gd">-    &#39;Logging format string ends in middle of conversion specifier&#39;,</span>
<span class="gd">-    &#39;logging-format-truncated&#39;,</span>
<span class="gd">-    &#39;Used when a logging statement format string terminates before the end of a conversion specifier.&#39;</span>
<span class="gd">-    ), &#39;E1205&#39;: (&#39;Too many arguments for logging format string&#39;,</span>
<span class="gd">-    &#39;logging-too-many-args&#39;,</span>
<span class="gd">-    &#39;Used when a logging format string is given too many arguments.&#39;),</span>
<span class="gd">-    &#39;E1206&#39;: (&#39;Not enough arguments for logging format string&#39;,</span>
<span class="gd">-    &#39;logging-too-few-args&#39;,</span>
<span class="gd">-    &#39;Used when a logging format string is given too few arguments.&#39;)}</span>
<span class="gd">-CHECKED_CONVENIENCE_FUNCTIONS = {&#39;critical&#39;, &#39;debug&#39;, &#39;error&#39;, &#39;exception&#39;,</span>
<span class="gd">-    &#39;fatal&#39;, &#39;info&#39;, &#39;warn&#39;, &#39;warning&#39;}</span>
<span class="gd">-MOST_COMMON_FORMATTING = frozenset([&#39;%s&#39;, &#39;%d&#39;, &#39;%f&#39;, &#39;%r&#39;])</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_method_call(func: bases.BoundMethod, types: tuple[str, ...]=(),</span>
<span class="gd">-    methods: tuple[str, ...]=()) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = (</span>
<span class="gi">+    {  # pylint: disable=consider-using-namedtuple-or-dataclass</span>
<span class="gi">+        &quot;W1201&quot;: (</span>
<span class="gi">+            &quot;Use %s formatting in logging functions&quot;,</span>
<span class="gi">+            &quot;logging-not-lazy&quot;,</span>
<span class="gi">+            &quot;Used when a logging statement has a call form of &quot;</span>
<span class="gi">+            &#39;&quot;logging.&lt;logging method&gt;(format_string % (format_args...))&quot;. &#39;</span>
<span class="gi">+            &quot;Use another type of string formatting instead. &quot;</span>
<span class="gi">+            &quot;You can use % formatting but leave interpolation to &quot;</span>
<span class="gi">+            &quot;the logging function by passing the parameters as arguments. &quot;</span>
<span class="gi">+            &quot;If logging-fstring-interpolation is disabled then &quot;</span>
<span class="gi">+            &quot;you can use fstring formatting. &quot;</span>
<span class="gi">+            &quot;If logging-format-interpolation is disabled then &quot;</span>
<span class="gi">+            &quot;you can use str.format.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1202&quot;: (</span>
<span class="gi">+            &quot;Use %s formatting in logging functions&quot;,</span>
<span class="gi">+            &quot;logging-format-interpolation&quot;,</span>
<span class="gi">+            &quot;Used when a logging statement has a call form of &quot;</span>
<span class="gi">+            &#39;&quot;logging.&lt;logging method&gt;(format_string.format(format_args...))&quot;. &#39;</span>
<span class="gi">+            &quot;Use another type of string formatting instead. &quot;</span>
<span class="gi">+            &quot;You can use % formatting but leave interpolation to &quot;</span>
<span class="gi">+            &quot;the logging function by passing the parameters as arguments. &quot;</span>
<span class="gi">+            &quot;If logging-fstring-interpolation is disabled then &quot;</span>
<span class="gi">+            &quot;you can use fstring formatting. &quot;</span>
<span class="gi">+            &quot;If logging-not-lazy is disabled then &quot;</span>
<span class="gi">+            &quot;you can use % formatting as normal.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1203&quot;: (</span>
<span class="gi">+            &quot;Use %s formatting in logging functions&quot;,</span>
<span class="gi">+            &quot;logging-fstring-interpolation&quot;,</span>
<span class="gi">+            &quot;Used when a logging statement has a call form of &quot;</span>
<span class="gi">+            &#39;&quot;logging.&lt;logging method&gt;(f&quot;...&quot;)&quot;.&#39;</span>
<span class="gi">+            &quot;Use another type of string formatting instead. &quot;</span>
<span class="gi">+            &quot;You can use % formatting but leave interpolation to &quot;</span>
<span class="gi">+            &quot;the logging function by passing the parameters as arguments. &quot;</span>
<span class="gi">+            &quot;If logging-format-interpolation is disabled then &quot;</span>
<span class="gi">+            &quot;you can use str.format. &quot;</span>
<span class="gi">+            &quot;If logging-not-lazy is disabled then &quot;</span>
<span class="gi">+            &quot;you can use % formatting as normal.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1200&quot;: (</span>
<span class="gi">+            &quot;Unsupported logging format character %r (%#02x) at index %d&quot;,</span>
<span class="gi">+            &quot;logging-unsupported-format&quot;,</span>
<span class="gi">+            &quot;Used when an unsupported format character is used in a logging &quot;</span>
<span class="gi">+            &quot;statement format string.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1201&quot;: (</span>
<span class="gi">+            &quot;Logging format string ends in middle of conversion specifier&quot;,</span>
<span class="gi">+            &quot;logging-format-truncated&quot;,</span>
<span class="gi">+            &quot;Used when a logging statement format string terminates before &quot;</span>
<span class="gi">+            &quot;the end of a conversion specifier.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1205&quot;: (</span>
<span class="gi">+            &quot;Too many arguments for logging format string&quot;,</span>
<span class="gi">+            &quot;logging-too-many-args&quot;,</span>
<span class="gi">+            &quot;Used when a logging format string is given too many arguments.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1206&quot;: (</span>
<span class="gi">+            &quot;Not enough arguments for logging format string&quot;,</span>
<span class="gi">+            &quot;logging-too-few-args&quot;,</span>
<span class="gi">+            &quot;Used when a logging format string is given too few arguments.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+CHECKED_CONVENIENCE_FUNCTIONS = {</span>
<span class="gi">+    &quot;critical&quot;,</span>
<span class="gi">+    &quot;debug&quot;,</span>
<span class="gi">+    &quot;error&quot;,</span>
<span class="gi">+    &quot;exception&quot;,</span>
<span class="gi">+    &quot;fatal&quot;,</span>
<span class="gi">+    &quot;info&quot;,</span>
<span class="gi">+    &quot;warn&quot;,</span>
<span class="gi">+    &quot;warning&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+MOST_COMMON_FORMATTING = frozenset([&quot;%s&quot;, &quot;%d&quot;, &quot;%f&quot;, &quot;%r&quot;])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_method_call(</span>
<span class="gi">+    func: bases.BoundMethod, types: tuple[str, ...] = (), methods: tuple[str, ...] = ()</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determines if a BoundMethod node represents a method call.

<span class="w"> </span>    Args:
<span class="gu">@@ -52,77 +116,280 @@ def is_method_call(func: bases.BoundMethod, types: tuple[str, ...]=(),</span>
<span class="w"> </span>      true if the node represents a method call for the given type and
<span class="w"> </span>      method names, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(func, astroid.BoundMethod)</span>
<span class="gi">+        and isinstance(func.bound, astroid.Instance)</span>
<span class="gi">+        and (func.bound.name in types if types else True)</span>
<span class="gi">+        and (func.name in methods if methods else True)</span>
<span class="gi">+    )</span>


<span class="w"> </span>class LoggingChecker(checkers.BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks use of the logging module.&quot;&quot;&quot;
<span class="gd">-    name = &#39;logging&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;logging&quot;</span>
<span class="w"> </span>    msgs = MSGS
<span class="gd">-    options = (&#39;logging-modules&#39;, {&#39;default&#39;: (&#39;logging&#39;,), &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;comma separated list&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Logging modules to check that the string format arguments are in logging function parameter format.&#39;</span>
<span class="gd">-        }), (&#39;logging-format-style&#39;, {&#39;default&#39;: &#39;old&#39;, &#39;type&#39;: &#39;choice&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;old (%) or new ({)&gt;&#39;, &#39;choices&#39;: [&#39;old&#39;, &#39;new&#39;],</span>
<span class="gd">-        &#39;help&#39;:</span>
<span class="gd">-        &#39;The type of string formatting that logging methods do. `old` means using % formatting, `new` is for `{}` formatting.&#39;</span>
<span class="gd">-        })</span>
<span class="gd">-</span>
<span class="gd">-    def visit_module(self, _: nodes.Module) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;logging-modules&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (&quot;logging&quot;,),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma separated list&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Logging modules to check that the string format &quot;</span>
<span class="gi">+                &quot;arguments are in logging function parameter format.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;logging-format-style&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;old&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;choice&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;old (%) or new ({)&gt;&quot;,</span>
<span class="gi">+                &quot;choices&quot;: [&quot;old&quot;, &quot;new&quot;],</span>
<span class="gi">+                &quot;help&quot;: &quot;The type of string formatting that logging methods do. &quot;</span>
<span class="gi">+                &quot;`old` means using % formatting, `new` is for `{}` formatting.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_module(self, _: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Clears any state left in this checker from last module checked.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # The code being checked can just as easily &quot;import logging as foo&quot;,</span>
<span class="gi">+        # so it is necessary to process the imports and store in this field</span>
<span class="gi">+        # what name the logging module is actually given.</span>
<span class="gi">+        self._logging_names: set[str] = set()</span>
<span class="gi">+        logging_mods = self.linter.config.logging_modules</span>
<span class="gi">+</span>
<span class="gi">+        self._format_style = self.linter.config.logging_format_style</span>

<span class="gd">-    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:</span>
<span class="gi">+        self._logging_modules = set(logging_mods)</span>
<span class="gi">+        self._from_imports = {}</span>
<span class="gi">+        for logging_mod in logging_mods:</span>
<span class="gi">+            parts = logging_mod.rsplit(&quot;.&quot;, 1)</span>
<span class="gi">+            if len(parts) &gt; 1:</span>
<span class="gi">+                self._from_imports[parts[0]] = parts[1]</span>
<span class="gi">+</span>
<span class="gi">+    def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks to see if a module uses a non-Python logging module.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            logging_name = self._from_imports[node.modname]</span>
<span class="gi">+            for module, as_name in node.names:</span>
<span class="gi">+                if module == logging_name:</span>
<span class="gi">+                    self._logging_names.add(as_name or module)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>

<span class="gd">-    def visit_import(self, node: nodes.Import) -&gt;None:</span>
<span class="gi">+    def visit_import(self, node: nodes.Import) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks to see if this module uses Python&#39;s built-in logging.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for module, as_name in node.names:</span>
<span class="gi">+            if module in self._logging_modules:</span>
<span class="gi">+                self._logging_names.add(as_name or module)</span>

<span class="gd">-    def visit_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks calls to logging methods.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _check_log_method(self, node: nodes.Call, name: str) -&gt;None:</span>
<span class="gi">+        def is_logging_name() -&gt; bool:</span>
<span class="gi">+            return (</span>
<span class="gi">+                isinstance(node.func, nodes.Attribute)</span>
<span class="gi">+                and isinstance(node.func.expr, nodes.Name)</span>
<span class="gi">+                and node.func.expr.name in self._logging_names</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        def is_logger_class() -&gt; tuple[bool, str | None]:</span>
<span class="gi">+            for inferred in infer_all(node.func):</span>
<span class="gi">+                if isinstance(inferred, astroid.BoundMethod):</span>
<span class="gi">+                    parent = inferred._proxied.parent</span>
<span class="gi">+                    if isinstance(parent, nodes.ClassDef) and (</span>
<span class="gi">+                        parent.qname() == &quot;logging.Logger&quot;</span>
<span class="gi">+                        or any(</span>
<span class="gi">+                            ancestor.qname() == &quot;logging.Logger&quot;</span>
<span class="gi">+                            for ancestor in parent.ancestors()</span>
<span class="gi">+                        )</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return True, inferred._proxied.name</span>
<span class="gi">+            return False, None</span>
<span class="gi">+</span>
<span class="gi">+        if is_logging_name():</span>
<span class="gi">+            name = node.func.attrname</span>
<span class="gi">+        else:</span>
<span class="gi">+            result, name = is_logger_class()</span>
<span class="gi">+            if not result:</span>
<span class="gi">+                return</span>
<span class="gi">+        self._check_log_method(node, name)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_log_method(self, node: nodes.Call, name: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks calls to logging.log(level, format, *format_args).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name == &quot;log&quot;:</span>
<span class="gi">+            if node.starargs or node.kwargs or len(node.args) &lt; 2:</span>
<span class="gi">+                # Either a malformed call, star args, or double-star args. Beyond</span>
<span class="gi">+                # the scope of this checker.</span>
<span class="gi">+                return</span>
<span class="gi">+            format_pos: Literal[0, 1] = 1</span>
<span class="gi">+        elif name in CHECKED_CONVENIENCE_FUNCTIONS:</span>
<span class="gi">+            if node.starargs or node.kwargs or not node.args:</span>
<span class="gi">+                # Either no args, star args, or double-star args. Beyond the</span>
<span class="gi">+                # scope of this checker.</span>
<span class="gi">+                return</span>
<span class="gi">+            format_pos = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        format_arg = node.args[format_pos]</span>
<span class="gi">+        if isinstance(format_arg, nodes.BinOp):</span>
<span class="gi">+            binop = format_arg</span>
<span class="gi">+            emit = binop.op == &quot;%&quot;</span>
<span class="gi">+            if binop.op == &quot;+&quot; and not self._is_node_explicit_str_concatenation(binop):</span>
<span class="gi">+                total_number_of_strings = sum(</span>
<span class="gi">+                    1</span>
<span class="gi">+                    for operand in (binop.left, binop.right)</span>
<span class="gi">+                    if self._is_operand_literal_str(utils.safe_infer(operand))</span>
<span class="gi">+                )</span>
<span class="gi">+                emit = total_number_of_strings &gt; 0</span>
<span class="gi">+            if emit:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;logging-not-lazy&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(self._helper_string(node),),</span>
<span class="gi">+                )</span>
<span class="gi">+        elif isinstance(format_arg, nodes.Call):</span>
<span class="gi">+            self._check_call_func(format_arg)</span>
<span class="gi">+        elif isinstance(format_arg, nodes.Const):</span>
<span class="gi">+            self._check_format_string(node, format_pos)</span>
<span class="gi">+        elif isinstance(format_arg, nodes.JoinedStr):</span>
<span class="gi">+            if str_formatting_in_f_string(format_arg):</span>
<span class="gi">+                return</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;logging-fstring-interpolation&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(self._helper_string(node),),</span>
<span class="gi">+            )</span>

<span class="gd">-    def _helper_string(self, node: nodes.Call) -&gt;str:</span>
<span class="gi">+    def _helper_string(self, node: nodes.Call) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a string that lists the valid types of formatting for this node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        valid_types = [&quot;lazy %&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if not self.linter.is_message_enabled(</span>
<span class="gi">+            &quot;logging-fstring-formatting&quot;, node.fromlineno</span>
<span class="gi">+        ):</span>
<span class="gi">+            valid_types.append(&quot;fstring&quot;)</span>
<span class="gi">+        if not self.linter.is_message_enabled(</span>
<span class="gi">+            &quot;logging-format-interpolation&quot;, node.fromlineno</span>
<span class="gi">+        ):</span>
<span class="gi">+            valid_types.append(&quot;.format()&quot;)</span>
<span class="gi">+        if not self.linter.is_message_enabled(&quot;logging-not-lazy&quot;, node.fromlineno):</span>
<span class="gi">+            valid_types.append(&quot;%&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return &quot; or &quot;.join(valid_types)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_operand_literal_str(operand: (InferenceResult | None)) -&gt;bool:</span>
<span class="gi">+    def _is_operand_literal_str(operand: InferenceResult | None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if the operand in argument is a literal string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return isinstance(operand, nodes.Const) and operand.name == &quot;str&quot;</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_node_explicit_str_concatenation(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    def _is_node_explicit_str_concatenation(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if the node represents an explicitly concatenated string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node, nodes.BinOp):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return (</span>
<span class="gi">+            LoggingChecker._is_operand_literal_str(node.left)</span>
<span class="gi">+            or LoggingChecker._is_node_explicit_str_concatenation(node.left)</span>
<span class="gi">+        ) and (</span>
<span class="gi">+            LoggingChecker._is_operand_literal_str(node.right)</span>
<span class="gi">+            or LoggingChecker._is_node_explicit_str_concatenation(node.right)</span>
<span class="gi">+        )</span>

<span class="gd">-    def _check_call_func(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    def _check_call_func(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks that function call is not format_string.format().&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        func = utils.safe_infer(node.func)</span>
<span class="gi">+        types = (&quot;str&quot;, &quot;unicode&quot;)</span>
<span class="gi">+        methods = (&quot;format&quot;,)</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(func, astroid.BoundMethod)</span>
<span class="gi">+            and is_method_call(func, types, methods)</span>
<span class="gi">+            and not is_complex_format_str(func.bound)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;logging-format-interpolation&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(self._helper_string(node),),</span>
<span class="gi">+            )</span>

<span class="gd">-    def _check_format_string(self, node: nodes.Call, format_arg: Literal[0, 1]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _check_format_string(self, node: nodes.Call, format_arg: Literal[0, 1]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks that format string tokens match the supplied arguments.

<span class="w"> </span>        Args:
<span class="w"> </span>          node: AST node to be checked.
<span class="w"> </span>          format_arg: Index of the format string in the node arguments.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        num_args = _count_supplied_tokens(node.args[format_arg + 1 :])</span>
<span class="gi">+        if not num_args:</span>
<span class="gi">+            # If no args were supplied the string is not interpolated and can contain</span>
<span class="gi">+            # formatting characters - it&#39;s used verbatim. Don&#39;t check any further.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        format_string = node.args[format_arg].value</span>
<span class="gi">+        required_num_args = 0</span>
<span class="gi">+        if isinstance(format_string, bytes):</span>
<span class="gi">+            format_string = format_string.decode()</span>
<span class="gi">+        if isinstance(format_string, str):</span>
<span class="gi">+            try:</span>
<span class="gi">+                if self._format_style == &quot;old&quot;:</span>
<span class="gi">+                    keyword_args, required_num_args, _, _ = utils.parse_format_string(</span>
<span class="gi">+                        format_string</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if keyword_args:</span>
<span class="gi">+                        # Keyword checking on logging strings is complicated by</span>
<span class="gi">+                        # special keywords - out of scope.</span>
<span class="gi">+                        return</span>
<span class="gi">+                elif self._format_style == &quot;new&quot;:</span>
<span class="gi">+                    (</span>
<span class="gi">+                        keyword_arguments,</span>
<span class="gi">+                        implicit_pos_args,</span>
<span class="gi">+                        explicit_pos_args,</span>
<span class="gi">+                    ) = utils.parse_format_method_string(format_string)</span>

<span class="gi">+                    keyword_args_cnt = len(</span>
<span class="gi">+                        {k for k, _ in keyword_arguments if not isinstance(k, int)}</span>
<span class="gi">+                    )</span>
<span class="gi">+                    required_num_args = (</span>
<span class="gi">+                        keyword_args_cnt + implicit_pos_args + explicit_pos_args</span>
<span class="gi">+                    )</span>
<span class="gi">+            except utils.UnsupportedFormatCharacter as ex:</span>
<span class="gi">+                char = format_string[ex.index]</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;logging-unsupported-format&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(char, ord(char), ex.index),</span>
<span class="gi">+                )</span>
<span class="gi">+                return</span>
<span class="gi">+            except utils.IncompleteFormatString:</span>
<span class="gi">+                self.add_message(&quot;logging-format-truncated&quot;, node=node)</span>
<span class="gi">+                return</span>
<span class="gi">+        if num_args &gt; required_num_args:</span>
<span class="gi">+            self.add_message(&quot;logging-too-many-args&quot;, node=node)</span>
<span class="gi">+        elif num_args &lt; required_num_args:</span>
<span class="gi">+            self.add_message(&quot;logging-too-few-args&quot;, node=node)</span>

<span class="gd">-def is_complex_format_str(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def is_complex_format_str(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return whether the node represents a string with complex formatting specs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    inferred = utils.safe_infer(node)</span>
<span class="gi">+    if inferred is None or not (</span>
<span class="gi">+        isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return True</span>
<span class="gi">+    try:</span>
<span class="gi">+        parsed = list(string.Formatter().parse(inferred.value))</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # This format string is invalid</span>
<span class="gi">+        return False</span>
<span class="gi">+    return any(format_spec for (_, _, format_spec, _) in parsed)</span>


<span class="gd">-def _count_supplied_tokens(args: list[nodes.NodeNG]) -&gt;int:</span>
<span class="gi">+def _count_supplied_tokens(args: list[nodes.NodeNG]) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Counts the number of tokens in an args list.

<span class="w"> </span>    The Python log functions allow for special keyword arguments: func,
<span class="gu">@@ -135,12 +402,21 @@ def _count_supplied_tokens(args: list[nodes.NodeNG]) -&gt;int:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>      Number of AST nodes that aren&#39;t keywords.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sum(1 for arg in args if not isinstance(arg, nodes.Keyword))</span>


<span class="gd">-def str_formatting_in_f_string(node: nodes.JoinedStr) -&gt;bool:</span>
<span class="gi">+def str_formatting_in_f_string(node: nodes.JoinedStr) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine whether the node represents an f-string with string formatting.

<span class="w"> </span>    For example: `f&#39;Hello %s&#39;`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Check &quot;%&quot; presence first for performance.</span>
<span class="gi">+    return any(</span>
<span class="gi">+        &quot;%&quot; in val.value and any(x in val.value for x in MOST_COMMON_FORMATTING)</span>
<span class="gi">+        for val in node.values</span>
<span class="gi">+        if isinstance(val, nodes.Const)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(LoggingChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/method_args.py b/pylint/checkers/method_args.py</span>
<span class="gh">index b9264d586..59083fa25 100644</span>
<span class="gd">--- a/pylint/checkers/method_args.py</span>
<span class="gi">+++ b/pylint/checkers/method_args.py</span>
<span class="gu">@@ -1,10 +1,19 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Variables checkers for Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import arguments, bases, nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="w"> </span>from pylint.interfaces import INFERENCE
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -16,35 +25,106 @@ class MethodArgsChecker(BaseChecker):</span>
<span class="w"> </span>    * missing-timeout
<span class="w"> </span>    * positional-only-arguments-expected
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;method_args&#39;</span>
<span class="gd">-    msgs = {&#39;W3101&#39;: (</span>
<span class="gd">-        &quot;Missing timeout argument for method &#39;%s&#39; can cause your program to hang indefinitely&quot;</span>
<span class="gd">-        , &#39;missing-timeout&#39;,</span>
<span class="gd">-        &quot;Used when a method needs a &#39;timeout&#39; parameter in order to avoid waiting for a long time. If no timeout is specified explicitly the default value is used. For example for &#39;requests&#39; the program will never time out (i.e. hang indefinitely).&quot;</span>
<span class="gd">-        ), &#39;E3102&#39;: (</span>
<span class="gd">-        &#39;`%s()` got some positional-only arguments passed as keyword arguments: %s&#39;</span>
<span class="gd">-        , &#39;positional-only-arguments-expected&#39;,</span>
<span class="gd">-        &#39;Emitted when positional-only arguments have been passed as keyword arguments. Remove the keywords for the affected arguments in the function call.&#39;</span>
<span class="gd">-        , {&#39;minversion&#39;: (3, 8)})}</span>
<span class="gd">-    options = (&#39;timeout-methods&#39;, {&#39;default&#39;: (&#39;requests.api.delete&#39;,</span>
<span class="gd">-        &#39;requests.api.get&#39;, &#39;requests.api.head&#39;, &#39;requests.api.options&#39;,</span>
<span class="gd">-        &#39;requests.api.patch&#39;, &#39;requests.api.post&#39;, &#39;requests.api.put&#39;,</span>
<span class="gd">-        &#39;requests.api.request&#39;), &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;comma separated list&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &quot;List of qualified names (i.e., library.method) which require a timeout parameter e.g. &#39;requests.api.get,requests.api.post&#39;&quot;</span>
<span class="gd">-        }),</span>
<span class="gd">-</span>
<span class="gd">-    def _check_missing_timeout(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;method_args&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W3101&quot;: (</span>
<span class="gi">+            &quot;Missing timeout argument for method &#39;%s&#39; can cause your program to hang indefinitely&quot;,</span>
<span class="gi">+            &quot;missing-timeout&quot;,</span>
<span class="gi">+            &quot;Used when a method needs a &#39;timeout&#39; parameter in order to avoid waiting &quot;</span>
<span class="gi">+            &quot;for a long time. If no timeout is specified explicitly the default value &quot;</span>
<span class="gi">+            &quot;is used. For example for &#39;requests&#39; the program will never time out &quot;</span>
<span class="gi">+            &quot;(i.e. hang indefinitely).&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E3102&quot;: (</span>
<span class="gi">+            &quot;`%s()` got some positional-only arguments passed as keyword arguments: %s&quot;,</span>
<span class="gi">+            &quot;positional-only-arguments-expected&quot;,</span>
<span class="gi">+            &quot;Emitted when positional-only arguments have been passed as keyword arguments. &quot;</span>
<span class="gi">+            &quot;Remove the keywords for the affected arguments in the function call.&quot;,</span>
<span class="gi">+            {&quot;minversion&quot;: (3, 8)},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;timeout-methods&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (</span>
<span class="gi">+                    &quot;requests.api.delete&quot;,</span>
<span class="gi">+                    &quot;requests.api.get&quot;,</span>
<span class="gi">+                    &quot;requests.api.head&quot;,</span>
<span class="gi">+                    &quot;requests.api.options&quot;,</span>
<span class="gi">+                    &quot;requests.api.patch&quot;,</span>
<span class="gi">+                    &quot;requests.api.post&quot;,</span>
<span class="gi">+                    &quot;requests.api.put&quot;,</span>
<span class="gi">+                    &quot;requests.api.request&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma separated list&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of qualified names (i.e., library.method) which require a timeout parameter &quot;</span>
<span class="gi">+                &quot;e.g. &#39;requests.api.get,requests.api.post&#39;&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;missing-timeout&quot;, &quot;positional-only-arguments-expected&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        self._check_missing_timeout(node)</span>
<span class="gi">+        self._check_positional_only_arguments_expected(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_missing_timeout(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the call needs a timeout parameter based on package.func_name
<span class="w"> </span>        configured in config.timeout_methods.

<span class="w"> </span>        Package uses inferred node in order to know the package imported.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred = utils.safe_infer(node.func)</span>
<span class="gi">+        call_site = arguments.CallSite.from_call(node)</span>
<span class="gi">+        if (</span>
<span class="gi">+            inferred</span>
<span class="gi">+            and not call_site.has_invalid_keywords()</span>
<span class="gi">+            and isinstance(</span>
<span class="gi">+                inferred, (nodes.FunctionDef, nodes.ClassDef, bases.UnboundMethod)</span>
<span class="gi">+            )</span>
<span class="gi">+            and inferred.qname() in self.linter.config.timeout_methods</span>
<span class="gi">+        ):</span>
<span class="gi">+            keyword_arguments = [keyword.arg for keyword in node.keywords]</span>
<span class="gi">+            keyword_arguments.extend(call_site.keyword_arguments)</span>
<span class="gi">+            if &quot;timeout&quot; not in keyword_arguments:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;missing-timeout&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(node.func.as_string(),),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>

<span class="gd">-    def _check_positional_only_arguments_expected(self, node: nodes.Call</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _check_positional_only_arguments_expected(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if positional only arguments have been passed as keyword arguments by
<span class="w"> </span>        inspecting its method definition.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred_func = utils.safe_infer(node.func)</span>
<span class="gi">+        while isinstance(inferred_func, (astroid.BoundMethod, astroid.UnboundMethod)):</span>
<span class="gi">+            inferred_func = inferred_func._proxied</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(inferred_func, (nodes.FunctionDef))</span>
<span class="gi">+            and inferred_func.args.posonlyargs</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        if inferred_func.args.kwarg:</span>
<span class="gi">+            return</span>
<span class="gi">+        pos_args = [a.name for a in inferred_func.args.posonlyargs]</span>
<span class="gi">+        kws = [k.arg for k in node.keywords if k.arg in pos_args]</span>
<span class="gi">+        if not kws:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;positional-only-arguments-expected&quot;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=(node.func.as_string(), &quot;, &quot;.join(f&quot;&#39;{k}&#39;&quot; for k in kws)),</span>
<span class="gi">+            confidence=INFERENCE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(MethodArgsChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/misc.py b/pylint/checkers/misc.py</span>
<span class="gh">index c7fce6781..78c21d0c5 100644</span>
<span class="gd">--- a/pylint/checkers/misc.py</span>
<span class="gi">+++ b/pylint/checkers/misc.py</span>
<span class="gu">@@ -1,26 +1,53 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Check source code is ascii only or has an encoding declaration (PEP 263).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import tokenize
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseRawFileChecker, BaseTokenChecker
<span class="w"> </span>from pylint.typing import ManagedMessage
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class ByIdManagedMessagesChecker(BaseRawFileChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks for messages that are enabled or disabled by id instead of symbol.&quot;&quot;&quot;
<span class="gd">-    name = &#39;miscellaneous&#39;</span>
<span class="gd">-    msgs = {&#39;I0023&#39;: (&#39;%s&#39;, &#39;use-symbolic-message-instead&#39;,</span>
<span class="gd">-        &#39;Used when a message is enabled or disabled by id.&#39;, {</span>
<span class="gd">-        &#39;default_enabled&#39;: False})}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;miscellaneous&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;I0023&quot;: (</span>
<span class="gi">+            &quot;%s&quot;,</span>
<span class="gi">+            &quot;use-symbolic-message-instead&quot;,</span>
<span class="gi">+            &quot;Used when a message is enabled or disabled by id.&quot;,</span>
<span class="gi">+            {&quot;default_enabled&quot;: False},</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="w"> </span>    options = ()

<span class="gd">-    def process_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+    def _clear_by_id_managed_msgs(self) -&gt; None:</span>
<span class="gi">+        self.linter._by_id_managed_msgs.clear()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_by_id_managed_msgs(self) -&gt; list[ManagedMessage]:</span>
<span class="gi">+        return self.linter._by_id_managed_msgs</span>
<span class="gi">+</span>
<span class="gi">+    def process_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Inspect the source file to find messages activated or deactivated by id.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        managed_msgs = self._get_by_id_managed_msgs()</span>
<span class="gi">+        for mod_name, msgid, symbol, lineno, is_disabled in managed_msgs:</span>
<span class="gi">+            if mod_name == node.name:</span>
<span class="gi">+                verb = &quot;disable&quot; if is_disabled else &quot;enable&quot;</span>
<span class="gi">+                txt = f&quot;&#39;{msgid}&#39; is cryptic: use &#39;# pylint: {verb}={symbol}&#39; instead&quot;</span>
<span class="gi">+                self.add_message(&quot;use-symbolic-message-instead&quot;, line=lineno, args=txt)</span>
<span class="gi">+        self._clear_by_id_managed_msgs()</span>


<span class="w"> </span>class EncodingChecker(BaseTokenChecker, BaseRawFileChecker):
<span class="gu">@@ -30,21 +57,94 @@ class EncodingChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>    * warning notes in the code like FIXME, XXX
<span class="w"> </span>    * encoding issues.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;miscellaneous&#39;</span>
<span class="gd">-    msgs = {&#39;W0511&#39;: (&#39;%s&#39;, &#39;fixme&#39;,</span>
<span class="gd">-        &#39;Used when a warning note as FIXME or XXX is detected.&#39;)}</span>
<span class="gd">-    options = (&#39;notes&#39;, {&#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;comma separated values&gt;&#39;, &#39;default&#39;: (&#39;FIXME&#39;, &#39;XXX&#39;, &#39;TODO&#39;),</span>
<span class="gd">-        &#39;help&#39;:</span>
<span class="gd">-        &#39;List of note tags to take in consideration, separated by a comma.&#39;}</span>
<span class="gd">-        ), (&#39;notes-rgx&#39;, {&#39;type&#39;: &#39;string&#39;, &#39;metavar&#39;: &#39;&lt;regexp&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Regular expression of note tags to take in consideration.&#39;,</span>
<span class="gd">-        &#39;default&#39;: &#39;&#39;})</span>
<span class="gd">-</span>
<span class="gd">-    def process_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;miscellaneous&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W0511&quot;: (</span>
<span class="gi">+            &quot;%s&quot;,</span>
<span class="gi">+            &quot;fixme&quot;,</span>
<span class="gi">+            &quot;Used when a warning note as FIXME or XXX is detected.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;notes&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma separated values&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: (&quot;FIXME&quot;, &quot;XXX&quot;, &quot;TODO&quot;),</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;List of note tags to take in consideration, &quot;</span>
<span class="gi">+                    &quot;separated by a comma.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;notes-rgx&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;regexp&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Regular expression of note tags to take in consideration.&quot;,</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        super().open()</span>
<span class="gi">+</span>
<span class="gi">+        notes = &quot;|&quot;.join(re.escape(note) for note in self.linter.config.notes)</span>
<span class="gi">+        if self.linter.config.notes_rgx:</span>
<span class="gi">+            regex_string = rf&quot;#\s*({notes}|{self.linter.config.notes_rgx})(?=(:|\s|\Z))&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            regex_string = rf&quot;#\s*({notes})(?=(:|\s|\Z))&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self._fixme_pattern = re.compile(regex_string, re.I)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_encoding(</span>
<span class="gi">+        self, lineno: int, line: bytes, file_encoding: str</span>
<span class="gi">+    ) -&gt; str | None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return line.decode(file_encoding)</span>
<span class="gi">+        except UnicodeDecodeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        except LookupError:</span>
<span class="gi">+            if (</span>
<span class="gi">+                line.startswith(b&quot;#&quot;)</span>
<span class="gi">+                and &quot;coding&quot; in str(line)</span>
<span class="gi">+                and file_encoding in str(line)</span>
<span class="gi">+            ):</span>
<span class="gi">+                msg = f&quot;Cannot decode using encoding &#39;{file_encoding}&#39;, bad encoding&quot;</span>
<span class="gi">+                self.add_message(&quot;syntax-error&quot;, line=lineno, args=msg)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def process_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Inspect the source file to find encoding problem.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        encoding = node.file_encoding if node.file_encoding else &quot;ascii&quot;</span>
<span class="gi">+</span>
<span class="gi">+        with node.stream() as stream:</span>
<span class="gi">+            for lineno, line in enumerate(stream):</span>
<span class="gi">+                self._check_encoding(lineno + 1, line, encoding)</span>

<span class="gd">-    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt;None:</span>
<span class="gi">+    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Inspect the source to find fixme problems.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.linter.config.notes:</span>
<span class="gi">+            return</span>
<span class="gi">+        for token_info in tokens:</span>
<span class="gi">+            if token_info.type != tokenize.COMMENT:</span>
<span class="gi">+                continue</span>
<span class="gi">+            comment_text = token_info.string[1:].lstrip()  # trim &#39;#&#39; and white-spaces</span>
<span class="gi">+            if self._fixme_pattern.search(&quot;#&quot; + comment_text.lower()):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;fixme&quot;,</span>
<span class="gi">+                    col_offset=token_info.start[1] + 1,</span>
<span class="gi">+                    args=comment_text,</span>
<span class="gi">+                    line=token_info.start[0],</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(EncodingChecker(linter))</span>
<span class="gi">+    linter.register_checker(ByIdManagedMessagesChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/modified_iterating_checker.py b/pylint/checkers/modified_iterating_checker.py</span>
<span class="gh">index a2395f574..be8d967ab 100644</span>
<span class="gd">--- a/pylint/checkers/modified_iterating_checker.py</span>
<span class="gi">+++ b/pylint/checkers/modified_iterating_checker.py</span>
<span class="gu">@@ -1,12 +1,22 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers, interfaces
<span class="w"> </span>from pylint.checkers import utils
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-_LIST_MODIFIER_METHODS = {&#39;append&#39;, &#39;remove&#39;}</span>
<span class="gd">-_SET_MODIFIER_METHODS = {&#39;add&#39;, &#39;clear&#39;, &#39;discard&#39;, &#39;pop&#39;, &#39;remove&#39;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_LIST_MODIFIER_METHODS = {&quot;append&quot;, &quot;remove&quot;}</span>
<span class="gi">+_SET_MODIFIER_METHODS = {&quot;add&quot;, &quot;clear&quot;, &quot;discard&quot;, &quot;pop&quot;, &quot;remove&quot;}</span>


<span class="w"> </span>class ModifiedIterationChecker(checkers.BaseChecker):
<span class="gu">@@ -14,23 +24,177 @@ class ModifiedIterationChecker(checkers.BaseChecker):</span>

<span class="w"> </span>    Currently supports `for` loops for Sets, Dictionaries and Lists.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;modified_iteration&#39;</span>
<span class="gd">-    msgs = {&#39;W4701&#39;: (</span>
<span class="gd">-        &quot;Iterated list &#39;%s&#39; is being modified inside for loop body, consider iterating through a copy of it instead.&quot;</span>
<span class="gd">-        , &#39;modified-iterating-list&#39;,</span>
<span class="gd">-        &#39;Emitted when items are added or removed to a list being iterated through. Doing so can result in unexpected behaviour, that is why it is preferred to use a copy of the list.&#39;</span>
<span class="gd">-        ), &#39;E4702&#39;: (</span>
<span class="gd">-        &quot;Iterated dict &#39;%s&#39; is being modified inside for loop body, iterate through a copy of it instead.&quot;</span>
<span class="gd">-        , &#39;modified-iterating-dict&#39;,</span>
<span class="gd">-        &#39;Emitted when items are added or removed to a dict being iterated through. Doing so raises a RuntimeError.&#39;</span>
<span class="gd">-        ), &#39;E4703&#39;: (</span>
<span class="gd">-        &quot;Iterated set &#39;%s&#39; is being modified inside for loop body, iterate through a copy of it instead.&quot;</span>
<span class="gd">-        , &#39;modified-iterating-set&#39;,</span>
<span class="gd">-        &#39;Emitted when items are added or removed to a set being iterated through. Doing so raises a RuntimeError.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;modified_iteration&quot;</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W4701&quot;: (</span>
<span class="gi">+            &quot;Iterated list &#39;%s&#39; is being modified inside for loop body, consider iterating through a copy of it &quot;</span>
<span class="gi">+            &quot;instead.&quot;,</span>
<span class="gi">+            &quot;modified-iterating-list&quot;,</span>
<span class="gi">+            &quot;Emitted when items are added or removed to a list being iterated through. &quot;</span>
<span class="gi">+            &quot;Doing so can result in unexpected behaviour, that is why it is preferred to use a copy of the list.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E4702&quot;: (</span>
<span class="gi">+            &quot;Iterated dict &#39;%s&#39; is being modified inside for loop body, iterate through a copy of it instead.&quot;,</span>
<span class="gi">+            &quot;modified-iterating-dict&quot;,</span>
<span class="gi">+            &quot;Emitted when items are added or removed to a dict being iterated through. &quot;</span>
<span class="gi">+            &quot;Doing so raises a RuntimeError.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E4703&quot;: (</span>
<span class="gi">+            &quot;Iterated set &#39;%s&#39; is being modified inside for loop body, iterate through a copy of it instead.&quot;,</span>
<span class="gi">+            &quot;modified-iterating-set&quot;,</span>
<span class="gi">+            &quot;Emitted when items are added or removed to a set being iterated through. &quot;</span>
<span class="gi">+            &quot;Doing so raises a RuntimeError.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    options = ()

<span class="gd">-    def _modified_iterating_check_on_node_and_children(self, body_node:</span>
<span class="gd">-        nodes.NodeNG, iter_obj: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;modified-iterating-list&quot;, &quot;modified-iterating-dict&quot;, &quot;modified-iterating-set&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        iter_obj = node.iter</span>
<span class="gi">+        for body_node in node.body:</span>
<span class="gi">+            self._modified_iterating_check_on_node_and_children(body_node, iter_obj)</span>
<span class="gi">+</span>
<span class="gi">+    def _modified_iterating_check_on_node_and_children(</span>
<span class="gi">+        self, body_node: nodes.NodeNG, iter_obj: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;See if node or any of its children raises modified iterating messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._modified_iterating_check(body_node, iter_obj)</span>
<span class="gi">+        for child in body_node.get_children():</span>
<span class="gi">+            self._modified_iterating_check_on_node_and_children(child, iter_obj)</span>
<span class="gi">+</span>
<span class="gi">+    def _modified_iterating_check(</span>
<span class="gi">+        self, node: nodes.NodeNG, iter_obj: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        msg_id = None</span>
<span class="gi">+        if isinstance(node, nodes.Delete) and any(</span>
<span class="gi">+            self._deleted_iteration_target_cond(t, iter_obj) for t in node.targets</span>
<span class="gi">+        ):</span>
<span class="gi">+            inferred = utils.safe_infer(iter_obj)</span>
<span class="gi">+            if isinstance(inferred, nodes.List):</span>
<span class="gi">+                msg_id = &quot;modified-iterating-list&quot;</span>
<span class="gi">+            elif isinstance(inferred, nodes.Dict):</span>
<span class="gi">+                msg_id = &quot;modified-iterating-dict&quot;</span>
<span class="gi">+            elif isinstance(inferred, nodes.Set):</span>
<span class="gi">+                msg_id = &quot;modified-iterating-set&quot;</span>
<span class="gi">+        elif not isinstance(iter_obj, (nodes.Name, nodes.Attribute)):</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif self._modified_iterating_list_cond(node, iter_obj):</span>
<span class="gi">+            msg_id = &quot;modified-iterating-list&quot;</span>
<span class="gi">+        elif self._modified_iterating_dict_cond(node, iter_obj):</span>
<span class="gi">+            msg_id = &quot;modified-iterating-dict&quot;</span>
<span class="gi">+        elif self._modified_iterating_set_cond(node, iter_obj):</span>
<span class="gi">+            msg_id = &quot;modified-iterating-set&quot;</span>
<span class="gi">+        if msg_id:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                msg_id,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(iter_obj.repr_name(),),</span>
<span class="gi">+                confidence=interfaces.INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_node_expr_that_calls_attribute_name(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(node, nodes.Expr)</span>
<span class="gi">+            and isinstance(node.value, nodes.Call)</span>
<span class="gi">+            and isinstance(node.value.func, nodes.Attribute)</span>
<span class="gi">+            and isinstance(node.value.func.expr, nodes.Name)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _common_cond_list_set(</span>
<span class="gi">+        node: nodes.Expr,</span>
<span class="gi">+        iter_obj: nodes.Name | nodes.Attribute,</span>
<span class="gi">+        infer_val: nodes.List | nodes.Set,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        iter_obj_name = (</span>
<span class="gi">+            iter_obj.attrname</span>
<span class="gi">+            if isinstance(iter_obj, nodes.Attribute)</span>
<span class="gi">+            else iter_obj.name</span>
<span class="gi">+        )</span>
<span class="gi">+        return (infer_val == utils.safe_infer(iter_obj)) and (  # type: ignore[no-any-return]</span>
<span class="gi">+            node.value.func.expr.name == iter_obj_name</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_node_assigns_subscript_name(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        return isinstance(node, nodes.Assign) and (</span>
<span class="gi">+            isinstance(node.targets[0], nodes.Subscript)</span>
<span class="gi">+            and (isinstance(node.targets[0].value, nodes.Name))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _modified_iterating_list_cond(</span>
<span class="gi">+        self, node: nodes.NodeNG, iter_obj: nodes.Name | nodes.Attribute</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        if not self._is_node_expr_that_calls_attribute_name(node):</span>
<span class="gi">+            return False</span>
<span class="gi">+        infer_val = utils.safe_infer(node.value.func.expr)</span>
<span class="gi">+        if not isinstance(infer_val, nodes.List):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return (</span>
<span class="gi">+            self._common_cond_list_set(node, iter_obj, infer_val)</span>
<span class="gi">+            and node.value.func.attrname in _LIST_MODIFIER_METHODS</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _modified_iterating_dict_cond(</span>
<span class="gi">+        self, node: nodes.NodeNG, iter_obj: nodes.Name | nodes.Attribute</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        if not self._is_node_assigns_subscript_name(node):</span>
<span class="gi">+            return False</span>
<span class="gi">+        # Do not emit when merely updating the same key being iterated</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(iter_obj, nodes.Name)</span>
<span class="gi">+            and iter_obj.name == node.targets[0].value.name</span>
<span class="gi">+            and isinstance(iter_obj.parent.target, nodes.AssignName)</span>
<span class="gi">+            and isinstance(node.targets[0].slice, nodes.Name)</span>
<span class="gi">+            and iter_obj.parent.target.name == node.targets[0].slice.name</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+        infer_val = utils.safe_infer(node.targets[0].value)</span>
<span class="gi">+        if not isinstance(infer_val, nodes.Dict):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if infer_val != utils.safe_infer(iter_obj):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if isinstance(iter_obj, nodes.Attribute):</span>
<span class="gi">+            iter_obj_name = iter_obj.attrname</span>
<span class="gi">+        else:</span>
<span class="gi">+            iter_obj_name = iter_obj.name</span>
<span class="gi">+        return node.targets[0].value.name == iter_obj_name  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    def _modified_iterating_set_cond(</span>
<span class="gi">+        self, node: nodes.NodeNG, iter_obj: nodes.Name | nodes.Attribute</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        if not self._is_node_expr_that_calls_attribute_name(node):</span>
<span class="gi">+            return False</span>
<span class="gi">+        infer_val = utils.safe_infer(node.value.func.expr)</span>
<span class="gi">+        if not isinstance(infer_val, nodes.Set):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return (</span>
<span class="gi">+            self._common_cond_list_set(node, iter_obj, infer_val)</span>
<span class="gi">+            and node.value.func.attrname in _SET_MODIFIER_METHODS</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _deleted_iteration_target_cond(</span>
<span class="gi">+        self, node: nodes.DelName, iter_obj: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        if not isinstance(node, nodes.DelName):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not isinstance(iter_obj.parent, nodes.For):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not isinstance(</span>
<span class="gi">+            iter_obj.parent.target, (nodes.AssignName, nodes.BaseContainer)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return any(</span>
<span class="gi">+            t == node.name</span>
<span class="gi">+            for t in utils.find_assigned_names_recursive(iter_obj.parent.target)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(ModifiedIterationChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/nested_min_max.py b/pylint/checkers/nested_min_max.py</span>
<span class="gh">index 043bee27a..c8231fe7d 100644</span>
<span class="gd">--- a/pylint/checkers/nested_min_max.py</span>
<span class="gi">+++ b/pylint/checkers/nested_min_max.py</span>
<span class="gu">@@ -1,17 +1,31 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Check for use of nested min/max functions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import copy
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes, objects
<span class="w"> </span>from astroid.const import Context
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages, safe_infer
<span class="w"> </span>from pylint.constants import PY39_PLUS
<span class="w"> </span>from pylint.interfaces import INFERENCE
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-DICT_TYPES = (objects.DictValues, objects.DictKeys, objects.DictItems,</span>
<span class="gd">-    nodes.node_classes.Dict)</span>
<span class="gi">+</span>
<span class="gi">+DICT_TYPES = (</span>
<span class="gi">+    objects.DictValues,</span>
<span class="gi">+    objects.DictKeys,</span>
<span class="gi">+    objects.DictItems,</span>
<span class="gi">+    nodes.node_classes.Dict,</span>
<span class="gi">+)</span>


<span class="w"> </span>class NestedMinMaxChecker(BaseChecker):
<span class="gu">@@ -20,16 +34,135 @@ class NestedMinMaxChecker(BaseChecker):</span>
<span class="w"> </span>    This behaviour is intended as it would slow down the checker to check
<span class="w"> </span>    for nested call with minimal benefits.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    FUNC_NAMES = &#39;builtins.min&#39;, &#39;builtins.max&#39;</span>
<span class="gd">-    name = &#39;nested_min_max&#39;</span>
<span class="gd">-    msgs = {&#39;W3301&#39;: (</span>
<span class="gd">-        &quot;Do not use nested call of &#39;%s&#39;; it&#39;s possible to do &#39;%s&#39; instead&quot;,</span>
<span class="gd">-        &#39;nested-min-max&#39;,</span>
<span class="gd">-        &#39;Nested calls ``min(1, min(2, 3))`` can be rewritten as ``min(1, 2, 3)``.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-</span>
<span class="gd">-    def _is_splattable_expression(self, arg: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+    FUNC_NAMES = (&quot;builtins.min&quot;, &quot;builtins.max&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;nested_min_max&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W3301&quot;: (</span>
<span class="gi">+            &quot;Do not use nested call of &#39;%s&#39;; it&#39;s possible to do &#39;%s&#39; instead&quot;,</span>
<span class="gi">+            &quot;nested-min-max&quot;,</span>
<span class="gi">+            &quot;Nested calls ``min(1, min(2, 3))`` can be rewritten as ``min(1, 2, 3)``.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def is_min_max_call(cls, node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        if not isinstance(node, nodes.Call):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        inferred = safe_infer(node.func)</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(inferred, nodes.FunctionDef)</span>
<span class="gi">+            and inferred.qname() in cls.FUNC_NAMES</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def get_redundant_calls(cls, node: nodes.Call) -&gt; list[nodes.Call]:</span>
<span class="gi">+        return [</span>
<span class="gi">+            arg</span>
<span class="gi">+            for arg in node.args</span>
<span class="gi">+            if (</span>
<span class="gi">+                cls.is_min_max_call(arg)</span>
<span class="gi">+                and arg.func.name == node.func.name</span>
<span class="gi">+                # Nesting is useful for finding the maximum in a matrix.</span>
<span class="gi">+                # Allow: max(max([[1, 2, 3], [4, 5, 6]]))</span>
<span class="gi">+                # Meaning, redundant call only if parent max call has more than 1 arg.</span>
<span class="gi">+                and len(arg.parent.args) &gt; 1</span>
<span class="gi">+            )</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;nested-min-max&quot;)</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if not self.is_min_max_call(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        redundant_calls = self.get_redundant_calls(node)</span>
<span class="gi">+        if not redundant_calls:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        fixed_node = copy.copy(node)</span>
<span class="gi">+        while len(redundant_calls) &gt; 0:</span>
<span class="gi">+            for i, arg in enumerate(fixed_node.args):</span>
<span class="gi">+                # Exclude any calls with generator expressions as there is no</span>
<span class="gi">+                # clear better suggestion for them.</span>
<span class="gi">+                if isinstance(arg, nodes.Call) and any(</span>
<span class="gi">+                    isinstance(a, nodes.GeneratorExp) for a in arg.args</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                if arg in redundant_calls:</span>
<span class="gi">+                    fixed_node.args = (</span>
<span class="gi">+                        fixed_node.args[:i] + arg.args + fixed_node.args[i + 1 :]</span>
<span class="gi">+                    )</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            redundant_calls = self.get_redundant_calls(fixed_node)</span>
<span class="gi">+</span>
<span class="gi">+        for idx, arg in enumerate(fixed_node.args):</span>
<span class="gi">+            if not isinstance(arg, nodes.Const):</span>
<span class="gi">+                if self._is_splattable_expression(arg):</span>
<span class="gi">+                    splat_node = nodes.Starred(</span>
<span class="gi">+                        ctx=Context.Load,</span>
<span class="gi">+                        lineno=arg.lineno,</span>
<span class="gi">+                        col_offset=0,</span>
<span class="gi">+                        parent=nodes.NodeNG(</span>
<span class="gi">+                            lineno=None,</span>
<span class="gi">+                            col_offset=None,</span>
<span class="gi">+                            end_lineno=None,</span>
<span class="gi">+                            end_col_offset=None,</span>
<span class="gi">+                            parent=None,</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        end_lineno=0,</span>
<span class="gi">+                        end_col_offset=0,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    splat_node.value = arg</span>
<span class="gi">+                    fixed_node.args = (</span>
<span class="gi">+                        fixed_node.args[:idx]</span>
<span class="gi">+                        + [splat_node]</span>
<span class="gi">+                        + fixed_node.args[idx + 1 : idx]</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;nested-min-max&quot;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=(node.func.name, fixed_node.as_string()),</span>
<span class="gi">+            confidence=INFERENCE,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _is_splattable_expression(self, arg: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns true if expression under min/max could be converted to splat
<span class="w"> </span>        expression.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Support sequence addition (operator __add__)</span>
<span class="gi">+        if isinstance(arg, nodes.BinOp) and arg.op == &quot;+&quot;:</span>
<span class="gi">+            return self._is_splattable_expression(</span>
<span class="gi">+                arg.left</span>
<span class="gi">+            ) and self._is_splattable_expression(arg.right)</span>
<span class="gi">+        # Support dict merge (operator __or__ in Python 3.9)</span>
<span class="gi">+        if isinstance(arg, nodes.BinOp) and arg.op == &quot;|&quot; and PY39_PLUS:</span>
<span class="gi">+            return self._is_splattable_expression(</span>
<span class="gi">+                arg.left</span>
<span class="gi">+            ) and self._is_splattable_expression(arg.right)</span>
<span class="gi">+</span>
<span class="gi">+        inferred = safe_infer(arg)</span>
<span class="gi">+        if inferred and inferred.pytype() in {&quot;builtins.list&quot;, &quot;builtins.tuple&quot;}:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(</span>
<span class="gi">+            inferred or arg,</span>
<span class="gi">+            (</span>
<span class="gi">+                nodes.List,</span>
<span class="gi">+                nodes.Tuple,</span>
<span class="gi">+                nodes.Set,</span>
<span class="gi">+                nodes.ListComp,</span>
<span class="gi">+                nodes.DictComp,</span>
<span class="gi">+                *DICT_TYPES,</span>
<span class="gi">+            ),</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(NestedMinMaxChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/newstyle.py b/pylint/checkers/newstyle.py</span>
<span class="gh">index c0588ddc5..0c2c559fe 100644</span>
<span class="gd">--- a/pylint/checkers/newstyle.py</span>
<span class="gi">+++ b/pylint/checkers/newstyle.py</span>
<span class="gu">@@ -1,17 +1,35 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Check for new / old style related problems.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="gd">-from pylint.checkers.utils import has_known_bases, node_frame_class, only_required_for_messages</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    has_known_bases,</span>
<span class="gi">+    node_frame_class,</span>
<span class="gi">+    only_required_for_messages,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;E1003&#39;: (</span>
<span class="gd">-    &#39;Bad first argument %r given to super()&#39;, &#39;bad-super-call&#39;,</span>
<span class="gd">-    &#39;Used when another argument than the current class is given as first argument of the super builtin.&#39;</span>
<span class="gd">-    )}</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+    &quot;E1003&quot;: (</span>
<span class="gi">+        &quot;Bad first argument %r given to super()&quot;,</span>
<span class="gi">+        &quot;bad-super-call&quot;,</span>
<span class="gi">+        &quot;Used when another argument than the current class is given as &quot;</span>
<span class="gi">+        &quot;first argument of the super builtin.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+}</span>


<span class="w"> </span>class NewStyleConflictChecker(BaseChecker):
<span class="gu">@@ -21,12 +39,91 @@ class NewStyleConflictChecker(BaseChecker):</span>
<span class="w"> </span>    * use of property, __slots__, super
<span class="w"> </span>    * &quot;super&quot; usage
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;newstyle&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;newstyle&quot;</span>
<span class="gi">+    # messages</span>
<span class="w"> </span>    msgs = MSGS
<span class="gi">+    # configuration options</span>
<span class="w"> </span>    options = ()

<span class="gd">-    @only_required_for_messages(&#39;bad-super-call&#39;)</span>
<span class="gd">-    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;bad-super-call&quot;)</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check use of super.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # ignore actual functions or method within a new style class</span>
<span class="gi">+        if not node.is_method():</span>
<span class="gi">+            return</span>
<span class="gi">+        klass = node.parent.frame()</span>
<span class="gi">+        for stmt in node.nodes_of_class(nodes.Call):</span>
<span class="gi">+            if node_frame_class(stmt) != node_frame_class(node):</span>
<span class="gi">+                # Don&#39;t look down in other scopes.</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            expr = stmt.func</span>
<span class="gi">+            if not isinstance(expr, nodes.Attribute):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            call = expr.expr</span>
<span class="gi">+            # skip the test if using super</span>
<span class="gi">+            if not (</span>
<span class="gi">+                isinstance(call, nodes.Call)</span>
<span class="gi">+                and isinstance(call.func, nodes.Name)</span>
<span class="gi">+                and call.func.name == &quot;super&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # super should not be used on an old style class</span>
<span class="gi">+            if klass.newstyle or not has_known_bases(klass):</span>
<span class="gi">+                # super first arg should not be the class</span>
<span class="gi">+                if not call.args:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # calling super(type(self), self) can lead to recursion loop</span>
<span class="gi">+                # in derived classes</span>
<span class="gi">+                arg0 = call.args[0]</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(arg0, nodes.Call)</span>
<span class="gi">+                    and isinstance(arg0.func, nodes.Name)</span>
<span class="gi">+                    and arg0.func.name == &quot;type&quot;</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(&quot;bad-super-call&quot;, node=call, args=(&quot;type&quot;,))</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # calling super(self.__class__, self) can lead to recursion loop</span>
<span class="gi">+                # in derived classes</span>
<span class="gi">+                if (</span>
<span class="gi">+                    len(call.args) &gt;= 2</span>
<span class="gi">+                    and isinstance(call.args[1], nodes.Name)</span>
<span class="gi">+                    and call.args[1].name == &quot;self&quot;</span>
<span class="gi">+                    and isinstance(arg0, nodes.Attribute)</span>
<span class="gi">+                    and arg0.attrname == &quot;__class__&quot;</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;bad-super-call&quot;, node=call, args=(&quot;self.__class__&quot;,)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    supcls = call.args and next(call.args[0].infer(), None)</span>
<span class="gi">+                except astroid.InferenceError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # If the supcls is in the ancestors of klass super can be used to skip</span>
<span class="gi">+                # a step in the mro() and get a method from a higher parent</span>
<span class="gi">+                if klass is not supcls and all(i != supcls for i in klass.ancestors()):</span>
<span class="gi">+                    name = None</span>
<span class="gi">+                    # if supcls is not Uninferable, then supcls was inferred</span>
<span class="gi">+                    # and use its name. Otherwise, try to look</span>
<span class="gi">+                    # for call.args[0].name</span>
<span class="gi">+                    if supcls:</span>
<span class="gi">+                        name = supcls.name</span>
<span class="gi">+                    elif call.args and hasattr(call.args[0], &quot;name&quot;):</span>
<span class="gi">+                        name = call.args[0].name</span>
<span class="gi">+                    if name:</span>
<span class="gi">+                        self.add_message(&quot;bad-super-call&quot;, node=call, args=(name,))</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(NewStyleConflictChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/non_ascii_names.py b/pylint/checkers/non_ascii_names.py</span>
<span class="gh">index 3105ba332..693d8529f 100644</span>
<span class="gd">--- a/pylint/checkers/non_ascii_names.py</span>
<span class="gi">+++ b/pylint/checkers/non_ascii_names.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;All alphanumeric unicode character are allowed in Python but due
<span class="w"> </span>to similarities in how they look they can be confused.

<span class="gu">@@ -5,12 +9,22 @@ See: https://peps.python.org/pep-0672/#confusing-features</span>

<span class="w"> </span>The following checkers are intended to make users are aware of these issues.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import constants, interfaces, lint
<span class="w"> </span>from pylint.checkers import base_checker, utils
<span class="gd">-NON_ASCII_HELP = &quot;&quot;&quot;Used when the name contains at least one non-ASCII unicode character. See https://peps.python.org/pep-0672/#confusing-features for a background why this could be bad. </span>
<span class="gd">-If your programming guideline defines that you are programming in English, then there should be no need for non ASCII characters in Python Names. If not you can simply disable this check.&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+NON_ASCII_HELP = (</span>
<span class="gi">+    &quot;Used when the name contains at least one non-ASCII unicode character. &quot;</span>
<span class="gi">+    &quot;See https://peps.python.org/pep-0672/#confusing-features&quot;</span>
<span class="gi">+    &quot; for a background why this could be bad. \n&quot;</span>
<span class="gi">+    &quot;If your programming guideline defines that you are programming in &quot;</span>
<span class="gi">+    &quot;English, then there should be no need for non ASCII characters in &quot;</span>
<span class="gi">+    &quot;Python Names. If not you can simply disable this check.&quot;</span>
<span class="gi">+)</span>


<span class="w"> </span>class NonAsciiNameChecker(base_checker.BaseChecker):
<span class="gu">@@ -19,30 +33,142 @@ class NonAsciiNameChecker(base_checker.BaseChecker):</span>
<span class="w"> </span>    Note: This check only checks Names, so it ignores the content of
<span class="w"> </span>          docstrings and comments!
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    msgs = {&#39;C2401&#39;: (</span>
<span class="gd">-        &#39;%s name &quot;%s&quot; contains a non-ASCII character, consider renaming it.&#39;,</span>
<span class="gd">-        &#39;non-ascii-name&#39;, NON_ASCII_HELP, {&#39;old_names&#39;: [(&#39;C0144&#39;,</span>
<span class="gd">-        &#39;old-non-ascii-name&#39;)]}), &#39;W2402&#39;: (</span>
<span class="gd">-        &#39;%s name &quot;%s&quot; contains a non-ASCII character.&#39;,</span>
<span class="gd">-        &#39;non-ascii-file-name&#39;,</span>
<span class="gd">-        &quot;Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.Since Python 3.5, even though Python supports UTF-8 files, some editors or tools don&#39;t.&quot;</span>
<span class="gd">-        ), &#39;C2403&#39;: (</span>
<span class="gd">-        &#39;%s name &quot;%s&quot; contains a non-ASCII character, use an ASCII-only alias for import.&#39;</span>
<span class="gd">-        , &#39;non-ascii-module-import&#39;, NON_ASCII_HELP)}</span>
<span class="gd">-    name = &#39;NonASCII-Checker&#39;</span>
<span class="gd">-</span>
<span class="gd">-    def _check_name(self, node_type: str, name: (str | None), node: nodes.</span>
<span class="gd">-        NodeNG) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C2401&quot;: (</span>
<span class="gi">+            &#39;%s name &quot;%s&quot; contains a non-ASCII character, consider renaming it.&#39;,</span>
<span class="gi">+            &quot;non-ascii-name&quot;,</span>
<span class="gi">+            NON_ASCII_HELP,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;C0144&quot;, &quot;old-non-ascii-name&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        # First %s will always be &quot;file&quot;</span>
<span class="gi">+        &quot;W2402&quot;: (</span>
<span class="gi">+            &#39;%s name &quot;%s&quot; contains a non-ASCII character.&#39;,</span>
<span class="gi">+            &quot;non-ascii-file-name&quot;,</span>
<span class="gi">+            (</span>
<span class="gi">+                # Some = PyCharm at the time of writing didn&#39;t display the non_ascii_name_loł</span>
<span class="gi">+                # files. That&#39;s also why this is a warning and not only a convention!</span>
<span class="gi">+                &quot;Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.&quot;</span>
<span class="gi">+                &quot;Since Python 3.5, even though Python supports UTF-8 files, some editors or tools &quot;</span>
<span class="gi">+                &quot;don&#39;t.&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+        ),</span>
<span class="gi">+        # First %s will always be &quot;module&quot;</span>
<span class="gi">+        &quot;C2403&quot;: (</span>
<span class="gi">+            &#39;%s name &quot;%s&quot; contains a non-ASCII character, use an ASCII-only alias for import.&#39;,</span>
<span class="gi">+            &quot;non-ascii-module-import&quot;,</span>
<span class="gi">+            NON_ASCII_HELP,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;NonASCII-Checker&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _check_name(self, node_type: str, name: str | None, node: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether a name is using non-ASCII characters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            # For some nodes i.e. *kwargs from a dict, the name will be empty</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not str(name).isascii():</span>
<span class="gi">+            type_label = constants.HUMAN_READABLE_TYPES[node_type]</span>
<span class="gi">+            args = (type_label.capitalize(), name)</span>
<span class="gi">+</span>
<span class="gi">+            msg = &quot;non-ascii-name&quot;</span>
<span class="gi">+</span>
<span class="gi">+            # Some node types have customized messages</span>
<span class="gi">+            if node_type == &quot;file&quot;:</span>
<span class="gi">+                msg = &quot;non-ascii-file-name&quot;</span>
<span class="gi">+            elif node_type == &quot;module&quot;:</span>
<span class="gi">+                msg = &quot;non-ascii-module-import&quot;</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(msg, node=node, args=args, confidence=interfaces.HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;non-ascii-name&quot;, &quot;non-ascii-file-name&quot;)</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="gi">+        self._check_name(&quot;file&quot;, node.name.split(&quot;.&quot;)[-1], node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;non-ascii-name&quot;)</span>
<span class="gi">+    def visit_functiondef(</span>
<span class="gi">+        self, node: nodes.FunctionDef | nodes.AsyncFunctionDef</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._check_name(&quot;function&quot;, node.name, node)</span>
<span class="gi">+</span>
<span class="gi">+        # Check argument names</span>
<span class="gi">+        arguments = node.args</span>
<span class="gi">+</span>
<span class="gi">+        # Check position only arguments</span>
<span class="gi">+        if arguments.posonlyargs:</span>
<span class="gi">+            for pos_only_arg in arguments.posonlyargs:</span>
<span class="gi">+                self._check_name(&quot;argument&quot;, pos_only_arg.name, pos_only_arg)</span>
<span class="gi">+</span>
<span class="gi">+        # Check &quot;normal&quot; arguments</span>
<span class="gi">+        if arguments.args:</span>
<span class="gi">+            for arg in arguments.args:</span>
<span class="gi">+                self._check_name(&quot;argument&quot;, arg.name, arg)</span>
<span class="gi">+</span>
<span class="gi">+        # Check key word only arguments</span>
<span class="gi">+        if arguments.kwonlyargs:</span>
<span class="gi">+            for kwarg in arguments.kwonlyargs:</span>
<span class="gi">+                self._check_name(&quot;argument&quot;, kwarg.name, kwarg)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    @utils.only_required_for_messages(&#39;non-ascii-name&#39;)</span>
<span class="gd">-    def visit_assignname(self, node: nodes.AssignName) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;non-ascii-name&quot;)</span>
<span class="gi">+    def visit_global(self, node: nodes.Global) -&gt; None:</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            self._check_name(&quot;const&quot;, name, node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;non-ascii-name&quot;)</span>
<span class="gi">+    def visit_assignname(self, node: nodes.AssignName) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check module level assigned names.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # The NameChecker from which this Checker originates knows a lot of different</span>
<span class="gi">+        # versions of variables, i.e. constants, inline variables etc.</span>
<span class="gi">+        # To simplify we use only `variable` here, as we don&#39;t need to apply different</span>
<span class="gi">+        # rules to different types of variables.</span>
<span class="gi">+        frame = node.frame()</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(frame, nodes.FunctionDef):</span>
<span class="gi">+            if node.parent in frame.body:</span>
<span class="gi">+                # Only perform the check if the assignment was done in within the body</span>
<span class="gi">+                # of the function (and not the function parameter definition</span>
<span class="gi">+                # (will be handled in visit_functiondef)</span>
<span class="gi">+                # or within a decorator (handled in visit_call)</span>
<span class="gi">+                self._check_name(&quot;variable&quot;, node.name, node)</span>
<span class="gi">+        elif isinstance(frame, nodes.ClassDef):</span>
<span class="gi">+            self._check_name(&quot;attr&quot;, node.name, node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Possibilities here:</span>
<span class="gi">+            # - isinstance(node.assign_type(), nodes.Comprehension) == inlinevar</span>
<span class="gi">+            # - isinstance(frame, nodes.Module) == variable (constant?)</span>
<span class="gi">+            # - some other kind of assignment missed but still most likely a variable</span>
<span class="gi">+            self._check_name(&quot;variable&quot;, node.name, node)</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;non-ascii-name&#39;)</span>
<span class="gd">-    def visit_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;non-ascii-name&quot;)</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        self._check_name(&quot;class&quot;, node.name, node)</span>
<span class="gi">+        for attr, anodes in node.instance_attrs.items():</span>
<span class="gi">+            if not any(node.instance_attr_ancestors(attr)):</span>
<span class="gi">+                self._check_name(&quot;attr&quot;, attr, anodes[0])</span>
<span class="gi">+</span>
<span class="gi">+    def _check_module_import(self, node: nodes.ImportFrom | nodes.Import) -&gt; None:</span>
<span class="gi">+        for module_name, alias in node.names:</span>
<span class="gi">+            name = alias or module_name</span>
<span class="gi">+            self._check_name(&quot;module&quot;, name, node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;non-ascii-name&quot;, &quot;non-ascii-module-import&quot;)</span>
<span class="gi">+    def visit_import(self, node: nodes.Import) -&gt; None:</span>
<span class="gi">+        self._check_module_import(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;non-ascii-name&quot;, &quot;non-ascii-module-import&quot;)</span>
<span class="gi">+    def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="gi">+        self._check_module_import(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;non-ascii-name&quot;)</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the used keyword args are correct.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for keyword in node.keywords:</span>
<span class="gi">+            self._check_name(&quot;argument&quot;, keyword.arg, keyword)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: lint.PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(NonAsciiNameChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/raw_metrics.py b/pylint/checkers/raw_metrics.py</span>
<span class="gh">index 205644431..ef4535345 100644</span>
<span class="gd">--- a/pylint/checkers/raw_metrics.py</span>
<span class="gi">+++ b/pylint/checkers/raw_metrics.py</span>
<span class="gu">@@ -1,17 +1,43 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import tokenize
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Literal, cast
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseTokenChecker
<span class="w"> </span>from pylint.reporters.ureports.nodes import Paragraph, Section, Table, Text
<span class="w"> </span>from pylint.utils import LinterStats, diff_string
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="gd">-def report_raw_stats(sect: Section, stats: LinterStats, old_stats: (</span>
<span class="gd">-    LinterStats | None)) -&gt;None:</span>
<span class="gi">+def report_raw_stats(</span>
<span class="gi">+    sect: Section,</span>
<span class="gi">+    stats: LinterStats,</span>
<span class="gi">+    old_stats: LinterStats | None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Calculate percentage of code / doc / comment / empty.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total_lines = stats.code_type_count[&quot;total&quot;]</span>
<span class="gi">+    sect.insert(0, Paragraph([Text(f&quot;{total_lines} lines have been analyzed\n&quot;)]))</span>
<span class="gi">+    lines = [&quot;type&quot;, &quot;number&quot;, &quot;%&quot;, &quot;previous&quot;, &quot;difference&quot;]</span>
<span class="gi">+    for node_type in (&quot;code&quot;, &quot;docstring&quot;, &quot;comment&quot;, &quot;empty&quot;):</span>
<span class="gi">+        node_type = cast(Literal[&quot;code&quot;, &quot;docstring&quot;, &quot;comment&quot;, &quot;empty&quot;], node_type)</span>
<span class="gi">+        total = stats.code_type_count[node_type]</span>
<span class="gi">+        percent = float(total * 100) / total_lines if total_lines else None</span>
<span class="gi">+        old = old_stats.code_type_count[node_type] if old_stats else None</span>
<span class="gi">+        diff_str = diff_string(old, total) if old else None</span>
<span class="gi">+        lines += [</span>
<span class="gi">+            node_type,</span>
<span class="gi">+            str(total),</span>
<span class="gi">+            f&quot;{percent:.2f}&quot; if percent is not None else &quot;NC&quot;,</span>
<span class="gi">+            str(old) if old else &quot;NC&quot;,</span>
<span class="gi">+            diff_str if diff_str else &quot;NC&quot;,</span>
<span class="gi">+        ]</span>
<span class="gi">+    sect.append(Table(children=lines, cols=5, rheaders=1))</span>


<span class="w"> </span>class RawMetricsChecker(BaseTokenChecker):
<span class="gu">@@ -24,24 +50,61 @@ class RawMetricsChecker(BaseTokenChecker):</span>
<span class="w"> </span>    * total number of comments lines
<span class="w"> </span>    * total number of empty lines
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;metrics&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;metrics&quot;</span>
<span class="gi">+    # configuration options</span>
<span class="w"> </span>    options = ()
<span class="gi">+    # messages</span>
<span class="w"> </span>    msgs: Any = {}
<span class="gd">-    reports = (&#39;RP0701&#39;, &#39;Raw metrics&#39;, report_raw_stats),</span>
<span class="gi">+    # reports</span>
<span class="gi">+    reports = ((&quot;RP0701&quot;, &quot;Raw metrics&quot;, report_raw_stats),)</span>

<span class="gd">-    def open(self) -&gt;None:</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Init statistics.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.linter.stats.reset_code_count()</span>

<span class="gd">-    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt;None:</span>
<span class="gi">+    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update stats.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        tokens = list(tokens)</span>
<span class="gi">+        while i &lt; len(tokens):</span>
<span class="gi">+            i, lines_number, line_type = get_type(tokens, i)</span>
<span class="gi">+            self.linter.stats.code_type_count[&quot;total&quot;] += lines_number</span>
<span class="gi">+            self.linter.stats.code_type_count[line_type] += lines_number</span>


<span class="gd">-JUNK = tokenize.NL, tokenize.INDENT, tokenize.NEWLINE, tokenize.ENDMARKER</span>
<span class="gi">+JUNK = (tokenize.NL, tokenize.INDENT, tokenize.NEWLINE, tokenize.ENDMARKER)</span>


<span class="gd">-def get_type(tokens: list[tokenize.TokenInfo], start_index: int) -&gt;tuple[</span>
<span class="gd">-    int, int, Literal[&#39;code&#39;, &#39;docstring&#39;, &#39;comment&#39;, &#39;empty&#39;]]:</span>
<span class="gi">+def get_type(</span>
<span class="gi">+    tokens: list[tokenize.TokenInfo], start_index: int</span>
<span class="gi">+) -&gt; tuple[int, int, Literal[&quot;code&quot;, &quot;docstring&quot;, &quot;comment&quot;, &quot;empty&quot;]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the line type : docstring, comment, code, empty.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    i = start_index</span>
<span class="gi">+    start = tokens[i][2]</span>
<span class="gi">+    pos = start</span>
<span class="gi">+    line_type = None</span>
<span class="gi">+    while i &lt; len(tokens) and tokens[i][2][0] == start[0]:</span>
<span class="gi">+        tok_type = tokens[i][0]</span>
<span class="gi">+        pos = tokens[i][3]</span>
<span class="gi">+        if line_type is None:</span>
<span class="gi">+            if tok_type == tokenize.STRING:</span>
<span class="gi">+                line_type = &quot;docstring&quot;</span>
<span class="gi">+            elif tok_type == tokenize.COMMENT:</span>
<span class="gi">+                line_type = &quot;comment&quot;</span>
<span class="gi">+            elif tok_type in JUNK:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                line_type = &quot;code&quot;</span>
<span class="gi">+        i += 1</span>
<span class="gi">+    if line_type is None:</span>
<span class="gi">+        line_type = &quot;empty&quot;</span>
<span class="gi">+    elif i &lt; len(tokens) and tokens[i][0] == tokenize.NEWLINE:</span>
<span class="gi">+        i += 1</span>
<span class="gi">+    # Mypy fails to infer the literal of line_type</span>
<span class="gi">+    return i, pos[0] - start[0] + 1, line_type  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(RawMetricsChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/refactoring/implicit_booleaness_checker.py b/pylint/checkers/refactoring/implicit_booleaness_checker.py</span>
<span class="gh">index b7c28e71f..5818c2f4a 100644</span>
<span class="gd">--- a/pylint/checkers/refactoring/implicit_booleaness_checker.py</span>
<span class="gi">+++ b/pylint/checkers/refactoring/implicit_booleaness_checker.py</span>
<span class="gu">@@ -1,12 +1,27 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import bases, nodes, util
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.interfaces import HIGH, INFERENCE


<span class="gi">+def _is_constant_zero(node: str | nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    # We have to check that node.value is not False because node.value == 0 is True</span>
<span class="gi">+    # when node.value is False</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(node, astroid.Const) and node.value == 0 and node.value is not False</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class ImplicitBooleanessChecker(checkers.BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks for incorrect usage of comparisons or len() inside conditions.

<span class="gu">@@ -45,52 +60,286 @@ class ImplicitBooleanessChecker(checkers.BaseChecker):</span>
<span class="w"> </span>    * comparison such as variable == empty_literal:
<span class="w"> </span>    * comparison such as variable != empty_literal:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;refactoring&#39;</span>
<span class="gd">-    msgs = {&#39;C1802&#39;: (</span>
<span class="gd">-        &#39;Do not use `len(SEQUENCE)` without comparison to determine if a sequence is empty&#39;</span>
<span class="gd">-        , &#39;use-implicit-booleaness-not-len&#39;,</span>
<span class="gd">-        &quot;Empty sequences are considered false in a boolean context. You can either remove the call to &#39;len&#39; (``if not x``) or compare the length against a scalar (``if len(x) &gt; 1``).&quot;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;C1801&#39;, &#39;len-as-condition&#39;)]}), &#39;C1803&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; can be simplified to &quot;%s&quot;, if it is strictly a sequence, as an empty %s is falsey&#39;</span>
<span class="gd">-        , &#39;use-implicit-booleaness-not-comparison&#39;,</span>
<span class="gd">-        &#39;Empty sequences are considered false in a boolean context. Following this check blindly in weakly typed code base can create hard to debug issues. If the value can be something else that is falsey but not a sequence (for example ``None``, an empty string, or ``0``) the code will not be equivalent.&#39;</span>
<span class="gd">-        ), &#39;C1804&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; can be simplified to &quot;%s&quot;, if it is striclty a string, as an empty string is falsey&#39;</span>
<span class="gd">-        , &#39;use-implicit-booleaness-not-comparison-to-string&#39;,</span>
<span class="gd">-        &#39;Empty string are considered false in a boolean context. Following this check blindly in weakly typed code base can create hard to debug issues. If the value can be something else that is falsey but not a string (for example ``None``, an empty sequence, or ``0``) the code will not be equivalent.&#39;</span>
<span class="gd">-        , {&#39;default_enabled&#39;: False, &#39;old_names&#39;: [(&#39;C1901&#39;,</span>
<span class="gd">-        &#39;compare-to-empty-string&#39;)]}), &#39;C1805&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; can be simplified to &quot;%s&quot;, if it is strictly an int, as 0 is falsey&#39;</span>
<span class="gd">-        , &#39;use-implicit-booleaness-not-comparison-to-zero&#39;,</span>
<span class="gd">-        &#39;0 is considered false in a boolean context. Following this check blindly in weakly typed code base can create hard to debug issues. If the value can be something else that is falsey but not an int (for example ``None``, an empty string, or an empty sequence) the code will not be equivalent.&#39;</span>
<span class="gd">-        , {&#39;default_enabled&#39;: False, &#39;old_names&#39;: [(&#39;C2001&#39;,</span>
<span class="gd">-        &#39;compare-to-zero&#39;)]})}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;refactoring&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C1802&quot;: (</span>
<span class="gi">+            &quot;Do not use `len(SEQUENCE)` without comparison to determine if a sequence is empty&quot;,</span>
<span class="gi">+            &quot;use-implicit-booleaness-not-len&quot;,</span>
<span class="gi">+            &quot;Empty sequences are considered false in a boolean context. You can either&quot;</span>
<span class="gi">+            &quot; remove the call to &#39;len&#39; (``if not x``) or compare the length against a&quot;</span>
<span class="gi">+            &quot; scalar (``if len(x) &gt; 1``).&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;C1801&quot;, &quot;len-as-condition&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C1803&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; can be simplified to &quot;%s&quot;, if it is strictly a sequence, as an empty %s is falsey&#39;,</span>
<span class="gi">+            &quot;use-implicit-booleaness-not-comparison&quot;,</span>
<span class="gi">+            &quot;Empty sequences are considered false in a boolean context. Following this&quot;</span>
<span class="gi">+            &quot; check blindly in weakly typed code base can create hard to debug issues.&quot;</span>
<span class="gi">+            &quot; If the value can be something else that is falsey but not a sequence (for&quot;</span>
<span class="gi">+            &quot; example ``None``, an empty string, or ``0``) the code will not be &quot;</span>
<span class="gi">+            &quot;equivalent.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C1804&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; can be simplified to &quot;%s&quot;, if it is striclty a string, as an empty string is falsey&#39;,</span>
<span class="gi">+            &quot;use-implicit-booleaness-not-comparison-to-string&quot;,</span>
<span class="gi">+            &quot;Empty string are considered false in a boolean context. Following this&quot;</span>
<span class="gi">+            &quot; check blindly in weakly typed code base can create hard to debug issues.&quot;</span>
<span class="gi">+            &quot; If the value can be something else that is falsey but not a string (for&quot;</span>
<span class="gi">+            &quot; example ``None``, an empty sequence, or ``0``) the code will not be &quot;</span>
<span class="gi">+            &quot;equivalent.&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default_enabled&quot;: False,</span>
<span class="gi">+                &quot;old_names&quot;: [(&quot;C1901&quot;, &quot;compare-to-empty-string&quot;)],</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C1805&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; can be simplified to &quot;%s&quot;, if it is strictly an int, as 0 is falsey&#39;,</span>
<span class="gi">+            &quot;use-implicit-booleaness-not-comparison-to-zero&quot;,</span>
<span class="gi">+            &quot;0 is considered false in a boolean context. Following this&quot;</span>
<span class="gi">+            &quot; check blindly in weakly typed code base can create hard to debug issues.&quot;</span>
<span class="gi">+            &quot; If the value can be something else that is falsey but not an int (for&quot;</span>
<span class="gi">+            &quot; example ``None``, an empty string, or an empty sequence) the code will not be &quot;</span>
<span class="gi">+            &quot;equivalent.&quot;,</span>
<span class="gi">+            {&quot;default_enabled&quot;: False, &quot;old_names&quot;: [(&quot;C2001&quot;, &quot;compare-to-zero&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    options = ()
<span class="gd">-    _operators = {&#39;!=&#39;, &#39;==&#39;, &#39;is not&#39;, &#39;is&#39;}</span>
<span class="gi">+    _operators = {&quot;!=&quot;, &quot;==&quot;, &quot;is not&quot;, &quot;is&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;use-implicit-booleaness-not-len&quot;)</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        # a len(S) call is used inside a test condition</span>
<span class="gi">+        # could be if, while, assert or if expression statement</span>
<span class="gi">+        # e.g. `if len(S):`</span>
<span class="gi">+        if not utils.is_call_of_name(node, &quot;len&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        # the len() call could also be nested together with other</span>
<span class="gi">+        # boolean operations, e.g. `if z or len(x):`</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        while isinstance(parent, nodes.BoolOp):</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        # we&#39;re finally out of any nested boolean operations so check if</span>
<span class="gi">+        # this len() call is part of a test condition</span>
<span class="gi">+        if not utils.is_test_condition(node, parent):</span>
<span class="gi">+            return</span>
<span class="gi">+        len_arg = node.args[0]</span>
<span class="gi">+        generator_or_comprehension = (</span>
<span class="gi">+            nodes.ListComp,</span>
<span class="gi">+            nodes.SetComp,</span>
<span class="gi">+            nodes.DictComp,</span>
<span class="gi">+            nodes.GeneratorExp,</span>
<span class="gi">+        )</span>
<span class="gi">+        if isinstance(len_arg, generator_or_comprehension):</span>
<span class="gi">+            # The node is a generator or comprehension as in len([x for x in ...])</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;use-implicit-booleaness-not-len&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            instance = next(len_arg.infer())</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            # Probably undefined-variable, abort check</span>
<span class="gi">+            return</span>
<span class="gi">+        mother_classes = self.base_names_of_instance(instance)</span>
<span class="gi">+        affected_by_pep8 = any(</span>
<span class="gi">+            t in mother_classes for t in (&quot;str&quot;, &quot;tuple&quot;, &quot;list&quot;, &quot;set&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        if &quot;range&quot; in mother_classes or (</span>
<span class="gi">+            affected_by_pep8 and not self.instance_has_bool(instance)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;use-implicit-booleaness-not-len&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;use-implicit-booleaness-not-len&#39;)</span>
<span class="gd">-    def visit_unaryop(self, node: nodes.UnaryOp) -&gt;None:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def instance_has_bool(class_def: nodes.ClassDef) -&gt; bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            class_def.getattr(&quot;__bool__&quot;)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except astroid.AttributeInferenceError:</span>
<span class="gi">+            ...</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;use-implicit-booleaness-not-len&quot;)</span>
<span class="gi">+    def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;`not len(S)` must become `not S` regardless if the parent block is a test
<span class="w"> </span>        condition or something else (boolean expression) e.g. `if not len(S):`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, nodes.UnaryOp)</span>
<span class="gi">+            and node.op == &quot;not&quot;</span>
<span class="gi">+            and utils.is_call_of_name(node.operand, &quot;len&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;use-implicit-booleaness-not-len&quot;, node=node, confidence=HIGH</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;use-implicit-booleaness-not-comparison&quot;,</span>
<span class="gi">+        &quot;use-implicit-booleaness-not-comparison-to-string&quot;,</span>
<span class="gi">+        &quot;use-implicit-booleaness-not-comparison-to-zero&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_compare(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        if self.linter.is_message_enabled(&quot;use-implicit-booleaness-not-comparison&quot;):</span>
<span class="gi">+            self._check_use_implicit_booleaness_not_comparison(node)</span>
<span class="gi">+        if self.linter.is_message_enabled(</span>
<span class="gi">+            &quot;use-implicit-booleaness-not-comparison-to-zero&quot;</span>
<span class="gi">+        ) or self.linter.is_message_enabled(</span>
<span class="gi">+            &quot;use-implicit-booleaness-not-comparison-to-str&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._check_compare_to_str_or_zero(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_compare_to_str_or_zero(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        # note: astroid.Compare has the left most operand in node.left</span>
<span class="gi">+        # while the rest are a list of tuples in node.ops</span>
<span class="gi">+        # the format of the tuple is (&#39;compare operator sign&#39;, node)</span>
<span class="gi">+        # here we squash everything into `ops` to make it easier for processing later</span>
<span class="gi">+        ops: list[tuple[str, nodes.NodeNG]] = [(&quot;&quot;, node.left), *node.ops]</span>
<span class="gi">+        iter_ops = iter(ops)</span>
<span class="gi">+        all_ops = list(itertools.chain(*iter_ops))</span>
<span class="gi">+        for ops_idx in range(len(all_ops) - 2):</span>
<span class="gi">+            op_2 = all_ops[ops_idx + 1]</span>
<span class="gi">+            if op_2 not in self._operators:</span>
<span class="gi">+                continue</span>
<span class="gi">+            op_1 = all_ops[ops_idx]</span>
<span class="gi">+            op_3 = all_ops[ops_idx + 2]</span>
<span class="gi">+            error_detected = False</span>
<span class="gi">+            if self.linter.is_message_enabled(</span>
<span class="gi">+                &quot;use-implicit-booleaness-not-comparison-to-zero&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                # 0 ?? X</span>
<span class="gi">+                if _is_constant_zero(op_1):</span>
<span class="gi">+                    error_detected = True</span>
<span class="gi">+                    op = op_3</span>
<span class="gi">+                # X ?? 0</span>
<span class="gi">+                elif _is_constant_zero(op_3):</span>
<span class="gi">+                    error_detected = True</span>
<span class="gi">+                    op = op_1</span>
<span class="gi">+                if error_detected:</span>
<span class="gi">+                    original = f&quot;{op_1.as_string()} {op_2} {op_3.as_string()}&quot;</span>
<span class="gi">+                    suggestion = (</span>
<span class="gi">+                        op.as_string()</span>
<span class="gi">+                        if op_2 in {&quot;!=&quot;, &quot;is not&quot;}</span>
<span class="gi">+                        else f&quot;not {op.as_string()}&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;use-implicit-booleaness-not-comparison-to-zero&quot;,</span>
<span class="gi">+                        args=(original, suggestion),</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    error_detected = False</span>
<span class="gi">+            if self.linter.is_message_enabled(</span>
<span class="gi">+                &quot;use-implicit-booleaness-not-comparison-to-str&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                node_name = &quot;&quot;</span>
<span class="gi">+                # x ?? &quot;&quot;</span>
<span class="gi">+                if utils.is_empty_str_literal(op_1):</span>
<span class="gi">+                    error_detected = True</span>
<span class="gi">+                    node_name = op_3.as_string()</span>
<span class="gi">+                # &#39;&#39; ?? X</span>
<span class="gi">+                elif utils.is_empty_str_literal(op_3):</span>
<span class="gi">+                    error_detected = True</span>
<span class="gi">+                    node_name = op_1.as_string()</span>
<span class="gi">+                if error_detected:</span>
<span class="gi">+                    suggestion = (</span>
<span class="gi">+                        f&quot;not {node_name}&quot; if op_2 in {&quot;==&quot;, &quot;is&quot;} else node_name</span>
<span class="gi">+                    )</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;use-implicit-booleaness-not-comparison-to-string&quot;,</span>
<span class="gi">+                        args=(node.as_string(), suggestion),</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>

<span class="gd">-    def _check_use_implicit_booleaness_not_comparison(self, node: nodes.Compare</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _check_use_implicit_booleaness_not_comparison(</span>
<span class="gi">+        self, node: nodes.Compare</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for left side and right side of the node for empty literals.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        is_left_empty_literal = utils.is_base_container(</span>
<span class="gi">+            node.left</span>
<span class="gi">+        ) or utils.is_empty_dict_literal(node.left)</span>
<span class="gi">+</span>
<span class="gi">+        # Check both left-hand side and right-hand side for literals</span>
<span class="gi">+        for operator, comparator in node.ops:</span>
<span class="gi">+            is_right_empty_literal = utils.is_base_container(</span>
<span class="gi">+                comparator</span>
<span class="gi">+            ) or utils.is_empty_dict_literal(comparator)</span>
<span class="gi">+            # Using Exclusive OR (XOR) to compare between two side.</span>
<span class="gi">+            # If two sides are both literal, it should be different error.</span>
<span class="gi">+            if is_right_empty_literal ^ is_left_empty_literal:</span>
<span class="gi">+                # set target_node to opposite side of literal</span>
<span class="gi">+                target_node = node.left if is_right_empty_literal else comparator</span>
<span class="gi">+                literal_node = comparator if is_right_empty_literal else node.left</span>
<span class="gi">+                # Infer node to check</span>
<span class="gi">+                target_instance = utils.safe_infer(target_node)</span>
<span class="gi">+                if target_instance is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                mother_classes = self.base_names_of_instance(target_instance)</span>
<span class="gi">+                is_base_comprehension_type = any(</span>
<span class="gi">+                    t in mother_classes for t in (&quot;tuple&quot;, &quot;list&quot;, &quot;dict&quot;, &quot;set&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                # Only time we bypass check is when target_node is not inherited by</span>
<span class="gi">+                # collection literals and have its own __bool__ implementation.</span>
<span class="gi">+                if not is_base_comprehension_type and self.instance_has_bool(</span>
<span class="gi">+                    target_instance</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # No need to check for operator when visiting compare node</span>
<span class="gi">+                if operator in {&quot;==&quot;, &quot;!=&quot;, &quot;&gt;=&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&lt;&quot;}:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;use-implicit-booleaness-not-comparison&quot;,</span>
<span class="gi">+                        args=self._implicit_booleaness_message_args(</span>
<span class="gi">+                            literal_node, operator, target_node</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_node_description(self, node: nodes.NodeNG) -&gt; str:</span>
<span class="gi">+        return {</span>
<span class="gi">+            nodes.List: &quot;list&quot;,</span>
<span class="gi">+            nodes.Tuple: &quot;tuple&quot;,</span>
<span class="gi">+            nodes.Dict: &quot;dict&quot;,</span>
<span class="gi">+            nodes.Const: &quot;str&quot;,</span>
<span class="gi">+        }.get(type(node), &quot;iterable&quot;)</span>

<span class="gd">-    def _implicit_booleaness_message_args(self, literal_node: nodes.NodeNG,</span>
<span class="gd">-        operator: str, target_node: nodes.NodeNG) -&gt;tuple[str, str, str]:</span>
<span class="gi">+    def _implicit_booleaness_message_args(</span>
<span class="gi">+        self, literal_node: nodes.NodeNG, operator: str, target_node: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; tuple[str, str, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Helper to get the right message for &quot;use-implicit-booleaness-not-comparison&quot;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        description = self._get_node_description(literal_node)</span>
<span class="gi">+        collection_literal = {</span>
<span class="gi">+            &quot;list&quot;: &quot;[]&quot;,</span>
<span class="gi">+            &quot;tuple&quot;: &quot;()&quot;,</span>
<span class="gi">+            &quot;dict&quot;: &quot;{}&quot;,</span>
<span class="gi">+        }.get(description, &quot;iterable&quot;)</span>
<span class="gi">+        instance_name = &quot;x&quot;</span>
<span class="gi">+        if isinstance(target_node, nodes.Call) and target_node.func:</span>
<span class="gi">+            instance_name = f&quot;{target_node.func.as_string()}(...)&quot;</span>
<span class="gi">+        elif isinstance(target_node, (nodes.Attribute, nodes.Name)):</span>
<span class="gi">+            instance_name = target_node.as_string()</span>
<span class="gi">+        original_comparison = f&quot;{instance_name} {operator} {collection_literal}&quot;</span>
<span class="gi">+        suggestion = f&quot;{instance_name}&quot; if operator == &quot;!=&quot; else f&quot;not {instance_name}&quot;</span>
<span class="gi">+        return original_comparison, suggestion, description</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def base_names_of_instance(node: (util.UninferableBase | bases.Instance)</span>
<span class="gd">-        ) -&gt;list[str]:</span>
<span class="gi">+    def base_names_of_instance(</span>
<span class="gi">+        node: util.UninferableBase | bases.Instance,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return all names inherited by a class instance or those returned by a
<span class="w"> </span>        function.

<span class="w"> </span>        The inherited names include &#39;object&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, bases.Instance):</span>
<span class="gi">+            return [node.name] + [x.name for x in node.ancestors()]</span>
<span class="gi">+        return []</span>
<span class="gh">diff --git a/pylint/checkers/refactoring/not_checker.py b/pylint/checkers/refactoring/not_checker.py</span>
<span class="gh">index dd1e2cd1d..c46b477b5 100644</span>
<span class="gd">--- a/pylint/checkers/refactoring/not_checker.py</span>
<span class="gi">+++ b/pylint/checkers/refactoring/not_checker.py</span>
<span class="gu">@@ -1,5 +1,10 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils

<span class="gu">@@ -10,13 +15,70 @@ class NotChecker(checkers.BaseChecker):</span>
<span class="w"> </span>    - &quot;not not&quot; should trigger a warning
<span class="w"> </span>    - &quot;not&quot; followed by a comparison should trigger a warning
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    msgs = {&#39;C0117&#39;: (&#39;Consider changing &quot;%s&quot; to &quot;%s&quot;&#39;,</span>
<span class="gd">-        &#39;unnecessary-negation&#39;,</span>
<span class="gd">-        &#39;Used when a boolean expression contains an unneeded negation, e.g. when two negation operators cancel each other out.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;C0113&#39;, &#39;unneeded-not&#39;)]})}</span>
<span class="gd">-    name = &#39;refactoring&#39;</span>
<span class="gd">-    reverse_op = {&#39;&lt;&#39;: &#39;&gt;=&#39;, &#39;&lt;=&#39;: &#39;&gt;&#39;, &#39;&gt;&#39;: &#39;&lt;=&#39;, &#39;&gt;=&#39;: &#39;&lt;&#39;, &#39;==&#39;: &#39;!=&#39;,</span>
<span class="gd">-        &#39;!=&#39;: &#39;==&#39;, &#39;in&#39;: &#39;not in&#39;, &#39;is&#39;: &#39;is not&#39;}</span>
<span class="gd">-    skipped_nodes = nodes.Set,</span>
<span class="gd">-    skipped_classnames = [f&#39;builtins.{qname}&#39; for qname in (&#39;set&#39;, &#39;frozenset&#39;)</span>
<span class="gd">-        ]</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C0117&quot;: (</span>
<span class="gi">+            &#39;Consider changing &quot;%s&quot; to &quot;%s&quot;&#39;,</span>
<span class="gi">+            &quot;unnecessary-negation&quot;,</span>
<span class="gi">+            &quot;Used when a boolean expression contains an unneeded negation, &quot;</span>
<span class="gi">+            &quot;e.g. when two negation operators cancel each other out.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;C0113&quot;, &quot;unneeded-not&quot;)]},</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+    name = &quot;refactoring&quot;</span>
<span class="gi">+    reverse_op = {</span>
<span class="gi">+        &quot;&lt;&quot;: &quot;&gt;=&quot;,</span>
<span class="gi">+        &quot;&lt;=&quot;: &quot;&gt;&quot;,</span>
<span class="gi">+        &quot;&gt;&quot;: &quot;&lt;=&quot;,</span>
<span class="gi">+        &quot;&gt;=&quot;: &quot;&lt;&quot;,</span>
<span class="gi">+        &quot;==&quot;: &quot;!=&quot;,</span>
<span class="gi">+        &quot;!=&quot;: &quot;==&quot;,</span>
<span class="gi">+        &quot;in&quot;: &quot;not in&quot;,</span>
<span class="gi">+        &quot;is&quot;: &quot;is not&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    # sets are not ordered, so for example &quot;not set(LEFT_VALS) &lt;= set(RIGHT_VALS)&quot; is</span>
<span class="gi">+    # not equivalent to &quot;set(LEFT_VALS) &gt; set(RIGHT_VALS)&quot;</span>
<span class="gi">+    skipped_nodes = (nodes.Set,)</span>
<span class="gi">+    # &#39;builtins&#39; py3, &#39;__builtin__&#39; py2</span>
<span class="gi">+    skipped_classnames = [f&quot;builtins.{qname}&quot; for qname in (&quot;set&quot;, &quot;frozenset&quot;)]</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;unnecessary-negation&quot;)</span>
<span class="gi">+    def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:</span>
<span class="gi">+        if node.op != &quot;not&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+        operand = node.operand</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(operand, nodes.UnaryOp) and operand.op == &quot;not&quot;:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unnecessary-negation&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(node.as_string(), operand.operand.as_string()),</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(operand, nodes.Compare):</span>
<span class="gi">+            left = operand.left</span>
<span class="gi">+            # ignore multiple comparisons</span>
<span class="gi">+            if len(operand.ops) &gt; 1:</span>
<span class="gi">+                return</span>
<span class="gi">+            operator, right = operand.ops[0]</span>
<span class="gi">+            if operator not in self.reverse_op:</span>
<span class="gi">+                return</span>
<span class="gi">+            # Ignore __ne__ as function of __eq__</span>
<span class="gi">+            frame = node.frame()</span>
<span class="gi">+            if frame.name == &quot;__ne__&quot; and operator == &quot;==&quot;:</span>
<span class="gi">+                return</span>
<span class="gi">+            for _type in (utils.node_type(left), utils.node_type(right)):</span>
<span class="gi">+                if not _type:</span>
<span class="gi">+                    return</span>
<span class="gi">+                if isinstance(_type, self.skipped_nodes):</span>
<span class="gi">+                    return</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(_type, astroid.Instance)</span>
<span class="gi">+                    and _type.qname() in self.skipped_classnames</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+            suggestion = (</span>
<span class="gi">+                f&quot;{left.as_string()} {self.reverse_op[operator]} {right.as_string()}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unnecessary-negation&quot;, node=node, args=(node.as_string(), suggestion)</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/pylint/checkers/refactoring/recommendation_checker.py b/pylint/checkers/refactoring/recommendation_checker.py</span>
<span class="gh">index 187ef26fc..c5b19e1a5 100644</span>
<span class="gd">--- a/pylint/checkers/refactoring/recommendation_checker.py</span>
<span class="gi">+++ b/pylint/checkers/refactoring/recommendation_checker.py</span>
<span class="gu">@@ -1,64 +1,454 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.interfaces import HIGH, INFERENCE


<span class="w"> </span>class RecommendationChecker(checkers.BaseChecker):
<span class="gd">-    name = &#39;refactoring&#39;</span>
<span class="gd">-    msgs = {&#39;C0200&#39;: (</span>
<span class="gd">-        &#39;Consider using enumerate instead of iterating with range and len&#39;,</span>
<span class="gd">-        &#39;consider-using-enumerate&#39;,</span>
<span class="gd">-        &#39;Emitted when code that iterates with range and len is encountered. Such code can be simplified by using the enumerate builtin.&#39;</span>
<span class="gd">-        ), &#39;C0201&#39;: (</span>
<span class="gd">-        &#39;Consider iterating the dictionary directly instead of calling .keys()&#39;</span>
<span class="gd">-        , &#39;consider-iterating-dictionary&#39;,</span>
<span class="gd">-        &#39;Emitted when the keys of a dictionary are iterated through the ``.keys()`` method or when ``.keys()`` is used for a membership check. It is enough to iterate through the dictionary itself, ``for key in dictionary``. For membership checks, ``if key in dictionary`` is faster.&#39;</span>
<span class="gd">-        ), &#39;C0206&#39;: (&#39;Consider iterating with .items()&#39;,</span>
<span class="gd">-        &#39;consider-using-dict-items&#39;,</span>
<span class="gd">-        &#39;Emitted when iterating over the keys of a dictionary and accessing the value by index lookup. Both the key and value can be accessed by iterating using the .items() method of the dictionary instead.&#39;</span>
<span class="gd">-        ), &#39;C0207&#39;: (&#39;Use %s instead&#39;, &#39;use-maxsplit-arg&#39;,</span>
<span class="gd">-        &#39;Emitted when accessing only the first or last element of str.split(). The first and last element can be accessed by using str.split(sep, maxsplit=1)[0] or str.rsplit(sep, maxsplit=1)[-1] instead.&#39;</span>
<span class="gd">-        ), &#39;C0208&#39;: (&#39;Use a sequence type when iterating over values&#39;,</span>
<span class="gd">-        &#39;use-sequence-for-iteration&#39;,</span>
<span class="gd">-        &#39;When iterating over values, sequence types (e.g., ``lists``, ``tuples``, ``ranges``) are more efficient than ``sets``.&#39;</span>
<span class="gd">-        ), &#39;C0209&#39;: (</span>
<span class="gd">-        &#39;Formatting a regular string which could be an f-string&#39;,</span>
<span class="gd">-        &#39;consider-using-f-string&#39;,</span>
<span class="gd">-        &#39;Used when we detect a string that is being formatted with format() or % which could potentially be an f-string. The use of f-strings is preferred. Requires Python 3.6 and ``py-version &gt;= 3.6``.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-</span>
<span class="gd">-    def _check_use_maxsplit_arg(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    name = &quot;refactoring&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C0200&quot;: (</span>
<span class="gi">+            &quot;Consider using enumerate instead of iterating with range and len&quot;,</span>
<span class="gi">+            &quot;consider-using-enumerate&quot;,</span>
<span class="gi">+            &quot;Emitted when code that iterates with range and len is &quot;</span>
<span class="gi">+            &quot;encountered. Such code can be simplified by using the &quot;</span>
<span class="gi">+            &quot;enumerate builtin.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0201&quot;: (</span>
<span class="gi">+            &quot;Consider iterating the dictionary directly instead of calling .keys()&quot;,</span>
<span class="gi">+            &quot;consider-iterating-dictionary&quot;,</span>
<span class="gi">+            &quot;Emitted when the keys of a dictionary are iterated through the ``.keys()`` &quot;</span>
<span class="gi">+            &quot;method or when ``.keys()`` is used for a membership check. &quot;</span>
<span class="gi">+            &quot;It is enough to iterate through the dictionary itself, &quot;</span>
<span class="gi">+            &quot;``for key in dictionary``. For membership checks, &quot;</span>
<span class="gi">+            &quot;``if key in dictionary`` is faster.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0206&quot;: (</span>
<span class="gi">+            &quot;Consider iterating with .items()&quot;,</span>
<span class="gi">+            &quot;consider-using-dict-items&quot;,</span>
<span class="gi">+            &quot;Emitted when iterating over the keys of a dictionary and accessing the &quot;</span>
<span class="gi">+            &quot;value by index lookup. &quot;</span>
<span class="gi">+            &quot;Both the key and value can be accessed by iterating using the .items() &quot;</span>
<span class="gi">+            &quot;method of the dictionary instead.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0207&quot;: (</span>
<span class="gi">+            &quot;Use %s instead&quot;,</span>
<span class="gi">+            &quot;use-maxsplit-arg&quot;,</span>
<span class="gi">+            &quot;Emitted when accessing only the first or last element of str.split(). &quot;</span>
<span class="gi">+            &quot;The first and last element can be accessed by using &quot;</span>
<span class="gi">+            &quot;str.split(sep, maxsplit=1)[0] or str.rsplit(sep, maxsplit=1)[-1] &quot;</span>
<span class="gi">+            &quot;instead.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0208&quot;: (</span>
<span class="gi">+            &quot;Use a sequence type when iterating over values&quot;,</span>
<span class="gi">+            &quot;use-sequence-for-iteration&quot;,</span>
<span class="gi">+            &quot;When iterating over values, sequence types (e.g., ``lists``, ``tuples``, ``ranges``) &quot;</span>
<span class="gi">+            &quot;are more efficient than ``sets``.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0209&quot;: (</span>
<span class="gi">+            &quot;Formatting a regular string which could be an f-string&quot;,</span>
<span class="gi">+            &quot;consider-using-f-string&quot;,</span>
<span class="gi">+            &quot;Used when we detect a string that is being formatted with format() or % &quot;</span>
<span class="gi">+            &quot;which could potentially be an f-string. The use of f-strings is preferred. &quot;</span>
<span class="gi">+            &quot;Requires Python 3.6 and ``py-version &gt;= 3.6``.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        py_version = self.linter.config.py_version</span>
<span class="gi">+        self._py36_plus = py_version &gt;= (3, 6)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_builtin(node: nodes.NodeNG, function: str) -&gt; bool:</span>
<span class="gi">+        inferred = utils.safe_infer(node)</span>
<span class="gi">+        if not inferred:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return utils.is_builtin_object(inferred) and inferred.name == function</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;consider-iterating-dictionary&quot;, &quot;use-maxsplit-arg&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        self._check_consider_iterating_dictionary(node)</span>
<span class="gi">+        self._check_use_maxsplit_arg(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_iterating_dictionary(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+            return</span>
<span class="gi">+        if node.func.attrname != &quot;keys&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.parent, nodes.BinOp) and node.parent.op in {&quot;&amp;&quot;, &quot;|&quot;, &quot;^&quot;}:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        comp_ancestor = utils.get_node_first_ancestor_of_type(node, nodes.Compare)</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.parent, (nodes.For, nodes.Comprehension))</span>
<span class="gi">+            or comp_ancestor</span>
<span class="gi">+            and any(</span>
<span class="gi">+                op</span>
<span class="gi">+                for op, comparator in comp_ancestor.ops</span>
<span class="gi">+                if op in {&quot;in&quot;, &quot;not in&quot;}</span>
<span class="gi">+                and (comparator in node.node_ancestors() or comparator is node)</span>
<span class="gi">+            )</span>
<span class="gi">+        ):</span>
<span class="gi">+            inferred = utils.safe_infer(node.func)</span>
<span class="gi">+            if not isinstance(inferred, astroid.BoundMethod) or not isinstance(</span>
<span class="gi">+                inferred.bound, nodes.Dict</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-iterating-dictionary&quot;, node=node, confidence=INFERENCE</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_use_maxsplit_arg(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add message when accessing first or last elements of a str.split() or
<span class="w"> </span>        str.rsplit().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check if call is split() or rsplit()</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(node.func, nodes.Attribute)</span>
<span class="gi">+            and node.func.attrname in {&quot;split&quot;, &quot;rsplit&quot;}</span>
<span class="gi">+            and isinstance(utils.safe_infer(node.func), astroid.BoundMethod)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        inferred_expr = utils.safe_infer(node.func.expr)</span>
<span class="gi">+        if isinstance(inferred_expr, astroid.Instance) and any(</span>
<span class="gi">+            inferred_expr.nodes_of_class(nodes.ClassDef)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        confidence = HIGH</span>
<span class="gi">+        try:</span>
<span class="gi">+            sep = utils.get_argument_from_call(node, 0, &quot;sep&quot;)</span>
<span class="gi">+        except utils.NoSuchArgumentError:</span>
<span class="gi">+            sep = utils.infer_kwarg_from_call(node, keyword=&quot;sep&quot;)</span>
<span class="gi">+            confidence = INFERENCE</span>
<span class="gi">+            if not sep:</span>
<span class="gi">+                return</span>

<span class="gd">-    def _check_consider_using_enumerate(self, node: nodes.For) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Ignore if maxsplit arg has been set</span>
<span class="gi">+            utils.get_argument_from_call(node, 1, &quot;maxsplit&quot;)</span>
<span class="gi">+            return</span>
<span class="gi">+        except utils.NoSuchArgumentError:</span>
<span class="gi">+            if utils.infer_kwarg_from_call(node, keyword=&quot;maxsplit&quot;):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.parent, nodes.Subscript):</span>
<span class="gi">+            try:</span>
<span class="gi">+                subscript_value = utils.get_subscript_const_value(node.parent).value</span>
<span class="gi">+            except utils.InferredTypeError:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Check for cases where variable (Name) subscripts may be mutated within a loop</span>
<span class="gi">+            if isinstance(node.parent.slice, nodes.Name):</span>
<span class="gi">+                # Check if loop present within the scope of the node</span>
<span class="gi">+                scope = node.scope()</span>
<span class="gi">+                for loop_node in scope.nodes_of_class((nodes.For, nodes.While)):</span>
<span class="gi">+                    if not loop_node.parent_of(node):</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    # Check if var is mutated within loop (Assign/AugAssign)</span>
<span class="gi">+                    for assignment_node in loop_node.nodes_of_class(nodes.AugAssign):</span>
<span class="gi">+                        if node.parent.slice.name == assignment_node.target.name:</span>
<span class="gi">+                            return</span>
<span class="gi">+                    for assignment_node in loop_node.nodes_of_class(nodes.Assign):</span>
<span class="gi">+                        if node.parent.slice.name in [</span>
<span class="gi">+                            n.name for n in assignment_node.targets</span>
<span class="gi">+                        ]:</span>
<span class="gi">+                            return</span>
<span class="gi">+</span>
<span class="gi">+            if subscript_value in (-1, 0):</span>
<span class="gi">+                fn_name = node.func.attrname</span>
<span class="gi">+                new_fn = &quot;rsplit&quot; if subscript_value == -1 else &quot;split&quot;</span>
<span class="gi">+                new_name = (</span>
<span class="gi">+                    node.func.as_string().rsplit(fn_name, maxsplit=1)[0]</span>
<span class="gi">+                    + new_fn</span>
<span class="gi">+                    + f&quot;({sep.as_string()}, maxsplit=1)[{subscript_value}]&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;use-maxsplit-arg&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(new_name,),</span>
<span class="gi">+                    confidence=confidence,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;consider-using-enumerate&quot;,</span>
<span class="gi">+        &quot;consider-using-dict-items&quot;,</span>
<span class="gi">+        &quot;use-sequence-for-iteration&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        self._check_consider_using_enumerate(node)</span>
<span class="gi">+        self._check_consider_using_dict_items(node)</span>
<span class="gi">+        self._check_use_sequence_for_iteration(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_using_enumerate(self, node: nodes.For) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit a convention whenever range and len are used for indexing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Verify that we have a `range([start], len(...), [stop])` call and</span>
<span class="gi">+        # that the object which is iterated is used as a subscript in the</span>
<span class="gi">+        # body of the for.</span>
<span class="gi">+</span>
<span class="gi">+        # Is it a proper range call?</span>
<span class="gi">+        if not isinstance(node.iter, nodes.Call):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not self._is_builtin(node.iter.func, &quot;range&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not node.iter.args:</span>
<span class="gi">+            return</span>
<span class="gi">+        is_constant_zero = (</span>
<span class="gi">+            isinstance(node.iter.args[0], nodes.Const) and node.iter.args[0].value == 0</span>
<span class="gi">+        )</span>
<span class="gi">+        if len(node.iter.args) == 2 and not is_constant_zero:</span>
<span class="gi">+            return</span>
<span class="gi">+        if len(node.iter.args) &gt; 2:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Is it a proper len call?</span>
<span class="gi">+        if not isinstance(node.iter.args[-1], nodes.Call):</span>
<span class="gi">+            return</span>
<span class="gi">+        second_func = node.iter.args[-1].func</span>
<span class="gi">+        if not self._is_builtin(second_func, &quot;len&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        len_args = node.iter.args[-1].args</span>
<span class="gi">+        if not len_args or len(len_args) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+        iterating_object = len_args[0]</span>
<span class="gi">+        if isinstance(iterating_object, nodes.Name):</span>
<span class="gi">+            expected_subscript_val_type = nodes.Name</span>
<span class="gi">+        elif isinstance(iterating_object, nodes.Attribute):</span>
<span class="gi">+            expected_subscript_val_type = nodes.Attribute</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+        # If we&#39;re defining __iter__ on self, enumerate won&#39;t work</span>
<span class="gi">+        scope = node.scope()</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(iterating_object, nodes.Name)</span>
<span class="gi">+            and iterating_object.name == &quot;self&quot;</span>
<span class="gi">+            and scope.name == &quot;__iter__&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Verify that the body of the for loop uses a subscript</span>
<span class="gi">+        # with the object that was iterated. This uses some heuristics</span>
<span class="gi">+        # in order to make sure that the same object is used in the</span>
<span class="gi">+        # for body.</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            for subscript in child.nodes_of_class(nodes.Subscript):</span>
<span class="gi">+                if not isinstance(subscript.value, expected_subscript_val_type):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                value = subscript.slice</span>
<span class="gi">+                if not isinstance(value, nodes.Name):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if subscript.value.scope() != node.scope():</span>
<span class="gi">+                    # Ignore this subscript if it&#39;s not in the same</span>
<span class="gi">+                    # scope. This means that in the body of the for</span>
<span class="gi">+                    # loop, another scope was created, where the same</span>
<span class="gi">+                    # name for the iterating object was used.</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if value.name == node.target.name and (</span>
<span class="gi">+                    isinstance(subscript.value, nodes.Name)</span>
<span class="gi">+                    and iterating_object.name == subscript.value.name</span>
<span class="gi">+                    or isinstance(subscript.value, nodes.Attribute)</span>
<span class="gi">+                    and iterating_object.attrname == subscript.value.attrname</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(&quot;consider-using-enumerate&quot;, node=node)</span>
<span class="gi">+                    return</span>

<span class="gd">-    def _check_consider_using_dict_items(self, node: nodes.For) -&gt;None:</span>
<span class="gi">+    def _check_consider_using_dict_items(self, node: nodes.For) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add message when accessing dict values by index lookup.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Verify that we have a .keys() call and</span>
<span class="gi">+        # that the object which is iterated is used as a subscript in the</span>
<span class="gi">+        # body of the for.</span>

<span class="gd">-    def _check_consider_using_dict_items_comprehension(self, node: nodes.</span>
<span class="gd">-        Comprehension) -&gt;None:</span>
<span class="gi">+        iterating_object_name = utils.get_iterating_dictionary_name(node)</span>
<span class="gi">+        if iterating_object_name is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Verify that the body of the for loop uses a subscript</span>
<span class="gi">+        # with the object that was iterated. This uses some heuristics</span>
<span class="gi">+        # in order to make sure that the same object is used in the</span>
<span class="gi">+        # for body.</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            for subscript in child.nodes_of_class(nodes.Subscript):</span>
<span class="gi">+                if not isinstance(subscript.value, (nodes.Name, nodes.Attribute)):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                value = subscript.slice</span>
<span class="gi">+                if (</span>
<span class="gi">+                    not isinstance(value, nodes.Name)</span>
<span class="gi">+                    or value.name != node.target.name</span>
<span class="gi">+                    or iterating_object_name != subscript.value.as_string()</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                last_definition_lineno = value.lookup(value.name)[1][-1].lineno</span>
<span class="gi">+                if last_definition_lineno &gt; node.lineno:</span>
<span class="gi">+                    # Ignore this subscript if it has been redefined after</span>
<span class="gi">+                    # the for loop. This checks for the line number using .lookup()</span>
<span class="gi">+                    # to get the line number where the iterating object was last</span>
<span class="gi">+                    # defined and compare that to the for loop&#39;s line number</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(subscript.parent, nodes.Assign)</span>
<span class="gi">+                    and subscript in subscript.parent.targets</span>
<span class="gi">+                    or isinstance(subscript.parent, nodes.AugAssign)</span>
<span class="gi">+                    and subscript == subscript.parent.target</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Ignore this subscript if it is the target of an assignment</span>
<span class="gi">+                    # Early termination as dict index lookup is necessary</span>
<span class="gi">+                    return</span>
<span class="gi">+                if isinstance(subscript.parent, nodes.Delete):</span>
<span class="gi">+                    # Ignore this subscript if the index is used to delete a</span>
<span class="gi">+                    # dictionary item.</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                self.add_message(&quot;consider-using-dict-items&quot;, node=node)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;consider-using-dict-items&quot;,</span>
<span class="gi">+        &quot;use-sequence-for-iteration&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_comprehension(self, node: nodes.Comprehension) -&gt; None:</span>
<span class="gi">+        self._check_consider_using_dict_items_comprehension(node)</span>
<span class="gi">+        self._check_use_sequence_for_iteration(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_using_dict_items_comprehension(</span>
<span class="gi">+        self, node: nodes.Comprehension</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add message when accessing dict values by index lookup.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        iterating_object_name = utils.get_iterating_dictionary_name(node)</span>
<span class="gi">+        if iterating_object_name is None:</span>
<span class="gi">+            return</span>

<span class="gd">-    def _check_use_sequence_for_iteration(self, node: (nodes.For | nodes.</span>
<span class="gd">-        Comprehension)) -&gt;None:</span>
<span class="gi">+        for child in node.parent.get_children():</span>
<span class="gi">+            for subscript in child.nodes_of_class(nodes.Subscript):</span>
<span class="gi">+                if not isinstance(subscript.value, (nodes.Name, nodes.Attribute)):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                value = subscript.slice</span>
<span class="gi">+                if (</span>
<span class="gi">+                    not isinstance(value, nodes.Name)</span>
<span class="gi">+                    or value.name != node.target.name</span>
<span class="gi">+                    or iterating_object_name != subscript.value.as_string()</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                self.add_message(&quot;consider-using-dict-items&quot;, node=node)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+    def _check_use_sequence_for_iteration(</span>
<span class="gi">+        self, node: nodes.For | nodes.Comprehension</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if code iterates over an in-place defined set.

<span class="w"> </span>        Sets using `*` are not considered in-place.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.iter, nodes.Set) and not any(</span>
<span class="gi">+            utils.has_starred_node_recursive(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;use-sequence-for-iteration&quot;, node=node.iter, confidence=HIGH</span>
<span class="gi">+            )</span>

<span class="gd">-    def _detect_replacable_format_call(self, node: nodes.Const) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;consider-using-f-string&quot;)</span>
<span class="gi">+    def visit_const(self, node: nodes.Const) -&gt; None:</span>
<span class="gi">+        if self._py36_plus:</span>
<span class="gi">+            # f-strings require Python 3.6</span>
<span class="gi">+            if node.pytype() == &quot;builtins.str&quot; and not isinstance(</span>
<span class="gi">+                node.parent, nodes.JoinedStr</span>
<span class="gi">+            ):</span>
<span class="gi">+                self._detect_replacable_format_call(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _detect_replacable_format_call(self, node: nodes.Const) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether a string is used in a call to format() or &#39;%&#39; and whether it
<span class="w"> </span>        can be replaced by an f-string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.parent, nodes.Attribute)</span>
<span class="gi">+            and node.parent.attrname == &quot;format&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Don&#39;t warn on referencing / assigning .format without calling it</span>
<span class="gi">+            if not isinstance(node.parent.parent, nodes.Call):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if node.parent.parent.args:</span>
<span class="gi">+                for arg in node.parent.parent.args:</span>
<span class="gi">+                    # If star expressions with more than 1 element are being used</span>
<span class="gi">+                    if isinstance(arg, nodes.Starred):</span>
<span class="gi">+                        inferred = utils.safe_infer(arg.value)</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            isinstance(inferred, astroid.List)</span>
<span class="gi">+                            and len(inferred.elts) &gt; 1</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            return</span>
<span class="gi">+                    # Backslashes can&#39;t be in f-string expressions</span>
<span class="gi">+                    if &quot;\\&quot; in arg.as_string():</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+            elif node.parent.parent.keywords:</span>
<span class="gi">+                keyword_args = [</span>
<span class="gi">+                    i[0] for i in utils.parse_format_method_string(node.value)[0]</span>
<span class="gi">+                ]</span>
<span class="gi">+                for keyword in node.parent.parent.keywords:</span>
<span class="gi">+                    # If keyword is used multiple times</span>
<span class="gi">+                    if keyword_args.count(keyword.arg) &gt; 1:</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                    keyword = utils.safe_infer(keyword.value)</span>
<span class="gi">+</span>
<span class="gi">+                    # If lists of more than one element are being unpacked</span>
<span class="gi">+                    if isinstance(keyword, nodes.Dict):</span>
<span class="gi">+                        if len(keyword.items) &gt; 1 and len(keyword_args) &gt; 1:</span>
<span class="gi">+                            return</span>
<span class="gi">+</span>
<span class="gi">+            # If all tests pass, then raise message</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-using-f-string&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                line=node.lineno,</span>
<span class="gi">+                col_offset=node.col_offset,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(node.parent, nodes.BinOp) and node.parent.op == &quot;%&quot;:</span>
<span class="gi">+            # Backslashes can&#39;t be in f-string expressions</span>
<span class="gi">+            if &quot;\\&quot; in node.parent.right.as_string():</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # If % applied to another type than str, it&#39;s modulo and can&#39;t be replaced by formatting</span>
<span class="gi">+            if not hasattr(node.parent.left, &quot;value&quot;) or not isinstance(</span>
<span class="gi">+                node.parent.left.value, str</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Brackets can be inconvenient in f-string expressions</span>
<span class="gi">+            if &quot;{&quot; in node.parent.left.value or &quot;}&quot; in node.parent.left.value:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            inferred_right = utils.safe_infer(node.parent.right)</span>
<span class="gi">+</span>
<span class="gi">+            # If dicts or lists of length &gt; 1 are used</span>
<span class="gi">+            if isinstance(inferred_right, nodes.Dict):</span>
<span class="gi">+                if len(inferred_right.items) &gt; 1:</span>
<span class="gi">+                    return</span>
<span class="gi">+            elif isinstance(inferred_right, nodes.List):</span>
<span class="gi">+                if len(inferred_right.elts) &gt; 1:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            # If all tests pass, then raise message</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-using-f-string&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                line=node.lineno,</span>
<span class="gi">+                col_offset=node.col_offset,</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/pylint/checkers/refactoring/refactoring_checker.py b/pylint/checkers/refactoring/refactoring_checker.py</span>
<span class="gh">index bfd096850..8e3dc4919 100644</span>
<span class="gd">--- a/pylint/checkers/refactoring/refactoring_checker.py</span>
<span class="gi">+++ b/pylint/checkers/refactoring/refactoring_checker.py</span>
<span class="gu">@@ -1,4 +1,9 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import copy
<span class="w"> </span>import itertools
<span class="gu">@@ -7,39 +12,73 @@ from collections.abc import Iterator</span>
<span class="w"> </span>from functools import cached_property, reduce
<span class="w"> </span>from re import Pattern
<span class="w"> </span>from typing import TYPE_CHECKING, Any, NamedTuple, Union, cast
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import bases, nodes
<span class="w"> </span>from astroid.util import UninferableBase
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.base.basic_error_checker import _loop_exits_early
<span class="w"> </span>from pylint.checkers.utils import node_frame_class
<span class="w"> </span>from pylint.interfaces import HIGH, INFERENCE, Confidence
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>NodesWithNestedBlocks = Union[nodes.Try, nodes.While, nodes.For, nodes.If]
<span class="gd">-KNOWN_INFINITE_ITERATORS = {&#39;itertools.count&#39;, &#39;itertools.cycle&#39;}</span>
<span class="gd">-BUILTIN_EXIT_FUNCS = frozenset((&#39;quit&#39;, &#39;exit&#39;))</span>
<span class="gd">-CALLS_THAT_COULD_BE_REPLACED_BY_WITH = frozenset((&#39;threading.lock.acquire&#39;,</span>
<span class="gd">-    &#39;threading._RLock.acquire&#39;, &#39;threading.Semaphore.acquire&#39;,</span>
<span class="gd">-    &#39;multiprocessing.managers.BaseManager.start&#39;,</span>
<span class="gd">-    &#39;multiprocessing.managers.SyncManager.start&#39;))</span>
<span class="gd">-CALLS_RETURNING_CONTEXT_MANAGERS = frozenset((&#39;_io.open&#39;,</span>
<span class="gd">-    &#39;pathlib.Path.open&#39;, &#39;codecs.open&#39;, &#39;urllib.request.urlopen&#39;,</span>
<span class="gd">-    &#39;tempfile.NamedTemporaryFile&#39;, &#39;tempfile.SpooledTemporaryFile&#39;,</span>
<span class="gd">-    &#39;tempfile.TemporaryDirectory&#39;, &#39;tempfile.TemporaryFile&#39;,</span>
<span class="gd">-    &#39;zipfile.ZipFile&#39;, &#39;zipfile.PyZipFile&#39;, &#39;zipfile.ZipFile.open&#39;,</span>
<span class="gd">-    &#39;zipfile.PyZipFile.open&#39;, &#39;tarfile.TarFile&#39;, &#39;tarfile.TarFile.open&#39;,</span>
<span class="gd">-    &#39;multiprocessing.context.BaseContext.Pool&#39;, &#39;subprocess.Popen&#39;))</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _except_statement_is_always_returning(node: nodes.Try,</span>
<span class="gd">-    returning_node_class: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+KNOWN_INFINITE_ITERATORS = {&quot;itertools.count&quot;, &quot;itertools.cycle&quot;}</span>
<span class="gi">+BUILTIN_EXIT_FUNCS = frozenset((&quot;quit&quot;, &quot;exit&quot;))</span>
<span class="gi">+CALLS_THAT_COULD_BE_REPLACED_BY_WITH = frozenset(</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;threading.lock.acquire&quot;,</span>
<span class="gi">+        &quot;threading._RLock.acquire&quot;,</span>
<span class="gi">+        &quot;threading.Semaphore.acquire&quot;,</span>
<span class="gi">+        &quot;multiprocessing.managers.BaseManager.start&quot;,</span>
<span class="gi">+        &quot;multiprocessing.managers.SyncManager.start&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+)</span>
<span class="gi">+CALLS_RETURNING_CONTEXT_MANAGERS = frozenset(</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;_io.open&quot;,  # regular &#39;open()&#39; call</span>
<span class="gi">+        &quot;pathlib.Path.open&quot;,</span>
<span class="gi">+        &quot;codecs.open&quot;,</span>
<span class="gi">+        &quot;urllib.request.urlopen&quot;,</span>
<span class="gi">+        &quot;tempfile.NamedTemporaryFile&quot;,</span>
<span class="gi">+        &quot;tempfile.SpooledTemporaryFile&quot;,</span>
<span class="gi">+        &quot;tempfile.TemporaryDirectory&quot;,</span>
<span class="gi">+        &quot;tempfile.TemporaryFile&quot;,</span>
<span class="gi">+        &quot;zipfile.ZipFile&quot;,</span>
<span class="gi">+        &quot;zipfile.PyZipFile&quot;,</span>
<span class="gi">+        &quot;zipfile.ZipFile.open&quot;,</span>
<span class="gi">+        &quot;zipfile.PyZipFile.open&quot;,</span>
<span class="gi">+        &quot;tarfile.TarFile&quot;,</span>
<span class="gi">+        &quot;tarfile.TarFile.open&quot;,</span>
<span class="gi">+        &quot;multiprocessing.context.BaseContext.Pool&quot;,</span>
<span class="gi">+        &quot;subprocess.Popen&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _if_statement_is_always_returning(</span>
<span class="gi">+    if_node: nodes.If, returning_node_class: nodes.NodeNG</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    return any(isinstance(node, returning_node_class) for node in if_node.body)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _except_statement_is_always_returning(</span>
<span class="gi">+    node: nodes.Try, returning_node_class: nodes.NodeNG</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Detect if all except statements return.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return all(</span>
<span class="gi">+        any(isinstance(child, returning_node_class) for child in handler.body)</span>
<span class="gi">+        for handler in node.handlers</span>
<span class="gi">+    )</span>


<span class="gd">-def _is_trailing_comma(tokens: list[tokenize.TokenInfo], index: int) -&gt;bool:</span>
<span class="gi">+def _is_trailing_comma(tokens: list[tokenize.TokenInfo], index: int) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given token is a trailing comma.

<span class="w"> </span>    :param tokens: Sequence of modules tokens
<span class="gu">@@ -48,52 +87,139 @@ def _is_trailing_comma(tokens: list[tokenize.TokenInfo], index: int) -&gt;bool:</span>
<span class="w"> </span>    :returns: True if the token is a comma which trails an expression
<span class="w"> </span>    :rtype: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _is_part_of_with_items(node: nodes.Call) -&gt;bool:</span>
<span class="gi">+    token = tokens[index]</span>
<span class="gi">+    if token.exact_type != tokenize.COMMA:</span>
<span class="gi">+        return False</span>
<span class="gi">+    # Must have remaining tokens on the same line such as NEWLINE</span>
<span class="gi">+    left_tokens = itertools.islice(tokens, index + 1, None)</span>
<span class="gi">+</span>
<span class="gi">+    more_tokens_on_line = False</span>
<span class="gi">+    for remaining_token in left_tokens:</span>
<span class="gi">+        if remaining_token.start[0] == token.start[0]:</span>
<span class="gi">+            more_tokens_on_line = True</span>
<span class="gi">+            # If one of the remaining same line tokens is not NEWLINE or COMMENT</span>
<span class="gi">+            # the comma is not trailing.</span>
<span class="gi">+            if remaining_token.type not in (tokenize.NEWLINE, tokenize.COMMENT):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+    if not more_tokens_on_line:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def get_curline_index_start() -&gt; int:</span>
<span class="gi">+        &quot;&quot;&quot;Get the index denoting the start of the current line.&quot;&quot;&quot;</span>
<span class="gi">+        for subindex, token in enumerate(reversed(tokens[:index])):</span>
<span class="gi">+            # See Lib/tokenize.py and Lib/token.py in cpython for more info</span>
<span class="gi">+            if token.type == tokenize.NEWLINE:</span>
<span class="gi">+                return index - subindex</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    curline_start = get_curline_index_start()</span>
<span class="gi">+    expected_tokens = {&quot;return&quot;, &quot;yield&quot;}</span>
<span class="gi">+    return any(</span>
<span class="gi">+        &quot;=&quot; in prevtoken.string or prevtoken.string in expected_tokens</span>
<span class="gi">+        for prevtoken in tokens[curline_start:index]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_inside_context_manager(node: nodes.Call) -&gt; bool:</span>
<span class="gi">+    frame = node.frame()</span>
<span class="gi">+    if not isinstance(</span>
<span class="gi">+        frame, (nodes.FunctionDef, astroid.BoundMethod, astroid.UnboundMethod)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return frame.name == &quot;__enter__&quot; or utils.decorated_with(</span>
<span class="gi">+        frame, &quot;contextlib.contextmanager&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_a_return_statement(node: nodes.Call) -&gt; bool:</span>
<span class="gi">+    frame = node.frame()</span>
<span class="gi">+    for parent in node.node_ancestors():</span>
<span class="gi">+        if parent is frame:</span>
<span class="gi">+            break</span>
<span class="gi">+        if isinstance(parent, nodes.Return):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_part_of_with_items(node: nodes.Call) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if one of the node&#39;s parents is a ``nodes.With`` node and that the node
<span class="w"> </span>    itself is located somewhere under its ``items``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _will_be_released_automatically(node: nodes.Call) -&gt;bool:</span>
<span class="gi">+    frame = node.frame()</span>
<span class="gi">+    current = node</span>
<span class="gi">+    while current != frame:</span>
<span class="gi">+        if isinstance(current, nodes.With):</span>
<span class="gi">+            items_start = current.items[0][0].lineno</span>
<span class="gi">+            items_end = current.items[-1][0].tolineno</span>
<span class="gi">+            return items_start &lt;= node.lineno &lt;= items_end  # type: ignore[no-any-return]</span>
<span class="gi">+        current = current.parent</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _will_be_released_automatically(node: nodes.Call) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if a call that could be used in a ``with`` statement is used in an
<span class="w"> </span>    alternative construct which would ensure that its __exit__ method is called.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _is_part_of_assignment_target(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    callables_taking_care_of_exit = frozenset(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;contextlib._BaseExitStack.enter_context&quot;,</span>
<span class="gi">+            &quot;contextlib.ExitStack.enter_context&quot;,  # necessary for Python 3.6 compatibility</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+    if not isinstance(node.parent, nodes.Call):</span>
<span class="gi">+        return False</span>
<span class="gi">+    func = utils.safe_infer(node.parent.func)</span>
<span class="gi">+    if not func:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return func.qname() in callables_taking_care_of_exit</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_part_of_assignment_target(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check whether use of a variable is happening as part of the left-hand
<span class="w"> </span>    side of an assignment.

<span class="w"> </span>    This requires recursive checking, because destructuring assignment can have
<span class="w"> </span>    arbitrarily nested tuples and lists to unpack.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node.parent, nodes.Assign):</span>
<span class="gi">+        return node in node.parent.targets</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(node.parent, nodes.AugAssign):</span>
<span class="gi">+        return node == node.parent.target  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(node.parent, (nodes.Tuple, nodes.List)):</span>
<span class="gi">+        return _is_part_of_assignment_target(node.parent)</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class ConsiderUsingWithStack(NamedTuple):
<span class="w"> </span>    &quot;&quot;&quot;Stack for objects that may potentially trigger a R1732 message
<span class="w"> </span>    if they are not used in a ``with`` block later on.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    module_scope: dict[str, nodes.NodeNG] = {}
<span class="w"> </span>    class_scope: dict[str, nodes.NodeNG] = {}
<span class="w"> </span>    function_scope: dict[str, nodes.NodeNG] = {}

<span class="gd">-    def __iter__(self) -&gt;Iterator[dict[str, nodes.NodeNG]]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[dict[str, nodes.NodeNG]]:</span>
<span class="w"> </span>        yield from (self.function_scope, self.class_scope, self.module_scope)

<span class="gd">-    def get_stack_for_frame(self, frame: (nodes.FunctionDef | nodes.</span>
<span class="gd">-        ClassDef | nodes.Module)) -&gt;dict[str, nodes.NodeNG]:</span>
<span class="gi">+    def get_stack_for_frame(</span>
<span class="gi">+        self, frame: nodes.FunctionDef | nodes.ClassDef | nodes.Module</span>
<span class="gi">+    ) -&gt; dict[str, nodes.NodeNG]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the stack corresponding to the scope of the given frame.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(frame, nodes.FunctionDef):</span>
<span class="gi">+            return self.function_scope</span>
<span class="gi">+        if isinstance(frame, nodes.ClassDef):</span>
<span class="gi">+            return self.class_scope</span>
<span class="gi">+        return self.module_scope</span>

<span class="gd">-    def clear_all(self) -&gt;None:</span>
<span class="gi">+    def clear_all(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convenience method to clear all stacks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for stack in self:</span>
<span class="gi">+            stack.clear()</span>


<span class="w"> </span>class RefactoringChecker(checkers.BaseTokenChecker):
<span class="gu">@@ -103,143 +229,305 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>    in order to create knowledge about whether an &quot;else if&quot; node
<span class="w"> </span>    is a true &quot;else if&quot; node, or an &quot;elif&quot; node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;refactoring&#39;</span>
<span class="gd">-    msgs = {&#39;R1701&#39;: (</span>
<span class="gd">-        &#39;Consider merging these isinstance calls to isinstance(%s, (%s))&#39;,</span>
<span class="gd">-        &#39;consider-merging-isinstance&#39;,</span>
<span class="gd">-        &#39;Used when multiple consecutive isinstance calls can be merged into one.&#39;</span>
<span class="gd">-        ), &#39;R1706&#39;: (&#39;Consider using ternary (%s)&#39;,</span>
<span class="gd">-        &#39;consider-using-ternary&#39;,</span>
<span class="gd">-        &#39;Used when one of known pre-python 2.5 ternary syntax is used.&#39;),</span>
<span class="gd">-        &#39;R1709&#39;: (&#39;Boolean expression may be simplified to %s&#39;,</span>
<span class="gd">-        &#39;simplify-boolean-expression&#39;,</span>
<span class="gd">-        &#39;Emitted when redundant pre-python 2.5 ternary syntax is used.&#39;),</span>
<span class="gd">-        &#39;R1726&#39;: (&#39;Boolean condition &quot;%s&quot; may be simplified to &quot;%s&quot;&#39;,</span>
<span class="gd">-        &#39;simplifiable-condition&#39;,</span>
<span class="gd">-        &#39;Emitted when a boolean condition is able to be simplified.&#39;),</span>
<span class="gd">-        &#39;R1727&#39;: (&quot;Boolean condition &#39;%s&#39; will always evaluate to &#39;%s&#39;&quot;,</span>
<span class="gd">-        &#39;condition-evals-to-constant&#39;,</span>
<span class="gd">-        &#39;Emitted when a boolean condition can be simplified to a constant value.&#39;</span>
<span class="gd">-        ), &#39;R1702&#39;: (&#39;Too many nested blocks (%s/%s)&#39;,</span>
<span class="gd">-        &#39;too-many-nested-blocks&#39;,</span>
<span class="gd">-        &#39;Used when a function or a method has too many nested blocks. This makes the code less understandable and maintainable.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;R0101&#39;, &#39;old-too-many-nested-blocks&#39;)]}),</span>
<span class="gd">-        &#39;R1703&#39;: (&#39;The if statement can be replaced with %s&#39;,</span>
<span class="gd">-        &#39;simplifiable-if-statement&#39;,</span>
<span class="gd">-        &quot;Used when an if statement can be replaced with &#39;bool(test)&#39;.&quot;, {</span>
<span class="gd">-        &#39;old_names&#39;: [(&#39;R0102&#39;, &#39;old-simplifiable-if-statement&#39;)]}),</span>
<span class="gd">-        &#39;R1704&#39;: (&#39;Redefining argument with the local name %r&#39;,</span>
<span class="gd">-        &#39;redefined-argument-from-local&#39;,</span>
<span class="gd">-        &#39;Used when a local name is redefining an argument, which might suggest a potential error. This is taken in account only for a handful of name binding operations, such as for iteration, with statement assignment and exception handler assignment.&#39;</span>
<span class="gd">-        ), &#39;R1705&#39;: (&#39;Unnecessary &quot;%s&quot; after &quot;return&quot;, %s&#39;,</span>
<span class="gd">-        &#39;no-else-return&#39;,</span>
<span class="gd">-        &#39;Used in order to highlight an unnecessary block of code following an if containing a return statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a return statement.&#39;</span>
<span class="gd">-        ), &#39;R1707&#39;: (&#39;Disallow trailing comma tuple&#39;,</span>
<span class="gd">-        &#39;trailing-comma-tuple&#39;,</span>
<span class="gd">-        &#39;In Python, a tuple is actually created by the comma symbol, not by the parentheses. Unfortunately, one can actually create a tuple by misplacing a trailing comma, which can lead to potential weird bugs in your code. You should always use parentheses explicitly for creating a tuple.&#39;</span>
<span class="gd">-        ), &#39;R1708&#39;: (</span>
<span class="gd">-        &#39;Do not raise StopIteration in generator, use return statement instead&#39;</span>
<span class="gd">-        , &#39;stop-iteration-return&#39;,</span>
<span class="gd">-        &#39;According to PEP479, the raise of StopIteration to end the loop of a generator may lead to hard to find bugs. This PEP specify that raise StopIteration has to be replaced by a simple return statement&#39;</span>
<span class="gd">-        ), &#39;R1710&#39;: (</span>
<span class="gd">-        &#39;Either all return statements in a function should return an expression, or none of them should.&#39;</span>
<span class="gd">-        , &#39;inconsistent-return-statements&#39;,</span>
<span class="gd">-        &#39;According to PEP8, if any return statement returns an expression, any return statements where no value is returned should explicitly state this as return None, and an explicit return statement should be present at the end of the function (if reachable)&#39;</span>
<span class="gd">-        ), &#39;R1711&#39;: (&#39;Useless return at end of function or method&#39;,</span>
<span class="gd">-        &#39;useless-return&#39;,</span>
<span class="gd">-        &#39;Emitted when a single &quot;return&quot; or &quot;return None&quot; statement is found at the end of function or method definition. This statement can safely be removed because Python will implicitly return None&#39;</span>
<span class="gd">-        ), &#39;R1712&#39;: (</span>
<span class="gd">-        &#39;Consider using tuple unpacking for swapping variables&#39;,</span>
<span class="gd">-        &#39;consider-swap-variables&#39;,</span>
<span class="gd">-        &#39;You do not have to use a temporary variable in order to swap variables. Using &quot;tuple unpacking&quot; to directly swap variables makes the intention more clear.&#39;</span>
<span class="gd">-        ), &#39;R1713&#39;: (</span>
<span class="gd">-        &#39;Consider using str.join(sequence) for concatenating strings from an iterable&#39;</span>
<span class="gd">-        , &#39;consider-using-join&#39;,</span>
<span class="gd">-        &#39;Using str.join(sequence) is faster, uses less memory and increases readability compared to for-loop iteration.&#39;</span>
<span class="gd">-        ), &#39;R1714&#39;: (</span>
<span class="gd">-        &quot;Consider merging these comparisons with &#39;in&#39; by using &#39;%s %sin (%s)&#39;. Use a set instead if elements are hashable.&quot;</span>
<span class="gd">-        , &#39;consider-using-in&#39;,</span>
<span class="gd">-        &#39;To check if a variable is equal to one of many values, combine the values into a set or tuple and check if the variable is contained &quot;in&quot; it instead of checking for equality against each of the values. This is faster and less verbose.&#39;</span>
<span class="gd">-        ), &#39;R1715&#39;: (</span>
<span class="gd">-        &#39;Consider using dict.get for getting values from a dict if a key is present or a default if not&#39;</span>
<span class="gd">-        , &#39;consider-using-get&#39;,</span>
<span class="gd">-        &#39;Using the builtin dict.get for getting a value from a dictionary if a key is present or a default if not, is simpler and considered more idiomatic, although sometimes a bit slower&#39;</span>
<span class="gd">-        ), &#39;R1716&#39;: (&#39;Simplify chained comparison between the operands&#39;,</span>
<span class="gd">-        &#39;chained-comparison&#39;,</span>
<span class="gd">-        &#39;This message is emitted when pylint encounters boolean operation like &quot;a &lt; b and b &lt; c&quot;, suggesting instead to refactor it to &quot;a &lt; b &lt; c&quot;&#39;</span>
<span class="gd">-        ), &#39;R1717&#39;: (&#39;Consider using a dictionary comprehension&#39;,</span>
<span class="gd">-        &#39;consider-using-dict-comprehension&#39;,</span>
<span class="gd">-        &quot;Emitted when we detect the creation of a dictionary using the dict() callable and a transient list. Although there is nothing syntactically wrong with this code, it is hard to read and can be simplified to a dict comprehension. Also it is faster since you don&#39;t need to create another transient list&quot;</span>
<span class="gd">-        ), &#39;R1718&#39;: (&#39;Consider using a set comprehension&#39;,</span>
<span class="gd">-        &#39;consider-using-set-comprehension&#39;,</span>
<span class="gd">-        &quot;Although there is nothing syntactically wrong with this code, it is hard to read and can be simplified to a set comprehension. Also it is faster since you don&#39;t need to create another transient list&quot;</span>
<span class="gd">-        ), &#39;R1719&#39;: (&#39;The if expression can be replaced with %s&#39;,</span>
<span class="gd">-        &#39;simplifiable-if-expression&#39;,</span>
<span class="gd">-        &quot;Used when an if expression can be replaced with &#39;bool(test)&#39; or simply &#39;test&#39; if the boolean cast is implicit.&quot;</span>
<span class="gd">-        ), &#39;R1720&#39;: (&#39;Unnecessary &quot;%s&quot; after &quot;raise&quot;, %s&#39;, &#39;no-else-raise&#39;,</span>
<span class="gd">-        &#39;Used in order to highlight an unnecessary block of code following an if containing a raise statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a raise statement.&#39;</span>
<span class="gd">-        ), &#39;R1721&#39;: (&#39;Unnecessary use of a comprehension, use %s instead.&#39;,</span>
<span class="gd">-        &#39;unnecessary-comprehension&#39;,</span>
<span class="gd">-        &#39;Instead of using an identity comprehension, consider using the list, dict or set constructor. It is faster and simpler.&#39;</span>
<span class="gd">-        ), &#39;R1722&#39;: (&quot;Consider using &#39;sys.exit&#39; instead&quot;,</span>
<span class="gd">-        &#39;consider-using-sys-exit&#39;,</span>
<span class="gd">-        &quot;Contrary to &#39;exit()&#39; or &#39;quit()&#39;, &#39;sys.exit&#39; does not rely on the site module being available (as the &#39;sys&#39; module is always available).&quot;</span>
<span class="gd">-        ), &#39;R1723&#39;: (&#39;Unnecessary &quot;%s&quot; after &quot;break&quot;, %s&#39;, &#39;no-else-break&#39;,</span>
<span class="gd">-        &#39;Used in order to highlight an unnecessary block of code following an if containing a break statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a break statement.&#39;</span>
<span class="gd">-        ), &#39;R1724&#39;: (&#39;Unnecessary &quot;%s&quot; after &quot;continue&quot;, %s&#39;,</span>
<span class="gd">-        &#39;no-else-continue&#39;,</span>
<span class="gd">-        &#39;Used in order to highlight an unnecessary block of code following an if containing a continue statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a continue statement.&#39;</span>
<span class="gd">-        ), &#39;R1725&#39;: (</span>
<span class="gd">-        &#39;Consider using Python 3 style super() without arguments&#39;,</span>
<span class="gd">-        &#39;super-with-arguments&#39;,</span>
<span class="gd">-        &#39;Emitted when calling the super() builtin with the current class and instance. On Python 3 these arguments are the default and they can be omitted.&#39;</span>
<span class="gd">-        ), &#39;R1728&#39;: (&quot;Consider using a generator instead &#39;%s(%s)&#39;&quot;,</span>
<span class="gd">-        &#39;consider-using-generator&#39;,</span>
<span class="gd">-        &#39;If your container can be large using a generator will bring better performance.&#39;</span>
<span class="gd">-        ), &#39;R1729&#39;: (&quot;Use a generator instead &#39;%s(%s)&#39;&quot;, &#39;use-a-generator&#39;,</span>
<span class="gd">-        &quot;Comprehension inside of &#39;any&#39;, &#39;all&#39;, &#39;max&#39;, &#39;min&#39; or &#39;sum&#39; is unnecessary. A generator would be sufficient and faster.&quot;</span>
<span class="gd">-        ), &#39;R1730&#39;: (&quot;Consider using &#39;%s&#39; instead of unnecessary if block&quot;,</span>
<span class="gd">-        &#39;consider-using-min-builtin&#39;,</span>
<span class="gd">-        &#39;Using the min builtin instead of a conditional improves readability and conciseness.&#39;</span>
<span class="gd">-        ), &#39;R1731&#39;: (&quot;Consider using &#39;%s&#39; instead of unnecessary if block&quot;,</span>
<span class="gd">-        &#39;consider-using-max-builtin&#39;,</span>
<span class="gd">-        &#39;Using the max builtin instead of a conditional improves readability and conciseness.&#39;</span>
<span class="gd">-        ), &#39;R1732&#39;: (</span>
<span class="gd">-        &quot;Consider using &#39;with&#39; for resource-allocating operations&quot;,</span>
<span class="gd">-        &#39;consider-using-with&#39;,</span>
<span class="gd">-        &quot;Emitted if a resource-allocating assignment or call may be replaced by a &#39;with&#39; block. By using &#39;with&#39; the release of the allocated resources is ensured even in the case of an exception.&quot;</span>
<span class="gd">-        ), &#39;R1733&#39;: (</span>
<span class="gd">-        &quot;Unnecessary dictionary index lookup, use &#39;%s&#39; instead&quot;,</span>
<span class="gd">-        &#39;unnecessary-dict-index-lookup&#39;,</span>
<span class="gd">-        &#39;Emitted when iterating over the dictionary items (key-item pairs) and accessing the value by index lookup. The value can be accessed directly instead.&#39;</span>
<span class="gd">-        ), &#39;R1734&#39;: (&#39;Consider using [] instead of list()&#39;,</span>
<span class="gd">-        &#39;use-list-literal&#39;,</span>
<span class="gd">-        &#39;Emitted when using list() to create an empty list instead of the literal []. The literal is faster as it avoids an additional function call.&#39;</span>
<span class="gd">-        ), &#39;R1735&#39;: (&quot;Consider using &#39;%s&#39; instead of a call to &#39;dict&#39;.&quot;,</span>
<span class="gd">-        &#39;use-dict-literal&#39;,</span>
<span class="gd">-        &quot;Emitted when using dict() to create a dictionary instead of a literal &#39;{ ... }&#39;. The literal is faster as it avoids an additional function call.&quot;</span>
<span class="gd">-        ), &#39;R1736&#39;: (&quot;Unnecessary list index lookup, use &#39;%s&#39; instead&quot;,</span>
<span class="gd">-        &#39;unnecessary-list-index-lookup&#39;,</span>
<span class="gd">-        &#39;Emitted when iterating over an enumeration and accessing the value by index lookup. The value can be accessed directly instead.&#39;</span>
<span class="gd">-        ), &#39;R1737&#39;: (</span>
<span class="gd">-        &quot;Use &#39;yield from&#39; directly instead of yielding each element one by one&quot;</span>
<span class="gd">-        , &#39;use-yield-from&#39;,</span>
<span class="gd">-        &#39;Yielding directly from the iterator is faster and arguably cleaner code than yielding each element one by one in the loop.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-    options = (&#39;max-nested-blocks&#39;, {&#39;default&#39;: 5, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;int&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Maximum number of nested blocks for function / method body&#39;}), (</span>
<span class="gd">-        &#39;never-returning-functions&#39;, {&#39;default&#39;: (&#39;sys.exit&#39;,</span>
<span class="gd">-        &#39;argparse.parse_error&#39;), &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;members names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Complete name of functions that never returns. When checking for inconsistent-return-statements if a never returning function is called then it will be considered as an explicit return statement and no message will be printed.&#39;</span>
<span class="gd">-        }), (&#39;suggest-join-with-non-empty-separator&#39;, {&#39;default&#39;: True,</span>
<span class="gd">-        &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &quot;&quot;&quot;Let &#39;consider-using-join&#39; be raised when the separator to join on would be non-empty (resulting in expected fixes of the type: ``&quot;- &quot; + &quot;</span>
<span class="gd">-- &quot;.join(items)``)&quot;&quot;&quot;</span>
<span class="gd">-        })</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;refactoring&quot;</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R1701&quot;: (</span>
<span class="gi">+            &quot;Consider merging these isinstance calls to isinstance(%s, (%s))&quot;,</span>
<span class="gi">+            &quot;consider-merging-isinstance&quot;,</span>
<span class="gi">+            &quot;Used when multiple consecutive isinstance calls can be merged into one.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1706&quot;: (</span>
<span class="gi">+            &quot;Consider using ternary (%s)&quot;,</span>
<span class="gi">+            &quot;consider-using-ternary&quot;,</span>
<span class="gi">+            &quot;Used when one of known pre-python 2.5 ternary syntax is used.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1709&quot;: (</span>
<span class="gi">+            &quot;Boolean expression may be simplified to %s&quot;,</span>
<span class="gi">+            &quot;simplify-boolean-expression&quot;,</span>
<span class="gi">+            &quot;Emitted when redundant pre-python 2.5 ternary syntax is used.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1726&quot;: (</span>
<span class="gi">+            &#39;Boolean condition &quot;%s&quot; may be simplified to &quot;%s&quot;&#39;,</span>
<span class="gi">+            &quot;simplifiable-condition&quot;,</span>
<span class="gi">+            &quot;Emitted when a boolean condition is able to be simplified.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1727&quot;: (</span>
<span class="gi">+            &quot;Boolean condition &#39;%s&#39; will always evaluate to &#39;%s&#39;&quot;,</span>
<span class="gi">+            &quot;condition-evals-to-constant&quot;,</span>
<span class="gi">+            &quot;Emitted when a boolean condition can be simplified to a constant value.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1702&quot;: (</span>
<span class="gi">+            &quot;Too many nested blocks (%s/%s)&quot;,</span>
<span class="gi">+            &quot;too-many-nested-blocks&quot;,</span>
<span class="gi">+            &quot;Used when a function or a method has too many nested &quot;</span>
<span class="gi">+            &quot;blocks. This makes the code less understandable and &quot;</span>
<span class="gi">+            &quot;maintainable.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;R0101&quot;, &quot;old-too-many-nested-blocks&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1703&quot;: (</span>
<span class="gi">+            &quot;The if statement can be replaced with %s&quot;,</span>
<span class="gi">+            &quot;simplifiable-if-statement&quot;,</span>
<span class="gi">+            &quot;Used when an if statement can be replaced with &#39;bool(test)&#39;.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;R0102&quot;, &quot;old-simplifiable-if-statement&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1704&quot;: (</span>
<span class="gi">+            &quot;Redefining argument with the local name %r&quot;,</span>
<span class="gi">+            &quot;redefined-argument-from-local&quot;,</span>
<span class="gi">+            &quot;Used when a local name is redefining an argument, which might &quot;</span>
<span class="gi">+            &quot;suggest a potential error. This is taken in account only for &quot;</span>
<span class="gi">+            &quot;a handful of name binding operations, such as for iteration, &quot;</span>
<span class="gi">+            &quot;with statement assignment and exception handler assignment.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1705&quot;: (</span>
<span class="gi">+            &#39;Unnecessary &quot;%s&quot; after &quot;return&quot;, %s&#39;,</span>
<span class="gi">+            &quot;no-else-return&quot;,</span>
<span class="gi">+            &quot;Used in order to highlight an unnecessary block of &quot;</span>
<span class="gi">+            &quot;code following an if containing a return statement. &quot;</span>
<span class="gi">+            &quot;As such, it will warn when it encounters an else &quot;</span>
<span class="gi">+            &quot;following a chain of ifs, all of them containing a &quot;</span>
<span class="gi">+            &quot;return statement.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1707&quot;: (</span>
<span class="gi">+            &quot;Disallow trailing comma tuple&quot;,</span>
<span class="gi">+            &quot;trailing-comma-tuple&quot;,</span>
<span class="gi">+            &quot;In Python, a tuple is actually created by the comma symbol, &quot;</span>
<span class="gi">+            &quot;not by the parentheses. Unfortunately, one can actually create a &quot;</span>
<span class="gi">+            &quot;tuple by misplacing a trailing comma, which can lead to potential &quot;</span>
<span class="gi">+            &quot;weird bugs in your code. You should always use parentheses &quot;</span>
<span class="gi">+            &quot;explicitly for creating a tuple.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1708&quot;: (</span>
<span class="gi">+            &quot;Do not raise StopIteration in generator, use return statement instead&quot;,</span>
<span class="gi">+            &quot;stop-iteration-return&quot;,</span>
<span class="gi">+            &quot;According to PEP479, the raise of StopIteration to end the loop of &quot;</span>
<span class="gi">+            &quot;a generator may lead to hard to find bugs. This PEP specify that &quot;</span>
<span class="gi">+            &quot;raise StopIteration has to be replaced by a simple return statement&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1710&quot;: (</span>
<span class="gi">+            &quot;Either all return statements in a function should return an expression, &quot;</span>
<span class="gi">+            &quot;or none of them should.&quot;,</span>
<span class="gi">+            &quot;inconsistent-return-statements&quot;,</span>
<span class="gi">+            &quot;According to PEP8, if any return statement returns an expression, &quot;</span>
<span class="gi">+            &quot;any return statements where no value is returned should explicitly &quot;</span>
<span class="gi">+            &quot;state this as return None, and an explicit return statement &quot;</span>
<span class="gi">+            &quot;should be present at the end of the function (if reachable)&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1711&quot;: (</span>
<span class="gi">+            &quot;Useless return at end of function or method&quot;,</span>
<span class="gi">+            &quot;useless-return&quot;,</span>
<span class="gi">+            &#39;Emitted when a single &quot;return&quot; or &quot;return None&quot; statement is found &#39;</span>
<span class="gi">+            &quot;at the end of function or method definition. This statement can safely be &quot;</span>
<span class="gi">+            &quot;removed because Python will implicitly return None&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1712&quot;: (</span>
<span class="gi">+            &quot;Consider using tuple unpacking for swapping variables&quot;,</span>
<span class="gi">+            &quot;consider-swap-variables&quot;,</span>
<span class="gi">+            &quot;You do not have to use a temporary variable in order to &quot;</span>
<span class="gi">+            &#39;swap variables. Using &quot;tuple unpacking&quot; to directly swap &#39;</span>
<span class="gi">+            &quot;variables makes the intention more clear.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1713&quot;: (</span>
<span class="gi">+            &quot;Consider using str.join(sequence) for concatenating &quot;</span>
<span class="gi">+            &quot;strings from an iterable&quot;,</span>
<span class="gi">+            &quot;consider-using-join&quot;,</span>
<span class="gi">+            &quot;Using str.join(sequence) is faster, uses less memory &quot;</span>
<span class="gi">+            &quot;and increases readability compared to for-loop iteration.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1714&quot;: (</span>
<span class="gi">+            &quot;Consider merging these comparisons with &#39;in&#39; by using &#39;%s %sin (%s)&#39;.&quot;</span>
<span class="gi">+            &quot; Use a set instead if elements are hashable.&quot;,</span>
<span class="gi">+            &quot;consider-using-in&quot;,</span>
<span class="gi">+            &quot;To check if a variable is equal to one of many values, &quot;</span>
<span class="gi">+            &#39;combine the values into a set or tuple and check if the variable is contained &quot;in&quot; it &#39;</span>
<span class="gi">+            &quot;instead of checking for equality against each of the values. &quot;</span>
<span class="gi">+            &quot;This is faster and less verbose.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1715&quot;: (</span>
<span class="gi">+            &quot;Consider using dict.get for getting values from a dict &quot;</span>
<span class="gi">+            &quot;if a key is present or a default if not&quot;,</span>
<span class="gi">+            &quot;consider-using-get&quot;,</span>
<span class="gi">+            &quot;Using the builtin dict.get for getting a value from a dictionary &quot;</span>
<span class="gi">+            &quot;if a key is present or a default if not, is simpler and considered &quot;</span>
<span class="gi">+            &quot;more idiomatic, although sometimes a bit slower&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1716&quot;: (</span>
<span class="gi">+            &quot;Simplify chained comparison between the operands&quot;,</span>
<span class="gi">+            &quot;chained-comparison&quot;,</span>
<span class="gi">+            &quot;This message is emitted when pylint encounters boolean operation like &quot;</span>
<span class="gi">+            &#39;&quot;a &lt; b and b &lt; c&quot;, suggesting instead to refactor it to &quot;a &lt; b &lt; c&quot;&#39;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1717&quot;: (</span>
<span class="gi">+            &quot;Consider using a dictionary comprehension&quot;,</span>
<span class="gi">+            &quot;consider-using-dict-comprehension&quot;,</span>
<span class="gi">+            &quot;Emitted when we detect the creation of a dictionary &quot;</span>
<span class="gi">+            &quot;using the dict() callable and a transient list. &quot;</span>
<span class="gi">+            &quot;Although there is nothing syntactically wrong with this code, &quot;</span>
<span class="gi">+            &quot;it is hard to read and can be simplified to a dict comprehension. &quot;</span>
<span class="gi">+            &quot;Also it is faster since you don&#39;t need to create another &quot;</span>
<span class="gi">+            &quot;transient list&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1718&quot;: (</span>
<span class="gi">+            &quot;Consider using a set comprehension&quot;,</span>
<span class="gi">+            &quot;consider-using-set-comprehension&quot;,</span>
<span class="gi">+            &quot;Although there is nothing syntactically wrong with this code, &quot;</span>
<span class="gi">+            &quot;it is hard to read and can be simplified to a set comprehension. &quot;</span>
<span class="gi">+            &quot;Also it is faster since you don&#39;t need to create another &quot;</span>
<span class="gi">+            &quot;transient list&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1719&quot;: (</span>
<span class="gi">+            &quot;The if expression can be replaced with %s&quot;,</span>
<span class="gi">+            &quot;simplifiable-if-expression&quot;,</span>
<span class="gi">+            &quot;Used when an if expression can be replaced with &#39;bool(test)&#39; &quot;</span>
<span class="gi">+            &quot;or simply &#39;test&#39; if the boolean cast is implicit.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1720&quot;: (</span>
<span class="gi">+            &#39;Unnecessary &quot;%s&quot; after &quot;raise&quot;, %s&#39;,</span>
<span class="gi">+            &quot;no-else-raise&quot;,</span>
<span class="gi">+            &quot;Used in order to highlight an unnecessary block of &quot;</span>
<span class="gi">+            &quot;code following an if containing a raise statement. &quot;</span>
<span class="gi">+            &quot;As such, it will warn when it encounters an else &quot;</span>
<span class="gi">+            &quot;following a chain of ifs, all of them containing a &quot;</span>
<span class="gi">+            &quot;raise statement.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1721&quot;: (</span>
<span class="gi">+            &quot;Unnecessary use of a comprehension, use %s instead.&quot;,</span>
<span class="gi">+            &quot;unnecessary-comprehension&quot;,</span>
<span class="gi">+            &quot;Instead of using an identity comprehension, &quot;</span>
<span class="gi">+            &quot;consider using the list, dict or set constructor. &quot;</span>
<span class="gi">+            &quot;It is faster and simpler.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1722&quot;: (</span>
<span class="gi">+            &quot;Consider using &#39;sys.exit&#39; instead&quot;,</span>
<span class="gi">+            &quot;consider-using-sys-exit&quot;,</span>
<span class="gi">+            &quot;Contrary to &#39;exit()&#39; or &#39;quit()&#39;, &#39;sys.exit&#39; does not rely on the &quot;</span>
<span class="gi">+            &quot;site module being available (as the &#39;sys&#39; module is always available).&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1723&quot;: (</span>
<span class="gi">+            &#39;Unnecessary &quot;%s&quot; after &quot;break&quot;, %s&#39;,</span>
<span class="gi">+            &quot;no-else-break&quot;,</span>
<span class="gi">+            &quot;Used in order to highlight an unnecessary block of &quot;</span>
<span class="gi">+            &quot;code following an if containing a break statement. &quot;</span>
<span class="gi">+            &quot;As such, it will warn when it encounters an else &quot;</span>
<span class="gi">+            &quot;following a chain of ifs, all of them containing a &quot;</span>
<span class="gi">+            &quot;break statement.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1724&quot;: (</span>
<span class="gi">+            &#39;Unnecessary &quot;%s&quot; after &quot;continue&quot;, %s&#39;,</span>
<span class="gi">+            &quot;no-else-continue&quot;,</span>
<span class="gi">+            &quot;Used in order to highlight an unnecessary block of &quot;</span>
<span class="gi">+            &quot;code following an if containing a continue statement. &quot;</span>
<span class="gi">+            &quot;As such, it will warn when it encounters an else &quot;</span>
<span class="gi">+            &quot;following a chain of ifs, all of them containing a &quot;</span>
<span class="gi">+            &quot;continue statement.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1725&quot;: (</span>
<span class="gi">+            &quot;Consider using Python 3 style super() without arguments&quot;,</span>
<span class="gi">+            &quot;super-with-arguments&quot;,</span>
<span class="gi">+            &quot;Emitted when calling the super() builtin with the current class &quot;</span>
<span class="gi">+            &quot;and instance. On Python 3 these arguments are the default and they can be omitted.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1728&quot;: (</span>
<span class="gi">+            &quot;Consider using a generator instead &#39;%s(%s)&#39;&quot;,</span>
<span class="gi">+            &quot;consider-using-generator&quot;,</span>
<span class="gi">+            &quot;If your container can be large using &quot;</span>
<span class="gi">+            &quot;a generator will bring better performance.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1729&quot;: (</span>
<span class="gi">+            &quot;Use a generator instead &#39;%s(%s)&#39;&quot;,</span>
<span class="gi">+            &quot;use-a-generator&quot;,</span>
<span class="gi">+            &quot;Comprehension inside of &#39;any&#39;, &#39;all&#39;, &#39;max&#39;, &#39;min&#39; or &#39;sum&#39; is unnecessary. &quot;</span>
<span class="gi">+            &quot;A generator would be sufficient and faster.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1730&quot;: (</span>
<span class="gi">+            &quot;Consider using &#39;%s&#39; instead of unnecessary if block&quot;,</span>
<span class="gi">+            &quot;consider-using-min-builtin&quot;,</span>
<span class="gi">+            &quot;Using the min builtin instead of a conditional improves readability and conciseness.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1731&quot;: (</span>
<span class="gi">+            &quot;Consider using &#39;%s&#39; instead of unnecessary if block&quot;,</span>
<span class="gi">+            &quot;consider-using-max-builtin&quot;,</span>
<span class="gi">+            &quot;Using the max builtin instead of a conditional improves readability and conciseness.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1732&quot;: (</span>
<span class="gi">+            &quot;Consider using &#39;with&#39; for resource-allocating operations&quot;,</span>
<span class="gi">+            &quot;consider-using-with&quot;,</span>
<span class="gi">+            &quot;Emitted if a resource-allocating assignment or call may be replaced by a &#39;with&#39; block. &quot;</span>
<span class="gi">+            &quot;By using &#39;with&#39; the release of the allocated resources is ensured even in the case &quot;</span>
<span class="gi">+            &quot;of an exception.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1733&quot;: (</span>
<span class="gi">+            &quot;Unnecessary dictionary index lookup, use &#39;%s&#39; instead&quot;,</span>
<span class="gi">+            &quot;unnecessary-dict-index-lookup&quot;,</span>
<span class="gi">+            &quot;Emitted when iterating over the dictionary items (key-item pairs) and accessing the &quot;</span>
<span class="gi">+            &quot;value by index lookup. &quot;</span>
<span class="gi">+            &quot;The value can be accessed directly instead.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1734&quot;: (</span>
<span class="gi">+            &quot;Consider using [] instead of list()&quot;,</span>
<span class="gi">+            &quot;use-list-literal&quot;,</span>
<span class="gi">+            &quot;Emitted when using list() to create an empty list instead of the literal []. &quot;</span>
<span class="gi">+            &quot;The literal is faster as it avoids an additional function call.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1735&quot;: (</span>
<span class="gi">+            &quot;Consider using &#39;%s&#39; instead of a call to &#39;dict&#39;.&quot;,</span>
<span class="gi">+            &quot;use-dict-literal&quot;,</span>
<span class="gi">+            &quot;Emitted when using dict() to create a dictionary instead of a literal &#39;{ ... }&#39;. &quot;</span>
<span class="gi">+            &quot;The literal is faster as it avoids an additional function call.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1736&quot;: (</span>
<span class="gi">+            &quot;Unnecessary list index lookup, use &#39;%s&#39; instead&quot;,</span>
<span class="gi">+            &quot;unnecessary-list-index-lookup&quot;,</span>
<span class="gi">+            &quot;Emitted when iterating over an enumeration and accessing the &quot;</span>
<span class="gi">+            &quot;value by index lookup. &quot;</span>
<span class="gi">+            &quot;The value can be accessed directly instead.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R1737&quot;: (</span>
<span class="gi">+            &quot;Use &#39;yield from&#39; directly instead of yielding each element one by one&quot;,</span>
<span class="gi">+            &quot;use-yield-from&quot;,</span>
<span class="gi">+            &quot;Yielding directly from the iterator is faster and arguably cleaner code than yielding each element &quot;</span>
<span class="gi">+            &quot;one by one in the loop.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-nested-blocks&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 5,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of nested blocks for function / method body&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;never-returning-functions&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (&quot;sys.exit&quot;, &quot;argparse.parse_error&quot;),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;members names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Complete name of functions that never returns. When checking &quot;</span>
<span class="gi">+                &quot;for inconsistent-return-statements if a never returning function is &quot;</span>
<span class="gi">+                &quot;called then it will be considered as an explicit return statement &quot;</span>
<span class="gi">+                &quot;and no message will be printed.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;suggest-join-with-non-empty-separator&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Let &#39;consider-using-join&#39; be raised when the separator to &quot;</span>
<span class="gi">+                    &quot;join on would be non-empty (resulting in expected fixes &quot;</span>
<span class="gi">+                    &#39;of the type: ``&quot;- &quot; + &quot;\n- &quot;.join(items)``)&#39;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="w"> </span>        self._return_nodes: dict[str, list[nodes.Return]] = {}
<span class="w"> </span>        self._consider_using_with_stack = ConsiderUsingWithStack()
<span class="gu">@@ -247,7 +535,33 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        self._never_returning_functions: set[str] = set()
<span class="w"> </span>        self._suggest_join_with_non_empty_separator: bool = False

<span class="gd">-    def _is_actual_elif(self, node: (nodes.If | nodes.Try)) -&gt;bool:</span>
<span class="gi">+    def _init(self) -&gt; None:</span>
<span class="gi">+        self._nested_blocks: list[NodesWithNestedBlocks] = []</span>
<span class="gi">+        self._elifs: list[tuple[int, int]] = []</span>
<span class="gi">+        self._reported_swap_nodes: set[nodes.NodeNG] = set()</span>
<span class="gi">+        self._can_simplify_bool_op: bool = False</span>
<span class="gi">+        self._consider_using_with_stack.clear_all()</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        # do this in open since config not fully initialized in __init__</span>
<span class="gi">+        self._never_returning_functions = set(</span>
<span class="gi">+            self.linter.config.never_returning_functions</span>
<span class="gi">+        )</span>
<span class="gi">+        self._suggest_join_with_non_empty_separator = (</span>
<span class="gi">+            self.linter.config.suggest_join_with_non_empty_separator</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @cached_property</span>
<span class="gi">+    def _dummy_rgx(self) -&gt; Pattern[str]:</span>
<span class="gi">+        return self.linter.config.dummy_variables_rgx  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_bool_const(node: nodes.Return | nodes.Assign) -&gt; bool:</span>
<span class="gi">+        return isinstance(node.value, nodes.Const) and isinstance(</span>
<span class="gi">+            node.value.value, bool</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _is_actual_elif(self, node: nodes.If | nodes.Try) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the given node is an actual elif.

<span class="w"> </span>        This is a problem we&#39;re having with the builtin ast module,
<span class="gu">@@ -255,9 +569,15 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        Unfortunately we need to know the exact type in certain
<span class="w"> </span>        cases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_simplifiable_if(self, node: nodes.If) -&gt;None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.If):</span>
<span class="gi">+            orelse = node.parent.orelse</span>
<span class="gi">+            # current if node must directly follow an &quot;else&quot;</span>
<span class="gi">+            if orelse and orelse == [node]:</span>
<span class="gi">+                if (node.lineno, node.col_offset) in self._elifs:</span>
<span class="gi">+                    return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _check_simplifiable_if(self, node: nodes.If) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the given if node can be simplified.

<span class="w"> </span>        The if statement can be reduced to a boolean expression
<span class="gu">@@ -266,25 +586,640 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        the result of the statement&#39;s test, then this can be reduced
<span class="w"> </span>        to `bool(test)` without losing any functionality.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._is_actual_elif(node):</span>
<span class="gi">+            # Not interested in if statements with multiple branches.</span>
<span class="gi">+            return</span>
<span class="gi">+        if len(node.orelse) != 1 or len(node.body) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Check if both branches can be reduced.</span>
<span class="gi">+        first_branch = node.body[0]</span>
<span class="gi">+        else_branch = node.orelse[0]</span>
<span class="gi">+        if isinstance(first_branch, nodes.Return):</span>
<span class="gi">+            if not isinstance(else_branch, nodes.Return):</span>
<span class="gi">+                return</span>
<span class="gi">+            first_branch_is_bool = self._is_bool_const(first_branch)</span>
<span class="gi">+            else_branch_is_bool = self._is_bool_const(else_branch)</span>
<span class="gi">+            reduced_to = &quot;&#39;return bool(test)&#39;&quot;</span>
<span class="gi">+        elif isinstance(first_branch, nodes.Assign):</span>
<span class="gi">+            if not isinstance(else_branch, nodes.Assign):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Check if we assign to the same value</span>
<span class="gi">+            first_branch_targets = [</span>
<span class="gi">+                target.name</span>
<span class="gi">+                for target in first_branch.targets</span>
<span class="gi">+                if isinstance(target, nodes.AssignName)</span>
<span class="gi">+            ]</span>
<span class="gi">+            else_branch_targets = [</span>
<span class="gi">+                target.name</span>
<span class="gi">+                for target in else_branch.targets</span>
<span class="gi">+                if isinstance(target, nodes.AssignName)</span>
<span class="gi">+            ]</span>
<span class="gi">+            if not first_branch_targets or not else_branch_targets:</span>
<span class="gi">+                return</span>
<span class="gi">+            if sorted(first_branch_targets) != sorted(else_branch_targets):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            first_branch_is_bool = self._is_bool_const(first_branch)</span>
<span class="gi">+            else_branch_is_bool = self._is_bool_const(else_branch)</span>
<span class="gi">+            reduced_to = &quot;&#39;var = bool(test)&#39;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not first_branch_is_bool or not else_branch_is_bool:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not first_branch.value.value:</span>
<span class="gi">+            # This is a case that can&#39;t be easily simplified and</span>
<span class="gi">+            # if it can be simplified, it will usually result in a</span>
<span class="gi">+            # code that&#39;s harder to understand and comprehend.</span>
<span class="gi">+            # Let&#39;s take for instance `arg and arg &lt;= 3`. This could theoretically be</span>
<span class="gi">+            # reduced to `not arg or arg &gt; 3`, but the net result is that now the</span>
<span class="gi">+            # condition is harder to understand, because it requires understanding of</span>
<span class="gi">+            # an extra clause:</span>
<span class="gi">+            #   * first, there is the negation of truthness with `not arg`</span>
<span class="gi">+            #   * the second clause is `arg &gt; 3`, which occurs when arg has a</span>
<span class="gi">+            #     a truth value, but it implies that `arg &gt; 3` is equivalent</span>
<span class="gi">+            #     with `arg and arg &gt; 3`, which means that the user must</span>
<span class="gi">+            #     think about this assumption when evaluating `arg &gt; 3`.</span>
<span class="gi">+            #     The original form is easier to grasp.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;simplifiable-if-statement&quot;, node=node, args=(reduced_to,))</span>
<span class="gi">+</span>
<span class="gi">+    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt; None:</span>
<span class="gi">+        # Optimization flag because &#39;_is_trailing_comma&#39; is costly</span>
<span class="gi">+        trailing_comma_tuple_enabled_for_file = self.linter.is_message_enabled(</span>
<span class="gi">+            &quot;trailing-comma-tuple&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        trailing_comma_tuple_enabled_once: bool = trailing_comma_tuple_enabled_for_file</span>
<span class="gi">+        # Process tokens and look for &#39;if&#39; or &#39;elif&#39;</span>
<span class="gi">+        for index, token in enumerate(tokens):</span>
<span class="gi">+            token_string = token[1]</span>
<span class="gi">+            if (</span>
<span class="gi">+                not trailing_comma_tuple_enabled_once</span>
<span class="gi">+                and token_string.startswith(&quot;#&quot;)</span>
<span class="gi">+                # We have at least 1 &#39;#&#39; (one char) at the start of the token</span>
<span class="gi">+                and &quot;pylint:&quot; in token_string[1:]</span>
<span class="gi">+                # We have at least &#39;#&#39; &#39;pylint&#39; ( + &#39;:&#39;) (8 chars) at the start of the token</span>
<span class="gi">+                and &quot;enable&quot; in token_string[8:]</span>
<span class="gi">+                # We have at least &#39;#&#39;, &#39;pylint&#39;, ( + &#39;:&#39;), &#39;enable&#39; (+ &#39;=&#39;) (15 chars) at</span>
<span class="gi">+                # the start of the token</span>
<span class="gi">+                and any(</span>
<span class="gi">+                    c in token_string[15:] for c in (&quot;trailing-comma-tuple&quot;, &quot;R1707&quot;)</span>
<span class="gi">+                )</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Way to not have to check if &quot;trailing-comma-tuple&quot; is enabled or</span>
<span class="gi">+                # disabled on each line: Any enable for it during tokenization and</span>
<span class="gi">+                # we&#39;ll start using the costly &#39;_is_trailing_comma&#39; to check if we</span>
<span class="gi">+                # need to raise the message. We still won&#39;t raise if it&#39;s disabled</span>
<span class="gi">+                # again due to the usual generic message control handling later.</span>
<span class="gi">+                trailing_comma_tuple_enabled_once = True</span>
<span class="gi">+            if token_string == &quot;elif&quot;:</span>
<span class="gi">+                # AST exists by the time process_tokens is called, so</span>
<span class="gi">+                # it&#39;s safe to assume tokens[index+1] exists.</span>
<span class="gi">+                # tokens[index+1][2] is the elif&#39;s position as</span>
<span class="gi">+                # reported by CPython and PyPy,</span>
<span class="gi">+                # token[2] is the actual position and also is</span>
<span class="gi">+                # reported by IronPython.</span>
<span class="gi">+                self._elifs.extend([token[2], tokens[index + 1][2]])</span>
<span class="gi">+            elif (</span>
<span class="gi">+                trailing_comma_tuple_enabled_for_file</span>
<span class="gi">+                or trailing_comma_tuple_enabled_once</span>
<span class="gi">+            ) and _is_trailing_comma(tokens, index):</span>
<span class="gi">+                # If &quot;trailing-comma-tuple&quot; is enabled globally we always check _is_trailing_comma</span>
<span class="gi">+                # it might be for nothing if there&#39;s a local disable, or if the message control is</span>
<span class="gi">+                # not enabling &#39;trailing-comma-tuple&#39;, but the alternative is having to check if</span>
<span class="gi">+                # it&#39;s enabled for a line each line (just to avoid calling &#39;_is_trailing_comma&#39;).</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;trailing-comma-tuple&quot;, line=token.start[0], confidence=HIGH</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;consider-using-with&quot;)</span>
<span class="gi">+    def leave_module(self, _: nodes.Module) -&gt; None:</span>
<span class="gi">+        # check for context managers that have been created but not used</span>
<span class="gi">+        self._emit_consider_using_with_if_needed(</span>
<span class="gi">+            self._consider_using_with_stack.module_scope</span>
<span class="gi">+        )</span>
<span class="gi">+        self._init()</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;too-many-nested-blocks&quot;, &quot;no-else-return&quot;)</span>
<span class="gi">+    def visit_try(self, node: nodes.Try) -&gt; None:</span>
<span class="gi">+        self._check_nested_blocks(node)</span>
<span class="gi">+</span>
<span class="gi">+        self._check_superfluous_else_return(node)</span>
<span class="gi">+        self._check_superfluous_else_raise(node)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_while = visit_try

<span class="gd">-    def _check_consider_using_min_max_builtin(self, node: nodes.If) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Check if the given if node can be refactored as a min/max python builtin.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def _check_redefined_argument_from_local(self, name_node: nodes.AssignName) -&gt; None:</span>
<span class="gi">+        if self._dummy_rgx and self._dummy_rgx.match(name_node.name):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not name_node.lineno:</span>
<span class="gi">+            # Unknown position, maybe it is a manually built AST?</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        scope = name_node.scope()</span>
<span class="gi">+        if not isinstance(scope, nodes.FunctionDef):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for defined_argument in scope.args.nodes_of_class(</span>
<span class="gi">+            nodes.AssignName, skip_klass=(nodes.Lambda,)</span>
<span class="gi">+        ):</span>
<span class="gi">+            if defined_argument.name == name_node.name:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;redefined-argument-from-local&quot;,</span>
<span class="gi">+                    node=name_node,</span>
<span class="gi">+                    args=(name_node.name,),</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;redefined-argument-from-local&quot;,</span>
<span class="gi">+        &quot;too-many-nested-blocks&quot;,</span>
<span class="gi">+        &quot;unnecessary-dict-index-lookup&quot;,</span>
<span class="gi">+        &quot;unnecessary-list-index-lookup&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        self._check_nested_blocks(node)</span>
<span class="gi">+        self._check_unnecessary_dict_index_lookup(node)</span>
<span class="gi">+        self._check_unnecessary_list_index_lookup(node)</span>
<span class="gi">+</span>
<span class="gi">+        for name in node.target.nodes_of_class(nodes.AssignName):</span>
<span class="gi">+            self._check_redefined_argument_from_local(name)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;redefined-argument-from-local&quot;)</span>
<span class="gi">+    def visit_excepthandler(self, node: nodes.ExceptHandler) -&gt; None:</span>
<span class="gi">+        if node.name and isinstance(node.name, nodes.AssignName):</span>
<span class="gi">+            self._check_redefined_argument_from_local(node.name)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;redefined-argument-from-local&quot;, &quot;consider-using-with&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_with(self, node: nodes.With) -&gt; None:</span>
<span class="gi">+        for var, names in node.items:</span>
<span class="gi">+            if isinstance(var, nodes.Name):</span>
<span class="gi">+                for stack in self._consider_using_with_stack:</span>
<span class="gi">+                    # We don&#39;t need to restrict the stacks we search to the current scope and</span>
<span class="gi">+                    # outer scopes, as e.g. the function_scope stack will be empty when we</span>
<span class="gi">+                    # check a ``with`` on the class level.</span>
<span class="gi">+                    if var.name in stack:</span>
<span class="gi">+                        del stack[var.name]</span>
<span class="gi">+                        break</span>
<span class="gi">+            if not names:</span>
<span class="gi">+                continue</span>
<span class="gi">+            for name in names.nodes_of_class(nodes.AssignName):</span>
<span class="gi">+                self._check_redefined_argument_from_local(name)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_superfluous_else(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.If | nodes.Try,</span>
<span class="gi">+        msg_id: str,</span>
<span class="gi">+        returning_node_class: nodes.NodeNG,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if isinstance(node, nodes.Try) and node.finalbody:</span>
<span class="gi">+            # Not interested in try/except/else/finally statements.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not node.orelse:</span>
<span class="gi">+            # Not interested in if/try statements without else.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self._is_actual_elif(node):</span>
<span class="gi">+            # Not interested in elif nodes; only if</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, nodes.If)</span>
<span class="gi">+            and _if_statement_is_always_returning(node, returning_node_class)</span>
<span class="gi">+        ) or (</span>
<span class="gi">+            isinstance(node, nodes.Try)</span>
<span class="gi">+            and not node.finalbody</span>
<span class="gi">+            and _except_statement_is_always_returning(node, returning_node_class)</span>
<span class="gi">+        ):</span>
<span class="gi">+            orelse = node.orelse[0]</span>
<span class="gi">+            if (orelse.lineno, orelse.col_offset) in self._elifs:</span>
<span class="gi">+                args = (&quot;elif&quot;, &#39;remove the leading &quot;el&quot; from &quot;elif&quot;&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                args = (&quot;else&quot;, &#39;remove the &quot;else&quot; and de-indent the code inside it&#39;)</span>
<span class="gi">+            self.add_message(msg_id, node=node, args=args, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_superfluous_else_return(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        return self._check_superfluous_else(</span>
<span class="gi">+            node, msg_id=&quot;no-else-return&quot;, returning_node_class=nodes.Return</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_superfluous_else_raise(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        return self._check_superfluous_else(</span>
<span class="gi">+            node, msg_id=&quot;no-else-raise&quot;, returning_node_class=nodes.Raise</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_superfluous_else_break(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        return self._check_superfluous_else(</span>
<span class="gi">+            node, msg_id=&quot;no-else-break&quot;, returning_node_class=nodes.Break</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_superfluous_else_continue(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        return self._check_superfluous_else(</span>
<span class="gi">+            node, msg_id=&quot;no-else-continue&quot;, returning_node_class=nodes.Continue</span>
<span class="gi">+        )</span>

<span class="gd">-    def _check_stop_iteration_inside_generator(self, node: nodes.Raise) -&gt;None:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _type_and_name_are_equal(node_a: Any, node_b: Any) -&gt; bool:</span>
<span class="gi">+        if isinstance(node_a, nodes.Name) and isinstance(node_b, nodes.Name):</span>
<span class="gi">+            return node_a.name == node_b.name  # type: ignore[no-any-return]</span>
<span class="gi">+        if isinstance(node_a, nodes.AssignName) and isinstance(</span>
<span class="gi">+            node_b, nodes.AssignName</span>
<span class="gi">+        ):</span>
<span class="gi">+            return node_a.name == node_b.name  # type: ignore[no-any-return]</span>
<span class="gi">+        if isinstance(node_a, nodes.Const) and isinstance(node_b, nodes.Const):</span>
<span class="gi">+            return node_a.value == node_b.value  # type: ignore[no-any-return]</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _is_dict_get_block(self, node: nodes.If) -&gt; bool:</span>
<span class="gi">+        # &quot;if &lt;compare node&gt;&quot;</span>
<span class="gi">+        if not isinstance(node.test, nodes.Compare):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Does not have a single statement in the guard&#39;s body</span>
<span class="gi">+        if len(node.body) != 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Look for a single variable assignment on the LHS and a subscript on RHS</span>
<span class="gi">+        stmt = node.body[0]</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(stmt, nodes.Assign)</span>
<span class="gi">+            and len(node.body[0].targets) == 1</span>
<span class="gi">+            and isinstance(node.body[0].targets[0], nodes.AssignName)</span>
<span class="gi">+            and isinstance(stmt.value, nodes.Subscript)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # The subscript&#39;s slice needs to be the same as the test variable.</span>
<span class="gi">+        slice_value = stmt.value.slice</span>
<span class="gi">+        if not (</span>
<span class="gi">+            self._type_and_name_are_equal(stmt.value.value, node.test.ops[0][1])</span>
<span class="gi">+            and self._type_and_name_are_equal(slice_value, node.test.left)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # The object needs to be a dictionary instance</span>
<span class="gi">+        return isinstance(utils.safe_infer(node.test.ops[0][1]), nodes.Dict)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_get(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        if_block_ok = self._is_dict_get_block(node)</span>
<span class="gi">+        if if_block_ok and not node.orelse:</span>
<span class="gi">+            self.add_message(&quot;consider-using-get&quot;, node=node)</span>
<span class="gi">+        elif (</span>
<span class="gi">+            if_block_ok</span>
<span class="gi">+            and len(node.orelse) == 1</span>
<span class="gi">+            and isinstance(node.orelse[0], nodes.Assign)</span>
<span class="gi">+            and self._type_and_name_are_equal(</span>
<span class="gi">+                node.orelse[0].targets[0], node.body[0].targets[0]</span>
<span class="gi">+            )</span>
<span class="gi">+            and len(node.orelse[0].targets) == 1</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;consider-using-get&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;too-many-nested-blocks&quot;,</span>
<span class="gi">+        &quot;simplifiable-if-statement&quot;,</span>
<span class="gi">+        &quot;no-else-return&quot;,</span>
<span class="gi">+        &quot;no-else-raise&quot;,</span>
<span class="gi">+        &quot;no-else-break&quot;,</span>
<span class="gi">+        &quot;no-else-continue&quot;,</span>
<span class="gi">+        &quot;consider-using-get&quot;,</span>
<span class="gi">+        &quot;consider-using-min-builtin&quot;,</span>
<span class="gi">+        &quot;consider-using-max-builtin&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_if(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        self._check_simplifiable_if(node)</span>
<span class="gi">+        self._check_nested_blocks(node)</span>
<span class="gi">+        self._check_superfluous_else_return(node)</span>
<span class="gi">+        self._check_superfluous_else_raise(node)</span>
<span class="gi">+        self._check_superfluous_else_break(node)</span>
<span class="gi">+        self._check_superfluous_else_continue(node)</span>
<span class="gi">+        self._check_consider_get(node)</span>
<span class="gi">+        self._check_consider_using_min_max_builtin(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_using_min_max_builtin(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Check if the given if node can be refactored as a min/max python builtin.&quot;&quot;&quot;</span>
<span class="gi">+        # This function is written expecting a test condition of form:</span>
<span class="gi">+        #  if a &lt; b: # [consider-using-max-builtin]</span>
<span class="gi">+        #    a = b</span>
<span class="gi">+        #  if a &gt; b: # [consider-using-min-builtin]</span>
<span class="gi">+        #    a = b</span>
<span class="gi">+        if self._is_actual_elif(node) or node.orelse:</span>
<span class="gi">+            # Not interested in if statements with multiple branches.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if len(node.body) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        def get_node_name(node: nodes.NodeNG) -&gt; str:</span>
<span class="gi">+            &quot;&quot;&quot;Obtain simplest representation of a node as a string.&quot;&quot;&quot;</span>
<span class="gi">+            if isinstance(node, nodes.Name):</span>
<span class="gi">+                return node.name  # type: ignore[no-any-return]</span>
<span class="gi">+            if isinstance(node, nodes.Const):</span>
<span class="gi">+                return str(node.value)</span>
<span class="gi">+            # this is a catch-all for nodes that are not of type Name or Const</span>
<span class="gi">+            # extremely helpful for Call or BinOp</span>
<span class="gi">+            return node.as_string()  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+        body = node.body[0]</span>
<span class="gi">+        # Check if condition can be reduced.</span>
<span class="gi">+        if not hasattr(body, &quot;targets&quot;) or len(body.targets) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        target = body.targets[0]</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(node.test, nodes.Compare)</span>
<span class="gi">+            and not isinstance(target, nodes.Subscript)</span>
<span class="gi">+            and not isinstance(node.test.left, nodes.Subscript)</span>
<span class="gi">+            and isinstance(body, nodes.Assign)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        # Assign body line has one requirement and that is the assign target</span>
<span class="gi">+        # is of type name or attribute. Attribute referring to NamedTuple.x perse.</span>
<span class="gi">+        # So we have to check that target is of these types</span>
<span class="gi">+</span>
<span class="gi">+        if not (hasattr(target, &quot;name&quot;) or hasattr(target, &quot;attrname&quot;)):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        target_assignation = get_node_name(target)</span>
<span class="gi">+</span>
<span class="gi">+        if len(node.test.ops) &gt; 1:</span>
<span class="gi">+            return</span>
<span class="gi">+        operator, right_statement = node.test.ops[0]</span>
<span class="gi">+</span>
<span class="gi">+        body_value = get_node_name(body.value)</span>
<span class="gi">+        left_operand = get_node_name(node.test.left)</span>
<span class="gi">+        right_statement_value = get_node_name(right_statement)</span>
<span class="gi">+</span>
<span class="gi">+        if left_operand == target_assignation:</span>
<span class="gi">+            # statement is in expected form</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif right_statement_value == target_assignation:</span>
<span class="gi">+            # statement is in reverse form</span>
<span class="gi">+            operator = utils.get_inverse_comparator(operator)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if body_value not in (right_statement_value, left_operand):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if operator in {&quot;&lt;&quot;, &quot;&lt;=&quot;}:</span>
<span class="gi">+            reduced_to = (</span>
<span class="gi">+                f&quot;{target_assignation} = max({target_assignation}, {body_value})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-using-max-builtin&quot;, node=node, args=(reduced_to,)</span>
<span class="gi">+            )</span>
<span class="gi">+        elif operator in {&quot;&gt;&quot;, &quot;&gt;=&quot;}:</span>
<span class="gi">+            reduced_to = (</span>
<span class="gi">+                f&quot;{target_assignation} = min({target_assignation}, {body_value})&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-using-min-builtin&quot;, node=node, args=(reduced_to,)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;simplifiable-if-expression&quot;)</span>
<span class="gi">+    def visit_ifexp(self, node: nodes.IfExp) -&gt; None:</span>
<span class="gi">+        self._check_simplifiable_ifexp(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_simplifiable_ifexp(self, node: nodes.IfExp) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.body, nodes.Const) or not isinstance(</span>
<span class="gi">+            node.orelse, nodes.Const</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(node.body.value, bool) or not isinstance(</span>
<span class="gi">+            node.orelse.value, bool</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.test, nodes.Compare):</span>
<span class="gi">+            test_reduced_to = &quot;test&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            test_reduced_to = &quot;bool(test)&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if (node.body.value, node.orelse.value) == (True, False):</span>
<span class="gi">+            reduced_to = f&quot;&#39;{test_reduced_to}&#39;&quot;</span>
<span class="gi">+        elif (node.body.value, node.orelse.value) == (False, True):</span>
<span class="gi">+            reduced_to = &quot;&#39;not test&#39;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;simplifiable-if-expression&quot;, node=node, args=(reduced_to,))</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;too-many-nested-blocks&quot;,</span>
<span class="gi">+        &quot;inconsistent-return-statements&quot;,</span>
<span class="gi">+        &quot;useless-return&quot;,</span>
<span class="gi">+        &quot;consider-using-with&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def leave_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        # check left-over nested blocks stack</span>
<span class="gi">+        self._emit_nested_blocks_message_if_needed(self._nested_blocks)</span>
<span class="gi">+        # new scope = reinitialize the stack of nested blocks</span>
<span class="gi">+        self._nested_blocks = []</span>
<span class="gi">+        # check consistent return statements</span>
<span class="gi">+        self._check_consistent_returns(node)</span>
<span class="gi">+        # check for single return or return None at the end</span>
<span class="gi">+        self._check_return_at_the_end(node)</span>
<span class="gi">+        self._return_nodes[node.name] = []</span>
<span class="gi">+        # check for context managers that have been created but not used</span>
<span class="gi">+        self._emit_consider_using_with_if_needed(</span>
<span class="gi">+            self._consider_using_with_stack.function_scope</span>
<span class="gi">+        )</span>
<span class="gi">+        self._consider_using_with_stack.function_scope.clear()</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;consider-using-with&quot;)</span>
<span class="gi">+    def leave_classdef(self, _: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        # check for context managers that have been created but not used</span>
<span class="gi">+        self._emit_consider_using_with_if_needed(</span>
<span class="gi">+            self._consider_using_with_stack.class_scope</span>
<span class="gi">+        )</span>
<span class="gi">+        self._consider_using_with_stack.class_scope.clear()</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;stop-iteration-return&quot;)</span>
<span class="gi">+    def visit_raise(self, node: nodes.Raise) -&gt; None:</span>
<span class="gi">+        self._check_stop_iteration_inside_generator(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_stop_iteration_inside_generator(self, node: nodes.Raise) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if an exception of type StopIteration is raised inside a generator.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        frame = node.frame()</span>
<span class="gi">+        if not isinstance(frame, nodes.FunctionDef) or not frame.is_generator():</span>
<span class="gi">+            return</span>
<span class="gi">+        if utils.node_ignores_exception(node, StopIteration):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not node.exc:</span>
<span class="gi">+            return</span>
<span class="gi">+        exc = utils.safe_infer(node.exc)</span>
<span class="gi">+        if not exc or not isinstance(exc, (bases.Instance, nodes.ClassDef)):</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._check_exception_inherit_from_stopiteration(exc):</span>
<span class="gi">+            self.add_message(&quot;stop-iteration-return&quot;, node=node, confidence=INFERENCE)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _check_exception_inherit_from_stopiteration(exc: (nodes.ClassDef |</span>
<span class="gd">-        bases.Instance)) -&gt;bool:</span>
<span class="gi">+    def _check_exception_inherit_from_stopiteration(</span>
<span class="gi">+        exc: nodes.ClassDef | bases.Instance,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if the exception node in argument inherit from StopIteration.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stopiteration_qname = f&quot;{utils.EXCEPTIONS_MODULE}.StopIteration&quot;</span>
<span class="gi">+        return any(_class.qname() == stopiteration_qname for _class in exc.mro())</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_using_comprehension_constructor(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.func, nodes.Name)</span>
<span class="gi">+            and node.args</span>
<span class="gi">+            and isinstance(node.args[0], nodes.ListComp)</span>
<span class="gi">+        ):</span>
<span class="gi">+            if node.func.name == &quot;dict&quot;:</span>
<span class="gi">+                element = node.args[0].elt</span>
<span class="gi">+                if isinstance(element, nodes.Call):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                # If we have an `IfExp` here where both the key AND value</span>
<span class="gi">+                # are different, then don&#39;t raise the issue. See #5588</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(element, nodes.IfExp)</span>
<span class="gi">+                    and isinstance(element.body, (nodes.Tuple, nodes.List))</span>
<span class="gi">+                    and len(element.body.elts) == 2</span>
<span class="gi">+                    and isinstance(element.orelse, (nodes.Tuple, nodes.List))</span>
<span class="gi">+                    and len(element.orelse.elts) == 2</span>
<span class="gi">+                ):</span>
<span class="gi">+                    key1, value1 = element.body.elts</span>
<span class="gi">+                    key2, value2 = element.orelse.elts</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        key1.as_string() != key2.as_string()</span>
<span class="gi">+                        and value1.as_string() != value2.as_string()</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                message_name = &quot;consider-using-dict-comprehension&quot;</span>
<span class="gi">+                self.add_message(message_name, node=node)</span>
<span class="gi">+            elif node.func.name == &quot;set&quot;:</span>
<span class="gi">+                message_name = &quot;consider-using-set-comprehension&quot;</span>
<span class="gi">+                self.add_message(message_name, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_using_generator(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        # &#39;any&#39;, &#39;all&#39;, definitely should use generator, while &#39;list&#39;, &#39;tuple&#39;,</span>
<span class="gi">+        # &#39;sum&#39;, &#39;max&#39;, and &#39;min&#39; need to be considered first</span>
<span class="gi">+        # See https://github.com/pylint-dev/pylint/pull/3309#discussion_r576683109</span>
<span class="gi">+        # https://github.com/pylint-dev/pylint/pull/6595#issuecomment-1125704244</span>
<span class="gi">+        # and https://peps.python.org/pep-0289/</span>
<span class="gi">+        checked_call = [&quot;any&quot;, &quot;all&quot;, &quot;sum&quot;, &quot;max&quot;, &quot;min&quot;, &quot;list&quot;, &quot;tuple&quot;]</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, nodes.Call)</span>
<span class="gi">+            and node.func</span>
<span class="gi">+            and isinstance(node.func, nodes.Name)</span>
<span class="gi">+            and node.func.name in checked_call</span>
<span class="gi">+        ):</span>
<span class="gi">+            # functions in checked_calls take exactly one positional argument</span>
<span class="gi">+            # check whether the argument is list comprehension</span>
<span class="gi">+            if len(node.args) == 1 and isinstance(node.args[0], nodes.ListComp):</span>
<span class="gi">+                # remove square brackets &#39;[]&#39;</span>
<span class="gi">+                inside_comp = node.args[0].as_string()[1:-1]</span>
<span class="gi">+                if node.keywords:</span>
<span class="gi">+                    inside_comp = f&quot;({inside_comp})&quot;</span>
<span class="gi">+                    inside_comp += &quot;, &quot;</span>
<span class="gi">+                    inside_comp += &quot;, &quot;.join(kw.as_string() for kw in node.keywords)</span>
<span class="gi">+                call_name = node.func.name</span>
<span class="gi">+                if call_name in {&quot;any&quot;, &quot;all&quot;}:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;use-a-generator&quot;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=(call_name, inside_comp),</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;consider-using-generator&quot;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=(call_name, inside_comp),</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;stop-iteration-return&quot;,</span>
<span class="gi">+        &quot;consider-using-dict-comprehension&quot;,</span>
<span class="gi">+        &quot;consider-using-set-comprehension&quot;,</span>
<span class="gi">+        &quot;consider-using-sys-exit&quot;,</span>
<span class="gi">+        &quot;super-with-arguments&quot;,</span>
<span class="gi">+        &quot;consider-using-generator&quot;,</span>
<span class="gi">+        &quot;consider-using-with&quot;,</span>
<span class="gi">+        &quot;use-list-literal&quot;,</span>
<span class="gi">+        &quot;use-dict-literal&quot;,</span>
<span class="gi">+        &quot;use-a-generator&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        self._check_raising_stopiteration_in_generator_next_call(node)</span>
<span class="gi">+        self._check_consider_using_comprehension_constructor(node)</span>
<span class="gi">+        self._check_quit_exit_call(node)</span>
<span class="gi">+        self._check_super_with_arguments(node)</span>
<span class="gi">+        self._check_consider_using_generator(node)</span>
<span class="gi">+        self._check_consider_using_with(node)</span>
<span class="gi">+        self._check_use_list_literal(node)</span>
<span class="gi">+        self._check_use_dict_literal(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;use-yield-from&quot;)</span>
<span class="gi">+    def visit_yield(self, node: nodes.Yield) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.value, nodes.Name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        loop_node = node.parent.parent</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(loop_node, nodes.For)</span>
<span class="gi">+            or isinstance(loop_node, nodes.AsyncFor)</span>
<span class="gi">+            or len(loop_node.body) != 1</span>
<span class="gi">+            # Avoid a false positive if the return value from `yield` is used,</span>
<span class="gi">+            # (such as via Assign, AugAssign, etc).</span>
<span class="gi">+            or not isinstance(node.parent, nodes.Expr)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if loop_node.target.name != node.value.name:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.frame(), nodes.AsyncFunctionDef):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;use-yield-from&quot;, node=loop_node, confidence=HIGH)</span>

<span class="gd">-    def _check_raising_stopiteration_in_generator_next_call(self, node:</span>
<span class="gd">-        nodes.Call) -&gt;None:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _has_exit_in_scope(scope: nodes.LocalsDictNodeNG) -&gt; bool:</span>
<span class="gi">+        exit_func = scope.locals.get(&quot;exit&quot;)</span>
<span class="gi">+        return bool(</span>
<span class="gi">+            exit_func and isinstance(exit_func[0], (nodes.ImportFrom, nodes.Import))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_quit_exit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if isinstance(node.func, nodes.Name) and node.func.name in BUILTIN_EXIT_FUNCS:</span>
<span class="gi">+            # If we have `exit` imported from `sys` in the current or global scope,</span>
<span class="gi">+            # exempt this instance.</span>
<span class="gi">+            local_scope = node.scope()</span>
<span class="gi">+            if self._has_exit_in_scope(local_scope) or self._has_exit_in_scope(</span>
<span class="gi">+                node.root()</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+            self.add_message(&quot;consider-using-sys-exit&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_super_with_arguments(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.func, nodes.Name) or node.func.name != &quot;super&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            len(node.args) != 2</span>
<span class="gi">+            or not all(isinstance(arg, nodes.Name) for arg in node.args)</span>
<span class="gi">+            or node.args[1].name != &quot;self&quot;</span>
<span class="gi">+            or (frame_class := node_frame_class(node)) is None</span>
<span class="gi">+            or node.args[0].name != frame_class.name</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;super-with-arguments&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_raising_stopiteration_in_generator_next_call(</span>
<span class="gi">+        self, node: nodes.Call</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a StopIteration exception is raised by the call to next function.

<span class="w"> </span>        If the next value has a default value, then do not add message.
<span class="gu">@@ -292,14 +1227,90 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        :param node: Check to see if this Call node is a next function
<span class="w"> </span>        :type node: :class:`nodes.Call`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _check_nested_blocks(self, node: NodesWithNestedBlocks) -&gt;None:</span>
<span class="gi">+        def _looks_like_infinite_iterator(param: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+            inferred = utils.safe_infer(param)</span>
<span class="gi">+            if isinstance(inferred, bases.Instance):</span>
<span class="gi">+                return inferred.qname() in KNOWN_INFINITE_ITERATORS</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+            # A next() method, which is now what we want.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if len(node.args) == 0:</span>
<span class="gi">+            # handle case when builtin.next is called without args.</span>
<span class="gi">+            # see https://github.com/pylint-dev/pylint/issues/7828</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        inferred = utils.safe_infer(node.func)</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(inferred, nodes.FunctionDef)</span>
<span class="gi">+            and inferred.qname() == &quot;builtins.next&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            frame = node.frame()</span>
<span class="gi">+            # The next builtin can only have up to two</span>
<span class="gi">+            # positional arguments and no keyword arguments</span>
<span class="gi">+            has_sentinel_value = len(node.args) &gt; 1</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(frame, nodes.FunctionDef)</span>
<span class="gi">+                and frame.is_generator()</span>
<span class="gi">+                and not has_sentinel_value</span>
<span class="gi">+                and not utils.node_ignores_exception(node, StopIteration)</span>
<span class="gi">+                and not _looks_like_infinite_iterator(node.args[0])</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;stop-iteration-return&quot;, node=node, confidence=INFERENCE</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_nested_blocks(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: NodesWithNestedBlocks,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update and check the number of nested blocks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # only check block levels inside functions or methods</span>
<span class="gi">+        if not isinstance(node.scope(), nodes.FunctionDef):</span>
<span class="gi">+            return</span>
<span class="gi">+        # messages are triggered on leaving the nested block. Here we save the</span>
<span class="gi">+        # stack in case the current node isn&#39;t nested in the previous one</span>
<span class="gi">+        nested_blocks = self._nested_blocks[:]</span>
<span class="gi">+        if node.parent == node.scope():</span>
<span class="gi">+            self._nested_blocks = [node]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # go through ancestors from the most nested to the less</span>
<span class="gi">+            for ancestor_node in reversed(self._nested_blocks):</span>
<span class="gi">+                if ancestor_node == node.parent:</span>
<span class="gi">+                    break</span>
<span class="gi">+                self._nested_blocks.pop()</span>
<span class="gi">+            # if the node is an elif, this should not be another nesting level</span>
<span class="gi">+            if isinstance(node, nodes.If) and self._is_actual_elif(node):</span>
<span class="gi">+                if self._nested_blocks:</span>
<span class="gi">+                    self._nested_blocks.pop()</span>
<span class="gi">+            self._nested_blocks.append(node)</span>
<span class="gi">+</span>
<span class="gi">+        # send message only once per group of nested blocks</span>
<span class="gi">+        if len(nested_blocks) &gt; len(self._nested_blocks):</span>
<span class="gi">+            self._emit_nested_blocks_message_if_needed(nested_blocks)</span>
<span class="gi">+</span>
<span class="gi">+    def _emit_nested_blocks_message_if_needed(</span>
<span class="gi">+        self, nested_blocks: list[NodesWithNestedBlocks]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if len(nested_blocks) &gt; self.linter.config.max_nested_blocks:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-nested-blocks&quot;,</span>
<span class="gi">+                node=nested_blocks[0],</span>
<span class="gi">+                args=(len(nested_blocks), self.linter.config.max_nested_blocks),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _emit_consider_using_with_if_needed(</span>
<span class="gi">+        self, stack: dict[str, nodes.NodeNG]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        for node in stack.values():</span>
<span class="gi">+            self.add_message(&quot;consider-using-with&quot;, node=node)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _duplicated_isinstance_types(node: nodes.BoolOp) -&gt;dict[str, set[str]]:</span>
<span class="gi">+    def _duplicated_isinstance_types(node: nodes.BoolOp) -&gt; dict[str, set[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the duplicated types from the underlying isinstance calls.

<span class="w"> </span>        :param nodes.BoolOp node: Node which should contain a bunch of isinstance calls.
<span class="gu">@@ -307,13 +1318,100 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>                  to duplicate values from consecutive calls.
<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        duplicated_objects: set[str] = set()</span>
<span class="gi">+        all_types: collections.defaultdict[str, set[str]] = collections.defaultdict(set)</span>

<span class="gd">-    def _check_consider_merging_isinstance(self, node: nodes.BoolOp) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Check isinstance calls which can be merged together.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        for call in node.values:</span>
<span class="gi">+            if not isinstance(call, nodes.Call) or len(call.args) != 2:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            inferred = utils.safe_infer(call.func)</span>
<span class="gi">+            if not inferred or not utils.is_builtin_object(inferred):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if inferred.name != &quot;isinstance&quot;:</span>
<span class="gi">+                continue</span>

<span class="gd">-    def _check_chained_comparison(self, node: nodes.BoolOp) -&gt;None:</span>
<span class="gi">+            isinstance_object = call.args[0].as_string()</span>
<span class="gi">+            isinstance_types = call.args[1]</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance_object in all_types:</span>
<span class="gi">+                duplicated_objects.add(isinstance_object)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(isinstance_types, nodes.Tuple):</span>
<span class="gi">+                elems = [</span>
<span class="gi">+                    class_type.as_string() for class_type in isinstance_types.itered()</span>
<span class="gi">+                ]</span>
<span class="gi">+            else:</span>
<span class="gi">+                elems = [isinstance_types.as_string()]</span>
<span class="gi">+            all_types[isinstance_object].update(elems)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove all keys which not duplicated</span>
<span class="gi">+        return {</span>
<span class="gi">+            key: value for key, value in all_types.items() if key in duplicated_objects</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_merging_isinstance(self, node: nodes.BoolOp) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Check isinstance calls which can be merged together.&quot;&quot;&quot;</span>
<span class="gi">+        if node.op != &quot;or&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        first_args = self._duplicated_isinstance_types(node)</span>
<span class="gi">+        for duplicated_name, class_names in first_args.items():</span>
<span class="gi">+            names = sorted(name for name in class_names)</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-merging-isinstance&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(duplicated_name, &quot;, &quot;.join(names)),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_using_in(self, node: nodes.BoolOp) -&gt; None:</span>
<span class="gi">+        allowed_ops = {&quot;or&quot;: &quot;==&quot;, &quot;and&quot;: &quot;!=&quot;}</span>
<span class="gi">+</span>
<span class="gi">+        if node.op not in allowed_ops or len(node.values) &lt; 2:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for value in node.values:</span>
<span class="gi">+            if (</span>
<span class="gi">+                not isinstance(value, nodes.Compare)</span>
<span class="gi">+                or len(value.ops) != 1</span>
<span class="gi">+                or value.ops[0][0] not in allowed_ops[node.op]</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+            for comparable in value.left, value.ops[0][1]:</span>
<span class="gi">+                if isinstance(comparable, nodes.Call):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+        # Gather variables and values from comparisons</span>
<span class="gi">+        variables, values = [], []</span>
<span class="gi">+        for value in node.values:</span>
<span class="gi">+            variable_set = set()</span>
<span class="gi">+            for comparable in value.left, value.ops[0][1]:</span>
<span class="gi">+                if isinstance(comparable, (nodes.Name, nodes.Attribute)):</span>
<span class="gi">+                    variable_set.add(comparable.as_string())</span>
<span class="gi">+                values.append(comparable.as_string())</span>
<span class="gi">+            variables.append(variable_set)</span>
<span class="gi">+</span>
<span class="gi">+        # Look for (common-)variables that occur in all comparisons</span>
<span class="gi">+        common_variables = reduce(lambda a, b: a.intersection(b), variables)</span>
<span class="gi">+</span>
<span class="gi">+        if not common_variables:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Gather information for the suggestion</span>
<span class="gi">+        common_variable = sorted(list(common_variables))[0]</span>
<span class="gi">+        values = list(collections.OrderedDict.fromkeys(values))</span>
<span class="gi">+        values.remove(common_variable)</span>
<span class="gi">+        values_string = &quot;, &quot;.join(values) if len(values) != 1 else values[0] + &quot;,&quot;</span>
<span class="gi">+        maybe_not = &quot;&quot; if node.op == &quot;or&quot; else &quot;not &quot;</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;consider-using-in&quot;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=(common_variable, maybe_not, values_string),</span>
<span class="gi">+            confidence=HIGH,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_chained_comparison(self, node: nodes.BoolOp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if there is any chained comparison in the expression.

<span class="w"> </span>        Add a refactoring message if a boolOp contains comparison like a &lt; b and b &lt; c,
<span class="gu">@@ -321,11 +1419,58 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>

<span class="w"> </span>        Care is taken to avoid simplifying a &lt; b &lt; c and b &lt; d.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.op != &quot;and&quot; or len(node.values) &lt; 2:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        def _find_lower_upper_bounds(</span>
<span class="gi">+            comparison_node: nodes.Compare,</span>
<span class="gi">+            uses: collections.defaultdict[str, dict[str, set[nodes.Compare]]],</span>
<span class="gi">+        ) -&gt; None:</span>
<span class="gi">+            left_operand = comparison_node.left</span>
<span class="gi">+            for operator, right_operand in comparison_node.ops:</span>
<span class="gi">+                for operand in (left_operand, right_operand):</span>
<span class="gi">+                    value = None</span>
<span class="gi">+                    if isinstance(operand, nodes.Name):</span>
<span class="gi">+                        value = operand.name</span>
<span class="gi">+                    elif isinstance(operand, nodes.Const):</span>
<span class="gi">+                        value = operand.value</span>
<span class="gi">+</span>
<span class="gi">+                    if value is None:</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if operator in {&quot;&lt;&quot;, &quot;&lt;=&quot;}:</span>
<span class="gi">+                        if operand is left_operand:</span>
<span class="gi">+                            uses[value][&quot;lower_bound&quot;].add(comparison_node)</span>
<span class="gi">+                        elif operand is right_operand:</span>
<span class="gi">+                            uses[value][&quot;upper_bound&quot;].add(comparison_node)</span>
<span class="gi">+                    elif operator in {&quot;&gt;&quot;, &quot;&gt;=&quot;}:</span>
<span class="gi">+                        if operand is left_operand:</span>
<span class="gi">+                            uses[value][&quot;upper_bound&quot;].add(comparison_node)</span>
<span class="gi">+                        elif operand is right_operand:</span>
<span class="gi">+                            uses[value][&quot;lower_bound&quot;].add(comparison_node)</span>
<span class="gi">+                left_operand = right_operand</span>
<span class="gi">+</span>
<span class="gi">+        uses: collections.defaultdict[str, dict[str, set[nodes.Compare]]] = (</span>
<span class="gi">+            collections.defaultdict(</span>
<span class="gi">+                lambda: {&quot;lower_bound&quot;: set(), &quot;upper_bound&quot;: set()}</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        for comparison_node in node.values:</span>
<span class="gi">+            if isinstance(comparison_node, nodes.Compare):</span>
<span class="gi">+                _find_lower_upper_bounds(comparison_node, uses)</span>
<span class="gi">+</span>
<span class="gi">+        for bounds in uses.values():</span>
<span class="gi">+            num_shared = len(bounds[&quot;lower_bound&quot;].intersection(bounds[&quot;upper_bound&quot;]))</span>
<span class="gi">+            num_lower_bounds = len(bounds[&quot;lower_bound&quot;])</span>
<span class="gi">+            num_upper_bounds = len(bounds[&quot;upper_bound&quot;])</span>
<span class="gi">+            if num_shared &lt; num_lower_bounds and num_shared &lt; num_upper_bounds:</span>
<span class="gi">+                self.add_message(&quot;chained-comparison&quot;, node=node)</span>
<span class="gi">+                break</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _apply_boolean_simplification_rules(operator: str, values: list[</span>
<span class="gd">-        nodes.NodeNG]) -&gt;list[nodes.NodeNG]:</span>
<span class="gi">+    def _apply_boolean_simplification_rules(</span>
<span class="gi">+        operator: str, values: list[nodes.NodeNG]</span>
<span class="gi">+    ) -&gt; list[nodes.NodeNG]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Removes irrelevant values or returns short-circuiting values.

<span class="w"> </span>        This function applies the following two rules:
<span class="gu">@@ -335,43 +1480,294 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        2) False values in OR expressions are only relevant if all values are
<span class="w"> </span>           false, and the reverse for AND
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        simplified_values: list[nodes.NodeNG] = []</span>
<span class="gi">+</span>
<span class="gi">+        for subnode in values:</span>
<span class="gi">+            inferred_bool = None</span>
<span class="gi">+            if not next(subnode.nodes_of_class(nodes.Name), False):</span>
<span class="gi">+                inferred = utils.safe_infer(subnode)</span>
<span class="gi">+                if inferred:</span>
<span class="gi">+                    inferred_bool = inferred.bool_value()</span>
<span class="gi">+</span>
<span class="gi">+            if not isinstance(inferred_bool, bool):</span>
<span class="gi">+                simplified_values.append(subnode)</span>
<span class="gi">+            elif (operator == &quot;or&quot;) == inferred_bool:</span>
<span class="gi">+                return [subnode]</span>

<span class="gd">-    def _simplify_boolean_operation(self, bool_op: nodes.BoolOp</span>
<span class="gd">-        ) -&gt;nodes.BoolOp:</span>
<span class="gi">+        return simplified_values or [nodes.Const(operator == &quot;and&quot;)]</span>
<span class="gi">+</span>
<span class="gi">+    def _simplify_boolean_operation(self, bool_op: nodes.BoolOp) -&gt; nodes.BoolOp:</span>
<span class="w"> </span>        &quot;&quot;&quot;Attempts to simplify a boolean operation.

<span class="w"> </span>        Recursively applies simplification on the operator terms,
<span class="w"> </span>        and keeps track of whether reductions have been made.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_simplifiable_condition(self, node: nodes.BoolOp) -&gt;None:</span>
<span class="gi">+        children = list(bool_op.get_children())</span>
<span class="gi">+        intermediate = [</span>
<span class="gi">+            (</span>
<span class="gi">+                self._simplify_boolean_operation(child)</span>
<span class="gi">+                if isinstance(child, nodes.BoolOp)</span>
<span class="gi">+                else child</span>
<span class="gi">+            )</span>
<span class="gi">+            for child in children</span>
<span class="gi">+        ]</span>
<span class="gi">+        result = self._apply_boolean_simplification_rules(bool_op.op, intermediate)</span>
<span class="gi">+        if len(result) &lt; len(children):</span>
<span class="gi">+            self._can_simplify_bool_op = True</span>
<span class="gi">+        if len(result) == 1:</span>
<span class="gi">+            return result[0]</span>
<span class="gi">+        simplified_bool_op = copy.copy(bool_op)</span>
<span class="gi">+        simplified_bool_op.postinit(result)</span>
<span class="gi">+        return simplified_bool_op</span>
<span class="gi">+</span>
<span class="gi">+    def _check_simplifiable_condition(self, node: nodes.BoolOp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a boolean condition can be simplified.

<span class="w"> </span>        Variables will not be simplified, even if the value can be inferred,
<span class="w"> </span>        and expressions like &#39;3 + 4&#39; will remain expanded.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not utils.is_test_condition(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._can_simplify_bool_op = False</span>
<span class="gi">+        simplified_expr = self._simplify_boolean_operation(node)</span>
<span class="gi">+</span>
<span class="gi">+        if not self._can_simplify_bool_op:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not next(simplified_expr.nodes_of_class(nodes.Name), False):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;condition-evals-to-constant&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(node.as_string(), simplified_expr.as_string()),</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;simplifiable-condition&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(node.as_string(), simplified_expr.as_string()),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;consider-merging-isinstance&quot;,</span>
<span class="gi">+        &quot;consider-using-in&quot;,</span>
<span class="gi">+        &quot;chained-comparison&quot;,</span>
<span class="gi">+        &quot;simplifiable-condition&quot;,</span>
<span class="gi">+        &quot;condition-evals-to-constant&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_boolop(self, node: nodes.BoolOp) -&gt; None:</span>
<span class="gi">+        self._check_consider_merging_isinstance(node)</span>
<span class="gi">+        self._check_consider_using_in(node)</span>
<span class="gi">+        self._check_chained_comparison(node)</span>
<span class="gi">+        self._check_simplifiable_condition(node)</span>

<span class="gd">-    def _check_use_list_literal(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_simple_assignment(node: nodes.NodeNG | None) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(node, nodes.Assign)</span>
<span class="gi">+            and len(node.targets) == 1</span>
<span class="gi">+            and isinstance(node.targets[0], nodes.AssignName)</span>
<span class="gi">+            and isinstance(node.value, nodes.Name)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_swap_variables(self, node: nodes.Return | nodes.Assign) -&gt; None:</span>
<span class="gi">+        if not node.next_sibling() or not node.next_sibling().next_sibling():</span>
<span class="gi">+            return</span>
<span class="gi">+        assignments = [node, node.next_sibling(), node.next_sibling().next_sibling()]</span>
<span class="gi">+        if not all(self._is_simple_assignment(node) for node in assignments):</span>
<span class="gi">+            return</span>
<span class="gi">+        if any(node in self._reported_swap_nodes for node in assignments):</span>
<span class="gi">+            return</span>
<span class="gi">+        left = [node.targets[0].name for node in assignments]</span>
<span class="gi">+        right = [node.value.name for node in assignments]</span>
<span class="gi">+        if left[0] == right[-1] and left[1:] == right[:-1]:</span>
<span class="gi">+            self._reported_swap_nodes.update(assignments)</span>
<span class="gi">+            message = &quot;consider-swap-variables&quot;</span>
<span class="gi">+            self.add_message(message, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;simplify-boolean-expression&quot;,</span>
<span class="gi">+        &quot;consider-using-ternary&quot;,</span>
<span class="gi">+        &quot;consider-swap-variables&quot;,</span>
<span class="gi">+        &quot;consider-using-with&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        self._append_context_managers_to_stack(node)</span>
<span class="gi">+        self.visit_return(node)  # remaining checks are identical as for return nodes</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;simplify-boolean-expression&quot;,</span>
<span class="gi">+        &quot;consider-using-ternary&quot;,</span>
<span class="gi">+        &quot;consider-swap-variables&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_return(self, node: nodes.Return | nodes.Assign) -&gt; None:</span>
<span class="gi">+        self._check_swap_variables(node)</span>
<span class="gi">+        if self._is_and_or_ternary(node.value):</span>
<span class="gi">+            cond, truth_value, false_value = self._and_or_ternary_arguments(node.value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if all(</span>
<span class="gi">+            isinstance(value, nodes.Compare) for value in (truth_value, false_value)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        inferred_truth_value = utils.safe_infer(truth_value, compare_constants=True)</span>
<span class="gi">+        if inferred_truth_value is None or isinstance(</span>
<span class="gi">+            inferred_truth_value, UninferableBase</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        truth_boolean_value = inferred_truth_value.bool_value()</span>
<span class="gi">+</span>
<span class="gi">+        if truth_boolean_value is False:</span>
<span class="gi">+            message = &quot;simplify-boolean-expression&quot;</span>
<span class="gi">+            suggestion = false_value.as_string()</span>
<span class="gi">+        else:</span>
<span class="gi">+            message = &quot;consider-using-ternary&quot;</span>
<span class="gi">+            suggestion = f&quot;{truth_value.as_string()} if {cond.as_string()} else {false_value.as_string()}&quot;</span>
<span class="gi">+        self.add_message(message, node=node, args=(suggestion,), confidence=INFERENCE)</span>
<span class="gi">+</span>
<span class="gi">+    def _append_context_managers_to_stack(self, node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        if _is_inside_context_manager(node):</span>
<span class="gi">+            # if we are inside a context manager itself, we assume that it will handle</span>
<span class="gi">+            # the resource management itself.</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node.targets[0], (nodes.Tuple, nodes.List, nodes.Set)):</span>
<span class="gi">+            assignees = node.targets[0].elts</span>
<span class="gi">+            value = utils.safe_infer(node.value)</span>
<span class="gi">+            if value is None or not hasattr(value, &quot;elts&quot;):</span>
<span class="gi">+                # We cannot deduce what values are assigned, so we have to skip this</span>
<span class="gi">+                return</span>
<span class="gi">+            values = value.elts</span>
<span class="gi">+        else:</span>
<span class="gi">+            assignees = [node.targets[0]]</span>
<span class="gi">+            values = [node.value]</span>
<span class="gi">+        if any(isinstance(n, UninferableBase) for n in (assignees, values)):</span>
<span class="gi">+            return</span>
<span class="gi">+        for assignee, value in zip(assignees, values):</span>
<span class="gi">+            if not isinstance(value, nodes.Call):</span>
<span class="gi">+                continue</span>
<span class="gi">+            inferred = utils.safe_infer(value.func)</span>
<span class="gi">+            if (</span>
<span class="gi">+                not inferred</span>
<span class="gi">+                or inferred.qname() not in CALLS_RETURNING_CONTEXT_MANAGERS</span>
<span class="gi">+                or not isinstance(assignee, (nodes.AssignName, nodes.AssignAttr))</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            stack = self._consider_using_with_stack.get_stack_for_frame(node.frame())</span>
<span class="gi">+            varname = (</span>
<span class="gi">+                assignee.name</span>
<span class="gi">+                if isinstance(assignee, nodes.AssignName)</span>
<span class="gi">+                else assignee.attrname</span>
<span class="gi">+            )</span>
<span class="gi">+            if varname in stack:</span>
<span class="gi">+                existing_node = stack[varname]</span>
<span class="gi">+                if astroid.are_exclusive(node, existing_node):</span>
<span class="gi">+                    # only one of the two assignments can be executed at runtime, thus it is fine</span>
<span class="gi">+                    stack[varname] = value</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # variable was redefined before it was used in a ``with`` block</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;consider-using-with&quot;,</span>
<span class="gi">+                    node=existing_node,</span>
<span class="gi">+                )</span>
<span class="gi">+            stack[varname] = value</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_using_with(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if _is_inside_context_manager(node) or _is_a_return_statement(node):</span>
<span class="gi">+            # If we are inside a context manager itself, we assume that it will handle the</span>
<span class="gi">+            # resource management itself.</span>
<span class="gi">+            # If the node is a child of a return, we assume that the caller knows he is getting</span>
<span class="gi">+            # a context manager he should use properly (i.e. in a ``with``).</span>
<span class="gi">+            return</span>
<span class="gi">+        if (</span>
<span class="gi">+            node</span>
<span class="gi">+            in self._consider_using_with_stack.get_stack_for_frame(</span>
<span class="gi">+                node.frame()</span>
<span class="gi">+            ).values()</span>
<span class="gi">+        ):</span>
<span class="gi">+            # the result of this call was already assigned to a variable and will be</span>
<span class="gi">+            # checked when leaving the scope.</span>
<span class="gi">+            return</span>
<span class="gi">+        inferred = utils.safe_infer(node.func)</span>
<span class="gi">+        if not inferred or not isinstance(</span>
<span class="gi">+            inferred, (nodes.FunctionDef, nodes.ClassDef, bases.UnboundMethod)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        could_be_used_in_with = (</span>
<span class="gi">+            # things like ``lock.acquire()``</span>
<span class="gi">+            inferred.qname() in CALLS_THAT_COULD_BE_REPLACED_BY_WITH</span>
<span class="gi">+            or (</span>
<span class="gi">+                # things like ``open(&quot;foo&quot;)`` which are not already inside a ``with`` statement</span>
<span class="gi">+                inferred.qname() in CALLS_RETURNING_CONTEXT_MANAGERS</span>
<span class="gi">+                and not _is_part_of_with_items(node)</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        if could_be_used_in_with and not _will_be_released_automatically(node):</span>
<span class="gi">+            self.add_message(&quot;consider-using-with&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_use_list_literal(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if empty list is created by using the literal [].&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.as_string() == &quot;list()&quot;:</span>
<span class="gi">+            inferred = utils.safe_infer(node.func)</span>
<span class="gi">+            if isinstance(inferred, nodes.ClassDef) and not node.args:</span>
<span class="gi">+                if inferred.qname() == &quot;builtins.list&quot;:</span>
<span class="gi">+                    self.add_message(&quot;use-list-literal&quot;, node=node)</span>

<span class="gd">-    def _check_use_dict_literal(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    def _check_use_dict_literal(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if dict is created by using the literal {}.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.func, astroid.Name) or node.func.name != &quot;dict&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+        inferred = utils.safe_infer(node.func)</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(inferred, nodes.ClassDef)</span>
<span class="gi">+            and inferred.qname() == &quot;builtins.dict&quot;</span>
<span class="gi">+            and not node.args</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;use-dict-literal&quot;,</span>
<span class="gi">+                args=(self._dict_literal_suggestion(node),),</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _dict_literal_suggestion(node: nodes.Call) -&gt;str:</span>
<span class="gi">+    def _dict_literal_suggestion(node: nodes.Call) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a suggestion of reasonable length.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _name_to_concatenate(self, node: nodes.NodeNG) -&gt;(str | None):</span>
<span class="gi">+        elements: list[str] = []</span>
<span class="gi">+        for keyword in node.keywords:</span>
<span class="gi">+            if len(&quot;, &quot;.join(elements)) &gt;= 64:</span>
<span class="gi">+                break</span>
<span class="gi">+            if keyword not in node.kwargs:</span>
<span class="gi">+                elements.append(f&#39;&quot;{keyword.arg}&quot;: {keyword.value.as_string()}&#39;)</span>
<span class="gi">+        for keyword in node.kwargs:</span>
<span class="gi">+            if len(&quot;, &quot;.join(elements)) &gt;= 64:</span>
<span class="gi">+                break</span>
<span class="gi">+            elements.append(f&quot;**{keyword.value.as_string()}&quot;)</span>
<span class="gi">+        suggestion = &quot;, &quot;.join(elements)</span>
<span class="gi">+        return f&quot;{{{suggestion}{&#39;, ... &#39;  if len(suggestion) &gt; 64 else &#39;&#39;}}}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _name_to_concatenate(self, node: nodes.NodeNG) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to extract the name used in a concatenation loop.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_consider_using_join(self, aug_assign: nodes.AugAssign) -&gt;None:</span>
<span class="gi">+        if isinstance(node, nodes.Name):</span>
<span class="gi">+            return cast(&quot;str | None&quot;, node.name)</span>
<span class="gi">+        if not isinstance(node, nodes.JoinedStr):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        values = [</span>
<span class="gi">+            value for value in node.values if isinstance(value, nodes.FormattedValue)</span>
<span class="gi">+        ]</span>
<span class="gi">+        if len(values) != 1 or not isinstance(values[0].value, nodes.Name):</span>
<span class="gi">+            return None</span>
<span class="gi">+        # If there are more values in joined string than formatted values,</span>
<span class="gi">+        # they are probably separators.</span>
<span class="gi">+        # Allow them only if the option `suggest-join-with-non-empty-separator` is set</span>
<span class="gi">+        with_separators = len(node.values) &gt; len(values)</span>
<span class="gi">+        if with_separators and not self._suggest_join_with_non_empty_separator:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return cast(&quot;str | None&quot;, values[0].value.name)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_using_join(self, aug_assign: nodes.AugAssign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;We start with the augmented assignment and work our way upwards.

<span class="w"> </span>        Names of variables for nodes if match successful:
<span class="gu">@@ -379,17 +1775,156 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        for number in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]  # for_loop
<span class="w"> </span>            result += number  # aug_assign
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for_loop = aug_assign.parent</span>
<span class="gi">+        if not isinstance(for_loop, nodes.For) or len(for_loop.body) &gt; 1:</span>
<span class="gi">+            return</span>
<span class="gi">+        assign = for_loop.previous_sibling()</span>
<span class="gi">+        if not isinstance(assign, nodes.Assign):</span>
<span class="gi">+            return</span>
<span class="gi">+        result_assign_names = {</span>
<span class="gi">+            target.name</span>
<span class="gi">+            for target in assign.targets</span>
<span class="gi">+            if isinstance(target, nodes.AssignName)</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        is_concat_loop = (</span>
<span class="gi">+            aug_assign.op == &quot;+=&quot;</span>
<span class="gi">+            and isinstance(aug_assign.target, nodes.AssignName)</span>
<span class="gi">+            and len(for_loop.body) == 1</span>
<span class="gi">+            and aug_assign.target.name in result_assign_names</span>
<span class="gi">+            and isinstance(assign.value, nodes.Const)</span>
<span class="gi">+            and isinstance(assign.value.value, str)</span>
<span class="gi">+            and self._name_to_concatenate(aug_assign.value) == for_loop.target.name</span>
<span class="gi">+        )</span>
<span class="gi">+        if is_concat_loop:</span>
<span class="gi">+            self.add_message(&quot;consider-using-join&quot;, node=aug_assign)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;consider-using-join&quot;)</span>
<span class="gi">+    def visit_augassign(self, node: nodes.AugAssign) -&gt; None:</span>
<span class="gi">+        self._check_consider_using_join(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;unnecessary-comprehension&quot;,</span>
<span class="gi">+        &quot;unnecessary-dict-index-lookup&quot;,</span>
<span class="gi">+        &quot;unnecessary-list-index-lookup&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_comprehension(self, node: nodes.Comprehension) -&gt; None:</span>
<span class="gi">+        self._check_unnecessary_comprehension(node)</span>
<span class="gi">+        self._check_unnecessary_dict_index_lookup(node)</span>
<span class="gi">+        self._check_unnecessary_list_index_lookup(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_unnecessary_comprehension(self, node: nodes.Comprehension) -&gt; None:</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.parent, nodes.GeneratorExp)</span>
<span class="gi">+            or len(node.ifs) != 0</span>
<span class="gi">+            or len(node.parent.generators) != 1</span>
<span class="gi">+            or node.is_async</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.parent, nodes.DictComp)</span>
<span class="gi">+            and isinstance(node.parent.key, nodes.Name)</span>
<span class="gi">+            and isinstance(node.parent.value, nodes.Name)</span>
<span class="gi">+            and isinstance(node.target, nodes.Tuple)</span>
<span class="gi">+            and all(isinstance(elt, nodes.AssignName) for elt in node.target.elts)</span>
<span class="gi">+        ):</span>
<span class="gi">+            expr_list = [node.parent.key.name, node.parent.value.name]</span>
<span class="gi">+            target_list = [elt.name for elt in node.target.elts]</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(node.parent, (nodes.ListComp, nodes.SetComp)):</span>
<span class="gi">+            expr = node.parent.elt</span>
<span class="gi">+            if isinstance(expr, nodes.Name):</span>
<span class="gi">+                expr_list = expr.name</span>
<span class="gi">+            elif isinstance(expr, nodes.Tuple):</span>
<span class="gi">+                if any(not isinstance(elt, nodes.Name) for elt in expr.elts):</span>
<span class="gi">+                    return</span>
<span class="gi">+                expr_list = [elt.name for elt in expr.elts]</span>
<span class="gi">+            else:</span>
<span class="gi">+                expr_list = []</span>
<span class="gi">+            target = node.parent.generators[0].target</span>
<span class="gi">+            target_list = (</span>
<span class="gi">+                target.name</span>
<span class="gi">+                if isinstance(target, nodes.AssignName)</span>
<span class="gi">+                else (</span>
<span class="gi">+                    [</span>
<span class="gi">+                        elt.name</span>
<span class="gi">+                        for elt in target.elts</span>
<span class="gi">+                        if isinstance(elt, nodes.AssignName)</span>
<span class="gi">+                    ]</span>
<span class="gi">+                    if isinstance(target, nodes.Tuple)</span>
<span class="gi">+                    else []</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+        if expr_list == target_list and expr_list:</span>
<span class="gi">+            args: tuple[str] | None = None</span>
<span class="gi">+            inferred = utils.safe_infer(node.iter)</span>
<span class="gi">+            if isinstance(node.parent, nodes.DictComp) and isinstance(</span>
<span class="gi">+                inferred, astroid.objects.DictItems</span>
<span class="gi">+            ):</span>
<span class="gi">+                args = (f&quot;dict({node.iter.func.expr.as_string()})&quot;,)</span>
<span class="gi">+            elif isinstance(node.parent, nodes.ListComp) and isinstance(</span>
<span class="gi">+                inferred, nodes.List</span>
<span class="gi">+            ):</span>
<span class="gi">+                args = (f&quot;list({node.iter.as_string()})&quot;,)</span>
<span class="gi">+            elif isinstance(node.parent, nodes.SetComp) and isinstance(</span>
<span class="gi">+                inferred, nodes.Set</span>
<span class="gi">+            ):</span>
<span class="gi">+                args = (f&quot;set({node.iter.as_string()})&quot;,)</span>
<span class="gi">+            if args:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;unnecessary-comprehension&quot;, node=node.parent, args=args</span>
<span class="gi">+                )</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(node.parent, nodes.DictComp):</span>
<span class="gi">+                func = &quot;dict&quot;</span>
<span class="gi">+            elif isinstance(node.parent, nodes.ListComp):</span>
<span class="gi">+                func = &quot;list&quot;</span>
<span class="gi">+            elif isinstance(node.parent, nodes.SetComp):</span>
<span class="gi">+                func = &quot;set&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unnecessary-comprehension&quot;,</span>
<span class="gi">+                node=node.parent,</span>
<span class="gi">+                args=(f&quot;{func}({node.iter.as_string()})&quot;,),</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_and_or_ternary(node: (nodes.NodeNG | None)) -&gt;bool:</span>
<span class="gi">+    def _is_and_or_ternary(node: nodes.NodeNG | None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns true if node is &#39;condition and true_value or false_value&#39; form.

<span class="w"> </span>        All of: condition, true_value and false_value should not be a complex boolean expression
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(node, nodes.BoolOp)</span>
<span class="gi">+            and node.op == &quot;or&quot;</span>
<span class="gi">+            and len(node.values) == 2</span>
<span class="gi">+            and isinstance(node.values[0], nodes.BoolOp)</span>
<span class="gi">+            and not isinstance(node.values[1], nodes.BoolOp)</span>
<span class="gi">+            and node.values[0].op == &quot;and&quot;</span>
<span class="gi">+            and not isinstance(node.values[0].values[1], nodes.BoolOp)</span>
<span class="gi">+            and len(node.values[0].values) == 2</span>
<span class="gi">+        )</span>

<span class="gd">-    def _check_consistent_returns(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _and_or_ternary_arguments(</span>
<span class="gi">+        node: nodes.BoolOp,</span>
<span class="gi">+    ) -&gt; tuple[nodes.NodeNG, nodes.NodeNG, nodes.NodeNG]:</span>
<span class="gi">+        false_value = node.values[1]</span>
<span class="gi">+        condition, true_value = node.values[0].values</span>
<span class="gi">+        return condition, true_value, false_value</span>
<span class="gi">+</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        self._return_nodes[node.name] = list(</span>
<span class="gi">+            node.nodes_of_class(nodes.Return, skip_klass=nodes.FunctionDef)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consistent_returns(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that all return statements inside a function are consistent.

<span class="w"> </span>        Return statements are consistent if:
<span class="gu">@@ -399,9 +1934,19 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        Args:
<span class="w"> </span>            node (nodes.FunctionDef): the function holding the return statements.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _is_if_node_return_ended(self, node: nodes.If) -&gt;bool:</span>
<span class="gi">+        # explicit return statements are those with a not None value</span>
<span class="gi">+        explicit_returns = [</span>
<span class="gi">+            _node for _node in self._return_nodes[node.name] if _node.value is not None</span>
<span class="gi">+        ]</span>
<span class="gi">+        if not explicit_returns:</span>
<span class="gi">+            return</span>
<span class="gi">+        if len(explicit_returns) == len(</span>
<span class="gi">+            self._return_nodes[node.name]</span>
<span class="gi">+        ) and self._is_node_return_ended(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        self.add_message(&quot;inconsistent-return-statements&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _is_if_node_return_ended(self, node: nodes.If) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the If node ends with an explicit return statement.

<span class="w"> </span>        Args:
<span class="gu">@@ -410,9 +1955,28 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            bool: True if the node ends with an explicit statement, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _is_raise_node_return_ended(self, node: nodes.Raise) -&gt;bool:</span>
<span class="gi">+        # Do not check if inner function definition are return ended.</span>
<span class="gi">+        is_if_returning = any(</span>
<span class="gi">+            self._is_node_return_ended(_ifn)</span>
<span class="gi">+            for _ifn in node.body</span>
<span class="gi">+            if not isinstance(_ifn, nodes.FunctionDef)</span>
<span class="gi">+        )</span>
<span class="gi">+        if not node.orelse:</span>
<span class="gi">+            # If there is not orelse part then the if statement is returning if :</span>
<span class="gi">+            # - there is at least one return statement in its siblings;</span>
<span class="gi">+            # - the if body is itself returning.</span>
<span class="gi">+            if not self._has_return_in_siblings(node):</span>
<span class="gi">+                return False</span>
<span class="gi">+            return is_if_returning</span>
<span class="gi">+        # If there is an orelse part then both if body and orelse part should return.</span>
<span class="gi">+        is_orelse_returning = any(</span>
<span class="gi">+            self._is_node_return_ended(_ore)</span>
<span class="gi">+            for _ore in node.orelse</span>
<span class="gi">+            if not isinstance(_ore, nodes.FunctionDef)</span>
<span class="gi">+        )</span>
<span class="gi">+        return is_if_returning and is_orelse_returning</span>
<span class="gi">+</span>
<span class="gi">+    def _is_raise_node_return_ended(self, node: nodes.Raise) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the Raise node ends with an explicit return statement.

<span class="w"> </span>        Args:
<span class="gu">@@ -421,9 +1985,35 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            bool: True if the node ends with an explicit statement, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _is_node_return_ended(self, node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+        # a Raise statement doesn&#39;t need to end with a return statement</span>
<span class="gi">+        # but if the exception raised is handled, then the handler has to</span>
<span class="gi">+        # ends with a return statement</span>
<span class="gi">+        if not node.exc:</span>
<span class="gi">+            # Ignore bare raises</span>
<span class="gi">+            return True</span>
<span class="gi">+        if not utils.is_node_inside_try_except(node):</span>
<span class="gi">+            # If the raise statement is not inside a try/except statement</span>
<span class="gi">+            # then the exception is raised and cannot be caught. No need</span>
<span class="gi">+            # to infer it.</span>
<span class="gi">+            return True</span>
<span class="gi">+        exc = utils.safe_infer(node.exc)</span>
<span class="gi">+        if (</span>
<span class="gi">+            exc is None</span>
<span class="gi">+            or isinstance(exc, UninferableBase)</span>
<span class="gi">+            or not hasattr(exc, &quot;pytype&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+        exc_name = exc.pytype().split(&quot;.&quot;)[-1]</span>
<span class="gi">+        handlers = utils.get_exception_handlers(node, exc_name)</span>
<span class="gi">+        handlers = list(handlers) if handlers is not None else []</span>
<span class="gi">+        if handlers:</span>
<span class="gi">+            # among all the handlers handling the exception at least one</span>
<span class="gi">+            # must end with a return statement</span>
<span class="gi">+            return any(self._is_node_return_ended(_handler) for _handler in handlers)</span>
<span class="gi">+        # if no handlers handle the exception then it&#39;s ok</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def _is_node_return_ended(self, node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the node ends with an explicit return statement.

<span class="w"> </span>        Args:
<span class="gu">@@ -432,15 +2022,59 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            bool: True if the node ends with an explicit statement, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Recursion base case</span>
<span class="gi">+        if isinstance(node, nodes.Return):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(node, nodes.Call):</span>
<span class="gi">+            try:</span>
<span class="gi">+                funcdef_node = node.func.inferred()[0]</span>
<span class="gi">+                if self._is_function_def_never_returning(funcdef_node):</span>
<span class="gi">+                    return True</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        if isinstance(node, nodes.While):</span>
<span class="gi">+            # A while-loop is considered return-ended if it has a</span>
<span class="gi">+            # truthy test and no break statements</span>
<span class="gi">+            return (node.test.bool_value() and not _loop_exits_early(node)) or any(</span>
<span class="gi">+                self._is_node_return_ended(child) for child in node.orelse</span>
<span class="gi">+            )</span>
<span class="gi">+        if isinstance(node, nodes.Raise):</span>
<span class="gi">+            return self._is_raise_node_return_ended(node)</span>
<span class="gi">+        if isinstance(node, nodes.If):</span>
<span class="gi">+            return self._is_if_node_return_ended(node)</span>
<span class="gi">+        if isinstance(node, nodes.Try):</span>
<span class="gi">+            handlers = {</span>
<span class="gi">+                _child</span>
<span class="gi">+                for _child in node.get_children()</span>
<span class="gi">+                if isinstance(_child, nodes.ExceptHandler)</span>
<span class="gi">+            }</span>
<span class="gi">+            all_but_handler = set(node.get_children()) - handlers</span>
<span class="gi">+            return any(</span>
<span class="gi">+                self._is_node_return_ended(_child) for _child in all_but_handler</span>
<span class="gi">+            ) and all(self._is_node_return_ended(_child) for _child in handlers)</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, nodes.Assert)</span>
<span class="gi">+            and isinstance(node.test, nodes.Const)</span>
<span class="gi">+            and not node.test.value</span>
<span class="gi">+        ):</span>
<span class="gi">+            # consider assert False as a return node</span>
<span class="gi">+            return True</span>
<span class="gi">+        # recurses on the children of the node</span>
<span class="gi">+        return any(self._is_node_return_ended(_child) for _child in node.get_children())</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _has_return_in_siblings(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    def _has_return_in_siblings(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns True if there is at least one return in the node&#39;s siblings.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _is_function_def_never_returning(self, node: (nodes.FunctionDef |</span>
<span class="gd">-        astroid.BoundMethod)) -&gt;bool:</span>
<span class="gi">+        next_sibling = node.next_sibling()</span>
<span class="gi">+        while next_sibling:</span>
<span class="gi">+            if isinstance(next_sibling, nodes.Return):</span>
<span class="gi">+                return True</span>
<span class="gi">+            next_sibling = next_sibling.next_sibling()</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _is_function_def_never_returning(</span>
<span class="gi">+        self, node: nodes.FunctionDef | astroid.BoundMethod</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if the function never returns, False otherwise.

<span class="w"> </span>        Args:
<span class="gu">@@ -449,9 +2083,19 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            bool: True if the function never returns, False otherwise.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_return_at_the_end(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+        if isinstance(node, (nodes.FunctionDef, astroid.BoundMethod)) and node.returns:</span>
<span class="gi">+            return (</span>
<span class="gi">+                isinstance(node.returns, nodes.Attribute)</span>
<span class="gi">+                and node.returns.attrname == &quot;NoReturn&quot;</span>
<span class="gi">+                or isinstance(node.returns, nodes.Name)</span>
<span class="gi">+                and node.returns.name == &quot;NoReturn&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        try:</span>
<span class="gi">+            return node.qname() in self._never_returning_functions</span>
<span class="gi">+        except (TypeError, AttributeError):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def _check_return_at_the_end(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for presence of a *single* return statement at the end of a
<span class="w"> </span>        function.

<span class="gu">@@ -463,15 +2107,311 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        Per its implementation and PEP8 we can have a &quot;return None&quot; at the end
<span class="w"> </span>        of the function body if there are other return statements before that!
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_unnecessary_dict_index_lookup(self, node: (nodes.For | nodes</span>
<span class="gd">-        .Comprehension)) -&gt;None:</span>
<span class="gi">+        if len(self._return_nodes[node.name]) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not node.body:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        last = node.body[-1]</span>
<span class="gi">+        if isinstance(last, nodes.Return) and len(node.body) == 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        while isinstance(last, (nodes.If, nodes.Try, nodes.ExceptHandler)):</span>
<span class="gi">+            last = last.last_child()</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(last, nodes.Return):</span>
<span class="gi">+            # e.g. &quot;return&quot;</span>
<span class="gi">+            if last.value is None:</span>
<span class="gi">+                self.add_message(&quot;useless-return&quot;, node=node)</span>
<span class="gi">+            # return None&quot;</span>
<span class="gi">+            elif isinstance(last.value, nodes.Const) and (last.value.value is None):</span>
<span class="gi">+                self.add_message(&quot;useless-return&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_unnecessary_dict_index_lookup(</span>
<span class="gi">+        self, node: nodes.For | nodes.Comprehension</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add message when accessing dict values by index lookup.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _enumerate_with_start(self, node: (nodes.For | nodes.Comprehension)</span>
<span class="gd">-        ) -&gt;tuple[bool, Confidence]:</span>
<span class="gi">+        # Verify that we have an .items() call and</span>
<span class="gi">+        # that the object which is iterated is used as a subscript in the</span>
<span class="gi">+        # body of the for.</span>
<span class="gi">+        # Is it a proper items call?</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.iter, nodes.Call)</span>
<span class="gi">+            and isinstance(node.iter.func, nodes.Attribute)</span>
<span class="gi">+            and node.iter.func.attrname == &quot;items&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            inferred = utils.safe_infer(node.iter.func)</span>
<span class="gi">+            if not isinstance(inferred, astroid.BoundMethod):</span>
<span class="gi">+                return</span>
<span class="gi">+            iterating_object_name = node.iter.func.expr.as_string()</span>
<span class="gi">+</span>
<span class="gi">+            # Store potential violations. These will only be reported if we don&#39;t</span>
<span class="gi">+            # discover any writes to the collection during the loop.</span>
<span class="gi">+            messages = []</span>
<span class="gi">+</span>
<span class="gi">+            # Verify that the body of the for loop uses a subscript</span>
<span class="gi">+            # with the object that was iterated. This uses some heuristics</span>
<span class="gi">+            # in order to make sure that the same object is used in the</span>
<span class="gi">+            # for body.</span>
<span class="gi">+</span>
<span class="gi">+            children = (</span>
<span class="gi">+                node.body</span>
<span class="gi">+                if isinstance(node, nodes.For)</span>
<span class="gi">+                else list(node.parent.get_children())</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Check if there are any for / while loops within the loop in question;</span>
<span class="gi">+            # If so, we will be more conservative about reporting errors as we</span>
<span class="gi">+            # can&#39;t yet do proper control flow analysis to be sure when</span>
<span class="gi">+            # reassignment will affect us</span>
<span class="gi">+            nested_loops = itertools.chain.from_iterable(</span>
<span class="gi">+                child.nodes_of_class((nodes.For, nodes.While)) for child in children</span>
<span class="gi">+            )</span>
<span class="gi">+            has_nested_loops = next(nested_loops, None) is not None</span>
<span class="gi">+</span>
<span class="gi">+            for child in children:</span>
<span class="gi">+                for subscript in child.nodes_of_class(nodes.Subscript):</span>
<span class="gi">+                    if not isinstance(subscript.value, (nodes.Name, nodes.Attribute)):</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    value = subscript.slice</span>
<span class="gi">+</span>
<span class="gi">+                    if isinstance(node, nodes.For) and _is_part_of_assignment_target(</span>
<span class="gi">+                        subscript</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        # Ignore this subscript if it is the target of an assignment</span>
<span class="gi">+                        # Early termination; after reassignment dict index lookup will be necessary</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                    if isinstance(subscript.parent, nodes.Delete):</span>
<span class="gi">+                        # Ignore this subscript if it&#39;s used with the delete keyword</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                    # Case where .items is assigned to k,v (i.e., for k, v in d.items())</span>
<span class="gi">+                    if isinstance(value, nodes.Name):</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            not isinstance(node.target, nodes.Tuple)</span>
<span class="gi">+                            # Ignore 1-tuples: for k, in d.items()</span>
<span class="gi">+                            or len(node.target.elts) &lt; 2</span>
<span class="gi">+                            or value.name != node.target.elts[0].name</span>
<span class="gi">+                            or iterating_object_name != subscript.value.as_string()</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            isinstance(node, nodes.For)</span>
<span class="gi">+                            and value.lookup(value.name)[1][-1].lineno &gt; node.lineno</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            # Ignore this subscript if it has been redefined after</span>
<span class="gi">+                            # the for loop. This checks for the line number using .lookup()</span>
<span class="gi">+                            # to get the line number where the iterating object was last</span>
<span class="gi">+                            # defined and compare that to the for loop&#39;s line number</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                        if has_nested_loops:</span>
<span class="gi">+                            messages.append(</span>
<span class="gi">+                                {</span>
<span class="gi">+                                    &quot;node&quot;: subscript,</span>
<span class="gi">+                                    &quot;variable&quot;: node.target.elts[1].as_string(),</span>
<span class="gi">+                                }</span>
<span class="gi">+                            )</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            self.add_message(</span>
<span class="gi">+                                &quot;unnecessary-dict-index-lookup&quot;,</span>
<span class="gi">+                                node=subscript,</span>
<span class="gi">+                                args=(node.target.elts[1].as_string(),),</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+                    # Case where .items is assigned to single var (i.e., for item in d.items())</span>
<span class="gi">+                    elif isinstance(value, nodes.Subscript):</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            not isinstance(node.target, nodes.AssignName)</span>
<span class="gi">+                            or not isinstance(value.value, nodes.Name)</span>
<span class="gi">+                            or node.target.name != value.value.name</span>
<span class="gi">+                            or iterating_object_name != subscript.value.as_string()</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            isinstance(node, nodes.For)</span>
<span class="gi">+                            and value.value.lookup(value.value.name)[1][-1].lineno</span>
<span class="gi">+                            &gt; node.lineno</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            # Ignore this subscript if it has been redefined after</span>
<span class="gi">+                            # the for loop. This checks for the line number using .lookup()</span>
<span class="gi">+                            # to get the line number where the iterating object was last</span>
<span class="gi">+                            # defined and compare that to the for loop&#39;s line number</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                        # check if subscripted by 0 (key)</span>
<span class="gi">+                        inferred = utils.safe_infer(value.slice)</span>
<span class="gi">+                        if not isinstance(inferred, nodes.Const) or inferred.value != 0:</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                        if has_nested_loops:</span>
<span class="gi">+                            messages.append(</span>
<span class="gi">+                                {</span>
<span class="gi">+                                    &quot;node&quot;: subscript,</span>
<span class="gi">+                                    &quot;variable&quot;: &quot;1&quot;.join(</span>
<span class="gi">+                                        value.as_string().rsplit(&quot;0&quot;, maxsplit=1)</span>
<span class="gi">+                                    ),</span>
<span class="gi">+                                }</span>
<span class="gi">+                            )</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            self.add_message(</span>
<span class="gi">+                                &quot;unnecessary-dict-index-lookup&quot;,</span>
<span class="gi">+                                node=subscript,</span>
<span class="gi">+                                args=(</span>
<span class="gi">+                                    &quot;1&quot;.join(value.as_string().rsplit(&quot;0&quot;, maxsplit=1)),</span>
<span class="gi">+                                ),</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+            for message in messages:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;unnecessary-dict-index-lookup&quot;,</span>
<span class="gi">+                    node=message[&quot;node&quot;],</span>
<span class="gi">+                    args=(message[&quot;variable&quot;],),</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_unnecessary_list_index_lookup(</span>
<span class="gi">+        self, node: nodes.For | nodes.Comprehension</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(node.iter, nodes.Call)</span>
<span class="gi">+            or not isinstance(node.iter.func, nodes.Name)</span>
<span class="gi">+            or not node.iter.func.name == &quot;enumerate&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        preliminary_confidence = HIGH</span>
<span class="gi">+        try:</span>
<span class="gi">+            iterable_arg = utils.get_argument_from_call(</span>
<span class="gi">+                node.iter, position=0, keyword=&quot;iterable&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        except utils.NoSuchArgumentError:</span>
<span class="gi">+            iterable_arg = utils.infer_kwarg_from_call(node.iter, keyword=&quot;iterable&quot;)</span>
<span class="gi">+            preliminary_confidence = INFERENCE</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(iterable_arg, nodes.Name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(node.target, nodes.Tuple) or len(node.target.elts) &lt; 2:</span>
<span class="gi">+            # enumerate() result is being assigned without destructuring</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(node.target.elts[1], nodes.AssignName):</span>
<span class="gi">+            # The value is not being assigned to a single variable, e.g. being</span>
<span class="gi">+            # destructured, so we can&#39;t necessarily use it.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        has_start_arg, confidence = self._enumerate_with_start(node)</span>
<span class="gi">+        if has_start_arg:</span>
<span class="gi">+            # enumerate is being called with start arg/kwarg so resulting index lookup</span>
<span class="gi">+            # is not redundant, hence we should not report an error.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Preserve preliminary_confidence if it was INFERENCE</span>
<span class="gi">+        confidence = (</span>
<span class="gi">+            preliminary_confidence</span>
<span class="gi">+            if preliminary_confidence == INFERENCE</span>
<span class="gi">+            else confidence</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        iterating_object_name = iterable_arg.name</span>
<span class="gi">+        value_variable = node.target.elts[1]</span>
<span class="gi">+</span>
<span class="gi">+        # Store potential violations. These will only be reported if we don&#39;t</span>
<span class="gi">+        # discover any writes to the collection during the loop.</span>
<span class="gi">+        bad_nodes = []</span>
<span class="gi">+</span>
<span class="gi">+        children = (</span>
<span class="gi">+            node.body</span>
<span class="gi">+            if isinstance(node, nodes.For)</span>
<span class="gi">+            else list(node.parent.get_children())</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Check if there are any for / while loops within the loop in question;</span>
<span class="gi">+        # If so, we will be more conservative about reporting errors as we</span>
<span class="gi">+        # can&#39;t yet do proper control flow analysis to be sure when</span>
<span class="gi">+        # reassignment will affect us</span>
<span class="gi">+        nested_loops = itertools.chain.from_iterable(</span>
<span class="gi">+            child.nodes_of_class((nodes.For, nodes.While)) for child in children</span>
<span class="gi">+        )</span>
<span class="gi">+        has_nested_loops = next(nested_loops, None) is not None</span>
<span class="gi">+</span>
<span class="gi">+        # Check if there are any if statements within the loop in question;</span>
<span class="gi">+        # If so, we will be more conservative about reporting errors as we</span>
<span class="gi">+        # can&#39;t yet do proper control flow analysis to be sure when</span>
<span class="gi">+        # reassignment will affect us</span>
<span class="gi">+        if_statements = itertools.chain.from_iterable(</span>
<span class="gi">+            child.nodes_of_class(nodes.If) for child in children</span>
<span class="gi">+        )</span>
<span class="gi">+        has_if_statements = next(if_statements, None) is not None</span>
<span class="gi">+</span>
<span class="gi">+        for child in children:</span>
<span class="gi">+            for subscript in child.nodes_of_class(nodes.Subscript):</span>
<span class="gi">+                if isinstance(node, nodes.For) and _is_part_of_assignment_target(</span>
<span class="gi">+                    subscript</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Ignore this subscript if it is the target of an assignment</span>
<span class="gi">+                    # Early termination; after reassignment index lookup will be necessary</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                if isinstance(subscript.parent, nodes.Delete):</span>
<span class="gi">+                    # Ignore this subscript if it&#39;s used with the delete keyword</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                index = subscript.slice</span>
<span class="gi">+                if isinstance(index, nodes.Name):</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        index.name != node.target.elts[0].name</span>
<span class="gi">+                        or iterating_object_name != subscript.value.as_string()</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        isinstance(node, nodes.For)</span>
<span class="gi">+                        and index.lookup(index.name)[1][-1].lineno &gt; node.lineno</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        # Ignore this subscript if it has been redefined after</span>
<span class="gi">+                        # the for loop.</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        isinstance(node, nodes.For)</span>
<span class="gi">+                        and index.lookup(value_variable.name)[1][-1].lineno</span>
<span class="gi">+                        &gt; node.lineno</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        # The variable holding the value from iteration has been</span>
<span class="gi">+                        # reassigned on a later line, so it can&#39;t be used.</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if has_nested_loops:</span>
<span class="gi">+                        # Have found a likely issue, but since there are nested</span>
<span class="gi">+                        # loops we don&#39;t want to report this unless we get to the</span>
<span class="gi">+                        # end of the loop without updating the collection</span>
<span class="gi">+                        bad_nodes.append(subscript)</span>
<span class="gi">+                    elif has_if_statements:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;unnecessary-list-index-lookup&quot;,</span>
<span class="gi">+                            node=subscript,</span>
<span class="gi">+                            args=(node.target.elts[1].name,),</span>
<span class="gi">+                            confidence=confidence,</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+        for subscript in bad_nodes:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unnecessary-list-index-lookup&quot;,</span>
<span class="gi">+                node=subscript,</span>
<span class="gi">+                args=(node.target.elts[1].name,),</span>
<span class="gi">+                confidence=confidence,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _enumerate_with_start(</span>
<span class="gi">+        self, node: nodes.For | nodes.Comprehension</span>
<span class="gi">+    ) -&gt; tuple[bool, Confidence]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check presence of `start` kwarg or second argument to enumerate.

<span class="w"> </span>        For example:
<span class="gu">@@ -482,4 +2422,40 @@ class RefactoringChecker(checkers.BaseTokenChecker):</span>
<span class="w"> </span>        If `start` is assigned to `0`, the default value, this is equivalent to
<span class="w"> </span>        not calling `enumerate` with start.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        confidence = HIGH</span>
<span class="gi">+</span>
<span class="gi">+        if len(node.iter.args) &gt; 1:</span>
<span class="gi">+            # We assume the second argument to `enumerate` is the `start` int arg.</span>
<span class="gi">+            # It&#39;s a reasonable assumption for now as it&#39;s the only possible argument:</span>
<span class="gi">+            # https://docs.python.org/3/library/functions.html#enumerate</span>
<span class="gi">+            start_arg = node.iter.args[1]</span>
<span class="gi">+            start_val, confidence = self._get_start_value(start_arg)</span>
<span class="gi">+            if start_val is None:</span>
<span class="gi">+                return False, confidence</span>
<span class="gi">+            return not start_val == 0, confidence</span>
<span class="gi">+</span>
<span class="gi">+        for keyword in node.iter.keywords:</span>
<span class="gi">+            if keyword.arg == &quot;start&quot;:</span>
<span class="gi">+                start_val, confidence = self._get_start_value(keyword.value)</span>
<span class="gi">+                if start_val is None:</span>
<span class="gi">+                    return False, confidence</span>
<span class="gi">+                return not start_val == 0, confidence</span>
<span class="gi">+</span>
<span class="gi">+        return False, confidence</span>
<span class="gi">+</span>
<span class="gi">+    def _get_start_value(self, node: nodes.NodeNG) -&gt; tuple[int | None, Confidence]:</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, (nodes.Name, nodes.Call, nodes.Attribute))</span>
<span class="gi">+            or isinstance(node, nodes.UnaryOp)</span>
<span class="gi">+            and isinstance(node.operand, (nodes.Attribute, nodes.Name))</span>
<span class="gi">+        ):</span>
<span class="gi">+            inferred = utils.safe_infer(node)</span>
<span class="gi">+            # inferred can be an astroid.base.Instance as in &#39;enumerate(x, int(y))&#39; or</span>
<span class="gi">+            # not correctly inferred (None)</span>
<span class="gi">+            start_val = inferred.value if isinstance(inferred, nodes.Const) else None</span>
<span class="gi">+            return start_val, INFERENCE</span>
<span class="gi">+        if isinstance(node, nodes.UnaryOp):</span>
<span class="gi">+            return node.operand.value, HIGH</span>
<span class="gi">+        if isinstance(node, nodes.Const):</span>
<span class="gi">+            return node.value, HIGH</span>
<span class="gi">+        return None, HIGH</span>
<span class="gh">diff --git a/pylint/checkers/similar.py b/pylint/checkers/similar.py</span>
<span class="gh">index b85648de9..ee1b60843 100644</span>
<span class="gd">--- a/pylint/checkers/similar.py</span>
<span class="gi">+++ b/pylint/checkers/similar.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;A similarities / code duplication command line tool and pylint checker.

<span class="w"> </span>The algorithm is based on comparing the hash value of n successive lines of a file.
<span class="gu">@@ -22,7 +26,9 @@ are common.</span>
<span class="w"> </span>Once post-processed the values of association table are the result looked for, i.e.
<span class="w"> </span>start and end lines numbers of common lines in both files.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import copy
<span class="w"> </span>import functools
<span class="gu">@@ -36,28 +42,54 @@ from collections.abc import Callable, Generator, Iterable, Sequence</span>
<span class="w"> </span>from getopt import GetoptError, getopt
<span class="w"> </span>from io import BufferedIOBase, BufferedReader, BytesIO
<span class="w"> </span>from itertools import chain
<span class="gd">-from typing import TYPE_CHECKING, Dict, List, NamedTuple, NewType, NoReturn, TextIO, Tuple, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    List,</span>
<span class="gi">+    NamedTuple,</span>
<span class="gi">+    NewType,</span>
<span class="gi">+    NoReturn,</span>
<span class="gi">+    TextIO,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, BaseRawFileChecker, table_lines_from_stats
<span class="w"> </span>from pylint.reporters.ureports.nodes import Section, Table
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple, Options
<span class="w"> </span>from pylint.utils import LinterStats, decoding_stream
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_MIN_SIMILARITY_LINE = 4
<span class="gd">-REGEX_FOR_LINES_WITH_CONTENT = re.compile(&#39;.*\\w+&#39;)</span>
<span class="gd">-Index = NewType(&#39;Index&#39;, int)</span>
<span class="gd">-LineNumber = NewType(&#39;LineNumber&#39;, int)</span>

<span class="gi">+REGEX_FOR_LINES_WITH_CONTENT = re.compile(r&quot;.*\w+&quot;)</span>

<span class="gi">+# Index defines a location in a LineSet stripped lines collection</span>
<span class="gi">+Index = NewType(&quot;Index&quot;, int)</span>
<span class="gi">+</span>
<span class="gi">+# LineNumber defines a location in a LinesSet real lines collection (the whole file lines)</span>
<span class="gi">+LineNumber = NewType(&quot;LineNumber&quot;, int)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# LineSpecifs holds characteristics of a line in a file</span>
<span class="w"> </span>class LineSpecifs(NamedTuple):
<span class="w"> </span>    line_number: LineNumber
<span class="w"> </span>    text: str


<span class="gd">-HashToIndex_T = Dict[&#39;LinesChunk&#39;, List[Index]]</span>
<span class="gd">-IndexToLines_T = Dict[Index, &#39;SuccessiveLinesLimits&#39;]</span>
<span class="gi">+# Links LinesChunk object to the starting indices (in lineset&#39;s stripped lines)</span>
<span class="gi">+# of the different chunk of lines that are used to compute the hash</span>
<span class="gi">+HashToIndex_T = Dict[&quot;LinesChunk&quot;, List[Index]]</span>
<span class="gi">+</span>
<span class="gi">+# Links index in the lineset&#39;s stripped lines to the real lines in the file</span>
<span class="gi">+IndexToLines_T = Dict[Index, &quot;SuccessiveLinesLimits&quot;]</span>
<span class="gi">+</span>
<span class="gi">+# The types the streams read by pylint can take. Originating from astroid.nodes.Module.stream() and open()</span>
<span class="w"> </span>STREAM_TYPES = Union[TextIO, BufferedReader, BytesIO]


<span class="gu">@@ -65,51 +97,62 @@ class CplSuccessiveLinesLimits:</span>
<span class="w"> </span>    &quot;&quot;&quot;Holds a SuccessiveLinesLimits object for each checked file and counts the number
<span class="w"> </span>    of common lines between both stripped lines collections extracted from both files.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;first_file&#39;, &#39;second_file&#39;, &#39;effective_cmn_lines_nb&#39;</span>

<span class="gd">-    def __init__(self, first_file: SuccessiveLinesLimits, second_file:</span>
<span class="gd">-        SuccessiveLinesLimits, effective_cmn_lines_nb: int) -&gt;None:</span>
<span class="gi">+    __slots__ = (&quot;first_file&quot;, &quot;second_file&quot;, &quot;effective_cmn_lines_nb&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        first_file: SuccessiveLinesLimits,</span>
<span class="gi">+        second_file: SuccessiveLinesLimits,</span>
<span class="gi">+        effective_cmn_lines_nb: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.first_file = first_file
<span class="w"> </span>        self.second_file = second_file
<span class="w"> </span>        self.effective_cmn_lines_nb = effective_cmn_lines_nb


<span class="gd">-CplIndexToCplLines_T = Dict[&#39;LineSetStartCouple&#39;, CplSuccessiveLinesLimits]</span>
<span class="gi">+# Links the indices to the starting line in both lineset&#39;s stripped lines to</span>
<span class="gi">+# the start and end lines in both files</span>
<span class="gi">+CplIndexToCplLines_T = Dict[&quot;LineSetStartCouple&quot;, CplSuccessiveLinesLimits]</span>


<span class="w"> </span>class LinesChunk:
<span class="w"> </span>    &quot;&quot;&quot;The LinesChunk object computes and stores the hash of some consecutive stripped
<span class="w"> </span>    lines of a lineset.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_fileid&#39;, &#39;_index&#39;, &#39;_hash&#39;</span>

<span class="gd">-    def __init__(self, fileid: str, num_line: int, *lines: Iterable[str]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    __slots__ = (&quot;_fileid&quot;, &quot;_index&quot;, &quot;_hash&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, fileid: str, num_line: int, *lines: Iterable[str]) -&gt; None:</span>
<span class="w"> </span>        self._fileid: str = fileid
<span class="w"> </span>        &quot;&quot;&quot;The name of the file from which the LinesChunk object is generated.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self._index: Index = Index(num_line)
<span class="w"> </span>        &quot;&quot;&quot;The index in the stripped lines that is the starting of consecutive
<span class="w"> </span>        lines.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self._hash: int = sum(hash(lin) for lin in lines)
<span class="w"> </span>        &quot;&quot;&quot;The hash of some consecutive lines.&quot;&quot;&quot;

<span class="gd">-    def __eq__(self, o: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, o: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(o, LinesChunk):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self._hash == o._hash

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return self._hash

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;&lt;LinesChunk object for file {self._fileid} ({self._index}, {self._hash})&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&quot;&lt;LinesChunk object for file {self._fileid} ({self._index}, {self._hash})&gt;&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return f&quot;&quot;&quot;LinesChunk object for file {self._fileid}, starting at line {self._index} </span>
<span class="gd">-Hash is {self._hash}&quot;&quot;&quot;</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return (</span>
<span class="gi">+            f&quot;LinesChunk object for file {self._fileid}, starting at line {self._index} \n&quot;</span>
<span class="gi">+            f&quot;Hash is {self._hash}&quot;</span>
<span class="gi">+        )</span>


<span class="w"> </span>class SuccessiveLinesLimits:
<span class="gu">@@ -117,41 +160,64 @@ class SuccessiveLinesLimits:</span>

<span class="w"> </span>    :note: Only the end line number can be updated.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __slots__ = &#39;_start&#39;, &#39;_end&#39;</span>

<span class="gd">-    def __init__(self, start: LineNumber, end: LineNumber) -&gt;None:</span>
<span class="gi">+    __slots__ = (&quot;_start&quot;, &quot;_end&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, start: LineNumber, end: LineNumber) -&gt; None:</span>
<span class="w"> </span>        self._start: LineNumber = start
<span class="w"> </span>        self._end: LineNumber = end

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;SuccessiveLinesLimits &lt;{self._start};{self._end}&gt;&gt;&#39;</span>
<span class="gi">+    @property</span>
<span class="gi">+    def start(self) -&gt; LineNumber:</span>
<span class="gi">+        return self._start</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def end(self) -&gt; LineNumber:</span>
<span class="gi">+        return self._end</span>
<span class="gi">+</span>
<span class="gi">+    @end.setter</span>
<span class="gi">+    def end(self, value: LineNumber) -&gt; None:</span>
<span class="gi">+        self._end = value</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;SuccessiveLinesLimits &lt;{self._start};{self._end}&gt;&gt;&quot;</span>


<span class="w"> </span>class LineSetStartCouple(NamedTuple):
<span class="w"> </span>    &quot;&quot;&quot;Indices in both linesets that mark the beginning of successive lines.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    fst_lineset_index: Index
<span class="w"> </span>    snd_lineset_index: Index

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;&lt;LineSetStartCouple &lt;{self.fst_lineset_index};{self.snd_lineset_index}&gt;&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            f&quot;&lt;LineSetStartCouple &lt;{self.fst_lineset_index};{self.snd_lineset_index}&gt;&gt;&quot;</span>
<span class="gi">+        )</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, LineSetStartCouple):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.fst_lineset_index == other.fst_lineset_index and self.</span>
<span class="gd">-            snd_lineset_index == other.snd_lineset_index)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.fst_lineset_index == other.fst_lineset_index</span>
<span class="gi">+            and self.snd_lineset_index == other.snd_lineset_index</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.fst_lineset_index) + hash(self.snd_lineset_index)

<span class="gi">+    def increment(self, value: Index) -&gt; LineSetStartCouple:</span>
<span class="gi">+        return LineSetStartCouple(</span>
<span class="gi">+            Index(self.fst_lineset_index + value),</span>
<span class="gi">+            Index(self.snd_lineset_index + value),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>

<span class="gd">-LinesChunkLimits_T = Tuple[&#39;LineSet&#39;, LineNumber, LineNumber]</span>
<span class="gi">+LinesChunkLimits_T = Tuple[&quot;LineSet&quot;, LineNumber, LineNumber]</span>


<span class="gd">-def hash_lineset(lineset: LineSet, min_common_lines: int=</span>
<span class="gd">-    DEFAULT_MIN_SIMILARITY_LINE) -&gt;tuple[HashToIndex_T, IndexToLines_T]:</span>
<span class="gi">+def hash_lineset(</span>
<span class="gi">+    lineset: LineSet, min_common_lines: int = DEFAULT_MIN_SIMILARITY_LINE</span>
<span class="gi">+) -&gt; tuple[HashToIndex_T, IndexToLines_T]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return two dicts.

<span class="w"> </span>    The first associates the hash of successive stripped lines of a lineset
<span class="gu">@@ -164,10 +230,33 @@ def hash_lineset(lineset: LineSet, min_common_lines: int=</span>
<span class="w"> </span>    :return: a dict linking hashes to corresponding start index and a dict that links this
<span class="w"> </span>             index to the start and end lines in the file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hash2index = defaultdict(list)</span>
<span class="gi">+    index2lines = {}</span>
<span class="gi">+    # Comments, docstring and other specific patterns maybe excluded -&gt; call to stripped_lines</span>
<span class="gi">+    # to get only what is desired</span>
<span class="gi">+    lines = tuple(x.text for x in lineset.stripped_lines)</span>
<span class="gi">+    # Need different iterators on same lines but each one is shifted 1 from the precedent</span>
<span class="gi">+    shifted_lines = [iter(lines[i:]) for i in range(min_common_lines)]</span>
<span class="gi">+</span>
<span class="gi">+    for i, *succ_lines in enumerate(zip(*shifted_lines)):</span>
<span class="gi">+        start_linenumber = LineNumber(lineset.stripped_lines[i].line_number)</span>
<span class="gi">+        try:</span>
<span class="gi">+            end_linenumber = lineset.stripped_lines[i + min_common_lines].line_number</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            end_linenumber = LineNumber(lineset.stripped_lines[-1].line_number + 1)</span>

<span class="gi">+        index = Index(i)</span>
<span class="gi">+        index2lines[index] = SuccessiveLinesLimits(</span>
<span class="gi">+            start=start_linenumber, end=end_linenumber</span>
<span class="gi">+        )</span>

<span class="gd">-def remove_successive(all_couples: CplIndexToCplLines_T) -&gt;None:</span>
<span class="gi">+        l_c = LinesChunk(lineset.name, index, *succ_lines)</span>
<span class="gi">+        hash2index[l_c].append(index)</span>
<span class="gi">+</span>
<span class="gi">+    return hash2index, index2lines</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def remove_successive(all_couples: CplIndexToCplLines_T) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Removes all successive entries in the dictionary in argument.

<span class="w"> </span>    :param all_couples: collection that has to be cleaned up from successive entries.
<span class="gu">@@ -192,11 +281,31 @@ def remove_successive(all_couples: CplIndexToCplLines_T) -&gt;None:</span>
<span class="w"> </span>    {(11, 34): ([5, 10], [27, 32]),
<span class="w"> </span>     (23, 79): ([15, 19], [45, 49])}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def filter_noncode_lines(ls_1: LineSet, stindex_1: Index, ls_2: LineSet,</span>
<span class="gd">-    stindex_2: Index, common_lines_nb: int) -&gt;int:</span>
<span class="gi">+    couple: LineSetStartCouple</span>
<span class="gi">+    for couple in tuple(all_couples.keys()):</span>
<span class="gi">+        to_remove = []</span>
<span class="gi">+        test = couple.increment(Index(1))</span>
<span class="gi">+        while test in all_couples:</span>
<span class="gi">+            all_couples[couple].first_file.end = all_couples[test].first_file.end</span>
<span class="gi">+            all_couples[couple].second_file.end = all_couples[test].second_file.end</span>
<span class="gi">+            all_couples[couple].effective_cmn_lines_nb += 1</span>
<span class="gi">+            to_remove.append(test)</span>
<span class="gi">+            test = test.increment(Index(1))</span>
<span class="gi">+</span>
<span class="gi">+        for target in to_remove:</span>
<span class="gi">+            try:</span>
<span class="gi">+                all_couples.pop(target)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def filter_noncode_lines(</span>
<span class="gi">+    ls_1: LineSet,</span>
<span class="gi">+    stindex_1: Index,</span>
<span class="gi">+    ls_2: LineSet,</span>
<span class="gi">+    stindex_2: Index,</span>
<span class="gi">+    common_lines_nb: int,</span>
<span class="gi">+) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the effective number of common lines between lineset1
<span class="w"> </span>    and lineset2 filtered from non code lines.

<span class="gu">@@ -211,7 +320,17 @@ def filter_noncode_lines(ls_1: LineSet, stindex_1: Index, ls_2: LineSet,</span>
<span class="w"> </span>    :param common_lines_nb: number of common successive stripped lines before being filtered from non code lines
<span class="w"> </span>    :return: the number of common successive stripped lines that contain code
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    stripped_l1 = [</span>
<span class="gi">+        lspecif.text</span>
<span class="gi">+        for lspecif in ls_1.stripped_lines[stindex_1 : stindex_1 + common_lines_nb]</span>
<span class="gi">+        if REGEX_FOR_LINES_WITH_CONTENT.match(lspecif.text)</span>
<span class="gi">+    ]</span>
<span class="gi">+    stripped_l2 = [</span>
<span class="gi">+        lspecif.text</span>
<span class="gi">+        for lspecif in ls_2.stripped_lines[stindex_2 : stindex_2 + common_lines_nb]</span>
<span class="gi">+        if REGEX_FOR_LINES_WITH_CONTENT.match(lspecif.text)</span>
<span class="gi">+    ]</span>
<span class="gi">+    return sum(sline_1 == sline_2 for sline_1, sline_2 in zip(stripped_l1, stripped_l2))</span>


<span class="w"> </span>class Commonality(NamedTuple):
<span class="gu">@@ -227,13 +346,20 @@ class Commonality(NamedTuple):</span>
<span class="w"> </span>class Similar:
<span class="w"> </span>    &quot;&quot;&quot;Finds copy-pasted lines of code in a project.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, min_lines: int=DEFAULT_MIN_SIMILARITY_LINE,</span>
<span class="gd">-        ignore_comments: bool=False, ignore_docstrings: bool=False,</span>
<span class="gd">-        ignore_imports: bool=False, ignore_signatures: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        min_lines: int = DEFAULT_MIN_SIMILARITY_LINE,</span>
<span class="gi">+        ignore_comments: bool = False,</span>
<span class="gi">+        ignore_docstrings: bool = False,</span>
<span class="gi">+        ignore_imports: bool = False,</span>
<span class="gi">+        ignore_signatures: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # If we run in pylint mode we link the namespace objects</span>
<span class="w"> </span>        if isinstance(self, BaseChecker):
<span class="w"> </span>            self.namespace = self.linter.config
<span class="w"> </span>        else:
<span class="w"> </span>            self.namespace = argparse.Namespace()
<span class="gi">+</span>
<span class="w"> </span>        self.namespace.min_similarity_lines = min_lines
<span class="w"> </span>        self.namespace.ignore_comments = ignore_comments
<span class="w"> </span>        self.namespace.ignore_docstrings = ignore_docstrings
<span class="gu">@@ -241,31 +367,119 @@ class Similar:</span>
<span class="w"> </span>        self.namespace.ignore_signatures = ignore_signatures
<span class="w"> </span>        self.linesets: list[LineSet] = []

<span class="gd">-    def append_stream(self, streamid: str, stream: STREAM_TYPES, encoding:</span>
<span class="gd">-        (str | None)=None) -&gt;None:</span>
<span class="gi">+    def append_stream(</span>
<span class="gi">+        self, streamid: str, stream: STREAM_TYPES, encoding: str | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Append a file to search for similarities.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(stream, BufferedIOBase):</span>
<span class="gi">+            if encoding is None:</span>
<span class="gi">+                raise ValueError</span>
<span class="gi">+            readlines = decoding_stream(stream, encoding).readlines</span>
<span class="gi">+        else:</span>
<span class="gi">+            # hint parameter is incorrectly typed as non-optional</span>
<span class="gi">+            readlines = stream.readlines  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            lines = readlines()</span>
<span class="gi">+        except UnicodeDecodeError:</span>
<span class="gi">+            lines = []</span>
<span class="gi">+</span>
<span class="gi">+        self.linesets.append(</span>
<span class="gi">+            LineSet(</span>
<span class="gi">+                streamid,</span>
<span class="gi">+                lines,</span>
<span class="gi">+                self.namespace.ignore_comments,</span>
<span class="gi">+                self.namespace.ignore_docstrings,</span>
<span class="gi">+                self.namespace.ignore_imports,</span>
<span class="gi">+                self.namespace.ignore_signatures,</span>
<span class="gi">+                line_enabled_callback=(</span>
<span class="gi">+                    self.linter._is_one_message_enabled</span>
<span class="gi">+                    if hasattr(self, &quot;linter&quot;)</span>
<span class="gi">+                    else None</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>

<span class="gd">-    def run(self) -&gt;None:</span>
<span class="gi">+    def run(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Start looking for similarities and display results on stdout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.namespace.min_similarity_lines == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._display_sims(self._compute_sims())</span>

<span class="gd">-    def _compute_sims(self) -&gt;list[tuple[int, set[LinesChunkLimits_T]]]:</span>
<span class="gi">+    def _compute_sims(self) -&gt; list[tuple[int, set[LinesChunkLimits_T]]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compute similarities in appended files.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _display_sims(self, similarities: list[tuple[int, set[</span>
<span class="gd">-        LinesChunkLimits_T]]]) -&gt;None:</span>
<span class="gi">+        no_duplicates: dict[int, list[set[LinesChunkLimits_T]]] = defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        for commonality in self._iter_sims():</span>
<span class="gi">+            num = commonality.cmn_lines_nb</span>
<span class="gi">+            lineset1 = commonality.fst_lset</span>
<span class="gi">+            start_line_1 = commonality.fst_file_start</span>
<span class="gi">+            end_line_1 = commonality.fst_file_end</span>
<span class="gi">+            lineset2 = commonality.snd_lset</span>
<span class="gi">+            start_line_2 = commonality.snd_file_start</span>
<span class="gi">+            end_line_2 = commonality.snd_file_end</span>
<span class="gi">+</span>
<span class="gi">+            duplicate = no_duplicates[num]</span>
<span class="gi">+            couples: set[LinesChunkLimits_T]</span>
<span class="gi">+            for couples in duplicate:</span>
<span class="gi">+                if (lineset1, start_line_1, end_line_1) in couples or (</span>
<span class="gi">+                    lineset2,</span>
<span class="gi">+                    start_line_2,</span>
<span class="gi">+                    end_line_2,</span>
<span class="gi">+                ) in couples:</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                duplicate.append(</span>
<span class="gi">+                    {</span>
<span class="gi">+                        (lineset1, start_line_1, end_line_1),</span>
<span class="gi">+                        (lineset2, start_line_2, end_line_2),</span>
<span class="gi">+                    }</span>
<span class="gi">+                )</span>
<span class="gi">+        sims: list[tuple[int, set[LinesChunkLimits_T]]] = []</span>
<span class="gi">+        ensembles: list[set[LinesChunkLimits_T]]</span>
<span class="gi">+        for num, ensembles in no_duplicates.items():</span>
<span class="gi">+            cpls: set[LinesChunkLimits_T]</span>
<span class="gi">+            for cpls in ensembles:</span>
<span class="gi">+                sims.append((num, cpls))</span>
<span class="gi">+        sims.sort()</span>
<span class="gi">+        sims.reverse()</span>
<span class="gi">+        return sims</span>
<span class="gi">+</span>
<span class="gi">+    def _display_sims(</span>
<span class="gi">+        self, similarities: list[tuple[int, set[LinesChunkLimits_T]]]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display computed similarities on stdout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        report = self._get_similarity_report(similarities)</span>
<span class="gi">+        print(report)</span>

<span class="gd">-    def _get_similarity_report(self, similarities: list[tuple[int, set[</span>
<span class="gd">-        LinesChunkLimits_T]]]) -&gt;str:</span>
<span class="gi">+    def _get_similarity_report(</span>
<span class="gi">+        self, similarities: list[tuple[int, set[LinesChunkLimits_T]]]</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a report from similarities.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _find_common(self, lineset1: LineSet, lineset2: LineSet) -&gt;Generator[</span>
<span class="gd">-        Commonality, None, None]:</span>
<span class="gi">+        report: str = &quot;&quot;</span>
<span class="gi">+        duplicated_line_number: int = 0</span>
<span class="gi">+        for number, couples in similarities:</span>
<span class="gi">+            report += f&quot;\n{number} similar lines in {len(couples)} files\n&quot;</span>
<span class="gi">+            couples_l = sorted(couples)</span>
<span class="gi">+            line_set = start_line = end_line = None</span>
<span class="gi">+            for line_set, start_line, end_line in couples_l:</span>
<span class="gi">+                report += f&quot;=={line_set.name}:[{start_line}:{end_line}]\n&quot;</span>
<span class="gi">+            if line_set:</span>
<span class="gi">+                for line in line_set._real_lines[start_line:end_line]:</span>
<span class="gi">+                    report += f&quot;   {line.rstrip()}\n&quot; if line.rstrip() else &quot;\n&quot;</span>
<span class="gi">+            duplicated_line_number += number * (len(couples_l) - 1)</span>
<span class="gi">+        total_line_number: int = sum(len(lineset) for lineset in self.linesets)</span>
<span class="gi">+        report += (</span>
<span class="gi">+            f&quot;TOTAL lines={total_line_number} &quot;</span>
<span class="gi">+            f&quot;duplicates={duplicated_line_number} &quot;</span>
<span class="gi">+            f&quot;percent={duplicated_line_number * 100.0 / total_line_number:.2f}\n&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        return report</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-locals</span>
<span class="gi">+    def _find_common(</span>
<span class="gi">+        self, lineset1: LineSet, lineset2: LineSet</span>
<span class="gi">+    ) -&gt; Generator[Commonality, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find similarities in the two given linesets.

<span class="w"> </span>        This the core of the algorithm. The idea is to compute the hashes of a
<span class="gu">@@ -278,35 +492,98 @@ class Similar:</span>
<span class="w"> </span>        account common chunk of lines that have more than the minimal number of
<span class="w"> </span>        successive lines required.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hash_to_index_1: HashToIndex_T</span>
<span class="gi">+        hash_to_index_2: HashToIndex_T</span>
<span class="gi">+        index_to_lines_1: IndexToLines_T</span>
<span class="gi">+        index_to_lines_2: IndexToLines_T</span>
<span class="gi">+        hash_to_index_1, index_to_lines_1 = hash_lineset(</span>
<span class="gi">+            lineset1, self.namespace.min_similarity_lines</span>
<span class="gi">+        )</span>
<span class="gi">+        hash_to_index_2, index_to_lines_2 = hash_lineset(</span>
<span class="gi">+            lineset2, self.namespace.min_similarity_lines</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        hash_1: frozenset[LinesChunk] = frozenset(hash_to_index_1.keys())</span>
<span class="gi">+        hash_2: frozenset[LinesChunk] = frozenset(hash_to_index_2.keys())</span>
<span class="gi">+</span>
<span class="gi">+        common_hashes: Iterable[LinesChunk] = sorted(</span>
<span class="gi">+            hash_1 &amp; hash_2, key=lambda m: hash_to_index_1[m][0]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # all_couples is a dict that links the couple of indices in both linesets that mark the beginning of</span>
<span class="gi">+        # successive common lines, to the corresponding starting and ending number lines in both files</span>
<span class="gi">+        all_couples: CplIndexToCplLines_T = {}</span>
<span class="gi">+</span>
<span class="gi">+        for c_hash in sorted(common_hashes, key=operator.attrgetter(&quot;_index&quot;)):</span>
<span class="gi">+            for indices_in_linesets in itertools.product(</span>
<span class="gi">+                hash_to_index_1[c_hash], hash_to_index_2[c_hash]</span>
<span class="gi">+            ):</span>
<span class="gi">+                index_1 = indices_in_linesets[0]</span>
<span class="gi">+                index_2 = indices_in_linesets[1]</span>
<span class="gi">+                all_couples[LineSetStartCouple(index_1, index_2)] = (</span>
<span class="gi">+                    CplSuccessiveLinesLimits(</span>
<span class="gi">+                        copy.copy(index_to_lines_1[index_1]),</span>
<span class="gi">+                        copy.copy(index_to_lines_2[index_2]),</span>
<span class="gi">+                        effective_cmn_lines_nb=self.namespace.min_similarity_lines,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        remove_successive(all_couples)</span>
<span class="gi">+</span>
<span class="gi">+        for cml_stripped_l, cmn_l in all_couples.items():</span>
<span class="gi">+            start_index_1 = cml_stripped_l.fst_lineset_index</span>
<span class="gi">+            start_index_2 = cml_stripped_l.snd_lineset_index</span>
<span class="gi">+            nb_common_lines = cmn_l.effective_cmn_lines_nb</span>
<span class="gi">+</span>
<span class="gi">+            com = Commonality(</span>
<span class="gi">+                cmn_lines_nb=nb_common_lines,</span>
<span class="gi">+                fst_lset=lineset1,</span>
<span class="gi">+                fst_file_start=cmn_l.first_file.start,</span>
<span class="gi">+                fst_file_end=cmn_l.first_file.end,</span>
<span class="gi">+                snd_lset=lineset2,</span>
<span class="gi">+                snd_file_start=cmn_l.second_file.start,</span>
<span class="gi">+                snd_file_end=cmn_l.second_file.end,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            eff_cmn_nb = filter_noncode_lines(</span>
<span class="gi">+                lineset1, start_index_1, lineset2, start_index_2, nb_common_lines</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            if eff_cmn_nb &gt; self.namespace.min_similarity_lines:</span>
<span class="gi">+                yield com</span>

<span class="gd">-    def _iter_sims(self) -&gt;Generator[Commonality, None, None]:</span>
<span class="gi">+    def _iter_sims(self) -&gt; Generator[Commonality, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterate on similarities among all files, by making a Cartesian
<span class="w"> </span>        product.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for idx, lineset in enumerate(self.linesets[:-1]):</span>
<span class="gi">+            for lineset2 in self.linesets[idx + 1 :]:</span>
<span class="gi">+                yield from self._find_common(lineset, lineset2)</span>

<span class="gd">-    def get_map_data(self) -&gt;list[LineSet]:</span>
<span class="gi">+    def get_map_data(self) -&gt; list[LineSet]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the data we can use for a map/reduce process.

<span class="w"> </span>        In this case we are returning this instance&#39;s Linesets, that is all file
<span class="w"> </span>        information that will later be used for vectorisation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.linesets</span>

<span class="gd">-    def combine_mapreduce_data(self, linesets_collection: list[list[LineSet]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def combine_mapreduce_data(self, linesets_collection: list[list[LineSet]]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reduces and recombines data into a format that we can report on.

<span class="w"> </span>        The partner function of get_map_data()
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.linesets = [line for lineset in linesets_collection for line in lineset]</span>


<span class="gd">-def stripped_lines(lines: Iterable[str], ignore_comments: bool,</span>
<span class="gd">-    ignore_docstrings: bool, ignore_imports: bool, ignore_signatures: bool,</span>
<span class="gd">-    line_enabled_callback: (Callable[[str, int], bool] | None)=None) -&gt;list[</span>
<span class="gd">-    LineSpecifs]:</span>
<span class="gi">+def stripped_lines(</span>
<span class="gi">+    lines: Iterable[str],</span>
<span class="gi">+    ignore_comments: bool,</span>
<span class="gi">+    ignore_docstrings: bool,</span>
<span class="gi">+    ignore_imports: bool,</span>
<span class="gi">+    ignore_signatures: bool,</span>
<span class="gi">+    line_enabled_callback: Callable[[str, int], bool] | None = None,</span>
<span class="gi">+) -&gt; list[LineSpecifs]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return tuples of line/line number/line type with leading/trailing white-space and
<span class="w"> </span>    any ignored code features removed.

<span class="gu">@@ -319,7 +596,79 @@ def stripped_lines(lines: Iterable[str], ignore_comments: bool,</span>
<span class="w"> </span>           the line
<span class="w"> </span>    :return: the collection of line/line number/line type tuples
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if ignore_imports or ignore_signatures:</span>
<span class="gi">+        tree = astroid.parse(&quot;&quot;.join(lines))</span>
<span class="gi">+    if ignore_imports:</span>
<span class="gi">+        import_lines = {}</span>
<span class="gi">+        for node in tree.nodes_of_class((nodes.Import, nodes.ImportFrom)):</span>
<span class="gi">+            for lineno in range(node.lineno, (node.end_lineno or node.lineno) + 1):</span>
<span class="gi">+                import_lines[lineno] = True</span>
<span class="gi">+    if ignore_signatures:</span>
<span class="gi">+</span>
<span class="gi">+        def _get_functions(</span>
<span class="gi">+            functions: list[nodes.NodeNG], tree: nodes.NodeNG</span>
<span class="gi">+        ) -&gt; list[nodes.NodeNG]:</span>
<span class="gi">+            &quot;&quot;&quot;Recursively get all functions including nested in the classes from the</span>
<span class="gi">+            tree.</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            for node in tree.body:</span>
<span class="gi">+                if isinstance(node, (nodes.FunctionDef, nodes.AsyncFunctionDef)):</span>
<span class="gi">+                    functions.append(node)</span>
<span class="gi">+</span>
<span class="gi">+                if isinstance(</span>
<span class="gi">+                    node,</span>
<span class="gi">+                    (nodes.ClassDef, nodes.FunctionDef, nodes.AsyncFunctionDef),</span>
<span class="gi">+                ):</span>
<span class="gi">+                    _get_functions(functions, node)</span>
<span class="gi">+</span>
<span class="gi">+            return functions</span>
<span class="gi">+</span>
<span class="gi">+        functions = _get_functions([], tree)</span>
<span class="gi">+        signature_lines = set(</span>
<span class="gi">+            chain(</span>
<span class="gi">+                *(</span>
<span class="gi">+                    range(</span>
<span class="gi">+                        func.lineno,</span>
<span class="gi">+                        func.body[0].lineno if func.body else func.tolineno + 1,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    for func in functions</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    strippedlines = []</span>
<span class="gi">+    docstring = None</span>
<span class="gi">+    for lineno, line in enumerate(lines, start=1):</span>
<span class="gi">+        if line_enabled_callback is not None and not line_enabled_callback(</span>
<span class="gi">+            &quot;R0801&quot;, lineno</span>
<span class="gi">+        ):</span>
<span class="gi">+            continue</span>
<span class="gi">+        line = line.strip()</span>
<span class="gi">+        if ignore_docstrings:</span>
<span class="gi">+            if not docstring:</span>
<span class="gi">+                if line.startswith((&#39;&quot;&quot;&quot;&#39;, &quot;&#39;&#39;&#39;&quot;)):</span>
<span class="gi">+                    docstring = line[:3]</span>
<span class="gi">+                    line = line[3:]</span>
<span class="gi">+                elif line.startswith((&#39;r&quot;&quot;&quot;&#39;, &quot;r&#39;&#39;&#39;&quot;)):</span>
<span class="gi">+                    docstring = line[1:4]</span>
<span class="gi">+                    line = line[4:]</span>
<span class="gi">+            if docstring:</span>
<span class="gi">+                if line.endswith(docstring):</span>
<span class="gi">+                    docstring = None</span>
<span class="gi">+                line = &quot;&quot;</span>
<span class="gi">+        if ignore_imports:</span>
<span class="gi">+            current_line_is_import = import_lines.get(lineno, False)</span>
<span class="gi">+            if current_line_is_import:</span>
<span class="gi">+                line = &quot;&quot;</span>
<span class="gi">+        if ignore_comments:</span>
<span class="gi">+            line = line.split(&quot;#&quot;, 1)[0].strip()</span>
<span class="gi">+        if ignore_signatures and lineno in signature_lines:</span>
<span class="gi">+            line = &quot;&quot;</span>
<span class="gi">+        if line:</span>
<span class="gi">+            strippedlines.append(</span>
<span class="gi">+                LineSpecifs(text=line, line_number=LineNumber(lineno - 1))</span>
<span class="gi">+            )</span>
<span class="gi">+    return strippedlines</span>


<span class="w"> </span>@functools.total_ordering
<span class="gu">@@ -330,125 +679,281 @@ class LineSet:</span>
<span class="w"> </span>    are the real ones from which undesired patterns have been removed.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str, lines: list[str], ignore_comments: bool=</span>
<span class="gd">-        False, ignore_docstrings: bool=False, ignore_imports: bool=False,</span>
<span class="gd">-        ignore_signatures: bool=False, line_enabled_callback: (Callable[[</span>
<span class="gd">-        str, int], bool] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        lines: list[str],</span>
<span class="gi">+        ignore_comments: bool = False,</span>
<span class="gi">+        ignore_docstrings: bool = False,</span>
<span class="gi">+        ignore_imports: bool = False,</span>
<span class="gi">+        ignore_signatures: bool = False,</span>
<span class="gi">+        line_enabled_callback: Callable[[str, int], bool] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self._real_lines = lines
<span class="gd">-        self._stripped_lines = stripped_lines(lines, ignore_comments,</span>
<span class="gd">-            ignore_docstrings, ignore_imports, ignore_signatures,</span>
<span class="gd">-            line_enabled_callback=line_enabled_callback)</span>
<span class="gd">-</span>
<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;&lt;Lineset for {self.name}&gt;&#39;</span>
<span class="gd">-</span>
<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+        self._stripped_lines = stripped_lines(</span>
<span class="gi">+            lines,</span>
<span class="gi">+            ignore_comments,</span>
<span class="gi">+            ignore_docstrings,</span>
<span class="gi">+            ignore_imports,</span>
<span class="gi">+            ignore_signatures,</span>
<span class="gi">+            line_enabled_callback=line_enabled_callback,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;Lineset for {self.name}&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self._real_lines)

<span class="gd">-    def __getitem__(self, index: int) -&gt;LineSpecifs:</span>
<span class="gi">+    def __getitem__(self, index: int) -&gt; LineSpecifs:</span>
<span class="w"> </span>        return self._stripped_lines[index]

<span class="gd">-    def __lt__(self, other: LineSet) -&gt;bool:</span>
<span class="gi">+    def __lt__(self, other: LineSet) -&gt; bool:</span>
<span class="w"> </span>        return self.name &lt; other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return id(self)

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, LineSet):
<span class="w"> </span>            return False
<span class="w"> </span>        return self.__dict__ == other.__dict__

<span class="gi">+    @property</span>
<span class="gi">+    def stripped_lines(self) -&gt; list[LineSpecifs]:</span>
<span class="gi">+        return self._stripped_lines</span>

<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;R0801&#39;: (</span>
<span class="gd">-    &quot;&quot;&quot;Similar lines in %s files</span>
<span class="gd">-%s&quot;&quot;&quot;, &#39;duplicate-code&#39;,</span>
<span class="gd">-    &#39;Indicates that a set of similar lines has been detected among multiple file. This usually means that the code should be refactored to avoid this duplication.&#39;</span>
<span class="gd">-    )}</span>
<span class="gi">+    @property</span>
<span class="gi">+    def real_lines(self) -&gt; list[str]:</span>
<span class="gi">+        return self._real_lines</span>


<span class="gd">-def report_similarities(sect: Section, stats: LinterStats, old_stats: (</span>
<span class="gd">-    LinterStats | None)) -&gt;None:</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+    &quot;R0801&quot;: (</span>
<span class="gi">+        &quot;Similar lines in %s files\n%s&quot;,</span>
<span class="gi">+        &quot;duplicate-code&quot;,</span>
<span class="gi">+        &quot;Indicates that a set of similar lines has been detected &quot;</span>
<span class="gi">+        &quot;among multiple file. This usually means that the code should &quot;</span>
<span class="gi">+        &quot;be refactored to avoid this duplication.&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def report_similarities(</span>
<span class="gi">+    sect: Section,</span>
<span class="gi">+    stats: LinterStats,</span>
<span class="gi">+    old_stats: LinterStats | None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make a layout with some stats about duplication.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = [&quot;&quot;, &quot;now&quot;, &quot;previous&quot;, &quot;difference&quot;]</span>
<span class="gi">+    lines += table_lines_from_stats(stats, old_stats, &quot;duplicated_lines&quot;)</span>
<span class="gi">+    sect.append(Table(children=lines, cols=4, rheaders=1, cheaders=1))</span>


<span class="gi">+# wrapper to get a pylint checker from the similar class</span>
<span class="w"> </span>class SimilarChecker(BaseRawFileChecker, Similar):
<span class="w"> </span>    &quot;&quot;&quot;Checks for similarities and duplicated code.

<span class="w"> </span>    This computation may be memory / CPU intensive, so you
<span class="w"> </span>    should disable it if you experience some problems.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;similarities&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;similarities&quot;</span>
<span class="gi">+    # messages</span>
<span class="w"> </span>    msgs = MSGS
<span class="gd">-    options: Options = ((&#39;min-similarity-lines&#39;, {&#39;default&#39;:</span>
<span class="gd">-        DEFAULT_MIN_SIMILARITY_LINE, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;: &#39;&lt;int&gt;&#39;,</span>
<span class="gd">-        &#39;help&#39;: &#39;Minimum lines number of a similarity.&#39;}), (</span>
<span class="gd">-        &#39;ignore-comments&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Comments are removed from the similarity computation&#39;}), (</span>
<span class="gd">-        &#39;ignore-docstrings&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Docstrings are removed from the similarity computation&#39;}), (</span>
<span class="gd">-        &#39;ignore-imports&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Imports are removed from the similarity computation&#39;}), (</span>
<span class="gd">-        &#39;ignore-signatures&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Signatures are removed from the similarity computation&#39;}))</span>
<span class="gd">-    reports = (&#39;RP0801&#39;, &#39;Duplication&#39;, report_similarities),</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    # configuration options</span>
<span class="gi">+    # for available dict keys/values see the optik parser &#39;add_option&#39; method</span>
<span class="gi">+    options: Options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;min-similarity-lines&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: DEFAULT_MIN_SIMILARITY_LINE,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Minimum lines number of a similarity.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-comments&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Comments are removed from the similarity computation&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-docstrings&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Docstrings are removed from the similarity computation&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-imports&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Imports are removed from the similarity computation&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-signatures&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Signatures are removed from the similarity computation&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    # reports</span>
<span class="gi">+    reports = ((&quot;RP0801&quot;, &quot;Duplication&quot;, report_similarities),)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        BaseRawFileChecker.__init__(self, linter)
<span class="gd">-        Similar.__init__(self, min_lines=self.linter.config.</span>
<span class="gd">-            min_similarity_lines, ignore_comments=self.linter.config.</span>
<span class="gd">-            ignore_comments, ignore_docstrings=self.linter.config.</span>
<span class="gd">-            ignore_docstrings, ignore_imports=self.linter.config.</span>
<span class="gd">-            ignore_imports, ignore_signatures=self.linter.config.</span>
<span class="gd">-            ignore_signatures)</span>
<span class="gd">-</span>
<span class="gd">-    def open(self) -&gt;None:</span>
<span class="gi">+        Similar.__init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            min_lines=self.linter.config.min_similarity_lines,</span>
<span class="gi">+            ignore_comments=self.linter.config.ignore_comments,</span>
<span class="gi">+            ignore_docstrings=self.linter.config.ignore_docstrings,</span>
<span class="gi">+            ignore_imports=self.linter.config.ignore_imports,</span>
<span class="gi">+            ignore_signatures=self.linter.config.ignore_signatures,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Init the checkers: reset linesets and statistics information.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.linesets = []</span>
<span class="gi">+        self.linter.stats.reset_duplicated_lines()</span>

<span class="gd">-    def process_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+    def process_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process a module.

<span class="w"> </span>        the module&#39;s content is accessible via the stream object

<span class="w"> </span>        stream must implement the readlines method
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.linter.current_name is None:</span>
<span class="gi">+            # TODO: 4.0 Fix current_name</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                (</span>
<span class="gi">+                    &quot;In pylint 3.0 the current_name attribute of the linter object should be a string. &quot;</span>
<span class="gi">+                    &quot;If unknown it should be initialized as an empty string.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="gi">+        with node.stream() as stream:</span>
<span class="gi">+            self.append_stream(self.linter.current_name, stream, node.file_encoding)</span>

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compute and display similarities on closing (i.e. end of parsing).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_map_data(self) -&gt;list[LineSet]:</span>
<span class="gi">+        total = sum(len(lineset) for lineset in self.linesets)</span>
<span class="gi">+        duplicated = 0</span>
<span class="gi">+        stats = self.linter.stats</span>
<span class="gi">+        for num, couples in self._compute_sims():</span>
<span class="gi">+            msg = []</span>
<span class="gi">+            lineset = start_line = end_line = None</span>
<span class="gi">+            for lineset, start_line, end_line in couples:</span>
<span class="gi">+                msg.append(f&quot;=={lineset.name}:[{start_line}:{end_line}]&quot;)</span>
<span class="gi">+            msg.sort()</span>
<span class="gi">+</span>
<span class="gi">+            if lineset:</span>
<span class="gi">+                for line in lineset.real_lines[start_line:end_line]:</span>
<span class="gi">+                    msg.append(line.rstrip())</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(&quot;R0801&quot;, args=(len(couples), &quot;\n&quot;.join(msg)))</span>
<span class="gi">+            duplicated += num * (len(couples) - 1)</span>
<span class="gi">+        stats.nb_duplicated_lines += int(duplicated)</span>
<span class="gi">+        stats.percent_duplicated_lines += float(total and duplicated * 100.0 / total)</span>
<span class="gi">+</span>
<span class="gi">+    def get_map_data(self) -&gt; list[LineSet]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Passthru override.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return Similar.get_map_data(self)</span>

<span class="gd">-    def reduce_map_data(self, linter: PyLinter, data: list[list[LineSet]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def reduce_map_data(self, linter: PyLinter, data: list[list[LineSet]]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reduces and recombines data into a format that we can report on.

<span class="w"> </span>        The partner function of get_map_data()

<span class="w"> </span>        Calls self.close() to actually calculate and report duplicate code.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        Similar.combine_mapreduce_data(self, linesets_collection=data)</span>
<span class="gi">+        self.close()</span>


<span class="gd">-def usage(status: int=0) -&gt;NoReturn:</span>
<span class="gd">-    &quot;&quot;&quot;Display command line usage information.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(SimilarChecker(linter))</span>


<span class="gd">-def Run(argv: (Sequence[str] | None)=None) -&gt;NoReturn:</span>
<span class="gd">-    &quot;&quot;&quot;Standalone command line access point.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def usage(status: int = 0) -&gt; NoReturn:</span>
<span class="gi">+    &quot;&quot;&quot;Display command line usage information.&quot;&quot;&quot;</span>
<span class="gi">+    print(&quot;finds copy pasted blocks in a set of files&quot;)</span>
<span class="gi">+    print()</span>
<span class="gi">+    print(</span>
<span class="gi">+        &quot;Usage: symilar [-d|--duplicates min_duplicated_lines] \</span>
<span class="gi">+[-i|--ignore-comments] [--ignore-docstrings] [--ignore-imports] [--ignore-signatures] file1...&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    sys.exit(status)</span>


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+def Run(argv: Sequence[str] | None = None) -&gt; NoReturn:</span>
<span class="gi">+    &quot;&quot;&quot;Standalone command line access point.&quot;&quot;&quot;</span>
<span class="gi">+    if argv is None:</span>
<span class="gi">+        argv = sys.argv[1:]</span>
<span class="gi">+</span>
<span class="gi">+    s_opts = &quot;hd:i:&quot;</span>
<span class="gi">+    l_opts = [</span>
<span class="gi">+        &quot;help&quot;,</span>
<span class="gi">+        &quot;duplicates=&quot;,</span>
<span class="gi">+        &quot;ignore-comments&quot;,</span>
<span class="gi">+        &quot;ignore-imports&quot;,</span>
<span class="gi">+        &quot;ignore-docstrings&quot;,</span>
<span class="gi">+        &quot;ignore-signatures&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    min_lines = DEFAULT_MIN_SIMILARITY_LINE</span>
<span class="gi">+    ignore_comments = False</span>
<span class="gi">+    ignore_docstrings = False</span>
<span class="gi">+    ignore_imports = False</span>
<span class="gi">+    ignore_signatures = False</span>
<span class="gi">+    try:</span>
<span class="gi">+        opts, args = getopt(list(argv), s_opts, l_opts)</span>
<span class="gi">+    except GetoptError as e:</span>
<span class="gi">+        print(e)</span>
<span class="gi">+        usage(2)</span>
<span class="gi">+    for opt, val in opts:</span>
<span class="gi">+        if opt in {&quot;-d&quot;, &quot;--duplicates&quot;}:</span>
<span class="gi">+            try:</span>
<span class="gi">+                min_lines = int(val)</span>
<span class="gi">+            except ValueError as e:</span>
<span class="gi">+                print(e)</span>
<span class="gi">+                usage(2)</span>
<span class="gi">+        elif opt in {&quot;-h&quot;, &quot;--help&quot;}:</span>
<span class="gi">+            usage()</span>
<span class="gi">+        elif opt in {&quot;-i&quot;, &quot;--ignore-comments&quot;}:</span>
<span class="gi">+            ignore_comments = True</span>
<span class="gi">+        elif opt in {&quot;--ignore-docstrings&quot;}:</span>
<span class="gi">+            ignore_docstrings = True</span>
<span class="gi">+        elif opt in {&quot;--ignore-imports&quot;}:</span>
<span class="gi">+            ignore_imports = True</span>
<span class="gi">+        elif opt in {&quot;--ignore-signatures&quot;}:</span>
<span class="gi">+            ignore_signatures = True</span>
<span class="gi">+    if not args:</span>
<span class="gi">+        usage(1)</span>
<span class="gi">+    sim = Similar(</span>
<span class="gi">+        min_lines, ignore_comments, ignore_docstrings, ignore_imports, ignore_signatures</span>
<span class="gi">+    )</span>
<span class="gi">+    for filename in args:</span>
<span class="gi">+        with open(filename, encoding=&quot;utf-8&quot;) as stream:</span>
<span class="gi">+            sim.append_stream(filename, stream)</span>
<span class="gi">+    sim.run()</span>
<span class="gi">+    sys.exit(0)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    Run()
<span class="gh">diff --git a/pylint/checkers/spelling.py b/pylint/checkers/spelling.py</span>
<span class="gh">index 110818045..27d1c7ce0 100644</span>
<span class="gd">--- a/pylint/checkers/spelling.py</span>
<span class="gi">+++ b/pylint/checkers/spelling.py</span>
<span class="gu">@@ -1,146 +1,474 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checker for spelling errors in comments and docstrings.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import tokenize
<span class="w"> </span>from re import Pattern
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Literal
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseTokenChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import enchant
<span class="gd">-    from enchant.tokenize import Chunker, EmailFilter, Filter, URLFilter, WikiWordFilter, get_tokenizer</span>
<span class="gi">+    from enchant.tokenize import (</span>
<span class="gi">+        Chunker,</span>
<span class="gi">+        EmailFilter,</span>
<span class="gi">+        Filter,</span>
<span class="gi">+        URLFilter,</span>
<span class="gi">+        WikiWordFilter,</span>
<span class="gi">+        get_tokenizer,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    PYENCHANT_AVAILABLE = True
<span class="gd">-except ImportError:</span>
<span class="gi">+except ImportError:  # pragma: no cover</span>
<span class="w"> </span>    enchant = None
<span class="w"> </span>    PYENCHANT_AVAILABLE = False

<span class="gd">-</span>
<span class="gd">-    class EmailFilter:</span>
<span class="gi">+    class EmailFilter:  # type: ignore[no-redef]</span>
<span class="w"> </span>        ...

<span class="gd">-</span>
<span class="gd">-    class URLFilter:</span>
<span class="gi">+    class URLFilter:  # type: ignore[no-redef]</span>
<span class="w"> </span>        ...

<span class="gd">-</span>
<span class="gd">-    class WikiWordFilter:</span>
<span class="gi">+    class WikiWordFilter:  # type: ignore[no-redef]</span>
<span class="w"> </span>        ...

<span class="gi">+    class Filter:  # type: ignore[no-redef]</span>
<span class="gi">+        def _skip(self, word: str) -&gt; bool:</span>
<span class="gi">+            raise NotImplementedError</span>

<span class="gd">-    class Filter:</span>
<span class="gi">+    class Chunker:  # type: ignore[no-redef]</span>
<span class="w"> </span>        pass

<span class="gi">+    def get_tokenizer(</span>
<span class="gi">+        tag: str | None = None,  # pylint: disable=unused-argument</span>
<span class="gi">+        chunkers: list[Chunker] | None = None,  # pylint: disable=unused-argument</span>
<span class="gi">+        filters: list[Filter] | None = None,  # pylint: disable=unused-argument</span>
<span class="gi">+    ) -&gt; Filter:</span>
<span class="gi">+        return Filter()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_enchant_dicts() -&gt; list[tuple[Any, enchant.ProviderDesc]]:</span>
<span class="gi">+    # Broker().list_dicts() is not typed in enchant, but it does return tuples</span>
<span class="gi">+    return enchant.Broker().list_dicts() if PYENCHANT_AVAILABLE else []  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_enchant_dict_choices(</span>
<span class="gi">+    inner_enchant_dicts: list[tuple[Any, enchant.ProviderDesc]]</span>
<span class="gi">+) -&gt; list[str]:</span>
<span class="gi">+    return [&quot;&quot;] + [d[0] for d in inner_enchant_dicts]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_enchant_dict_help(</span>
<span class="gi">+    inner_enchant_dicts: list[tuple[Any, enchant.ProviderDesc]],</span>
<span class="gi">+    pyenchant_available: bool,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    if inner_enchant_dicts:</span>
<span class="gi">+        dict_as_str = [f&quot;{d[0]} ({d[1].name})&quot; for d in inner_enchant_dicts]</span>
<span class="gi">+        enchant_help = f&quot;Available dictionaries: {&#39;, &#39;.join(dict_as_str)}&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        enchant_help = &quot;No available dictionaries : You need to install &quot;</span>
<span class="gi">+        if not pyenchant_available:</span>
<span class="gi">+            enchant_help += &quot;both the python package and &quot;</span>
<span class="gi">+        enchant_help += &quot;the system dependency for enchant to work&quot;</span>
<span class="gi">+    return f&quot;Spelling dictionary name. {enchant_help}.&quot;</span>
<span class="gi">+</span>

<span class="gd">-    class Chunker:</span>
<span class="gd">-        pass</span>
<span class="w"> </span>enchant_dicts = _get_enchant_dicts()


<span class="gd">-class WordsWithDigitsFilter(Filter):</span>
<span class="gi">+class WordsWithDigitsFilter(Filter):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;Skips words with digits.&quot;&quot;&quot;

<span class="gi">+    def _skip(self, word: str) -&gt; bool:</span>
<span class="gi">+        return any(char.isdigit() for char in word)</span>
<span class="gi">+</span>

<span class="gd">-class WordsWithUnderscores(Filter):</span>
<span class="gi">+class WordsWithUnderscores(Filter):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;Skips words with underscores.

<span class="w"> </span>    They are probably function parameter names.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def _skip(self, word: str) -&gt; bool:</span>
<span class="gi">+        return &quot;_&quot; in word</span>

<span class="gd">-class RegExFilter(Filter):</span>
<span class="gi">+</span>
<span class="gi">+class RegExFilter(Filter):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;Parent class for filters using regular expressions.

<span class="w"> </span>    This filter skips any words the match the expression
<span class="w"> </span>    assigned to the class attribute ``_pattern``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _pattern: Pattern[str]

<span class="gi">+    def _skip(self, word: str) -&gt; bool:</span>
<span class="gi">+        return bool(self._pattern.match(word))</span>
<span class="gi">+</span>

<span class="w"> </span>class CamelCasedWord(RegExFilter):
<span class="gd">-    &quot;&quot;&quot;Filter skipping over camelCasedWords.</span>
<span class="gi">+    r&quot;&quot;&quot;Filter skipping over camelCasedWords.</span>
<span class="w"> </span>    This filter skips any words matching the following regular expression:

<span class="gd">-           ^([a-z]\\w+[A-Z]+\\w+)</span>
<span class="gi">+           ^([a-z]\w+[A-Z]+\w+)</span>

<span class="w"> </span>    That is, any words that are camelCasedWords.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _pattern = re.compile(&#39;^([a-z]+(\\d|[A-Z])(?:\\w+)?)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    _pattern = re.compile(r&quot;^([a-z]+(\d|[A-Z])(?:\w+)?)&quot;)</span>


<span class="w"> </span>class SphinxDirectives(RegExFilter):
<span class="gd">-    &quot;&quot;&quot;Filter skipping over Sphinx Directives.</span>
<span class="gi">+    r&quot;&quot;&quot;Filter skipping over Sphinx Directives.</span>
<span class="w"> </span>    This filter skips any words matching the following regular expression:

<span class="w"> </span>           ^(:([a-z]+)){1,2}:`([^`]+)(`)?

<span class="w"> </span>    That is, for example, :class:`BaseQuery`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _pattern = re.compile(&#39;^(:([a-z]+)){1,2}:`([^`]+)(`)?&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # The final ` in the pattern is optional because enchant strips it out</span>
<span class="gi">+    _pattern = re.compile(r&quot;^(:([a-z]+)){1,2}:`([^`]+)(`)?&quot;)</span>


<span class="gd">-class ForwardSlashChunker(Chunker):</span>
<span class="gi">+class ForwardSlashChunker(Chunker):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;This chunker allows splitting words like &#39;before/after&#39; into &#39;before&#39; and
<span class="w"> </span>    &#39;after&#39;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _text: str</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-CODE_FLANKED_IN_BACKTICK_REGEX = re.compile(</span>
<span class="gd">-    &#39;(\\s|^)(`{1,2})([^`]+)(\\2)([^`]|$)&#39;)</span>

<span class="gi">+    _text: str</span>

<span class="gd">-def _strip_code_flanked_in_backticks(line: str) -&gt;str:</span>
<span class="gi">+    def next(self) -&gt; tuple[str, int]:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if not self._text:</span>
<span class="gi">+                raise StopIteration()</span>
<span class="gi">+            if &quot;/&quot; not in self._text:</span>
<span class="gi">+                text = self._text</span>
<span class="gi">+                self._offset = 0</span>
<span class="gi">+                self._text = &quot;&quot;</span>
<span class="gi">+                return text, 0</span>
<span class="gi">+            pre_text, post_text = self._text.split(&quot;/&quot;, 1)</span>
<span class="gi">+            self._text = post_text</span>
<span class="gi">+            self._offset = 0</span>
<span class="gi">+            if (</span>
<span class="gi">+                not pre_text</span>
<span class="gi">+                or not post_text</span>
<span class="gi">+                or not pre_text[-1].isalpha()</span>
<span class="gi">+                or not post_text[0].isalpha()</span>
<span class="gi">+            ):</span>
<span class="gi">+                self._text = &quot;&quot;</span>
<span class="gi">+                self._offset = 0</span>
<span class="gi">+                return f&quot;{pre_text}/{post_text}&quot;, 0</span>
<span class="gi">+            return pre_text, 0</span>
<span class="gi">+</span>
<span class="gi">+    def _next(self) -&gt; tuple[str, Literal[0]]:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if &quot;/&quot; not in self._text:</span>
<span class="gi">+                return self._text, 0</span>
<span class="gi">+            pre_text, post_text = self._text.split(&quot;/&quot;, 1)</span>
<span class="gi">+            if not pre_text or not post_text:</span>
<span class="gi">+                break</span>
<span class="gi">+            if not pre_text[-1].isalpha() or not post_text[0].isalpha():</span>
<span class="gi">+                raise StopIteration()</span>
<span class="gi">+            self._text = pre_text + &quot; &quot; + post_text</span>
<span class="gi">+        raise StopIteration()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+CODE_FLANKED_IN_BACKTICK_REGEX = re.compile(r&quot;(\s|^)(`{1,2})([^`]+)(\2)([^`]|$)&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _strip_code_flanked_in_backticks(line: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Alter line so code flanked in back-ticks is ignored.

<span class="w"> </span>    Pyenchant automatically strips back-ticks when parsing tokens,
<span class="w"> </span>    so this cannot be done at the individual filter level.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def replace_code_but_leave_surrounding_characters(match_obj: re.Match[str]) -&gt; str:</span>
<span class="gi">+        return match_obj.group(1) + match_obj.group(5)</span>
<span class="gi">+</span>
<span class="gi">+    return CODE_FLANKED_IN_BACKTICK_REGEX.sub(</span>
<span class="gi">+        replace_code_but_leave_surrounding_characters, line</span>
<span class="gi">+    )</span>


<span class="w"> </span>class SpellingChecker(BaseTokenChecker):
<span class="w"> </span>    &quot;&quot;&quot;Check spelling in comments and docstrings.&quot;&quot;&quot;
<span class="gd">-    name = &#39;spelling&#39;</span>
<span class="gd">-    msgs = {&#39;C0401&#39;: (</span>
<span class="gd">-        &quot;Wrong spelling of a word &#39;%s&#39; in a comment:\n%s\n%s\nDid you mean: &#39;%s&#39;?&quot;</span>
<span class="gd">-        , &#39;wrong-spelling-in-comment&#39;,</span>
<span class="gd">-        &#39;Used when a word in comment is not spelled correctly.&#39;), &#39;C0402&#39;:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;spelling&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C0401&quot;: (</span>
<span class="gi">+            &quot;Wrong spelling of a word &#39;%s&#39; in a comment:\n%s\n&quot;</span>
<span class="gi">+            &quot;%s\nDid you mean: &#39;%s&#39;?&quot;,</span>
<span class="gi">+            &quot;wrong-spelling-in-comment&quot;,</span>
<span class="gi">+            &quot;Used when a word in comment is not spelled correctly.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0402&quot;: (</span>
<span class="gi">+            &quot;Wrong spelling of a word &#39;%s&#39; in a docstring:\n%s\n&quot;</span>
<span class="gi">+            &quot;%s\nDid you mean: &#39;%s&#39;?&quot;,</span>
<span class="gi">+            &quot;wrong-spelling-in-docstring&quot;,</span>
<span class="gi">+            &quot;Used when a word in docstring is not spelled correctly.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0403&quot;: (</span>
<span class="gi">+            &quot;Invalid characters %r in a docstring&quot;,</span>
<span class="gi">+            &quot;invalid-characters-in-docstring&quot;,</span>
<span class="gi">+            &quot;Used when a word in docstring cannot be checked by enchant.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;spelling-dict&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;choice&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;dict name&gt;&quot;,</span>
<span class="gi">+                &quot;choices&quot;: _get_enchant_dict_choices(enchant_dicts),</span>
<span class="gi">+                &quot;help&quot;: _get_enchant_dict_help(enchant_dicts, PYENCHANT_AVAILABLE),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;spelling-ignore-words&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma separated words&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of comma separated words that should not be checked.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;spelling-private-dict-file&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;path&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;path to file&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;A path to a file that contains the private &quot;</span>
<span class="gi">+                &quot;dictionary; one word per line.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="w"> </span>        (
<span class="gd">-        &quot;&quot;&quot;Wrong spelling of a word &#39;%s&#39; in a docstring:</span>
<span class="gd">-%s</span>
<span class="gd">-%s</span>
<span class="gd">-Did you mean: &#39;%s&#39;?&quot;&quot;&quot;</span>
<span class="gd">-        , &#39;wrong-spelling-in-docstring&#39;,</span>
<span class="gd">-        &#39;Used when a word in docstring is not spelled correctly.&#39;), &#39;C0403&#39;:</span>
<span class="gd">-        (&#39;Invalid characters %r in a docstring&#39;,</span>
<span class="gd">-        &#39;invalid-characters-in-docstring&#39;,</span>
<span class="gd">-        &#39;Used when a word in docstring cannot be checked by enchant.&#39;)}</span>
<span class="gd">-    options = (&#39;spelling-dict&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;choice&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;dict name&gt;&#39;, &#39;choices&#39;: _get_enchant_dict_choices(enchant_dicts),</span>
<span class="gd">-        &#39;help&#39;: _get_enchant_dict_help(enchant_dicts, PYENCHANT_AVAILABLE)}), (</span>
<span class="gd">-        &#39;spelling-ignore-words&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;string&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;comma separated words&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of comma separated words that should not be checked.&#39;}), (</span>
<span class="gd">-        &#39;spelling-private-dict-file&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;path&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;path to file&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;A path to a file that contains the private dictionary; one word per line.&#39;</span>
<span class="gd">-        }), (&#39;spelling-store-unknown-words&#39;, {&#39;default&#39;: &#39;n&#39;, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Tells whether to store unknown words to the private dictionary (see the --spelling-private-dict-file option) instead of raising a message.&#39;</span>
<span class="gd">-        }), (&#39;max-spelling-suggestions&#39;, {&#39;default&#39;: 4, &#39;type&#39;: &#39;int&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;N&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Limits count of emitted suggestions for spelling mistakes.&#39;}), (</span>
<span class="gd">-        &#39;spelling-ignore-comment-directives&#39;, {&#39;default&#39;:</span>
<span class="gd">-        &#39;fmt: on,fmt: off,noqa:,noqa,nosec,isort:skip,mypy:&#39;, &#39;type&#39;:</span>
<span class="gd">-        &#39;string&#39;, &#39;metavar&#39;: &#39;&lt;comma separated words&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of comma separated words that should be considered directives if they appear at the beginning of a comment and should not be checked.&#39;</span>
<span class="gd">-        })</span>
<span class="gi">+            &quot;spelling-store-unknown-words&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;n&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Tells whether to store unknown words to the &quot;</span>
<span class="gi">+                &quot;private dictionary (see the &quot;</span>
<span class="gi">+                &quot;--spelling-private-dict-file option) instead of &quot;</span>
<span class="gi">+                &quot;raising a message.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-spelling-suggestions&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 4,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;N&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Limits count of emitted suggestions for spelling mistakes.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;spelling-ignore-comment-directives&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;fmt: on,fmt: off,noqa:,noqa,nosec,isort:skip,mypy:&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma separated words&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of comma separated words that should be considered &quot;</span>
<span class="gi">+                &quot;directives if they appear at the beginning of a comment &quot;</span>
<span class="gi">+                &quot;and should not be checked.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        self.initialized = False</span>
<span class="gi">+        if not PYENCHANT_AVAILABLE:</span>
<span class="gi">+            return</span>
<span class="gi">+        dict_name = self.linter.config.spelling_dict</span>
<span class="gi">+        if not dict_name:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.ignore_list = [</span>
<span class="gi">+            w.strip() for w in self.linter.config.spelling_ignore_words.split(&quot;,&quot;)</span>
<span class="gi">+        ]</span>
<span class="gi">+        # &quot;param&quot; appears in docstring in param description and</span>
<span class="gi">+        # &quot;pylint&quot; appears in comments in pylint pragmas.</span>
<span class="gi">+        self.ignore_list.extend([&quot;param&quot;, &quot;pylint&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        self.ignore_comment_directive_list = [</span>
<span class="gi">+            w.strip()</span>
<span class="gi">+            for w in self.linter.config.spelling_ignore_comment_directives.split(&quot;,&quot;)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        if self.linter.config.spelling_private_dict_file:</span>
<span class="gi">+            self.spelling_dict = enchant.DictWithPWL(</span>
<span class="gi">+                dict_name, self.linter.config.spelling_private_dict_file</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.spelling_dict = enchant.Dict(dict_name)</span>
<span class="gi">+</span>
<span class="gi">+        if self.linter.config.spelling_store_unknown_words:</span>
<span class="gi">+            self.unknown_words: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        self.tokenizer = get_tokenizer(</span>
<span class="gi">+            dict_name,</span>
<span class="gi">+            chunkers=[ForwardSlashChunker],</span>
<span class="gi">+            filters=[</span>
<span class="gi">+                EmailFilter,</span>
<span class="gi">+                URLFilter,</span>
<span class="gi">+                WikiWordFilter,</span>
<span class="gi">+                WordsWithDigitsFilter,</span>
<span class="gi">+                WordsWithUnderscores,</span>
<span class="gi">+                CamelCasedWord,</span>
<span class="gi">+                SphinxDirectives,</span>
<span class="gi">+            ],</span>
<span class="gi">+        )</span>
<span class="gi">+        self.initialized = True</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-statements</span>
<span class="gi">+    def _check_spelling(self, msgid: str, line: str, line_num: int) -&gt; None:</span>
<span class="gi">+        original_line = line</span>
<span class="gi">+        try:</span>
<span class="gi">+            # The mypy warning is caught by the except statement</span>
<span class="gi">+            initial_space = re.search(r&quot;^\s+&quot;, line).regs[0][1]  # type: ignore[union-attr]</span>
<span class="gi">+        except (IndexError, AttributeError):</span>
<span class="gi">+            initial_space = 0</span>
<span class="gi">+        if line.strip().startswith(&quot;#&quot;) and &quot;docstring&quot; not in msgid:</span>
<span class="gi">+            line = line.strip()[1:]</span>
<span class="gi">+            # A ``Filter`` cannot determine if the directive is at the beginning of a line,</span>
<span class="gi">+            #   nor determine if a colon is present or not (``pyenchant`` strips trailing colons).</span>
<span class="gi">+            #   So implementing this here.</span>
<span class="gi">+            for iter_directive in self.ignore_comment_directive_list:</span>
<span class="gi">+                if line.startswith(&quot; &quot; + iter_directive):</span>
<span class="gi">+                    line = line[(len(iter_directive) + 1) :]</span>
<span class="gi">+                    break</span>
<span class="gi">+            starts_with_comment = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            starts_with_comment = False</span>
<span class="gi">+</span>
<span class="gi">+        line = _strip_code_flanked_in_backticks(line)</span>
<span class="gi">+</span>
<span class="gi">+        for word, word_start_at in self.tokenizer(line.strip()):</span>
<span class="gi">+            word_start_at += initial_space</span>
<span class="gi">+            lower_cased_word = word.casefold()</span>
<span class="gi">+</span>
<span class="gi">+            # Skip words from ignore list.</span>
<span class="gi">+            if word in self.ignore_list or lower_cased_word in self.ignore_list:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Strip starting u&#39; from unicode literals and r&#39; from raw strings.</span>
<span class="gi">+            if word.startswith((&quot;u&#39;&quot;, &#39;u&quot;&#39;, &quot;r&#39;&quot;, &#39;r&quot;&#39;)) and len(word) &gt; 2:</span>
<span class="gi">+                word = word[2:]</span>
<span class="gi">+                lower_cased_word = lower_cased_word[2:]</span>
<span class="gi">+</span>
<span class="gi">+            # If it is a known word, then continue.</span>
<span class="gi">+            try:</span>
<span class="gi">+                if self.spelling_dict.check(lower_cased_word):</span>
<span class="gi">+                    # The lower cased version of word passed spell checking</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # If we reached this far, it means there was a spelling mistake.</span>
<span class="gi">+                # Let&#39;s retry with the original work because &#39;unicode&#39; is a</span>
<span class="gi">+                # spelling mistake but &#39;Unicode&#39; is not</span>
<span class="gi">+                if self.spelling_dict.check(word):</span>
<span class="gi">+                    continue</span>
<span class="gi">+            except enchant.errors.Error:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;invalid-characters-in-docstring&quot;, line=line_num, args=(word,)</span>
<span class="gi">+                )</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Store word to private dict or raise a message.</span>
<span class="gi">+            if self.linter.config.spelling_store_unknown_words:</span>
<span class="gi">+                if lower_cased_word not in self.unknown_words:</span>
<span class="gi">+                    with open(</span>
<span class="gi">+                        self.linter.config.spelling_private_dict_file,</span>
<span class="gi">+                        &quot;a&quot;,</span>
<span class="gi">+                        encoding=&quot;utf-8&quot;,</span>
<span class="gi">+                    ) as f:</span>
<span class="gi">+                        f.write(f&quot;{lower_cased_word}\n&quot;)</span>
<span class="gi">+                    self.unknown_words.add(lower_cased_word)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Present up to N suggestions.</span>
<span class="gi">+                suggestions = self.spelling_dict.suggest(word)</span>
<span class="gi">+                del suggestions[self.linter.config.max_spelling_suggestions :]</span>
<span class="gi">+                line_segment = line[word_start_at:]</span>
<span class="gi">+                match = re.search(rf&quot;(\W|^)({word})(\W|$)&quot;, line_segment)</span>
<span class="gi">+                if match:</span>
<span class="gi">+                    # Start position of second group in regex.</span>
<span class="gi">+                    col = match.regs[2][0]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    col = line_segment.index(word)</span>
<span class="gi">+                col += word_start_at</span>
<span class="gi">+                if starts_with_comment:</span>
<span class="gi">+                    col += 1</span>
<span class="gi">+                indicator = (&quot; &quot; * col) + (&quot;^&quot; * len(word))</span>
<span class="gi">+                all_suggestion = &quot;&#39; or &#39;&quot;.join(suggestions)</span>
<span class="gi">+                args = (word, original_line, indicator, f&quot;&#39;{all_suggestion}&#39;&quot;)</span>
<span class="gi">+                self.add_message(msgid, line=line_num, args=args)</span>
<span class="gi">+</span>
<span class="gi">+    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt; None:</span>
<span class="gi">+        if not self.initialized:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Process tokens and look for comments.</span>
<span class="gi">+        for tok_type, token, (start_row, _), _, _ in tokens:</span>
<span class="gi">+            if tok_type == tokenize.COMMENT:</span>
<span class="gi">+                if start_row == 1 and token.startswith(&quot;#!/&quot;):</span>
<span class="gi">+                    # Skip shebang lines</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if token.startswith(&quot;# pylint:&quot;):</span>
<span class="gi">+                    # Skip pylint enable/disable comments</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if token.startswith(&quot;# type: &quot;):</span>
<span class="gi">+                    # Skip python 2 type comments and mypy type ignore comments</span>
<span class="gi">+                    # mypy do not support additional text in type comments</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self._check_spelling(&quot;wrong-spelling-in-comment&quot;, token, start_row)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;wrong-spelling-in-docstring&quot;)</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="gi">+        self._check_docstring(node)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;wrong-spelling-in-docstring&quot;)</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        self._check_docstring(node)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;wrong-spelling-in-docstring&quot;)</span>
<span class="gi">+    def visit_functiondef(</span>
<span class="gi">+        self, node: nodes.FunctionDef | nodes.AsyncFunctionDef</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._check_docstring(node)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    def _check_docstring(self, node: (nodes.FunctionDef | nodes.</span>
<span class="gd">-        AsyncFunctionDef | nodes.ClassDef | nodes.Module)) -&gt;None:</span>
<span class="gi">+    def _check_docstring(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: (</span>
<span class="gi">+            nodes.FunctionDef | nodes.AsyncFunctionDef | nodes.ClassDef | nodes.Module</span>
<span class="gi">+        ),</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the node has any spelling errors.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.initialized:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not node.doc_node:</span>
<span class="gi">+            return</span>
<span class="gi">+        start_line = node.lineno + 1</span>
<span class="gi">+        # Go through lines of docstring</span>
<span class="gi">+        for idx, line in enumerate(node.doc_node.value.splitlines()):</span>
<span class="gi">+            self._check_spelling(&quot;wrong-spelling-in-docstring&quot;, line, start_line + idx)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(SpellingChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/stdlib.py b/pylint/checkers/stdlib.py</span>
<span class="gh">index 0baac8efa..10c1d54bf 100644</span>
<span class="gd">--- a/pylint/checkers/stdlib.py</span>
<span class="gi">+++ b/pylint/checkers/stdlib.py</span>
<span class="gu">@@ -1,229 +1,548 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checkers for various standard library functions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from collections.abc import Iterable
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Dict, Set, Tuple
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes, util
<span class="w"> </span>from astroid.typing import InferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint import interfaces
<span class="w"> </span>from pylint.checkers import BaseChecker, DeprecatedMixin, utils
<span class="w"> </span>from pylint.interfaces import HIGH, INFERENCE
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="w"> </span>DeprecationDict = Dict[Tuple[int, int, int], Set[str]]
<span class="gd">-OPEN_FILES_MODE = &#39;open&#39;, &#39;file&#39;</span>
<span class="gd">-OPEN_FILES_FUNCS = *OPEN_FILES_MODE, &#39;read_text&#39;, &#39;write_text&#39;</span>
<span class="gd">-UNITTEST_CASE = &#39;unittest.case&#39;</span>
<span class="gd">-THREADING_THREAD = &#39;threading.Thread&#39;</span>
<span class="gd">-COPY_COPY = &#39;copy.copy&#39;</span>
<span class="gd">-OS_ENVIRON = &#39;os._Environ&#39;</span>
<span class="gd">-ENV_GETTERS = &#39;os.getenv&#39;,</span>
<span class="gd">-SUBPROCESS_POPEN = &#39;subprocess.Popen&#39;</span>
<span class="gd">-SUBPROCESS_RUN = &#39;subprocess.run&#39;</span>
<span class="gd">-OPEN_MODULE = {&#39;_io&#39;, &#39;pathlib&#39;}</span>
<span class="gd">-DEBUG_BREAKPOINTS = (&#39;builtins.breakpoint&#39;, &#39;sys.breakpointhook&#39;,</span>
<span class="gd">-    &#39;pdb.set_trace&#39;)</span>
<span class="gd">-LRU_CACHE = {&#39;functools.lru_cache&#39;, &#39;functools._lru_cache_wrapper.wrapper&#39;,</span>
<span class="gd">-    &#39;functools.lru_cache.decorating_function&#39;}</span>
<span class="gd">-NON_INSTANCE_METHODS = {&#39;builtins.staticmethod&#39;, &#39;builtins.classmethod&#39;}</span>
<span class="gd">-DEPRECATED_ARGUMENTS: dict[tuple[int, int, int], dict[str, tuple[tuple[int |</span>
<span class="gd">-    None, str], ...]]] = {(0, 0, 0): {&#39;int&#39;: ((None, &#39;x&#39;),), &#39;bool&#39;: ((None,</span>
<span class="gd">-    &#39;x&#39;),), &#39;float&#39;: ((None, &#39;x&#39;),)}, (3, 8, 0): {&#39;asyncio.tasks.sleep&#39;: ((</span>
<span class="gd">-    None, &#39;loop&#39;),), &#39;asyncio.tasks.gather&#39;: ((None, &#39;loop&#39;),),</span>
<span class="gd">-    &#39;asyncio.tasks.shield&#39;: ((None, &#39;loop&#39;),), &#39;asyncio.tasks.wait_for&#39;: ((</span>
<span class="gd">-    None, &#39;loop&#39;),), &#39;asyncio.tasks.wait&#39;: ((None, &#39;loop&#39;),),</span>
<span class="gd">-    &#39;asyncio.tasks.as_completed&#39;: ((None, &#39;loop&#39;),),</span>
<span class="gd">-    &#39;asyncio.subprocess.create_subprocess_exec&#39;: ((None, &#39;loop&#39;),),</span>
<span class="gd">-    &#39;asyncio.subprocess.create_subprocess_shell&#39;: ((4, &#39;loop&#39;),),</span>
<span class="gd">-    &#39;gettext.translation&#39;: ((5, &#39;codeset&#39;),), &#39;gettext.install&#39;: ((2,</span>
<span class="gd">-    &#39;codeset&#39;),), &#39;functools.partialmethod&#39;: ((None, &#39;func&#39;),),</span>
<span class="gd">-    &#39;weakref.finalize&#39;: ((None, &#39;func&#39;), (None, &#39;obj&#39;)),</span>
<span class="gd">-    &#39;profile.Profile.runcall&#39;: ((None, &#39;func&#39;),),</span>
<span class="gd">-    &#39;cProfile.Profile.runcall&#39;: ((None, &#39;func&#39;),), &#39;bdb.Bdb.runcall&#39;: ((</span>
<span class="gd">-    None, &#39;func&#39;),), &#39;trace.Trace.runfunc&#39;: ((None, &#39;func&#39;),),</span>
<span class="gd">-    &#39;curses.wrapper&#39;: ((None, &#39;func&#39;),),</span>
<span class="gd">-    &#39;unittest.case.TestCase.addCleanup&#39;: ((None, &#39;function&#39;),),</span>
<span class="gd">-    &#39;concurrent.futures.thread.ThreadPoolExecutor.submit&#39;: ((None, &#39;fn&#39;),),</span>
<span class="gd">-    &#39;concurrent.futures.process.ProcessPoolExecutor.submit&#39;: ((None, &#39;fn&#39;),</span>
<span class="gd">-    ), &#39;contextlib._BaseExitStack.callback&#39;: ((None, &#39;callback&#39;),),</span>
<span class="gd">-    &#39;contextlib.AsyncExitStack.push_async_callback&#39;: ((None, &#39;callback&#39;),),</span>
<span class="gd">-    &#39;multiprocessing.managers.Server.create&#39;: ((None, &#39;c&#39;), (None, &#39;typeid&#39;</span>
<span class="gd">-    )), &#39;multiprocessing.managers.SharedMemoryServer.create&#39;: ((None, &#39;c&#39;),</span>
<span class="gd">-    (None, &#39;typeid&#39;))}, (3, 9, 0): {&#39;random.Random.shuffle&#39;: ((1, &#39;random&#39;)</span>
<span class="gd">-    ,)}, (3, 12, 0): {&#39;argparse.BooleanOptionalAction&#39;: ((3, &#39;type&#39;), (4,</span>
<span class="gd">-    &#39;choices&#39;), (7, &#39;metavar&#39;)), &#39;coroutine.throw&#39;: ((1, &#39;value&#39;), (2,</span>
<span class="gd">-    &#39;traceback&#39;)), &#39;email.utils.localtime&#39;: ((1, &#39;isdst&#39;),),</span>
<span class="gd">-    &#39;shutil.rmtree&#39;: ((2, &#39;onerror&#39;),)}}</span>
<span class="gd">-DEPRECATED_DECORATORS: DeprecationDict = {(3, 8, 0): {&#39;asyncio.coroutine&#39;},</span>
<span class="gd">-    (3, 3, 0): {&#39;abc.abstractclassmethod&#39;, &#39;abc.abstractstaticmethod&#39;,</span>
<span class="gd">-    &#39;abc.abstractproperty&#39;}, (3, 4, 0): {&#39;importlib.util.module_for_loader&#39;}}</span>
<span class="gd">-DEPRECATED_METHODS: dict[int, DeprecationDict] = {(0): {(0, 0, 0): {</span>
<span class="gd">-    &#39;cgi.parse_qs&#39;, &#39;cgi.parse_qsl&#39;, &#39;ctypes.c_buffer&#39;,</span>
<span class="gd">-    &#39;distutils.command.register.register.check_metadata&#39;,</span>
<span class="gd">-    &#39;distutils.command.sdist.sdist.check_metadata&#39;,</span>
<span class="gd">-    &#39;tkinter.Misc.tk_menuBar&#39;, &#39;tkinter.Menu.tk_bindForTraversal&#39;}}, (2): {</span>
<span class="gd">-    (2, 6, 0): {&#39;commands.getstatus&#39;, &#39;os.popen2&#39;, &#39;os.popen3&#39;, &#39;os.popen4&#39;,</span>
<span class="gd">-    &#39;macostools.touched&#39;}, (2, 7, 0): {</span>
<span class="gd">-    &#39;unittest.case.TestCase.assertEquals&#39;,</span>
<span class="gd">-    &#39;unittest.case.TestCase.assertNotEquals&#39;,</span>
<span class="gd">-    &#39;unittest.case.TestCase.assertAlmostEquals&#39;,</span>
<span class="gd">-    &#39;unittest.case.TestCase.assertNotAlmostEquals&#39;,</span>
<span class="gd">-    &#39;unittest.case.TestCase.assert_&#39;,</span>
<span class="gd">-    &#39;xml.etree.ElementTree.Element.getchildren&#39;,</span>
<span class="gd">-    &#39;xml.etree.ElementTree.Element.getiterator&#39;,</span>
<span class="gd">-    &#39;xml.etree.ElementTree.XMLParser.getiterator&#39;,</span>
<span class="gd">-    &#39;xml.etree.ElementTree.XMLParser.doctype&#39;}}, (3): {(3, 0, 0): {</span>
<span class="gd">-    &#39;inspect.getargspec&#39;, &#39;failUnlessEqual&#39;, &#39;assertEquals&#39;, &#39;failIfEqual&#39;,</span>
<span class="gd">-    &#39;assertNotEquals&#39;, &#39;failUnlessAlmostEqual&#39;, &#39;assertAlmostEquals&#39;,</span>
<span class="gd">-    &#39;failIfAlmostEqual&#39;, &#39;assertNotAlmostEquals&#39;, &#39;failUnless&#39;, &#39;assert_&#39;,</span>
<span class="gd">-    &#39;failUnlessRaises&#39;, &#39;failIf&#39;, &#39;assertRaisesRegexp&#39;,</span>
<span class="gd">-    &#39;assertRegexpMatches&#39;, &#39;assertNotRegexpMatches&#39;}, (3, 1, 0): {</span>
<span class="gd">-    &#39;base64.encodestring&#39;, &#39;base64.decodestring&#39;, &#39;ntpath.splitunc&#39;,</span>
<span class="gd">-    &#39;os.path.splitunc&#39;, &#39;os.stat_float_times&#39;,</span>
<span class="gd">-    &#39;turtle.RawTurtle.settiltangle&#39;}, (3, 2, 0): {&#39;cgi.escape&#39;,</span>
<span class="gd">-    &#39;configparser.RawConfigParser.readfp&#39;,</span>
<span class="gd">-    &#39;xml.etree.ElementTree.Element.getchildren&#39;,</span>
<span class="gd">-    &#39;xml.etree.ElementTree.Element.getiterator&#39;,</span>
<span class="gd">-    &#39;xml.etree.ElementTree.XMLParser.getiterator&#39;,</span>
<span class="gd">-    &#39;xml.etree.ElementTree.XMLParser.doctype&#39;}, (3, 3, 0): {</span>
<span class="gd">-    &#39;inspect.getmoduleinfo&#39;, &#39;logging.warn&#39;, &#39;logging.Logger.warn&#39;,</span>
<span class="gd">-    &#39;logging.LoggerAdapter.warn&#39;, &#39;nntplib._NNTPBase.xpath&#39;,</span>
<span class="gd">-    &#39;platform.popen&#39;, &#39;sqlite3.OptimizedUnicode&#39;, &#39;time.clock&#39;}, (3, 4, 0):</span>
<span class="gd">-    {&#39;importlib.find_loader&#39;, &#39;importlib.abc.Loader.load_module&#39;,</span>
<span class="gd">-    &#39;importlib.abc.Loader.module_repr&#39;,</span>
<span class="gd">-    &#39;importlib.abc.PathEntryFinder.find_loader&#39;,</span>
<span class="gd">-    &#39;importlib.abc.PathEntryFinder.find_module&#39;, &#39;plistlib.readPlist&#39;,</span>
<span class="gd">-    &#39;plistlib.writePlist&#39;, &#39;plistlib.readPlistFromBytes&#39;,</span>
<span class="gd">-    &#39;plistlib.writePlistToBytes&#39;}, (3, 4, 4): {&#39;asyncio.tasks.async&#39;}, (3, </span>
<span class="gd">-    5, 0): {&#39;fractions.gcd&#39;, &#39;inspect.formatargspec&#39;, &#39;inspect.getcallargs&#39;,</span>
<span class="gd">-    &#39;platform.linux_distribution&#39;, &#39;platform.dist&#39;}, (3, 6, 0): {</span>
<span class="gd">-    &#39;importlib._bootstrap_external.FileLoader.load_module&#39;,</span>
<span class="gd">-    &#39;_ssl.RAND_pseudo_bytes&#39;}, (3, 7, 0): {&#39;sys.set_coroutine_wrapper&#39;,</span>
<span class="gd">-    &#39;sys.get_coroutine_wrapper&#39;, &#39;aifc.openfp&#39;, &#39;threading.Thread.isAlive&#39;,</span>
<span class="gd">-    &#39;asyncio.Task.current_task&#39;, &#39;asyncio.Task.all_task&#39;, &#39;locale.format&#39;,</span>
<span class="gd">-    &#39;ssl.wrap_socket&#39;, &#39;ssl.match_hostname&#39;, &#39;sunau.openfp&#39;, &#39;wave.openfp&#39;},</span>
<span class="gd">-    (3, 8, 0): {&#39;gettext.lgettext&#39;, &#39;gettext.ldgettext&#39;,</span>
<span class="gd">-    &#39;gettext.lngettext&#39;, &#39;gettext.ldngettext&#39;,</span>
<span class="gd">-    &#39;gettext.bind_textdomain_codeset&#39;,</span>
<span class="gd">-    &#39;gettext.NullTranslations.output_charset&#39;,</span>
<span class="gd">-    &#39;gettext.NullTranslations.set_output_charset&#39;,</span>
<span class="gd">-    &#39;threading.Thread.isAlive&#39;}, (3, 9, 0): {&#39;binascii.b2a_hqx&#39;,</span>
<span class="gd">-    &#39;binascii.a2b_hqx&#39;, &#39;binascii.rlecode_hqx&#39;, &#39;binascii.rledecode_hqx&#39;,</span>
<span class="gd">-    &#39;importlib.resources.contents&#39;, &#39;importlib.resources.is_resource&#39;,</span>
<span class="gd">-    &#39;importlib.resources.open_binary&#39;, &#39;importlib.resources.open_text&#39;,</span>
<span class="gd">-    &#39;importlib.resources.path&#39;, &#39;importlib.resources.read_binary&#39;,</span>
<span class="gd">-    &#39;importlib.resources.read_text&#39;}, (3, 10, 0): {</span>
<span class="gd">-    &#39;_sqlite3.enable_shared_cache&#39;, &#39;importlib.abc.Finder.find_module&#39;,</span>
<span class="gd">-    &#39;pathlib.Path.link_to&#39;, &#39;zipimport.zipimporter.load_module&#39;,</span>
<span class="gd">-    &#39;zipimport.zipimporter.find_module&#39;,</span>
<span class="gd">-    &#39;zipimport.zipimporter.find_loader&#39;, &#39;threading.currentThread&#39;,</span>
<span class="gd">-    &#39;threading.activeCount&#39;, &#39;threading.Condition.notifyAll&#39;,</span>
<span class="gd">-    &#39;threading.Event.isSet&#39;, &#39;threading.Thread.setName&#39;,</span>
<span class="gd">-    &#39;threading.Thread.getName&#39;, &#39;threading.Thread.isDaemon&#39;,</span>
<span class="gd">-    &#39;threading.Thread.setDaemon&#39;, &#39;cgi.log&#39;}, (3, 11, 0): {</span>
<span class="gd">-    &#39;locale.getdefaultlocale&#39;, &#39;locale.resetlocale&#39;, &#39;re.template&#39;,</span>
<span class="gd">-    &#39;unittest.findTestCases&#39;, &#39;unittest.makeSuite&#39;,</span>
<span class="gd">-    &#39;unittest.getTestCaseNames&#39;, &#39;unittest.TestLoader.loadTestsFromModule&#39;,</span>
<span class="gd">-    &#39;unittest.TestLoader.loadTestsFromTestCase&#39;,</span>
<span class="gd">-    &#39;unittest.TestLoader.getTestCaseNames&#39;,</span>
<span class="gd">-    &#39;unittest.TestProgram.usageExit&#39;}, (3, 12, 0): {</span>
<span class="gd">-    &#39;builtins.bool.__invert__&#39;, &#39;datetime.datetime.utcfromtimestamp&#39;,</span>
<span class="gd">-    &#39;datetime.datetime.utcnow&#39;, &#39;pkgutil.find_loader&#39;, &#39;pkgutil.get_loader&#39;,</span>
<span class="gd">-    &#39;pty.master_open&#39;, &#39;pty.slave_open&#39;,</span>
<span class="gd">-    &#39;xml.etree.ElementTree.Element.__bool__&#39;}}}</span>
<span class="gd">-DEPRECATED_CLASSES: dict[tuple[int, int, int], dict[str, set[str]]] = {(3, </span>
<span class="gd">-    2, 0): {&#39;configparser&#39;: {&#39;LegacyInterpolation&#39;, &#39;SafeConfigParser&#39;}}, (</span>
<span class="gd">-    3, 3, 0): {&#39;importlib.abc&#39;: {&#39;Finder&#39;}, &#39;pkgutil&#39;: {&#39;ImpImporter&#39;,</span>
<span class="gd">-    &#39;ImpLoader&#39;}, &#39;collections&#39;: {&#39;Awaitable&#39;, &#39;Coroutine&#39;, &#39;AsyncIterable&#39;,</span>
<span class="gd">-    &#39;AsyncIterator&#39;, &#39;AsyncGenerator&#39;, &#39;Hashable&#39;, &#39;Iterable&#39;, &#39;Iterator&#39;,</span>
<span class="gd">-    &#39;Generator&#39;, &#39;Reversible&#39;, &#39;Sized&#39;, &#39;Container&#39;, &#39;Callable&#39;,</span>
<span class="gd">-    &#39;Collection&#39;, &#39;Set&#39;, &#39;MutableSet&#39;, &#39;Mapping&#39;, &#39;MutableMapping&#39;,</span>
<span class="gd">-    &#39;MappingView&#39;, &#39;KeysView&#39;, &#39;ItemsView&#39;, &#39;ValuesView&#39;, &#39;Sequence&#39;,</span>
<span class="gd">-    &#39;MutableSequence&#39;, &#39;ByteString&#39;}}, (3, 9, 0): {&#39;smtpd&#39;: {&#39;MailmanProxy&#39;</span>
<span class="gd">-    }}, (3, 11, 0): {&#39;typing&#39;: {&#39;Text&#39;}, &#39;webbrowser&#39;: {&#39;MacOSX&#39;}}, (3, 12,</span>
<span class="gd">-    0): {&#39;ast&#39;: {&#39;Bytes&#39;, &#39;Ellipsis&#39;, &#39;NameConstant&#39;, &#39;Num&#39;, &#39;Str&#39;},</span>
<span class="gd">-    &#39;asyncio&#39;: {&#39;AbstractChildWatcher&#39;, &#39;MultiLoopChildWatcher&#39;,</span>
<span class="gd">-    &#39;FastChildWatcher&#39;, &#39;SafeChildWatcher&#39;}, &#39;collections.abc&#39;: {</span>
<span class="gd">-    &#39;ByteString&#39;}, &#39;importlib.abc&#39;: {&#39;ResourceReader&#39;, &#39;Traversable&#39;,</span>
<span class="gd">-    &#39;TraversableResources&#39;}, &#39;typing&#39;: {&#39;ByteString&#39;, &#39;Hashable&#39;, &#39;Sized&#39;}}}</span>
<span class="gd">-DEPRECATED_ATTRIBUTES: DeprecationDict = {(3, 2, 0): {</span>
<span class="gd">-    &#39;configparser.ParsingError.filename&#39;}, (3, 12, 0): {&#39;calendar.January&#39;,</span>
<span class="gd">-    &#39;calendar.February&#39;, &#39;sys.last_traceback&#39;, &#39;sys.last_type&#39;,</span>
<span class="gd">-    &#39;sys.last_value&#39;}}</span>
<span class="gi">+</span>
<span class="gi">+OPEN_FILES_MODE = (&quot;open&quot;, &quot;file&quot;)</span>
<span class="gi">+OPEN_FILES_FUNCS = (*OPEN_FILES_MODE, &quot;read_text&quot;, &quot;write_text&quot;)</span>
<span class="gi">+UNITTEST_CASE = &quot;unittest.case&quot;</span>
<span class="gi">+THREADING_THREAD = &quot;threading.Thread&quot;</span>
<span class="gi">+COPY_COPY = &quot;copy.copy&quot;</span>
<span class="gi">+OS_ENVIRON = &quot;os._Environ&quot;</span>
<span class="gi">+ENV_GETTERS = (&quot;os.getenv&quot;,)</span>
<span class="gi">+SUBPROCESS_POPEN = &quot;subprocess.Popen&quot;</span>
<span class="gi">+SUBPROCESS_RUN = &quot;subprocess.run&quot;</span>
<span class="gi">+OPEN_MODULE = {&quot;_io&quot;, &quot;pathlib&quot;}</span>
<span class="gi">+DEBUG_BREAKPOINTS = (&quot;builtins.breakpoint&quot;, &quot;sys.breakpointhook&quot;, &quot;pdb.set_trace&quot;)</span>
<span class="gi">+LRU_CACHE = {</span>
<span class="gi">+    &quot;functools.lru_cache&quot;,  # Inferred for @lru_cache</span>
<span class="gi">+    &quot;functools._lru_cache_wrapper.wrapper&quot;,  # Inferred for @lru_cache() on &gt;= Python 3.8</span>
<span class="gi">+    &quot;functools.lru_cache.decorating_function&quot;,  # Inferred for @lru_cache() on &lt;= Python 3.7</span>
<span class="gi">+}</span>
<span class="gi">+NON_INSTANCE_METHODS = {&quot;builtins.staticmethod&quot;, &quot;builtins.classmethod&quot;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# For modules, see ImportsChecker</span>
<span class="gi">+</span>
<span class="gi">+DEPRECATED_ARGUMENTS: dict[</span>
<span class="gi">+    tuple[int, int, int], dict[str, tuple[tuple[int | None, str], ...]]</span>
<span class="gi">+] = {</span>
<span class="gi">+    (0, 0, 0): {</span>
<span class="gi">+        &quot;int&quot;: ((None, &quot;x&quot;),),</span>
<span class="gi">+        &quot;bool&quot;: ((None, &quot;x&quot;),),</span>
<span class="gi">+        &quot;float&quot;: ((None, &quot;x&quot;),),</span>
<span class="gi">+    },</span>
<span class="gi">+    (3, 8, 0): {</span>
<span class="gi">+        &quot;asyncio.tasks.sleep&quot;: ((None, &quot;loop&quot;),),</span>
<span class="gi">+        &quot;asyncio.tasks.gather&quot;: ((None, &quot;loop&quot;),),</span>
<span class="gi">+        &quot;asyncio.tasks.shield&quot;: ((None, &quot;loop&quot;),),</span>
<span class="gi">+        &quot;asyncio.tasks.wait_for&quot;: ((None, &quot;loop&quot;),),</span>
<span class="gi">+        &quot;asyncio.tasks.wait&quot;: ((None, &quot;loop&quot;),),</span>
<span class="gi">+        &quot;asyncio.tasks.as_completed&quot;: ((None, &quot;loop&quot;),),</span>
<span class="gi">+        &quot;asyncio.subprocess.create_subprocess_exec&quot;: ((None, &quot;loop&quot;),),</span>
<span class="gi">+        &quot;asyncio.subprocess.create_subprocess_shell&quot;: ((4, &quot;loop&quot;),),</span>
<span class="gi">+        &quot;gettext.translation&quot;: ((5, &quot;codeset&quot;),),</span>
<span class="gi">+        &quot;gettext.install&quot;: ((2, &quot;codeset&quot;),),</span>
<span class="gi">+        &quot;functools.partialmethod&quot;: ((None, &quot;func&quot;),),</span>
<span class="gi">+        &quot;weakref.finalize&quot;: ((None, &quot;func&quot;), (None, &quot;obj&quot;)),</span>
<span class="gi">+        &quot;profile.Profile.runcall&quot;: ((None, &quot;func&quot;),),</span>
<span class="gi">+        &quot;cProfile.Profile.runcall&quot;: ((None, &quot;func&quot;),),</span>
<span class="gi">+        &quot;bdb.Bdb.runcall&quot;: ((None, &quot;func&quot;),),</span>
<span class="gi">+        &quot;trace.Trace.runfunc&quot;: ((None, &quot;func&quot;),),</span>
<span class="gi">+        &quot;curses.wrapper&quot;: ((None, &quot;func&quot;),),</span>
<span class="gi">+        &quot;unittest.case.TestCase.addCleanup&quot;: ((None, &quot;function&quot;),),</span>
<span class="gi">+        &quot;concurrent.futures.thread.ThreadPoolExecutor.submit&quot;: ((None, &quot;fn&quot;),),</span>
<span class="gi">+        &quot;concurrent.futures.process.ProcessPoolExecutor.submit&quot;: ((None, &quot;fn&quot;),),</span>
<span class="gi">+        &quot;contextlib._BaseExitStack.callback&quot;: ((None, &quot;callback&quot;),),</span>
<span class="gi">+        &quot;contextlib.AsyncExitStack.push_async_callback&quot;: ((None, &quot;callback&quot;),),</span>
<span class="gi">+        &quot;multiprocessing.managers.Server.create&quot;: ((None, &quot;c&quot;), (None, &quot;typeid&quot;)),</span>
<span class="gi">+        &quot;multiprocessing.managers.SharedMemoryServer.create&quot;: (</span>
<span class="gi">+            (None, &quot;c&quot;),</span>
<span class="gi">+            (None, &quot;typeid&quot;),</span>
<span class="gi">+        ),</span>
<span class="gi">+    },</span>
<span class="gi">+    (3, 9, 0): {&quot;random.Random.shuffle&quot;: ((1, &quot;random&quot;),)},</span>
<span class="gi">+    (3, 12, 0): {</span>
<span class="gi">+        &quot;argparse.BooleanOptionalAction&quot;: ((3, &quot;type&quot;), (4, &quot;choices&quot;), (7, &quot;metavar&quot;)),</span>
<span class="gi">+        &quot;coroutine.throw&quot;: ((1, &quot;value&quot;), (2, &quot;traceback&quot;)),</span>
<span class="gi">+        &quot;email.utils.localtime&quot;: ((1, &quot;isdst&quot;),),</span>
<span class="gi">+        &quot;shutil.rmtree&quot;: ((2, &quot;onerror&quot;),),</span>
<span class="gi">+    },</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+DEPRECATED_DECORATORS: DeprecationDict = {</span>
<span class="gi">+    (3, 8, 0): {&quot;asyncio.coroutine&quot;},</span>
<span class="gi">+    (3, 3, 0): {</span>
<span class="gi">+        &quot;abc.abstractclassmethod&quot;,</span>
<span class="gi">+        &quot;abc.abstractstaticmethod&quot;,</span>
<span class="gi">+        &quot;abc.abstractproperty&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+    (3, 4, 0): {&quot;importlib.util.module_for_loader&quot;},</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DEPRECATED_METHODS: dict[int, DeprecationDict] = {</span>
<span class="gi">+    0: {</span>
<span class="gi">+        (0, 0, 0): {</span>
<span class="gi">+            &quot;cgi.parse_qs&quot;,</span>
<span class="gi">+            &quot;cgi.parse_qsl&quot;,</span>
<span class="gi">+            &quot;ctypes.c_buffer&quot;,</span>
<span class="gi">+            &quot;distutils.command.register.register.check_metadata&quot;,</span>
<span class="gi">+            &quot;distutils.command.sdist.sdist.check_metadata&quot;,</span>
<span class="gi">+            &quot;tkinter.Misc.tk_menuBar&quot;,</span>
<span class="gi">+            &quot;tkinter.Menu.tk_bindForTraversal&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+    },</span>
<span class="gi">+    2: {</span>
<span class="gi">+        (2, 6, 0): {</span>
<span class="gi">+            &quot;commands.getstatus&quot;,</span>
<span class="gi">+            &quot;os.popen2&quot;,</span>
<span class="gi">+            &quot;os.popen3&quot;,</span>
<span class="gi">+            &quot;os.popen4&quot;,</span>
<span class="gi">+            &quot;macostools.touched&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (2, 7, 0): {</span>
<span class="gi">+            &quot;unittest.case.TestCase.assertEquals&quot;,</span>
<span class="gi">+            &quot;unittest.case.TestCase.assertNotEquals&quot;,</span>
<span class="gi">+            &quot;unittest.case.TestCase.assertAlmostEquals&quot;,</span>
<span class="gi">+            &quot;unittest.case.TestCase.assertNotAlmostEquals&quot;,</span>
<span class="gi">+            &quot;unittest.case.TestCase.assert_&quot;,</span>
<span class="gi">+            &quot;xml.etree.ElementTree.Element.getchildren&quot;,</span>
<span class="gi">+            &quot;xml.etree.ElementTree.Element.getiterator&quot;,</span>
<span class="gi">+            &quot;xml.etree.ElementTree.XMLParser.getiterator&quot;,</span>
<span class="gi">+            &quot;xml.etree.ElementTree.XMLParser.doctype&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    },</span>
<span class="gi">+    3: {</span>
<span class="gi">+        (3, 0, 0): {</span>
<span class="gi">+            &quot;inspect.getargspec&quot;,</span>
<span class="gi">+            &quot;failUnlessEqual&quot;,</span>
<span class="gi">+            &quot;assertEquals&quot;,</span>
<span class="gi">+            &quot;failIfEqual&quot;,</span>
<span class="gi">+            &quot;assertNotEquals&quot;,</span>
<span class="gi">+            &quot;failUnlessAlmostEqual&quot;,</span>
<span class="gi">+            &quot;assertAlmostEquals&quot;,</span>
<span class="gi">+            &quot;failIfAlmostEqual&quot;,</span>
<span class="gi">+            &quot;assertNotAlmostEquals&quot;,</span>
<span class="gi">+            &quot;failUnless&quot;,</span>
<span class="gi">+            &quot;assert_&quot;,</span>
<span class="gi">+            &quot;failUnlessRaises&quot;,</span>
<span class="gi">+            &quot;failIf&quot;,</span>
<span class="gi">+            &quot;assertRaisesRegexp&quot;,</span>
<span class="gi">+            &quot;assertRegexpMatches&quot;,</span>
<span class="gi">+            &quot;assertNotRegexpMatches&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 1, 0): {</span>
<span class="gi">+            &quot;base64.encodestring&quot;,</span>
<span class="gi">+            &quot;base64.decodestring&quot;,</span>
<span class="gi">+            &quot;ntpath.splitunc&quot;,</span>
<span class="gi">+            &quot;os.path.splitunc&quot;,</span>
<span class="gi">+            &quot;os.stat_float_times&quot;,</span>
<span class="gi">+            &quot;turtle.RawTurtle.settiltangle&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 2, 0): {</span>
<span class="gi">+            &quot;cgi.escape&quot;,</span>
<span class="gi">+            &quot;configparser.RawConfigParser.readfp&quot;,</span>
<span class="gi">+            &quot;xml.etree.ElementTree.Element.getchildren&quot;,</span>
<span class="gi">+            &quot;xml.etree.ElementTree.Element.getiterator&quot;,</span>
<span class="gi">+            &quot;xml.etree.ElementTree.XMLParser.getiterator&quot;,</span>
<span class="gi">+            &quot;xml.etree.ElementTree.XMLParser.doctype&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 3, 0): {</span>
<span class="gi">+            &quot;inspect.getmoduleinfo&quot;,</span>
<span class="gi">+            &quot;logging.warn&quot;,</span>
<span class="gi">+            &quot;logging.Logger.warn&quot;,</span>
<span class="gi">+            &quot;logging.LoggerAdapter.warn&quot;,</span>
<span class="gi">+            &quot;nntplib._NNTPBase.xpath&quot;,</span>
<span class="gi">+            &quot;platform.popen&quot;,</span>
<span class="gi">+            &quot;sqlite3.OptimizedUnicode&quot;,</span>
<span class="gi">+            &quot;time.clock&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 4, 0): {</span>
<span class="gi">+            &quot;importlib.find_loader&quot;,</span>
<span class="gi">+            &quot;importlib.abc.Loader.load_module&quot;,</span>
<span class="gi">+            &quot;importlib.abc.Loader.module_repr&quot;,</span>
<span class="gi">+            &quot;importlib.abc.PathEntryFinder.find_loader&quot;,</span>
<span class="gi">+            &quot;importlib.abc.PathEntryFinder.find_module&quot;,</span>
<span class="gi">+            &quot;plistlib.readPlist&quot;,</span>
<span class="gi">+            &quot;plistlib.writePlist&quot;,</span>
<span class="gi">+            &quot;plistlib.readPlistFromBytes&quot;,</span>
<span class="gi">+            &quot;plistlib.writePlistToBytes&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 4, 4): {&quot;asyncio.tasks.async&quot;},</span>
<span class="gi">+        (3, 5, 0): {</span>
<span class="gi">+            &quot;fractions.gcd&quot;,</span>
<span class="gi">+            &quot;inspect.formatargspec&quot;,</span>
<span class="gi">+            &quot;inspect.getcallargs&quot;,</span>
<span class="gi">+            &quot;platform.linux_distribution&quot;,</span>
<span class="gi">+            &quot;platform.dist&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 6, 0): {</span>
<span class="gi">+            &quot;importlib._bootstrap_external.FileLoader.load_module&quot;,</span>
<span class="gi">+            &quot;_ssl.RAND_pseudo_bytes&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 7, 0): {</span>
<span class="gi">+            &quot;sys.set_coroutine_wrapper&quot;,</span>
<span class="gi">+            &quot;sys.get_coroutine_wrapper&quot;,</span>
<span class="gi">+            &quot;aifc.openfp&quot;,</span>
<span class="gi">+            &quot;threading.Thread.isAlive&quot;,</span>
<span class="gi">+            &quot;asyncio.Task.current_task&quot;,</span>
<span class="gi">+            &quot;asyncio.Task.all_task&quot;,</span>
<span class="gi">+            &quot;locale.format&quot;,</span>
<span class="gi">+            &quot;ssl.wrap_socket&quot;,</span>
<span class="gi">+            &quot;ssl.match_hostname&quot;,</span>
<span class="gi">+            &quot;sunau.openfp&quot;,</span>
<span class="gi">+            &quot;wave.openfp&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 8, 0): {</span>
<span class="gi">+            &quot;gettext.lgettext&quot;,</span>
<span class="gi">+            &quot;gettext.ldgettext&quot;,</span>
<span class="gi">+            &quot;gettext.lngettext&quot;,</span>
<span class="gi">+            &quot;gettext.ldngettext&quot;,</span>
<span class="gi">+            &quot;gettext.bind_textdomain_codeset&quot;,</span>
<span class="gi">+            &quot;gettext.NullTranslations.output_charset&quot;,</span>
<span class="gi">+            &quot;gettext.NullTranslations.set_output_charset&quot;,</span>
<span class="gi">+            &quot;threading.Thread.isAlive&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 9, 0): {</span>
<span class="gi">+            &quot;binascii.b2a_hqx&quot;,</span>
<span class="gi">+            &quot;binascii.a2b_hqx&quot;,</span>
<span class="gi">+            &quot;binascii.rlecode_hqx&quot;,</span>
<span class="gi">+            &quot;binascii.rledecode_hqx&quot;,</span>
<span class="gi">+            &quot;importlib.resources.contents&quot;,</span>
<span class="gi">+            &quot;importlib.resources.is_resource&quot;,</span>
<span class="gi">+            &quot;importlib.resources.open_binary&quot;,</span>
<span class="gi">+            &quot;importlib.resources.open_text&quot;,</span>
<span class="gi">+            &quot;importlib.resources.path&quot;,</span>
<span class="gi">+            &quot;importlib.resources.read_binary&quot;,</span>
<span class="gi">+            &quot;importlib.resources.read_text&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 10, 0): {</span>
<span class="gi">+            &quot;_sqlite3.enable_shared_cache&quot;,</span>
<span class="gi">+            &quot;importlib.abc.Finder.find_module&quot;,</span>
<span class="gi">+            &quot;pathlib.Path.link_to&quot;,</span>
<span class="gi">+            &quot;zipimport.zipimporter.load_module&quot;,</span>
<span class="gi">+            &quot;zipimport.zipimporter.find_module&quot;,</span>
<span class="gi">+            &quot;zipimport.zipimporter.find_loader&quot;,</span>
<span class="gi">+            &quot;threading.currentThread&quot;,</span>
<span class="gi">+            &quot;threading.activeCount&quot;,</span>
<span class="gi">+            &quot;threading.Condition.notifyAll&quot;,</span>
<span class="gi">+            &quot;threading.Event.isSet&quot;,</span>
<span class="gi">+            &quot;threading.Thread.setName&quot;,</span>
<span class="gi">+            &quot;threading.Thread.getName&quot;,</span>
<span class="gi">+            &quot;threading.Thread.isDaemon&quot;,</span>
<span class="gi">+            &quot;threading.Thread.setDaemon&quot;,</span>
<span class="gi">+            &quot;cgi.log&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 11, 0): {</span>
<span class="gi">+            &quot;locale.getdefaultlocale&quot;,</span>
<span class="gi">+            &quot;locale.resetlocale&quot;,</span>
<span class="gi">+            &quot;re.template&quot;,</span>
<span class="gi">+            &quot;unittest.findTestCases&quot;,</span>
<span class="gi">+            &quot;unittest.makeSuite&quot;,</span>
<span class="gi">+            &quot;unittest.getTestCaseNames&quot;,</span>
<span class="gi">+            &quot;unittest.TestLoader.loadTestsFromModule&quot;,</span>
<span class="gi">+            &quot;unittest.TestLoader.loadTestsFromTestCase&quot;,</span>
<span class="gi">+            &quot;unittest.TestLoader.getTestCaseNames&quot;,</span>
<span class="gi">+            &quot;unittest.TestProgram.usageExit&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        (3, 12, 0): {</span>
<span class="gi">+            &quot;builtins.bool.__invert__&quot;,</span>
<span class="gi">+            &quot;datetime.datetime.utcfromtimestamp&quot;,</span>
<span class="gi">+            &quot;datetime.datetime.utcnow&quot;,</span>
<span class="gi">+            &quot;pkgutil.find_loader&quot;,</span>
<span class="gi">+            &quot;pkgutil.get_loader&quot;,</span>
<span class="gi">+            &quot;pty.master_open&quot;,</span>
<span class="gi">+            &quot;pty.slave_open&quot;,</span>
<span class="gi">+            &quot;xml.etree.ElementTree.Element.__bool__&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    },</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DEPRECATED_CLASSES: dict[tuple[int, int, int], dict[str, set[str]]] = {</span>
<span class="gi">+    (3, 2, 0): {</span>
<span class="gi">+        &quot;configparser&quot;: {</span>
<span class="gi">+            &quot;LegacyInterpolation&quot;,</span>
<span class="gi">+            &quot;SafeConfigParser&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    },</span>
<span class="gi">+    (3, 3, 0): {</span>
<span class="gi">+        &quot;importlib.abc&quot;: {</span>
<span class="gi">+            &quot;Finder&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;pkgutil&quot;: {</span>
<span class="gi">+            &quot;ImpImporter&quot;,</span>
<span class="gi">+            &quot;ImpLoader&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;collections&quot;: {</span>
<span class="gi">+            &quot;Awaitable&quot;,</span>
<span class="gi">+            &quot;Coroutine&quot;,</span>
<span class="gi">+            &quot;AsyncIterable&quot;,</span>
<span class="gi">+            &quot;AsyncIterator&quot;,</span>
<span class="gi">+            &quot;AsyncGenerator&quot;,</span>
<span class="gi">+            &quot;Hashable&quot;,</span>
<span class="gi">+            &quot;Iterable&quot;,</span>
<span class="gi">+            &quot;Iterator&quot;,</span>
<span class="gi">+            &quot;Generator&quot;,</span>
<span class="gi">+            &quot;Reversible&quot;,</span>
<span class="gi">+            &quot;Sized&quot;,</span>
<span class="gi">+            &quot;Container&quot;,</span>
<span class="gi">+            &quot;Callable&quot;,</span>
<span class="gi">+            &quot;Collection&quot;,</span>
<span class="gi">+            &quot;Set&quot;,</span>
<span class="gi">+            &quot;MutableSet&quot;,</span>
<span class="gi">+            &quot;Mapping&quot;,</span>
<span class="gi">+            &quot;MutableMapping&quot;,</span>
<span class="gi">+            &quot;MappingView&quot;,</span>
<span class="gi">+            &quot;KeysView&quot;,</span>
<span class="gi">+            &quot;ItemsView&quot;,</span>
<span class="gi">+            &quot;ValuesView&quot;,</span>
<span class="gi">+            &quot;Sequence&quot;,</span>
<span class="gi">+            &quot;MutableSequence&quot;,</span>
<span class="gi">+            &quot;ByteString&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    },</span>
<span class="gi">+    (3, 9, 0): {</span>
<span class="gi">+        &quot;smtpd&quot;: {</span>
<span class="gi">+            &quot;MailmanProxy&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+    },</span>
<span class="gi">+    (3, 11, 0): {</span>
<span class="gi">+        &quot;typing&quot;: {</span>
<span class="gi">+            &quot;Text&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;webbrowser&quot;: {</span>
<span class="gi">+            &quot;MacOSX&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    },</span>
<span class="gi">+    (3, 12, 0): {</span>
<span class="gi">+        &quot;ast&quot;: {</span>
<span class="gi">+            &quot;Bytes&quot;,</span>
<span class="gi">+            &quot;Ellipsis&quot;,</span>
<span class="gi">+            &quot;NameConstant&quot;,</span>
<span class="gi">+            &quot;Num&quot;,</span>
<span class="gi">+            &quot;Str&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;asyncio&quot;: {</span>
<span class="gi">+            &quot;AbstractChildWatcher&quot;,</span>
<span class="gi">+            &quot;MultiLoopChildWatcher&quot;,</span>
<span class="gi">+            &quot;FastChildWatcher&quot;,</span>
<span class="gi">+            &quot;SafeChildWatcher&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;collections.abc&quot;: {</span>
<span class="gi">+            &quot;ByteString&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;importlib.abc&quot;: {</span>
<span class="gi">+            &quot;ResourceReader&quot;,</span>
<span class="gi">+            &quot;Traversable&quot;,</span>
<span class="gi">+            &quot;TraversableResources&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+        &quot;typing&quot;: {</span>
<span class="gi">+            &quot;ByteString&quot;,</span>
<span class="gi">+            &quot;Hashable&quot;,</span>
<span class="gi">+            &quot;Sized&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    },</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DEPRECATED_ATTRIBUTES: DeprecationDict = {</span>
<span class="gi">+    (3, 2, 0): {</span>
<span class="gi">+        &quot;configparser.ParsingError.filename&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+    (3, 12, 0): {</span>
<span class="gi">+        &quot;calendar.January&quot;,</span>
<span class="gi">+        &quot;calendar.February&quot;,</span>
<span class="gi">+        &quot;sys.last_traceback&quot;,</span>
<span class="gi">+        &quot;sys.last_type&quot;,</span>
<span class="gi">+        &quot;sys.last_value&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _check_mode_str(mode: Any) -&gt; bool:</span>
<span class="gi">+    # check type</span>
<span class="gi">+    if not isinstance(mode, str):</span>
<span class="gi">+        return False</span>
<span class="gi">+    # check syntax</span>
<span class="gi">+    modes = set(mode)</span>
<span class="gi">+    _mode = &quot;rwatb+Ux&quot;</span>
<span class="gi">+    creating = &quot;x&quot; in modes</span>
<span class="gi">+    if modes - set(_mode) or len(mode) &gt; len(modes):</span>
<span class="gi">+        return False</span>
<span class="gi">+    # check logic</span>
<span class="gi">+    reading = &quot;r&quot; in modes</span>
<span class="gi">+    writing = &quot;w&quot; in modes</span>
<span class="gi">+    appending = &quot;a&quot; in modes</span>
<span class="gi">+    text = &quot;t&quot; in modes</span>
<span class="gi">+    binary = &quot;b&quot; in modes</span>
<span class="gi">+    if &quot;U&quot; in modes:</span>
<span class="gi">+        if writing or appending or creating:</span>
<span class="gi">+            return False</span>
<span class="gi">+        reading = True</span>
<span class="gi">+    if text and binary:</span>
<span class="gi">+        return False</span>
<span class="gi">+    total = reading + writing + appending + creating</span>
<span class="gi">+    if total &gt; 1:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if not (reading or writing or appending or creating):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>class StdlibChecker(DeprecatedMixin, BaseChecker):
<span class="gd">-    name = &#39;stdlib&#39;</span>
<span class="gd">-    msgs: dict[str, MessageDefinitionTuple] = {**DeprecatedMixin.</span>
<span class="gd">-        DEPRECATED_METHOD_MESSAGE, **DeprecatedMixin.</span>
<span class="gd">-        DEPRECATED_ARGUMENT_MESSAGE, **DeprecatedMixin.</span>
<span class="gd">-        DEPRECATED_CLASS_MESSAGE, **DeprecatedMixin.</span>
<span class="gd">-        DEPRECATED_DECORATOR_MESSAGE, **DeprecatedMixin.</span>
<span class="gd">-        DEPRECATED_ATTRIBUTE_MESSAGE, &#39;W1501&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; is not a valid mode for open.&#39;, &#39;bad-open-mode&#39;,</span>
<span class="gd">-        &#39;Python supports: r, w, a[, x] modes with b, +, and U (only with r) options. See https://docs.python.org/3/library/functions.html#open&#39;</span>
<span class="gd">-        ), &#39;W1502&#39;: (&#39;Using datetime.time in a boolean context.&#39;,</span>
<span class="gd">-        &#39;boolean-datetime&#39;,</span>
<span class="gd">-        &#39;Using datetime.time in a boolean context can hide subtle bugs when the time they represent matches midnight UTC. This behaviour was fixed in Python 3.5. See https://bugs.python.org/issue13936 for reference.&#39;</span>
<span class="gd">-        , {&#39;maxversion&#39;: (3, 5)}), &#39;W1503&#39;: (</span>
<span class="gd">-        &#39;Redundant use of %s with constant value %r&#39;,</span>
<span class="gd">-        &#39;redundant-unittest-assert&#39;,</span>
<span class="gd">-        &#39;The first argument of assertTrue and assertFalse is a condition. If a constant is passed as parameter, that condition will be always true. In this case a warning should be emitted.&#39;</span>
<span class="gd">-        ), &#39;W1506&#39;: (&#39;threading.Thread needs the target function&#39;,</span>
<span class="gd">-        &#39;bad-thread-instantiation&#39;,</span>
<span class="gd">-        &#39;The warning is emitted when a threading.Thread class is instantiated without the target function being passed as a kwarg or as a second argument. By default, the first parameter is the group param, not the target param.&#39;</span>
<span class="gd">-        ), &#39;W1507&#39;: (</span>
<span class="gd">-        &#39;Using copy.copy(os.environ). Use os.environ.copy() instead.&#39;,</span>
<span class="gd">-        &#39;shallow-copy-environ&#39;,</span>
<span class="gd">-        &#39;os.environ is not a dict object but proxy object, so shallow copy has still effects on original object. See https://bugs.python.org/issue15373 for reference.&#39;</span>
<span class="gd">-        ), &#39;E1507&#39;: (&#39;%s does not support %s type argument&#39;,</span>
<span class="gd">-        &#39;invalid-envvar-value&#39;,</span>
<span class="gd">-        &#39;Env manipulation functions support only string type arguments. See https://docs.python.org/3/library/os.html#os.getenv.&#39;</span>
<span class="gd">-        ), &#39;E1519&#39;: (</span>
<span class="gd">-        &#39;singledispatch decorator should not be used with methods, use singledispatchmethod instead.&#39;</span>
<span class="gd">-        , &#39;singledispatch-method&#39;,</span>
<span class="gd">-        &#39;singledispatch should decorate functions and not class/instance methods. Use singledispatchmethod for those cases.&#39;</span>
<span class="gd">-        ), &#39;E1520&#39;: (</span>
<span class="gd">-        &#39;singledispatchmethod decorator should not be used with functions, use singledispatch instead.&#39;</span>
<span class="gd">-        , &#39;singledispatchmethod-function&#39;,</span>
<span class="gd">-        &#39;singledispatchmethod should decorate class/instance methods and not functions. Use singledispatch for those cases.&#39;</span>
<span class="gd">-        ), &#39;W1508&#39;: (&#39;%s default type is %s. Expected str or None.&#39;,</span>
<span class="gd">-        &#39;invalid-envvar-default&#39;,</span>
<span class="gd">-        &#39;Env manipulation functions return None or str values. Supplying anything different as a default may cause bugs. See https://docs.python.org/3/library/os.html#os.getenv.&#39;</span>
<span class="gd">-        ), &#39;W1509&#39;: (</span>
<span class="gd">-        &#39;Using preexec_fn keyword which may be unsafe in the presence of threads&#39;</span>
<span class="gd">-        , &#39;subprocess-popen-preexec-fn&#39;,</span>
<span class="gd">-        &#39;The preexec_fn parameter is not safe to use in the presence of threads in your application. The child process could deadlock before exec is called. If you must use it, keep it trivial! Minimize the number of libraries you call into. See https://docs.python.org/3/library/subprocess.html#popen-constructor&#39;</span>
<span class="gd">-        ), &#39;W1510&#39;: (</span>
<span class="gd">-        &quot;&#39;subprocess.run&#39; used without explicitly defining the value for &#39;check&#39;.&quot;</span>
<span class="gd">-        , &#39;subprocess-run-check&#39;,</span>
<span class="gd">-        &quot;The ``check`` keyword  is set to False by default. It means the process launched by ``subprocess.run`` can exit with a non-zero exit code and fail silently. It&#39;s better to set it explicitly to make clear what the error-handling behavior is.&quot;</span>
<span class="gd">-        ), &#39;W1514&#39;: (&#39;Using open without explicitly specifying an encoding&#39;,</span>
<span class="gd">-        &#39;unspecified-encoding&#39;,</span>
<span class="gd">-        &#39;It is better to specify an encoding when opening documents. Using the system default implicitly can create problems on other operating systems. See https://peps.python.org/pep-0597/&#39;</span>
<span class="gd">-        ), &#39;W1515&#39;: (</span>
<span class="gd">-        &#39;Leaving functions creating breakpoints in production code is not recommended&#39;</span>
<span class="gd">-        , &#39;forgotten-debug-statement&#39;,</span>
<span class="gd">-        &#39;Calls to breakpoint(), sys.breakpointhook() and pdb.set_trace() should be removed from code that is not actively being debugged.&#39;</span>
<span class="gd">-        ), &#39;W1518&#39;: (</span>
<span class="gd">-        &quot;&#39;lru_cache(maxsize=None)&#39; or &#39;cache&#39; will keep all method args alive indefinitely, including &#39;self&#39;&quot;</span>
<span class="gd">-        , &#39;method-cache-max-size-none&#39;,</span>
<span class="gd">-        &quot;By decorating a method with lru_cache or cache the &#39;self&#39; argument will be linked to the function and therefore never garbage collected. Unless your instance will never need to be garbage collected (singleton) it is recommended to refactor code to avoid this pattern or add a maxsize to the cache. The default value for maxsize is 128.&quot;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;W1516&#39;, &#39;lru-cache-decorating-method&#39;), (&#39;W1517&#39;,</span>
<span class="gd">-        &#39;cache-max-size-none&#39;)]})}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    name = &quot;stdlib&quot;</span>
<span class="gi">+</span>
<span class="gi">+    msgs: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+        **DeprecatedMixin.DEPRECATED_METHOD_MESSAGE,</span>
<span class="gi">+        **DeprecatedMixin.DEPRECATED_ARGUMENT_MESSAGE,</span>
<span class="gi">+        **DeprecatedMixin.DEPRECATED_CLASS_MESSAGE,</span>
<span class="gi">+        **DeprecatedMixin.DEPRECATED_DECORATOR_MESSAGE,</span>
<span class="gi">+        **DeprecatedMixin.DEPRECATED_ATTRIBUTE_MESSAGE,</span>
<span class="gi">+        &quot;W1501&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; is not a valid mode for open.&#39;,</span>
<span class="gi">+            &quot;bad-open-mode&quot;,</span>
<span class="gi">+            &quot;Python supports: r, w, a[, x] modes with b, +, &quot;</span>
<span class="gi">+            &quot;and U (only with r) options. &quot;</span>
<span class="gi">+            &quot;See https://docs.python.org/3/library/functions.html#open&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1502&quot;: (</span>
<span class="gi">+            &quot;Using datetime.time in a boolean context.&quot;,</span>
<span class="gi">+            &quot;boolean-datetime&quot;,</span>
<span class="gi">+            &quot;Using datetime.time in a boolean context can hide &quot;</span>
<span class="gi">+            &quot;subtle bugs when the time they represent matches &quot;</span>
<span class="gi">+            &quot;midnight UTC. This behaviour was fixed in Python 3.5. &quot;</span>
<span class="gi">+            &quot;See https://bugs.python.org/issue13936 for reference.&quot;,</span>
<span class="gi">+            {&quot;maxversion&quot;: (3, 5)},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1503&quot;: (</span>
<span class="gi">+            &quot;Redundant use of %s with constant value %r&quot;,</span>
<span class="gi">+            &quot;redundant-unittest-assert&quot;,</span>
<span class="gi">+            &quot;The first argument of assertTrue and assertFalse is &quot;</span>
<span class="gi">+            &quot;a condition. If a constant is passed as parameter, that &quot;</span>
<span class="gi">+            &quot;condition will be always true. In this case a warning &quot;</span>
<span class="gi">+            &quot;should be emitted.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1506&quot;: (</span>
<span class="gi">+            &quot;threading.Thread needs the target function&quot;,</span>
<span class="gi">+            &quot;bad-thread-instantiation&quot;,</span>
<span class="gi">+            &quot;The warning is emitted when a threading.Thread class &quot;</span>
<span class="gi">+            &quot;is instantiated without the target function being passed as a kwarg or as a second argument. &quot;</span>
<span class="gi">+            &quot;By default, the first parameter is the group param, not the target param.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1507&quot;: (</span>
<span class="gi">+            &quot;Using copy.copy(os.environ). Use os.environ.copy() instead.&quot;,</span>
<span class="gi">+            &quot;shallow-copy-environ&quot;,</span>
<span class="gi">+            &quot;os.environ is not a dict object but proxy object, so &quot;</span>
<span class="gi">+            &quot;shallow copy has still effects on original object. &quot;</span>
<span class="gi">+            &quot;See https://bugs.python.org/issue15373 for reference.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1507&quot;: (</span>
<span class="gi">+            &quot;%s does not support %s type argument&quot;,</span>
<span class="gi">+            &quot;invalid-envvar-value&quot;,</span>
<span class="gi">+            &quot;Env manipulation functions support only string type arguments. &quot;</span>
<span class="gi">+            &quot;See https://docs.python.org/3/library/os.html#os.getenv.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1519&quot;: (</span>
<span class="gi">+            &quot;singledispatch decorator should not be used with methods, &quot;</span>
<span class="gi">+            &quot;use singledispatchmethod instead.&quot;,</span>
<span class="gi">+            &quot;singledispatch-method&quot;,</span>
<span class="gi">+            &quot;singledispatch should decorate functions and not class/instance methods. &quot;</span>
<span class="gi">+            &quot;Use singledispatchmethod for those cases.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1520&quot;: (</span>
<span class="gi">+            &quot;singledispatchmethod decorator should not be used with functions, &quot;</span>
<span class="gi">+            &quot;use singledispatch instead.&quot;,</span>
<span class="gi">+            &quot;singledispatchmethod-function&quot;,</span>
<span class="gi">+            &quot;singledispatchmethod should decorate class/instance methods and not functions. &quot;</span>
<span class="gi">+            &quot;Use singledispatch for those cases.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1508&quot;: (</span>
<span class="gi">+            &quot;%s default type is %s. Expected str or None.&quot;,</span>
<span class="gi">+            &quot;invalid-envvar-default&quot;,</span>
<span class="gi">+            &quot;Env manipulation functions return None or str values. &quot;</span>
<span class="gi">+            &quot;Supplying anything different as a default may cause bugs. &quot;</span>
<span class="gi">+            &quot;See https://docs.python.org/3/library/os.html#os.getenv.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1509&quot;: (</span>
<span class="gi">+            &quot;Using preexec_fn keyword which may be unsafe in the presence &quot;</span>
<span class="gi">+            &quot;of threads&quot;,</span>
<span class="gi">+            &quot;subprocess-popen-preexec-fn&quot;,</span>
<span class="gi">+            &quot;The preexec_fn parameter is not safe to use in the presence &quot;</span>
<span class="gi">+            &quot;of threads in your application. The child process could &quot;</span>
<span class="gi">+            &quot;deadlock before exec is called. If you must use it, keep it &quot;</span>
<span class="gi">+            &quot;trivial! Minimize the number of libraries you call into. &quot;</span>
<span class="gi">+            &quot;See https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1510&quot;: (</span>
<span class="gi">+            &quot;&#39;subprocess.run&#39; used without explicitly defining the value for &#39;check&#39;.&quot;,</span>
<span class="gi">+            &quot;subprocess-run-check&quot;,</span>
<span class="gi">+            &quot;The ``check`` keyword  is set to False by default. It means the process &quot;</span>
<span class="gi">+            &quot;launched by ``subprocess.run`` can exit with a non-zero exit code and &quot;</span>
<span class="gi">+            &quot;fail silently. It&#39;s better to set it explicitly to make clear what the &quot;</span>
<span class="gi">+            &quot;error-handling behavior is.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1514&quot;: (</span>
<span class="gi">+            &quot;Using open without explicitly specifying an encoding&quot;,</span>
<span class="gi">+            &quot;unspecified-encoding&quot;,</span>
<span class="gi">+            &quot;It is better to specify an encoding when opening documents. &quot;</span>
<span class="gi">+            &quot;Using the system default implicitly can create problems on other operating systems. &quot;</span>
<span class="gi">+            &quot;See https://peps.python.org/pep-0597/&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1515&quot;: (</span>
<span class="gi">+            &quot;Leaving functions creating breakpoints in production code is not recommended&quot;,</span>
<span class="gi">+            &quot;forgotten-debug-statement&quot;,</span>
<span class="gi">+            &quot;Calls to breakpoint(), sys.breakpointhook() and pdb.set_trace() should be removed &quot;</span>
<span class="gi">+            &quot;from code that is not actively being debugged.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1518&quot;: (</span>
<span class="gi">+            &quot;&#39;lru_cache(maxsize=None)&#39; or &#39;cache&#39; will keep all method args alive indefinitely, including &#39;self&#39;&quot;,</span>
<span class="gi">+            &quot;method-cache-max-size-none&quot;,</span>
<span class="gi">+            &quot;By decorating a method with lru_cache or cache the &#39;self&#39; argument will be linked to &quot;</span>
<span class="gi">+            &quot;the function and therefore never garbage collected. Unless your instance &quot;</span>
<span class="gi">+            &quot;will never need to be garbage collected (singleton) it is recommended to refactor &quot;</span>
<span class="gi">+            &quot;code to avoid this pattern or add a maxsize to the cache. &quot;</span>
<span class="gi">+            &quot;The default value for maxsize is 128.&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;old_names&quot;: [</span>
<span class="gi">+                    (&quot;W1516&quot;, &quot;lru-cache-decorating-method&quot;),</span>
<span class="gi">+                    (&quot;W1517&quot;, &quot;cache-max-size-none&quot;),</span>
<span class="gi">+                ]</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        BaseChecker.__init__(self, linter)
<span class="w"> </span>        self._deprecated_methods: set[str] = set()
<span class="gd">-        self._deprecated_arguments: dict[str, tuple[tuple[int | None, str],</span>
<span class="gd">-            ...]] = {}</span>
<span class="gi">+        self._deprecated_arguments: dict[str, tuple[tuple[int | None, str], ...]] = {}</span>
<span class="w"> </span>        self._deprecated_classes: dict[str, set[str]] = {}
<span class="w"> </span>        self._deprecated_decorators: set[str] = set()
<span class="w"> </span>        self._deprecated_attributes: set[str] = set()
<span class="gd">-        for since_vers, func_list in DEPRECATED_METHODS[sys.version_info[0]</span>
<span class="gd">-            ].items():</span>
<span class="gi">+</span>
<span class="gi">+        for since_vers, func_list in DEPRECATED_METHODS[sys.version_info[0]].items():</span>
<span class="w"> </span>            if since_vers &lt;= sys.version_info:
<span class="w"> </span>                self._deprecated_methods.update(func_list)
<span class="w"> </span>        for since_vers, args_list in DEPRECATED_ARGUMENTS.items():
<span class="gu">@@ -238,27 +557,374 @@ class StdlibChecker(DeprecatedMixin, BaseChecker):</span>
<span class="w"> </span>        for since_vers, attribute_list in DEPRECATED_ATTRIBUTES.items():
<span class="w"> </span>            if since_vers &lt;= sys.version_info:
<span class="w"> </span>                self._deprecated_attributes.update(attribute_list)
<span class="gi">+        # Modules are checked by the ImportsChecker, because the list is</span>
<span class="gi">+        # synced with the config argument deprecated-modules</span>

<span class="gd">-    @utils.only_required_for_messages(&#39;bad-open-mode&#39;,</span>
<span class="gd">-        &#39;redundant-unittest-assert&#39;, &#39;deprecated-method&#39;,</span>
<span class="gd">-        &#39;deprecated-argument&#39;, &#39;bad-thread-instantiation&#39;,</span>
<span class="gd">-        &#39;shallow-copy-environ&#39;, &#39;invalid-envvar-value&#39;,</span>
<span class="gd">-        &#39;invalid-envvar-default&#39;, &#39;subprocess-popen-preexec-fn&#39;,</span>
<span class="gd">-        &#39;subprocess-run-check&#39;, &#39;deprecated-class&#39;, &#39;unspecified-encoding&#39;,</span>
<span class="gd">-        &#39;forgotten-debug-statement&#39;)</span>
<span class="gd">-    def visit_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    def _check_bad_thread_instantiation(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        func_kwargs = {key.arg for key in node.keywords}</span>
<span class="gi">+        if &quot;target&quot; in func_kwargs:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if len(node.args) &lt; 2 and (not node.kwargs or &quot;target&quot; not in func_kwargs):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;bad-thread-instantiation&quot;, node=node, confidence=interfaces.HIGH</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_for_preexec_fn_in_popen(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if node.keywords:</span>
<span class="gi">+            for keyword in node.keywords:</span>
<span class="gi">+                if keyword.arg == &quot;preexec_fn&quot;:</span>
<span class="gi">+                    self.add_message(&quot;subprocess-popen-preexec-fn&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_for_check_kw_in_run(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        kwargs = {keyword.arg for keyword in (node.keywords or ())}</span>
<span class="gi">+        if &quot;check&quot; not in kwargs:</span>
<span class="gi">+            self.add_message(&quot;subprocess-run-check&quot;, node=node, confidence=INFERENCE)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_shallow_copy_environ(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        confidence = HIGH</span>
<span class="gi">+        try:</span>
<span class="gi">+            arg = utils.get_argument_from_call(node, position=0, keyword=&quot;x&quot;)</span>
<span class="gi">+        except utils.NoSuchArgumentError:</span>
<span class="gi">+            arg = utils.infer_kwarg_from_call(node, keyword=&quot;x&quot;)</span>
<span class="gi">+            if not arg:</span>
<span class="gi">+                return</span>
<span class="gi">+            confidence = INFERENCE</span>
<span class="gi">+        try:</span>
<span class="gi">+            inferred_args = arg.inferred()</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+        for inferred in inferred_args:</span>
<span class="gi">+            if inferred.qname() == OS_ENVIRON:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;shallow-copy-environ&quot;, node=node, confidence=confidence</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;bad-open-mode&quot;,</span>
<span class="gi">+        &quot;redundant-unittest-assert&quot;,</span>
<span class="gi">+        &quot;deprecated-method&quot;,</span>
<span class="gi">+        &quot;deprecated-argument&quot;,</span>
<span class="gi">+        &quot;bad-thread-instantiation&quot;,</span>
<span class="gi">+        &quot;shallow-copy-environ&quot;,</span>
<span class="gi">+        &quot;invalid-envvar-value&quot;,</span>
<span class="gi">+        &quot;invalid-envvar-default&quot;,</span>
<span class="gi">+        &quot;subprocess-popen-preexec-fn&quot;,</span>
<span class="gi">+        &quot;subprocess-run-check&quot;,</span>
<span class="gi">+        &quot;deprecated-class&quot;,</span>
<span class="gi">+        &quot;unspecified-encoding&quot;,</span>
<span class="gi">+        &quot;forgotten-debug-statement&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit a Call node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.check_deprecated_class_in_call(node)</span>
<span class="gi">+        for inferred in utils.infer_all(node.func):</span>
<span class="gi">+            if isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if inferred.root().name in OPEN_MODULE:</span>
<span class="gi">+                open_func_name: str | None = None</span>
<span class="gi">+                if isinstance(node.func, nodes.Name):</span>
<span class="gi">+                    open_func_name = node.func.name</span>
<span class="gi">+                if isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+                    open_func_name = node.func.attrname</span>
<span class="gi">+                if open_func_name in OPEN_FILES_FUNCS:</span>
<span class="gi">+                    self._check_open_call(node, inferred.root().name, open_func_name)</span>
<span class="gi">+            elif inferred.root().name == UNITTEST_CASE:</span>
<span class="gi">+                self._check_redundant_assert(node, inferred)</span>
<span class="gi">+            elif isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+                if inferred.qname() == THREADING_THREAD:</span>
<span class="gi">+                    self._check_bad_thread_instantiation(node)</span>
<span class="gi">+                elif inferred.qname() == SUBPROCESS_POPEN:</span>
<span class="gi">+                    self._check_for_preexec_fn_in_popen(node)</span>
<span class="gi">+            elif isinstance(inferred, nodes.FunctionDef):</span>
<span class="gi">+                name = inferred.qname()</span>
<span class="gi">+                if name == COPY_COPY:</span>
<span class="gi">+                    self._check_shallow_copy_environ(node)</span>
<span class="gi">+                elif name in ENV_GETTERS:</span>
<span class="gi">+                    self._check_env_function(node, inferred)</span>
<span class="gi">+                elif name == SUBPROCESS_RUN:</span>
<span class="gi">+                    self._check_for_check_kw_in_run(node)</span>
<span class="gi">+                elif name in DEBUG_BREAKPOINTS:</span>
<span class="gi">+                    self.add_message(&quot;forgotten-debug-statement&quot;, node=node)</span>
<span class="gi">+            self.check_deprecated_method(node, inferred)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;boolean-datetime&quot;)</span>
<span class="gi">+    def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:</span>
<span class="gi">+        if node.op == &quot;not&quot;:</span>
<span class="gi">+            self._check_datetime(node.operand)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;boolean-datetime&quot;)</span>
<span class="gi">+    def visit_if(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        self._check_datetime(node.test)</span>

<span class="gd">-    def _check_lru_cache_decorators(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;boolean-datetime&quot;)</span>
<span class="gi">+    def visit_ifexp(self, node: nodes.IfExp) -&gt; None:</span>
<span class="gi">+        self._check_datetime(node.test)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;boolean-datetime&quot;)</span>
<span class="gi">+    def visit_boolop(self, node: nodes.BoolOp) -&gt; None:</span>
<span class="gi">+        for value in node.values:</span>
<span class="gi">+            self._check_datetime(value)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;method-cache-max-size-none&quot;,</span>
<span class="gi">+        &quot;singledispatch-method&quot;,</span>
<span class="gi">+        &quot;singledispatchmethod-function&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        if node.decorators:</span>
<span class="gi">+            if isinstance(node.parent, nodes.ClassDef):</span>
<span class="gi">+                self._check_lru_cache_decorators(node)</span>
<span class="gi">+            self._check_dispatch_decorators(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_lru_cache_decorators(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if instance methods are decorated with functools.lru_cache.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if any(utils.is_enum(ancestor) for ancestor in node.parent.ancestors()):</span>
<span class="gi">+            # method of class inheriting from Enum is exempt from this check.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        lru_cache_nodes: list[nodes.NodeNG] = []</span>
<span class="gi">+        for d_node in node.decorators.nodes:</span>
<span class="gi">+            # pylint: disable = too-many-try-statements</span>
<span class="gi">+            try:</span>
<span class="gi">+                for infered_node in d_node.infer():</span>
<span class="gi">+                    q_name = infered_node.qname()</span>
<span class="gi">+                    if q_name in NON_INSTANCE_METHODS:</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+                    # Check if there is a maxsize argument set to None in the call</span>
<span class="gi">+                    if q_name in LRU_CACHE and isinstance(d_node, nodes.Call):</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            arg = utils.get_argument_from_call(</span>
<span class="gi">+                                d_node, position=0, keyword=&quot;maxsize&quot;</span>
<span class="gi">+                            )</span>
<span class="gi">+                        except utils.NoSuchArgumentError:</span>
<span class="gi">+                            arg = utils.infer_kwarg_from_call(d_node, &quot;maxsize&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                        if not isinstance(arg, nodes.Const) or arg.value is not None:</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+                        lru_cache_nodes.append(d_node)</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+                    if q_name == &quot;functools.cache&quot;:</span>
<span class="gi">+                        lru_cache_nodes.append(d_node)</span>
<span class="gi">+                        break</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        for lru_cache_node in lru_cache_nodes:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;method-cache-max-size-none&quot;,</span>
<span class="gi">+                node=lru_cache_node,</span>
<span class="gi">+                confidence=interfaces.INFERENCE,</span>
<span class="gi">+            )</span>

<span class="gd">-    def _check_datetime(self, node: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+    def _check_dispatch_decorators(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        decorators_map: dict[str, tuple[nodes.NodeNG, interfaces.Confidence]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        for decorator in node.decorators.nodes:</span>
<span class="gi">+            if isinstance(decorator, nodes.Name) and decorator.name:</span>
<span class="gi">+                decorators_map[decorator.name] = (decorator, interfaces.HIGH)</span>
<span class="gi">+            elif utils.is_registered_in_singledispatch_function(node):</span>
<span class="gi">+                decorators_map[&quot;singledispatch&quot;] = (decorator, interfaces.INFERENCE)</span>
<span class="gi">+            elif utils.is_registered_in_singledispatchmethod_function(node):</span>
<span class="gi">+                decorators_map[&quot;singledispatchmethod&quot;] = (</span>
<span class="gi">+                    decorator,</span>
<span class="gi">+                    interfaces.INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if node.is_method():</span>
<span class="gi">+            if &quot;singledispatch&quot; in decorators_map:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;singledispatch-method&quot;,</span>
<span class="gi">+                    node=decorators_map[&quot;singledispatch&quot;][0],</span>
<span class="gi">+                    confidence=decorators_map[&quot;singledispatch&quot;][1],</span>
<span class="gi">+                )</span>
<span class="gi">+        elif &quot;singledispatchmethod&quot; in decorators_map:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;singledispatchmethod-function&quot;,</span>
<span class="gi">+                node=decorators_map[&quot;singledispatchmethod&quot;][0],</span>
<span class="gi">+                confidence=decorators_map[&quot;singledispatchmethod&quot;][1],</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_redundant_assert(self, node: nodes.Call, infer: InferenceResult) -&gt; None:</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(infer, astroid.BoundMethod)</span>
<span class="gi">+            and node.args</span>
<span class="gi">+            and isinstance(node.args[0], nodes.Const)</span>
<span class="gi">+            and infer.name in {&quot;assertTrue&quot;, &quot;assertFalse&quot;}</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;redundant-unittest-assert&quot;,</span>
<span class="gi">+                args=(infer.name, node.args[0].value),</span>
<span class="gi">+                node=node,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_datetime(self, node: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that a datetime was inferred, if so, emit boolean-datetime warning.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            inferred = next(node.infer())</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(inferred, astroid.Instance) and inferred.qname() in {</span>
<span class="gi">+            &quot;_pydatetime.time&quot;,</span>
<span class="gi">+            &quot;datetime.time&quot;,</span>
<span class="gi">+        }:</span>
<span class="gi">+            self.add_message(&quot;boolean-datetime&quot;, node=node)</span>

<span class="gd">-    def _check_open_call(self, node: nodes.Call, open_module: str,</span>
<span class="gd">-        func_name: str) -&gt;None:</span>
<span class="gi">+    def _check_open_call(</span>
<span class="gi">+        self, node: nodes.Call, open_module: str, func_name: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Various checks for an open call.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mode_arg = None</span>
<span class="gi">+        confidence = HIGH</span>
<span class="gi">+        try:</span>
<span class="gi">+            if open_module == &quot;_io&quot;:</span>
<span class="gi">+                mode_arg = utils.get_argument_from_call(</span>
<span class="gi">+                    node, position=1, keyword=&quot;mode&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            elif open_module == &quot;pathlib&quot;:</span>
<span class="gi">+                mode_arg = utils.get_argument_from_call(</span>
<span class="gi">+                    node, position=0, keyword=&quot;mode&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        except utils.NoSuchArgumentError:</span>
<span class="gi">+            mode_arg = utils.infer_kwarg_from_call(node, keyword=&quot;mode&quot;)</span>
<span class="gi">+            if mode_arg:</span>
<span class="gi">+                confidence = INFERENCE</span>
<span class="gi">+</span>
<span class="gi">+        if mode_arg:</span>
<span class="gi">+            mode_arg = utils.safe_infer(mode_arg)</span>
<span class="gi">+            if (</span>
<span class="gi">+                func_name in OPEN_FILES_MODE</span>
<span class="gi">+                and isinstance(mode_arg, nodes.Const)</span>
<span class="gi">+                and not _check_mode_str(mode_arg.value)</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;bad-open-mode&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=mode_arg.value or str(mode_arg.value),</span>
<span class="gi">+                    confidence=confidence,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            not mode_arg</span>
<span class="gi">+            or isinstance(mode_arg, nodes.Const)</span>
<span class="gi">+            and (not mode_arg.value or &quot;b&quot; not in str(mode_arg.value))</span>
<span class="gi">+        ):</span>
<span class="gi">+            confidence = HIGH</span>
<span class="gi">+            try:</span>
<span class="gi">+                if open_module == &quot;pathlib&quot;:</span>
<span class="gi">+                    if node.func.attrname == &quot;read_text&quot;:</span>
<span class="gi">+                        encoding_arg = utils.get_argument_from_call(</span>
<span class="gi">+                            node, position=0, keyword=&quot;encoding&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    elif node.func.attrname == &quot;write_text&quot;:</span>
<span class="gi">+                        encoding_arg = utils.get_argument_from_call(</span>
<span class="gi">+                            node, position=1, keyword=&quot;encoding&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        encoding_arg = utils.get_argument_from_call(</span>
<span class="gi">+                            node, position=2, keyword=&quot;encoding&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    encoding_arg = utils.get_argument_from_call(</span>
<span class="gi">+                        node, position=3, keyword=&quot;encoding&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+            except utils.NoSuchArgumentError:</span>
<span class="gi">+                encoding_arg = utils.infer_kwarg_from_call(node, keyword=&quot;encoding&quot;)</span>
<span class="gi">+                if encoding_arg:</span>
<span class="gi">+                    confidence = INFERENCE</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;unspecified-encoding&quot;, node=node, confidence=confidence</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            if encoding_arg:</span>
<span class="gi">+                encoding_arg = utils.safe_infer(encoding_arg)</span>
<span class="gi">+</span>
<span class="gi">+                if isinstance(encoding_arg, nodes.Const) and encoding_arg.value is None:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;unspecified-encoding&quot;, node=node, confidence=confidence</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_env_function(self, node: nodes.Call, infer: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        env_name_kwarg = &quot;key&quot;</span>
<span class="gi">+        env_value_kwarg = &quot;default&quot;</span>
<span class="gi">+        if node.keywords:</span>
<span class="gi">+            kwargs = {keyword.arg: keyword.value for keyword in node.keywords}</span>
<span class="gi">+        else:</span>
<span class="gi">+            kwargs = None</span>
<span class="gi">+        if node.args:</span>
<span class="gi">+            env_name_arg = node.args[0]</span>
<span class="gi">+        elif kwargs and env_name_kwarg in kwargs:</span>
<span class="gi">+            env_name_arg = kwargs[env_name_kwarg]</span>
<span class="gi">+        else:</span>
<span class="gi">+            env_name_arg = None</span>
<span class="gi">+</span>
<span class="gi">+        if env_name_arg:</span>
<span class="gi">+            self._check_invalid_envvar_value(</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                message=&quot;invalid-envvar-value&quot;,</span>
<span class="gi">+                call_arg=utils.safe_infer(env_name_arg),</span>
<span class="gi">+                infer=infer,</span>
<span class="gi">+                allow_none=False,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if len(node.args) == 2:</span>
<span class="gi">+            env_value_arg = node.args[1]</span>
<span class="gi">+        elif kwargs and env_value_kwarg in kwargs:</span>
<span class="gi">+            env_value_arg = kwargs[env_value_kwarg]</span>
<span class="gi">+        else:</span>
<span class="gi">+            env_value_arg = None</span>
<span class="gi">+</span>
<span class="gi">+        if env_value_arg:</span>
<span class="gi">+            self._check_invalid_envvar_value(</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                infer=infer,</span>
<span class="gi">+                message=&quot;invalid-envvar-default&quot;,</span>
<span class="gi">+                call_arg=utils.safe_infer(env_value_arg),</span>
<span class="gi">+                allow_none=True,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_invalid_envvar_value(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Call,</span>
<span class="gi">+        infer: nodes.FunctionDef,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        call_arg: InferenceResult | None,</span>
<span class="gi">+        allow_none: bool,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if call_arg is None or isinstance(call_arg, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        name = infer.qname()</span>
<span class="gi">+        if isinstance(call_arg, nodes.Const):</span>
<span class="gi">+            emit = False</span>
<span class="gi">+            if call_arg.value is None:</span>
<span class="gi">+                emit = not allow_none</span>
<span class="gi">+            elif not isinstance(call_arg.value, str):</span>
<span class="gi">+                emit = True</span>
<span class="gi">+            if emit:</span>
<span class="gi">+                self.add_message(message, node=node, args=(name, call_arg.pytype()))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_message(message, node=node, args=(name, call_arg.pytype()))</span>
<span class="gi">+</span>
<span class="gi">+    def deprecated_methods(self) -&gt; set[str]:</span>
<span class="gi">+        return self._deprecated_methods</span>
<span class="gi">+</span>
<span class="gi">+    def deprecated_arguments(self, method: str) -&gt; tuple[tuple[int | None, str], ...]:</span>
<span class="gi">+        return self._deprecated_arguments.get(method, ())</span>
<span class="gi">+</span>
<span class="gi">+    def deprecated_classes(self, module: str) -&gt; Iterable[str]:</span>
<span class="gi">+        return self._deprecated_classes.get(module, ())</span>
<span class="gi">+</span>
<span class="gi">+    def deprecated_decorators(self) -&gt; Iterable[str]:</span>
<span class="gi">+        return self._deprecated_decorators</span>
<span class="gi">+</span>
<span class="gi">+    def deprecated_attributes(self) -&gt; Iterable[str]:</span>
<span class="gi">+        return self._deprecated_attributes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(StdlibChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/strings.py b/pylint/checkers/strings.py</span>
<span class="gh">index bb0cd648f..90493fa00 100644</span>
<span class="gd">--- a/pylint/checkers/strings.py</span>
<span class="gi">+++ b/pylint/checkers/strings.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checker for string formatting operations.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="gu">@@ -7,164 +13,817 @@ import tokenize</span>
<span class="w"> </span>from collections import Counter
<span class="w"> </span>from collections.abc import Iterable, Sequence
<span class="w"> </span>from typing import TYPE_CHECKING, Literal
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import bases, nodes, util
<span class="w"> </span>from astroid.typing import SuccessfulInferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, BaseRawFileChecker, BaseTokenChecker, utils
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-_AST_NODE_STR_TYPES = &#39;__builtin__.unicode&#39;, &#39;__builtin__.str&#39;, &#39;builtins.str&#39;</span>
<span class="gd">-_PREFIXES = {&#39;r&#39;, &#39;u&#39;, &#39;R&#39;, &#39;U&#39;, &#39;f&#39;, &#39;F&#39;, &#39;fr&#39;, &#39;Fr&#39;, &#39;fR&#39;, &#39;FR&#39;, &#39;rf&#39;,</span>
<span class="gd">-    &#39;rF&#39;, &#39;Rf&#39;, &#39;RF&#39;, &#39;b&#39;, &#39;B&#39;, &#39;br&#39;, &#39;Br&#39;, &#39;bR&#39;, &#39;BR&#39;, &#39;rb&#39;, &#39;rB&#39;, &#39;Rb&#39;, &#39;RB&#39;}</span>
<span class="gd">-_PAREN_IGNORE_TOKEN_TYPES = tokenize.NEWLINE, tokenize.NL, tokenize.COMMENT</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_AST_NODE_STR_TYPES = (&quot;__builtin__.unicode&quot;, &quot;__builtin__.str&quot;, &quot;builtins.str&quot;)</span>
<span class="gi">+# Prefixes for both strings and bytes literals per</span>
<span class="gi">+# https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals</span>
<span class="gi">+_PREFIXES = {</span>
<span class="gi">+    &quot;r&quot;,</span>
<span class="gi">+    &quot;u&quot;,</span>
<span class="gi">+    &quot;R&quot;,</span>
<span class="gi">+    &quot;U&quot;,</span>
<span class="gi">+    &quot;f&quot;,</span>
<span class="gi">+    &quot;F&quot;,</span>
<span class="gi">+    &quot;fr&quot;,</span>
<span class="gi">+    &quot;Fr&quot;,</span>
<span class="gi">+    &quot;fR&quot;,</span>
<span class="gi">+    &quot;FR&quot;,</span>
<span class="gi">+    &quot;rf&quot;,</span>
<span class="gi">+    &quot;rF&quot;,</span>
<span class="gi">+    &quot;Rf&quot;,</span>
<span class="gi">+    &quot;RF&quot;,</span>
<span class="gi">+    &quot;b&quot;,</span>
<span class="gi">+    &quot;B&quot;,</span>
<span class="gi">+    &quot;br&quot;,</span>
<span class="gi">+    &quot;Br&quot;,</span>
<span class="gi">+    &quot;bR&quot;,</span>
<span class="gi">+    &quot;BR&quot;,</span>
<span class="gi">+    &quot;rb&quot;,</span>
<span class="gi">+    &quot;rB&quot;,</span>
<span class="gi">+    &quot;Rb&quot;,</span>
<span class="gi">+    &quot;RB&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+_PAREN_IGNORE_TOKEN_TYPES = (</span>
<span class="gi">+    tokenize.NEWLINE,</span>
<span class="gi">+    tokenize.NL,</span>
<span class="gi">+    tokenize.COMMENT,</span>
<span class="gi">+)</span>
<span class="w"> </span>SINGLE_QUOTED_REGEX = re.compile(f&quot;({&#39;|&#39;.join(_PREFIXES)})?&#39;&#39;&#39;&quot;)
<span class="gd">-DOUBLE_QUOTED_REGEX = re.compile(f&#39;({\&#39;|\&#39;.join(_PREFIXES)})?&quot;&quot;&quot;&#39;)</span>
<span class="gd">-QUOTE_DELIMITER_REGEX = re.compile(f&#39;({\&#39;|\&#39;.join(_PREFIXES)})?(&quot;|\&#39;)&#39;, re.</span>
<span class="gd">-    DOTALL)</span>
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;E1300&#39;: (</span>
<span class="gd">-    &#39;Unsupported format character %r (%#02x) at index %d&#39;,</span>
<span class="gd">-    &#39;bad-format-character&#39;,</span>
<span class="gd">-    &#39;Used when an unsupported format character is used in a format string.&#39;</span>
<span class="gd">-    ), &#39;E1301&#39;: (&#39;Format string ends in middle of conversion specifier&#39;,</span>
<span class="gd">-    &#39;truncated-format-string&#39;,</span>
<span class="gd">-    &#39;Used when a format string terminates before the end of a conversion specifier.&#39;</span>
<span class="gd">-    ), &#39;E1302&#39;: (</span>
<span class="gd">-    &#39;Mixing named and unnamed conversion specifiers in format string&#39;,</span>
<span class="gd">-    &#39;mixed-format-string&#39;,</span>
<span class="gd">-    &quot;Used when a format string contains both named (e.g. &#39;%(foo)d&#39;) and unnamed (e.g. &#39;%d&#39;) conversion specifiers.  This is also used when a named conversion specifier contains * for the minimum field width and/or precision.&quot;</span>
<span class="gd">-    ), &#39;E1303&#39;: (&#39;Expected mapping for format string, not %s&#39;,</span>
<span class="gd">-    &#39;format-needs-mapping&#39;,</span>
<span class="gd">-    &#39;Used when a format string that uses named conversion specifiers is used with an argument that is not a mapping.&#39;</span>
<span class="gd">-    ), &#39;W1300&#39;: (&#39;Format string dictionary key should be a string, not %s&#39;,</span>
<span class="gd">-    &#39;bad-format-string-key&#39;,</span>
<span class="gd">-    &#39;Used when a format string that uses named conversion specifiers is used with a dictionary whose keys are not all strings.&#39;</span>
<span class="gd">-    ), &#39;W1301&#39;: (&#39;Unused key %r in format string dictionary&#39;,</span>
<span class="gd">-    &#39;unused-format-string-key&#39;,</span>
<span class="gd">-    &#39;Used when a format string that uses named conversion specifiers is used with a dictionary that contains keys not required by the format string.&#39;</span>
<span class="gd">-    ), &#39;E1304&#39;: (&#39;Missing key %r in format string dictionary&#39;,</span>
<span class="gd">-    &#39;missing-format-string-key&#39;,</span>
<span class="gd">-    &quot;Used when a format string that uses named conversion specifiers is used with a dictionary that doesn&#39;t contain all the keys required by the format string.&quot;</span>
<span class="gd">-    ), &#39;E1305&#39;: (&#39;Too many arguments for format string&#39;,</span>
<span class="gd">-    &#39;too-many-format-args&#39;,</span>
<span class="gd">-    &#39;Used when a format string that uses unnamed conversion specifiers is given too many arguments.&#39;</span>
<span class="gd">-    ), &#39;E1306&#39;: (&#39;Not enough arguments for format string&#39;,</span>
<span class="gd">-    &#39;too-few-format-args&#39;,</span>
<span class="gd">-    &#39;Used when a format string that uses unnamed conversion specifiers is given too few arguments&#39;</span>
<span class="gd">-    ), &#39;E1307&#39;: (&#39;Argument %r does not match format type %r&#39;,</span>
<span class="gd">-    &#39;bad-string-format-type&#39;,</span>
<span class="gd">-    &#39;Used when a type required by format string is not suitable for actual argument type&#39;</span>
<span class="gd">-    ), &#39;E1310&#39;: (&#39;Suspicious argument in %s.%s call&#39;, &#39;bad-str-strip-call&#39;,</span>
<span class="gd">-    &#39;The argument to a str.{l,r,}strip call contains a duplicate character,&#39;</span>
<span class="gd">-    ), &#39;W1302&#39;: (&#39;Invalid format string&#39;, &#39;bad-format-string&#39;,</span>
<span class="gd">-    &#39;Used when a PEP 3101 format string is invalid.&#39;), &#39;W1303&#39;: (</span>
<span class="gd">-    &#39;Missing keyword argument %r for format string&#39;,</span>
<span class="gd">-    &#39;missing-format-argument-key&#39;,</span>
<span class="gd">-    &quot;Used when a PEP 3101 format string that uses named fields doesn&#39;t receive one or more required keywords.&quot;</span>
<span class="gd">-    ), &#39;W1304&#39;: (&#39;Unused format argument %r&#39;,</span>
<span class="gd">-    &#39;unused-format-string-argument&#39;,</span>
<span class="gd">-    &#39;Used when a PEP 3101 format string that uses named fields is used with an argument that is not required by the format string.&#39;</span>
<span class="gd">-    ), &#39;W1305&#39;: (</span>
<span class="gd">-    &#39;Format string contains both automatic field numbering and manual field specification&#39;</span>
<span class="gd">-    , &#39;format-combined-specification&#39;,</span>
<span class="gd">-    &quot;Used when a PEP 3101 format string contains both automatic field numbering (e.g. &#39;{}&#39;) and manual field specification (e.g. &#39;{0}&#39;).&quot;</span>
<span class="gd">-    ), &#39;W1306&#39;: (&#39;Missing format attribute %r in format specifier %r&#39;,</span>
<span class="gd">-    &#39;missing-format-attribute&#39;,</span>
<span class="gd">-    &quot;Used when a PEP 3101 format string uses an attribute specifier ({0.length}), but the argument passed for formatting doesn&#39;t have that attribute.&quot;</span>
<span class="gd">-    ), &#39;W1307&#39;: (&#39;Using invalid lookup key %r in format specifier %r&#39;,</span>
<span class="gd">-    &#39;invalid-format-index&#39;,</span>
<span class="gd">-    &quot;Used when a PEP 3101 format string uses a lookup specifier ({a[1]}), but the argument passed for formatting doesn&#39;t contain or doesn&#39;t have that key as an attribute.&quot;</span>
<span class="gd">-    ), &#39;W1308&#39;: (</span>
<span class="gd">-    &#39;Duplicate string formatting argument %r, consider passing as named argument&#39;</span>
<span class="gd">-    , &#39;duplicate-string-formatting-argument&#39;,</span>
<span class="gd">-    &#39;Used when we detect that a string formatting is repeating an argument instead of using named string arguments&#39;</span>
<span class="gd">-    ), &#39;W1309&#39;: (</span>
<span class="gd">-    &#39;Using an f-string that does not have any interpolated variables&#39;,</span>
<span class="gd">-    &#39;f-string-without-interpolation&#39;,</span>
<span class="gd">-    &#39;Used when we detect an f-string that does not use any interpolation variables, in which case it can be either a normal string or a bug in the code.&#39;</span>
<span class="gd">-    ), &#39;W1310&#39;: (</span>
<span class="gd">-    &#39;Using formatting for a string that does not have any interpolated variables&#39;</span>
<span class="gd">-    , &#39;format-string-without-interpolation&#39;,</span>
<span class="gd">-    &#39;Used when we detect a string that does not have any interpolation variables, in which case it can be either a normal string without formatting or a bug in the code.&#39;</span>
<span class="gd">-    )}</span>
<span class="gd">-OTHER_NODES = (nodes.Const, nodes.List, nodes.Lambda, nodes.FunctionDef,</span>
<span class="gd">-    nodes.ListComp, nodes.SetComp, nodes.GeneratorExp)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_access_path(key: (str | Literal[0]), parts: list[tuple[bool, str]]</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+DOUBLE_QUOTED_REGEX = re.compile(f&quot;({&#39;|&#39;.join(_PREFIXES)})?\&quot;\&quot;\&quot;&quot;)</span>
<span class="gi">+QUOTE_DELIMITER_REGEX = re.compile(f&quot;({&#39;|&#39;.join(_PREFIXES)})?(\&quot;|&#39;)&quot;, re.DOTALL)</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = (</span>
<span class="gi">+    {  # pylint: disable=consider-using-namedtuple-or-dataclass</span>
<span class="gi">+        &quot;E1300&quot;: (</span>
<span class="gi">+            &quot;Unsupported format character %r (%#02x) at index %d&quot;,</span>
<span class="gi">+            &quot;bad-format-character&quot;,</span>
<span class="gi">+            &quot;Used when an unsupported format character is used in a format string.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1301&quot;: (</span>
<span class="gi">+            &quot;Format string ends in middle of conversion specifier&quot;,</span>
<span class="gi">+            &quot;truncated-format-string&quot;,</span>
<span class="gi">+            &quot;Used when a format string terminates before the end of a &quot;</span>
<span class="gi">+            &quot;conversion specifier.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1302&quot;: (</span>
<span class="gi">+            &quot;Mixing named and unnamed conversion specifiers in format string&quot;,</span>
<span class="gi">+            &quot;mixed-format-string&quot;,</span>
<span class="gi">+            &quot;Used when a format string contains both named (e.g. &#39;%(foo)d&#39;) &quot;</span>
<span class="gi">+            &quot;and unnamed (e.g. &#39;%d&#39;) conversion specifiers.  This is also &quot;</span>
<span class="gi">+            &quot;used when a named conversion specifier contains * for the &quot;</span>
<span class="gi">+            &quot;minimum field width and/or precision.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1303&quot;: (</span>
<span class="gi">+            &quot;Expected mapping for format string, not %s&quot;,</span>
<span class="gi">+            &quot;format-needs-mapping&quot;,</span>
<span class="gi">+            &quot;Used when a format string that uses named conversion specifiers &quot;</span>
<span class="gi">+            &quot;is used with an argument that is not a mapping.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1300&quot;: (</span>
<span class="gi">+            &quot;Format string dictionary key should be a string, not %s&quot;,</span>
<span class="gi">+            &quot;bad-format-string-key&quot;,</span>
<span class="gi">+            &quot;Used when a format string that uses named conversion specifiers &quot;</span>
<span class="gi">+            &quot;is used with a dictionary whose keys are not all strings.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1301&quot;: (</span>
<span class="gi">+            &quot;Unused key %r in format string dictionary&quot;,</span>
<span class="gi">+            &quot;unused-format-string-key&quot;,</span>
<span class="gi">+            &quot;Used when a format string that uses named conversion specifiers &quot;</span>
<span class="gi">+            &quot;is used with a dictionary that contains keys not required by the &quot;</span>
<span class="gi">+            &quot;format string.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1304&quot;: (</span>
<span class="gi">+            &quot;Missing key %r in format string dictionary&quot;,</span>
<span class="gi">+            &quot;missing-format-string-key&quot;,</span>
<span class="gi">+            &quot;Used when a format string that uses named conversion specifiers &quot;</span>
<span class="gi">+            &quot;is used with a dictionary that doesn&#39;t contain all the keys &quot;</span>
<span class="gi">+            &quot;required by the format string.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1305&quot;: (</span>
<span class="gi">+            &quot;Too many arguments for format string&quot;,</span>
<span class="gi">+            &quot;too-many-format-args&quot;,</span>
<span class="gi">+            &quot;Used when a format string that uses unnamed conversion &quot;</span>
<span class="gi">+            &quot;specifiers is given too many arguments.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1306&quot;: (</span>
<span class="gi">+            &quot;Not enough arguments for format string&quot;,</span>
<span class="gi">+            &quot;too-few-format-args&quot;,</span>
<span class="gi">+            &quot;Used when a format string that uses unnamed conversion &quot;</span>
<span class="gi">+            &quot;specifiers is given too few arguments&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1307&quot;: (</span>
<span class="gi">+            &quot;Argument %r does not match format type %r&quot;,</span>
<span class="gi">+            &quot;bad-string-format-type&quot;,</span>
<span class="gi">+            &quot;Used when a type required by format string &quot;</span>
<span class="gi">+            &quot;is not suitable for actual argument type&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1310&quot;: (</span>
<span class="gi">+            &quot;Suspicious argument in %s.%s call&quot;,</span>
<span class="gi">+            &quot;bad-str-strip-call&quot;,</span>
<span class="gi">+            &quot;The argument to a str.{l,r,}strip call contains a duplicate character,&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1302&quot;: (</span>
<span class="gi">+            &quot;Invalid format string&quot;,</span>
<span class="gi">+            &quot;bad-format-string&quot;,</span>
<span class="gi">+            &quot;Used when a PEP 3101 format string is invalid.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1303&quot;: (</span>
<span class="gi">+            &quot;Missing keyword argument %r for format string&quot;,</span>
<span class="gi">+            &quot;missing-format-argument-key&quot;,</span>
<span class="gi">+            &quot;Used when a PEP 3101 format string that uses named fields &quot;</span>
<span class="gi">+            &quot;doesn&#39;t receive one or more required keywords.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1304&quot;: (</span>
<span class="gi">+            &quot;Unused format argument %r&quot;,</span>
<span class="gi">+            &quot;unused-format-string-argument&quot;,</span>
<span class="gi">+            &quot;Used when a PEP 3101 format string that uses named &quot;</span>
<span class="gi">+            &quot;fields is used with an argument that &quot;</span>
<span class="gi">+            &quot;is not required by the format string.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1305&quot;: (</span>
<span class="gi">+            &quot;Format string contains both automatic field numbering &quot;</span>
<span class="gi">+            &quot;and manual field specification&quot;,</span>
<span class="gi">+            &quot;format-combined-specification&quot;,</span>
<span class="gi">+            &quot;Used when a PEP 3101 format string contains both automatic &quot;</span>
<span class="gi">+            &quot;field numbering (e.g. &#39;{}&#39;) and manual field &quot;</span>
<span class="gi">+            &quot;specification (e.g. &#39;{0}&#39;).&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1306&quot;: (</span>
<span class="gi">+            &quot;Missing format attribute %r in format specifier %r&quot;,</span>
<span class="gi">+            &quot;missing-format-attribute&quot;,</span>
<span class="gi">+            &quot;Used when a PEP 3101 format string uses an &quot;</span>
<span class="gi">+            &quot;attribute specifier ({0.length}), but the argument &quot;</span>
<span class="gi">+            &quot;passed for formatting doesn&#39;t have that attribute.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1307&quot;: (</span>
<span class="gi">+            &quot;Using invalid lookup key %r in format specifier %r&quot;,</span>
<span class="gi">+            &quot;invalid-format-index&quot;,</span>
<span class="gi">+            &quot;Used when a PEP 3101 format string uses a lookup specifier &quot;</span>
<span class="gi">+            &quot;({a[1]}), but the argument passed for formatting &quot;</span>
<span class="gi">+            &quot;doesn&#39;t contain or doesn&#39;t have that key as an attribute.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1308&quot;: (</span>
<span class="gi">+            &quot;Duplicate string formatting argument %r, consider passing as named argument&quot;,</span>
<span class="gi">+            &quot;duplicate-string-formatting-argument&quot;,</span>
<span class="gi">+            &quot;Used when we detect that a string formatting is &quot;</span>
<span class="gi">+            &quot;repeating an argument instead of using named string arguments&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1309&quot;: (</span>
<span class="gi">+            &quot;Using an f-string that does not have any interpolated variables&quot;,</span>
<span class="gi">+            &quot;f-string-without-interpolation&quot;,</span>
<span class="gi">+            &quot;Used when we detect an f-string that does not use any interpolation variables, &quot;</span>
<span class="gi">+            &quot;in which case it can be either a normal string or a bug in the code.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1310&quot;: (</span>
<span class="gi">+            &quot;Using formatting for a string that does not have any interpolated variables&quot;,</span>
<span class="gi">+            &quot;format-string-without-interpolation&quot;,</span>
<span class="gi">+            &quot;Used when we detect a string that does not have any interpolation variables, &quot;</span>
<span class="gi">+            &quot;in which case it can be either a normal string without formatting or a bug in the code.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+OTHER_NODES = (</span>
<span class="gi">+    nodes.Const,</span>
<span class="gi">+    nodes.List,</span>
<span class="gi">+    nodes.Lambda,</span>
<span class="gi">+    nodes.FunctionDef,</span>
<span class="gi">+    nodes.ListComp,</span>
<span class="gi">+    nodes.SetComp,</span>
<span class="gi">+    nodes.GeneratorExp,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_access_path(key: str | Literal[0], parts: list[tuple[bool, str]]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a list of format specifiers, returns
<span class="w"> </span>    the final access path (e.g. a.b.c[0][1]).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    path = []</span>
<span class="gi">+    for is_attribute, specifier in parts:</span>
<span class="gi">+        if is_attribute:</span>
<span class="gi">+            path.append(f&quot;.{specifier}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            path.append(f&quot;[{specifier!r}]&quot;)</span>
<span class="gi">+    return str(key) + &quot;&quot;.join(path)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def arg_matches_format_type(</span>
<span class="gi">+    arg_type: SuccessfulInferenceResult, format_type: str</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    if format_type in &quot;sr&quot;:</span>
<span class="gi">+        # All types can be printed with %s and %r</span>
<span class="gi">+        return True</span>
<span class="gi">+    if isinstance(arg_type, astroid.Instance):</span>
<span class="gi">+        arg_type = arg_type.pytype()</span>
<span class="gi">+        if arg_type == &quot;builtins.str&quot;:</span>
<span class="gi">+            return format_type == &quot;c&quot;</span>
<span class="gi">+        if arg_type == &quot;builtins.float&quot;:</span>
<span class="gi">+            return format_type in &quot;deEfFgGn%&quot;</span>
<span class="gi">+        if arg_type == &quot;builtins.int&quot;:</span>
<span class="gi">+            # Integers allow all types</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>class StringFormatChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks string formatting operations to ensure that the format string
<span class="w"> </span>    is valid and the arguments match the format string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;string&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;string&quot;</span>
<span class="w"> </span>    msgs = MSGS

<span class="gd">-    def _check_new_format(self, node: nodes.Call, func: bases.BoundMethod</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    # pylint: disable = too-many-branches, too-many-locals, too-many-statements</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;bad-format-character&quot;,</span>
<span class="gi">+        &quot;truncated-format-string&quot;,</span>
<span class="gi">+        &quot;mixed-format-string&quot;,</span>
<span class="gi">+        &quot;bad-format-string-key&quot;,</span>
<span class="gi">+        &quot;missing-format-string-key&quot;,</span>
<span class="gi">+        &quot;unused-format-string-key&quot;,</span>
<span class="gi">+        &quot;bad-string-format-type&quot;,</span>
<span class="gi">+        &quot;format-needs-mapping&quot;,</span>
<span class="gi">+        &quot;too-many-format-args&quot;,</span>
<span class="gi">+        &quot;too-few-format-args&quot;,</span>
<span class="gi">+        &quot;format-string-without-interpolation&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_binop(self, node: nodes.BinOp) -&gt; None:</span>
<span class="gi">+        if node.op != &quot;%&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+        left = node.left</span>
<span class="gi">+        args = node.right</span>
<span class="gi">+</span>
<span class="gi">+        if not (isinstance(left, nodes.Const) and isinstance(left.value, str)):</span>
<span class="gi">+            return</span>
<span class="gi">+        format_string = left.value</span>
<span class="gi">+        try:</span>
<span class="gi">+            (</span>
<span class="gi">+                required_keys,</span>
<span class="gi">+                required_num_args,</span>
<span class="gi">+                required_key_types,</span>
<span class="gi">+                required_arg_types,</span>
<span class="gi">+            ) = utils.parse_format_string(format_string)</span>
<span class="gi">+        except utils.UnsupportedFormatCharacter as exc:</span>
<span class="gi">+            formatted = format_string[exc.index]</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;bad-format-character&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(formatted, ord(formatted), exc.index),</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+        except utils.IncompleteFormatString:</span>
<span class="gi">+            self.add_message(&quot;truncated-format-string&quot;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+        if not required_keys and not required_num_args:</span>
<span class="gi">+            self.add_message(&quot;format-string-without-interpolation&quot;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+        if required_keys and required_num_args:</span>
<span class="gi">+            # The format string uses both named and unnamed format</span>
<span class="gi">+            # specifiers.</span>
<span class="gi">+            self.add_message(&quot;mixed-format-string&quot;, node=node)</span>
<span class="gi">+        elif required_keys:</span>
<span class="gi">+            # The format string uses only named format specifiers.</span>
<span class="gi">+            # Check that the RHS of the % operator is a mapping object</span>
<span class="gi">+            # that contains precisely the set of keys required by the</span>
<span class="gi">+            # format string.</span>
<span class="gi">+            if isinstance(args, nodes.Dict):</span>
<span class="gi">+                keys = set()</span>
<span class="gi">+                unknown_keys = False</span>
<span class="gi">+                for k, _ in args.items:</span>
<span class="gi">+                    if isinstance(k, nodes.Const):</span>
<span class="gi">+                        key = k.value</span>
<span class="gi">+                        if isinstance(key, str):</span>
<span class="gi">+                            keys.add(key)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            self.add_message(</span>
<span class="gi">+                                &quot;bad-format-string-key&quot;, node=node, args=key</span>
<span class="gi">+                            )</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # One of the keys was something other than a</span>
<span class="gi">+                        # constant.  Since we can&#39;t tell what it is,</span>
<span class="gi">+                        # suppress checks for missing keys in the</span>
<span class="gi">+                        # dictionary.</span>
<span class="gi">+                        unknown_keys = True</span>
<span class="gi">+                if not unknown_keys:</span>
<span class="gi">+                    for key in required_keys:</span>
<span class="gi">+                        if key not in keys:</span>
<span class="gi">+                            self.add_message(</span>
<span class="gi">+                                &quot;missing-format-string-key&quot;, node=node, args=key</span>
<span class="gi">+                            )</span>
<span class="gi">+                for key in keys:</span>
<span class="gi">+                    if key not in required_keys:</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;unused-format-string-key&quot;, node=node, args=key</span>
<span class="gi">+                        )</span>
<span class="gi">+                for key, arg in args.items:</span>
<span class="gi">+                    if not isinstance(key, nodes.Const):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    format_type = required_key_types.get(key.value, None)</span>
<span class="gi">+                    arg_type = utils.safe_infer(arg)</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        format_type is not None</span>
<span class="gi">+                        and arg_type</span>
<span class="gi">+                        and not isinstance(arg_type, util.UninferableBase)</span>
<span class="gi">+                        and not arg_matches_format_type(arg_type, format_type)</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;bad-string-format-type&quot;,</span>
<span class="gi">+                            node=node,</span>
<span class="gi">+                            args=(arg_type.pytype(), format_type),</span>
<span class="gi">+                        )</span>
<span class="gi">+            elif isinstance(args, (OTHER_NODES, nodes.Tuple)):</span>
<span class="gi">+                type_name = type(args).__name__</span>
<span class="gi">+                self.add_message(&quot;format-needs-mapping&quot;, node=node, args=type_name)</span>
<span class="gi">+            # else:</span>
<span class="gi">+            # The RHS of the format specifier is a name or</span>
<span class="gi">+            # expression.  It may be a mapping object, so</span>
<span class="gi">+            # there&#39;s nothing we can check.</span>
<span class="gi">+        else:</span>
<span class="gi">+            # The format string uses only unnamed format specifiers.</span>
<span class="gi">+            # Check that the number of arguments passed to the RHS of</span>
<span class="gi">+            # the % operator matches the number required by the format</span>
<span class="gi">+            # string.</span>
<span class="gi">+            args_elts = []</span>
<span class="gi">+            if isinstance(args, nodes.Tuple):</span>
<span class="gi">+                rhs_tuple = utils.safe_infer(args)</span>
<span class="gi">+                num_args = None</span>
<span class="gi">+                if isinstance(rhs_tuple, nodes.BaseContainer):</span>
<span class="gi">+                    args_elts = rhs_tuple.elts</span>
<span class="gi">+                    num_args = len(args_elts)</span>
<span class="gi">+            elif isinstance(args, (OTHER_NODES, (nodes.Dict, nodes.DictComp))):</span>
<span class="gi">+                args_elts = [args]</span>
<span class="gi">+                num_args = 1</span>
<span class="gi">+            elif isinstance(args, nodes.Name):</span>
<span class="gi">+                inferred = utils.safe_infer(args)</span>
<span class="gi">+                if isinstance(inferred, nodes.Tuple):</span>
<span class="gi">+                    # The variable is a tuple, so we need to get the elements</span>
<span class="gi">+                    # from it for further inspection</span>
<span class="gi">+                    args_elts = inferred.elts</span>
<span class="gi">+                    num_args = len(args_elts)</span>
<span class="gi">+                elif isinstance(inferred, nodes.Const):</span>
<span class="gi">+                    args_elts = [inferred]</span>
<span class="gi">+                    num_args = 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    num_args = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                # The RHS of the format specifier is an expression.</span>
<span class="gi">+                # It could be a tuple of unknown size, so</span>
<span class="gi">+                # there&#39;s nothing we can check.</span>
<span class="gi">+                num_args = None</span>
<span class="gi">+            if num_args is not None:</span>
<span class="gi">+                if num_args &gt; required_num_args:</span>
<span class="gi">+                    self.add_message(&quot;too-many-format-args&quot;, node=node)</span>
<span class="gi">+                elif num_args &lt; required_num_args:</span>
<span class="gi">+                    self.add_message(&quot;too-few-format-args&quot;, node=node)</span>
<span class="gi">+                for arg, format_type in zip(args_elts, required_arg_types):</span>
<span class="gi">+                    if not arg:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    arg_type = utils.safe_infer(arg)</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        arg_type</span>
<span class="gi">+                        and not isinstance(arg_type, util.UninferableBase)</span>
<span class="gi">+                        and not arg_matches_format_type(arg_type, format_type)</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;bad-string-format-type&quot;,</span>
<span class="gi">+                            node=node,</span>
<span class="gi">+                            args=(arg_type.pytype(), format_type),</span>
<span class="gi">+                        )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;f-string-without-interpolation&quot;)</span>
<span class="gi">+    def visit_joinedstr(self, node: nodes.JoinedStr) -&gt; None:</span>
<span class="gi">+        self._check_interpolation(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_interpolation(self, node: nodes.JoinedStr) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.FormattedValue):</span>
<span class="gi">+            return</span>
<span class="gi">+        for value in node.values:</span>
<span class="gi">+            if isinstance(value, nodes.FormattedValue):</span>
<span class="gi">+                return</span>
<span class="gi">+        self.add_message(&quot;f-string-without-interpolation&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        func = utils.safe_infer(node.func)</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(func, astroid.BoundMethod)</span>
<span class="gi">+            and isinstance(func.bound, astroid.Instance)</span>
<span class="gi">+            and func.bound.name in {&quot;str&quot;, &quot;unicode&quot;, &quot;bytes&quot;}</span>
<span class="gi">+        ):</span>
<span class="gi">+            if func.name in {&quot;strip&quot;, &quot;lstrip&quot;, &quot;rstrip&quot;} and node.args:</span>
<span class="gi">+                arg = utils.safe_infer(node.args[0])</span>
<span class="gi">+                if not isinstance(arg, nodes.Const) or not isinstance(arg.value, str):</span>
<span class="gi">+                    return</span>
<span class="gi">+                if len(arg.value) != len(set(arg.value)):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;bad-str-strip-call&quot;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=(func.bound.name, func.name),</span>
<span class="gi">+                    )</span>
<span class="gi">+            elif func.name == &quot;format&quot;:</span>
<span class="gi">+                self._check_new_format(node, func)</span>
<span class="gi">+</span>
<span class="gi">+    def _detect_vacuous_formatting(</span>
<span class="gi">+        self, node: nodes.Call, positional_arguments: list[SuccessfulInferenceResult]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        counter = collections.Counter(</span>
<span class="gi">+            arg.name for arg in positional_arguments if isinstance(arg, nodes.Name)</span>
<span class="gi">+        )</span>
<span class="gi">+        for name, count in counter.items():</span>
<span class="gi">+            if count == 1:</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;duplicate-string-formatting-argument&quot;, node=node, args=(name,)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_new_format(self, node: nodes.Call, func: bases.BoundMethod) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check the new string formatting.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Skip format nodes which don&#39;t have an explicit string on the</span>
<span class="gi">+        # left side of the format operation.</span>
<span class="gi">+        # We do this because our inference engine can&#39;t properly handle</span>
<span class="gi">+        # redefinition of the original string.</span>
<span class="gi">+        # Note that there may not be any left side at all, if the format method</span>
<span class="gi">+        # has been assigned to another variable. See issue 351. For example:</span>
<span class="gi">+        #</span>
<span class="gi">+        #    fmt = &#39;some string {}&#39;.format</span>
<span class="gi">+        #    fmt(&#39;arg&#39;)</span>
<span class="gi">+        if isinstance(node.func, nodes.Attribute) and not isinstance(</span>
<span class="gi">+            node.func.expr, nodes.Const</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        if node.starargs or node.kwargs:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            strnode = next(func.bound.infer())</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not (isinstance(strnode, nodes.Const) and isinstance(strnode.value, str)):</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            call_site = astroid.arguments.CallSite.from_call(node)</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            fields, num_args, manual_pos = utils.parse_format_method_string(</span>
<span class="gi">+                strnode.value</span>
<span class="gi">+            )</span>
<span class="gi">+        except utils.IncompleteFormatString:</span>
<span class="gi">+            self.add_message(&quot;bad-format-string&quot;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        positional_arguments = call_site.positional_arguments</span>
<span class="gi">+        named_arguments = call_site.keyword_arguments</span>
<span class="gi">+        named_fields = {field[0] for field in fields if isinstance(field[0], str)}</span>
<span class="gi">+        if num_args and manual_pos:</span>
<span class="gi">+            self.add_message(&quot;format-combined-specification&quot;, node=node)</span>
<span class="gi">+            return</span>

<span class="gd">-    def _check_new_format_specifiers(self, node: nodes.Call, fields: list[</span>
<span class="gd">-        tuple[str, list[tuple[bool, str]]]], named: dict[str,</span>
<span class="gd">-        SuccessfulInferenceResult]) -&gt;None:</span>
<span class="gi">+        check_args = False</span>
<span class="gi">+        # Consider &quot;{[0]} {[1]}&quot; as num_args.</span>
<span class="gi">+        num_args += sum(1 for field in named_fields if not field)</span>
<span class="gi">+        if named_fields:</span>
<span class="gi">+            for field in named_fields:</span>
<span class="gi">+                if field and field not in named_arguments:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;missing-format-argument-key&quot;, node=node, args=(field,)</span>
<span class="gi">+                    )</span>
<span class="gi">+            for field in named_arguments:</span>
<span class="gi">+                if field not in named_fields:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;unused-format-string-argument&quot;, node=node, args=(field,)</span>
<span class="gi">+                    )</span>
<span class="gi">+            # num_args can be 0 if manual_pos is not.</span>
<span class="gi">+            num_args = num_args or manual_pos</span>
<span class="gi">+            if positional_arguments or num_args:</span>
<span class="gi">+                empty = not all(field for field in named_fields)</span>
<span class="gi">+                if named_arguments or empty:</span>
<span class="gi">+                    # Verify the required number of positional arguments</span>
<span class="gi">+                    # only if the .format got at least one keyword argument.</span>
<span class="gi">+                    # This means that the format strings accepts both</span>
<span class="gi">+                    # positional and named fields and we should warn</span>
<span class="gi">+                    # when one of them is missing or is extra.</span>
<span class="gi">+                    check_args = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            check_args = True</span>
<span class="gi">+        if check_args:</span>
<span class="gi">+            # num_args can be 0 if manual_pos is not.</span>
<span class="gi">+            num_args = num_args or manual_pos</span>
<span class="gi">+            if not num_args:</span>
<span class="gi">+                self.add_message(&quot;format-string-without-interpolation&quot;, node=node)</span>
<span class="gi">+                return</span>
<span class="gi">+            if len(positional_arguments) &gt; num_args:</span>
<span class="gi">+                self.add_message(&quot;too-many-format-args&quot;, node=node)</span>
<span class="gi">+            elif len(positional_arguments) &lt; num_args:</span>
<span class="gi">+                self.add_message(&quot;too-few-format-args&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+        self._detect_vacuous_formatting(node, positional_arguments)</span>
<span class="gi">+        self._check_new_format_specifiers(node, fields, named_arguments)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-statements</span>
<span class="gi">+    def _check_new_format_specifiers(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Call,</span>
<span class="gi">+        fields: list[tuple[str, list[tuple[bool, str]]]],</span>
<span class="gi">+        named: dict[str, SuccessfulInferenceResult],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check attribute and index access in the format
<span class="w"> </span>        string (&quot;{0.a}&quot; and &quot;{0[a]}&quot;).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        key: Literal[0] | str</span>
<span class="gi">+        for key, specifiers in fields:</span>
<span class="gi">+            # Obtain the argument. If it can&#39;t be obtained</span>
<span class="gi">+            # or inferred, skip this check.</span>
<span class="gi">+            if not key:</span>
<span class="gi">+                # {[0]} will have an unnamed argument, defaulting</span>
<span class="gi">+                # to 0. It will not be present in `named`, so use the value</span>
<span class="gi">+                # 0 for it.</span>
<span class="gi">+                key = 0</span>
<span class="gi">+            if isinstance(key, int):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    argname = utils.get_argument_from_call(node, key)</span>
<span class="gi">+                except utils.NoSuchArgumentError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                if key not in named:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                argname = named[key]</span>
<span class="gi">+            if argname is None or isinstance(argname, util.UninferableBase):</span>
<span class="gi">+                continue</span>
<span class="gi">+            try:</span>
<span class="gi">+                argument = utils.safe_infer(argname)</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not specifiers or not argument:</span>
<span class="gi">+                # No need to check this key if it doesn&#39;t</span>
<span class="gi">+                # use attribute / item access</span>
<span class="gi">+                continue</span>
<span class="gi">+            if argument.parent and isinstance(argument.parent, nodes.Arguments):</span>
<span class="gi">+                # Ignore any object coming from an argument,</span>
<span class="gi">+                # because we can&#39;t infer its value properly.</span>
<span class="gi">+                continue</span>
<span class="gi">+            previous = argument</span>
<span class="gi">+            parsed: list[tuple[bool, str]] = []</span>
<span class="gi">+            for is_attribute, specifier in specifiers:</span>
<span class="gi">+                if isinstance(previous, util.UninferableBase):</span>
<span class="gi">+                    break</span>
<span class="gi">+                parsed.append((is_attribute, specifier))</span>
<span class="gi">+                if is_attribute:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        previous = previous.getattr(specifier)[0]</span>
<span class="gi">+                    except astroid.NotFoundError:</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            hasattr(previous, &quot;has_dynamic_getattr&quot;)</span>
<span class="gi">+                            and previous.has_dynamic_getattr()</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            # Don&#39;t warn if the object has a custom __getattr__</span>
<span class="gi">+                            break</span>
<span class="gi">+                        path = get_access_path(key, parsed)</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;missing-format-attribute&quot;,</span>
<span class="gi">+                            args=(specifier, path),</span>
<span class="gi">+                            node=node,</span>
<span class="gi">+                        )</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    warn_error = False</span>
<span class="gi">+                    if hasattr(previous, &quot;getitem&quot;):</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            previous = previous.getitem(nodes.Const(specifier))</span>
<span class="gi">+                        except (</span>
<span class="gi">+                            astroid.AstroidIndexError,</span>
<span class="gi">+                            astroid.AstroidTypeError,</span>
<span class="gi">+                            astroid.AttributeInferenceError,</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            warn_error = True</span>
<span class="gi">+                        except astroid.InferenceError:</span>
<span class="gi">+                            break</span>
<span class="gi">+                        if isinstance(previous, util.UninferableBase):</span>
<span class="gi">+                            break</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            # Lookup __getitem__ in the current node,</span>
<span class="gi">+                            # but skip further checks, because we can&#39;t</span>
<span class="gi">+                            # retrieve the looked object</span>
<span class="gi">+                            previous.getattr(&quot;__getitem__&quot;)</span>
<span class="gi">+                            break</span>
<span class="gi">+                        except astroid.NotFoundError:</span>
<span class="gi">+                            warn_error = True</span>
<span class="gi">+                    if warn_error:</span>
<span class="gi">+                        path = get_access_path(key, parsed)</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;invalid-format-index&quot;, args=(specifier, path), node=node</span>
<span class="gi">+                        )</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    previous = next(previous.infer())</span>
<span class="gi">+                except astroid.InferenceError:</span>
<span class="gi">+                    # can&#39;t check further if we can&#39;t infer it</span>
<span class="gi">+                    break</span>


<span class="w"> </span>class StringConstantChecker(BaseTokenChecker, BaseRawFileChecker):
<span class="w"> </span>    &quot;&quot;&quot;Check string literals.&quot;&quot;&quot;
<span class="gd">-    name = &#39;string&#39;</span>
<span class="gd">-    msgs = {&#39;W1401&#39;: (</span>
<span class="gd">-        &quot;Anomalous backslash in string: &#39;%s&#39;. String constant might be missing an r prefix.&quot;</span>
<span class="gd">-        , &#39;anomalous-backslash-in-string&#39;,</span>
<span class="gd">-        &#39;Used when a backslash is in a literal string but not as an escape.&#39;</span>
<span class="gd">-        ), &#39;W1402&#39;: (</span>
<span class="gd">-        &quot;Anomalous Unicode escape in byte string: &#39;%s&#39;. String constant might be missing an r or u prefix.&quot;</span>
<span class="gd">-        , &#39;anomalous-unicode-escape-in-string&#39;,</span>
<span class="gd">-        &#39;Used when an escape like \\u is encountered in a byte string where it has no effect.&#39;</span>
<span class="gd">-        ), &#39;W1404&#39;: (&#39;Implicit string concatenation found in %s&#39;,</span>
<span class="gd">-        &#39;implicit-str-concat&#39;,</span>
<span class="gd">-        &#39;String literals are implicitly concatenated in a literal iterable definition : maybe a comma is missing ?&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;W1403&#39;, &#39;implicit-str-concat-in-sequence&#39;)]}),</span>
<span class="gd">-        &#39;W1405&#39;: (</span>
<span class="gd">-        &#39;Quote delimiter %s is inconsistent with the rest of the file&#39;,</span>
<span class="gd">-        &#39;inconsistent-quotes&#39;,</span>
<span class="gd">-        &#39;Quote delimiters are not used consistently throughout a module (with allowances made for avoiding unnecessary escaping).&#39;</span>
<span class="gd">-        ), &#39;W1406&#39;: (</span>
<span class="gd">-        &#39;The u prefix for strings is no longer necessary in Python &gt;=3.0&#39;,</span>
<span class="gd">-        &#39;redundant-u-string-prefix&#39;,</span>
<span class="gd">-        &#39;Used when we detect a string with a u prefix. These prefixes were necessary in Python 2 to indicate a string was Unicode, but since Python 3.0 strings are Unicode by default.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-    options = (&#39;check-str-concat-over-line-jumps&#39;, {&#39;default&#39;: False,</span>
<span class="gd">-        &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;This flag controls whether the implicit-str-concat should generate a warning on implicit string concatenation in sequences defined over several lines.&#39;</span>
<span class="gd">-        }), (&#39;check-quote-consistency&#39;, {&#39;default&#39;: False, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;This flag controls whether inconsistent-quotes generates a warning when the character used as a quote delimiter is used inconsistently within a module.&#39;</span>
<span class="gd">-        })</span>
<span class="gd">-    ESCAPE_CHARACTERS = &#39;abfnrtvx\n\r\t\\\&#39;&quot;01234567&#39;</span>
<span class="gd">-    UNICODE_ESCAPE_CHARACTERS = &#39;uUN&#39;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;string&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W1401&quot;: (</span>
<span class="gi">+            &quot;Anomalous backslash in string: &#39;%s&#39;. &quot;</span>
<span class="gi">+            &quot;String constant might be missing an r prefix.&quot;,</span>
<span class="gi">+            &quot;anomalous-backslash-in-string&quot;,</span>
<span class="gi">+            &quot;Used when a backslash is in a literal string but not as an escape.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1402&quot;: (</span>
<span class="gi">+            &quot;Anomalous Unicode escape in byte string: &#39;%s&#39;. &quot;</span>
<span class="gi">+            &quot;String constant might be missing an r or u prefix.&quot;,</span>
<span class="gi">+            &quot;anomalous-unicode-escape-in-string&quot;,</span>
<span class="gi">+            &quot;Used when an escape like \\u is encountered in a byte &quot;</span>
<span class="gi">+            &quot;string where it has no effect.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1404&quot;: (</span>
<span class="gi">+            &quot;Implicit string concatenation found in %s&quot;,</span>
<span class="gi">+            &quot;implicit-str-concat&quot;,</span>
<span class="gi">+            &quot;String literals are implicitly concatenated in a &quot;</span>
<span class="gi">+            &quot;literal iterable definition : &quot;</span>
<span class="gi">+            &quot;maybe a comma is missing ?&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W1403&quot;, &quot;implicit-str-concat-in-sequence&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1405&quot;: (</span>
<span class="gi">+            &quot;Quote delimiter %s is inconsistent with the rest of the file&quot;,</span>
<span class="gi">+            &quot;inconsistent-quotes&quot;,</span>
<span class="gi">+            &quot;Quote delimiters are not used consistently throughout a module &quot;</span>
<span class="gi">+            &quot;(with allowances made for avoiding unnecessary escaping).&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W1406&quot;: (</span>
<span class="gi">+            &quot;The u prefix for strings is no longer necessary in Python &gt;=3.0&quot;,</span>
<span class="gi">+            &quot;redundant-u-string-prefix&quot;,</span>
<span class="gi">+            &quot;Used when we detect a string with a u prefix. These prefixes were necessary &quot;</span>
<span class="gi">+            &quot;in Python 2 to indicate a string was Unicode, but since Python 3.0 strings &quot;</span>
<span class="gi">+            &quot;are Unicode by default.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;check-str-concat-over-line-jumps&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;This flag controls whether the &quot;</span>
<span class="gi">+                &quot;implicit-str-concat should generate a warning &quot;</span>
<span class="gi">+                &quot;on implicit string concatenation in sequences defined over &quot;</span>
<span class="gi">+                &quot;several lines.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;check-quote-consistency&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;This flag controls whether inconsistent-quotes generates a &quot;</span>
<span class="gi">+                &quot;warning when the character used as a quote delimiter is used &quot;</span>
<span class="gi">+                &quot;inconsistently within a module.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # Characters that have a special meaning after a backslash in either</span>
<span class="gi">+    # Unicode or byte strings.</span>
<span class="gi">+    ESCAPE_CHARACTERS = &quot;abfnrtvx\n\r\t\\&#39;\&quot;01234567&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # Characters that have a special meaning after a backslash but only in</span>
<span class="gi">+    # Unicode strings.</span>
<span class="gi">+    UNICODE_ESCAPE_CHARACTERS = &quot;uUN&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="gd">-        self.string_tokens: dict[tuple[int, int], tuple[str, tokenize.</span>
<span class="gd">-            TokenInfo | None]] = {}</span>
<span class="gi">+        self.string_tokens: dict[</span>
<span class="gi">+            tuple[int, int], tuple[str, tokenize.TokenInfo | None]</span>
<span class="gi">+        ] = {}</span>
<span class="w"> </span>        &quot;&quot;&quot;Token position -&gt; (token value, next token).&quot;&quot;&quot;
<span class="w"> </span>        self._parenthesized_string_tokens: dict[tuple[int, int], bool] = {}

<span class="gd">-    def check_for_consistent_string_delimiters(self, tokens: Iterable[</span>
<span class="gd">-        tokenize.TokenInfo]) -&gt;None:</span>
<span class="gi">+    def process_module(self, node: nodes.Module) -&gt; None:</span>
<span class="gi">+        self._unicode_literals = &quot;unicode_literals&quot; in node.future_imports</span>
<span class="gi">+</span>
<span class="gi">+    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt; None:</span>
<span class="gi">+        encoding = &quot;ascii&quot;</span>
<span class="gi">+        for i, (token_type, token, start, _, line) in enumerate(tokens):</span>
<span class="gi">+            if token_type == tokenize.ENCODING:</span>
<span class="gi">+                # this is always the first token processed</span>
<span class="gi">+                encoding = token</span>
<span class="gi">+            elif token_type == tokenize.STRING:</span>
<span class="gi">+                # &#39;token&#39; is the whole un-parsed token; we can look at the start</span>
<span class="gi">+                # of it to see whether it&#39;s a raw or unicode string etc.</span>
<span class="gi">+                self.process_string_token(token, start[0], start[1])</span>
<span class="gi">+                # We figure the next token, ignoring comments &amp; newlines:</span>
<span class="gi">+                j = i + 1</span>
<span class="gi">+                while j &lt; len(tokens) and tokens[j].type in (</span>
<span class="gi">+                    tokenize.NEWLINE,</span>
<span class="gi">+                    tokenize.NL,</span>
<span class="gi">+                    tokenize.COMMENT,</span>
<span class="gi">+                ):</span>
<span class="gi">+                    j += 1</span>
<span class="gi">+                next_token = tokens[j] if j &lt; len(tokens) else None</span>
<span class="gi">+                if encoding != &quot;ascii&quot;:</span>
<span class="gi">+                    # We convert `tokenize` character count into a byte count,</span>
<span class="gi">+                    # to match with astroid `.col_offset`</span>
<span class="gi">+                    start = (start[0], len(line[: start[1]].encode(encoding)))</span>
<span class="gi">+                self.string_tokens[start] = (str_eval(token), next_token)</span>
<span class="gi">+                is_parenthesized = self._is_initial_string_token(</span>
<span class="gi">+                    i, tokens</span>
<span class="gi">+                ) and self._is_parenthesized(i, tokens)</span>
<span class="gi">+                self._parenthesized_string_tokens[start] = is_parenthesized</span>
<span class="gi">+</span>
<span class="gi">+        if self.linter.config.check_quote_consistency:</span>
<span class="gi">+            self.check_for_consistent_string_delimiters(tokens)</span>
<span class="gi">+</span>
<span class="gi">+    def _is_initial_string_token(</span>
<span class="gi">+        self, index: int, tokens: Sequence[tokenize.TokenInfo]</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        # Must NOT be preceded by a string literal</span>
<span class="gi">+        prev_token = self._find_prev_token(index, tokens)</span>
<span class="gi">+        if prev_token and prev_token.type == tokenize.STRING:</span>
<span class="gi">+            return False</span>
<span class="gi">+        # Must be followed by a string literal token.</span>
<span class="gi">+        next_token = self._find_next_token(index, tokens)</span>
<span class="gi">+        return bool(next_token and next_token.type == tokenize.STRING)</span>
<span class="gi">+</span>
<span class="gi">+    def _is_parenthesized(self, index: int, tokens: list[tokenize.TokenInfo]) -&gt; bool:</span>
<span class="gi">+        prev_token = self._find_prev_token(</span>
<span class="gi">+            index, tokens, ignore=(*_PAREN_IGNORE_TOKEN_TYPES, tokenize.STRING)</span>
<span class="gi">+        )</span>
<span class="gi">+        if not prev_token or prev_token.type != tokenize.OP or prev_token[1] != &quot;(&quot;:</span>
<span class="gi">+            return False</span>
<span class="gi">+        next_token = self._find_next_token(</span>
<span class="gi">+            index, tokens, ignore=(*_PAREN_IGNORE_TOKEN_TYPES, tokenize.STRING)</span>
<span class="gi">+        )</span>
<span class="gi">+        return bool(</span>
<span class="gi">+            next_token and next_token.type == tokenize.OP and next_token[1] == &quot;)&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _find_prev_token(</span>
<span class="gi">+        self,</span>
<span class="gi">+        index: int,</span>
<span class="gi">+        tokens: Sequence[tokenize.TokenInfo],</span>
<span class="gi">+        *,</span>
<span class="gi">+        ignore: tuple[int, ...] = _PAREN_IGNORE_TOKEN_TYPES,</span>
<span class="gi">+    ) -&gt; tokenize.TokenInfo | None:</span>
<span class="gi">+        i = index - 1</span>
<span class="gi">+        while i &gt;= 0 and tokens[i].type in ignore:</span>
<span class="gi">+            i -= 1</span>
<span class="gi">+        return tokens[i] if i &gt;= 0 else None</span>
<span class="gi">+</span>
<span class="gi">+    def _find_next_token(</span>
<span class="gi">+        self,</span>
<span class="gi">+        index: int,</span>
<span class="gi">+        tokens: Sequence[tokenize.TokenInfo],</span>
<span class="gi">+        *,</span>
<span class="gi">+        ignore: tuple[int, ...] = _PAREN_IGNORE_TOKEN_TYPES,</span>
<span class="gi">+    ) -&gt; tokenize.TokenInfo | None:</span>
<span class="gi">+        i = index + 1</span>
<span class="gi">+        while i &lt; len(tokens) and tokens[i].type in ignore:</span>
<span class="gi">+            i += 1</span>
<span class="gi">+        return tokens[i] if i &lt; len(tokens) else None</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;implicit-str-concat&quot;)</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        self.check_for_concatenated_strings(node.args, &quot;call&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;implicit-str-concat&quot;)</span>
<span class="gi">+    def visit_list(self, node: nodes.List) -&gt; None:</span>
<span class="gi">+        self.check_for_concatenated_strings(node.elts, &quot;list&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;implicit-str-concat&quot;)</span>
<span class="gi">+    def visit_set(self, node: nodes.Set) -&gt; None:</span>
<span class="gi">+        self.check_for_concatenated_strings(node.elts, &quot;set&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;implicit-str-concat&quot;)</span>
<span class="gi">+    def visit_tuple(self, node: nodes.Tuple) -&gt; None:</span>
<span class="gi">+        self.check_for_concatenated_strings(node.elts, &quot;tuple&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        if isinstance(node.value, nodes.Const) and isinstance(node.value.value, str):</span>
<span class="gi">+            self.check_for_concatenated_strings([node.value], &quot;assignment&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def check_for_consistent_string_delimiters(</span>
<span class="gi">+        self, tokens: Iterable[tokenize.TokenInfo]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a message for each string using inconsistent quote delimiters.

<span class="w"> </span>        Quote delimiters are used inconsistently if &quot; and &#39; are mixed in a module&#39;s
<span class="gu">@@ -174,10 +833,110 @@ class StringConstantChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>        Args:
<span class="w"> </span>          tokens: The tokens to be checked against for consistent usage.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        string_delimiters: Counter[str] = collections.Counter()</span>
<span class="gi">+</span>
<span class="gi">+        inside_fstring = False  # whether token is inside f-string (since 3.12)</span>
<span class="gi">+        target_py312 = self.linter.config.py_version &gt;= (3, 12)</span>
<span class="gi">+</span>
<span class="gi">+        # First, figure out which quote character predominates in the module</span>
<span class="gi">+        for tok_type, token, _, _, _ in tokens:</span>
<span class="gi">+            if sys.version_info[:2] &gt;= (3, 12):</span>
<span class="gi">+                # pylint: disable=no-member,useless-suppression</span>
<span class="gi">+                if tok_type == tokenize.FSTRING_START:</span>
<span class="gi">+                    inside_fstring = True</span>
<span class="gi">+                elif tok_type == tokenize.FSTRING_END:</span>
<span class="gi">+                    inside_fstring = False</span>
<span class="gi">+</span>
<span class="gi">+                if inside_fstring and not target_py312:</span>
<span class="gi">+                    # skip analysis of f-string contents</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            if tok_type == tokenize.STRING and _is_quote_delimiter_chosen_freely(token):</span>
<span class="gi">+                string_delimiters[_get_quote_delimiter(token)] += 1</span>

<span class="gd">-    def process_non_raw_string_token(self, prefix: str, string_body: str,</span>
<span class="gd">-        start_row: int, string_start_col: int) -&gt;None:</span>
<span class="gi">+        if len(string_delimiters) &gt; 1:</span>
<span class="gi">+            # Ties are broken arbitrarily</span>
<span class="gi">+            most_common_delimiter = string_delimiters.most_common(1)[0][0]</span>
<span class="gi">+            for tok_type, token, start, _, _ in tokens:</span>
<span class="gi">+                if tok_type != tokenize.STRING:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                quote_delimiter = _get_quote_delimiter(token)</span>
<span class="gi">+                if (</span>
<span class="gi">+                    _is_quote_delimiter_chosen_freely(token)</span>
<span class="gi">+                    and quote_delimiter != most_common_delimiter</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;inconsistent-quotes&quot;, line=start[0], args=(quote_delimiter,)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def check_for_concatenated_strings(</span>
<span class="gi">+        self, elements: Sequence[nodes.NodeNG], iterable_type: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        for elt in elements:</span>
<span class="gi">+            if not (</span>
<span class="gi">+                isinstance(elt, nodes.Const) and elt.pytype() in _AST_NODE_STR_TYPES</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if elt.col_offset &lt; 0:</span>
<span class="gi">+                # This can happen in case of escaped newlines</span>
<span class="gi">+                continue</span>
<span class="gi">+            token_index = (elt.lineno, elt.col_offset)</span>
<span class="gi">+            if token_index not in self.string_tokens:</span>
<span class="gi">+                # This may happen with Latin1 encoding</span>
<span class="gi">+                # cf. https://github.com/pylint-dev/pylint/issues/2610</span>
<span class="gi">+                continue</span>
<span class="gi">+            matching_token, next_token = self.string_tokens[token_index]</span>
<span class="gi">+            # We detect string concatenation: the AST Const is the</span>
<span class="gi">+            # combination of 2 string tokens</span>
<span class="gi">+            if (</span>
<span class="gi">+                matching_token != elt.value</span>
<span class="gi">+                and next_token is not None</span>
<span class="gi">+                and next_token.type == tokenize.STRING</span>
<span class="gi">+            ):</span>
<span class="gi">+                if next_token.start[0] == elt.lineno or (</span>
<span class="gi">+                    self.linter.config.check_str_concat_over_line_jumps</span>
<span class="gi">+                    # Allow implicitly concatenated strings in parens.</span>
<span class="gi">+                    # See https://github.com/pylint-dev/pylint/issues/8552.</span>
<span class="gi">+                    and not self._parenthesized_string_tokens.get(</span>
<span class="gi">+                        (elt.lineno, elt.col_offset)</span>
<span class="gi">+                    )</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;implicit-str-concat&quot;,</span>
<span class="gi">+                        line=elt.lineno,</span>
<span class="gi">+                        args=(iterable_type,),</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def process_string_token(self, token: str, start_row: int, start_col: int) -&gt; None:</span>
<span class="gi">+        quote_char = None</span>
<span class="gi">+        for _index, char in enumerate(token):</span>
<span class="gi">+            if char in &quot;&#39;\&quot;&quot;:</span>
<span class="gi">+                quote_char = char</span>
<span class="gi">+                break</span>
<span class="gi">+        if quote_char is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        # pylint: disable=undefined-loop-variable</span>
<span class="gi">+        prefix = token[:_index].lower()  # markers like u, b, r.</span>
<span class="gi">+        after_prefix = token[_index:]</span>
<span class="gi">+        # pylint: enable=undefined-loop-variable</span>
<span class="gi">+        # Chop off quotes</span>
<span class="gi">+        quote_length = (</span>
<span class="gi">+            3 if after_prefix[:3] == after_prefix[-3:] == 3 * quote_char else 1</span>
<span class="gi">+        )</span>
<span class="gi">+        string_body = after_prefix[quote_length:-quote_length]</span>
<span class="gi">+        # No special checks on raw strings at the moment.</span>
<span class="gi">+        if &quot;r&quot; not in prefix:</span>
<span class="gi">+            self.process_non_raw_string_token(</span>
<span class="gi">+                prefix,</span>
<span class="gi">+                string_body,</span>
<span class="gi">+                start_row,</span>
<span class="gi">+                start_col + len(prefix) + quote_length,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def process_non_raw_string_token(</span>
<span class="gi">+        self, prefix: str, string_body: str, start_row: int, string_start_col: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for bad escapes in a non-raw string.

<span class="w"> </span>        prefix: lowercase string of string prefix markers (&#39;ur&#39;).
<span class="gu">@@ -186,24 +945,96 @@ class StringConstantChecker(BaseTokenChecker, BaseRawFileChecker):</span>
<span class="w"> </span>        start_row: line number in the source.
<span class="w"> </span>        string_start_col: col number of the string start in the source.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Walk through the string; if we see a backslash then escape the next</span>
<span class="gi">+        # character, and skip over it.  If we see a non-escaped character,</span>
<span class="gi">+        # alert, and continue.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Accept a backslash when it escapes a backslash, or a quote, or</span>
<span class="gi">+        # end-of-line, or one of the letters that introduce a special escape</span>
<span class="gi">+        # sequence &lt;https://docs.python.org/reference/lexical_analysis.html&gt;</span>
<span class="gi">+        #</span>
<span class="gi">+        index = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            index = string_body.find(&quot;\\&quot;, index)</span>
<span class="gi">+            if index == -1:</span>
<span class="gi">+                break</span>
<span class="gi">+            # There must be a next character; having a backslash at the end</span>
<span class="gi">+            # of the string would be a SyntaxError.</span>
<span class="gi">+            next_char = string_body[index + 1]</span>
<span class="gi">+            match = string_body[index : index + 2]</span>
<span class="gi">+            # The column offset will vary depending on whether the string token</span>
<span class="gi">+            # is broken across lines. Calculate relative to the nearest line</span>
<span class="gi">+            # break or relative to the start of the token&#39;s line.</span>
<span class="gi">+            last_newline = string_body.rfind(&quot;\n&quot;, 0, index)</span>
<span class="gi">+            if last_newline == -1:</span>
<span class="gi">+                line = start_row</span>
<span class="gi">+                col_offset = index + string_start_col</span>
<span class="gi">+            else:</span>
<span class="gi">+                line = start_row + string_body.count(&quot;\n&quot;, 0, index)</span>
<span class="gi">+                col_offset = index - last_newline - 1</span>
<span class="gi">+            if next_char in self.UNICODE_ESCAPE_CHARACTERS:</span>
<span class="gi">+                if &quot;u&quot; in prefix:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif &quot;b&quot; not in prefix:</span>
<span class="gi">+                    pass  # unicode by default</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;anomalous-unicode-escape-in-string&quot;,</span>
<span class="gi">+                        line=line,</span>
<span class="gi">+                        args=(match,),</span>
<span class="gi">+                        col_offset=col_offset,</span>
<span class="gi">+                    )</span>
<span class="gi">+            elif next_char not in self.ESCAPE_CHARACTERS:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;anomalous-backslash-in-string&quot;,</span>
<span class="gi">+                    line=line,</span>
<span class="gi">+                    args=(match,),</span>
<span class="gi">+                    col_offset=col_offset,</span>
<span class="gi">+                )</span>
<span class="gi">+            # Whether it was a valid escape or not, backslash followed by</span>
<span class="gi">+            # another character can always be consumed whole: the second</span>
<span class="gi">+            # character can never be the start of a new backslash escape.</span>
<span class="gi">+            index += 2</span>

<span class="gd">-    def _detect_u_string_prefix(self, node: nodes.Const) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;redundant-u-string-prefix&quot;)</span>
<span class="gi">+    def visit_const(self, node: nodes.Const) -&gt; None:</span>
<span class="gi">+        if node.pytype() == &quot;builtins.str&quot; and not isinstance(</span>
<span class="gi">+            node.parent, nodes.JoinedStr</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._detect_u_string_prefix(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _detect_u_string_prefix(self, node: nodes.Const) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether strings include a &#39;u&#39; prefix like u&#39;String&#39;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.kind == &quot;u&quot;:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;redundant-u-string-prefix&quot;,</span>
<span class="gi">+                line=node.lineno,</span>
<span class="gi">+                col_offset=node.col_offset,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(StringFormatChecker(linter))</span>
<span class="gi">+    linter.register_checker(StringConstantChecker(linter))</span>


<span class="gd">-def str_eval(token: str) -&gt;str:</span>
<span class="gi">+def str_eval(token: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Mostly replicate `ast.literal_eval(token)` manually to avoid any performance hit.

<span class="w"> </span>    This supports f-strings, contrary to `ast.literal_eval`.
<span class="w"> </span>    We have to support all string literal notations:
<span class="w"> </span>    https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if token[0:2].lower() in {&quot;fr&quot;, &quot;rf&quot;}:</span>
<span class="gi">+        token = token[2:]</span>
<span class="gi">+    elif token[0].lower() in {&quot;r&quot;, &quot;u&quot;, &quot;f&quot;}:</span>
<span class="gi">+        token = token[1:]</span>
<span class="gi">+    if token[0:3] in {&#39;&quot;&quot;&quot;&#39;, &quot;&#39;&#39;&#39;&quot;}:</span>
<span class="gi">+        return token[3:-3]</span>
<span class="gi">+    return token[1:-1]</span>


<span class="gd">-def _is_long_string(string_token: str) -&gt;bool:</span>
<span class="gi">+def _is_long_string(string_token: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Is this string token a &quot;longstring&quot; (is it triple-quoted)?

<span class="w"> </span>    Long strings are triple-quoted as defined in
<span class="gu">@@ -220,10 +1051,13 @@ def _is_long_string(string_token: str) -&gt;bool:</span>
<span class="w"> </span>        A boolean representing whether this token matches a longstring
<span class="w"> </span>        regex.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bool(</span>
<span class="gi">+        SINGLE_QUOTED_REGEX.match(string_token)</span>
<span class="gi">+        or DOUBLE_QUOTED_REGEX.match(string_token)</span>
<span class="gi">+    )</span>


<span class="gd">-def _get_quote_delimiter(string_token: str) -&gt;str:</span>
<span class="gi">+def _get_quote_delimiter(string_token: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the quote character used to delimit this token string.

<span class="w"> </span>    This function checks whether the token is a well-formed string.
<span class="gu">@@ -238,10 +1072,13 @@ def _get_quote_delimiter(string_token: str) -&gt;str:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>      ValueError: No quote delimiter characters are present.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = QUOTE_DELIMITER_REGEX.match(string_token)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise ValueError(f&quot;string token {string_token} is not a well-formed string&quot;)</span>
<span class="gi">+    return match.group(2)</span>


<span class="gd">-def _is_quote_delimiter_chosen_freely(string_token: str) -&gt;bool:</span>
<span class="gi">+def _is_quote_delimiter_chosen_freely(string_token: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Was there a non-awkward option for the quote delimiter?

<span class="w"> </span>    Args:
<span class="gu">@@ -253,4 +1090,10 @@ def _is_quote_delimiter_chosen_freely(string_token: str) -&gt;bool:</span>
<span class="w"> </span>        strings are excepted from this analysis under the assumption that their
<span class="w"> </span>        quote characters are set by policy.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    quote_delimiter = _get_quote_delimiter(string_token)</span>
<span class="gi">+    unchosen_delimiter = &#39;&quot;&#39; if quote_delimiter == &quot;&#39;&quot; else &quot;&#39;&quot;</span>
<span class="gi">+    return bool(</span>
<span class="gi">+        quote_delimiter</span>
<span class="gi">+        and not _is_long_string(string_token)</span>
<span class="gi">+        and unchosen_delimiter not in str_eval(string_token)</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pylint/checkers/threading_checker.py b/pylint/checkers/threading_checker.py</span>
<span class="gh">index 76dec0d98..b289d6707 100644</span>
<span class="gd">--- a/pylint/checkers/threading_checker.py</span>
<span class="gi">+++ b/pylint/checkers/threading_checker.py</span>
<span class="gu">@@ -1,8 +1,16 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages, safe_infer
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -12,11 +20,40 @@ class ThreadingChecker(BaseChecker):</span>

<span class="w"> </span>    - useless with lock - locking used in wrong way that has no effect (with threading.Lock():)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;threading&#39;</span>
<span class="gd">-    LOCKS = frozenset((&#39;threading.Lock&#39;, &#39;threading.RLock&#39;,</span>
<span class="gd">-        &#39;threading.Condition&#39;, &#39;threading.Semaphore&#39;,</span>
<span class="gd">-        &#39;threading.BoundedSemaphore&#39;))</span>
<span class="gd">-    msgs = {&#39;W2101&#39;: (&quot;&#39;%s()&#39; directly created in &#39;with&#39; has no effect&quot;,</span>
<span class="gd">-        &#39;useless-with-lock&#39;,</span>
<span class="gd">-        &#39;Used when a new lock instance is created by using with statement which has no effect. Instead, an existing instance should be used to acquire lock.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;threading&quot;</span>
<span class="gi">+</span>
<span class="gi">+    LOCKS = frozenset(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;threading.Lock&quot;,</span>
<span class="gi">+            &quot;threading.RLock&quot;,</span>
<span class="gi">+            &quot;threading.Condition&quot;,</span>
<span class="gi">+            &quot;threading.Semaphore&quot;,</span>
<span class="gi">+            &quot;threading.BoundedSemaphore&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W2101&quot;: (</span>
<span class="gi">+            &quot;&#39;%s()&#39; directly created in &#39;with&#39; has no effect&quot;,</span>
<span class="gi">+            &quot;useless-with-lock&quot;,</span>
<span class="gi">+            &quot;Used when a new lock instance is created by using with statement &quot;</span>
<span class="gi">+            &quot;which has no effect. Instead, an existing instance should be used to acquire lock.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;useless-with-lock&quot;)</span>
<span class="gi">+    def visit_with(self, node: nodes.With) -&gt; None:</span>
<span class="gi">+        context_managers = (c for c, _ in node.items if isinstance(c, nodes.Call))</span>
<span class="gi">+        for context_manager in context_managers:</span>
<span class="gi">+            if isinstance(context_manager, nodes.Call):</span>
<span class="gi">+                infered_function = safe_infer(context_manager.func)</span>
<span class="gi">+                if infered_function is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                qname = infered_function.qname()</span>
<span class="gi">+                if qname in self.LOCKS:</span>
<span class="gi">+                    self.add_message(&quot;useless-with-lock&quot;, node=node, args=qname)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(ThreadingChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/typecheck.py b/pylint/checkers/typecheck.py</span>
<span class="gh">index f7ac53ca5..9e6465531 100644</span>
<span class="gd">--- a/pylint/checkers/typecheck.py</span>
<span class="gi">+++ b/pylint/checkers/typecheck.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Try to find more bugs in the code using astroid inference capabilities.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import heapq
<span class="w"> </span>import itertools
<span class="w"> </span>import operator
<span class="gu">@@ -10,31 +16,84 @@ from collections.abc import Callable, Iterable</span>
<span class="w"> </span>from functools import cached_property, singledispatch
<span class="w"> </span>from re import Pattern
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Literal, Union
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>import astroid.exceptions
<span class="w"> </span>import astroid.helpers
<span class="w"> </span>from astroid import arguments, bases, nodes, util
<span class="w"> </span>from astroid.nodes import _base_nodes
<span class="w"> </span>from astroid.typing import InferenceResult, SuccessfulInferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="gd">-from pylint.checkers.utils import decorated_with, decorated_with_property, has_known_bases, is_builtin_object, is_comprehension, is_hashable, is_inside_abstract_class, is_iterable, is_mapping, is_module_ignored, is_node_in_type_annotation_context, is_none, is_overload_stub, is_postponed_evaluation_enabled, is_super, node_ignores_exception, only_required_for_messages, safe_infer, supports_delitem, supports_getitem, supports_membership_test, supports_setitem</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    decorated_with,</span>
<span class="gi">+    decorated_with_property,</span>
<span class="gi">+    has_known_bases,</span>
<span class="gi">+    is_builtin_object,</span>
<span class="gi">+    is_comprehension,</span>
<span class="gi">+    is_hashable,</span>
<span class="gi">+    is_inside_abstract_class,</span>
<span class="gi">+    is_iterable,</span>
<span class="gi">+    is_mapping,</span>
<span class="gi">+    is_module_ignored,</span>
<span class="gi">+    is_node_in_type_annotation_context,</span>
<span class="gi">+    is_none,</span>
<span class="gi">+    is_overload_stub,</span>
<span class="gi">+    is_postponed_evaluation_enabled,</span>
<span class="gi">+    is_super,</span>
<span class="gi">+    node_ignores_exception,</span>
<span class="gi">+    only_required_for_messages,</span>
<span class="gi">+    safe_infer,</span>
<span class="gi">+    supports_delitem,</span>
<span class="gi">+    supports_getitem,</span>
<span class="gi">+    supports_membership_test,</span>
<span class="gi">+    supports_setitem,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.constants import PY310_PLUS
<span class="w"> </span>from pylint.interfaces import HIGH, INFERENCE
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-CallableObjects = Union[bases.BoundMethod, bases.UnboundMethod, nodes.</span>
<span class="gd">-    FunctionDef, nodes.Lambda, nodes.ClassDef]</span>
<span class="gd">-STR_FORMAT = {&#39;builtins.str.format&#39;}</span>
<span class="gd">-ASYNCIO_COROUTINE = &#39;asyncio.coroutines.coroutine&#39;</span>
<span class="gd">-BUILTIN_TUPLE = &#39;builtins.tuple&#39;</span>
<span class="gd">-TYPE_ANNOTATION_NODES_TYPES = (nodes.AnnAssign, nodes.Arguments, nodes.</span>
<span class="gd">-    FunctionDef)</span>
<span class="gd">-BUILTINS_IMPLICIT_RETURN_NONE = {&#39;builtins.dict&#39;: {&#39;clear&#39;, &#39;update&#39;},</span>
<span class="gd">-    &#39;builtins.list&#39;: {&#39;append&#39;, &#39;clear&#39;, &#39;extend&#39;, &#39;insert&#39;, &#39;remove&#39;,</span>
<span class="gd">-    &#39;reverse&#39;, &#39;sort&#39;}, &#39;builtins.set&#39;: {&#39;add&#39;, &#39;clear&#39;,</span>
<span class="gd">-    &#39;difference_update&#39;, &#39;discard&#39;, &#39;intersection_update&#39;, &#39;remove&#39;,</span>
<span class="gd">-    &#39;symmetric_difference_update&#39;, &#39;update&#39;}}</span>
<span class="gi">+</span>
<span class="gi">+CallableObjects = Union[</span>
<span class="gi">+    bases.BoundMethod,</span>
<span class="gi">+    bases.UnboundMethod,</span>
<span class="gi">+    nodes.FunctionDef,</span>
<span class="gi">+    nodes.Lambda,</span>
<span class="gi">+    nodes.ClassDef,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+STR_FORMAT = {&quot;builtins.str.format&quot;}</span>
<span class="gi">+ASYNCIO_COROUTINE = &quot;asyncio.coroutines.coroutine&quot;</span>
<span class="gi">+BUILTIN_TUPLE = &quot;builtins.tuple&quot;</span>
<span class="gi">+TYPE_ANNOTATION_NODES_TYPES = (</span>
<span class="gi">+    nodes.AnnAssign,</span>
<span class="gi">+    nodes.Arguments,</span>
<span class="gi">+    nodes.FunctionDef,</span>
<span class="gi">+)</span>
<span class="gi">+BUILTINS_IMPLICIT_RETURN_NONE = {</span>
<span class="gi">+    &quot;builtins.dict&quot;: {&quot;clear&quot;, &quot;update&quot;},</span>
<span class="gi">+    &quot;builtins.list&quot;: {</span>
<span class="gi">+        &quot;append&quot;,</span>
<span class="gi">+        &quot;clear&quot;,</span>
<span class="gi">+        &quot;extend&quot;,</span>
<span class="gi">+        &quot;insert&quot;,</span>
<span class="gi">+        &quot;remove&quot;,</span>
<span class="gi">+        &quot;reverse&quot;,</span>
<span class="gi">+        &quot;sort&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+    &quot;builtins.set&quot;: {</span>
<span class="gi">+        &quot;add&quot;,</span>
<span class="gi">+        &quot;clear&quot;,</span>
<span class="gi">+        &quot;difference_update&quot;,</span>
<span class="gi">+        &quot;discard&quot;,</span>
<span class="gi">+        &quot;intersection_update&quot;,</span>
<span class="gi">+        &quot;remove&quot;,</span>
<span class="gi">+        &quot;symmetric_difference_update&quot;,</span>
<span class="gi">+        &quot;update&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+}</span>


<span class="w"> </span>class VERSION_COMPATIBLE_OVERLOAD:
<span class="gu">@@ -44,9 +103,12 @@ class VERSION_COMPATIBLE_OVERLOAD:</span>
<span class="w"> </span>VERSION_COMPATIBLE_OVERLOAD_SENTINEL = VERSION_COMPATIBLE_OVERLOAD()


<span class="gd">-def _is_owner_ignored(owner: SuccessfulInferenceResult, attrname: (str |</span>
<span class="gd">-    None), ignored_classes: Iterable[str], ignored_modules: Iterable[str]</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def _is_owner_ignored(</span>
<span class="gi">+    owner: SuccessfulInferenceResult,</span>
<span class="gi">+    attrname: str | None,</span>
<span class="gi">+    ignored_classes: Iterable[str],</span>
<span class="gi">+    ignored_modules: Iterable[str],</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given owner should be ignored.

<span class="w"> </span>    This will verify if the owner&#39;s module is in *ignored_modules*
<span class="gu">@@ -58,122 +120,318 @@ def _is_owner_ignored(owner: SuccessfulInferenceResult, attrname: (str |</span>
<span class="w"> </span>    matches any name from the *ignored_classes* or if its qualified
<span class="w"> </span>    name can be found in *ignored_classes*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_module_ignored(owner.root().qname(), ignored_modules):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Match against ignored classes.</span>
<span class="gi">+    ignored_classes = set(ignored_classes)</span>
<span class="gi">+    qname = owner.qname() if hasattr(owner, &quot;qname&quot;) else &quot;&quot;</span>
<span class="gi">+    return any(ignore in (attrname, qname) for ignore in ignored_classes)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@singledispatch</span>
<span class="gi">+def _node_names(node: SuccessfulInferenceResult) -&gt; Iterable[str]:</span>
<span class="gi">+    if not hasattr(node, &quot;locals&quot;):</span>
<span class="gi">+        return []</span>
<span class="gi">+    return node.locals.keys()  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@_node_names.register(nodes.ClassDef)</span>
<span class="gi">+@_node_names.register(astroid.Instance)</span>
<span class="gi">+def _(node: nodes.ClassDef | bases.Instance) -&gt; Iterable[str]:</span>
<span class="gi">+    values = itertools.chain(node.instance_attrs.keys(), node.locals.keys())</span>

<span class="gi">+    try:</span>
<span class="gi">+        mro = node.mro()[1:]</span>
<span class="gi">+    except (NotImplementedError, TypeError, astroid.MroError):</span>
<span class="gi">+        mro = node.ancestors()</span>

<span class="gd">-def _similar_names(owner: SuccessfulInferenceResult, attrname: (str | None),</span>
<span class="gd">-    distance_threshold: int, max_choices: int) -&gt;list[str]:</span>
<span class="gi">+    other_values = [value for cls in mro for value in _node_names(cls)]</span>
<span class="gi">+    return itertools.chain(values, other_values)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _string_distance(seq1: str, seq2: str) -&gt; int:</span>
<span class="gi">+    seq2_length = len(seq2)</span>
<span class="gi">+</span>
<span class="gi">+    row = [*list(range(1, seq2_length + 1)), 0]</span>
<span class="gi">+    for seq1_index, seq1_char in enumerate(seq1):</span>
<span class="gi">+        last_row = row</span>
<span class="gi">+        row = [0] * seq2_length + [seq1_index + 1]</span>
<span class="gi">+</span>
<span class="gi">+        for seq2_index, seq2_char in enumerate(seq2):</span>
<span class="gi">+            row[seq2_index] = min(</span>
<span class="gi">+                last_row[seq2_index] + 1,</span>
<span class="gi">+                row[seq2_index - 1] + 1,</span>
<span class="gi">+                last_row[seq2_index - 1] + (seq1_char != seq2_char),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    return row[seq2_length - 1]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _similar_names(</span>
<span class="gi">+    owner: SuccessfulInferenceResult,</span>
<span class="gi">+    attrname: str | None,</span>
<span class="gi">+    distance_threshold: int,</span>
<span class="gi">+    max_choices: int,</span>
<span class="gi">+) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given an owner and a name, try to find similar names.

<span class="w"> </span>    The similar names are searched given a distance metric and only
<span class="w"> </span>    a given number of choices will be returned.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    possible_names: list[tuple[str, int]] = []</span>
<span class="gi">+    names = _node_names(owner)</span>
<span class="gi">+</span>
<span class="gi">+    for name in names:</span>
<span class="gi">+        if name == attrname:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        distance = _string_distance(attrname or &quot;&quot;, name)</span>
<span class="gi">+        if distance &lt;= distance_threshold:</span>
<span class="gi">+            possible_names.append((name, distance))</span>
<span class="gi">+</span>
<span class="gi">+    # Now get back the values with a minimum, up to the given</span>
<span class="gi">+    # limit or choices.</span>
<span class="gi">+    picked = [</span>
<span class="gi">+        name</span>
<span class="gi">+        for (name, _) in heapq.nsmallest(</span>
<span class="gi">+            max_choices, possible_names, key=operator.itemgetter(1)</span>
<span class="gi">+        )</span>
<span class="gi">+    ]</span>
<span class="gi">+    return sorted(picked)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _missing_member_hint(</span>
<span class="gi">+    owner: SuccessfulInferenceResult,</span>
<span class="gi">+    attrname: str | None,</span>
<span class="gi">+    distance_threshold: int,</span>
<span class="gi">+    max_choices: int,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    names = _similar_names(owner, attrname, distance_threshold, max_choices)</span>
<span class="gi">+    if not names:</span>
<span class="gi">+        # No similar name.</span>
<span class="gi">+        return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    names = [repr(name) for name in names]</span>
<span class="gi">+    if len(names) == 1:</span>
<span class="gi">+        names_hint = &quot;, &quot;.join(names)</span>
<span class="gi">+    else:</span>
<span class="gi">+        names_hint = f&quot;one of {&#39;, &#39;.join(names[:-1])} or {names[-1]}&quot;</span>

<span class="gi">+    return f&quot;; maybe {names_hint}?&quot;</span>

<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;E1101&#39;: (</span>
<span class="gd">-    &#39;%s %r has no %r member%s&#39;, &#39;no-member&#39;,</span>
<span class="gd">-    &#39;Used when a variable is accessed for a nonexistent member.&#39;, {</span>
<span class="gd">-    &#39;old_names&#39;: [(&#39;E1103&#39;, &#39;maybe-no-member&#39;)]}), &#39;I1101&#39;: (</span>
<span class="gd">-    &#39;%s %r has no %r member%s, but source is unavailable. Consider adding this module to extension-pkg-allow-list if you want to perform analysis based on run-time introspection of living objects.&#39;</span>
<span class="gd">-    , &#39;c-extension-no-member&#39;,</span>
<span class="gd">-    &#39;Used when a variable is accessed for non-existent member of C extension. Due to unavailability of source static analysis is impossible, but it may be performed by introspecting living objects in run-time.&#39;</span>
<span class="gd">-    ), &#39;E1102&#39;: (&#39;%s is not callable&#39;, &#39;not-callable&#39;,</span>
<span class="gd">-    &#39;Used when an object being called has been inferred to a non callable object.&#39;</span>
<span class="gd">-    ), &#39;E1111&#39;: (</span>
<span class="gd">-    &#39;Assigning result of a function call, where the function has no return&#39;,</span>
<span class="gd">-    &#39;assignment-from-no-return&#39;,</span>
<span class="gd">-    &quot;Used when an assignment is done on a function call but the inferred function doesn&#39;t return anything.&quot;</span>
<span class="gd">-    ), &#39;E1120&#39;: (&#39;No value for argument %s in %s call&#39;,</span>
<span class="gd">-    &#39;no-value-for-parameter&#39;,</span>
<span class="gd">-    &#39;Used when a function call passes too few arguments.&#39;), &#39;E1121&#39;: (</span>
<span class="gd">-    &#39;Too many positional arguments for %s call&#39;, &#39;too-many-function-args&#39;,</span>
<span class="gd">-    &#39;Used when a function call passes too many positional arguments.&#39;),</span>
<span class="gd">-    &#39;E1123&#39;: (&#39;Unexpected keyword argument %r in %s call&#39;,</span>
<span class="gd">-    &#39;unexpected-keyword-arg&#39;,</span>
<span class="gd">-    &quot;Used when a function call passes a keyword argument that doesn&#39;t correspond to one of the function&#39;s parameter names.&quot;</span>
<span class="gd">-    ), &#39;E1124&#39;: (&#39;Argument %r passed by position and keyword in %s call&#39;,</span>
<span class="gd">-    &#39;redundant-keyword-arg&#39;,</span>
<span class="gd">-    &#39;Used when a function call would result in assigning multiple values to a function parameter, one value from a positional argument and one from a keyword argument.&#39;</span>
<span class="gd">-    ), &#39;E1125&#39;: (&#39;Missing mandatory keyword argument %r in %s call&#39;,</span>
<span class="gd">-    &#39;missing-kwoa&#39;,</span>
<span class="gd">-    &#39;Used when a function call does not pass a mandatory keyword-only argument.&#39;</span>
<span class="gd">-    ), &#39;E1126&#39;: (</span>
<span class="gd">-    &#39;Sequence index is not an int, slice, or instance with __index__&#39;,</span>
<span class="gd">-    &#39;invalid-sequence-index&#39;,</span>
<span class="gd">-    &#39;Used when a sequence type is indexed with an invalid type. Valid types are ints, slices, and objects with an __index__ method.&#39;</span>
<span class="gd">-    ), &#39;E1127&#39;: (</span>
<span class="gd">-    &#39;Slice index is not an int, None, or instance with __index__&#39;,</span>
<span class="gd">-    &#39;invalid-slice-index&#39;,</span>
<span class="gd">-    &#39;Used when a slice index is not an integer, None, or an object with an __index__ method.&#39;</span>
<span class="gd">-    ), &#39;E1128&#39;: (</span>
<span class="gd">-    &#39;Assigning result of a function call, where the function returns None&#39;,</span>
<span class="gd">-    &#39;assignment-from-none&#39;,</span>
<span class="gd">-    &#39;Used when an assignment is done on a function call but the inferred function returns nothing but None.&#39;</span>
<span class="gd">-    , {&#39;old_names&#39;: [(&#39;W1111&#39;, &#39;old-assignment-from-none&#39;)]}), &#39;E1129&#39;: (</span>
<span class="gd">-    &quot;Context manager &#39;%s&#39; doesn&#39;t implement __enter__ and __exit__.&quot;,</span>
<span class="gd">-    &#39;not-context-manager&#39;,</span>
<span class="gd">-    &quot;Used when an instance in a with statement doesn&#39;t implement the context manager protocol(__enter__/__exit__).&quot;</span>
<span class="gd">-    ), &#39;E1130&#39;: (&#39;%s&#39;, &#39;invalid-unary-operand-type&#39;,</span>
<span class="gd">-    &#39;Emitted when a unary operand is used on an object which does not support this type of operation.&#39;</span>
<span class="gd">-    ), &#39;E1131&#39;: (&#39;%s&#39;, &#39;unsupported-binary-operation&#39;,</span>
<span class="gd">-    &#39;Emitted when a binary arithmetic operation between two operands is not supported.&#39;</span>
<span class="gd">-    ), &#39;E1132&#39;: (</span>
<span class="gd">-    &#39;Got multiple values for keyword argument %r in function call&#39;,</span>
<span class="gd">-    &#39;repeated-keyword&#39;,</span>
<span class="gd">-    &#39;Emitted when a function call got multiple values for a keyword.&#39;),</span>
<span class="gd">-    &#39;E1135&#39;: (&quot;Value &#39;%s&#39; doesn&#39;t support membership test&quot;,</span>
<span class="gd">-    &#39;unsupported-membership-test&#39;,</span>
<span class="gd">-    &quot;Emitted when an instance in membership test expression doesn&#39;t implement membership protocol (__contains__/__iter__/__getitem__).&quot;</span>
<span class="gd">-    ), &#39;E1136&#39;: (&quot;Value &#39;%s&#39; is unsubscriptable&quot;, &#39;unsubscriptable-object&#39;,</span>
<span class="gd">-    &quot;Emitted when a subscripted value doesn&#39;t support subscription (i.e. doesn&#39;t define __getitem__ method or __class_getitem__ for a class).&quot;</span>
<span class="gd">-    ), &#39;E1137&#39;: (&#39;%r does not support item assignment&#39;,</span>
<span class="gd">-    &#39;unsupported-assignment-operation&#39;,</span>
<span class="gd">-    &quot;Emitted when an object does not support item assignment (i.e. doesn&#39;t define __setitem__ method).&quot;</span>
<span class="gd">-    ), &#39;E1138&#39;: (&#39;%r does not support item deletion&#39;,</span>
<span class="gd">-    &#39;unsupported-delete-operation&#39;,</span>
<span class="gd">-    &quot;Emitted when an object does not support item deletion (i.e. doesn&#39;t define __delitem__ method).&quot;</span>
<span class="gd">-    ), &#39;E1139&#39;: (&#39;Invalid metaclass %r used&#39;, &#39;invalid-metaclass&#39;,</span>
<span class="gd">-    &#39;Emitted whenever we can detect that a class is using, as a metaclass, something which might be invalid for using as a metaclass.&#39;</span>
<span class="gd">-    ), &#39;E1141&#39;: (</span>
<span class="gd">-    &#39;Unpacking a dictionary in iteration without calling .items()&#39;,</span>
<span class="gd">-    &#39;dict-iter-missing-items&#39;,</span>
<span class="gd">-    &#39;Emitted when trying to iterate through a dict without calling .items()&#39;</span>
<span class="gd">-    ), &#39;E1142&#39;: (&quot;&#39;await&#39; should be used within an async function&quot;,</span>
<span class="gd">-    &#39;await-outside-async&#39;,</span>
<span class="gd">-    &#39;Emitted when await is used outside an async function.&#39;), &#39;E1143&#39;: (</span>
<span class="gd">-    &quot;&#39;%s&#39; is unhashable and can&#39;t be used as a %s in a %s&quot;,</span>
<span class="gd">-    &#39;unhashable-member&#39;,</span>
<span class="gd">-    &quot;Emitted when a dict key or set member is not hashable (i.e. doesn&#39;t define __hash__ method).&quot;</span>
<span class="gd">-    , {&#39;old_names&#39;: [(&#39;E1140&#39;, &#39;unhashable-dict-key&#39;)]}), &#39;E1144&#39;: (</span>
<span class="gd">-    &#39;Slice step cannot be 0&#39;, &#39;invalid-slice-step&#39;,</span>
<span class="gd">-    &quot;Used when a slice step is 0 and the object doesn&#39;t implement a custom __getitem__ method.&quot;</span>
<span class="gd">-    ), &#39;W1113&#39;: (</span>
<span class="gd">-    &#39;Keyword argument before variable positional arguments list in the definition of %s function&#39;</span>
<span class="gd">-    , &#39;keyword-arg-before-vararg&#39;,</span>
<span class="gd">-    &#39;When defining a keyword argument before variable positional arguments, one can end up in having multiple values passed for the aforementioned parameter in case the method is called with keyword arguments.&#39;</span>
<span class="gd">-    ), &#39;W1114&#39;: (&#39;Positional arguments appear to be out of order&#39;,</span>
<span class="gd">-    &#39;arguments-out-of-order&#39;,</span>
<span class="gd">-    &quot;Emitted  when the caller&#39;s argument names fully match the parameter names in the function signature but do not have the same order.&quot;</span>
<span class="gd">-    ), &#39;W1115&#39;: (&#39;Non-string value assigned to __name__&#39;,</span>
<span class="gd">-    &#39;non-str-assignment-to-dunder-name&#39;,</span>
<span class="gd">-    &#39;Emitted when a non-string value is assigned to __name__&#39;), &#39;W1116&#39;: (</span>
<span class="gd">-    &#39;Second argument of isinstance is not a type&#39;,</span>
<span class="gd">-    &#39;isinstance-second-argument-not-valid-type&#39;,</span>
<span class="gd">-    &#39;Emitted when the second argument of an isinstance call is not a type.&#39;</span>
<span class="gd">-    ), &#39;W1117&#39;: (</span>
<span class="gd">-    &#39;%r will be included in %r since a positional-only parameter with this name already exists&#39;</span>
<span class="gd">-    , &#39;kwarg-superseded-by-positional-arg&#39;,</span>
<span class="gd">-    &#39;Emitted when a function is called with a keyword argument that has the same name as a positional-only parameter and the function contains a keyword variadic parameter dict.&#39;</span>
<span class="gd">-    )}</span>
<span class="gd">-SEQUENCE_TYPES = {&#39;str&#39;, &#39;unicode&#39;, &#39;list&#39;, &#39;tuple&#39;, &#39;bytearray&#39;, &#39;xrange&#39;,</span>
<span class="gd">-    &#39;range&#39;, &#39;bytes&#39;, &#39;memoryview&#39;}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _emit_no_member(node: (nodes.Attribute | nodes.AssignAttr | nodes.</span>
<span class="gd">-    DelAttr), owner: InferenceResult, owner_name: (str | None),</span>
<span class="gd">-    mixin_class_rgx: Pattern[str], ignored_mixins: bool=True, ignored_none:</span>
<span class="gd">-    bool=True) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+    &quot;E1101&quot;: (</span>
<span class="gi">+        &quot;%s %r has no %r member%s&quot;,</span>
<span class="gi">+        &quot;no-member&quot;,</span>
<span class="gi">+        &quot;Used when a variable is accessed for a nonexistent member.&quot;,</span>
<span class="gi">+        {&quot;old_names&quot;: [(&quot;E1103&quot;, &quot;maybe-no-member&quot;)]},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;I1101&quot;: (</span>
<span class="gi">+        &quot;%s %r has no %r member%s, but source is unavailable. Consider &quot;</span>
<span class="gi">+        &quot;adding this module to extension-pkg-allow-list if you want &quot;</span>
<span class="gi">+        &quot;to perform analysis based on run-time introspection of living objects.&quot;,</span>
<span class="gi">+        &quot;c-extension-no-member&quot;,</span>
<span class="gi">+        &quot;Used when a variable is accessed for non-existent member of C &quot;</span>
<span class="gi">+        &quot;extension. Due to unavailability of source static analysis is impossible, &quot;</span>
<span class="gi">+        &quot;but it may be performed by introspecting living objects in run-time.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1102&quot;: (</span>
<span class="gi">+        &quot;%s is not callable&quot;,</span>
<span class="gi">+        &quot;not-callable&quot;,</span>
<span class="gi">+        &quot;Used when an object being called has been inferred to a non &quot;</span>
<span class="gi">+        &quot;callable object.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1111&quot;: (</span>
<span class="gi">+        &quot;Assigning result of a function call, where the function has no return&quot;,</span>
<span class="gi">+        &quot;assignment-from-no-return&quot;,</span>
<span class="gi">+        &quot;Used when an assignment is done on a function call but the &quot;</span>
<span class="gi">+        &quot;inferred function doesn&#39;t return anything.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1120&quot;: (</span>
<span class="gi">+        &quot;No value for argument %s in %s call&quot;,</span>
<span class="gi">+        &quot;no-value-for-parameter&quot;,</span>
<span class="gi">+        &quot;Used when a function call passes too few arguments.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1121&quot;: (</span>
<span class="gi">+        &quot;Too many positional arguments for %s call&quot;,</span>
<span class="gi">+        &quot;too-many-function-args&quot;,</span>
<span class="gi">+        &quot;Used when a function call passes too many positional arguments.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1123&quot;: (</span>
<span class="gi">+        &quot;Unexpected keyword argument %r in %s call&quot;,</span>
<span class="gi">+        &quot;unexpected-keyword-arg&quot;,</span>
<span class="gi">+        &quot;Used when a function call passes a keyword argument that &quot;</span>
<span class="gi">+        &quot;doesn&#39;t correspond to one of the function&#39;s parameter names.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1124&quot;: (</span>
<span class="gi">+        &quot;Argument %r passed by position and keyword in %s call&quot;,</span>
<span class="gi">+        &quot;redundant-keyword-arg&quot;,</span>
<span class="gi">+        &quot;Used when a function call would result in assigning multiple &quot;</span>
<span class="gi">+        &quot;values to a function parameter, one value from a positional &quot;</span>
<span class="gi">+        &quot;argument and one from a keyword argument.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1125&quot;: (</span>
<span class="gi">+        &quot;Missing mandatory keyword argument %r in %s call&quot;,</span>
<span class="gi">+        &quot;missing-kwoa&quot;,</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;Used when a function call does not pass a mandatory&quot;</span>
<span class="gi">+            &quot; keyword-only argument.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1126&quot;: (</span>
<span class="gi">+        &quot;Sequence index is not an int, slice, or instance with __index__&quot;,</span>
<span class="gi">+        &quot;invalid-sequence-index&quot;,</span>
<span class="gi">+        &quot;Used when a sequence type is indexed with an invalid type. &quot;</span>
<span class="gi">+        &quot;Valid types are ints, slices, and objects with an __index__ &quot;</span>
<span class="gi">+        &quot;method.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1127&quot;: (</span>
<span class="gi">+        &quot;Slice index is not an int, None, or instance with __index__&quot;,</span>
<span class="gi">+        &quot;invalid-slice-index&quot;,</span>
<span class="gi">+        &quot;Used when a slice index is not an integer, None, or an object &quot;</span>
<span class="gi">+        &quot;with an __index__ method.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1128&quot;: (</span>
<span class="gi">+        &quot;Assigning result of a function call, where the function returns None&quot;,</span>
<span class="gi">+        &quot;assignment-from-none&quot;,</span>
<span class="gi">+        &quot;Used when an assignment is done on a function call but the &quot;</span>
<span class="gi">+        &quot;inferred function returns nothing but None.&quot;,</span>
<span class="gi">+        {&quot;old_names&quot;: [(&quot;W1111&quot;, &quot;old-assignment-from-none&quot;)]},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1129&quot;: (</span>
<span class="gi">+        &quot;Context manager &#39;%s&#39; doesn&#39;t implement __enter__ and __exit__.&quot;,</span>
<span class="gi">+        &quot;not-context-manager&quot;,</span>
<span class="gi">+        &quot;Used when an instance in a with statement doesn&#39;t implement &quot;</span>
<span class="gi">+        &quot;the context manager protocol(__enter__/__exit__).&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1130&quot;: (</span>
<span class="gi">+        &quot;%s&quot;,</span>
<span class="gi">+        &quot;invalid-unary-operand-type&quot;,</span>
<span class="gi">+        &quot;Emitted when a unary operand is used on an object which does not &quot;</span>
<span class="gi">+        &quot;support this type of operation.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1131&quot;: (</span>
<span class="gi">+        &quot;%s&quot;,</span>
<span class="gi">+        &quot;unsupported-binary-operation&quot;,</span>
<span class="gi">+        &quot;Emitted when a binary arithmetic operation between two &quot;</span>
<span class="gi">+        &quot;operands is not supported.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1132&quot;: (</span>
<span class="gi">+        &quot;Got multiple values for keyword argument %r in function call&quot;,</span>
<span class="gi">+        &quot;repeated-keyword&quot;,</span>
<span class="gi">+        &quot;Emitted when a function call got multiple values for a keyword.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1135&quot;: (</span>
<span class="gi">+        &quot;Value &#39;%s&#39; doesn&#39;t support membership test&quot;,</span>
<span class="gi">+        &quot;unsupported-membership-test&quot;,</span>
<span class="gi">+        &quot;Emitted when an instance in membership test expression doesn&#39;t &quot;</span>
<span class="gi">+        &quot;implement membership protocol (__contains__/__iter__/__getitem__).&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1136&quot;: (</span>
<span class="gi">+        &quot;Value &#39;%s&#39; is unsubscriptable&quot;,</span>
<span class="gi">+        &quot;unsubscriptable-object&quot;,</span>
<span class="gi">+        &quot;Emitted when a subscripted value doesn&#39;t support subscription &quot;</span>
<span class="gi">+        &quot;(i.e. doesn&#39;t define __getitem__ method or __class_getitem__ for a class).&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1137&quot;: (</span>
<span class="gi">+        &quot;%r does not support item assignment&quot;,</span>
<span class="gi">+        &quot;unsupported-assignment-operation&quot;,</span>
<span class="gi">+        &quot;Emitted when an object does not support item assignment &quot;</span>
<span class="gi">+        &quot;(i.e. doesn&#39;t define __setitem__ method).&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1138&quot;: (</span>
<span class="gi">+        &quot;%r does not support item deletion&quot;,</span>
<span class="gi">+        &quot;unsupported-delete-operation&quot;,</span>
<span class="gi">+        &quot;Emitted when an object does not support item deletion &quot;</span>
<span class="gi">+        &quot;(i.e. doesn&#39;t define __delitem__ method).&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1139&quot;: (</span>
<span class="gi">+        &quot;Invalid metaclass %r used&quot;,</span>
<span class="gi">+        &quot;invalid-metaclass&quot;,</span>
<span class="gi">+        &quot;Emitted whenever we can detect that a class is using, &quot;</span>
<span class="gi">+        &quot;as a metaclass, something which might be invalid for using as &quot;</span>
<span class="gi">+        &quot;a metaclass.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1141&quot;: (</span>
<span class="gi">+        &quot;Unpacking a dictionary in iteration without calling .items()&quot;,</span>
<span class="gi">+        &quot;dict-iter-missing-items&quot;,</span>
<span class="gi">+        &quot;Emitted when trying to iterate through a dict without calling .items()&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1142&quot;: (</span>
<span class="gi">+        &quot;&#39;await&#39; should be used within an async function&quot;,</span>
<span class="gi">+        &quot;await-outside-async&quot;,</span>
<span class="gi">+        &quot;Emitted when await is used outside an async function.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1143&quot;: (</span>
<span class="gi">+        &quot;&#39;%s&#39; is unhashable and can&#39;t be used as a %s in a %s&quot;,</span>
<span class="gi">+        &quot;unhashable-member&quot;,</span>
<span class="gi">+        &quot;Emitted when a dict key or set member is not hashable &quot;</span>
<span class="gi">+        &quot;(i.e. doesn&#39;t define __hash__ method).&quot;,</span>
<span class="gi">+        {&quot;old_names&quot;: [(&quot;E1140&quot;, &quot;unhashable-dict-key&quot;)]},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E1144&quot;: (</span>
<span class="gi">+        &quot;Slice step cannot be 0&quot;,</span>
<span class="gi">+        &quot;invalid-slice-step&quot;,</span>
<span class="gi">+        &quot;Used when a slice step is 0 and the object doesn&#39;t implement &quot;</span>
<span class="gi">+        &quot;a custom __getitem__ method.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W1113&quot;: (</span>
<span class="gi">+        &quot;Keyword argument before variable positional arguments list &quot;</span>
<span class="gi">+        &quot;in the definition of %s function&quot;,</span>
<span class="gi">+        &quot;keyword-arg-before-vararg&quot;,</span>
<span class="gi">+        &quot;When defining a keyword argument before variable positional arguments, one can &quot;</span>
<span class="gi">+        &quot;end up in having multiple values passed for the aforementioned parameter in &quot;</span>
<span class="gi">+        &quot;case the method is called with keyword arguments.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W1114&quot;: (</span>
<span class="gi">+        &quot;Positional arguments appear to be out of order&quot;,</span>
<span class="gi">+        &quot;arguments-out-of-order&quot;,</span>
<span class="gi">+        &quot;Emitted  when the caller&#39;s argument names fully match the parameter &quot;</span>
<span class="gi">+        &quot;names in the function signature but do not have the same order.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W1115&quot;: (</span>
<span class="gi">+        &quot;Non-string value assigned to __name__&quot;,</span>
<span class="gi">+        &quot;non-str-assignment-to-dunder-name&quot;,</span>
<span class="gi">+        &quot;Emitted when a non-string value is assigned to __name__&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W1116&quot;: (</span>
<span class="gi">+        &quot;Second argument of isinstance is not a type&quot;,</span>
<span class="gi">+        &quot;isinstance-second-argument-not-valid-type&quot;,</span>
<span class="gi">+        &quot;Emitted when the second argument of an isinstance call is not a type.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W1117&quot;: (</span>
<span class="gi">+        &quot;%r will be included in %r since a positional-only parameter with this name already exists&quot;,</span>
<span class="gi">+        &quot;kwarg-superseded-by-positional-arg&quot;,</span>
<span class="gi">+        &quot;Emitted when a function is called with a keyword argument that has the &quot;</span>
<span class="gi">+        &quot;same name as a positional-only parameter and the function contains a &quot;</span>
<span class="gi">+        &quot;keyword variadic parameter dict.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+# builtin sequence types in Python 2 and 3.</span>
<span class="gi">+SEQUENCE_TYPES = {</span>
<span class="gi">+    &quot;str&quot;,</span>
<span class="gi">+    &quot;unicode&quot;,</span>
<span class="gi">+    &quot;list&quot;,</span>
<span class="gi">+    &quot;tuple&quot;,</span>
<span class="gi">+    &quot;bytearray&quot;,</span>
<span class="gi">+    &quot;xrange&quot;,</span>
<span class="gi">+    &quot;range&quot;,</span>
<span class="gi">+    &quot;bytes&quot;,</span>
<span class="gi">+    &quot;memoryview&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _emit_no_member(</span>
<span class="gi">+    node: nodes.Attribute | nodes.AssignAttr | nodes.DelAttr,</span>
<span class="gi">+    owner: InferenceResult,</span>
<span class="gi">+    owner_name: str | None,</span>
<span class="gi">+    mixin_class_rgx: Pattern[str],</span>
<span class="gi">+    ignored_mixins: bool = True,</span>
<span class="gi">+    ignored_none: bool = True,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Try to see if no-member should be emitted for the given owner.

<span class="w"> </span>    The following cases are ignored:
<span class="gu">@@ -186,18 +444,262 @@ def _emit_no_member(node: (nodes.Attribute | nodes.AssignAttr | nodes.</span>
<span class="w"> </span>          AttributeError, Exception or bare except.
<span class="w"> </span>        * The node is guarded behind and `IF` or `IFExp` node
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # pylint: disable = too-many-return-statements, too-many-branches</span>
<span class="gi">+    if node_ignores_exception(node, AttributeError):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if ignored_none and isinstance(owner, nodes.Const) and owner.value is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if is_super(owner) or getattr(owner, &quot;type&quot;, None) == &quot;metaclass&quot;:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if owner_name and ignored_mixins and mixin_class_rgx.match(owner_name):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if isinstance(owner, nodes.FunctionDef) and (</span>
<span class="gi">+        owner.decorators or owner.is_abstract()</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if isinstance(owner, (astroid.Instance, nodes.ClassDef)):</span>
<span class="gi">+        # Issue #2565: Don&#39;t ignore enums, as they have a `__getattr__` but it&#39;s not</span>
<span class="gi">+        # invoked at this point.</span>
<span class="gi">+        try:</span>
<span class="gi">+            metaclass = owner.metaclass()</span>
<span class="gi">+        except astroid.MroError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Renamed in Python 3.10 to `EnumType`</span>
<span class="gi">+            if metaclass and metaclass.qname() in {&quot;enum.EnumMeta&quot;, &quot;enum.EnumType&quot;}:</span>
<span class="gi">+                return not _enum_has_attribute(owner, node)</span>
<span class="gi">+        if owner.has_dynamic_getattr():</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not has_known_bases(owner):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Exclude typed annotations, since these might actually exist</span>
<span class="gi">+        # at some point during the runtime of the program.</span>
<span class="gi">+        if utils.is_attribute_typed_annotation(owner, node.attrname):</span>
<span class="gi">+            return False</span>
<span class="gi">+    if isinstance(owner, astroid.objects.Super):</span>
<span class="gi">+        # Verify if we are dealing with an invalid Super object.</span>
<span class="gi">+        # If it is invalid, then there&#39;s no point in checking that</span>
<span class="gi">+        # it has the required attribute. Also, don&#39;t fail if the</span>
<span class="gi">+        # MRO is invalid.</span>
<span class="gi">+        try:</span>
<span class="gi">+            owner.super_mro()</span>
<span class="gi">+        except (astroid.MroError, astroid.SuperError):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not all(has_known_bases(base) for base in owner.type.mro()):</span>
<span class="gi">+            return False</span>
<span class="gi">+    if isinstance(owner, nodes.Module):</span>
<span class="gi">+        try:</span>
<span class="gi">+            owner.getattr(&quot;__getattr__&quot;)</span>
<span class="gi">+            return False</span>
<span class="gi">+        except astroid.NotFoundError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    if owner_name and node.attrname.startswith(&quot;_&quot; + owner_name):</span>
<span class="gi">+        # Test if an attribute has been mangled (&#39;private&#39; attribute)</span>
<span class="gi">+        unmangled_name = node.attrname.split(&quot;_&quot; + owner_name)[-1]</span>
<span class="gi">+        try:</span>
<span class="gi">+            if owner.getattr(unmangled_name, context=None) is not None:</span>
<span class="gi">+                return False</span>
<span class="gi">+        except astroid.NotFoundError:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    # Don&#39;t emit no-member if guarded behind `IF` or `IFExp`</span>
<span class="gi">+    #   * Walk up recursively until if statement is found.</span>
<span class="gi">+    #   * Check if condition can be inferred as `Const`,</span>
<span class="gi">+    #       would evaluate as `False`,</span>
<span class="gi">+    #       and whether the node is part of the `body`.</span>
<span class="gi">+    #   * Continue checking until scope of node is reached.</span>
<span class="gi">+    scope: nodes.NodeNG = node.scope()</span>
<span class="gi">+    node_origin: nodes.NodeNG = node</span>
<span class="gi">+    parent: nodes.NodeNG = node.parent</span>
<span class="gi">+    while parent != scope:</span>
<span class="gi">+        if isinstance(parent, (nodes.If, nodes.IfExp)):</span>
<span class="gi">+            inferred = safe_infer(parent.test)</span>
<span class="gi">+            if (  # pylint: disable=too-many-boolean-expressions</span>
<span class="gi">+                isinstance(inferred, nodes.Const)</span>
<span class="gi">+                and inferred.bool_value() is False</span>
<span class="gi">+                and (</span>
<span class="gi">+                    isinstance(parent, nodes.If)</span>
<span class="gi">+                    and node_origin in parent.body</span>
<span class="gi">+                    or isinstance(parent, nodes.IfExp)</span>
<span class="gi">+                    and node_origin == parent.body</span>
<span class="gi">+                )</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+        node_origin, parent = parent, parent.parent</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_all_attribute_assignments(</span>
<span class="gi">+    node: nodes.FunctionDef, name: str | None = None</span>
<span class="gi">+) -&gt; set[str]:</span>
<span class="gi">+    attributes: set[str] = set()</span>
<span class="gi">+    for child in node.nodes_of_class((nodes.Assign, nodes.AnnAssign)):</span>
<span class="gi">+        targets = []</span>
<span class="gi">+        if isinstance(child, nodes.Assign):</span>
<span class="gi">+            targets = child.targets</span>
<span class="gi">+        elif isinstance(child, nodes.AnnAssign):</span>
<span class="gi">+            targets = [child.target]</span>
<span class="gi">+        for assign_target in targets:</span>
<span class="gi">+            if isinstance(assign_target, nodes.Tuple):</span>
<span class="gi">+                targets.extend(assign_target.elts)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(assign_target, nodes.AssignAttr)</span>
<span class="gi">+                and isinstance(assign_target.expr, nodes.Name)</span>
<span class="gi">+                and (name is None or assign_target.expr.name == name)</span>
<span class="gi">+            ):</span>
<span class="gi">+                attributes.add(assign_target.attrname)</span>
<span class="gi">+    return attributes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _enum_has_attribute(</span>
<span class="gi">+    owner: astroid.Instance | nodes.ClassDef, node: nodes.Attribute</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    if isinstance(owner, astroid.Instance):</span>
<span class="gi">+        enum_def = next(</span>
<span class="gi">+            (b.parent for b in owner.bases if isinstance(b.parent, nodes.ClassDef)),</span>
<span class="gi">+            None,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if enum_def is None:</span>
<span class="gi">+            # We don&#39;t inherit from anything, so try to find the parent</span>
<span class="gi">+            # class definition and roll with that</span>
<span class="gi">+            enum_def = node</span>
<span class="gi">+            while enum_def is not None and not isinstance(enum_def, nodes.ClassDef):</span>
<span class="gi">+                enum_def = enum_def.parent</span>
<span class="gi">+</span>
<span class="gi">+        # If this blows, something is clearly wrong</span>
<span class="gi">+        assert enum_def is not None, &quot;enum_def unexpectedly None&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        enum_def = owner</span>

<span class="gi">+    # Find __new__ and __init__</span>
<span class="gi">+    dunder_new = next((m for m in enum_def.methods() if m.name == &quot;__new__&quot;), None)</span>
<span class="gi">+    dunder_init = next((m for m in enum_def.methods() if m.name == &quot;__init__&quot;), None)</span>

<span class="gd">-def _has_parent_of_type(node: nodes.Call, node_type: (nodes.Keyword | nodes</span>
<span class="gd">-    .Starred), statement: _base_nodes.Statement) -&gt;bool:</span>
<span class="gi">+    enum_attributes: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+    # Find attributes defined in __new__</span>
<span class="gi">+    if dunder_new:</span>
<span class="gi">+        # Get the object returned in __new__</span>
<span class="gi">+        returned_obj_name = next(</span>
<span class="gi">+            (c.value for c in dunder_new.get_children() if isinstance(c, nodes.Return)),</span>
<span class="gi">+            None,</span>
<span class="gi">+        )</span>
<span class="gi">+        if isinstance(returned_obj_name, nodes.Name):</span>
<span class="gi">+            # Find all attribute assignments to the returned object</span>
<span class="gi">+            enum_attributes |= _get_all_attribute_assignments(</span>
<span class="gi">+                dunder_new, returned_obj_name.name</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # Find attributes defined in __init__</span>
<span class="gi">+    if dunder_init and dunder_init.body and dunder_init.args:</span>
<span class="gi">+        # Grab the name referring to `self` from the function def</span>
<span class="gi">+        enum_attributes |= _get_all_attribute_assignments(</span>
<span class="gi">+            dunder_init, dunder_init.args.arguments[0].name</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return node.attrname in enum_attributes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _determine_callable(</span>
<span class="gi">+    callable_obj: nodes.NodeNG,</span>
<span class="gi">+) -&gt; tuple[CallableObjects, int, str]:</span>
<span class="gi">+    # TODO: The typing of the second return variable is actually Literal[0,1]</span>
<span class="gi">+    # We need typing on astroid.NodeNG.implicit_parameters for this</span>
<span class="gi">+    # TODO: The typing of the third return variable can be narrowed to a Literal</span>
<span class="gi">+    # We need typing on astroid.NodeNG.type for this</span>
<span class="gi">+</span>
<span class="gi">+    # Ordering is important, since BoundMethod is a subclass of UnboundMethod,</span>
<span class="gi">+    # and Function inherits Lambda.</span>
<span class="gi">+    parameters = 0</span>
<span class="gi">+    if hasattr(callable_obj, &quot;implicit_parameters&quot;):</span>
<span class="gi">+        parameters = callable_obj.implicit_parameters()</span>
<span class="gi">+    if isinstance(callable_obj, bases.BoundMethod):</span>
<span class="gi">+        # Bound methods have an extra implicit &#39;self&#39; argument.</span>
<span class="gi">+        return callable_obj, parameters, callable_obj.type</span>
<span class="gi">+    if isinstance(callable_obj, bases.UnboundMethod):</span>
<span class="gi">+        return callable_obj, parameters, &quot;unbound method&quot;</span>
<span class="gi">+    if isinstance(callable_obj, nodes.FunctionDef):</span>
<span class="gi">+        return callable_obj, parameters, callable_obj.type</span>
<span class="gi">+    if isinstance(callable_obj, nodes.Lambda):</span>
<span class="gi">+        return callable_obj, parameters, &quot;lambda&quot;</span>
<span class="gi">+    if isinstance(callable_obj, nodes.ClassDef):</span>
<span class="gi">+        # Class instantiation, lookup __new__ instead.</span>
<span class="gi">+        # If we only find object.__new__, we can safely check __init__</span>
<span class="gi">+        # instead. If __new__ belongs to builtins, then we look</span>
<span class="gi">+        # again for __init__ in the locals, since we won&#39;t have</span>
<span class="gi">+        # argument information for the builtin __new__ function.</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Use the last definition of __new__.</span>
<span class="gi">+            new = callable_obj.local_attr(&quot;__new__&quot;)[-1]</span>
<span class="gi">+        except astroid.NotFoundError:</span>
<span class="gi">+            new = None</span>
<span class="gi">+</span>
<span class="gi">+        from_object = new and new.parent.scope().name == &quot;object&quot;</span>
<span class="gi">+        from_builtins = new and new.root().name in sys.builtin_module_names</span>
<span class="gi">+</span>
<span class="gi">+        if not new or from_object or from_builtins:</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Use the last definition of __init__.</span>
<span class="gi">+                callable_obj = callable_obj.local_attr(&quot;__init__&quot;)[-1]</span>
<span class="gi">+            except astroid.NotFoundError as e:</span>
<span class="gi">+                raise ValueError from e</span>
<span class="gi">+        else:</span>
<span class="gi">+            callable_obj = new</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(callable_obj, nodes.FunctionDef):</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+        # both have an extra implicit &#39;cls&#39;/&#39;self&#39; argument.</span>
<span class="gi">+        return callable_obj, parameters, &quot;constructor&quot;</span>
<span class="gi">+</span>
<span class="gi">+    raise ValueError</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _has_parent_of_type(</span>
<span class="gi">+    node: nodes.Call,</span>
<span class="gi">+    node_type: nodes.Keyword | nodes.Starred,</span>
<span class="gi">+    statement: _base_nodes.Statement,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given node has a parent of the given type.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent = node.parent</span>
<span class="gi">+    while not isinstance(parent, node_type) and statement.parent_of(parent):</span>
<span class="gi">+        parent = parent.parent</span>
<span class="gi">+    return isinstance(parent, node_type)</span>


<span class="gd">-def _no_context_variadic(node: nodes.Call, variadic_name: (str | None),</span>
<span class="gd">-    variadic_type: (nodes.Keyword | nodes.Starred), variadics: list[nodes.</span>
<span class="gd">-    Keyword | nodes.Starred]) -&gt;bool:</span>
<span class="gi">+def _no_context_variadic_keywords(node: nodes.Call, scope: nodes.Lambda) -&gt; bool:</span>
<span class="gi">+    statement = node.statement()</span>
<span class="gi">+    variadics = []</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        isinstance(scope, nodes.Lambda)</span>
<span class="gi">+        and not isinstance(scope, nodes.FunctionDef)</span>
<span class="gi">+        or isinstance(statement, nodes.With)</span>
<span class="gi">+    ):</span>
<span class="gi">+        variadics = list(node.keywords or []) + node.kwargs</span>
<span class="gi">+    elif isinstance(statement, (nodes.Return, nodes.Expr, nodes.Assign)) and isinstance(</span>
<span class="gi">+        statement.value, nodes.Call</span>
<span class="gi">+    ):</span>
<span class="gi">+        call = statement.value</span>
<span class="gi">+        variadics = list(call.keywords or []) + call.kwargs</span>
<span class="gi">+</span>
<span class="gi">+    return _no_context_variadic(node, scope.args.kwarg, nodes.Keyword, variadics)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _no_context_variadic_positional(node: nodes.Call, scope: nodes.Lambda) -&gt; bool:</span>
<span class="gi">+    variadics = node.starargs + node.kwargs</span>
<span class="gi">+    return _no_context_variadic(node, scope.args.vararg, nodes.Starred, variadics)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _no_context_variadic(</span>
<span class="gi">+    node: nodes.Call,</span>
<span class="gi">+    variadic_name: str | None,</span>
<span class="gi">+    variadic_type: nodes.Keyword | nodes.Starred,</span>
<span class="gi">+    variadics: list[nodes.Keyword | nodes.Starred],</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Verify if the given call node has variadic nodes without context.

<span class="w"> </span>    This is a workaround for handling cases of nested call functions
<span class="gu">@@ -208,11 +710,54 @@ def _no_context_variadic(node: nodes.Call, variadic_name: (str | None),</span>
<span class="w"> </span>    This can lead pylint to believe that a function call receives
<span class="w"> </span>    too few arguments.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scope = node.scope()</span>
<span class="gi">+    is_in_lambda_scope = not isinstance(scope, nodes.FunctionDef) and isinstance(</span>
<span class="gi">+        scope, nodes.Lambda</span>
<span class="gi">+    )</span>
<span class="gi">+    statement = node.statement()</span>
<span class="gi">+    for name in statement.nodes_of_class(nodes.Name):</span>
<span class="gi">+        if name.name != variadic_name:</span>
<span class="gi">+            continue</span>

<span class="gi">+        inferred = safe_infer(name)</span>
<span class="gi">+        if isinstance(inferred, (nodes.List, nodes.Tuple)):</span>
<span class="gi">+            length = len(inferred.elts)</span>
<span class="gi">+        elif isinstance(inferred, nodes.Dict):</span>
<span class="gi">+            length = len(inferred.items)</span>
<span class="gi">+        else:</span>
<span class="gi">+            continue</span>

<span class="gd">-def _infer_from_metaclass_constructor(cls: nodes.ClassDef, func: nodes.</span>
<span class="gd">-    FunctionDef) -&gt;(InferenceResult | None):</span>
<span class="gi">+        if is_in_lambda_scope and isinstance(inferred.parent, nodes.Arguments):</span>
<span class="gi">+            # The statement of the variadic will be the assignment itself,</span>
<span class="gi">+            # so we need to go the lambda instead</span>
<span class="gi">+            inferred_statement = inferred.parent.parent</span>
<span class="gi">+        else:</span>
<span class="gi">+            inferred_statement = inferred.statement()</span>
<span class="gi">+</span>
<span class="gi">+        if not length and isinstance(</span>
<span class="gi">+            inferred_statement, (nodes.Lambda, nodes.FunctionDef)</span>
<span class="gi">+        ):</span>
<span class="gi">+            is_in_starred_context = _has_parent_of_type(node, variadic_type, statement)</span>
<span class="gi">+            used_as_starred_argument = any(</span>
<span class="gi">+                variadic.value == name or variadic.value.parent_of(name)</span>
<span class="gi">+                for variadic in variadics</span>
<span class="gi">+            )</span>
<span class="gi">+            if is_in_starred_context or used_as_starred_argument:</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_invalid_metaclass(metaclass: nodes.ClassDef) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        mro = metaclass.mro()</span>
<span class="gi">+    except (astroid.DuplicateBasesError, astroid.InconsistentMroError):</span>
<span class="gi">+        return True</span>
<span class="gi">+    return not any(is_builtin_object(cls) and cls.name == &quot;type&quot; for cls in mro)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _infer_from_metaclass_constructor(</span>
<span class="gi">+    cls: nodes.ClassDef, func: nodes.FunctionDef</span>
<span class="gi">+) -&gt; InferenceResult | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Try to infer what the given *func* constructor is building.

<span class="w"> </span>    :param astroid.FunctionDef func:
<span class="gu">@@ -229,60 +774,298 @@ def _infer_from_metaclass_constructor(cls: nodes.ClassDef, func: nodes.</span>
<span class="w"> </span>        if we couldn&#39;t infer it.
<span class="w"> </span>    :rtype: astroid.ClassDef
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    context = astroid.context.InferenceContext()</span>
<span class="gi">+</span>
<span class="gi">+    class_bases = nodes.List()</span>
<span class="gi">+    class_bases.postinit(elts=cls.bases)</span>
<span class="gi">+</span>
<span class="gi">+    attrs = nodes.Dict(</span>
<span class="gi">+        lineno=0, col_offset=0, parent=None, end_lineno=0, end_col_offset=0</span>
<span class="gi">+    )</span>
<span class="gi">+    local_names = [(name, values[-1]) for name, values in cls.locals.items()]</span>
<span class="gi">+    attrs.postinit(local_names)</span>
<span class="gi">+</span>
<span class="gi">+    builder_args = nodes.Tuple()</span>
<span class="gi">+    builder_args.postinit([cls.name, class_bases, attrs])</span>
<span class="gi">+</span>
<span class="gi">+    context.callcontext = astroid.context.CallContext(builder_args)</span>
<span class="gi">+    try:</span>
<span class="gi">+        inferred = next(func.infer_call_result(func, context), None)</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return inferred or None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_c_extension(module_node: InferenceResult) -&gt; bool:</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(module_node, nodes.Module)</span>
<span class="gi">+        and not astroid.modutils.is_stdlib_module(module_node.name)</span>
<span class="gi">+        and not module_node.fully_defined()</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_invalid_isinstance_type(arg: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    # Return True if we are sure that arg is not a type</span>
<span class="gi">+    if PY310_PLUS and isinstance(arg, nodes.BinOp) and arg.op == &quot;|&quot;:</span>
<span class="gi">+        return any(</span>
<span class="gi">+            _is_invalid_isinstance_type(elt) and not is_none(elt)</span>
<span class="gi">+            for elt in (arg.left, arg.right)</span>
<span class="gi">+        )</span>
<span class="gi">+    inferred = utils.safe_infer(arg)</span>
<span class="gi">+    if not inferred:</span>
<span class="gi">+        # Cannot infer it so skip it.</span>
<span class="gi">+        return False</span>
<span class="gi">+    if isinstance(inferred, nodes.Tuple):</span>
<span class="gi">+        return any(_is_invalid_isinstance_type(elt) for elt in inferred.elts)</span>
<span class="gi">+    if isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if isinstance(inferred, astroid.Instance) and inferred.qname() == BUILTIN_TUPLE:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if PY310_PLUS and isinstance(inferred, bases.UnionType):</span>
<span class="gi">+        return any(</span>
<span class="gi">+            _is_invalid_isinstance_type(elt) and not is_none(elt)</span>
<span class="gi">+            for elt in (inferred.left, inferred.right)</span>
<span class="gi">+        )</span>
<span class="gi">+    return True</span>


<span class="w"> </span>class TypeChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Try to find bugs in the code using type inference.&quot;&quot;&quot;
<span class="gd">-    name = &#39;typecheck&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;typecheck&quot;</span>
<span class="gi">+    # messages</span>
<span class="w"> </span>    msgs = MSGS
<span class="gd">-    options = (&#39;ignore-on-opaque-inference&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;This flag controls whether pylint should warn about no-member and similar checks whenever an opaque object is returned when inferring. The inference can return multiple potential results while evaluating a Python object, but some branches might not be evaluated, which results in partial inference. In that case, it might be useful to still emit no-member and other checks for the rest of the inferred objects.&#39;</span>
<span class="gd">-        }), (&#39;mixin-class-rgx&#39;, {&#39;default&#39;: &#39;.*[Mm]ixin&#39;, &#39;type&#39;: &#39;regexp&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;regexp&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Regex pattern to define which classes are considered mixins.&#39;}), (</span>
<span class="gd">-        &#39;ignore-mixin-members&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Tells whether missing members accessed in mixin class should be ignored. A class is considered mixin if its name matches the mixin-class-rgx option.&#39;</span>
<span class="gd">-        , &#39;kwargs&#39;: {&#39;new_names&#39;: [&#39;ignore-checks-for-mixin&#39;]}}), (</span>
<span class="gd">-        &#39;ignored-checks-for-mixins&#39;, {&#39;default&#39;: [&#39;no-member&#39;,</span>
<span class="gd">-        &#39;not-async-context-manager&#39;, &#39;not-context-manager&#39;,</span>
<span class="gd">-        &#39;attribute-defined-outside-init&#39;], &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;list of messages names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of symbolic message names to ignore for Mixin members.&#39;}), (</span>
<span class="gd">-        &#39;ignore-none&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Tells whether to warn about missing members when the owner of the attribute is inferred to be None.&#39;</span>
<span class="gd">-        }), (&#39;ignored-classes&#39;, {&#39;default&#39;: (&#39;optparse.Values&#39;,</span>
<span class="gd">-        &#39;thread._local&#39;, &#39;_thread._local&#39;, &#39;argparse.Namespace&#39;), &#39;type&#39;:</span>
<span class="gd">-        &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;members names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of class names for which member attributes should not be checked (useful for classes with dynamically set attributes). This supports the use of qualified names.&#39;</span>
<span class="gd">-        }), (&#39;generated-members&#39;, {&#39;default&#39;: (), &#39;type&#39;: &#39;string&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;members names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &quot;List of members which are set dynamically and missed by pylint inference system, and so shouldn&#39;t trigger E1101 when accessed. Python regular expressions are accepted.&quot;</span>
<span class="gd">-        }), (&#39;contextmanager-decorators&#39;, {&#39;default&#39;: [</span>
<span class="gd">-        &#39;contextlib.contextmanager&#39;], &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;decorator names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of decorators that produce context managers, such as contextlib.contextmanager. Add to this list to register other decorators that produce valid context managers.&#39;</span>
<span class="gd">-        }), (&#39;missing-member-hint-distance&#39;, {&#39;default&#39;: 1, &#39;type&#39;: &#39;int&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;member hint edit distance&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;The minimum edit distance a name should have in order to be considered a similar match for a missing member name.&#39;</span>
<span class="gd">-        }), (&#39;missing-member-max-choices&#39;, {&#39;default&#39;: 1, &#39;type&#39;: &#39;int&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;member hint max choices&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;The total number of similar names that should be taken in consideration when showing a hint for a missing member.&#39;</span>
<span class="gd">-        }), (&#39;missing-member-hint&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;missing member hint&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Show a hint with possible names when a member name was not found. The aspect of finding the hint is based on edit distance.&#39;</span>
<span class="gd">-        }), (&#39;signature-mutators&#39;, {&#39;default&#39;: [], &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;decorator names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of decorators that change the signature of a decorated function.&#39;</span>
<span class="gd">-        })</span>
<span class="gi">+    # configuration options</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-on-opaque-inference&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;This flag controls whether pylint should warn about &quot;</span>
<span class="gi">+                &quot;no-member and similar checks whenever an opaque object &quot;</span>
<span class="gi">+                &quot;is returned when inferring. The inference can return &quot;</span>
<span class="gi">+                &quot;multiple potential results while evaluating a Python object, &quot;</span>
<span class="gi">+                &quot;but some branches might not be evaluated, which results in &quot;</span>
<span class="gi">+                &quot;partial inference. In that case, it might be useful to still emit &quot;</span>
<span class="gi">+                &quot;no-member and other checks for the rest of the inferred objects.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;mixin-class-rgx&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;.*[Mm]ixin&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;regexp&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Regex pattern to define which classes are considered mixins.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-mixin-members&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Tells whether missing members accessed in mixin &quot;</span>
<span class="gi">+                &quot;class should be ignored. A class is considered mixin if its name matches &quot;</span>
<span class="gi">+                &quot;the mixin-class-rgx option.&quot;,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;new_names&quot;: [&quot;ignore-checks-for-mixin&quot;]},</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignored-checks-for-mixins&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: [</span>
<span class="gi">+                    &quot;no-member&quot;,</span>
<span class="gi">+                    &quot;not-async-context-manager&quot;,</span>
<span class="gi">+                    &quot;not-context-manager&quot;,</span>
<span class="gi">+                    &quot;attribute-defined-outside-init&quot;,</span>
<span class="gi">+                ],</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;list of messages names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of symbolic message names to ignore for Mixin members.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-none&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Tells whether to warn about missing members when the owner &quot;</span>
<span class="gi">+                &quot;of the attribute is inferred to be None.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        # the defaults here are *stdlib* names that (almost) always</span>
<span class="gi">+        # lead to false positives, since their idiomatic use is</span>
<span class="gi">+        # &#39;too dynamic&#39; for pylint to grok.</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignored-classes&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (</span>
<span class="gi">+                    &quot;optparse.Values&quot;,</span>
<span class="gi">+                    &quot;thread._local&quot;,</span>
<span class="gi">+                    &quot;_thread._local&quot;,</span>
<span class="gi">+                    &quot;argparse.Namespace&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;members names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of class names for which member attributes &quot;</span>
<span class="gi">+                &quot;should not be checked (useful for classes with &quot;</span>
<span class="gi">+                &quot;dynamically set attributes). This supports &quot;</span>
<span class="gi">+                &quot;the use of qualified names.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;generated-members&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;members names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of members which are set dynamically and \</span>
<span class="gi">+missed by pylint inference system, and so shouldn&#39;t trigger E1101 when \</span>
<span class="gi">+accessed. Python regular expressions are accepted.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;contextmanager-decorators&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: [&quot;contextlib.contextmanager&quot;],</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;decorator names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of decorators that produce context managers, &quot;</span>
<span class="gi">+                &quot;such as contextlib.contextmanager. Add to this list &quot;</span>
<span class="gi">+                &quot;to register other decorators that produce valid &quot;</span>
<span class="gi">+                &quot;context managers.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;missing-member-hint-distance&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 1,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;member hint edit distance&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;The minimum edit distance a name should have in order &quot;</span>
<span class="gi">+                &quot;to be considered a similar match for a missing member name.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;missing-member-max-choices&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 1,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;member hint max choices&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;The total number of similar names that should be taken in &quot;</span>
<span class="gi">+                &quot;consideration when showing a hint for a missing member.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;missing-member-hint&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;missing member hint&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Show a hint with possible names when a member name was not &quot;</span>
<span class="gi">+                &quot;found. The aspect of finding the hint is based on edit distance.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;signature-mutators&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: [],</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;decorator names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of decorators that change the signature of &quot;</span>
<span class="gi">+                &quot;a decorated function.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        py_version = self.linter.config.py_version</span>
<span class="gi">+        self._py310_plus = py_version &gt;= (3, 10)</span>
<span class="gi">+        self._mixin_class_rgx = self.linter.config.mixin_class_rgx</span>
<span class="gi">+</span>
<span class="gi">+    @cached_property</span>
<span class="gi">+    def _suggestion_mode(self) -&gt; bool:</span>
<span class="gi">+        return self.linter.config.suggestion_mode  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    @cached_property</span>
<span class="gi">+    def _compiled_generated_members(self) -&gt; tuple[Pattern[str], ...]:</span>
<span class="gi">+        # do this lazily since config not fully initialized in __init__</span>
<span class="gi">+        # generated_members may contain regular expressions</span>
<span class="gi">+        # (surrounded by quote `&quot;` and followed by a comma `,`)</span>
<span class="gi">+        # REQUEST,aq_parent,&quot;[a-zA-Z]+_set{1,2}&quot;&#39; =&gt;</span>
<span class="gi">+        # (&#39;REQUEST&#39;, &#39;aq_parent&#39;, &#39;[a-zA-Z]+_set{1,2}&#39;)</span>
<span class="gi">+        generated_members = self.linter.config.generated_members</span>
<span class="gi">+        if isinstance(generated_members, str):</span>
<span class="gi">+            gen = shlex.shlex(generated_members)</span>
<span class="gi">+            gen.whitespace += &quot;,&quot;</span>
<span class="gi">+            gen.wordchars += r&quot;[]-+\.*?()|&quot;</span>
<span class="gi">+            generated_members = tuple(tok.strip(&#39;&quot;&#39;) for tok in gen)</span>
<span class="gi">+        return tuple(re.compile(exp) for exp in generated_members)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;keyword-arg-before-vararg&quot;)</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        # check for keyword arg before varargs.</span>
<span class="gi">+</span>
<span class="gi">+        if node.args.vararg and node.args.defaults:</span>
<span class="gi">+            # When `positional-only` parameters are present then only</span>
<span class="gi">+            # `positional-or-keyword` parameters are checked. I.e:</span>
<span class="gi">+            # &gt;&gt;&gt; def name(pos_only_params, /, pos_or_keyword_params, *args): ...</span>
<span class="gi">+            if node.args.posonlyargs and not node.args.args:</span>
<span class="gi">+                return</span>
<span class="gi">+            self.add_message(&quot;keyword-arg-before-vararg&quot;, node=node, args=(node.name))</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    @only_required_for_messages(&#39;no-member&#39;, &#39;c-extension-no-member&#39;)</span>
<span class="gd">-    def visit_attribute(self, node: (nodes.Attribute | nodes.AssignAttr |</span>
<span class="gd">-        nodes.DelAttr)) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;invalid-metaclass&quot;)</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        def _metaclass_name(metaclass: InferenceResult) -&gt; str | None:</span>
<span class="gi">+            # pylint: disable=unidiomatic-typecheck</span>
<span class="gi">+            if isinstance(metaclass, (nodes.ClassDef, nodes.FunctionDef)):</span>
<span class="gi">+                return metaclass.name  # type: ignore[no-any-return]</span>
<span class="gi">+            if type(metaclass) is bases.Instance:</span>
<span class="gi">+                # Really do mean type, not isinstance, since subclasses of bases.Instance</span>
<span class="gi">+                # like Const or Dict should use metaclass.as_string below.</span>
<span class="gi">+                return str(metaclass)</span>
<span class="gi">+            return metaclass.as_string()  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+        metaclass = node.declared_metaclass()</span>
<span class="gi">+        if not metaclass:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(metaclass, nodes.FunctionDef):</span>
<span class="gi">+            # Try to infer the result.</span>
<span class="gi">+            metaclass = _infer_from_metaclass_constructor(node, metaclass)</span>
<span class="gi">+            if not metaclass:</span>
<span class="gi">+                # Don&#39;t do anything if we cannot infer the result.</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(metaclass, nodes.ClassDef):</span>
<span class="gi">+            if _is_invalid_metaclass(metaclass):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;invalid-metaclass&quot;, node=node, args=(_metaclass_name(metaclass),)</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;invalid-metaclass&quot;, node=node, args=(_metaclass_name(metaclass),)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_assignattr(self, node: nodes.AssignAttr) -&gt; None:</span>
<span class="gi">+        if isinstance(node.assign_type(), nodes.AugAssign):</span>
<span class="gi">+            self.visit_attribute(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_delattr(self, node: nodes.DelAttr) -&gt; None:</span>
<span class="gi">+        self.visit_attribute(node)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-branches, too-many-statements</span>
<span class="gi">+    @only_required_for_messages(&quot;no-member&quot;, &quot;c-extension-no-member&quot;)</span>
<span class="gi">+    def visit_attribute(</span>
<span class="gi">+        self, node: nodes.Attribute | nodes.AssignAttr | nodes.DelAttr</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that the accessed attribute exists.

<span class="w"> </span>        to avoid too much false positives for now, we&#39;ll consider the code as
<span class="gu">@@ -290,75 +1073,908 @@ class TypeChecker(BaseChecker):</span>

<span class="w"> </span>        function/method, super call and metaclasses are ignored
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if any(</span>
<span class="gi">+            pattern.match(name)</span>
<span class="gi">+            for name in (node.attrname, node.as_string())</span>
<span class="gi">+            for pattern in self._compiled_generated_members</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(</span>
<span class="gi">+            node</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            inferred = list(node.expr.infer())</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # list of (node, nodename) which are missing the attribute</span>
<span class="gi">+        missingattr: set[tuple[SuccessfulInferenceResult, str | None]] = set()</span>
<span class="gi">+</span>
<span class="gi">+        non_opaque_inference_results: list[SuccessfulInferenceResult] = [</span>
<span class="gi">+            owner</span>
<span class="gi">+            for owner in inferred</span>
<span class="gi">+            if not isinstance(owner, (nodes.Unknown, util.UninferableBase))</span>
<span class="gi">+        ]</span>
<span class="gi">+        if (</span>
<span class="gi">+            len(non_opaque_inference_results) != len(inferred)</span>
<span class="gi">+            and self.linter.config.ignore_on_opaque_inference</span>
<span class="gi">+        ):</span>
<span class="gi">+            # There is an ambiguity in the inference. Since we can&#39;t</span>
<span class="gi">+            # make sure that we won&#39;t emit a false positive, we just stop</span>
<span class="gi">+            # whenever the inference returns an opaque inference object.</span>
<span class="gi">+            return</span>
<span class="gi">+        for owner in non_opaque_inference_results:</span>
<span class="gi">+            name = getattr(owner, &quot;name&quot;, None)</span>
<span class="gi">+            if _is_owner_ignored(</span>
<span class="gi">+                owner,</span>
<span class="gi">+                name,</span>
<span class="gi">+                self.linter.config.ignored_classes,</span>
<span class="gi">+                self.linter.config.ignored_modules,</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            qualname = f&quot;{owner.pytype()}.{node.attrname}&quot;</span>
<span class="gi">+            if any(</span>
<span class="gi">+                pattern.match(qualname) for pattern in self._compiled_generated_members</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                attr_nodes = owner.getattr(node.attrname)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            except astroid.DuplicateBasesError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            except astroid.NotFoundError:</span>
<span class="gi">+                # Avoid false positive in case a decorator supplies member.</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(owner, (astroid.FunctionDef, astroid.BoundMethod))</span>
<span class="gi">+                    and owner.decorators</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # This can&#39;t be moved before the actual .getattr call,</span>
<span class="gi">+                # because there can be more values inferred and we are</span>
<span class="gi">+                # stopping after the first one which has the attribute in question.</span>
<span class="gi">+                # The problem is that if the first one has the attribute,</span>
<span class="gi">+                # but we continue to the next values which doesn&#39;t have the</span>
<span class="gi">+                # attribute, then we&#39;ll have a false positive.</span>
<span class="gi">+                # So call this only after the call has been made.</span>
<span class="gi">+                if not _emit_no_member(</span>
<span class="gi">+                    node,</span>
<span class="gi">+                    owner,</span>
<span class="gi">+                    name,</span>
<span class="gi">+                    self._mixin_class_rgx,</span>
<span class="gi">+                    ignored_mixins=(</span>
<span class="gi">+                        &quot;no-member&quot; in self.linter.config.ignored_checks_for_mixins</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    ignored_none=self.linter.config.ignore_none,</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                missingattr.add((owner, name))</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                for attr_node in attr_nodes:</span>
<span class="gi">+                    attr_parent = attr_node.parent</span>
<span class="gi">+                    # Skip augmented assignments</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        if isinstance(attr_node.statement(), nodes.AugAssign) or (</span>
<span class="gi">+                            isinstance(attr_parent, nodes.Assign)</span>
<span class="gi">+                            and utils.is_augmented_assign(attr_parent)[0]</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    except astroid.exceptions.StatementMissing:</span>
<span class="gi">+                        break</span>
<span class="gi">+                    # Skip self-referencing assignments</span>
<span class="gi">+                    if attr_parent is node.parent:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    missingattr.add((owner, name))</span>
<span class="gi">+                    continue</span>
<span class="gi">+            # stop on the first found</span>
<span class="gi">+            break</span>
<span class="gi">+        else:</span>
<span class="gi">+            # we have not found any node with the attributes, display the</span>
<span class="gi">+            # message for inferred nodes</span>
<span class="gi">+            done = set()</span>
<span class="gi">+            for owner, name in missingattr:</span>
<span class="gi">+                if isinstance(owner, astroid.Instance):</span>
<span class="gi">+                    actual = owner._proxied</span>
<span class="gi">+                else:</span>
<span class="gi">+                    actual = owner</span>
<span class="gi">+                if actual in done:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                done.add(actual)</span>
<span class="gi">+</span>
<span class="gi">+                msg, hint = self._get_nomember_msgid_hint(node, owner)</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    msg,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(owner.display_type(), name, node.attrname, hint),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>

<span class="gd">-    @only_required_for_messages(&#39;assignment-from-no-return&#39;,</span>
<span class="gd">-        &#39;assignment-from-none&#39;, &#39;non-str-assignment-to-dunder-name&#39;)</span>
<span class="gd">-    def visit_assign(self, node: nodes.Assign) -&gt;None:</span>
<span class="gi">+    def _get_nomember_msgid_hint(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Attribute | nodes.AssignAttr | nodes.DelAttr,</span>
<span class="gi">+        owner: SuccessfulInferenceResult,</span>
<span class="gi">+    ) -&gt; tuple[Literal[&quot;c-extension-no-member&quot;, &quot;no-member&quot;], str]:</span>
<span class="gi">+        suggestions_are_possible = self._suggestion_mode and isinstance(</span>
<span class="gi">+            owner, nodes.Module</span>
<span class="gi">+        )</span>
<span class="gi">+        if suggestions_are_possible and _is_c_extension(owner):</span>
<span class="gi">+            msg = &quot;c-extension-no-member&quot;</span>
<span class="gi">+            hint = &quot;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = &quot;no-member&quot;</span>
<span class="gi">+            if self.linter.config.missing_member_hint:</span>
<span class="gi">+                hint = _missing_member_hint(</span>
<span class="gi">+                    owner,</span>
<span class="gi">+                    node.attrname,</span>
<span class="gi">+                    self.linter.config.missing_member_hint_distance,</span>
<span class="gi">+                    self.linter.config.missing_member_max_choices,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                hint = &quot;&quot;</span>
<span class="gi">+        return msg, hint  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;assignment-from-no-return&quot;,</span>
<span class="gi">+        &quot;assignment-from-none&quot;,</span>
<span class="gi">+        &quot;non-str-assignment-to-dunder-name&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process assignments in the AST.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_assignment_from_function_call(node)</span>
<span class="gi">+        self._check_dundername_is_string(node)</span>

<span class="gd">-    def _check_assignment_from_function_call(self, node: nodes.Assign) -&gt;None:</span>
<span class="gi">+    def _check_assignment_from_function_call(self, node: nodes.Assign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;When assigning to a function call, check that the function returns a valid
<span class="w"> </span>        value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.value, nodes.Call):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        function_node = safe_infer(node.value.func)</span>
<span class="gi">+        funcs = (nodes.FunctionDef, astroid.UnboundMethod, astroid.BoundMethod)</span>
<span class="gi">+        if not isinstance(function_node, funcs):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Unwrap to get the actual function node object</span>
<span class="gi">+        if isinstance(function_node, astroid.BoundMethod) and isinstance(</span>
<span class="gi">+            function_node._proxied, astroid.UnboundMethod</span>
<span class="gi">+        ):</span>
<span class="gi">+            function_node = function_node._proxied._proxied</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure that it&#39;s a valid function that we can analyze.</span>
<span class="gi">+        # Ordered from less expensive to more expensive checks.</span>
<span class="gi">+        if (</span>
<span class="gi">+            not function_node.is_function</span>
<span class="gi">+            or function_node.decorators</span>
<span class="gi">+            or self._is_ignored_function(function_node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Handle builtins such as list.sort() or dict.update()</span>
<span class="gi">+        if self._is_builtin_no_return(node):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;assignment-from-no-return&quot;, node=node, confidence=INFERENCE</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not function_node.root().fully_defined():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        return_nodes = list(</span>
<span class="gi">+            function_node.nodes_of_class(nodes.Return, skip_klass=nodes.FunctionDef)</span>
<span class="gi">+        )</span>
<span class="gi">+        if not return_nodes:</span>
<span class="gi">+            self.add_message(&quot;assignment-from-no-return&quot;, node=node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for ret_node in return_nodes:</span>
<span class="gi">+                if not (</span>
<span class="gi">+                    isinstance(ret_node.value, nodes.Const)</span>
<span class="gi">+                    and ret_node.value.value is None</span>
<span class="gi">+                    or ret_node.value is None</span>
<span class="gi">+                ):</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.add_message(&quot;assignment-from-none&quot;, node=node)</span>

<span class="gd">-    def _check_dundername_is_string(self, node: nodes.Assign) -&gt;None:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_ignored_function(</span>
<span class="gi">+        function_node: nodes.FunctionDef | bases.UnboundMethod,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(function_node, nodes.AsyncFunctionDef)</span>
<span class="gi">+            or utils.is_error(function_node)</span>
<span class="gi">+            or function_node.is_generator()</span>
<span class="gi">+            or function_node.is_abstract(pass_is_abstract=False)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_builtin_no_return(node: nodes.Assign) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(node.value, nodes.Call)</span>
<span class="gi">+            and isinstance(node.value.func, nodes.Attribute)</span>
<span class="gi">+            and bool(inferred := utils.safe_infer(node.value.func.expr))</span>
<span class="gi">+            and isinstance(inferred, bases.Instance)</span>
<span class="gi">+            and node.value.func.attrname</span>
<span class="gi">+            in BUILTINS_IMPLICIT_RETURN_NONE.get(inferred.pytype(), ())</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_dundername_is_string(self, node: nodes.Assign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check a string is assigned to self.__name__.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check the left-hand side of the assignment is &lt;something&gt;.__name__</span>
<span class="gi">+        lhs = node.targets[0]</span>
<span class="gi">+        if not isinstance(lhs, nodes.AssignAttr):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not lhs.attrname == &quot;__name__&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # If the right-hand side is not a string</span>
<span class="gi">+        rhs = node.value</span>
<span class="gi">+        if isinstance(rhs, nodes.Const) and isinstance(rhs.value, str):</span>
<span class="gi">+            return</span>
<span class="gi">+        inferred = utils.safe_infer(rhs)</span>
<span class="gi">+        if not inferred:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not (isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)):</span>
<span class="gi">+            # Add the message</span>
<span class="gi">+            self.add_message(&quot;non-str-assignment-to-dunder-name&quot;, node=node)</span>

<span class="gd">-    def _check_uninferable_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+    def _check_uninferable_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that the given uninferable Call node does not
<span class="w"> </span>        call an actual function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.func, nodes.Attribute):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Look for properties. First, obtain</span>
<span class="gi">+        # the lhs of the Attribute node and search the attribute</span>
<span class="gi">+        # there. If that attribute is a property or a subclass of properties,</span>
<span class="gi">+        # then most likely it&#39;s not callable.</span>

<span class="gd">-    def _check_argument_order(self, node: nodes.Call, call_site: arguments.</span>
<span class="gd">-        CallSite, called: CallableObjects, called_param_names: list[str | None]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        expr = node.func.expr</span>
<span class="gi">+        klass = safe_infer(expr)</span>
<span class="gi">+        if not isinstance(klass, astroid.Instance):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            attrs = klass._proxied.getattr(node.func.attrname)</span>
<span class="gi">+        except astroid.NotFoundError:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for attr in attrs:</span>
<span class="gi">+            if not isinstance(attr, nodes.FunctionDef):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Decorated, see if it is decorated with a property.</span>
<span class="gi">+            # Also, check the returns and see if they are callable.</span>
<span class="gi">+            if decorated_with_property(attr):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    call_results = list(attr.infer_call_result(node))</span>
<span class="gi">+                except astroid.InferenceError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if all(</span>
<span class="gi">+                    isinstance(return_node, util.UninferableBase)</span>
<span class="gi">+                    for return_node in call_results</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # We were unable to infer return values of the call, skipping</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if any(return_node.callable() for return_node in call_results):</span>
<span class="gi">+                    # Only raise this issue if *all* the inferred values are not callable</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                self.add_message(&quot;not-callable&quot;, node=node, args=node.func.as_string())</span>
<span class="gi">+</span>
<span class="gi">+    def _check_argument_order(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Call,</span>
<span class="gi">+        call_site: arguments.CallSite,</span>
<span class="gi">+        called: CallableObjects,</span>
<span class="gi">+        called_param_names: list[str | None],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Match the supplied argument names against the function parameters.

<span class="w"> </span>        Warn if some argument names are not in the same order as they are in
<span class="w"> </span>        the function signature.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check for called function being an object instance function</span>
<span class="gi">+        # If so, ignore the initial &#39;self&#39; argument in the signature</span>
<span class="gi">+        try:</span>
<span class="gi">+            is_classdef = isinstance(called.parent, nodes.ClassDef)</span>
<span class="gi">+            if is_classdef and called_param_names[0] == &quot;self&quot;:</span>
<span class="gi">+                called_param_names = called_param_names[1:]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return</span>

<span class="gd">-    def visit_call(self, node: nodes.Call) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # extract argument names, if they have names</span>
<span class="gi">+            calling_parg_names = [p.name for p in call_site.positional_arguments]</span>
<span class="gi">+</span>
<span class="gi">+            # Additionally, get names of keyword arguments to use in a full match</span>
<span class="gi">+            # against parameters</span>
<span class="gi">+            calling_kwarg_names = [</span>
<span class="gi">+                arg.name for arg in call_site.keyword_arguments.values()</span>
<span class="gi">+            ]</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # the type of arg does not provide a `.name`. In this case we</span>
<span class="gi">+            # stop checking for out-of-order arguments because it is only relevant</span>
<span class="gi">+            # for named variables.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t check for ordering if there is an unmatched arg or param</span>
<span class="gi">+        arg_set = set(calling_parg_names) | set(calling_kwarg_names)</span>
<span class="gi">+        param_set = set(called_param_names)</span>
<span class="gi">+        if arg_set != param_set:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Warn based on the equality of argument ordering</span>
<span class="gi">+        if calling_parg_names != called_param_names[: len(calling_parg_names)]:</span>
<span class="gi">+            self.add_message(&quot;arguments-out-of-order&quot;, node=node, args=())</span>
<span class="gi">+</span>
<span class="gi">+    def _check_isinstance_args(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if len(node.args) != 2:</span>
<span class="gi">+            # isinstance called with wrong number of args</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        second_arg = node.args[1]</span>
<span class="gi">+        if _is_invalid_isinstance_type(second_arg):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;isinstance-second-argument-not-valid-type&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-branches, too-many-locals, too-many-statements</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that called functions/methods are inferred to callable objects,
<span class="w"> </span>        and that passed arguments match the parameters in the inferred function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        called = safe_infer(node.func, compare_constructors=True)</span>
<span class="gi">+</span>
<span class="gi">+        self._check_not_callable(node, called)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            called, implicit_args, callable_name = _determine_callable(called)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            # Any error occurred during determining the function type, most of</span>
<span class="gi">+            # those errors are handled by different warnings.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if called.args.args is None:</span>
<span class="gi">+            if called.name == &quot;isinstance&quot;:</span>
<span class="gi">+                # Verify whether second argument of isinstance is a valid type</span>
<span class="gi">+                self._check_isinstance_args(node)</span>
<span class="gi">+            # Built-in functions have no argument information.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if len(called.argnames()) != len(set(called.argnames())):</span>
<span class="gi">+            # Duplicate parameter name (see duplicate-argument).  We can&#39;t really</span>
<span class="gi">+            # make sense of the function call in this case, so just return.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Build the set of keyword arguments, checking for duplicate keywords,</span>
<span class="gi">+        # and count the positional arguments.</span>
<span class="gi">+        call_site = astroid.arguments.CallSite.from_call(node)</span>
<span class="gi">+</span>
<span class="gi">+        # Warn about duplicated keyword arguments, such as `f=24, **{&#39;f&#39;: 24}`</span>
<span class="gi">+        for keyword in call_site.duplicated_keywords:</span>
<span class="gi">+            self.add_message(&quot;repeated-keyword&quot;, node=node, args=(keyword,))</span>
<span class="gi">+</span>
<span class="gi">+        if call_site.has_invalid_arguments() or call_site.has_invalid_keywords():</span>
<span class="gi">+            # Can&#39;t make sense of this.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Has the function signature changed in ways we cannot reliably detect?</span>
<span class="gi">+        if hasattr(called, &quot;decorators&quot;) and decorated_with(</span>
<span class="gi">+            called, self.linter.config.signature_mutators</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        num_positional_args = len(call_site.positional_arguments)</span>
<span class="gi">+        keyword_args = list(call_site.keyword_arguments.keys())</span>
<span class="gi">+        overload_function = is_overload_stub(called)</span>
<span class="gi">+</span>
<span class="gi">+        # Determine if we don&#39;t have a context for our call and we use variadics.</span>
<span class="gi">+        node_scope = node.scope()</span>
<span class="gi">+        if isinstance(node_scope, (nodes.Lambda, nodes.FunctionDef)):</span>
<span class="gi">+            has_no_context_positional_variadic = _no_context_variadic_positional(</span>
<span class="gi">+                node, node_scope</span>
<span class="gi">+            )</span>
<span class="gi">+            has_no_context_keywords_variadic = _no_context_variadic_keywords(</span>
<span class="gi">+                node, node_scope</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            has_no_context_positional_variadic = has_no_context_keywords_variadic = (</span>
<span class="gi">+                False</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # These are coming from the functools.partial implementation in astroid</span>
<span class="gi">+        already_filled_positionals = getattr(called, &quot;filled_positionals&quot;, 0)</span>
<span class="gi">+        already_filled_keywords = getattr(called, &quot;filled_keywords&quot;, {})</span>
<span class="gi">+</span>
<span class="gi">+        keyword_args += list(already_filled_keywords)</span>
<span class="gi">+        num_positional_args += implicit_args + already_filled_positionals</span>
<span class="gi">+</span>
<span class="gi">+        # Decrement `num_positional_args` by 1 when a function call is assigned to a class attribute</span>
<span class="gi">+        # inside the class where the function is defined.</span>
<span class="gi">+        # This avoids emitting `too-many-function-args` since `num_positional_args`</span>
<span class="gi">+        # includes an implicit `self` argument which is not present in `called.args`.</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.frame(), nodes.ClassDef)</span>
<span class="gi">+            and isinstance(called, nodes.FunctionDef)</span>
<span class="gi">+            and called in node.frame().body</span>
<span class="gi">+            and num_positional_args &gt; 0</span>
<span class="gi">+            and &quot;builtins.staticmethod&quot; not in called.decoratornames()</span>
<span class="gi">+        ):</span>
<span class="gi">+            num_positional_args -= 1</span>
<span class="gi">+</span>
<span class="gi">+        # Analyze the list of formal parameters.</span>
<span class="gi">+        args = list(itertools.chain(called.args.posonlyargs or (), called.args.args))</span>
<span class="gi">+        num_mandatory_parameters = len(args) - len(called.args.defaults)</span>
<span class="gi">+        parameters: list[tuple[tuple[str | None, nodes.NodeNG | None], bool]] = []</span>
<span class="gi">+        parameter_name_to_index = {}</span>
<span class="gi">+        for i, arg in enumerate(args):</span>
<span class="gi">+            name = arg.name</span>
<span class="gi">+            parameter_name_to_index[name] = i</span>
<span class="gi">+            if i &gt;= num_mandatory_parameters:</span>
<span class="gi">+                defval = called.args.defaults[i - num_mandatory_parameters]</span>
<span class="gi">+            else:</span>
<span class="gi">+                defval = None</span>
<span class="gi">+            parameters.append(((name, defval), False))</span>
<span class="gi">+</span>
<span class="gi">+        kwparams = {}</span>
<span class="gi">+        for i, arg in enumerate(called.args.kwonlyargs):</span>
<span class="gi">+            if isinstance(arg, nodes.Keyword):</span>
<span class="gi">+                name = arg.arg</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert isinstance(arg, nodes.AssignName)</span>
<span class="gi">+                name = arg.name</span>
<span class="gi">+            kwparams[name] = [called.args.kw_defaults[i], False]</span>
<span class="gi">+</span>
<span class="gi">+        self._check_argument_order(</span>
<span class="gi">+            node, call_site, called, [p[0][0] for p in parameters]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # 1. Match the positional arguments.</span>
<span class="gi">+        for i in range(num_positional_args):</span>
<span class="gi">+            if i &lt; len(parameters):</span>
<span class="gi">+                parameters[i] = (parameters[i][0], True)</span>
<span class="gi">+            elif called.args.vararg is not None:</span>
<span class="gi">+                # The remaining positional arguments get assigned to the *args</span>
<span class="gi">+                # parameter.</span>
<span class="gi">+                break</span>
<span class="gi">+            elif not overload_function:</span>
<span class="gi">+                # Too many positional arguments.</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;too-many-function-args&quot;, node=node, args=(callable_name,)</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        # 2. Match the keyword arguments.</span>
<span class="gi">+        for keyword in keyword_args:</span>
<span class="gi">+            # Skip if `keyword` is the same name as a positional-only parameter</span>
<span class="gi">+            # and a `**kwargs` parameter exists.</span>
<span class="gi">+            if called.args.kwarg and keyword in [</span>
<span class="gi">+                arg.name for arg in called.args.posonlyargs</span>
<span class="gi">+            ]:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;kwarg-superseded-by-positional-arg&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(keyword, f&quot;**{called.args.kwarg}&quot;),</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+                continue</span>
<span class="gi">+            if keyword in parameter_name_to_index:</span>
<span class="gi">+                i = parameter_name_to_index[keyword]</span>
<span class="gi">+                if parameters[i][1]:</span>
<span class="gi">+                    # Duplicate definition of function parameter.</span>
<span class="gi">+</span>
<span class="gi">+                    # Might be too hard-coded, but this can actually</span>
<span class="gi">+                    # happen when using str.format and `self` is passed</span>
<span class="gi">+                    # by keyword argument, as in `.format(self=self)`.</span>
<span class="gi">+                    # It&#39;s perfectly valid to so, so we&#39;re just skipping</span>
<span class="gi">+                    # it if that&#39;s the case.</span>
<span class="gi">+                    if not (keyword == &quot;self&quot; and called.qname() in STR_FORMAT):</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;redundant-keyword-arg&quot;,</span>
<span class="gi">+                            node=node,</span>
<span class="gi">+                            args=(keyword, callable_name),</span>
<span class="gi">+                        )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    parameters[i] = (parameters[i][0], True)</span>
<span class="gi">+            elif keyword in kwparams:</span>
<span class="gi">+                if kwparams[keyword][1]:</span>
<span class="gi">+                    # Duplicate definition of function parameter.</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;redundant-keyword-arg&quot;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=(keyword, callable_name),</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    kwparams[keyword][1] = True</span>
<span class="gi">+            elif called.args.kwarg is not None:</span>
<span class="gi">+                # The keyword argument gets assigned to the **kwargs parameter.</span>
<span class="gi">+                pass</span>
<span class="gi">+            elif isinstance(</span>
<span class="gi">+                called, nodes.FunctionDef</span>
<span class="gi">+            ) and self._keyword_argument_is_in_all_decorator_returns(called, keyword):</span>
<span class="gi">+                pass</span>
<span class="gi">+            elif not overload_function:</span>
<span class="gi">+                # Unexpected keyword argument.</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;unexpected-keyword-arg&quot;, node=node, args=(keyword, callable_name)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        # 3. Match the **kwargs, if any.</span>
<span class="gi">+        if node.kwargs:</span>
<span class="gi">+            for i, [(name, _defval), _assigned] in enumerate(parameters):</span>
<span class="gi">+                # Assume that *kwargs provides values for all remaining</span>
<span class="gi">+                # unassigned named parameters.</span>
<span class="gi">+                if name is not None:</span>
<span class="gi">+                    parameters[i] = (parameters[i][0], True)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # **kwargs can&#39;t assign to tuples.</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+        # Check that any parameters without a default have been assigned</span>
<span class="gi">+        # values.</span>
<span class="gi">+        for [(name, defval), assigned] in parameters:</span>
<span class="gi">+            if (defval is None) and not assigned:</span>
<span class="gi">+                display_name = &quot;&lt;tuple&gt;&quot; if name is None else repr(name)</span>
<span class="gi">+                if not has_no_context_positional_variadic and not overload_function:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;no-value-for-parameter&quot;,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        args=(display_name, callable_name),</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+        for name, val in kwparams.items():</span>
<span class="gi">+            defval, assigned = val</span>
<span class="gi">+            if (</span>
<span class="gi">+                defval is None</span>
<span class="gi">+                and not assigned</span>
<span class="gi">+                and not has_no_context_keywords_variadic</span>
<span class="gi">+                and not overload_function</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;missing-kwoa&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(name, callable_name),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _keyword_argument_is_in_all_decorator_returns(func: nodes.</span>
<span class="gd">-        FunctionDef, keyword: str) -&gt;bool:</span>
<span class="gi">+    def _keyword_argument_is_in_all_decorator_returns(</span>
<span class="gi">+        func: nodes.FunctionDef, keyword: str</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the keyword argument exists in all signatures of the
<span class="w"> </span>        return values of all decorators of the function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not func.decorators:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        for decorator in func.decorators.nodes:</span>
<span class="gi">+            inferred = safe_infer(decorator)</span>
<span class="gi">+</span>
<span class="gi">+            # If we can&#39;t infer the decorator we assume it satisfies consumes</span>
<span class="gi">+            # the keyword, so we don&#39;t raise false positives</span>
<span class="gi">+            if not inferred:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+            # We only check arguments of function decorators</span>
<span class="gi">+            if not isinstance(inferred, nodes.FunctionDef):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            for return_value in inferred.infer_call_result(caller=None):</span>
<span class="gi">+                # infer_call_result() returns nodes.Const.None for None return values</span>
<span class="gi">+                # so this also catches non-returning decorators</span>
<span class="gi">+                if not isinstance(return_value, nodes.FunctionDef):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+                # If the return value uses a kwarg the keyword will be consumed</span>
<span class="gi">+                if return_value.args.kwarg:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # Check if the keyword is another type of argument</span>
<span class="gi">+                if return_value.args.is_argument(keyword):</span>
<span class="gi">+                    continue</span>

<span class="gd">-    def _check_not_callable(self, node: nodes.Call, inferred_call: (nodes.</span>
<span class="gd">-        NodeNG | None)) -&gt;None:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def _check_invalid_sequence_index(self, subscript: nodes.Subscript) -&gt; None:</span>
<span class="gi">+        # Look for index operations where the parent is a sequence type.</span>
<span class="gi">+        # If the types can be determined, only allow indices to be int,</span>
<span class="gi">+        # slice or instances with __index__.</span>
<span class="gi">+        parent_type = safe_infer(subscript.value)</span>
<span class="gi">+        if not isinstance(</span>
<span class="gi">+            parent_type, (nodes.ClassDef, astroid.Instance)</span>
<span class="gi">+        ) or not has_known_bases(parent_type):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # Determine what method on the parent this index will use</span>
<span class="gi">+        # The parent of this node will be a Subscript, and the parent of that</span>
<span class="gi">+        # node determines if the Subscript is a get, set, or delete operation.</span>
<span class="gi">+        if subscript.ctx is astroid.Context.Store:</span>
<span class="gi">+            methodname = &quot;__setitem__&quot;</span>
<span class="gi">+        elif subscript.ctx is astroid.Context.Del:</span>
<span class="gi">+            methodname = &quot;__delitem__&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            methodname = &quot;__getitem__&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Check if this instance&#39;s __getitem__, __setitem__, or __delitem__, as</span>
<span class="gi">+        # appropriate to the statement, is implemented in a builtin sequence</span>
<span class="gi">+        # type. This way we catch subclasses of sequence types but skip classes</span>
<span class="gi">+        # that override __getitem__ and which may allow non-integer indices.</span>
<span class="gi">+        try:</span>
<span class="gi">+            methods = astroid.interpreter.dunder_lookup.lookup(parent_type, methodname)</span>
<span class="gi">+            if isinstance(methods, util.UninferableBase):</span>
<span class="gi">+                return None</span>
<span class="gi">+            itemmethod = methods[0]</span>
<span class="gi">+        except (</span>
<span class="gi">+            astroid.AttributeInferenceError,</span>
<span class="gi">+            IndexError,</span>
<span class="gi">+        ):</span>
<span class="gi">+            return None</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(itemmethod, nodes.FunctionDef)</span>
<span class="gi">+            or itemmethod.root().name != &quot;builtins&quot;</span>
<span class="gi">+            or not itemmethod.parent</span>
<span class="gi">+            or itemmethod.parent.frame().name not in SEQUENCE_TYPES</span>
<span class="gi">+        ):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        index_type = safe_infer(subscript.slice)</span>
<span class="gi">+        if index_type is None or isinstance(index_type, util.UninferableBase):</span>
<span class="gi">+            return None</span>
<span class="gi">+        # Constants must be of type int</span>
<span class="gi">+        if isinstance(index_type, nodes.Const):</span>
<span class="gi">+            if isinstance(index_type.value, int):</span>
<span class="gi">+                return None</span>
<span class="gi">+        # Instance values must be int, slice, or have an __index__ method</span>
<span class="gi">+        elif isinstance(index_type, astroid.Instance):</span>
<span class="gi">+            if index_type.pytype() in {&quot;builtins.int&quot;, &quot;builtins.slice&quot;}:</span>
<span class="gi">+                return None</span>
<span class="gi">+            try:</span>
<span class="gi">+                index_type.getattr(&quot;__index__&quot;)</span>
<span class="gi">+                return None</span>
<span class="gi">+            except astroid.NotFoundError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        elif isinstance(index_type, nodes.Slice):</span>
<span class="gi">+            # A slice can be present</span>
<span class="gi">+            # here after inferring the index node, which could</span>
<span class="gi">+            # be a `slice(...)` call for instance.</span>
<span class="gi">+            return self._check_invalid_slice_index(index_type)</span>
<span class="gi">+</span>
<span class="gi">+        # Anything else is an error</span>
<span class="gi">+        self.add_message(&quot;invalid-sequence-index&quot;, node=subscript)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _check_not_callable(</span>
<span class="gi">+        self, node: nodes.Call, inferred_call: nodes.NodeNG | None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks to see if the not-callable message should be emitted.

<span class="w"> </span>        Only functions, generators and objects defining __call__ are &quot;callable&quot;
<span class="w"> </span>        We ignore instances of descriptors since astroid cannot properly handle them yet
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Handle uninferable calls</span>
<span class="gi">+        if not inferred_call or inferred_call.callable():</span>
<span class="gi">+            self._check_uninferable_call(node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(inferred_call, astroid.Instance):</span>
<span class="gi">+            self.add_message(&quot;not-callable&quot;, node=node, args=node.func.as_string())</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t emit if we can&#39;t make sure this object is callable.</span>
<span class="gi">+        if not has_known_bases(inferred_call):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if inferred_call.parent and isinstance(inferred_call.scope(), nodes.ClassDef):</span>
<span class="gi">+            # Ignore descriptor instances</span>
<span class="gi">+            if &quot;__get__&quot; in inferred_call.locals:</span>
<span class="gi">+                return</span>
<span class="gi">+            # NamedTuple instances are callable</span>
<span class="gi">+            if inferred_call.qname() == &quot;typing.NamedTuple&quot;:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;not-callable&quot;, node=node, args=node.func.as_string())</span>
<span class="gi">+</span>
<span class="gi">+    def _check_invalid_slice_index(self, node: nodes.Slice) -&gt; None:</span>
<span class="gi">+        # Check the type of each part of the slice</span>
<span class="gi">+        invalid_slices_nodes: list[nodes.NodeNG] = []</span>
<span class="gi">+        for index in (node.lower, node.upper, node.step):</span>
<span class="gi">+            if index is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            index_type = safe_infer(index)</span>
<span class="gi">+            if index_type is None or isinstance(index_type, util.UninferableBase):</span>
<span class="gi">+                continue</span>

<span class="gd">-    @only_required_for_messages(&#39;invalid-unary-operand-type&#39;)</span>
<span class="gd">-    def visit_unaryop(self, node: nodes.UnaryOp) -&gt;None:</span>
<span class="gi">+            # Constants must be of type int or None</span>
<span class="gi">+            if isinstance(index_type, nodes.Const):</span>
<span class="gi">+                if isinstance(index_type.value, (int, type(None))):</span>
<span class="gi">+                    continue</span>
<span class="gi">+            # Instance values must be of type int, None or an object</span>
<span class="gi">+            # with __index__</span>
<span class="gi">+            elif isinstance(index_type, astroid.Instance):</span>
<span class="gi">+                if index_type.pytype() in {&quot;builtins.int&quot;, &quot;builtins.NoneType&quot;}:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    index_type.getattr(&quot;__index__&quot;)</span>
<span class="gi">+                    return</span>
<span class="gi">+                except astroid.NotFoundError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+            invalid_slices_nodes.append(index)</span>
<span class="gi">+</span>
<span class="gi">+        invalid_slice_step = (</span>
<span class="gi">+            node.step and isinstance(node.step, nodes.Const) and node.step.value == 0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if not (invalid_slices_nodes or invalid_slice_step):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Anything else is an error, unless the object that is indexed</span>
<span class="gi">+        # is a custom object, which knows how to handle this kind of slices</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        if isinstance(parent, nodes.Subscript):</span>
<span class="gi">+            inferred = safe_infer(parent.value)</span>
<span class="gi">+            if inferred is None or isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+                # Don&#39;t know what this is</span>
<span class="gi">+                return</span>
<span class="gi">+            known_objects = (</span>
<span class="gi">+                nodes.List,</span>
<span class="gi">+                nodes.Dict,</span>
<span class="gi">+                nodes.Tuple,</span>
<span class="gi">+                astroid.objects.FrozenSet,</span>
<span class="gi">+                nodes.Set,</span>
<span class="gi">+            )</span>
<span class="gi">+            if not (</span>
<span class="gi">+                isinstance(inferred, known_objects)</span>
<span class="gi">+                or isinstance(inferred, nodes.Const)</span>
<span class="gi">+                and inferred.pytype() in {&quot;builtins.str&quot;, &quot;builtins.bytes&quot;}</span>
<span class="gi">+                or isinstance(inferred, astroid.bases.Instance)</span>
<span class="gi">+                and inferred.pytype() == &quot;builtins.range&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Might be an instance that knows how to handle this slice object</span>
<span class="gi">+                return</span>
<span class="gi">+        for snode in invalid_slices_nodes:</span>
<span class="gi">+            self.add_message(&quot;invalid-slice-index&quot;, node=snode)</span>
<span class="gi">+        if invalid_slice_step:</span>
<span class="gi">+            self.add_message(&quot;invalid-slice-step&quot;, node=node.step, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;not-context-manager&quot;)</span>
<span class="gi">+    def visit_with(self, node: nodes.With) -&gt; None:</span>
<span class="gi">+        for ctx_mgr, _ in node.items:</span>
<span class="gi">+            context = astroid.context.InferenceContext()</span>
<span class="gi">+            inferred = safe_infer(ctx_mgr, context=context)</span>
<span class="gi">+            if inferred is None or isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(inferred, astroid.bases.Generator):</span>
<span class="gi">+                # Check if we are dealing with a function decorated</span>
<span class="gi">+                # with contextlib.contextmanager.</span>
<span class="gi">+                if decorated_with(</span>
<span class="gi">+                    inferred.parent, self.linter.config.contextmanager_decorators</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # If the parent of the generator is not the context manager itself,</span>
<span class="gi">+                # that means that it could have been returned from another</span>
<span class="gi">+                # function which was the real context manager.</span>
<span class="gi">+                # The following approach is more of a hack rather than a real</span>
<span class="gi">+                # solution: walk all the inferred statements for the</span>
<span class="gi">+                # given *ctx_mgr* and if you find one function scope</span>
<span class="gi">+                # which is decorated, consider it to be the real</span>
<span class="gi">+                # manager and give up, otherwise emit not-context-manager.</span>
<span class="gi">+                # See the test file for not_context_manager for a couple</span>
<span class="gi">+                # of self explaining tests.</span>
<span class="gi">+</span>
<span class="gi">+                # Retrieve node from all previously visited nodes in the</span>
<span class="gi">+                # inference history</span>
<span class="gi">+                for inferred_path, _ in context.path:</span>
<span class="gi">+                    if not inferred_path:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if isinstance(inferred_path, nodes.Call):</span>
<span class="gi">+                        scope = safe_infer(inferred_path.func)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        scope = inferred_path.scope()</span>
<span class="gi">+                    if not isinstance(scope, nodes.FunctionDef):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if decorated_with(</span>
<span class="gi">+                        scope, self.linter.config.contextmanager_decorators</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;not-context-manager&quot;, node=node, args=(inferred.name,)</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    inferred.getattr(&quot;__enter__&quot;)</span>
<span class="gi">+                    inferred.getattr(&quot;__exit__&quot;)</span>
<span class="gi">+                except astroid.NotFoundError:</span>
<span class="gi">+                    if isinstance(inferred, astroid.Instance):</span>
<span class="gi">+                        # If we do not know the bases of this class,</span>
<span class="gi">+                        # just skip it.</span>
<span class="gi">+                        if not has_known_bases(inferred):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        # Just ignore mixin classes.</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            &quot;not-context-manager&quot;</span>
<span class="gi">+                            in self.linter.config.ignored_checks_for_mixins</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            if inferred.name[-5:].lower() == &quot;mixin&quot;:</span>
<span class="gi">+                                continue</span>
<span class="gi">+</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;not-context-manager&quot;, node=node, args=(inferred.name,)</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;invalid-unary-operand-type&quot;)</span>
<span class="gi">+    def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Detect TypeErrors for unary operands.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for error in node.type_errors():</span>
<span class="gi">+            # Let the error customize its output.</span>
<span class="gi">+            self.add_message(&quot;invalid-unary-operand-type&quot;, args=str(error), node=node)</span>

<span class="gd">-    def _detect_unsupported_alternative_union_syntax(self, node: nodes.BinOp</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;unsupported-binary-operation&quot;)</span>
<span class="gi">+    def visit_binop(self, node: nodes.BinOp) -&gt; None:</span>
<span class="gi">+        if node.op == &quot;|&quot;:</span>
<span class="gi">+            self._detect_unsupported_alternative_union_syntax(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _detect_unsupported_alternative_union_syntax(self, node: nodes.BinOp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Detect if unsupported alternative Union syntax (PEP 604) was used.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._py310_plus:  # 310+ supports the new syntax</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(</span>
<span class="gi">+            node.parent, TYPE_ANNOTATION_NODES_TYPES</span>
<span class="gi">+        ) and not is_postponed_evaluation_enabled(node):</span>
<span class="gi">+            # Use in type annotations only allowed if</span>
<span class="gi">+            # postponed evaluation is enabled.</span>
<span class="gi">+            self._check_unsupported_alternative_union_syntax(node)</span>

<span class="gd">-    def _includes_version_compatible_overload(self, attrs: list[nodes.NodeNG]</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+        if isinstance(</span>
<span class="gi">+            node.parent,</span>
<span class="gi">+            (</span>
<span class="gi">+                nodes.Assign,</span>
<span class="gi">+                nodes.Call,</span>
<span class="gi">+                nodes.Keyword,</span>
<span class="gi">+                nodes.Dict,</span>
<span class="gi">+                nodes.Tuple,</span>
<span class="gi">+                nodes.Set,</span>
<span class="gi">+                nodes.List,</span>
<span class="gi">+                nodes.BinOp,</span>
<span class="gi">+            ),</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Check other contexts the syntax might appear, but are invalid.</span>
<span class="gi">+            # Make sure to filter context if postponed evaluation is enabled</span>
<span class="gi">+            # and parent is allowed node type.</span>
<span class="gi">+            allowed_nested_syntax = False</span>
<span class="gi">+            if is_postponed_evaluation_enabled(node):</span>
<span class="gi">+                parent_node = node.parent</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    if isinstance(parent_node, TYPE_ANNOTATION_NODES_TYPES):</span>
<span class="gi">+                        allowed_nested_syntax = True</span>
<span class="gi">+                        break</span>
<span class="gi">+                    parent_node = parent_node.parent</span>
<span class="gi">+                    if isinstance(parent_node, nodes.Module):</span>
<span class="gi">+                        break</span>
<span class="gi">+            if not allowed_nested_syntax:</span>
<span class="gi">+                self._check_unsupported_alternative_union_syntax(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _includes_version_compatible_overload(self, attrs: list[nodes.NodeNG]) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a set of overloads of an operator includes one that
<span class="w"> </span>        can be relied upon for our configured Python version.

<span class="gu">@@ -367,27 +1983,224 @@ class TypeChecker(BaseChecker):</span>
<span class="w"> </span>        existence of __or__ / __ror__ on builtins.type, but these aren&#39;t
<span class="w"> </span>        available in the configured version of Python.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        is_py310_builtin = all(</span>
<span class="gi">+            isinstance(attr, (nodes.FunctionDef, astroid.BoundMethod))</span>
<span class="gi">+            and attr.parent.qname() == &quot;builtins.type&quot;</span>
<span class="gi">+            for attr in attrs</span>
<span class="gi">+        )</span>
<span class="gi">+        return not is_py310_builtin or self._py310_plus</span>
<span class="gi">+</span>
<span class="gi">+    def _recursive_search_for_classdef_type(</span>
<span class="gi">+        self, node: nodes.ClassDef, operation: Literal[&quot;__or__&quot;, &quot;__ror__&quot;]</span>
<span class="gi">+    ) -&gt; bool | VERSION_COMPATIBLE_OVERLOAD:</span>
<span class="gi">+        if not isinstance(node, nodes.ClassDef):</span>
<span class="gi">+            return False</span>
<span class="gi">+        try:</span>
<span class="gi">+            attrs = node.getattr(operation)</span>
<span class="gi">+        except astroid.NotFoundError:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if self._includes_version_compatible_overload(attrs):</span>
<span class="gi">+            return VERSION_COMPATIBLE_OVERLOAD_SENTINEL</span>
<span class="gi">+        return True</span>

<span class="gd">-    def _check_unsupported_alternative_union_syntax(self, node: nodes.BinOp</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _check_unsupported_alternative_union_syntax(self, node: nodes.BinOp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if left or right node is of type `type`.

<span class="w"> </span>        If either is, and doesn&#39;t support an or operator via a metaclass,
<span class="w"> </span>        infer that this is a mistaken attempt to use alternative union
<span class="w"> </span>        syntax when not supported.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        msg = &quot;unsupported operand type(s) for |&quot;</span>
<span class="gi">+        left_obj = astroid.helpers.object_type(node.left)</span>
<span class="gi">+        right_obj = astroid.helpers.object_type(node.right)</span>
<span class="gi">+        left_is_type = self._recursive_search_for_classdef_type(left_obj, &quot;__or__&quot;)</span>
<span class="gi">+        if left_is_type is VERSION_COMPATIBLE_OVERLOAD_SENTINEL:</span>
<span class="gi">+            return</span>
<span class="gi">+        right_is_type = self._recursive_search_for_classdef_type(right_obj, &quot;__ror__&quot;)</span>
<span class="gi">+        if right_is_type is VERSION_COMPATIBLE_OVERLOAD_SENTINEL:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if left_is_type or right_is_type:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unsupported-binary-operation&quot;,</span>
<span class="gi">+                args=msg,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>

<span class="gd">-    @only_required_for_messages(&#39;unsupported-binary-operation&#39;)</span>
<span class="gd">-    def _visit_binop(self, node: nodes.BinOp) -&gt;None:</span>
<span class="gi">+    # TODO: This check was disabled (by adding the leading underscore)</span>
<span class="gi">+    # due to false positives several years ago - can we re-enable it?</span>
<span class="gi">+    # https://github.com/pylint-dev/pylint/issues/6359</span>
<span class="gi">+    @only_required_for_messages(&quot;unsupported-binary-operation&quot;)</span>
<span class="gi">+    def _visit_binop(self, node: nodes.BinOp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Detect TypeErrors for binary arithmetic operands.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_binop_errors(node)</span>

<span class="gd">-    @only_required_for_messages(&#39;unsupported-binary-operation&#39;)</span>
<span class="gd">-    def _visit_augassign(self, node: nodes.AugAssign) -&gt;None:</span>
<span class="gi">+    # TODO: This check was disabled (by adding the leading underscore)</span>
<span class="gi">+    # due to false positives several years ago - can we re-enable it?</span>
<span class="gi">+    # https://github.com/pylint-dev/pylint/issues/6359</span>
<span class="gi">+    @only_required_for_messages(&quot;unsupported-binary-operation&quot;)</span>
<span class="gi">+    def _visit_augassign(self, node: nodes.AugAssign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Detect TypeErrors for augmented binary arithmetic operands.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_binop_errors(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_binop_errors(self, node: nodes.BinOp | nodes.AugAssign) -&gt; None:</span>
<span class="gi">+        for error in node.type_errors():</span>
<span class="gi">+            # Let the error customize its output.</span>
<span class="gi">+            if any(</span>
<span class="gi">+                isinstance(obj, nodes.ClassDef) and not has_known_bases(obj)</span>
<span class="gi">+                for obj in (error.left_type, error.right_type)</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.add_message(&quot;unsupported-binary-operation&quot;, args=str(error), node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_membership_test(self, node: nodes.NodeNG) -&gt; None:</span>
<span class="gi">+        if is_inside_abstract_class(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        if is_comprehension(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        inferred = safe_infer(node)</span>
<span class="gi">+        if inferred is None or isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not supports_membership_test(inferred):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unsupported-membership-test&quot;, args=node.as_string(), node=node</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;unsupported-membership-test&quot;)</span>
<span class="gi">+    def visit_compare(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        if len(node.ops) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        op, right = node.ops[0]</span>
<span class="gi">+        if op in {&quot;in&quot;, &quot;not in&quot;}:</span>
<span class="gi">+            self._check_membership_test(right)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;unhashable-member&quot;)</span>
<span class="gi">+    def visit_dict(self, node: nodes.Dict) -&gt; None:</span>
<span class="gi">+        for k, _ in node.items:</span>
<span class="gi">+            if not is_hashable(k):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;unhashable-member&quot;,</span>
<span class="gi">+                    node=k,</span>
<span class="gi">+                    args=(k.as_string(), &quot;key&quot;, &quot;dict&quot;),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;unhashable-member&quot;)</span>
<span class="gi">+    def visit_set(self, node: nodes.Set) -&gt; None:</span>
<span class="gi">+        for element in node.elts:</span>
<span class="gi">+            if not is_hashable(element):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;unhashable-member&quot;,</span>
<span class="gi">+                    node=element,</span>
<span class="gi">+                    args=(element.as_string(), &quot;member&quot;, &quot;set&quot;),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;unsubscriptable-object&quot;,</span>
<span class="gi">+        &quot;unsupported-assignment-operation&quot;,</span>
<span class="gi">+        &quot;unsupported-delete-operation&quot;,</span>
<span class="gi">+        &quot;unhashable-member&quot;,</span>
<span class="gi">+        &quot;invalid-sequence-index&quot;,</span>
<span class="gi">+        &quot;invalid-slice-index&quot;,</span>
<span class="gi">+        &quot;invalid-slice-step&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_subscript(self, node: nodes.Subscript) -&gt; None:</span>
<span class="gi">+        self._check_invalid_sequence_index(node)</span>
<span class="gi">+</span>
<span class="gi">+        supported_protocol: Callable[[Any, Any], bool] | None = None</span>
<span class="gi">+        if isinstance(node.value, (nodes.ListComp, nodes.DictComp)):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.value, nodes.Dict):</span>
<span class="gi">+            # Assert dict key is hashable</span>
<span class="gi">+            if not is_hashable(node.slice):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;unhashable-member&quot;,</span>
<span class="gi">+                    node=node.value,</span>
<span class="gi">+                    args=(node.slice.as_string(), &quot;key&quot;, &quot;dict&quot;),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if node.ctx == astroid.Context.Load:</span>
<span class="gi">+            supported_protocol = supports_getitem</span>
<span class="gi">+            msg = &quot;unsubscriptable-object&quot;</span>
<span class="gi">+        elif node.ctx == astroid.Context.Store:</span>
<span class="gi">+            supported_protocol = supports_setitem</span>
<span class="gi">+            msg = &quot;unsupported-assignment-operation&quot;</span>
<span class="gi">+        elif node.ctx == astroid.Context.Del:</span>
<span class="gi">+            supported_protocol = supports_delitem</span>
<span class="gi">+            msg = &quot;unsupported-delete-operation&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.value, nodes.SetComp):</span>
<span class="gi">+            self.add_message(msg, args=node.value.as_string(), node=node.value)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if is_inside_abstract_class(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        inferred = safe_infer(node.value)</span>
<span class="gi">+</span>
<span class="gi">+        if inferred is None or isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if getattr(inferred, &quot;decorators&quot;, None):</span>
<span class="gi">+            first_decorator = astroid.util.safe_infer(inferred.decorators.nodes[0])</span>
<span class="gi">+            if isinstance(first_decorator, nodes.ClassDef):</span>
<span class="gi">+                inferred = first_decorator.instantiate_class()</span>
<span class="gi">+            else:</span>
<span class="gi">+                return  # It would be better to handle function</span>
<span class="gi">+                # decorators, but let&#39;s start slow.</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            supported_protocol</span>
<span class="gi">+            and not supported_protocol(inferred, node)</span>
<span class="gi">+            and not utils.in_type_checking_block(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(msg, args=node.value.as_string(), node=node.value)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;dict-items-missing-iter&quot;)</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.target, nodes.Tuple):</span>
<span class="gi">+            # target is not a tuple</span>
<span class="gi">+            return</span>
<span class="gi">+        if not len(node.target.elts) == 2:</span>
<span class="gi">+            # target is not a tuple of two elements</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        iterable = node.iter</span>
<span class="gi">+        if not isinstance(iterable, nodes.Name):</span>
<span class="gi">+            # it&#39;s not a bare variable</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        inferred = safe_infer(iterable)</span>
<span class="gi">+        if not inferred:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(inferred, nodes.Dict):</span>
<span class="gi">+            # the iterable is not a dict</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if all(isinstance(i[0], nodes.Tuple) for i in inferred.items):</span>
<span class="gi">+            # if all keys are tuples</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;dict-iter-missing-items&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;await-outside-async&quot;)</span>
<span class="gi">+    def visit_await(self, node: nodes.Await) -&gt; None:</span>
<span class="gi">+        self._check_await_outside_coroutine(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_await_outside_coroutine(self, node: nodes.Await) -&gt; None:</span>
<span class="gi">+        node_scope = node.scope()</span>
<span class="gi">+        while not isinstance(node_scope, nodes.Module):</span>
<span class="gi">+            if isinstance(node_scope, nodes.AsyncFunctionDef):</span>
<span class="gi">+                return</span>
<span class="gi">+            if isinstance(node_scope, nodes.FunctionDef):</span>
<span class="gi">+                break</span>
<span class="gi">+            node_scope = node_scope.parent.scope()</span>
<span class="gi">+        self.add_message(&quot;await-outside-async&quot;, node=node)</span>


<span class="w"> </span>class IterableChecker(BaseChecker):
<span class="gu">@@ -401,12 +2214,105 @@ class IterableChecker(BaseChecker):</span>
<span class="w"> </span>    - generator expressions
<span class="w"> </span>    Also checks for non-mappings in function call kwargs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;typecheck&#39;</span>
<span class="gd">-    msgs = {&#39;E1133&#39;: (</span>
<span class="gd">-        &#39;Non-iterable value %s is used in an iterating context&#39;,</span>
<span class="gd">-        &#39;not-an-iterable&#39;,</span>
<span class="gd">-        &#39;Used when a non-iterable value is used in place where iterable is expected&#39;</span>
<span class="gd">-        ), &#39;E1134&#39;: (&#39;Non-mapping value %s is used in a mapping context&#39;,</span>
<span class="gd">-        &#39;not-a-mapping&#39;,</span>
<span class="gd">-        &#39;Used when a non-mapping value is used in place where mapping is expected&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;typecheck&quot;</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;E1133&quot;: (</span>
<span class="gi">+            &quot;Non-iterable value %s is used in an iterating context&quot;,</span>
<span class="gi">+            &quot;not-an-iterable&quot;,</span>
<span class="gi">+            &quot;Used when a non-iterable value is used in place where &quot;</span>
<span class="gi">+            &quot;iterable is expected&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E1134&quot;: (</span>
<span class="gi">+            &quot;Non-mapping value %s is used in a mapping context&quot;,</span>
<span class="gi">+            &quot;not-a-mapping&quot;,</span>
<span class="gi">+            &quot;Used when a non-mapping value is used in place where &quot;</span>
<span class="gi">+            &quot;mapping is expected&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_asyncio_coroutine(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        if not isinstance(node, nodes.Call):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        inferred_func = safe_infer(node.func)</span>
<span class="gi">+        if not isinstance(inferred_func, nodes.FunctionDef):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not inferred_func.decorators:</span>
<span class="gi">+            return False</span>
<span class="gi">+        for decorator in inferred_func.decorators.nodes:</span>
<span class="gi">+            inferred_decorator = safe_infer(decorator)</span>
<span class="gi">+            if not isinstance(inferred_decorator, nodes.FunctionDef):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if inferred_decorator.qname() != ASYNCIO_COROUTINE:</span>
<span class="gi">+                continue</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _check_iterable(self, node: nodes.NodeNG, check_async: bool = False) -&gt; None:</span>
<span class="gi">+        if is_inside_abstract_class(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        inferred = safe_infer(node)</span>
<span class="gi">+        if not inferred or is_comprehension(inferred):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not is_iterable(inferred, check_async=check_async):</span>
<span class="gi">+            self.add_message(&quot;not-an-iterable&quot;, args=node.as_string(), node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_mapping(self, node: nodes.NodeNG) -&gt; None:</span>
<span class="gi">+        if is_inside_abstract_class(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node, nodes.DictComp):</span>
<span class="gi">+            return</span>
<span class="gi">+        inferred = safe_infer(node)</span>
<span class="gi">+        if inferred is None or isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not is_mapping(inferred):</span>
<span class="gi">+            self.add_message(&quot;not-a-mapping&quot;, args=node.as_string(), node=node)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;not-an-iterable&quot;)</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        self._check_iterable(node.iter)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;not-an-iterable&quot;)</span>
<span class="gi">+    def visit_asyncfor(self, node: nodes.AsyncFor) -&gt; None:</span>
<span class="gi">+        self._check_iterable(node.iter, check_async=True)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;not-an-iterable&quot;)</span>
<span class="gi">+    def visit_yieldfrom(self, node: nodes.YieldFrom) -&gt; None:</span>
<span class="gi">+        if self._is_asyncio_coroutine(node.value):</span>
<span class="gi">+            return</span>
<span class="gi">+        self._check_iterable(node.value)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;not-an-iterable&quot;, &quot;not-a-mapping&quot;)</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        for stararg in node.starargs:</span>
<span class="gi">+            self._check_iterable(stararg.value)</span>
<span class="gi">+        for kwarg in node.kwargs:</span>
<span class="gi">+            self._check_mapping(kwarg.value)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;not-an-iterable&quot;)</span>
<span class="gi">+    def visit_listcomp(self, node: nodes.ListComp) -&gt; None:</span>
<span class="gi">+        for gen in node.generators:</span>
<span class="gi">+            self._check_iterable(gen.iter, check_async=gen.is_async)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;not-an-iterable&quot;)</span>
<span class="gi">+    def visit_dictcomp(self, node: nodes.DictComp) -&gt; None:</span>
<span class="gi">+        for gen in node.generators:</span>
<span class="gi">+            self._check_iterable(gen.iter, check_async=gen.is_async)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;not-an-iterable&quot;)</span>
<span class="gi">+    def visit_setcomp(self, node: nodes.SetComp) -&gt; None:</span>
<span class="gi">+        for gen in node.generators:</span>
<span class="gi">+            self._check_iterable(gen.iter, check_async=gen.is_async)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;not-an-iterable&quot;)</span>
<span class="gi">+    def visit_generatorexp(self, node: nodes.GeneratorExp) -&gt; None:</span>
<span class="gi">+        for gen in node.generators:</span>
<span class="gi">+            self._check_iterable(gen.iter, check_async=gen.is_async)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(TypeChecker(linter))</span>
<span class="gi">+    linter.register_checker(IterableChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/unicode.py b/pylint/checkers/unicode.py</span>
<span class="gh">index b6fd71f21..c90ace971 100644</span>
<span class="gd">--- a/pylint/checkers/unicode.py</span>
<span class="gi">+++ b/pylint/checkers/unicode.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Unicode and some other ASCII characters can be used to create programs that run
<span class="w"> </span>much different compared to what a human reader would expect from them.

<span class="gu">@@ -6,7 +10,9 @@ See: https://www.python.org/dev/peps/pep-0672/</span>

<span class="w"> </span>The following checkers are intended to make users are aware of these issues.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import codecs
<span class="w"> </span>import contextlib
<span class="w"> </span>import io
<span class="gu">@@ -16,111 +22,261 @@ from collections.abc import Iterable</span>
<span class="w"> </span>from functools import lru_cache
<span class="w"> </span>from tokenize import detect_encoding
<span class="w"> </span>from typing import NamedTuple, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>import pylint.interfaces
<span class="w"> </span>import pylint.lint
<span class="w"> </span>from pylint import checkers
<span class="gd">-_StrLike = TypeVar(&#39;_StrLike&#39;, str, bytes)</span>
<span class="gd">-BIDI_UNICODE = [&#39;\u202a&#39;, &#39;\u202b&#39;, &#39;\u202c&#39;, &#39;\u202d&#39;, &#39;\u202e&#39;, &#39;\u2066&#39;,</span>
<span class="gd">-    &#39;\u2067&#39;, &#39;\u2068&#39;, &#39;\u2069&#39;, &#39;\u200f&#39;]</span>
<span class="gi">+</span>
<span class="gi">+_StrLike = TypeVar(&quot;_StrLike&quot;, str, bytes)</span>
<span class="gi">+</span>
<span class="gi">+# Based on:</span>
<span class="gi">+# https://golangexample.com/go-linter-which-checks-for-dangerous-unicode-character-sequences/</span>
<span class="gi">+# We use &#39;\u&#39; because it doesn&#39;t require a map lookup and is therefore faster</span>
<span class="gi">+BIDI_UNICODE = [</span>
<span class="gi">+    &quot;\u202A&quot;,  # \N{LEFT-TO-RIGHT EMBEDDING}</span>
<span class="gi">+    &quot;\u202B&quot;,  # \N{RIGHT-TO-LEFT EMBEDDING}</span>
<span class="gi">+    &quot;\u202C&quot;,  # \N{POP DIRECTIONAL FORMATTING}</span>
<span class="gi">+    &quot;\u202D&quot;,  # \N{LEFT-TO-RIGHT OVERRIDE}</span>
<span class="gi">+    &quot;\u202E&quot;,  # \N{RIGHT-TO-LEFT OVERRIDE}</span>
<span class="gi">+    &quot;\u2066&quot;,  # \N{LEFT-TO-RIGHT ISOLATE}</span>
<span class="gi">+    &quot;\u2067&quot;,  # \N{RIGHT-TO-LEFT ISOLATE}</span>
<span class="gi">+    &quot;\u2068&quot;,  # \N{FIRST STRONG ISOLATE}</span>
<span class="gi">+    &quot;\u2069&quot;,  # \N{POP DIRECTIONAL ISOLATE}</span>
<span class="gi">+    # The following was part of PEP 672:</span>
<span class="gi">+    # https://www.python.org/dev/peps/pep-0672/</span>
<span class="gi">+    # so the list above might not be complete</span>
<span class="gi">+    &quot;\u200F&quot;,  # \n{RIGHT-TO-LEFT MARK}</span>
<span class="gi">+    # We don&#39;t use</span>
<span class="gi">+    #   &quot;\u200E&quot; # \n{LEFT-TO-RIGHT MARK}</span>
<span class="gi">+    # as this is the default for latin files and can&#39;t be used</span>
<span class="gi">+    # to hide code</span>
<span class="gi">+]</span>


<span class="w"> </span>class _BadChar(NamedTuple):
<span class="w"> </span>    &quot;&quot;&quot;Representation of an ASCII char considered bad.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name: str
<span class="w"> </span>    unescaped: str
<span class="w"> </span>    escaped: str
<span class="w"> </span>    code: str
<span class="w"> </span>    help_text: str

<span class="gd">-    def description(self) -&gt;str:</span>
<span class="gi">+    def description(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used for the detailed error message description.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            f&quot;Invalid unescaped character {self.name}, &quot;</span>
<span class="gi">+            f&#39;use &quot;{self.escaped}&quot; instead.&#39;</span>
<span class="gi">+        )</span>

<span class="gd">-    def human_code(self) -&gt;str:</span>
<span class="gi">+    def human_code(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used to generate the human readable error message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-BAD_CHARS = [_BadChar(&#39;backspace&#39;, &#39;\x08&#39;, &#39;\\b&#39;, &#39;E2510&#39;,</span>
<span class="gd">-    &#39;Moves the cursor back, so the character after it will overwrite the character before.&#39;</span>
<span class="gd">-    ), _BadChar(&#39;carriage-return&#39;, &#39;\r&#39;, &#39;\\r&#39;, &#39;E2511&#39;,</span>
<span class="gd">-    &#39;Moves the cursor to the start of line, subsequent characters overwrite the start of the line.&#39;</span>
<span class="gd">-    ), _BadChar(&#39;sub&#39;, &#39;\x1a&#39;, &#39;\\x1A&#39;, &#39;E2512&#39;,</span>
<span class="gd">-    &#39;Ctrl+Z &quot;End of text&quot; on Windows. Some programs (such as type) ignore the rest of the file after it.&#39;</span>
<span class="gd">-    ), _BadChar(&#39;esc&#39;, &#39;\x1b&#39;, &#39;\\x1B&#39;, &#39;E2513&#39;,</span>
<span class="gd">-    &#39;Commonly initiates escape codes which allow arbitrary control of the terminal.&#39;</span>
<span class="gd">-    ), _BadChar(&#39;nul&#39;, &#39;\x00&#39;, &#39;\\0&#39;, &#39;E2514&#39;,</span>
<span class="gd">-    &#39;Mostly end of input for python.&#39;), _BadChar(&#39;zero-width-space&#39;,</span>
<span class="gd">-    &#39;\u200b&#39;, &#39;\\u200B&#39;, &#39;E2515&#39;,</span>
<span class="gd">-    &#39;Invisible space character could hide real code execution.&#39;)]</span>
<span class="gi">+        return f&quot;invalid-character-{self.name}&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Based on https://www.python.org/dev/peps/pep-0672/</span>
<span class="gi">+BAD_CHARS = [</span>
<span class="gi">+    _BadChar(</span>
<span class="gi">+        &quot;backspace&quot;,</span>
<span class="gi">+        &quot;\b&quot;,</span>
<span class="gi">+        &quot;\\b&quot;,</span>
<span class="gi">+        &quot;E2510&quot;,</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;Moves the cursor back, so the character after it will overwrite the &quot;</span>
<span class="gi">+            &quot;character before.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+    ),</span>
<span class="gi">+    _BadChar(</span>
<span class="gi">+        &quot;carriage-return&quot;,</span>
<span class="gi">+        &quot;\r&quot;,</span>
<span class="gi">+        &quot;\\r&quot;,</span>
<span class="gi">+        &quot;E2511&quot;,</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;Moves the cursor to the start of line, subsequent characters overwrite &quot;</span>
<span class="gi">+            &quot;the start of the line.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+    ),</span>
<span class="gi">+    _BadChar(</span>
<span class="gi">+        &quot;sub&quot;,</span>
<span class="gi">+        &quot;\x1A&quot;,</span>
<span class="gi">+        &quot;\\x1A&quot;,</span>
<span class="gi">+        &quot;E2512&quot;,</span>
<span class="gi">+        (</span>
<span class="gi">+            &#39;Ctrl+Z &quot;End of text&quot; on Windows. Some programs (such as type) ignore &#39;</span>
<span class="gi">+            &quot;the rest of the file after it.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+    ),</span>
<span class="gi">+    _BadChar(</span>
<span class="gi">+        &quot;esc&quot;,</span>
<span class="gi">+        &quot;\x1B&quot;,</span>
<span class="gi">+        &quot;\\x1B&quot;,</span>
<span class="gi">+        &quot;E2513&quot;,</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;Commonly initiates escape codes which allow arbitrary control &quot;</span>
<span class="gi">+            &quot;of the terminal.&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+    ),</span>
<span class="gi">+    _BadChar(</span>
<span class="gi">+        &quot;nul&quot;,</span>
<span class="gi">+        &quot;\0&quot;,</span>
<span class="gi">+        &quot;\\0&quot;,</span>
<span class="gi">+        &quot;E2514&quot;,</span>
<span class="gi">+        &quot;Mostly end of input for python.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    _BadChar(</span>
<span class="gi">+        # Zero Width with Space. At the time of writing not accepted by Python.</span>
<span class="gi">+        # But used in Trojan Source Examples, so still included and tested for.</span>
<span class="gi">+        &quot;zero-width-space&quot;,</span>
<span class="gi">+        &quot;\u200B&quot;,  # \n{ZERO WIDTH SPACE}</span>
<span class="gi">+        &quot;\\u200B&quot;,</span>
<span class="gi">+        &quot;E2515&quot;,</span>
<span class="gi">+        &quot;Invisible space character could hide real code execution.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+]</span>
<span class="w"> </span>BAD_ASCII_SEARCH_DICT = {char.unescaped: char for char in BAD_CHARS}


<span class="gd">-def _line_length(line: _StrLike, codec: str) -&gt;int:</span>
<span class="gi">+def _line_length(line: _StrLike, codec: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the length of a string like line as displayed in an editor.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(line, bytes):</span>
<span class="gi">+        decoded = _remove_bom(line, codec).decode(codec, &quot;replace&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        decoded = line</span>
<span class="gi">+</span>
<span class="gi">+    stripped = decoded.rstrip(&quot;\n&quot;)</span>

<span class="gi">+    if stripped != decoded:</span>
<span class="gi">+        stripped = stripped.rstrip(&quot;\r&quot;)</span>

<span class="gd">-def _map_positions_to_result(line: _StrLike, search_dict: dict[_StrLike,</span>
<span class="gd">-    _BadChar], new_line: _StrLike, byte_str_length: int=1) -&gt;dict[int, _BadChar</span>
<span class="gd">-    ]:</span>
<span class="gi">+    return len(stripped)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _map_positions_to_result(</span>
<span class="gi">+    line: _StrLike,</span>
<span class="gi">+    search_dict: dict[_StrLike, _BadChar],</span>
<span class="gi">+    new_line: _StrLike,</span>
<span class="gi">+    byte_str_length: int = 1,</span>
<span class="gi">+) -&gt; dict[int, _BadChar]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get all occurrences of search dict keys within line.

<span class="w"> </span>    Ignores Windows end of line and can handle bytes as well as string.
<span class="w"> </span>    Also takes care of encodings for which the length of an encoded code point does not
<span class="w"> </span>    default to 8 Bit.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-UNICODE_BOMS = {&#39;utf-8&#39;: codecs.BOM_UTF8, &#39;utf-16&#39;: codecs.BOM_UTF16,</span>
<span class="gd">-    &#39;utf-32&#39;: codecs.BOM_UTF32, &#39;utf-16le&#39;: codecs.BOM_UTF16_LE, &#39;utf-16be&#39;:</span>
<span class="gd">-    codecs.BOM_UTF16_BE, &#39;utf-32le&#39;: codecs.BOM_UTF32_LE, &#39;utf-32be&#39;:</span>
<span class="gd">-    codecs.BOM_UTF32_BE}</span>
<span class="gd">-BOM_SORTED_TO_CODEC = OrderedDict((UNICODE_BOMS[codec], codec) for codec in</span>
<span class="gd">-    (&#39;utf-32le&#39;, &#39;utf-32be&#39;, &#39;utf-8&#39;, &#39;utf-16le&#39;, &#39;utf-16be&#39;))</span>
<span class="gd">-UTF_NAME_REGEX_COMPILED = re.compile(&#39;utf[ -]?(8|16|32)[ -]?(le|be|)?(sig)?&#39;,</span>
<span class="gd">-    flags=re.IGNORECASE)</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _normalize_codec_name(codec: str) -&gt;str:</span>
<span class="gi">+    result: dict[int, _BadChar] = {}</span>
<span class="gi">+</span>
<span class="gi">+    for search_for, char in search_dict.items():</span>
<span class="gi">+        if search_for not in line:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # Special Handling for Windows &#39;\r\n&#39;</span>
<span class="gi">+        if char.unescaped == &quot;\r&quot; and line.endswith(new_line):</span>
<span class="gi">+            ignore_pos = len(line) - 2 * byte_str_length</span>
<span class="gi">+        else:</span>
<span class="gi">+            ignore_pos = None</span>
<span class="gi">+</span>
<span class="gi">+        start = 0</span>
<span class="gi">+        pos = line.find(search_for, start)</span>
<span class="gi">+        while pos &gt; 0:</span>
<span class="gi">+            if pos != ignore_pos:</span>
<span class="gi">+                # Calculate the column</span>
<span class="gi">+                col = int(pos / byte_str_length)</span>
<span class="gi">+                result[col] = char</span>
<span class="gi">+            start = pos + 1</span>
<span class="gi">+            pos = line.find(search_for, start)</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+UNICODE_BOMS = {</span>
<span class="gi">+    &quot;utf-8&quot;: codecs.BOM_UTF8,</span>
<span class="gi">+    &quot;utf-16&quot;: codecs.BOM_UTF16,</span>
<span class="gi">+    &quot;utf-32&quot;: codecs.BOM_UTF32,</span>
<span class="gi">+    &quot;utf-16le&quot;: codecs.BOM_UTF16_LE,</span>
<span class="gi">+    &quot;utf-16be&quot;: codecs.BOM_UTF16_BE,</span>
<span class="gi">+    &quot;utf-32le&quot;: codecs.BOM_UTF32_LE,</span>
<span class="gi">+    &quot;utf-32be&quot;: codecs.BOM_UTF32_BE,</span>
<span class="gi">+}</span>
<span class="gi">+BOM_SORTED_TO_CODEC = OrderedDict(</span>
<span class="gi">+    # Sorted by length of BOM of each codec</span>
<span class="gi">+    (UNICODE_BOMS[codec], codec)</span>
<span class="gi">+    for codec in (&quot;utf-32le&quot;, &quot;utf-32be&quot;, &quot;utf-8&quot;, &quot;utf-16le&quot;, &quot;utf-16be&quot;)</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+UTF_NAME_REGEX_COMPILED = re.compile(</span>
<span class="gi">+    &quot;utf[ -]?(8|16|32)[ -]?(le|be|)?(sig)?&quot;, flags=re.IGNORECASE</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _normalize_codec_name(codec: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make sure the codec name is always given as defined in the BOM dict.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return UTF_NAME_REGEX_COMPILED.sub(r&quot;utf-\1\2&quot;, codec).lower()</span>


<span class="gd">-def _remove_bom(encoded: bytes, encoding: str) -&gt;bytes:</span>
<span class="gi">+def _remove_bom(encoded: bytes, encoding: str) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Remove the bom if given from a line.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if encoding not in UNICODE_BOMS:</span>
<span class="gi">+        return encoded</span>
<span class="gi">+    bom = UNICODE_BOMS[encoding]</span>
<span class="gi">+    if encoded.startswith(bom):</span>
<span class="gi">+        return encoded[len(bom) :]</span>
<span class="gi">+    return encoded</span>


<span class="gd">-def _encode_without_bom(string: str, encoding: str) -&gt;bytes:</span>
<span class="gi">+def _encode_without_bom(string: str, encoding: str) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;Encode a string but remove the BOM.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _remove_bom(string.encode(encoding), encoding)</span>


<span class="gd">-def _byte_to_str_length(codec: str) -&gt;int:</span>
<span class="gi">+def _byte_to_str_length(codec: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return how many byte are usually(!) a character point.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if codec.startswith(&quot;utf-32&quot;):</span>
<span class="gi">+        return 4</span>
<span class="gi">+    if codec.startswith(&quot;utf-16&quot;):</span>
<span class="gi">+        return 2</span>
<span class="gi">+</span>
<span class="gi">+    return 1</span>


<span class="w"> </span>@lru_cache(maxsize=1000)
<span class="gd">-def _cached_encode_search(string: str, encoding: str) -&gt;bytes:</span>
<span class="gi">+def _cached_encode_search(string: str, encoding: str) -&gt; bytes:</span>
<span class="w"> </span>    &quot;&quot;&quot;A cached version of encode used for search pattern.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _encode_without_bom(string, encoding)</span>


<span class="gd">-def _fix_utf16_32_line_stream(steam: Iterable[bytes], codec: str) -&gt;Iterable[</span>
<span class="gd">-    bytes]:</span>
<span class="gd">-    &quot;&quot;&quot;Handle line ending for UTF16 and UTF32 correctly.</span>
<span class="gi">+def _fix_utf16_32_line_stream(steam: Iterable[bytes], codec: str) -&gt; Iterable[bytes]:</span>
<span class="gi">+    r&quot;&quot;&quot;Handle line ending for UTF16 and UTF32 correctly.</span>

<span class="gd">-    Currently, Python simply strips the required zeros after \\n after the</span>
<span class="gi">+    Currently, Python simply strips the required zeros after \n after the</span>
<span class="w"> </span>    line ending. Leading to lines that can&#39;t be decoded properly
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def extract_codec_from_bom(first_line: bytes) -&gt;str:</span>
<span class="gi">+    if not codec.startswith(&quot;utf-16&quot;) and not codec.startswith(&quot;utf-32&quot;):</span>
<span class="gi">+        yield from steam</span>
<span class="gi">+    else:</span>
<span class="gi">+        # First we get all the bytes in memory</span>
<span class="gi">+        content = b&quot;&quot;.join(line for line in steam)</span>
<span class="gi">+</span>
<span class="gi">+        new_line = _cached_encode_search(&quot;\n&quot;, codec)</span>
<span class="gi">+</span>
<span class="gi">+        # Now we split the line by the real new line in the correct encoding</span>
<span class="gi">+        # we can&#39;t use split as it would strip the \n that we need</span>
<span class="gi">+        start = 0</span>
<span class="gi">+        while True:</span>
<span class="gi">+            pos = content.find(new_line, start)</span>
<span class="gi">+            if pos &gt;= 0:</span>
<span class="gi">+                yield content[start : pos + len(new_line)]</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Yield the rest and finish</span>
<span class="gi">+                if content[start:]:</span>
<span class="gi">+                    yield content[start:]</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            start = pos + len(new_line)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_codec_from_bom(first_line: bytes) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Try to extract the codec (unicode only) by checking for the BOM.

<span class="w"> </span>    For details about BOM see https://unicode.org/faq/utf_bom.html#BOM
<span class="gu">@@ -134,7 +290,11 @@ def extract_codec_from_bom(first_line: bytes) -&gt;str:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        ValueError: if no codec was found
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for bom, codec in BOM_SORTED_TO_CODEC.items():</span>
<span class="gi">+        if first_line.startswith(bom):</span>
<span class="gi">+            return codec</span>
<span class="gi">+</span>
<span class="gi">+    raise ValueError(&quot;No BOM found. Could not detect Unicode codec.&quot;)</span>


<span class="w"> </span>class UnicodeChecker(checkers.BaseRawFileChecker):
<span class="gu">@@ -156,26 +316,72 @@ class UnicodeChecker(checkers.BaseRawFileChecker):</span>
<span class="w"> </span>    https://stackoverflow.com/questions/69897842/ and https://bugs.python.org/issue1503789
<span class="w"> </span>    for background.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;unicode_checker&#39;</span>
<span class="gd">-    msgs = {&#39;E2501&#39;: (</span>
<span class="gd">-        &quot;UTF-16 and UTF-32 aren&#39;t backward compatible. Use UTF-8 instead&quot;,</span>
<span class="gd">-        &#39;invalid-unicode-codec&#39;,</span>
<span class="gd">-        &#39;For compatibility use UTF-8 instead of UTF-16/UTF-32. See also https://bugs.python.org/issue1503789 for a history of this issue. And https://softwareengineering.stackexchange.com/questions/102205/ for some possible problems when using UTF-16 for instance.&#39;</span>
<span class="gd">-        ), &#39;E2502&#39;: (</span>
<span class="gd">-        &#39;Contains control characters that can permit obfuscated code executed differently than displayed&#39;</span>
<span class="gd">-        , &#39;bidirectional-unicode&#39;,</span>
<span class="gd">-        &quot;&quot;&quot;bidirectional unicode are typically not displayed characters required to display right-to-left (RTL) script (i.e. Chinese, Japanese, Arabic, Hebrew, ...) correctly. So can you trust this code? Are you sure it displayed correctly in all editors? If you did not write it or your language is not RTL, remove the special characters, as they could be used to trick you into executing code, that does something else than what it looks like.</span>
<span class="gd">-More Information:</span>
<span class="gd">-https://en.wikipedia.org/wiki/Bidirectional_text</span>
<span class="gd">-https://trojansource.codes/&quot;&quot;&quot;</span>
<span class="gd">-        ), &#39;C2503&#39;: (&#39;PEP8 recommends UTF-8 as encoding for Python files&#39;,</span>
<span class="gd">-        &#39;bad-file-encoding&#39;,</span>
<span class="gd">-        &#39;PEP8 recommends UTF-8 default encoding for Python files. See https://peps.python.org/pep-0008/#source-file-encoding&#39;</span>
<span class="gd">-        ), **{bad_char.code: (bad_char.description(), bad_char.human_code(),</span>
<span class="gd">-        bad_char.help_text) for bad_char in BAD_CHARS}}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;unicode_checker&quot;</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;E2501&quot;: (</span>
<span class="gi">+            # This error will be only displayed to users once Python Supports</span>
<span class="gi">+            # UTF-16/UTF-32 (if at all)</span>
<span class="gi">+            &quot;UTF-16 and UTF-32 aren&#39;t backward compatible. Use UTF-8 instead&quot;,</span>
<span class="gi">+            &quot;invalid-unicode-codec&quot;,</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;For compatibility use UTF-8 instead of UTF-16/UTF-32. &quot;</span>
<span class="gi">+                &quot;See also https://bugs.python.org/issue1503789 for a history &quot;</span>
<span class="gi">+                &quot;of this issue. And &quot;</span>
<span class="gi">+                &quot;https://softwareengineering.stackexchange.com/questions/102205/ &quot;</span>
<span class="gi">+                &quot;for some possible problems when using UTF-16 for instance.&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E2502&quot;: (</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;Contains control characters that can permit obfuscated code &quot;</span>
<span class="gi">+                &quot;executed differently than displayed&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            &quot;bidirectional-unicode&quot;,</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;bidirectional unicode are typically not displayed characters required &quot;</span>
<span class="gi">+                &quot;to display right-to-left (RTL) script &quot;</span>
<span class="gi">+                &quot;(i.e. Chinese, Japanese, Arabic, Hebrew, ...) correctly. &quot;</span>
<span class="gi">+                &quot;So can you trust this code? &quot;</span>
<span class="gi">+                &quot;Are you sure it displayed correctly in all editors? &quot;</span>
<span class="gi">+                &quot;If you did not write it or your language is not RTL,&quot;</span>
<span class="gi">+                &quot; remove the special characters, as they could be used to trick you into &quot;</span>
<span class="gi">+                &quot;executing code, &quot;</span>
<span class="gi">+                &quot;that does something else than what it looks like.\n&quot;</span>
<span class="gi">+                &quot;More Information:\n&quot;</span>
<span class="gi">+                &quot;https://en.wikipedia.org/wiki/Bidirectional_text\n&quot;</span>
<span class="gi">+                &quot;https://trojansource.codes/&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C2503&quot;: (</span>
<span class="gi">+            &quot;PEP8 recommends UTF-8 as encoding for Python files&quot;,</span>
<span class="gi">+            &quot;bad-file-encoding&quot;,</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;PEP8 recommends UTF-8 default encoding for Python files. See &quot;</span>
<span class="gi">+                &quot;https://peps.python.org/pep-0008/#source-file-encoding&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+        ),</span>
<span class="gi">+        **{</span>
<span class="gi">+            bad_char.code: (</span>
<span class="gi">+                bad_char.description(),</span>
<span class="gi">+                bad_char.human_code(),</span>
<span class="gi">+                bad_char.help_text,</span>
<span class="gi">+            )</span>
<span class="gi">+            for bad_char in BAD_CHARS</span>
<span class="gi">+        },</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_invalid_codec(codec: str) -&gt; bool:</span>
<span class="gi">+        return codec.startswith((&quot;utf-16&quot;, &quot;utf-32&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_unicode(codec: str) -&gt; bool:</span>
<span class="gi">+        return codec.startswith(&quot;utf&quot;)</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def _find_line_matches(cls, line: bytes, codec: str) -&gt;dict[int, _BadChar]:</span>
<span class="gi">+    def _find_line_matches(cls, line: bytes, codec: str) -&gt; dict[int, _BadChar]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find all matches of BAD_CHARS within line.

<span class="w"> </span>        Args:
<span class="gu">@@ -185,10 +391,33 @@ https://trojansource.codes/&quot;&quot;&quot;</span>
<span class="w"> </span>        Return:
<span class="w"> </span>            A dictionary with the column offset and the BadASCIIChar
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # We try to decode in Unicode to get the correct column offset</span>
<span class="gi">+        # if we would use bytes, it could be off because UTF-8 has no fixed length</span>
<span class="gi">+        try:</span>
<span class="gi">+            line_search = line.decode(codec, errors=&quot;strict&quot;)</span>
<span class="gi">+            search_dict = BAD_ASCII_SEARCH_DICT</span>
<span class="gi">+            return _map_positions_to_result(line_search, search_dict, &quot;\n&quot;)</span>
<span class="gi">+        except UnicodeDecodeError:</span>
<span class="gi">+            # If we can&#39;t decode properly, we simply use bytes, even so the column offsets</span>
<span class="gi">+            # might be wrong a bit, but it is still better then nothing</span>
<span class="gi">+            line_search_byte = line</span>
<span class="gi">+            search_dict_byte: dict[bytes, _BadChar] = {}</span>
<span class="gi">+            for char in BAD_CHARS:</span>
<span class="gi">+                # Some characters might not exist in all encodings</span>
<span class="gi">+                with contextlib.suppress(UnicodeDecodeError):</span>
<span class="gi">+                    search_dict_byte[_cached_encode_search(char.unescaped, codec)] = (</span>
<span class="gi">+                        char</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            return _map_positions_to_result(</span>
<span class="gi">+                line_search_byte,</span>
<span class="gi">+                search_dict_byte,</span>
<span class="gi">+                _cached_encode_search(&quot;\n&quot;, codec),</span>
<span class="gi">+                byte_str_length=_byte_to_str_length(codec),</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _determine_codec(stream: io.BytesIO) -&gt;tuple[str, int]:</span>
<span class="gi">+    def _determine_codec(stream: io.BytesIO) -&gt; tuple[str, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Determine the codec from the given stream.

<span class="w"> </span>        first tries https://www.python.org/dev/peps/pep-0263/
<span class="gu">@@ -205,21 +434,104 @@ https://trojansource.codes/&quot;&quot;&quot;</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            SyntaxError: if failing to detect codec
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_codec(self, codec: str, codec_definition_line: int) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # First try to detect encoding with PEP 263</span>
<span class="gi">+            # Doesn&#39;t work with UTF-16/32 at the time of writing</span>
<span class="gi">+            # see https://bugs.python.org/issue1503789</span>
<span class="gi">+            codec, lines = detect_encoding(stream.readline)</span>
<span class="gi">+</span>
<span class="gi">+            # lines are empty if UTF-8 BOM is found</span>
<span class="gi">+            codec_definition_line = len(lines) or 1</span>
<span class="gi">+        except SyntaxError as e:</span>
<span class="gi">+            # Codec could not be detected by Python, we try manually to check for</span>
<span class="gi">+            # UTF 16/32 BOMs, which aren&#39;t supported by Python at the time of writing.</span>
<span class="gi">+            # This is only included to be future save and handle these codecs as well</span>
<span class="gi">+            stream.seek(0)</span>
<span class="gi">+            try:</span>
<span class="gi">+                codec = extract_codec_from_bom(stream.readline())</span>
<span class="gi">+                codec_definition_line = 1</span>
<span class="gi">+            except ValueError as ve:</span>
<span class="gi">+                # Failed to detect codec, so the syntax error originated not from</span>
<span class="gi">+                # UTF16/32 codec usage. So simply raise the error again.</span>
<span class="gi">+                raise e from ve</span>
<span class="gi">+</span>
<span class="gi">+        return _normalize_codec_name(codec), codec_definition_line</span>
<span class="gi">+</span>
<span class="gi">+    def _check_codec(self, codec: str, codec_definition_line: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check validity of the codec.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_invalid_chars(self, line: bytes, lineno: int, codec: str</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        if codec != &quot;utf-8&quot;:</span>
<span class="gi">+            msg = &quot;bad-file-encoding&quot;</span>
<span class="gi">+            if self._is_invalid_codec(codec):</span>
<span class="gi">+                msg = &quot;invalid-unicode-codec&quot;</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                msg,</span>
<span class="gi">+                # Currently Nodes will lead to crashes of pylint</span>
<span class="gi">+                # node=node,</span>
<span class="gi">+                line=codec_definition_line,</span>
<span class="gi">+                end_lineno=codec_definition_line,</span>
<span class="gi">+                confidence=pylint.interfaces.HIGH,</span>
<span class="gi">+                col_offset=None,</span>
<span class="gi">+                end_col_offset=None,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_invalid_chars(self, line: bytes, lineno: int, codec: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look for chars considered bad.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_bidi_chars(self, line: bytes, lineno: int, codec: str) -&gt;None:</span>
<span class="gi">+        matches = self._find_line_matches(line, codec)</span>
<span class="gi">+        for col, char in matches.items():</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                char.human_code(),</span>
<span class="gi">+                # Currently Nodes will lead to crashes of pylint</span>
<span class="gi">+                # node=node,</span>
<span class="gi">+                line=lineno,</span>
<span class="gi">+                end_lineno=lineno,</span>
<span class="gi">+                confidence=pylint.interfaces.HIGH,</span>
<span class="gi">+                col_offset=col + 1,</span>
<span class="gi">+                end_col_offset=col + len(char.unescaped) + 1,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _check_bidi_chars(self, line: bytes, lineno: int, codec: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Look for Bidirectional Unicode, if we use unicode.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def process_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+        if not self._is_unicode(codec):</span>
<span class="gi">+            return</span>
<span class="gi">+        for dangerous in BIDI_UNICODE:</span>
<span class="gi">+            if _cached_encode_search(dangerous, codec) in line:</span>
<span class="gi">+                # Note that we don&#39;t add a col_offset on purpose:</span>
<span class="gi">+                #   Using these unicode characters it depends on the editor</span>
<span class="gi">+                #   how it displays the location of characters in the line.</span>
<span class="gi">+                #   So we mark the complete line.</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;bidirectional-unicode&quot;,</span>
<span class="gi">+                    # Currently Nodes will lead to crashes of pylint</span>
<span class="gi">+                    # node=node,</span>
<span class="gi">+                    line=lineno,</span>
<span class="gi">+                    end_lineno=lineno,</span>
<span class="gi">+                    # We mark the complete line, as bidi controls make it hard</span>
<span class="gi">+                    # to determine the correct cursor position within an editor</span>
<span class="gi">+                    col_offset=0,</span>
<span class="gi">+                    end_col_offset=_line_length(line, codec),</span>
<span class="gi">+                    confidence=pylint.interfaces.HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+                # We look for bidirectional unicode only once per line</span>
<span class="gi">+                # as we mark the complete line anyway</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def process_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform the actual check by checking module stream.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with node.stream() as stream:</span>
<span class="gi">+            codec, codec_line = self._determine_codec(stream)</span>
<span class="gi">+            self._check_codec(codec, codec_line)</span>
<span class="gi">+</span>
<span class="gi">+            stream.seek(0)</span>
<span class="gi">+</span>
<span class="gi">+            # Check for invalid content (controls/chars)</span>
<span class="gi">+            for lineno, line in enumerate(</span>
<span class="gi">+                _fix_utf16_32_line_stream(stream, codec), start=1</span>
<span class="gi">+            ):</span>
<span class="gi">+                if lineno == 1:</span>
<span class="gi">+                    line = _remove_bom(line, codec)</span>
<span class="gi">+                self._check_bidi_chars(line, lineno, codec)</span>
<span class="gi">+                self._check_invalid_chars(line, lineno, codec)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: pylint.lint.PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(UnicodeChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/unsupported_version.py b/pylint/checkers/unsupported_version.py</span>
<span class="gh">index 8be4654c4..64f2630d8 100644</span>
<span class="gd">--- a/pylint/checkers/unsupported_version.py</span>
<span class="gi">+++ b/pylint/checkers/unsupported_version.py</span>
<span class="gu">@@ -1,11 +1,24 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checker for features used that are not supported by all python versions
<span class="w"> </span>indicated by the py-version setting.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="gd">-from pylint.checkers.utils import only_required_for_messages, safe_infer, uninferable_final_decorators</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    only_required_for_messages,</span>
<span class="gi">+    safe_infer,</span>
<span class="gi">+    uninferable_final_decorators,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -14,33 +27,58 @@ class UnsupportedVersionChecker(BaseChecker):</span>
<span class="w"> </span>    &quot;&quot;&quot;Checker for features that are not supported by all python versions
<span class="w"> </span>    indicated by the py-version setting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;unsupported_version&#39;</span>
<span class="gd">-    msgs = {&#39;W2601&#39;: (</span>
<span class="gd">-        &#39;F-strings are not supported by all versions included in the py-version setting&#39;</span>
<span class="gd">-        , &#39;using-f-string-in-unsupported-version&#39;,</span>
<span class="gd">-        &#39;Used when the py-version set by the user is lower than 3.6 and pylint encounters an f-string.&#39;</span>
<span class="gd">-        ), &#39;W2602&#39;: (</span>
<span class="gd">-        &#39;typing.final is not supported by all versions included in the py-version setting&#39;</span>
<span class="gd">-        , &#39;using-final-decorator-in-unsupported-version&#39;,</span>
<span class="gd">-        &#39;Used when the py-version set by the user is lower than 3.8 and pylint encounters a ``typing.final`` decorator.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-</span>
<span class="gd">-    def open(self) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;unsupported_version&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W2601&quot;: (</span>
<span class="gi">+            &quot;F-strings are not supported by all versions included in the py-version setting&quot;,</span>
<span class="gi">+            &quot;using-f-string-in-unsupported-version&quot;,</span>
<span class="gi">+            &quot;Used when the py-version set by the user is lower than 3.6 and pylint encounters &quot;</span>
<span class="gi">+            &quot;an f-string.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W2602&quot;: (</span>
<span class="gi">+            &quot;typing.final is not supported by all versions included in the py-version setting&quot;,</span>
<span class="gi">+            &quot;using-final-decorator-in-unsupported-version&quot;,</span>
<span class="gi">+            &quot;Used when the py-version set by the user is lower than 3.8 and pylint encounters &quot;</span>
<span class="gi">+            &quot;a ``typing.final`` decorator.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize visit variables and statistics.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        py_version = self.linter.config.py_version</span>
<span class="gi">+        self._py36_plus = py_version &gt;= (3, 6)</span>
<span class="gi">+        self._py38_plus = py_version &gt;= (3, 8)</span>

<span class="gd">-    @only_required_for_messages(&#39;using-f-string-in-unsupported-version&#39;)</span>
<span class="gd">-    def visit_joinedstr(self, node: nodes.JoinedStr) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;using-f-string-in-unsupported-version&quot;)</span>
<span class="gi">+    def visit_joinedstr(self, node: nodes.JoinedStr) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check f-strings.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._py36_plus:</span>
<span class="gi">+            self.add_message(&quot;using-f-string-in-unsupported-version&quot;, node=node)</span>

<span class="gd">-    @only_required_for_messages(&#39;using-final-decorator-in-unsupported-version&#39;)</span>
<span class="gd">-    def visit_decorators(self, node: nodes.Decorators) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;using-final-decorator-in-unsupported-version&quot;)</span>
<span class="gi">+    def visit_decorators(self, node: nodes.Decorators) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check decorators.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_typing_final(node)</span>

<span class="gd">-    def _check_typing_final(self, node: nodes.Decorators) -&gt;None:</span>
<span class="gi">+    def _check_typing_final(self, node: nodes.Decorators) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a message when the `typing.final` decorator is used and the
<span class="w"> </span>        py-version is lower than 3.8.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._py38_plus:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        decorators = []</span>
<span class="gi">+        for decorator in node.get_children():</span>
<span class="gi">+            inferred = safe_infer(decorator)</span>
<span class="gi">+            if inferred and inferred.qname() == &quot;typing.final&quot;:</span>
<span class="gi">+                decorators.append(decorator)</span>
<span class="gi">+</span>
<span class="gi">+        for decorator in decorators or uninferable_final_decorators(node):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;using-final-decorator-in-unsupported-version&quot;, node=decorator</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(UnsupportedVersionChecker(linter))</span>
<span class="gh">diff --git a/pylint/checkers/utils.py b/pylint/checkers/utils.py</span>
<span class="gh">index 83788746a..26aac1bd8 100644</span>
<span class="gd">--- a/pylint/checkers/utils.py</span>
<span class="gi">+++ b/pylint/checkers/utils.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Some functions that may be useful for various checkers.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import builtins
<span class="w"> </span>import fnmatch
<span class="w"> </span>import itertools
<span class="gu">@@ -10,6 +16,7 @@ from collections.abc import Iterable, Iterator</span>
<span class="w"> </span>from functools import lru_cache, partial
<span class="w"> </span>from re import Match
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, TypeVar
<span class="gi">+</span>
<span class="w"> </span>import _string
<span class="w"> </span>import astroid.objects
<span class="w"> </span>from astroid import TooManyLevelsError, nodes, util
<span class="gu">@@ -17,79 +24,221 @@ from astroid.context import InferenceContext</span>
<span class="w"> </span>from astroid.exceptions import AstroidError
<span class="w"> </span>from astroid.nodes._base_nodes import ImportNode, Statement
<span class="w"> </span>from astroid.typing import InferenceResult, SuccessfulInferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint.constants import TYPING_NEVER, TYPING_NORETURN
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from functools import _lru_cache_wrapper
<span class="gi">+</span>
<span class="w"> </span>    from pylint.checkers import BaseChecker
<span class="gd">-_NodeT = TypeVar(&#39;_NodeT&#39;, bound=nodes.NodeNG)</span>
<span class="gd">-_CheckerT = TypeVar(&#39;_CheckerT&#39;, bound=&#39;BaseChecker&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_NodeT = TypeVar(&quot;_NodeT&quot;, bound=nodes.NodeNG)</span>
<span class="gi">+_CheckerT = TypeVar(&quot;_CheckerT&quot;, bound=&quot;BaseChecker&quot;)</span>
<span class="w"> </span>AstCallbackMethod = Callable[[_CheckerT, _NodeT], None]
<span class="gd">-COMP_NODE_TYPES = (nodes.ListComp, nodes.SetComp, nodes.DictComp, nodes.</span>
<span class="gd">-    GeneratorExp)</span>
<span class="gd">-EXCEPTIONS_MODULE = &#39;builtins&#39;</span>
<span class="gd">-ABC_MODULES = {&#39;abc&#39;, &#39;_py_abc&#39;}</span>
<span class="gd">-ABC_METHODS = {&#39;abc.abstractproperty&#39;, &#39;abc.abstractmethod&#39;,</span>
<span class="gd">-    &#39;abc.abstractclassmethod&#39;, &#39;abc.abstractstaticmethod&#39;}</span>
<span class="gd">-TYPING_PROTOCOLS = frozenset({&#39;typing.Protocol&#39;,</span>
<span class="gd">-    &#39;typing_extensions.Protocol&#39;, &#39;.Protocol&#39;})</span>
<span class="gd">-COMMUTATIVE_OPERATORS = frozenset({&#39;*&#39;, &#39;+&#39;, &#39;^&#39;, &#39;&amp;&#39;, &#39;|&#39;})</span>
<span class="gd">-ITER_METHOD = &#39;__iter__&#39;</span>
<span class="gd">-AITER_METHOD = &#39;__aiter__&#39;</span>
<span class="gd">-NEXT_METHOD = &#39;__next__&#39;</span>
<span class="gd">-GETITEM_METHOD = &#39;__getitem__&#39;</span>
<span class="gd">-CLASS_GETITEM_METHOD = &#39;__class_getitem__&#39;</span>
<span class="gd">-SETITEM_METHOD = &#39;__setitem__&#39;</span>
<span class="gd">-DELITEM_METHOD = &#39;__delitem__&#39;</span>
<span class="gd">-CONTAINS_METHOD = &#39;__contains__&#39;</span>
<span class="gd">-KEYS_METHOD = &#39;keys&#39;</span>
<span class="gd">-_SPECIAL_METHODS_PARAMS = {None: (&#39;__new__&#39;, &#39;__init__&#39;, &#39;__call__&#39;,</span>
<span class="gd">-    &#39;__init_subclass__&#39;), (0): (&#39;__del__&#39;, &#39;__repr__&#39;, &#39;__str__&#39;,</span>
<span class="gd">-    &#39;__bytes__&#39;, &#39;__hash__&#39;, &#39;__bool__&#39;, &#39;__dir__&#39;, &#39;__len__&#39;,</span>
<span class="gd">-    &#39;__length_hint__&#39;, &#39;__iter__&#39;, &#39;__reversed__&#39;, &#39;__neg__&#39;, &#39;__pos__&#39;,</span>
<span class="gd">-    &#39;__abs__&#39;, &#39;__invert__&#39;, &#39;__complex__&#39;, &#39;__int__&#39;, &#39;__float__&#39;,</span>
<span class="gd">-    &#39;__index__&#39;, &#39;__trunc__&#39;, &#39;__floor__&#39;, &#39;__ceil__&#39;, &#39;__enter__&#39;,</span>
<span class="gd">-    &#39;__aenter__&#39;, &#39;__getnewargs_ex__&#39;, &#39;__getnewargs__&#39;, &#39;__getstate__&#39;,</span>
<span class="gd">-    &#39;__reduce__&#39;, &#39;__copy__&#39;, &#39;__unicode__&#39;, &#39;__nonzero__&#39;, &#39;__await__&#39;,</span>
<span class="gd">-    &#39;__aiter__&#39;, &#39;__anext__&#39;, &#39;__fspath__&#39;, &#39;__subclasses__&#39;), (1): (</span>
<span class="gd">-    &#39;__format__&#39;, &#39;__lt__&#39;, &#39;__le__&#39;, &#39;__eq__&#39;, &#39;__ne__&#39;, &#39;__gt__&#39;,</span>
<span class="gd">-    &#39;__ge__&#39;, &#39;__getattr__&#39;, &#39;__getattribute__&#39;, &#39;__delattr__&#39;,</span>
<span class="gd">-    &#39;__delete__&#39;, &#39;__instancecheck__&#39;, &#39;__subclasscheck__&#39;, &#39;__getitem__&#39;,</span>
<span class="gd">-    &#39;__missing__&#39;, &#39;__delitem__&#39;, &#39;__contains__&#39;, &#39;__add__&#39;, &#39;__sub__&#39;,</span>
<span class="gd">-    &#39;__mul__&#39;, &#39;__truediv__&#39;, &#39;__floordiv__&#39;, &#39;__rfloordiv__&#39;, &#39;__mod__&#39;,</span>
<span class="gd">-    &#39;__divmod__&#39;, &#39;__lshift__&#39;, &#39;__rshift__&#39;, &#39;__and__&#39;, &#39;__xor__&#39;,</span>
<span class="gd">-    &#39;__or__&#39;, &#39;__radd__&#39;, &#39;__rsub__&#39;, &#39;__rmul__&#39;, &#39;__rtruediv__&#39;,</span>
<span class="gd">-    &#39;__rmod__&#39;, &#39;__rdivmod__&#39;, &#39;__rpow__&#39;, &#39;__rlshift__&#39;, &#39;__rrshift__&#39;,</span>
<span class="gd">-    &#39;__rand__&#39;, &#39;__rxor__&#39;, &#39;__ror__&#39;, &#39;__iadd__&#39;, &#39;__isub__&#39;, &#39;__imul__&#39;,</span>
<span class="gd">-    &#39;__itruediv__&#39;, &#39;__ifloordiv__&#39;, &#39;__imod__&#39;, &#39;__ilshift__&#39;,</span>
<span class="gd">-    &#39;__irshift__&#39;, &#39;__iand__&#39;, &#39;__ixor__&#39;, &#39;__ior__&#39;, &#39;__ipow__&#39;,</span>
<span class="gd">-    &#39;__setstate__&#39;, &#39;__reduce_ex__&#39;, &#39;__deepcopy__&#39;, &#39;__cmp__&#39;,</span>
<span class="gd">-    &#39;__matmul__&#39;, &#39;__rmatmul__&#39;, &#39;__imatmul__&#39;, &#39;__div__&#39;), (2): (</span>
<span class="gd">-    &#39;__setattr__&#39;, &#39;__get__&#39;, &#39;__set__&#39;, &#39;__setitem__&#39;, &#39;__set_name__&#39;), (3</span>
<span class="gd">-    ): (&#39;__exit__&#39;, &#39;__aexit__&#39;), (0, 1): (&#39;__round__&#39;,), (1, 2): (&#39;__pow__&#39;,)}</span>
<span class="gd">-SPECIAL_METHODS_PARAMS = {name: params for params, methods in</span>
<span class="gd">-    _SPECIAL_METHODS_PARAMS.items() for name in methods}</span>
<span class="gi">+</span>
<span class="gi">+COMP_NODE_TYPES = (</span>
<span class="gi">+    nodes.ListComp,</span>
<span class="gi">+    nodes.SetComp,</span>
<span class="gi">+    nodes.DictComp,</span>
<span class="gi">+    nodes.GeneratorExp,</span>
<span class="gi">+)</span>
<span class="gi">+EXCEPTIONS_MODULE = &quot;builtins&quot;</span>
<span class="gi">+ABC_MODULES = {&quot;abc&quot;, &quot;_py_abc&quot;}</span>
<span class="gi">+ABC_METHODS = {</span>
<span class="gi">+    &quot;abc.abstractproperty&quot;,</span>
<span class="gi">+    &quot;abc.abstractmethod&quot;,</span>
<span class="gi">+    &quot;abc.abstractclassmethod&quot;,</span>
<span class="gi">+    &quot;abc.abstractstaticmethod&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+TYPING_PROTOCOLS = frozenset(</span>
<span class="gi">+    {&quot;typing.Protocol&quot;, &quot;typing_extensions.Protocol&quot;, &quot;.Protocol&quot;}</span>
<span class="gi">+)</span>
<span class="gi">+COMMUTATIVE_OPERATORS = frozenset({&quot;*&quot;, &quot;+&quot;, &quot;^&quot;, &quot;&amp;&quot;, &quot;|&quot;})</span>
<span class="gi">+ITER_METHOD = &quot;__iter__&quot;</span>
<span class="gi">+AITER_METHOD = &quot;__aiter__&quot;</span>
<span class="gi">+NEXT_METHOD = &quot;__next__&quot;</span>
<span class="gi">+GETITEM_METHOD = &quot;__getitem__&quot;</span>
<span class="gi">+CLASS_GETITEM_METHOD = &quot;__class_getitem__&quot;</span>
<span class="gi">+SETITEM_METHOD = &quot;__setitem__&quot;</span>
<span class="gi">+DELITEM_METHOD = &quot;__delitem__&quot;</span>
<span class="gi">+CONTAINS_METHOD = &quot;__contains__&quot;</span>
<span class="gi">+KEYS_METHOD = &quot;keys&quot;</span>
<span class="gi">+</span>
<span class="gi">+# Dictionary which maps the number of expected parameters a</span>
<span class="gi">+# special method can have to a set of special methods.</span>
<span class="gi">+# The following keys are used to denote the parameters restrictions:</span>
<span class="gi">+#</span>
<span class="gi">+# * None: variable number of parameters</span>
<span class="gi">+# * number: exactly that number of parameters</span>
<span class="gi">+# * tuple: these are the odd ones. Basically it means that the function</span>
<span class="gi">+#          can work with any number of arguments from that tuple,</span>
<span class="gi">+#          although it&#39;s best to implement it in order to accept</span>
<span class="gi">+#          all of them.</span>
<span class="gi">+_SPECIAL_METHODS_PARAMS = {</span>
<span class="gi">+    None: (&quot;__new__&quot;, &quot;__init__&quot;, &quot;__call__&quot;, &quot;__init_subclass__&quot;),</span>
<span class="gi">+    0: (</span>
<span class="gi">+        &quot;__del__&quot;,</span>
<span class="gi">+        &quot;__repr__&quot;,</span>
<span class="gi">+        &quot;__str__&quot;,</span>
<span class="gi">+        &quot;__bytes__&quot;,</span>
<span class="gi">+        &quot;__hash__&quot;,</span>
<span class="gi">+        &quot;__bool__&quot;,</span>
<span class="gi">+        &quot;__dir__&quot;,</span>
<span class="gi">+        &quot;__len__&quot;,</span>
<span class="gi">+        &quot;__length_hint__&quot;,</span>
<span class="gi">+        &quot;__iter__&quot;,</span>
<span class="gi">+        &quot;__reversed__&quot;,</span>
<span class="gi">+        &quot;__neg__&quot;,</span>
<span class="gi">+        &quot;__pos__&quot;,</span>
<span class="gi">+        &quot;__abs__&quot;,</span>
<span class="gi">+        &quot;__invert__&quot;,</span>
<span class="gi">+        &quot;__complex__&quot;,</span>
<span class="gi">+        &quot;__int__&quot;,</span>
<span class="gi">+        &quot;__float__&quot;,</span>
<span class="gi">+        &quot;__index__&quot;,</span>
<span class="gi">+        &quot;__trunc__&quot;,</span>
<span class="gi">+        &quot;__floor__&quot;,</span>
<span class="gi">+        &quot;__ceil__&quot;,</span>
<span class="gi">+        &quot;__enter__&quot;,</span>
<span class="gi">+        &quot;__aenter__&quot;,</span>
<span class="gi">+        &quot;__getnewargs_ex__&quot;,</span>
<span class="gi">+        &quot;__getnewargs__&quot;,</span>
<span class="gi">+        &quot;__getstate__&quot;,</span>
<span class="gi">+        &quot;__reduce__&quot;,</span>
<span class="gi">+        &quot;__copy__&quot;,</span>
<span class="gi">+        &quot;__unicode__&quot;,</span>
<span class="gi">+        &quot;__nonzero__&quot;,</span>
<span class="gi">+        &quot;__await__&quot;,</span>
<span class="gi">+        &quot;__aiter__&quot;,</span>
<span class="gi">+        &quot;__anext__&quot;,</span>
<span class="gi">+        &quot;__fspath__&quot;,</span>
<span class="gi">+        &quot;__subclasses__&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    1: (</span>
<span class="gi">+        &quot;__format__&quot;,</span>
<span class="gi">+        &quot;__lt__&quot;,</span>
<span class="gi">+        &quot;__le__&quot;,</span>
<span class="gi">+        &quot;__eq__&quot;,</span>
<span class="gi">+        &quot;__ne__&quot;,</span>
<span class="gi">+        &quot;__gt__&quot;,</span>
<span class="gi">+        &quot;__ge__&quot;,</span>
<span class="gi">+        &quot;__getattr__&quot;,</span>
<span class="gi">+        &quot;__getattribute__&quot;,</span>
<span class="gi">+        &quot;__delattr__&quot;,</span>
<span class="gi">+        &quot;__delete__&quot;,</span>
<span class="gi">+        &quot;__instancecheck__&quot;,</span>
<span class="gi">+        &quot;__subclasscheck__&quot;,</span>
<span class="gi">+        &quot;__getitem__&quot;,</span>
<span class="gi">+        &quot;__missing__&quot;,</span>
<span class="gi">+        &quot;__delitem__&quot;,</span>
<span class="gi">+        &quot;__contains__&quot;,</span>
<span class="gi">+        &quot;__add__&quot;,</span>
<span class="gi">+        &quot;__sub__&quot;,</span>
<span class="gi">+        &quot;__mul__&quot;,</span>
<span class="gi">+        &quot;__truediv__&quot;,</span>
<span class="gi">+        &quot;__floordiv__&quot;,</span>
<span class="gi">+        &quot;__rfloordiv__&quot;,</span>
<span class="gi">+        &quot;__mod__&quot;,</span>
<span class="gi">+        &quot;__divmod__&quot;,</span>
<span class="gi">+        &quot;__lshift__&quot;,</span>
<span class="gi">+        &quot;__rshift__&quot;,</span>
<span class="gi">+        &quot;__and__&quot;,</span>
<span class="gi">+        &quot;__xor__&quot;,</span>
<span class="gi">+        &quot;__or__&quot;,</span>
<span class="gi">+        &quot;__radd__&quot;,</span>
<span class="gi">+        &quot;__rsub__&quot;,</span>
<span class="gi">+        &quot;__rmul__&quot;,</span>
<span class="gi">+        &quot;__rtruediv__&quot;,</span>
<span class="gi">+        &quot;__rmod__&quot;,</span>
<span class="gi">+        &quot;__rdivmod__&quot;,</span>
<span class="gi">+        &quot;__rpow__&quot;,</span>
<span class="gi">+        &quot;__rlshift__&quot;,</span>
<span class="gi">+        &quot;__rrshift__&quot;,</span>
<span class="gi">+        &quot;__rand__&quot;,</span>
<span class="gi">+        &quot;__rxor__&quot;,</span>
<span class="gi">+        &quot;__ror__&quot;,</span>
<span class="gi">+        &quot;__iadd__&quot;,</span>
<span class="gi">+        &quot;__isub__&quot;,</span>
<span class="gi">+        &quot;__imul__&quot;,</span>
<span class="gi">+        &quot;__itruediv__&quot;,</span>
<span class="gi">+        &quot;__ifloordiv__&quot;,</span>
<span class="gi">+        &quot;__imod__&quot;,</span>
<span class="gi">+        &quot;__ilshift__&quot;,</span>
<span class="gi">+        &quot;__irshift__&quot;,</span>
<span class="gi">+        &quot;__iand__&quot;,</span>
<span class="gi">+        &quot;__ixor__&quot;,</span>
<span class="gi">+        &quot;__ior__&quot;,</span>
<span class="gi">+        &quot;__ipow__&quot;,</span>
<span class="gi">+        &quot;__setstate__&quot;,</span>
<span class="gi">+        &quot;__reduce_ex__&quot;,</span>
<span class="gi">+        &quot;__deepcopy__&quot;,</span>
<span class="gi">+        &quot;__cmp__&quot;,</span>
<span class="gi">+        &quot;__matmul__&quot;,</span>
<span class="gi">+        &quot;__rmatmul__&quot;,</span>
<span class="gi">+        &quot;__imatmul__&quot;,</span>
<span class="gi">+        &quot;__div__&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    2: (&quot;__setattr__&quot;, &quot;__get__&quot;, &quot;__set__&quot;, &quot;__setitem__&quot;, &quot;__set_name__&quot;),</span>
<span class="gi">+    3: (&quot;__exit__&quot;, &quot;__aexit__&quot;),</span>
<span class="gi">+    (0, 1): (&quot;__round__&quot;,),</span>
<span class="gi">+    (1, 2): (&quot;__pow__&quot;,),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+SPECIAL_METHODS_PARAMS = {</span>
<span class="gi">+    name: params</span>
<span class="gi">+    for params, methods in _SPECIAL_METHODS_PARAMS.items()</span>
<span class="gi">+    for name in methods</span>
<span class="gi">+}</span>
<span class="w"> </span>PYMETHODS = set(SPECIAL_METHODS_PARAMS)
<span class="gd">-SUBSCRIPTABLE_CLASSES_PEP585 = frozenset((&#39;builtins.tuple&#39;, &#39;builtins.list&#39;,</span>
<span class="gd">-    &#39;builtins.dict&#39;, &#39;builtins.set&#39;, &#39;builtins.frozenset&#39;, &#39;builtins.type&#39;,</span>
<span class="gd">-    &#39;collections.deque&#39;, &#39;collections.defaultdict&#39;,</span>
<span class="gd">-    &#39;collections.OrderedDict&#39;, &#39;collections.Counter&#39;,</span>
<span class="gd">-    &#39;collections.ChainMap&#39;, &#39;_collections_abc.Awaitable&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Coroutine&#39;, &#39;_collections_abc.AsyncIterable&#39;,</span>
<span class="gd">-    &#39;_collections_abc.AsyncIterator&#39;, &#39;_collections_abc.AsyncGenerator&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Iterable&#39;, &#39;_collections_abc.Iterator&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Generator&#39;, &#39;_collections_abc.Reversible&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Container&#39;, &#39;_collections_abc.Collection&#39;,</span>
<span class="gd">-    &#39;_collections_abc.Callable&#39;, &#39;_collections_abc.Set&#39;,</span>
<span class="gd">-    &#39;_collections_abc.MutableSet&#39;, &#39;_collections_abc.Mapping&#39;,</span>
<span class="gd">-    &#39;_collections_abc.MutableMapping&#39;, &#39;_collections_abc.Sequence&#39;,</span>
<span class="gd">-    &#39;_collections_abc.MutableSequence&#39;, &#39;_collections_abc.ByteString&#39;,</span>
<span class="gd">-    &#39;_collections_abc.MappingView&#39;, &#39;_collections_abc.KeysView&#39;,</span>
<span class="gd">-    &#39;_collections_abc.ItemsView&#39;, &#39;_collections_abc.ValuesView&#39;,</span>
<span class="gd">-    &#39;contextlib.AbstractContextManager&#39;,</span>
<span class="gd">-    &#39;contextlib.AbstractAsyncContextManager&#39;, &#39;re.Pattern&#39;, &#39;re.Match&#39;))</span>
<span class="gi">+</span>
<span class="gi">+SUBSCRIPTABLE_CLASSES_PEP585 = frozenset(</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;builtins.tuple&quot;,</span>
<span class="gi">+        &quot;builtins.list&quot;,</span>
<span class="gi">+        &quot;builtins.dict&quot;,</span>
<span class="gi">+        &quot;builtins.set&quot;,</span>
<span class="gi">+        &quot;builtins.frozenset&quot;,</span>
<span class="gi">+        &quot;builtins.type&quot;,</span>
<span class="gi">+        &quot;collections.deque&quot;,</span>
<span class="gi">+        &quot;collections.defaultdict&quot;,</span>
<span class="gi">+        &quot;collections.OrderedDict&quot;,</span>
<span class="gi">+        &quot;collections.Counter&quot;,</span>
<span class="gi">+        &quot;collections.ChainMap&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Awaitable&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Coroutine&quot;,</span>
<span class="gi">+        &quot;_collections_abc.AsyncIterable&quot;,</span>
<span class="gi">+        &quot;_collections_abc.AsyncIterator&quot;,</span>
<span class="gi">+        &quot;_collections_abc.AsyncGenerator&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Iterable&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Iterator&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Generator&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Reversible&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Container&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Collection&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Callable&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Set&quot;,</span>
<span class="gi">+        &quot;_collections_abc.MutableSet&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Mapping&quot;,</span>
<span class="gi">+        &quot;_collections_abc.MutableMapping&quot;,</span>
<span class="gi">+        &quot;_collections_abc.Sequence&quot;,</span>
<span class="gi">+        &quot;_collections_abc.MutableSequence&quot;,</span>
<span class="gi">+        &quot;_collections_abc.ByteString&quot;,</span>
<span class="gi">+        &quot;_collections_abc.MappingView&quot;,</span>
<span class="gi">+        &quot;_collections_abc.KeysView&quot;,</span>
<span class="gi">+        &quot;_collections_abc.ItemsView&quot;,</span>
<span class="gi">+        &quot;_collections_abc.ValuesView&quot;,</span>
<span class="gi">+        &quot;contextlib.AbstractContextManager&quot;,</span>
<span class="gi">+        &quot;contextlib.AbstractAsyncContextManager&quot;,</span>
<span class="gi">+        &quot;re.Pattern&quot;,</span>
<span class="gi">+        &quot;re.Match&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>SINGLETON_VALUES = {True, False, None}
<span class="gd">-TERMINATING_FUNCS_QNAMES = frozenset({&#39;_sitebuiltins.Quitter&#39;, &#39;sys.exit&#39;,</span>
<span class="gd">-    &#39;posix._exit&#39;, &#39;nt._exit&#39;})</span>
<span class="gi">+</span>
<span class="gi">+TERMINATING_FUNCS_QNAMES = frozenset(</span>
<span class="gi">+    {&quot;_sitebuiltins.Quitter&quot;, &quot;sys.exit&quot;, &quot;posix._exit&quot;, &quot;nt._exit&quot;}</span>
<span class="gi">+)</span>


<span class="w"> </span>class NoSuchArgumentError(Exception):
<span class="gu">@@ -100,36 +249,101 @@ class InferredTypeError(Exception):</span>
<span class="w"> </span>    pass


<span class="gd">-def get_all_elements(node: nodes.NodeNG) -&gt;Iterable[nodes.NodeNG]:</span>
<span class="gi">+def get_all_elements(</span>
<span class="gi">+    node: nodes.NodeNG,</span>
<span class="gi">+) -&gt; Iterable[nodes.NodeNG]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Recursively returns all atoms in nested lists and tuples.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, (nodes.Tuple, nodes.List)):</span>
<span class="gi">+        for child in node.elts:</span>
<span class="gi">+            yield from get_all_elements(child)</span>
<span class="gi">+    else:</span>
<span class="gi">+        yield node</span>


<span class="gd">-def is_super(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_super(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if the node is referencing the &quot;super&quot; builtin function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if getattr(node, &quot;name&quot;, None) == &quot;super&quot; and node.root().name == &quot;builtins&quot;:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>


<span class="gd">-def is_error(node: nodes.FunctionDef) -&gt;bool:</span>
<span class="gi">+def is_error(node: nodes.FunctionDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the given function node only raises an exception.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(node.body) == 1 and isinstance(node.body[0], nodes.Raise)</span>


<span class="gd">-builtins = builtins.__dict__.copy()</span>
<span class="gd">-SPECIAL_BUILTINS = &#39;__builtins__&#39;,</span>
<span class="gi">+builtins = builtins.__dict__.copy()  # type: ignore[assignment]</span>
<span class="gi">+SPECIAL_BUILTINS = (&quot;__builtins__&quot;,)  # &#39;__path__&#39;, &#39;__file__&#39;)</span>


<span class="gd">-def is_builtin_object(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_builtin_object(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns True if the given node is an object from the __builtin__ module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return node and node.root().name == &quot;builtins&quot;  # type: ignore[no-any-return]</span>


<span class="gd">-def is_builtin(name: str) -&gt;bool:</span>
<span class="gi">+def is_builtin(name: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if &lt;name&gt; could be considered as a builtin defined by python.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return name in builtins or name in SPECIAL_BUILTINS  # type: ignore[operator]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_defined_in_scope(</span>
<span class="gi">+    var_node: nodes.NodeNG,</span>
<span class="gi">+    varname: str,</span>
<span class="gi">+    scope: nodes.NodeNG,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    return defnode_in_scope(var_node, varname, scope) is not None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable = too-many-branches</span>
<span class="gi">+def defnode_in_scope(</span>
<span class="gi">+    var_node: nodes.NodeNG,</span>
<span class="gi">+    varname: str,</span>
<span class="gi">+    scope: nodes.NodeNG,</span>
<span class="gi">+) -&gt; nodes.NodeNG | None:</span>
<span class="gi">+    if isinstance(scope, nodes.If):</span>
<span class="gi">+        for node in scope.body:</span>
<span class="gi">+            if isinstance(node, nodes.Nonlocal) and varname in node.names:</span>
<span class="gi">+                return node</span>
<span class="gi">+            if isinstance(node, nodes.Assign):</span>
<span class="gi">+                for target in node.targets:</span>
<span class="gi">+                    if isinstance(target, nodes.AssignName) and target.name == varname:</span>
<span class="gi">+                        return target</span>
<span class="gi">+    elif isinstance(scope, (COMP_NODE_TYPES, nodes.For)):</span>
<span class="gi">+        for ass_node in scope.nodes_of_class(nodes.AssignName):</span>
<span class="gi">+            if ass_node.name == varname:</span>
<span class="gi">+                return ass_node</span>
<span class="gi">+    elif isinstance(scope, nodes.With):</span>
<span class="gi">+        for expr, ids in scope.items:</span>
<span class="gi">+            if expr.parent_of(var_node):</span>
<span class="gi">+                break</span>
<span class="gi">+            if ids and isinstance(ids, nodes.AssignName) and ids.name == varname:</span>
<span class="gi">+                return ids</span>
<span class="gi">+    elif isinstance(scope, (nodes.Lambda, nodes.FunctionDef)):</span>
<span class="gi">+        if scope.args.is_argument(varname):</span>
<span class="gi">+            # If the name is found inside a default value</span>
<span class="gi">+            # of a function, then let the search continue</span>
<span class="gi">+            # in the parent&#39;s tree.</span>
<span class="gi">+            if scope.args.parent_of(var_node):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    scope.args.default_value(varname)</span>
<span class="gi">+                    scope = scope.parent</span>
<span class="gi">+                    defnode = defnode_in_scope(var_node, varname, scope)</span>
<span class="gi">+                except astroid.NoDefault:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return defnode</span>
<span class="gi">+            return scope</span>
<span class="gi">+        if getattr(scope, &quot;name&quot;, None) == varname:</span>
<span class="gi">+            return scope</span>
<span class="gi">+    elif isinstance(scope, nodes.ExceptHandler):</span>
<span class="gi">+        if isinstance(scope.name, nodes.AssignName):</span>
<span class="gi">+            ass_node = scope.name</span>
<span class="gi">+            if ass_node.name == varname:</span>
<span class="gi">+                return ass_node</span>
<span class="gi">+    return None</span>


<span class="gd">-def is_defined_before(var_node: nodes.Name) -&gt;bool:</span>
<span class="gi">+def is_defined_before(var_node: nodes.Name) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given variable node is defined before.

<span class="w"> </span>    Verify that the variable node is defined by a parent node
<span class="gu">@@ -138,49 +352,129 @@ def is_defined_before(var_node: nodes.Name) -&gt;bool:</span>
<span class="w"> </span>    or in a previous sibling node on the same line
<span class="w"> </span>    (statement_defining ; statement_using).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_default_argument(node: nodes.NodeNG, scope: (nodes.NodeNG | None)=None</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+    varname = var_node.name</span>
<span class="gi">+    for parent in var_node.node_ancestors():</span>
<span class="gi">+        defnode = defnode_in_scope(var_node, varname, parent)</span>
<span class="gi">+        if defnode is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        defnode_scope = defnode.scope()</span>
<span class="gi">+        if isinstance(</span>
<span class="gi">+            defnode_scope, (*COMP_NODE_TYPES, nodes.Lambda, nodes.FunctionDef)</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Avoid the case where var_node_scope is a nested function</span>
<span class="gi">+            if isinstance(defnode_scope, nodes.FunctionDef):</span>
<span class="gi">+                var_node_scope = var_node.scope()</span>
<span class="gi">+                if var_node_scope is not defnode_scope and isinstance(</span>
<span class="gi">+                    var_node_scope, nodes.FunctionDef</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            return True</span>
<span class="gi">+        if defnode.lineno &lt; var_node.lineno:</span>
<span class="gi">+            return True</span>
<span class="gi">+        # `defnode` and `var_node` on the same line</span>
<span class="gi">+        for defnode_anc in defnode.node_ancestors():</span>
<span class="gi">+            if defnode_anc.lineno != var_node.lineno:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if isinstance(</span>
<span class="gi">+                defnode_anc,</span>
<span class="gi">+                (</span>
<span class="gi">+                    nodes.For,</span>
<span class="gi">+                    nodes.While,</span>
<span class="gi">+                    nodes.With,</span>
<span class="gi">+                    nodes.Try,</span>
<span class="gi">+                    nodes.ExceptHandler,</span>
<span class="gi">+                ),</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+    # possibly multiple statements on the same line using semicolon separator</span>
<span class="gi">+    stmt = var_node.statement()</span>
<span class="gi">+    _node = stmt.previous_sibling()</span>
<span class="gi">+    lineno = stmt.fromlineno</span>
<span class="gi">+    while _node and _node.fromlineno == lineno:</span>
<span class="gi">+        for assign_node in _node.nodes_of_class(nodes.AssignName):</span>
<span class="gi">+            if assign_node.name == varname:</span>
<span class="gi">+                return True</span>
<span class="gi">+        for imp_node in _node.nodes_of_class((nodes.ImportFrom, nodes.Import)):</span>
<span class="gi">+            if varname in [name[1] or name[0] for name in imp_node.names]:</span>
<span class="gi">+                return True</span>
<span class="gi">+        _node = _node.previous_sibling()</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_default_argument(node: nodes.NodeNG, scope: nodes.NodeNG | None = None) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the given Name node is used in function or lambda
<span class="w"> </span>    default argument&#39;s value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_func_decorator(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    if not scope:</span>
<span class="gi">+        scope = node.scope()</span>
<span class="gi">+    if isinstance(scope, (nodes.FunctionDef, nodes.Lambda)):</span>
<span class="gi">+        all_defaults = itertools.chain(</span>
<span class="gi">+            scope.args.defaults, (d for d in scope.args.kw_defaults if d is not None)</span>
<span class="gi">+        )</span>
<span class="gi">+        return any(</span>
<span class="gi">+            default_name_node is node</span>
<span class="gi">+            for default_node in all_defaults</span>
<span class="gi">+            for default_name_node in default_node.nodes_of_class(nodes.Name)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_func_decorator(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the name is used in function decorator.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_ancestor_name(frame: nodes.ClassDef, node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    for parent in node.node_ancestors():</span>
<span class="gi">+        if isinstance(parent, nodes.Decorators):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if parent.is_statement or isinstance(</span>
<span class="gi">+            parent,</span>
<span class="gi">+            (</span>
<span class="gi">+                nodes.Lambda,</span>
<span class="gi">+                nodes.ComprehensionScope,</span>
<span class="gi">+                nodes.ListComp,</span>
<span class="gi">+            ),</span>
<span class="gi">+        ):</span>
<span class="gi">+            break</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_ancestor_name(frame: nodes.ClassDef, node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return whether `frame` is an astroid.Class node with `node` in the
<span class="w"> </span>    subtree of its bases attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(frame, nodes.ClassDef):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return any(node in base.nodes_of_class(nodes.Name) for base in frame.bases)</span>


<span class="gd">-def is_being_called(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_being_called(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if node is the function being called in a Call node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(node.parent, nodes.Call) and node.parent.func is node</span>


<span class="gd">-def assign_parent(node: nodes.NodeNG) -&gt;nodes.NodeNG:</span>
<span class="gi">+def assign_parent(node: nodes.NodeNG) -&gt; nodes.NodeNG:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the higher parent which is not an AssignName, Tuple or List node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+    return node</span>


<span class="gd">-def overrides_a_method(class_node: nodes.ClassDef, name: str) -&gt;bool:</span>
<span class="gi">+def overrides_a_method(class_node: nodes.ClassDef, name: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if &lt;name&gt; is a method overridden from an ancestor
<span class="w"> </span>    which is not the base object class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def only_required_for_messages(*messages: str) -&gt;Callable[[</span>
<span class="gd">-    AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]</span>
<span class="gd">-    ]:</span>
<span class="gi">+    for ancestor in class_node.ancestors():</span>
<span class="gi">+        if ancestor.name == &quot;object&quot;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if name in ancestor and isinstance(ancestor[name], nodes.FunctionDef):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def only_required_for_messages(</span>
<span class="gi">+    *messages: str,</span>
<span class="gi">+) -&gt; Callable[</span>
<span class="gi">+    [AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]</span>
<span class="gi">+]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator to store messages that are handled by a checker method as an
<span class="w"> </span>    attribute of the function object.

<span class="gu">@@ -190,7 +484,14 @@ def only_required_for_messages(*messages: str) -&gt;Callable[[</span>
<span class="w"> </span>    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods
<span class="w"> </span>    of a class inheriting from ``BaseChecker``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def store_messages(</span>
<span class="gi">+        func: AstCallbackMethod[_CheckerT, _NodeT]</span>
<span class="gi">+    ) -&gt; AstCallbackMethod[_CheckerT, _NodeT]:</span>
<span class="gi">+        func.checks_msgs = messages  # type: ignore[attr-defined]</span>
<span class="gi">+        return func</span>
<span class="gi">+</span>
<span class="gi">+    return store_messages</span>


<span class="w"> </span>class IncompleteFormatString(Exception):
<span class="gu">@@ -202,33 +503,133 @@ class UnsupportedFormatCharacter(Exception):</span>
<span class="w"> </span>    format characters.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, index: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, index: int) -&gt; None:</span>
<span class="w"> </span>        super().__init__(index)
<span class="w"> </span>        self.index = index


<span class="gd">-def parse_format_string(format_string: str) -&gt;tuple[set[str], int, dict[str,</span>
<span class="gd">-    str], list[str]]:</span>
<span class="gi">+def parse_format_string(</span>
<span class="gi">+    format_string: str,</span>
<span class="gi">+) -&gt; tuple[set[str], int, dict[str, str], list[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parses a format string, returning a tuple (keys, num_args).

<span class="w"> </span>    Where &#39;keys&#39; is the set of mapping keys in the format string, and &#39;num_args&#39; is the number
<span class="w"> </span>    of arguments required by the format string. Raises IncompleteFormatString or
<span class="w"> </span>    UnsupportedFormatCharacter if a parse error occurs.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def collect_string_fields(format_string: str) -&gt;Iterable[str | None]:</span>
<span class="gi">+    keys = set()</span>
<span class="gi">+    key_types = {}</span>
<span class="gi">+    pos_types = []</span>
<span class="gi">+    num_args = 0</span>
<span class="gi">+</span>
<span class="gi">+    def next_char(i: int) -&gt; tuple[int, str]:</span>
<span class="gi">+        i += 1</span>
<span class="gi">+        if i == len(format_string):</span>
<span class="gi">+            raise IncompleteFormatString</span>
<span class="gi">+        return (i, format_string[i])</span>
<span class="gi">+</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while i &lt; len(format_string):</span>
<span class="gi">+        char = format_string[i]</span>
<span class="gi">+        if char == &quot;%&quot;:</span>
<span class="gi">+            i, char = next_char(i)</span>
<span class="gi">+            # Parse the mapping key (optional).</span>
<span class="gi">+            key = None</span>
<span class="gi">+            if char == &quot;(&quot;:</span>
<span class="gi">+                depth = 1</span>
<span class="gi">+                i, char = next_char(i)</span>
<span class="gi">+                key_start = i</span>
<span class="gi">+                while depth != 0:</span>
<span class="gi">+                    if char == &quot;(&quot;:</span>
<span class="gi">+                        depth += 1</span>
<span class="gi">+                    elif char == &quot;)&quot;:</span>
<span class="gi">+                        depth -= 1</span>
<span class="gi">+                    i, char = next_char(i)</span>
<span class="gi">+                key_end = i - 1</span>
<span class="gi">+                key = format_string[key_start:key_end]</span>
<span class="gi">+</span>
<span class="gi">+            # Parse the conversion flags (optional).</span>
<span class="gi">+            while char in &quot;#0- +&quot;:</span>
<span class="gi">+                i, char = next_char(i)</span>
<span class="gi">+            # Parse the minimum field width (optional).</span>
<span class="gi">+            if char == &quot;*&quot;:</span>
<span class="gi">+                num_args += 1</span>
<span class="gi">+                i, char = next_char(i)</span>
<span class="gi">+            else:</span>
<span class="gi">+                while char in string.digits:</span>
<span class="gi">+                    i, char = next_char(i)</span>
<span class="gi">+            # Parse the precision (optional).</span>
<span class="gi">+            if char == &quot;.&quot;:</span>
<span class="gi">+                i, char = next_char(i)</span>
<span class="gi">+                if char == &quot;*&quot;:</span>
<span class="gi">+                    num_args += 1</span>
<span class="gi">+                    i, char = next_char(i)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    while char in string.digits:</span>
<span class="gi">+                        i, char = next_char(i)</span>
<span class="gi">+            # Parse the length modifier (optional).</span>
<span class="gi">+            if char in &quot;hlL&quot;:</span>
<span class="gi">+                i, char = next_char(i)</span>
<span class="gi">+            # Parse the conversion type (mandatory).</span>
<span class="gi">+            flags = &quot;diouxXeEfFgGcrs%a&quot;</span>
<span class="gi">+            if char not in flags:</span>
<span class="gi">+                raise UnsupportedFormatCharacter(i)</span>
<span class="gi">+            if key:</span>
<span class="gi">+                keys.add(key)</span>
<span class="gi">+                key_types[key] = char</span>
<span class="gi">+            elif char != &quot;%&quot;:</span>
<span class="gi">+                num_args += 1</span>
<span class="gi">+                pos_types.append(char)</span>
<span class="gi">+        i += 1</span>
<span class="gi">+    return keys, num_args, key_types, pos_types</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def split_format_field_names(</span>
<span class="gi">+    format_string: str,</span>
<span class="gi">+) -&gt; tuple[str, Iterable[tuple[bool, str]]]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return _string.formatter_field_name_split(format_string)  # type: ignore[no-any-return]</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise IncompleteFormatString() from e</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def collect_string_fields(format_string: str) -&gt; Iterable[str | None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a format string, return an iterator
<span class="w"> </span>    of all the valid format fields.

<span class="w"> </span>    It handles nested fields as well.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def parse_format_method_string(format_string: str) -&gt;tuple[list[tuple[str,</span>
<span class="gd">-    list[tuple[bool, str]]]], int, int]:</span>
<span class="gi">+    formatter = string.Formatter()</span>
<span class="gi">+    # pylint: disable = too-many-try-statements</span>
<span class="gi">+    try:</span>
<span class="gi">+        parseiterator = formatter.parse(format_string)</span>
<span class="gi">+        for result in parseiterator:</span>
<span class="gi">+            if all(item is None for item in result[1:]):</span>
<span class="gi">+                # not a replacement format</span>
<span class="gi">+                continue</span>
<span class="gi">+            name = result[1]</span>
<span class="gi">+            nested = result[2]</span>
<span class="gi">+            yield name</span>
<span class="gi">+            if nested:</span>
<span class="gi">+                yield from collect_string_fields(nested)</span>
<span class="gi">+    except ValueError as exc:</span>
<span class="gi">+        # Probably the format string is invalid.</span>
<span class="gi">+        if exc.args[0].startswith(&quot;cannot switch from manual&quot;):</span>
<span class="gi">+            # On Jython, parsing a string with both manual</span>
<span class="gi">+            # and automatic positions will fail with a ValueError,</span>
<span class="gi">+            # while on CPython it will simply return the fields,</span>
<span class="gi">+            # the validation being done in the interpreter (?).</span>
<span class="gi">+            # We&#39;re just returning two mixed fields in order</span>
<span class="gi">+            # to trigger the format-combined-specification check.</span>
<span class="gi">+            yield &quot;&quot;</span>
<span class="gi">+            yield &quot;1&quot;</span>
<span class="gi">+            return</span>
<span class="gi">+        raise IncompleteFormatString(format_string) from exc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_format_method_string(</span>
<span class="gi">+    format_string: str,</span>
<span class="gi">+) -&gt; tuple[list[tuple[str, list[tuple[bool, str]]]], int, int]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parses a PEP 3101 format string, returning a tuple of
<span class="w"> </span>    (keyword_arguments, implicit_pos_args_cnt, explicit_pos_args).

<span class="gu">@@ -236,39 +637,79 @@ def parse_format_method_string(format_string: str) -&gt;tuple[list[tuple[str,</span>
<span class="w"> </span>    is the number of arguments required by the format string and
<span class="w"> </span>    explicit_pos_args is the number of arguments passed with the position.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_attr_protected(attrname: str) -&gt;bool:</span>
<span class="gi">+    keyword_arguments = []</span>
<span class="gi">+    implicit_pos_args_cnt = 0</span>
<span class="gi">+    explicit_pos_args = set()</span>
<span class="gi">+    for name in collect_string_fields(format_string):</span>
<span class="gi">+        if name and str(name).isdigit():</span>
<span class="gi">+            explicit_pos_args.add(str(name))</span>
<span class="gi">+        elif name:</span>
<span class="gi">+            keyname, fielditerator = split_format_field_names(name)</span>
<span class="gi">+            if isinstance(keyname, numbers.Number):</span>
<span class="gi">+                explicit_pos_args.add(str(keyname))</span>
<span class="gi">+            try:</span>
<span class="gi">+                keyword_arguments.append((keyname, list(fielditerator)))</span>
<span class="gi">+            except ValueError as e:</span>
<span class="gi">+                raise IncompleteFormatString() from e</span>
<span class="gi">+        else:</span>
<span class="gi">+            implicit_pos_args_cnt += 1</span>
<span class="gi">+    return keyword_arguments, implicit_pos_args_cnt, len(explicit_pos_args)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_attr_protected(attrname: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if attribute name is protected (start with _ and some other
<span class="w"> </span>    details), False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        attrname[0] == &quot;_&quot;</span>
<span class="gi">+        and attrname != &quot;_&quot;</span>
<span class="gi">+        and not (attrname.startswith(&quot;__&quot;) and attrname.endswith(&quot;__&quot;))</span>
<span class="gi">+    )</span>


<span class="gd">-def node_frame_class(node: nodes.NodeNG) -&gt;(nodes.ClassDef | None):</span>
<span class="gi">+def node_frame_class(node: nodes.NodeNG) -&gt; nodes.ClassDef | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the class that is wrapping the given node.

<span class="w"> </span>    The function returns a class for a method node (or a staticmethod or a
<span class="w"> </span>    classmethod), otherwise it returns `None`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_outer_class(class_node: astroid.ClassDef) -&gt;(astroid.ClassDef | None):</span>
<span class="gi">+    klass = node.frame()</span>
<span class="gi">+    nodes_to_check = (</span>
<span class="gi">+        nodes.NodeNG,</span>
<span class="gi">+        astroid.UnboundMethod,</span>
<span class="gi">+        astroid.BaseInstance,</span>
<span class="gi">+    )</span>
<span class="gi">+    while (</span>
<span class="gi">+        klass</span>
<span class="gi">+        and isinstance(klass, nodes_to_check)</span>
<span class="gi">+        and not isinstance(klass, nodes.ClassDef)</span>
<span class="gi">+    ):</span>
<span class="gi">+        if klass.parent is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        klass = klass.parent.frame()</span>
<span class="gi">+</span>
<span class="gi">+    return klass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_outer_class(class_node: astroid.ClassDef) -&gt; astroid.ClassDef | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the class that is the outer class of given (nested) class_node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent_klass = class_node.parent.frame()</span>

<span class="gi">+    return parent_klass if isinstance(parent_klass, astroid.ClassDef) else None</span>

<span class="gd">-def is_attr_private(attrname: str) -&gt;(Match[str] | None):</span>
<span class="gi">+</span>
<span class="gi">+def is_attr_private(attrname: str) -&gt; Match[str] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check that attribute name is private (at least two leading underscores,
<span class="w"> </span>    at most one trailing underscore).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    regex = re.compile(&quot;^_{2,10}.*[^_]+_?$&quot;)</span>
<span class="gi">+    return regex.match(attrname)</span>


<span class="gd">-def get_argument_from_call(call_node: nodes.Call, position: (int | None)=</span>
<span class="gd">-    None, keyword: (str | None)=None) -&gt;nodes.Name:</span>
<span class="gi">+def get_argument_from_call(</span>
<span class="gi">+    call_node: nodes.Call, position: int | None = None, keyword: str | None = None</span>
<span class="gi">+) -&gt; nodes.Name:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the specified argument from a function call.

<span class="w"> </span>    :param nodes.Call call_node: Node representing a function call to check.
<span class="gu">@@ -281,11 +722,22 @@ def get_argument_from_call(call_node: nodes.Call, position: (int | None)=</span>
<span class="w"> </span>    :raises NoSuchArgumentError: if no argument at the provided position or with
<span class="w"> </span>    the provided keyword.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def infer_kwarg_from_call(call_node: nodes.Call, keyword: str) -&gt;(nodes.</span>
<span class="gd">-    Name | None):</span>
<span class="gi">+    if position is None and keyword is None:</span>
<span class="gi">+        raise ValueError(&quot;Must specify at least one of: position or keyword.&quot;)</span>
<span class="gi">+    if position is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return call_node.args[position]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    if keyword and call_node.keywords:</span>
<span class="gi">+        for arg in call_node.keywords:</span>
<span class="gi">+            if arg.arg == keyword:</span>
<span class="gi">+                return arg.value</span>
<span class="gi">+</span>
<span class="gi">+    raise NoSuchArgumentError</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def infer_kwarg_from_call(call_node: nodes.Call, keyword: str) -&gt; nodes.Name | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the specified argument from a function&#39;s kwargs.

<span class="w"> </span>    :param nodes.Call call_node: Node representing a function call to check.
<span class="gu">@@ -294,18 +746,32 @@ def infer_kwarg_from_call(call_node: nodes.Call, keyword: str) -&gt;(nodes.</span>
<span class="w"> </span>    :returns: The node representing the argument, None if the argument is not found.
<span class="w"> </span>    :rtype: nodes.Name
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for arg in call_node.kwargs:</span>
<span class="gi">+        inferred = safe_infer(arg.value)</span>
<span class="gi">+        if isinstance(inferred, nodes.Dict):</span>
<span class="gi">+            for item in inferred.items:</span>
<span class="gi">+                if item[0].value == keyword:</span>
<span class="gi">+                    return item[1]</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>


<span class="gd">-def inherit_from_std_ex(node: (nodes.NodeNG | astroid.Instance)) -&gt;bool:</span>
<span class="gi">+def inherit_from_std_ex(node: nodes.NodeNG | astroid.Instance) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return whether the given class node is subclass of
<span class="w"> </span>    exceptions.Exception.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def error_of_type(handler: nodes.ExceptHandler, error_type: (str | type[</span>
<span class="gd">-    Exception] | tuple[str | type[Exception], ...])) -&gt;bool:</span>
<span class="gi">+    ancestors = node.ancestors() if hasattr(node, &quot;ancestors&quot;) else []</span>
<span class="gi">+    return any(</span>
<span class="gi">+        ancestor.name in {&quot;Exception&quot;, &quot;BaseException&quot;}</span>
<span class="gi">+        and ancestor.root().name == EXCEPTIONS_MODULE</span>
<span class="gi">+        for ancestor in itertools.chain([node], ancestors)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_of_type(</span>
<span class="gi">+    handler: nodes.ExceptHandler,</span>
<span class="gi">+    error_type: str | type[Exception] | tuple[str | type[Exception], ...],</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given exception handler catches
<span class="w"> </span>    the given error_type.

<span class="gu">@@ -315,49 +781,163 @@ def error_of_type(handler: nodes.ExceptHandler, error_type: (str | type[</span>
<span class="w"> </span>    The function will return True if the handler catches any of the
<span class="w"> </span>    given errors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    def stringify_error(error: str | type[Exception]) -&gt; str:</span>
<span class="gi">+        if not isinstance(error, str):</span>
<span class="gi">+            return error.__name__</span>
<span class="gi">+        return error</span>

<span class="gd">-def decorated_with_property(node: nodes.FunctionDef) -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;Detect if the given function node is decorated with a property.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(error_type, tuple):</span>
<span class="gi">+        error_type = (error_type,)</span>
<span class="gi">+    expected_errors = {stringify_error(error) for error in error_type}</span>
<span class="gi">+    if not handler.type:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return handler.catch(expected_errors)  # type: ignore[no-any-return]</span>


<span class="gd">-def is_property_setter(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def decorated_with_property(node: nodes.FunctionDef) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Detect if the given function node is decorated with a property.&quot;&quot;&quot;</span>
<span class="gi">+    if not node.decorators:</span>
<span class="gi">+        return False</span>
<span class="gi">+    for decorator in node.decorators.nodes:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if _is_property_decorator(decorator):</span>
<span class="gi">+                return True</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_property_kind(node: nodes.NodeNG, *kinds: str) -&gt; bool:</span>
<span class="gi">+    if not isinstance(node, (astroid.UnboundMethod, nodes.FunctionDef)):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if node.decorators:</span>
<span class="gi">+        for decorator in node.decorators.nodes:</span>
<span class="gi">+            if isinstance(decorator, nodes.Attribute) and decorator.attrname in kinds:</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_property_setter(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given node is a property setter.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _is_property_kind(node, &quot;setter&quot;)</span>


<span class="gd">-def is_property_deleter(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_property_deleter(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given node is a property deleter.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _is_property_kind(node, &quot;deleter&quot;)</span>


<span class="gd">-def is_property_setter_or_deleter(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_property_setter_or_deleter(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given node is either a property setter or a deleter.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def decorated_with(func: (nodes.ClassDef | nodes.FunctionDef | astroid.</span>
<span class="gd">-    BoundMethod | astroid.UnboundMethod), qnames: Iterable[str]) -&gt;bool:</span>
<span class="gi">+    return _is_property_kind(node, &quot;setter&quot;, &quot;deleter&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_property_decorator(decorator: nodes.Name) -&gt; bool:</span>
<span class="gi">+    for inferred in decorator.infer():</span>
<span class="gi">+        if isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+            if inferred.qname() in {&quot;builtins.property&quot;, &quot;functools.cached_property&quot;}:</span>
<span class="gi">+                return True</span>
<span class="gi">+            for ancestor in inferred.ancestors():</span>
<span class="gi">+                if ancestor.name == &quot;property&quot; and ancestor.root().name == &quot;builtins&quot;:</span>
<span class="gi">+                    return True</span>
<span class="gi">+        elif isinstance(inferred, nodes.FunctionDef):</span>
<span class="gi">+            # If decorator is function, check if it has exactly one return</span>
<span class="gi">+            # and the return is itself a function decorated with property</span>
<span class="gi">+            returns: list[nodes.Return] = list(</span>
<span class="gi">+                inferred._get_return_nodes_skip_functions()</span>
<span class="gi">+            )</span>
<span class="gi">+            if len(returns) == 1 and isinstance(</span>
<span class="gi">+                returns[0].value, (nodes.Name, nodes.Attribute)</span>
<span class="gi">+            ):</span>
<span class="gi">+                inferred = safe_infer(returns[0].value)</span>
<span class="gi">+                if (</span>
<span class="gi">+                    inferred</span>
<span class="gi">+                    and isinstance(inferred, astroid.objects.Property)</span>
<span class="gi">+                    and isinstance(inferred.function, nodes.FunctionDef)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return decorated_with_property(inferred.function)</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def decorated_with(</span>
<span class="gi">+    func: (</span>
<span class="gi">+        nodes.ClassDef | nodes.FunctionDef | astroid.BoundMethod | astroid.UnboundMethod</span>
<span class="gi">+    ),</span>
<span class="gi">+    qnames: Iterable[str],</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine if the `func` node has a decorator with the qualified name `qname`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def uninferable_final_decorators(node: nodes.Decorators) -&gt;list[nodes.</span>
<span class="gd">-    Attribute | nodes.Name | None]:</span>
<span class="gi">+    decorators = func.decorators.nodes if func.decorators else []</span>
<span class="gi">+    for decorator_node in decorators:</span>
<span class="gi">+        if isinstance(decorator_node, nodes.Call):</span>
<span class="gi">+            # We only want to infer the function name</span>
<span class="gi">+            decorator_node = decorator_node.func</span>
<span class="gi">+        try:</span>
<span class="gi">+            if any(</span>
<span class="gi">+                i.name in qnames or i.qname() in qnames</span>
<span class="gi">+                for i in decorator_node.infer()</span>
<span class="gi">+                if i is not None and not isinstance(i, util.UninferableBase)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            continue</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def uninferable_final_decorators(</span>
<span class="gi">+    node: nodes.Decorators,</span>
<span class="gi">+) -&gt; list[nodes.Attribute | nodes.Name | None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a list of uninferable `typing.final` decorators in `node`.

<span class="w"> </span>    This function is used to determine if the `typing.final` decorator is used
<span class="w"> </span>    with an unsupported Python version; the decorator cannot be inferred when
<span class="w"> </span>    using a Python version lower than 3.8.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    decorators = []</span>
<span class="gi">+    for decorator in getattr(node, &quot;nodes&quot;, []):</span>
<span class="gi">+        import_nodes: tuple[nodes.Import | nodes.ImportFrom] | None = None</span>
<span class="gi">+</span>
<span class="gi">+        # Get the `Import` node. The decorator is of the form: @module.name</span>
<span class="gi">+        if isinstance(decorator, nodes.Attribute):</span>
<span class="gi">+            inferred = safe_infer(decorator.expr)</span>
<span class="gi">+            if isinstance(inferred, nodes.Module) and inferred.qname() == &quot;typing&quot;:</span>
<span class="gi">+                _, import_nodes = decorator.expr.lookup(decorator.expr.name)</span>
<span class="gi">+</span>
<span class="gi">+        # Get the `ImportFrom` node. The decorator is of the form: @name</span>
<span class="gi">+        elif isinstance(decorator, nodes.Name):</span>
<span class="gi">+            _, import_nodes = decorator.lookup(decorator.name)</span>
<span class="gi">+</span>
<span class="gi">+        # The `final` decorator is expected to be found in the</span>
<span class="gi">+        # import_nodes. Continue if we don&#39;t find any `Import` or `ImportFrom`</span>
<span class="gi">+        # nodes for this decorator.</span>
<span class="gi">+        if not import_nodes:</span>
<span class="gi">+            continue</span>
<span class="gi">+        import_node = import_nodes[0]</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(import_node, (astroid.Import, astroid.ImportFrom)):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        import_names = dict(import_node.names)</span>
<span class="gi">+</span>
<span class="gi">+        # Check if the import is of the form: `from typing import final`</span>
<span class="gi">+        is_from_import = (&quot;final&quot; in import_names) and import_node.modname == &quot;typing&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Check if the import is of the form: `import typing`</span>
<span class="gi">+        is_import = (&quot;typing&quot; in import_names) and getattr(</span>
<span class="gi">+            decorator, &quot;attrname&quot;, None</span>
<span class="gi">+        ) == &quot;final&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if is_from_import or is_import:</span>
<span class="gi">+            inferred = safe_infer(decorator)</span>
<span class="gi">+            if inferred is None or isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+                decorators.append(decorator)</span>
<span class="gi">+    return decorators</span>


<span class="w"> </span>@lru_cache(maxsize=1024)
<span class="gd">-def unimplemented_abstract_methods(node: nodes.ClassDef, is_abstract_cb: (</span>
<span class="gd">-    nodes.FunctionDef | None)=None) -&gt;dict[str, nodes.FunctionDef]:</span>
<span class="gi">+def unimplemented_abstract_methods(</span>
<span class="gi">+    node: nodes.ClassDef, is_abstract_cb: nodes.FunctionDef | None = None</span>
<span class="gi">+) -&gt; dict[str, nodes.FunctionDef]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the unimplemented abstract methods for the given *node*.

<span class="w"> </span>    A method can be considered abstract if the callback *is_abstract_cb*
<span class="gu">@@ -366,28 +946,113 @@ def unimplemented_abstract_methods(node: nodes.ClassDef, is_abstract_cb: (</span>
<span class="w"> </span>    It will return a dictionary of abstract method
<span class="w"> </span>    names and their inferred objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def find_try_except_wrapper_node(node: nodes.NodeNG) -&gt;(nodes.ExceptHandler |</span>
<span class="gd">-    nodes.Try | None):</span>
<span class="gi">+    if is_abstract_cb is None:</span>
<span class="gi">+        is_abstract_cb = partial(decorated_with, qnames=ABC_METHODS)</span>
<span class="gi">+    visited: dict[str, nodes.FunctionDef] = {}</span>
<span class="gi">+    try:</span>
<span class="gi">+        mro = reversed(node.mro())</span>
<span class="gi">+    except astroid.ResolveError:</span>
<span class="gi">+        # Probably inconsistent hierarchy, don&#39;t try to figure this out here.</span>
<span class="gi">+        return {}</span>
<span class="gi">+    for ancestor in mro:</span>
<span class="gi">+        for obj in ancestor.values():</span>
<span class="gi">+            inferred = obj</span>
<span class="gi">+            if isinstance(obj, nodes.AssignName):</span>
<span class="gi">+                inferred = safe_infer(obj)</span>
<span class="gi">+                if not inferred:</span>
<span class="gi">+                    # Might be an abstract function,</span>
<span class="gi">+                    # but since we don&#39;t have enough information</span>
<span class="gi">+                    # in order to take this decision, we&#39;re taking</span>
<span class="gi">+                    # the *safe* decision instead.</span>
<span class="gi">+                    if obj.name in visited:</span>
<span class="gi">+                        del visited[obj.name]</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if not isinstance(inferred, nodes.FunctionDef):</span>
<span class="gi">+                    if obj.name in visited:</span>
<span class="gi">+                        del visited[obj.name]</span>
<span class="gi">+            if isinstance(inferred, nodes.FunctionDef):</span>
<span class="gi">+                # It&#39;s critical to use the original name,</span>
<span class="gi">+                # since after inferring, an object can be something</span>
<span class="gi">+                # else than expected, as in the case of the</span>
<span class="gi">+                # following assignment.</span>
<span class="gi">+                #</span>
<span class="gi">+                # class A:</span>
<span class="gi">+                #     def keys(self): pass</span>
<span class="gi">+                #     __iter__ = keys</span>
<span class="gi">+                abstract = is_abstract_cb(inferred)</span>
<span class="gi">+                if abstract:</span>
<span class="gi">+                    visited[obj.name] = inferred</span>
<span class="gi">+                elif not abstract and obj.name in visited:</span>
<span class="gi">+                    del visited[obj.name]</span>
<span class="gi">+    return visited</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_try_except_wrapper_node(</span>
<span class="gi">+    node: nodes.NodeNG,</span>
<span class="gi">+) -&gt; nodes.ExceptHandler | nodes.Try | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the ExceptHandler or the Try node in which the node is.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current = node</span>
<span class="gi">+    ignores = (nodes.ExceptHandler, nodes.Try)</span>
<span class="gi">+    while current and not isinstance(current.parent, ignores):</span>
<span class="gi">+        current = current.parent</span>
<span class="gi">+</span>
<span class="gi">+    if current and isinstance(current.parent, ignores):</span>
<span class="gi">+        return current.parent</span>
<span class="gi">+    return None</span>


<span class="gd">-def find_except_wrapper_node_in_scope(node: nodes.NodeNG) -&gt;(nodes.</span>
<span class="gd">-    ExceptHandler | None):</span>
<span class="gi">+def find_except_wrapper_node_in_scope(</span>
<span class="gi">+    node: nodes.NodeNG,</span>
<span class="gi">+) -&gt; nodes.ExceptHandler | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the ExceptHandler in which the node is, without going out of scope.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for current in node.node_ancestors():</span>
<span class="gi">+        if isinstance(current, astroid.scoped_nodes.LocalsDictNodeNG):</span>
<span class="gi">+            # If we&#39;re inside a function/class definition, we don&#39;t want to keep checking</span>
<span class="gi">+            # higher ancestors for `except` clauses, because if these exist, it means our</span>
<span class="gi">+            # function/class was defined in an `except` clause, rather than the current code</span>
<span class="gi">+            # actually running in an `except` clause.</span>
<span class="gi">+            return None</span>
<span class="gi">+        if isinstance(current, nodes.ExceptHandler):</span>
<span class="gi">+            return current</span>
<span class="gi">+    return None</span>


<span class="gd">-def is_from_fallback_block(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_from_fallback_block(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given node is from a fallback import block.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_exception_handlers(node: nodes.NodeNG, exception: (type[Exception] |</span>
<span class="gd">-    str)=Exception) -&gt;(list[nodes.ExceptHandler] | None):</span>
<span class="gi">+    context = find_try_except_wrapper_node(node)</span>
<span class="gi">+    if not context:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(context, nodes.ExceptHandler):</span>
<span class="gi">+        other_body = context.parent.body</span>
<span class="gi">+        handlers = context.parent.handlers</span>
<span class="gi">+    else:</span>
<span class="gi">+        other_body = itertools.chain.from_iterable(</span>
<span class="gi">+            handler.body for handler in context.handlers</span>
<span class="gi">+        )</span>
<span class="gi">+        handlers = context.handlers</span>
<span class="gi">+</span>
<span class="gi">+    has_fallback_imports = any(</span>
<span class="gi">+        isinstance(import_node, (nodes.ImportFrom, nodes.Import))</span>
<span class="gi">+        for import_node in other_body</span>
<span class="gi">+    )</span>
<span class="gi">+    ignores_import_error = _except_handlers_ignores_exceptions(</span>
<span class="gi">+        handlers, (ImportError, ModuleNotFoundError)</span>
<span class="gi">+    )</span>
<span class="gi">+    return ignores_import_error or has_fallback_imports</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _except_handlers_ignores_exceptions(</span>
<span class="gi">+    handlers: nodes.ExceptHandler,</span>
<span class="gi">+    exceptions: tuple[type[ImportError], type[ModuleNotFoundError]],</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    func = partial(error_of_type, error_type=exceptions)</span>
<span class="gi">+    return any(func(handler) for handler in handlers)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_exception_handlers(</span>
<span class="gi">+    node: nodes.NodeNG, exception: type[Exception] | str = Exception</span>
<span class="gi">+) -&gt; list[nodes.ExceptHandler] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the collections of handlers handling the exception in arguments.

<span class="w"> </span>    Args:
<span class="gu">@@ -397,22 +1062,46 @@ def get_exception_handlers(node: nodes.NodeNG, exception: (type[Exception] |</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        list: the collection of handlers that are handling the exception or None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    context = find_try_except_wrapper_node(node)</span>
<span class="gi">+    if isinstance(context, nodes.Try):</span>
<span class="gi">+        return [</span>
<span class="gi">+            handler for handler in context.handlers if error_of_type(handler, exception)</span>
<span class="gi">+        ]</span>
<span class="gi">+    return []</span>


<span class="gd">-def get_contextlib_with_statements(node: nodes.NodeNG) -&gt;Iterator[nodes.With]:</span>
<span class="gi">+def get_contextlib_with_statements(node: nodes.NodeNG) -&gt; Iterator[nodes.With]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get all contextlib.with statements in the ancestors of the given node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for with_node in node.node_ancestors():</span>
<span class="gi">+        if isinstance(with_node, nodes.With):</span>
<span class="gi">+            yield with_node</span>


<span class="gd">-def _suppresses_exception(call: nodes.Call, exception: (type[Exception] |</span>
<span class="gd">-    str)=Exception) -&gt;bool:</span>
<span class="gi">+def _suppresses_exception(</span>
<span class="gi">+    call: nodes.Call, exception: type[Exception] | str = Exception</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given node suppresses the given exception.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_contextlib_suppressors(node: nodes.NodeNG, exception: (type[</span>
<span class="gd">-    Exception] | str)=Exception) -&gt;Iterator[nodes.With]:</span>
<span class="gi">+    if not isinstance(exception, str):</span>
<span class="gi">+        exception = exception.__name__</span>
<span class="gi">+    for arg in call.args:</span>
<span class="gi">+        inferred = safe_infer(arg)</span>
<span class="gi">+        if isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+            if inferred.name == exception:</span>
<span class="gi">+                return True</span>
<span class="gi">+        elif isinstance(inferred, nodes.Tuple):</span>
<span class="gi">+            for elt in inferred.elts:</span>
<span class="gi">+                inferred_elt = safe_infer(elt)</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(inferred_elt, nodes.ClassDef)</span>
<span class="gi">+                    and inferred_elt.name == exception</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_contextlib_suppressors(</span>
<span class="gi">+    node: nodes.NodeNG, exception: type[Exception] | str = Exception</span>
<span class="gi">+) -&gt; Iterator[nodes.With]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the contextlib suppressors handling the exception.

<span class="w"> </span>    Args:
<span class="gu">@@ -422,10 +1111,19 @@ def get_contextlib_suppressors(node: nodes.NodeNG, exception: (type[</span>
<span class="w"> </span>    Yields:
<span class="w"> </span>        nodes.With: A with node that is suppressing the exception.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_node_inside_try_except(node: nodes.Raise) -&gt;bool:</span>
<span class="gi">+    for with_node in get_contextlib_with_statements(node):</span>
<span class="gi">+        for item, _ in with_node.items:</span>
<span class="gi">+            if isinstance(item, nodes.Call):</span>
<span class="gi">+                inferred = safe_infer(item.func)</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(inferred, nodes.ClassDef)</span>
<span class="gi">+                    and inferred.qname() == &quot;contextlib.suppress&quot;</span>
<span class="gi">+                ):</span>
<span class="gi">+                    if _suppresses_exception(item, exception):</span>
<span class="gi">+                        yield with_node</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_node_inside_try_except(node: nodes.Raise) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the node is directly under a Try/Except statement
<span class="w"> </span>    (but not under an ExceptHandler!).

<span class="gu">@@ -435,31 +1133,221 @@ def is_node_inside_try_except(node: nodes.Raise) -&gt;bool:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        bool: True if the node is inside a try/except statement, False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    context = find_try_except_wrapper_node(node)</span>
<span class="gi">+    return isinstance(context, nodes.Try)</span>


<span class="gd">-def node_ignores_exception(node: nodes.NodeNG, exception: (type[Exception] |</span>
<span class="gd">-    str)=Exception) -&gt;bool:</span>
<span class="gi">+def node_ignores_exception(</span>
<span class="gi">+    node: nodes.NodeNG, exception: type[Exception] | str = Exception</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the node is in a Try which handles the given exception.

<span class="w"> </span>    If the exception is not given, the function is going to look for bare
<span class="w"> </span>    excepts.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    managing_handlers = get_exception_handlers(node, exception)</span>
<span class="gi">+    if managing_handlers:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return any(get_contextlib_suppressors(node, exception))</span>


<span class="w"> </span>@lru_cache(maxsize=1024)
<span class="gd">-def class_is_abstract(node: nodes.ClassDef) -&gt;bool:</span>
<span class="gi">+def class_is_abstract(node: nodes.ClassDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if the given class node should be considered as an abstract
<span class="w"> </span>    class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Protocol classes are considered &quot;abstract&quot;</span>
<span class="gi">+    if is_protocol_class(node):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Only check for explicit metaclass=ABCMeta on this specific class</span>
<span class="gi">+    meta = node.declared_metaclass()</span>
<span class="gi">+    if meta is not None:</span>
<span class="gi">+        if meta.name == &quot;ABCMeta&quot; and meta.root().name in ABC_MODULES:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    for ancestor in node.ancestors():</span>
<span class="gi">+        if ancestor.name == &quot;ABC&quot; and ancestor.root().name in ABC_MODULES:</span>
<span class="gi">+            # abc.ABC inheritance</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    for method in node.methods():</span>
<span class="gi">+        if method.parent.frame() is node:</span>
<span class="gi">+            if method.is_abstract(pass_is_abstract=False):</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _supports_protocol_method(value: nodes.NodeNG, attr: str) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        attributes = value.getattr(attr)</span>
<span class="gi">+    except astroid.NotFoundError:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    first = attributes[0]</span>
<span class="gi">+</span>
<span class="gi">+    # Return False if a constant is assigned</span>
<span class="gi">+    if isinstance(first, nodes.AssignName):</span>
<span class="gi">+        this_assign_parent = get_node_first_ancestor_of_type(</span>
<span class="gi">+            first, (nodes.Assign, nodes.NamedExpr)</span>
<span class="gi">+        )</span>
<span class="gi">+        if this_assign_parent is None:  # pragma: no cover</span>
<span class="gi">+            # Cannot imagine this being None, but return True to avoid false positives</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(this_assign_parent.value, nodes.BaseContainer):</span>
<span class="gi">+            if all(isinstance(n, nodes.Const) for n in this_assign_parent.value.elts):</span>
<span class="gi">+                return False</span>
<span class="gi">+        if isinstance(this_assign_parent.value, nodes.Const):</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_comprehension(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    comprehensions = (</span>
<span class="gi">+        nodes.ListComp,</span>
<span class="gi">+        nodes.SetComp,</span>
<span class="gi">+        nodes.DictComp,</span>
<span class="gi">+        nodes.GeneratorExp,</span>
<span class="gi">+    )</span>
<span class="gi">+    return isinstance(node, comprehensions)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _supports_mapping_protocol(value: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol_method(</span>
<span class="gi">+        value, GETITEM_METHOD</span>
<span class="gi">+    ) and _supports_protocol_method(value, KEYS_METHOD)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _supports_membership_test_protocol(value: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol_method(value, CONTAINS_METHOD)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _supports_iteration_protocol(value: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol_method(value, ITER_METHOD) or _supports_protocol_method(</span>
<span class="gi">+        value, GETITEM_METHOD</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _supports_async_iteration_protocol(value: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol_method(value, AITER_METHOD)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _supports_getitem_protocol(value: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol_method(value, GETITEM_METHOD)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _supports_setitem_protocol(value: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol_method(value, SETITEM_METHOD)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _supports_delitem_protocol(value: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol_method(value, DELITEM_METHOD)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_abstract_class_name(name: str) -&gt; bool:</span>
<span class="gi">+    lname = name.lower()</span>
<span class="gi">+    is_mixin = lname.endswith(&quot;mixin&quot;)</span>
<span class="gi">+    is_abstract = lname.startswith(&quot;abstract&quot;)</span>
<span class="gi">+    is_base = lname.startswith(&quot;base&quot;) or lname.endswith(&quot;base&quot;)</span>
<span class="gi">+    return is_mixin or is_abstract or is_base</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_inside_abstract_class(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    while node is not None:</span>
<span class="gi">+        if isinstance(node, nodes.ClassDef):</span>
<span class="gi">+            if class_is_abstract(node):</span>
<span class="gi">+                return True</span>
<span class="gi">+            name = getattr(node, &quot;name&quot;, None)</span>
<span class="gi">+            if name is not None and _is_abstract_class_name(name):</span>
<span class="gi">+                return True</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _supports_protocol(</span>
<span class="gi">+    value: nodes.NodeNG, protocol_callback: Callable[[nodes.NodeNG], bool]</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    if isinstance(value, nodes.ClassDef):</span>
<span class="gi">+        if not has_known_bases(value):</span>
<span class="gi">+            return True</span>
<span class="gi">+        # classobj can only be iterable if it has an iterable metaclass</span>
<span class="gi">+        meta = value.metaclass()</span>
<span class="gi">+        if meta is not None:</span>
<span class="gi">+            if protocol_callback(meta):</span>
<span class="gi">+                return True</span>
<span class="gi">+    if isinstance(value, astroid.BaseInstance):</span>
<span class="gi">+        if not has_known_bases(value):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if value.has_dynamic_getattr():</span>
<span class="gi">+            return True</span>
<span class="gi">+        if protocol_callback(value):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, nodes.ComprehensionScope):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        isinstance(value, astroid.bases.Proxy)</span>
<span class="gi">+        and isinstance(value._proxied, astroid.BaseInstance)</span>
<span class="gi">+        and has_known_bases(value._proxied)</span>
<span class="gi">+    ):</span>
<span class="gi">+        value = value._proxied</span>
<span class="gi">+        return protocol_callback(value)</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_iterable(value: nodes.NodeNG, check_async: bool = False) -&gt; bool:</span>
<span class="gi">+    if check_async:</span>
<span class="gi">+        protocol_check = _supports_async_iteration_protocol</span>
<span class="gi">+    else:</span>
<span class="gi">+        protocol_check = _supports_iteration_protocol</span>
<span class="gi">+    return _supports_protocol(value, protocol_check)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_mapping(value: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol(value, _supports_mapping_protocol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def supports_membership_test(value: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    supported = _supports_protocol(value, _supports_membership_test_protocol)</span>
<span class="gi">+    return supported or is_iterable(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def supports_getitem(value: nodes.NodeNG, node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    if isinstance(value, nodes.ClassDef):</span>
<span class="gi">+        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(</span>
<span class="gi">+            node</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return _supports_protocol(value, _supports_getitem_protocol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def supports_setitem(value: nodes.NodeNG, _: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol(value, _supports_setitem_protocol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def supports_delitem(value: nodes.NodeNG, _: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return _supports_protocol(value, _supports_delitem_protocol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_python_type_of_node(node: nodes.NodeNG) -&gt; str | None:</span>
<span class="gi">+    pytype: Callable[[], str] | None = getattr(node, &quot;pytype&quot;, None)</span>
<span class="gi">+    if callable(pytype):</span>
<span class="gi">+        return pytype()</span>
<span class="gi">+    return None</span>


<span class="w"> </span>@lru_cache(maxsize=1024)
<span class="gd">-def safe_infer(node: nodes.NodeNG, context: (InferenceContext | None)=None,</span>
<span class="gd">-    *, compare_constants: bool=False, compare_constructors: bool=False) -&gt;(</span>
<span class="gd">-    InferenceResult | None):</span>
<span class="gi">+def safe_infer(</span>
<span class="gi">+    node: nodes.NodeNG,</span>
<span class="gi">+    context: InferenceContext | None = None,</span>
<span class="gi">+    *,</span>
<span class="gi">+    compare_constants: bool = False,</span>
<span class="gi">+    compare_constructors: bool = False,</span>
<span class="gi">+) -&gt; InferenceResult | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the inferred value for the given node.

<span class="w"> </span>    Return None if inference failed or if there is some ambiguity (more than
<span class="gu">@@ -471,145 +1359,462 @@ def safe_infer(node: nodes.NodeNG, context: (InferenceContext | None)=None,</span>
<span class="w"> </span>    If compare_constructors is True and if multiple classes are inferred,
<span class="w"> </span>    constructors with different signatures are held ambiguous and return None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def has_known_bases(klass: nodes.ClassDef, context: (InferenceContext |</span>
<span class="gd">-    None)=None) -&gt;bool:</span>
<span class="gi">+    inferred_types: set[str | None] = set()</span>
<span class="gi">+    try:</span>
<span class="gi">+        infer_gen = node.infer(context=context)</span>
<span class="gi">+        value = next(infer_gen)</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return None</span>
<span class="gi">+    except Exception as e:  # pragma: no cover</span>
<span class="gi">+        raise AstroidError from e</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(value, util.UninferableBase):</span>
<span class="gi">+        inferred_types.add(_get_python_type_of_node(value))</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-try-statements</span>
<span class="gi">+    try:</span>
<span class="gi">+        for inferred in infer_gen:</span>
<span class="gi">+            inferred_type = _get_python_type_of_node(inferred)</span>
<span class="gi">+            if inferred_type not in inferred_types:</span>
<span class="gi">+                return None  # If there is ambiguity on the inferred node.</span>
<span class="gi">+            if (</span>
<span class="gi">+                compare_constants</span>
<span class="gi">+                and isinstance(inferred, nodes.Const)</span>
<span class="gi">+                and isinstance(value, nodes.Const)</span>
<span class="gi">+                and inferred.value != value.value</span>
<span class="gi">+            ):</span>
<span class="gi">+                return None</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(inferred, nodes.FunctionDef)</span>
<span class="gi">+                and isinstance(value, nodes.FunctionDef)</span>
<span class="gi">+                and function_arguments_are_ambiguous(inferred, value)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return None</span>
<span class="gi">+            if (</span>
<span class="gi">+                compare_constructors</span>
<span class="gi">+                and isinstance(inferred, nodes.ClassDef)</span>
<span class="gi">+                and isinstance(value, nodes.ClassDef)</span>
<span class="gi">+                and class_constructors_are_ambiguous(inferred, value)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return None</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return None  # There is some kind of ambiguity</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return value</span>
<span class="gi">+    except Exception as e:  # pragma: no cover</span>
<span class="gi">+        raise AstroidError from e</span>
<span class="gi">+    return value if len(inferred_types) &lt;= 1 else None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@lru_cache(maxsize=512)</span>
<span class="gi">+def infer_all(</span>
<span class="gi">+    node: nodes.NodeNG, context: InferenceContext | None = None</span>
<span class="gi">+) -&gt; list[InferenceResult]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return list(node.infer(context=context))</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return []</span>
<span class="gi">+    except Exception as e:  # pragma: no cover</span>
<span class="gi">+        raise AstroidError from e</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def function_arguments_are_ambiguous(</span>
<span class="gi">+    func1: nodes.FunctionDef, func2: nodes.FunctionDef</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    if func1.argnames() != func2.argnames():</span>
<span class="gi">+        return True</span>
<span class="gi">+    # Check ambiguity among function default values</span>
<span class="gi">+    pairs_of_defaults = [</span>
<span class="gi">+        (func1.args.defaults, func2.args.defaults),</span>
<span class="gi">+        (func1.args.kw_defaults, func2.args.kw_defaults),</span>
<span class="gi">+    ]</span>
<span class="gi">+    for zippable_default in pairs_of_defaults:</span>
<span class="gi">+        if None in zippable_default:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if len(zippable_default[0]) != len(zippable_default[1]):</span>
<span class="gi">+            return True</span>
<span class="gi">+        for default1, default2 in zip(*zippable_default):</span>
<span class="gi">+            if isinstance(default1, nodes.Const) and isinstance(default2, nodes.Const):</span>
<span class="gi">+                if default1.value != default2.value:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            elif isinstance(default1, nodes.Name) and isinstance(default2, nodes.Name):</span>
<span class="gi">+                if default1.name != default2.name:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            else:</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def class_constructors_are_ambiguous(</span>
<span class="gi">+    class1: nodes.ClassDef, class2: nodes.ClassDef</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        constructor1 = class1.local_attr(&quot;__init__&quot;)[0]</span>
<span class="gi">+        constructor2 = class2.local_attr(&quot;__init__&quot;)[0]</span>
<span class="gi">+    except astroid.NotFoundError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if not isinstance(constructor1, nodes.FunctionDef):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if not isinstance(constructor2, nodes.FunctionDef):</span>
<span class="gi">+        return False</span>
<span class="gi">+    return function_arguments_are_ambiguous(constructor1, constructor2)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def has_known_bases(</span>
<span class="gi">+    klass: nodes.ClassDef, context: InferenceContext | None = None</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return true if all base classes of a class could be inferred.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def node_type(node: nodes.NodeNG) -&gt;(SuccessfulInferenceResult | None):</span>
<span class="gi">+    try:</span>
<span class="gi">+        return klass._all_bases_known  # type: ignore[no-any-return]</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    for base in klass.bases:</span>
<span class="gi">+        result = safe_infer(base, context=context)</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(result, nodes.ClassDef)</span>
<span class="gi">+            or result is klass</span>
<span class="gi">+            or not has_known_bases(result, context=context)</span>
<span class="gi">+        ):</span>
<span class="gi">+            klass._all_bases_known = False</span>
<span class="gi">+            return False</span>
<span class="gi">+    klass._all_bases_known = True</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_none(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return (</span>
<span class="gi">+        node is None</span>
<span class="gi">+        or (isinstance(node, nodes.Const) and node.value is None)</span>
<span class="gi">+        or (isinstance(node, nodes.Name) and node.name == &quot;None&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def node_type(node: nodes.NodeNG) -&gt; SuccessfulInferenceResult | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the inferred type for `node`.

<span class="w"> </span>    If there is more than one possible type, or if inferred type is Uninferable or None,
<span class="w"> </span>    return None
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # check there is only one possible type for the assign node. Else we</span>
<span class="gi">+    # don&#39;t handle it for now</span>
<span class="gi">+    types: set[SuccessfulInferenceResult] = set()</span>
<span class="gi">+    try:</span>
<span class="gi">+        for var_type in node.infer():</span>
<span class="gi">+            if isinstance(var_type, util.UninferableBase) or is_none(var_type):</span>
<span class="gi">+                continue</span>
<span class="gi">+            types.add(var_type)</span>
<span class="gi">+            if len(types) &gt; 1:</span>
<span class="gi">+                return None</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return types.pop() if types else None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_registered_in_singledispatch_function(node: nodes.FunctionDef) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Check if the given function node is a singledispatch function.&quot;&quot;&quot;</span>
<span class="gi">+    singledispatch_qnames = (</span>
<span class="gi">+        &quot;functools.singledispatch&quot;,</span>
<span class="gi">+        &quot;singledispatch.singledispatch&quot;,</span>
<span class="gi">+    )</span>

<span class="gi">+    if not isinstance(node, nodes.FunctionDef):</span>
<span class="gi">+        return False</span>

<span class="gd">-def is_registered_in_singledispatch_function(node: nodes.FunctionDef) -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;Check if the given function node is a singledispatch function.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    decorators = node.decorators.nodes if node.decorators else []</span>
<span class="gi">+    for decorator in decorators:</span>
<span class="gi">+        # func.register are function calls or register attributes</span>
<span class="gi">+        # when the function is annotated with types</span>
<span class="gi">+        if isinstance(decorator, nodes.Call):</span>
<span class="gi">+            func = decorator.func</span>
<span class="gi">+        elif isinstance(decorator, nodes.Attribute):</span>
<span class="gi">+            func = decorator</span>
<span class="gi">+        else:</span>
<span class="gi">+            continue</span>

<span class="gi">+        if not isinstance(func, nodes.Attribute) or func.attrname != &quot;register&quot;:</span>
<span class="gi">+            continue</span>

<span class="gd">-def is_registered_in_singledispatchmethod_function(node: nodes.FunctionDef</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            func_def = next(func.expr.infer())</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(func_def, nodes.FunctionDef):</span>
<span class="gi">+            return decorated_with(func_def, singledispatch_qnames)</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_inferred_fn_from_register(node: nodes.NodeNG) -&gt; nodes.FunctionDef | None:</span>
<span class="gi">+    # func.register are function calls or register attributes</span>
<span class="gi">+    # when the function is annotated with types</span>
<span class="gi">+    if isinstance(node, nodes.Call):</span>
<span class="gi">+        func = node.func</span>
<span class="gi">+    elif isinstance(node, nodes.Attribute):</span>
<span class="gi">+        func = node</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(func, nodes.Attribute) or func.attrname != &quot;register&quot;:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    func_def = safe_infer(func.expr)</span>
<span class="gi">+    if not isinstance(func_def, nodes.FunctionDef):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    return func_def</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_registered_in_singledispatchmethod_function(node: nodes.FunctionDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given function node is a singledispatchmethod function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    singledispatchmethod_qnames = (</span>
<span class="gi">+        &quot;functools.singledispatchmethod&quot;,</span>
<span class="gi">+        &quot;singledispatch.singledispatchmethod&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    decorators = node.decorators.nodes if node.decorators else []</span>
<span class="gi">+    for decorator in decorators:</span>
<span class="gi">+        func_def = find_inferred_fn_from_register(decorator)</span>
<span class="gi">+        if func_def:</span>
<span class="gi">+            return decorated_with(func_def, singledispatchmethod_qnames)</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>


<span class="gd">-def get_node_last_lineno(node: nodes.NodeNG) -&gt;int:</span>
<span class="gi">+def get_node_last_lineno(node: nodes.NodeNG) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the last lineno of the given node.

<span class="w"> </span>    For a simple statement this will just be node.lineno,
<span class="w"> </span>    but for a node that has child statements (e.g. a method) this will be the lineno of the last
<span class="w"> </span>    child statement recursively.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_postponed_evaluation_enabled(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    # &#39;finalbody&#39; is always the last clause in a try statement, if present</span>
<span class="gi">+    if getattr(node, &quot;finalbody&quot;, False):</span>
<span class="gi">+        return get_node_last_lineno(node.finalbody[-1])</span>
<span class="gi">+    # For if, while, and for statements &#39;orelse&#39; is always the last clause.</span>
<span class="gi">+    # For try statements &#39;orelse&#39; is the last in the absence of a &#39;finalbody&#39;</span>
<span class="gi">+    if getattr(node, &quot;orelse&quot;, False):</span>
<span class="gi">+        return get_node_last_lineno(node.orelse[-1])</span>
<span class="gi">+    # try statements have the &#39;handlers&#39; last if there is no &#39;orelse&#39; or &#39;finalbody&#39;</span>
<span class="gi">+    if getattr(node, &quot;handlers&quot;, False):</span>
<span class="gi">+        return get_node_last_lineno(node.handlers[-1])</span>
<span class="gi">+    # All compound statements have a &#39;body&#39;</span>
<span class="gi">+    if getattr(node, &quot;body&quot;, False):</span>
<span class="gi">+        return get_node_last_lineno(node.body[-1])</span>
<span class="gi">+    # Not a compound statement</span>
<span class="gi">+    return node.lineno  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_postponed_evaluation_enabled(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the postponed evaluation of annotations is enabled.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module = node.root()</span>
<span class="gi">+    return &quot;annotations&quot; in module.future_imports</span>


<span class="gd">-def is_node_in_type_annotation_context(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_node_in_type_annotation_context(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if node is in type annotation context.

<span class="w"> </span>    Check for &#39;AnnAssign&#39;, function &#39;Arguments&#39;,
<span class="w"> </span>    or part of function return type annotation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -&gt;bool:</span>
<span class="gi">+    # pylint: disable=too-many-boolean-expressions</span>
<span class="gi">+    current_node, parent_node = node, node.parent</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(parent_node, nodes.AnnAssign)</span>
<span class="gi">+            and parent_node.annotation == current_node</span>
<span class="gi">+            or isinstance(parent_node, nodes.Arguments)</span>
<span class="gi">+            and current_node</span>
<span class="gi">+            in (</span>
<span class="gi">+                *parent_node.annotations,</span>
<span class="gi">+                *parent_node.posonlyargs_annotations,</span>
<span class="gi">+                *parent_node.kwonlyargs_annotations,</span>
<span class="gi">+                parent_node.varargannotation,</span>
<span class="gi">+                parent_node.kwargannotation,</span>
<span class="gi">+            )</span>
<span class="gi">+            or isinstance(parent_node, nodes.FunctionDef)</span>
<span class="gi">+            and parent_node.returns == current_node</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        current_node, parent_node = parent_node, parent_node.parent</span>
<span class="gi">+        if isinstance(parent_node, nodes.Module):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if first node is a subclass of second node.

<span class="w"> </span>    :param child: Node to check for subclass.
<span class="w"> </span>    :param parent: Node to check for superclass.
<span class="w"> </span>    :returns: True if child is derived from parent. False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not all(isinstance(node, nodes.ClassDef) for node in (child, parent)):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    for ancestor in child.ancestors():</span>
<span class="gi">+        try:</span>
<span class="gi">+            if astroid.helpers.is_subtype(ancestor, parent):</span>
<span class="gi">+                return True</span>
<span class="gi">+        except astroid.exceptions._NonDeducibleTypeHierarchy:</span>
<span class="gi">+            continue</span>
<span class="gi">+    return False</span>


<span class="w"> </span>@lru_cache(maxsize=1024)
<span class="gd">-def is_overload_stub(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_overload_stub(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a node is a function stub decorated with typing.overload.

<span class="w"> </span>    :param node: Node to check.
<span class="w"> </span>    :returns: True if node is an overload function stub. False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    decorators = getattr(node, &quot;decorators&quot;, None)</span>
<span class="gi">+    return bool(decorators and decorated_with(node, [&quot;typing.overload&quot;, &quot;overload&quot;]))</span>


<span class="gd">-def is_protocol_class(cls: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_protocol_class(cls: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given node represents a protocol class.

<span class="w"> </span>    :param cls: The node to check
<span class="w"> </span>    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(cls, nodes.ClassDef):</span>
<span class="gi">+        return False</span>

<span class="gi">+    # Return if klass is protocol</span>
<span class="gi">+    if cls.qname() in TYPING_PROTOCOLS:</span>
<span class="gi">+        return True</span>

<span class="gd">-def is_call_of_name(node: nodes.NodeNG, name: str) -&gt;bool:</span>
<span class="gi">+    for base in cls.bases:</span>
<span class="gi">+        try:</span>
<span class="gi">+            for inf_base in base.infer():</span>
<span class="gi">+                if inf_base.qname() in TYPING_PROTOCOLS:</span>
<span class="gi">+                    return True</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            continue</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_call_of_name(node: nodes.NodeNG, name: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if node is a function call with the given name.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(node, nodes.Call)</span>
<span class="gi">+        and isinstance(node.func, nodes.Name)</span>
<span class="gi">+        and node.func.name == name</span>
<span class="gi">+    )</span>


<span class="gd">-def is_test_condition(node: nodes.NodeNG, parent: (nodes.NodeNG | None)=None</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def is_test_condition(</span>
<span class="gi">+    node: nodes.NodeNG,</span>
<span class="gi">+    parent: nodes.NodeNG | None = None,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns true if the given node is being tested for truthiness.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parent = parent or node.parent</span>
<span class="gi">+    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):</span>
<span class="gi">+        return node is parent.test or parent.test.parent_of(node)</span>
<span class="gi">+    if isinstance(parent, nodes.Comprehension):</span>
<span class="gi">+        return node in parent.ifs</span>
<span class="gi">+    return is_call_of_name(parent, &quot;bool&quot;) and parent.parent_of(node)</span>


<span class="gd">-def is_classdef_type(node: nodes.ClassDef) -&gt;bool:</span>
<span class="gi">+def is_classdef_type(node: nodes.ClassDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Test if ClassDef node is Type.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node.name == &quot;type&quot;:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return any(isinstance(b, nodes.Name) and b.name == &quot;type&quot; for b in node.bases)</span>


<span class="gd">-def is_attribute_typed_annotation(node: (nodes.ClassDef | astroid.Instance),</span>
<span class="gd">-    attr_name: str) -&gt;bool:</span>
<span class="gi">+def is_attribute_typed_annotation(</span>
<span class="gi">+    node: nodes.ClassDef | astroid.Instance, attr_name: str</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Test if attribute is typed annotation in current node
<span class="w"> </span>    or any base nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+    attribute = node.locals.get(attr_name, [None])[0]</span>
<span class="gi">+    if (</span>
<span class="gi">+        attribute</span>
<span class="gi">+        and isinstance(attribute, nodes.AssignName)</span>
<span class="gi">+        and isinstance(attribute.parent, nodes.AnnAssign)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return True</span>
<span class="gi">+    for base in node.bases:</span>
<span class="gi">+        inferred = safe_infer(base)</span>
<span class="gi">+        if (</span>
<span class="gi">+            inferred</span>
<span class="gi">+            and isinstance(inferred, nodes.ClassDef)</span>
<span class="gi">+            and is_attribute_typed_annotation(inferred, attr_name)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_enum(node: nodes.ClassDef) -&gt; bool:</span>
<span class="gi">+    return node.name == &quot;Enum&quot; and node.root().name == &quot;enum&quot;  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Test if AssignName node has `typing_name` annotation.

<span class="w"> </span>    Especially useful to check for `typing._SpecialForm` instances
<span class="w"> </span>    like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_iterating_dictionary_name(node: (nodes.For | nodes.Comprehension)) -&gt;(</span>
<span class="gd">-    str | None):</span>
<span class="gi">+    if not isinstance(node.parent, nodes.AnnAssign):</span>
<span class="gi">+        return False</span>
<span class="gi">+    annotation = node.parent.annotation</span>
<span class="gi">+    if isinstance(annotation, nodes.Subscript):</span>
<span class="gi">+        annotation = annotation.value</span>
<span class="gi">+    if (</span>
<span class="gi">+        isinstance(annotation, nodes.Name)</span>
<span class="gi">+        and annotation.name == typing_name</span>
<span class="gi">+        or isinstance(annotation, nodes.Attribute)</span>
<span class="gi">+        and annotation.attrname == typing_name</span>
<span class="gi">+    ):</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_iterating_dictionary_name(node: nodes.For | nodes.Comprehension) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the name of the dictionary which keys are being iterated over on
<span class="w"> </span>    a ``nodes.For`` or ``nodes.Comprehension`` node.

<span class="w"> </span>    If the iterating object is not either the keys method of a dictionary
<span class="w"> </span>    or a dictionary itself, this returns None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Is it a proper keys call?</span>
<span class="gi">+    if (</span>
<span class="gi">+        isinstance(node.iter, nodes.Call)</span>
<span class="gi">+        and isinstance(node.iter.func, nodes.Attribute)</span>
<span class="gi">+        and node.iter.func.attrname == &quot;keys&quot;</span>
<span class="gi">+    ):</span>
<span class="gi">+        inferred = safe_infer(node.iter.func)</span>
<span class="gi">+        if not isinstance(inferred, astroid.BoundMethod):</span>
<span class="gi">+            return None</span>
<span class="gi">+        return node.iter.as_string().rpartition(&quot;.keys&quot;)[0]  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    # Is it a dictionary?</span>
<span class="gi">+    if isinstance(node.iter, (nodes.Name, nodes.Attribute)):</span>
<span class="gi">+        inferred = safe_infer(node.iter)</span>
<span class="gi">+        if not isinstance(inferred, nodes.Dict):</span>
<span class="gi">+            return None</span>
<span class="gi">+        return node.iter.as_string()  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>


<span class="gd">-def get_subscript_const_value(node: nodes.Subscript) -&gt;nodes.Const:</span>
<span class="gi">+def get_subscript_const_value(node: nodes.Subscript) -&gt; nodes.Const:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the value &#39;subscript.slice&#39; of a Subscript node.

<span class="w"> </span>    :param node: Subscript Node to extract value from
<span class="w"> </span>    :returns: Const Node containing subscript value
<span class="w"> </span>    :raises InferredTypeError: if the subscript node cannot be inferred as a Const
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    inferred = safe_infer(node.slice)</span>
<span class="gi">+    if not isinstance(inferred, nodes.Const):</span>
<span class="gi">+        raise InferredTypeError(&quot;Subscript.slice cannot be inferred as a nodes.Const&quot;)</span>

<span class="gi">+    return inferred</span>

<span class="gd">-def get_import_name(importnode: ImportNode, modname: (str | None)) -&gt;(str |</span>
<span class="gd">-    None):</span>
<span class="gi">+</span>
<span class="gi">+def get_import_name(importnode: ImportNode, modname: str | None) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get a prepared module name from the given import node.

<span class="w"> </span>    In the case of relative imports, this will return the
<span class="gu">@@ -622,10 +1827,19 @@ def get_import_name(importnode: ImportNode, modname: (str | None)) -&gt;(str |</span>
<span class="w"> </span>    :returns: absolute qualified module name of the module
<span class="w"> </span>        used in import.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_sys_guard(node: nodes.If) -&gt;bool:</span>
<span class="gi">+    if isinstance(importnode, nodes.ImportFrom) and importnode.level:</span>
<span class="gi">+        root = importnode.root()</span>
<span class="gi">+        if isinstance(root, nodes.Module):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return root.relative_to_absolute_name(  # type: ignore[no-any-return]</span>
<span class="gi">+                    modname, level=importnode.level</span>
<span class="gi">+                )</span>
<span class="gi">+            except TooManyLevelsError:</span>
<span class="gi">+                return modname</span>
<span class="gi">+    return modname</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_sys_guard(node: nodes.If) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if IF stmt is a sys.version_info guard.

<span class="w"> </span>    &gt;&gt;&gt; import sys
<span class="gu">@@ -634,110 +1848,303 @@ def is_sys_guard(node: nodes.If) -&gt;bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; else:
<span class="w"> </span>    &gt;&gt;&gt;     from typing_extensions import Literal
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_reassigned_after_current(node: nodes.NodeNG, varname: str) -&gt;bool:</span>
<span class="gi">+    if isinstance(node.test, nodes.Compare):</span>
<span class="gi">+        value = node.test.left</span>
<span class="gi">+        if isinstance(value, nodes.Subscript):</span>
<span class="gi">+            value = value.value</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(value, nodes.Attribute)</span>
<span class="gi">+            and value.as_string() == &quot;sys.version_info&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+    elif isinstance(node.test, nodes.Attribute) and node.test.as_string() in {</span>
<span class="gi">+        &quot;six.PY2&quot;,</span>
<span class="gi">+        &quot;six.PY3&quot;,</span>
<span class="gi">+    }:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_reassigned_after_current(node: nodes.NodeNG, varname: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given variable name is reassigned in the same scope after the
<span class="w"> </span>    current node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(</span>
<span class="gi">+        a.name == varname and a.lineno &gt; node.lineno</span>
<span class="gi">+        for a in node.scope().nodes_of_class(</span>
<span class="gi">+            (nodes.AssignName, nodes.ClassDef, nodes.FunctionDef)</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>


<span class="gd">-def is_deleted_after_current(node: nodes.NodeNG, varname: str) -&gt;bool:</span>
<span class="gi">+def is_deleted_after_current(node: nodes.NodeNG, varname: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the given variable name is deleted in the same scope after the current
<span class="w"> </span>    node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(</span>
<span class="gi">+        getattr(target, &quot;name&quot;, None) == varname and target.lineno &gt; node.lineno</span>
<span class="gi">+        for del_node in node.scope().nodes_of_class(nodes.Delete)</span>
<span class="gi">+        for target in del_node.targets</span>
<span class="gi">+    )</span>


<span class="gd">-def is_function_body_ellipsis(node: nodes.FunctionDef) -&gt;bool:</span>
<span class="gi">+def is_function_body_ellipsis(node: nodes.FunctionDef) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks whether a function body only consists of a single Ellipsis.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        len(node.body) == 1</span>
<span class="gi">+        and isinstance(node.body[0], nodes.Expr)</span>
<span class="gi">+        and isinstance(node.body[0].value, nodes.Const)</span>
<span class="gi">+        and node.body[0].value.value == Ellipsis</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_base_container(node: nodes.NodeNG | None) -&gt; bool:</span>
<span class="gi">+    return isinstance(node, nodes.BaseContainer) and not node.elts</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_empty_dict_literal(node: nodes.NodeNG | None) -&gt; bool:</span>
<span class="gi">+    return isinstance(node, nodes.Dict) and not node.items</span>
<span class="gi">+</span>

<span class="gi">+def is_empty_str_literal(node: nodes.NodeNG | None) -&gt; bool:</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(node, nodes.Const) and isinstance(node.value, str) and not node.value</span>
<span class="gi">+    )</span>

<span class="gd">-def returns_bool(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def returns_bool(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns true if a node is a nodes.Return that returns a constant boolean.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(node, nodes.Return)</span>
<span class="gi">+        and isinstance(node.value, nodes.Const)</span>
<span class="gi">+        and isinstance(node.value.value, bool)</span>
<span class="gi">+    )</span>


<span class="gd">-def assigned_bool(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def assigned_bool(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns true if a node is a nodes.Assign that returns a constant boolean.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(node, nodes.Assign)</span>
<span class="gi">+        and isinstance(node.value, nodes.Const)</span>
<span class="gi">+        and isinstance(node.value.value, bool)</span>
<span class="gi">+    )</span>


<span class="gd">-def get_node_first_ancestor_of_type(node: nodes.NodeNG, ancestor_type: (</span>
<span class="gd">-    type[_NodeT] | tuple[type[_NodeT], ...])) -&gt;(_NodeT | None):</span>
<span class="gi">+def get_node_first_ancestor_of_type(</span>
<span class="gi">+    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]</span>
<span class="gi">+) -&gt; _NodeT | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the first parent node that is any of the provided types (or None).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for ancestor in node.node_ancestors():</span>
<span class="gi">+        if isinstance(ancestor, ancestor_type):</span>
<span class="gi">+            return ancestor  # type: ignore[no-any-return]</span>
<span class="gi">+    return None</span>


<span class="gd">-def get_node_first_ancestor_of_type_and_its_child(node: nodes.NodeNG,</span>
<span class="gd">-    ancestor_type: (type[_NodeT] | tuple[type[_NodeT], ...])) -&gt;(tuple[None,</span>
<span class="gd">-    None] | tuple[_NodeT, nodes.NodeNG]):</span>
<span class="gi">+def get_node_first_ancestor_of_type_and_its_child(</span>
<span class="gi">+    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]</span>
<span class="gi">+) -&gt; tuple[None, None] | tuple[_NodeT, nodes.NodeNG]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Modified version of get_node_first_ancestor_of_type to also return the
<span class="w"> </span>    descendant visited directly before reaching the sought ancestor.

<span class="w"> </span>    Useful for extracting whether a statement is guarded by a try, except, or finally
<span class="w"> </span>    when searching for a Try ancestor.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    child = node</span>
<span class="gi">+    for ancestor in node.node_ancestors():</span>
<span class="gi">+        if isinstance(ancestor, ancestor_type):</span>
<span class="gi">+            return (ancestor, child)</span>
<span class="gi">+        child = ancestor</span>
<span class="gi">+    return None, None</span>


<span class="gd">-def in_type_checking_block(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def in_type_checking_block(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a node is guarded by a TYPE_CHECKING guard.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_typing_member(node: nodes.NodeNG, names_to_check: tuple[str, ...]</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+    for ancestor in node.node_ancestors():</span>
<span class="gi">+        if not isinstance(ancestor, nodes.If):</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(ancestor.test, nodes.Name):</span>
<span class="gi">+            if ancestor.test.name != &quot;TYPE_CHECKING&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            lookup_result = ancestor.test.lookup(ancestor.test.name)[1]</span>
<span class="gi">+            if not lookup_result:</span>
<span class="gi">+                return False</span>
<span class="gi">+            maybe_import_from = lookup_result[0]</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(maybe_import_from, nodes.ImportFrom)</span>
<span class="gi">+                and maybe_import_from.modname == &quot;typing&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+            inferred = safe_infer(ancestor.test)</span>
<span class="gi">+            if isinstance(inferred, nodes.Const) and inferred.value is False:</span>
<span class="gi">+                return True</span>
<span class="gi">+        elif isinstance(ancestor.test, nodes.Attribute):</span>
<span class="gi">+            if ancestor.test.attrname != &quot;TYPE_CHECKING&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            inferred_module = safe_infer(ancestor.test.expr)</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(inferred_module, nodes.Module)</span>
<span class="gi">+                and inferred_module.name == &quot;typing&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_typing_member(node: nodes.NodeNG, names_to_check: tuple[str, ...]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if `node` is a member of the `typing` module and has one of the names from
<span class="w"> </span>    `names_to_check`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, nodes.Name):</span>
<span class="gi">+        try:</span>
<span class="gi">+            import_from = node.lookup(node.name)[1][0]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(import_from, nodes.ImportFrom):</span>
<span class="gi">+            return (</span>
<span class="gi">+                import_from.modname == &quot;typing&quot;</span>
<span class="gi">+                and import_from.real_name(node.name) in names_to_check</span>
<span class="gi">+            )</span>
<span class="gi">+    elif isinstance(node, nodes.Attribute):</span>
<span class="gi">+        inferred_module = safe_infer(node.expr)</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(inferred_module, nodes.Module)</span>
<span class="gi">+            and inferred_module.name == &quot;typing&quot;</span>
<span class="gi">+            and node.attrname in names_to_check</span>
<span class="gi">+        )</span>
<span class="gi">+    return False</span>


<span class="w"> </span>@lru_cache
<span class="gd">-def in_for_else_branch(parent: nodes.NodeNG, stmt: Statement) -&gt;bool:</span>
<span class="gi">+def in_for_else_branch(parent: nodes.NodeNG, stmt: Statement) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns True if stmt is inside the else branch for a parent For stmt.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(parent, nodes.For) and any(</span>
<span class="gi">+        else_stmt.parent_of(stmt) or else_stmt == stmt for else_stmt in parent.orelse</span>
<span class="gi">+    )</span>


<span class="gd">-def find_assigned_names_recursive(target: (nodes.AssignName | nodes.</span>
<span class="gd">-    BaseContainer)) -&gt;Iterator[str]:</span>
<span class="gi">+def find_assigned_names_recursive(</span>
<span class="gi">+    target: nodes.AssignName | nodes.BaseContainer,</span>
<span class="gi">+) -&gt; Iterator[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Yield the names of assignment targets, accounting for nested ones.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(target, nodes.AssignName):</span>
<span class="gi">+        if target.name is not None:</span>
<span class="gi">+            yield target.name</span>
<span class="gi">+    elif isinstance(target, nodes.BaseContainer):</span>
<span class="gi">+        for elt in target.elts:</span>
<span class="gi">+            yield from find_assigned_names_recursive(elt)</span>


<span class="gd">-def has_starred_node_recursive(node: (nodes.For | nodes.Comprehension |</span>
<span class="gd">-    nodes.Set)) -&gt;Iterator[bool]:</span>
<span class="gi">+def has_starred_node_recursive(</span>
<span class="gi">+    node: nodes.For | nodes.Comprehension | nodes.Set,</span>
<span class="gi">+) -&gt; Iterator[bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Yield ``True`` if a Starred node is found recursively.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, nodes.Starred):</span>
<span class="gi">+        yield True</span>
<span class="gi">+    elif isinstance(node, nodes.Set):</span>
<span class="gi">+        for elt in node.elts:</span>
<span class="gi">+            yield from has_starred_node_recursive(elt)</span>
<span class="gi">+    elif isinstance(node, (nodes.For, nodes.Comprehension)):</span>
<span class="gi">+        for elt in node.iter.elts:</span>
<span class="gi">+            yield from has_starred_node_recursive(elt)</span>


<span class="gd">-def is_hashable(node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+def is_hashable(node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return whether any inferred value of `node` is hashable.

<span class="w"> </span>    When finding ambiguity, return True.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _is_target_name_in_binop_side(target: (nodes.AssignName | nodes.</span>
<span class="gd">-    AssignAttr), side: (nodes.NodeNG | None)) -&gt;bool:</span>
<span class="gi">+    # pylint: disable = too-many-try-statements</span>
<span class="gi">+    try:</span>
<span class="gi">+        for inferred in node.infer():</span>
<span class="gi">+            if isinstance(inferred, (nodes.ClassDef, util.UninferableBase)):</span>
<span class="gi">+                return True</span>
<span class="gi">+            if not hasattr(inferred, &quot;igetattr&quot;):</span>
<span class="gi">+                return True</span>
<span class="gi">+            hash_fn = next(inferred.igetattr(&quot;__hash__&quot;))</span>
<span class="gi">+            if hash_fn.parent is inferred:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if getattr(hash_fn, &quot;value&quot;, True) is not None:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def subscript_chain_is_equal(left: nodes.Subscript, right: nodes.Subscript) -&gt; bool:</span>
<span class="gi">+    while isinstance(left, nodes.Subscript) and isinstance(right, nodes.Subscript):</span>
<span class="gi">+        try:</span>
<span class="gi">+            if (</span>
<span class="gi">+                get_subscript_const_value(left).value</span>
<span class="gi">+                != get_subscript_const_value(right).value</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            left = left.value</span>
<span class="gi">+            right = right.value</span>
<span class="gi">+        except InferredTypeError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    return left.as_string() == right.as_string()  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_target_name_in_binop_side(</span>
<span class="gi">+    target: nodes.AssignName | nodes.AssignAttr, side: nodes.NodeNG | None</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine whether the target name-like node is referenced in the side node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(side, nodes.Name):</span>
<span class="gi">+        if isinstance(target, nodes.AssignName):</span>
<span class="gi">+            return target.name == side.name  # type: ignore[no-any-return]</span>
<span class="gi">+        return False</span>
<span class="gi">+    if isinstance(side, nodes.Attribute) and isinstance(target, nodes.AssignAttr):</span>
<span class="gi">+        return target.as_string() == side.as_string()  # type: ignore[no-any-return]</span>
<span class="gi">+    if isinstance(side, nodes.Subscript) and isinstance(target, nodes.Subscript):</span>
<span class="gi">+        return subscript_chain_is_equal(target, side)</span>

<span class="gi">+    return False</span>

<span class="gd">-def is_augmented_assign(node: nodes.Assign) -&gt;tuple[bool, str]:</span>
<span class="gi">+</span>
<span class="gi">+def is_augmented_assign(node: nodes.Assign) -&gt; tuple[bool, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine if the node is assigning itself (with modifications) to itself.

<span class="w"> </span>    For example: x = 1 + x
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _qualified_name_parts(qualified_module_name: str) -&gt;list[str]:</span>
<span class="gi">+    if not isinstance(node.value, nodes.BinOp):</span>
<span class="gi">+        return False, &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    binop = node.value</span>
<span class="gi">+    target = node.targets[0]</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(target, (nodes.AssignName, nodes.AssignAttr, nodes.Subscript)):</span>
<span class="gi">+        return False, &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # We don&#39;t want to catch x = &quot;1&quot; + x or x = &quot;%s&quot; % x</span>
<span class="gi">+    if isinstance(binop.left, nodes.Const) and isinstance(</span>
<span class="gi">+        binop.left.value, (str, bytes)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False, &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # This could probably be improved but for now we disregard all assignments from calls</span>
<span class="gi">+    if isinstance(binop.left, nodes.Call) or isinstance(binop.right, nodes.Call):</span>
<span class="gi">+        return False, &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if _is_target_name_in_binop_side(target, binop.left):</span>
<span class="gi">+        return True, binop.op</span>
<span class="gi">+    if (</span>
<span class="gi">+        # Unless an operator is commutative, we should not raise (i.e. x = 3/x)</span>
<span class="gi">+        binop.op in COMMUTATIVE_OPERATORS</span>
<span class="gi">+        and _is_target_name_in_binop_side(target, binop.right)</span>
<span class="gi">+    ):</span>
<span class="gi">+        inferred_left = safe_infer(binop.left)</span>
<span class="gi">+        if isinstance(inferred_left, nodes.Const) and isinstance(</span>
<span class="gi">+            inferred_left.value, int</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True, binop.op</span>
<span class="gi">+        return False, &quot;&quot;</span>
<span class="gi">+    return False, &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _qualified_name_parts(qualified_module_name: str) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Split the names of the given module into subparts.

<span class="w"> </span>    For example,
<span class="gu">@@ -745,17 +2152,85 @@ def _qualified_name_parts(qualified_module_name: str) -&gt;list[str]:</span>
<span class="w"> </span>    returns
<span class="w"> </span>        [&#39;pylint&#39;, &#39;pylint.checkers&#39;, &#39;pylint.checkers.ImportsChecker&#39;]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    names = qualified_module_name.split(&quot;.&quot;)</span>
<span class="gi">+    return [&quot;.&quot;.join(names[0 : i + 1]) for i in range(len(names))]</span>


<span class="gd">-def is_terminating_func(node: nodes.Call) -&gt;bool:</span>
<span class="gi">+def is_module_ignored(</span>
<span class="gi">+    qualified_module_name: str, ignored_modules: Iterable[str]</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    ignored_modules = set(ignored_modules)</span>
<span class="gi">+    for current_module in _qualified_name_parts(qualified_module_name):</span>
<span class="gi">+        # Try to match the module name directly</span>
<span class="gi">+        if current_module in ignored_modules:</span>
<span class="gi">+            return True</span>
<span class="gi">+        for ignore in ignored_modules:</span>
<span class="gi">+            # Try to see if the ignores pattern match against the module name.</span>
<span class="gi">+            if fnmatch.fnmatch(current_module, ignore):</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_singleton_const(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return isinstance(node, nodes.Const) and any(</span>
<span class="gi">+        node.value is value for value in SINGLETON_VALUES</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_terminating_func(node: nodes.Call) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Detect call to exit(), quit(), os._exit(), sys.exit(), or
<span class="w"> </span>    functions annotated with `typing.NoReturn` or `typing.Never`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_inverse_comparator(op: str) -&gt;str:</span>
<span class="gi">+    if (</span>
<span class="gi">+        not isinstance(node.func, nodes.Attribute)</span>
<span class="gi">+        and not (isinstance(node.func, nodes.Name))</span>
<span class="gi">+        or isinstance(node.parent, nodes.Lambda)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        for inferred in node.func.infer():</span>
<span class="gi">+            if (</span>
<span class="gi">+                hasattr(inferred, &quot;qname&quot;)</span>
<span class="gi">+                and inferred.qname() in TERMINATING_FUNCS_QNAMES</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+            # Unwrap to get the actual function node object</span>
<span class="gi">+            if isinstance(inferred, astroid.BoundMethod) and isinstance(</span>
<span class="gi">+                inferred._proxied, astroid.UnboundMethod</span>
<span class="gi">+            ):</span>
<span class="gi">+                inferred = inferred._proxied._proxied</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(inferred, nodes.FunctionDef)</span>
<span class="gi">+                and isinstance(inferred.returns, nodes.Name)</span>
<span class="gi">+                and (inferred_func := safe_infer(inferred.returns))</span>
<span class="gi">+                and hasattr(inferred_func, &quot;qname&quot;)</span>
<span class="gi">+                and inferred_func.qname()</span>
<span class="gi">+                in (</span>
<span class="gi">+                    *TYPING_NEVER,</span>
<span class="gi">+                    *TYPING_NORETURN,</span>
<span class="gi">+                    # In Python 3.7 - 3.8, NoReturn is alias of &#39;_SpecialForm&#39;</span>
<span class="gi">+                    # &quot;typing._SpecialForm&quot;,</span>
<span class="gi">+                    # But &#39;typing.Any&#39; also inherits _SpecialForm</span>
<span class="gi">+                    # See #9751</span>
<span class="gi">+                )</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+    except (StopIteration, astroid.InferenceError):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_class_attr(name: str, klass: nodes.ClassDef) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        klass.getattr(name)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except astroid.NotFoundError:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_inverse_comparator(op: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns the inverse comparator given a comparator.

<span class="w"> </span>    E.g. when given &quot;==&quot;, returns &quot;!=&quot;
<span class="gu">@@ -765,23 +2240,101 @@ def get_inverse_comparator(op: str) -&gt;str:</span>
<span class="w"> </span>    :returns: The inverse of the comparator in string format
<span class="w"> </span>    :raises KeyError: if input is not recognized as a comparator
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return {</span>
<span class="gi">+        &quot;==&quot;: &quot;!=&quot;,</span>
<span class="gi">+        &quot;!=&quot;: &quot;==&quot;,</span>
<span class="gi">+        &quot;&lt;&quot;: &quot;&gt;=&quot;,</span>
<span class="gi">+        &quot;&gt;&quot;: &quot;&lt;=&quot;,</span>
<span class="gi">+        &quot;&lt;=&quot;: &quot;&gt;&quot;,</span>
<span class="gi">+        &quot;&gt;=&quot;: &quot;&lt;&quot;,</span>
<span class="gi">+        &quot;in&quot;: &quot;not in&quot;,</span>
<span class="gi">+        &quot;not in&quot;: &quot;in&quot;,</span>
<span class="gi">+        &quot;is&quot;: &quot;is not&quot;,</span>
<span class="gi">+        &quot;is not&quot;: &quot;is&quot;,</span>
<span class="gi">+    }[op]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def not_condition_as_string(</span>
<span class="gi">+    test_node: nodes.Compare | nodes.Name | nodes.UnaryOp | nodes.BoolOp | nodes.BinOp,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    msg = f&quot;not {test_node.as_string()}&quot;</span>
<span class="gi">+    if isinstance(test_node, nodes.UnaryOp):</span>
<span class="gi">+        msg = test_node.operand.as_string()</span>
<span class="gi">+    elif isinstance(test_node, nodes.BoolOp):</span>
<span class="gi">+        msg = f&quot;not ({test_node.as_string()})&quot;</span>
<span class="gi">+    elif isinstance(test_node, nodes.Compare):</span>
<span class="gi">+        lhs = test_node.left</span>
<span class="gi">+        ops, rhs = test_node.ops[0]</span>
<span class="gi">+        lower_priority_expressions = (</span>
<span class="gi">+            nodes.Lambda,</span>
<span class="gi">+            nodes.UnaryOp,</span>
<span class="gi">+            nodes.BoolOp,</span>
<span class="gi">+            nodes.IfExp,</span>
<span class="gi">+            nodes.NamedExpr,</span>
<span class="gi">+        )</span>
<span class="gi">+        lhs = (</span>
<span class="gi">+            f&quot;({lhs.as_string()})&quot;</span>
<span class="gi">+            if isinstance(lhs, lower_priority_expressions)</span>
<span class="gi">+            else lhs.as_string()</span>
<span class="gi">+        )</span>
<span class="gi">+        rhs = (</span>
<span class="gi">+            f&quot;({rhs.as_string()})&quot;</span>
<span class="gi">+            if isinstance(rhs, lower_priority_expressions)</span>
<span class="gi">+            else rhs.as_string()</span>
<span class="gi">+        )</span>
<span class="gi">+        msg = f&quot;{lhs} {get_inverse_comparator(ops)} {rhs}&quot;</span>
<span class="gi">+    return msg</span>


<span class="w"> </span>@lru_cache(maxsize=1000)
<span class="gd">-def overridden_method(klass: nodes.LocalsDictNodeNG, name: (str | None)) -&gt;(</span>
<span class="gd">-    nodes.FunctionDef | None):</span>
<span class="gi">+def overridden_method(</span>
<span class="gi">+    klass: nodes.LocalsDictNodeNG, name: str | None</span>
<span class="gi">+) -&gt; nodes.FunctionDef | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get overridden method if any.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def clear_lru_caches() -&gt;None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        parent = next(klass.local_attr_ancestors(name))</span>
<span class="gi">+    except (StopIteration, KeyError):</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        meth_node = parent[name]</span>
<span class="gi">+    except KeyError:  # pragma: no cover</span>
<span class="gi">+        # We have found an ancestor defining &lt;name&gt; but it&#39;s not in the local</span>
<span class="gi">+        # dictionary. This may happen with astroid built from living objects.</span>
<span class="gi">+        return None</span>
<span class="gi">+    if isinstance(meth_node, nodes.FunctionDef):</span>
<span class="gi">+        return meth_node</span>
<span class="gi">+    return None  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def clear_lru_caches() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Clear caches holding references to AST nodes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_enum_member(node: nodes.AssignName) -&gt;bool:</span>
<span class="gi">+    caches_holding_node_references: list[_lru_cache_wrapper[Any]] = [</span>
<span class="gi">+        class_is_abstract,</span>
<span class="gi">+        in_for_else_branch,</span>
<span class="gi">+        infer_all,</span>
<span class="gi">+        is_overload_stub,</span>
<span class="gi">+        overridden_method,</span>
<span class="gi">+        unimplemented_abstract_methods,</span>
<span class="gi">+        safe_infer,</span>
<span class="gi">+    ]</span>
<span class="gi">+    for lru in caches_holding_node_references:</span>
<span class="gi">+        lru.cache_clear()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_enum_member(node: nodes.AssignName) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return `True` if `node` is an Enum member (is an item of the
<span class="w"> </span>    `__members__` container).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    frame = node.frame()</span>
<span class="gi">+    if (</span>
<span class="gi">+        not isinstance(frame, nodes.ClassDef)</span>
<span class="gi">+        or not frame.is_subtype_of(&quot;enum.Enum&quot;)</span>
<span class="gi">+        or frame.root().qname() == &quot;enum&quot;</span>
<span class="gi">+    ):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    members = frame.locals.get(&quot;__members__&quot;)</span>
<span class="gi">+    # A dataclass is one known case for when `members` can be `None`</span>
<span class="gi">+    if members is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return node.name in [name_obj.name for value, name_obj in members[0].items]</span>
<span class="gh">diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py</span>
<span class="gh">index 822aebe55..495051f31 100644</span>
<span class="gd">--- a/pylint/checkers/variables.py</span>
<span class="gi">+++ b/pylint/checkers/variables.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Variables checkers for Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import copy
<span class="w"> </span>import itertools
<span class="gu">@@ -11,39 +17,112 @@ from collections.abc import Generator, Iterable, Iterator</span>
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from functools import cached_property
<span class="w"> </span>from typing import TYPE_CHECKING, Any, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>import astroid.exceptions
<span class="w"> </span>from astroid import bases, extract_node, nodes, util
<span class="w"> </span>from astroid.nodes import _base_nodes
<span class="w"> </span>from astroid.typing import InferenceResult
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="gd">-from pylint.checkers.utils import in_type_checking_block, is_module_ignored, is_postponed_evaluation_enabled, is_sys_guard, overridden_method</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    in_type_checking_block,</span>
<span class="gi">+    is_module_ignored,</span>
<span class="gi">+    is_postponed_evaluation_enabled,</span>
<span class="gi">+    is_sys_guard,</span>
<span class="gi">+    overridden_method,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.constants import PY39_PLUS, TYPING_NEVER, TYPING_NORETURN
<span class="w"> </span>from pylint.interfaces import CONTROL_FLOW, HIGH, INFERENCE, INFERENCE_FAILURE
<span class="w"> </span>from pylint.typing import MessageDefinitionTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-SPECIAL_OBJ = re.compile(&#39;^_{2}[a-z]+_{2}$&#39;)</span>
<span class="gd">-FUTURE = &#39;__future__&#39;</span>
<span class="gd">-IGNORED_ARGUMENT_NAMES = re.compile(&#39;_.*|^ignored_|^unused_&#39;)</span>
<span class="gd">-METACLASS_NAME_TRANSFORMS = {&#39;_py_abc&#39;: &#39;abc&#39;}</span>
<span class="gd">-BUILTIN_RANGE = &#39;builtins.range&#39;</span>
<span class="gd">-TYPING_MODULE = &#39;typing&#39;</span>
<span class="gd">-TYPING_NAMES = frozenset({&#39;Any&#39;, &#39;Callable&#39;, &#39;ClassVar&#39;, &#39;Generic&#39;,</span>
<span class="gd">-    &#39;Optional&#39;, &#39;Tuple&#39;, &#39;Type&#39;, &#39;TypeVar&#39;, &#39;Union&#39;, &#39;AbstractSet&#39;,</span>
<span class="gd">-    &#39;ByteString&#39;, &#39;Container&#39;, &#39;ContextManager&#39;, &#39;Hashable&#39;, &#39;ItemsView&#39;,</span>
<span class="gd">-    &#39;Iterable&#39;, &#39;Iterator&#39;, &#39;KeysView&#39;, &#39;Mapping&#39;, &#39;MappingView&#39;,</span>
<span class="gd">-    &#39;MutableMapping&#39;, &#39;MutableSequence&#39;, &#39;MutableSet&#39;, &#39;Sequence&#39;, &#39;Sized&#39;,</span>
<span class="gd">-    &#39;ValuesView&#39;, &#39;Awaitable&#39;, &#39;AsyncIterator&#39;, &#39;AsyncIterable&#39;,</span>
<span class="gd">-    &#39;Coroutine&#39;, &#39;Collection&#39;, &#39;AsyncGenerator&#39;, &#39;AsyncContextManager&#39;,</span>
<span class="gd">-    &#39;Reversible&#39;, &#39;SupportsAbs&#39;, &#39;SupportsBytes&#39;, &#39;SupportsComplex&#39;,</span>
<span class="gd">-    &#39;SupportsFloat&#39;, &#39;SupportsInt&#39;, &#39;SupportsRound&#39;, &#39;Counter&#39;, &#39;Deque&#39;,</span>
<span class="gd">-    &#39;Dict&#39;, &#39;DefaultDict&#39;, &#39;List&#39;, &#39;Set&#39;, &#39;FrozenSet&#39;, &#39;NamedTuple&#39;,</span>
<span class="gd">-    &#39;Generator&#39;, &#39;AnyStr&#39;, &#39;Text&#39;, &#39;Pattern&#39;, &#39;BinaryIO&#39;})</span>
<span class="gd">-DICT_TYPES = (astroid.objects.DictValues, astroid.objects.DictKeys, astroid</span>
<span class="gd">-    .objects.DictItems, astroid.nodes.node_classes.Dict)</span>
<span class="gd">-NODES_WITH_VALUE_ATTR = (nodes.Assign, nodes.AnnAssign, nodes.AugAssign,</span>
<span class="gd">-    nodes.Expr, nodes.Return, nodes.Match, nodes.TypeAlias)</span>
<span class="gi">+</span>
<span class="gi">+SPECIAL_OBJ = re.compile(&quot;^_{2}[a-z]+_{2}$&quot;)</span>
<span class="gi">+FUTURE = &quot;__future__&quot;</span>
<span class="gi">+# regexp for ignored argument name</span>
<span class="gi">+IGNORED_ARGUMENT_NAMES = re.compile(&quot;_.*|^ignored_|^unused_&quot;)</span>
<span class="gi">+# In Python 3.7 abc has a Python implementation which is preferred</span>
<span class="gi">+# by astroid. Unfortunately this also messes up our explicit checks</span>
<span class="gi">+# for `abc`</span>
<span class="gi">+METACLASS_NAME_TRANSFORMS = {&quot;_py_abc&quot;: &quot;abc&quot;}</span>
<span class="gi">+BUILTIN_RANGE = &quot;builtins.range&quot;</span>
<span class="gi">+TYPING_MODULE = &quot;typing&quot;</span>
<span class="gi">+TYPING_NAMES = frozenset(</span>
<span class="gi">+    {</span>
<span class="gi">+        &quot;Any&quot;,</span>
<span class="gi">+        &quot;Callable&quot;,</span>
<span class="gi">+        &quot;ClassVar&quot;,</span>
<span class="gi">+        &quot;Generic&quot;,</span>
<span class="gi">+        &quot;Optional&quot;,</span>
<span class="gi">+        &quot;Tuple&quot;,</span>
<span class="gi">+        &quot;Type&quot;,</span>
<span class="gi">+        &quot;TypeVar&quot;,</span>
<span class="gi">+        &quot;Union&quot;,</span>
<span class="gi">+        &quot;AbstractSet&quot;,</span>
<span class="gi">+        &quot;ByteString&quot;,</span>
<span class="gi">+        &quot;Container&quot;,</span>
<span class="gi">+        &quot;ContextManager&quot;,</span>
<span class="gi">+        &quot;Hashable&quot;,</span>
<span class="gi">+        &quot;ItemsView&quot;,</span>
<span class="gi">+        &quot;Iterable&quot;,</span>
<span class="gi">+        &quot;Iterator&quot;,</span>
<span class="gi">+        &quot;KeysView&quot;,</span>
<span class="gi">+        &quot;Mapping&quot;,</span>
<span class="gi">+        &quot;MappingView&quot;,</span>
<span class="gi">+        &quot;MutableMapping&quot;,</span>
<span class="gi">+        &quot;MutableSequence&quot;,</span>
<span class="gi">+        &quot;MutableSet&quot;,</span>
<span class="gi">+        &quot;Sequence&quot;,</span>
<span class="gi">+        &quot;Sized&quot;,</span>
<span class="gi">+        &quot;ValuesView&quot;,</span>
<span class="gi">+        &quot;Awaitable&quot;,</span>
<span class="gi">+        &quot;AsyncIterator&quot;,</span>
<span class="gi">+        &quot;AsyncIterable&quot;,</span>
<span class="gi">+        &quot;Coroutine&quot;,</span>
<span class="gi">+        &quot;Collection&quot;,</span>
<span class="gi">+        &quot;AsyncGenerator&quot;,</span>
<span class="gi">+        &quot;AsyncContextManager&quot;,</span>
<span class="gi">+        &quot;Reversible&quot;,</span>
<span class="gi">+        &quot;SupportsAbs&quot;,</span>
<span class="gi">+        &quot;SupportsBytes&quot;,</span>
<span class="gi">+        &quot;SupportsComplex&quot;,</span>
<span class="gi">+        &quot;SupportsFloat&quot;,</span>
<span class="gi">+        &quot;SupportsInt&quot;,</span>
<span class="gi">+        &quot;SupportsRound&quot;,</span>
<span class="gi">+        &quot;Counter&quot;,</span>
<span class="gi">+        &quot;Deque&quot;,</span>
<span class="gi">+        &quot;Dict&quot;,</span>
<span class="gi">+        &quot;DefaultDict&quot;,</span>
<span class="gi">+        &quot;List&quot;,</span>
<span class="gi">+        &quot;Set&quot;,</span>
<span class="gi">+        &quot;FrozenSet&quot;,</span>
<span class="gi">+        &quot;NamedTuple&quot;,</span>
<span class="gi">+        &quot;Generator&quot;,</span>
<span class="gi">+        &quot;AnyStr&quot;,</span>
<span class="gi">+        &quot;Text&quot;,</span>
<span class="gi">+        &quot;Pattern&quot;,</span>
<span class="gi">+        &quot;BinaryIO&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+DICT_TYPES = (</span>
<span class="gi">+    astroid.objects.DictValues,</span>
<span class="gi">+    astroid.objects.DictKeys,</span>
<span class="gi">+    astroid.objects.DictItems,</span>
<span class="gi">+    astroid.nodes.node_classes.Dict,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+NODES_WITH_VALUE_ATTR = (</span>
<span class="gi">+    nodes.Assign,</span>
<span class="gi">+    nodes.AnnAssign,</span>
<span class="gi">+    nodes.AugAssign,</span>
<span class="gi">+    nodes.Expr,</span>
<span class="gi">+    nodes.Return,</span>
<span class="gi">+    nodes.Match,</span>
<span class="gi">+    nodes.TypeAlias,</span>
<span class="gi">+)</span>


<span class="w"> </span>class VariableVisitConsumerAction(Enum):
<span class="gu">@@ -53,25 +132,50 @@ class VariableVisitConsumerAction(Enum):</span>
<span class="w"> </span>    Continue -&gt; continue loop to next consumer
<span class="w"> </span>    Return -&gt; return and thereby break the loop
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    CONTINUE = 0
<span class="w"> </span>    RETURN = 1


<span class="gd">-def _is_from_future_import(stmt: nodes.ImportFrom, name: str) -&gt;(bool | None):</span>
<span class="gi">+def _is_from_future_import(stmt: nodes.ImportFrom, name: str) -&gt; bool | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the name is a future import from another module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = stmt.do_import_module(stmt.modname)</span>
<span class="gi">+    except astroid.AstroidBuildingError:</span>
<span class="gi">+        return None</span>

<span class="gi">+    for local_node in module.locals.get(name, []):</span>
<span class="gi">+        if isinstance(local_node, nodes.ImportFrom) and local_node.modname == FUTURE:</span>
<span class="gi">+            return True</span>
<span class="gi">+    return None</span>

<span class="gd">-def _get_unpacking_extra_info(node: nodes.Assign, inferred: InferenceResult</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def _get_unpacking_extra_info(node: nodes.Assign, inferred: InferenceResult) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return extra information to add to the message for unpacking-non-sequence
<span class="w"> </span>    and unbalanced-tuple/dict-unpacking errors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _detect_global_scope(node: nodes.Name, frame: nodes.LocalsDictNodeNG,</span>
<span class="gd">-    defframe: nodes.LocalsDictNodeNG) -&gt;bool:</span>
<span class="gi">+    more = &quot;&quot;</span>
<span class="gi">+    if isinstance(inferred, DICT_TYPES):</span>
<span class="gi">+        if isinstance(node, nodes.Assign):</span>
<span class="gi">+            more = node.value.as_string()</span>
<span class="gi">+        elif isinstance(node, nodes.For):</span>
<span class="gi">+            more = node.iter.as_string()</span>
<span class="gi">+        return more</span>
<span class="gi">+</span>
<span class="gi">+    inferred_module = inferred.root().name</span>
<span class="gi">+    if node.root().name == inferred_module:</span>
<span class="gi">+        if node.lineno == inferred.lineno:</span>
<span class="gi">+            more = f&quot;&#39;{inferred.as_string()}&#39;&quot;</span>
<span class="gi">+        elif inferred.lineno:</span>
<span class="gi">+            more = f&quot;defined at line {inferred.lineno}&quot;</span>
<span class="gi">+    elif inferred.lineno:</span>
<span class="gi">+        more = f&quot;defined at line {inferred.lineno} of {inferred_module}&quot;</span>
<span class="gi">+    return more</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _detect_global_scope(</span>
<span class="gi">+    node: nodes.Name, frame: nodes.LocalsDictNodeNG, defframe: nodes.LocalsDictNodeNG</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Detect that the given frames share a global scope.

<span class="w"> </span>    Two frames share a global scope when neither
<span class="gu">@@ -94,11 +198,68 @@ def _detect_global_scope(node: nodes.Name, frame: nodes.LocalsDictNodeNG,</span>
<span class="w"> </span>                class B(C): ...
<span class="w"> </span>        class C: ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _fix_dot_imports(not_consumed: dict[str, list[nodes.NodeNG]]) -&gt;list[tuple</span>
<span class="gd">-    [str, _base_nodes.ImportNode]]:</span>
<span class="gi">+    def_scope = scope = None</span>
<span class="gi">+    if frame and frame.parent:</span>
<span class="gi">+        scope = frame.parent.scope()</span>
<span class="gi">+    if defframe and defframe.parent:</span>
<span class="gi">+        def_scope = defframe.parent.scope()</span>
<span class="gi">+    if (</span>
<span class="gi">+        isinstance(frame, nodes.ClassDef)</span>
<span class="gi">+        and scope is not def_scope</span>
<span class="gi">+        and scope is utils.get_node_first_ancestor_of_type(node, nodes.FunctionDef)</span>
<span class="gi">+    ):</span>
<span class="gi">+        # If the current node&#39;s scope is a class nested under a function,</span>
<span class="gi">+        # and the def_scope is something else, then they aren&#39;t shared.</span>
<span class="gi">+        return False</span>
<span class="gi">+    if isinstance(frame, nodes.FunctionDef):</span>
<span class="gi">+        # If the parent of the current node is a</span>
<span class="gi">+        # function, then it can be under its scope (defined in); or</span>
<span class="gi">+        # the `-&gt;` part of annotations. The same goes</span>
<span class="gi">+        # for annotations of function arguments, they&#39;ll have</span>
<span class="gi">+        # their parent the Arguments node.</span>
<span class="gi">+        if frame.parent_of(defframe):</span>
<span class="gi">+            return node.lineno &lt; defframe.lineno  # type: ignore[no-any-return]</span>
<span class="gi">+        if not isinstance(node.parent, (nodes.FunctionDef, nodes.Arguments)):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    break_scopes = []</span>
<span class="gi">+    for current_scope in (scope or frame, def_scope):</span>
<span class="gi">+        # Look for parent scopes. If there is anything different</span>
<span class="gi">+        # than a module or a class scope, then the frames don&#39;t</span>
<span class="gi">+        # share a global scope.</span>
<span class="gi">+        parent_scope = current_scope</span>
<span class="gi">+        while parent_scope:</span>
<span class="gi">+            if not isinstance(parent_scope, (nodes.ClassDef, nodes.Module)):</span>
<span class="gi">+                break_scopes.append(parent_scope)</span>
<span class="gi">+                break</span>
<span class="gi">+            if parent_scope.parent:</span>
<span class="gi">+                parent_scope = parent_scope.parent.scope()</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+    if len(set(break_scopes)) &gt; 1:</span>
<span class="gi">+        # Store different scopes than expected.</span>
<span class="gi">+        # If the stored scopes are, in fact, the very same, then it means</span>
<span class="gi">+        # that the two frames (frame and defframe) share the same scope,</span>
<span class="gi">+        # and we could apply our lineno analysis over them.</span>
<span class="gi">+        # For instance, this works when they are inside a function, the node</span>
<span class="gi">+        # that uses a definition and the definition itself.</span>
<span class="gi">+        return False</span>
<span class="gi">+    # At this point, we are certain that frame and defframe share a scope</span>
<span class="gi">+    # and the definition of the first depends on the second.</span>
<span class="gi">+    return frame.lineno &lt; defframe.lineno  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _infer_name_module(</span>
<span class="gi">+    node: nodes.Import, name: str</span>
<span class="gi">+) -&gt; Generator[InferenceResult, None, None]:</span>
<span class="gi">+    context = astroid.context.InferenceContext()</span>
<span class="gi">+    context.lookupname = name</span>
<span class="gi">+    return node.infer(context, asname=False)  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _fix_dot_imports(</span>
<span class="gi">+    not_consumed: dict[str, list[nodes.NodeNG]]</span>
<span class="gi">+) -&gt; list[tuple[str, _base_nodes.ImportNode]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Try to fix imports with multiple dots, by returning a dictionary
<span class="w"> </span>    with the import names expanded.

<span class="gu">@@ -106,94 +267,268 @@ def _fix_dot_imports(not_consumed: dict[str, list[nodes.NodeNG]]) -&gt;list[tuple</span>
<span class="w"> </span>    like &#39;xml&#39; (when we have both &#39;xml.etree&#39; and &#39;xml.sax&#39;), to &#39;xml.etree&#39;
<span class="w"> </span>    and &#39;xml.sax&#39; respectively.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _find_frame_imports(name: str, frame: nodes.LocalsDictNodeNG) -&gt;bool:</span>
<span class="gi">+    names: dict[str, _base_nodes.ImportNode] = {}</span>
<span class="gi">+    for name, stmts in not_consumed.items():</span>
<span class="gi">+        if any(</span>
<span class="gi">+            isinstance(stmt, nodes.AssignName)</span>
<span class="gi">+            and isinstance(stmt.assign_type(), nodes.AugAssign)</span>
<span class="gi">+            for stmt in stmts</span>
<span class="gi">+        ):</span>
<span class="gi">+            continue</span>
<span class="gi">+        for stmt in stmts:</span>
<span class="gi">+            if not isinstance(stmt, (nodes.ImportFrom, nodes.Import)):</span>
<span class="gi">+                continue</span>
<span class="gi">+            for imports in stmt.names:</span>
<span class="gi">+                second_name = None</span>
<span class="gi">+                import_module_name = imports[0]</span>
<span class="gi">+                if import_module_name == &quot;*&quot;:</span>
<span class="gi">+                    # In case of wildcard imports,</span>
<span class="gi">+                    # pick the name from inside the imported module.</span>
<span class="gi">+                    second_name = name</span>
<span class="gi">+                else:</span>
<span class="gi">+                    name_matches_dotted_import = False</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        import_module_name.startswith(name)</span>
<span class="gi">+                        and import_module_name.find(&quot;.&quot;) &gt; -1</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        name_matches_dotted_import = True</span>
<span class="gi">+</span>
<span class="gi">+                    if name_matches_dotted_import or name in imports:</span>
<span class="gi">+                        # Most likely something like &#39;xml.etree&#39;,</span>
<span class="gi">+                        # which will appear in the .locals as &#39;xml&#39;.</span>
<span class="gi">+                        # Only pick the name if it wasn&#39;t consumed.</span>
<span class="gi">+                        second_name = import_module_name</span>
<span class="gi">+                if second_name and second_name not in names:</span>
<span class="gi">+                    names[second_name] = stmt</span>
<span class="gi">+    return sorted(names.items(), key=lambda a: a[1].fromlineno)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _find_frame_imports(name: str, frame: nodes.LocalsDictNodeNG) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Detect imports in the frame, with the required *name*.

<span class="w"> </span>    Such imports can be considered assignments if they are not globals.
<span class="w"> </span>    Returns True if an import for the given name was found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _assigned_locally(name_node: nodes.Name) -&gt;bool:</span>
<span class="gi">+    if name in _flattened_scope_names(frame.nodes_of_class(nodes.Global)):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    imports = frame.nodes_of_class((nodes.Import, nodes.ImportFrom))</span>
<span class="gi">+    for import_node in imports:</span>
<span class="gi">+        for import_name, import_alias in import_node.names:</span>
<span class="gi">+            # If the import uses an alias, check only that.</span>
<span class="gi">+            # Otherwise, check only the import name.</span>
<span class="gi">+            if import_alias:</span>
<span class="gi">+                if import_alias == name:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            elif import_name and import_name == name:</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _import_name_is_global(</span>
<span class="gi">+    stmt: nodes.Global | _base_nodes.ImportNode, global_names: set[str]</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    for import_name, import_alias in stmt.names:</span>
<span class="gi">+        # If the import uses an alias, check only that.</span>
<span class="gi">+        # Otherwise, check only the import name.</span>
<span class="gi">+        if import_alias:</span>
<span class="gi">+            if import_alias in global_names:</span>
<span class="gi">+                return True</span>
<span class="gi">+        elif import_name in global_names:</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _flattened_scope_names(</span>
<span class="gi">+    iterator: Iterator[nodes.Global | nodes.Nonlocal],</span>
<span class="gi">+) -&gt; set[str]:</span>
<span class="gi">+    values = (set(stmt.names) for stmt in iterator)</span>
<span class="gi">+    return set(itertools.chain.from_iterable(values))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _assigned_locally(name_node: nodes.Name) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if name_node has corresponding assign statement in same scope.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;E0601&#39;: (</span>
<span class="gd">-    &#39;Using variable %r before assignment&#39;, &#39;used-before-assignment&#39;,</span>
<span class="gd">-    &#39;Emitted when a local variable is accessed before its assignment took place. Assignments in try blocks are assumed not to have occurred when evaluating associated except/finally blocks. Assignments in except blocks are assumed not to have occurred when evaluating statements outside the block, except when the associated try block contains a return statement.&#39;</span>
<span class="gd">-    ), &#39;E0602&#39;: (&#39;Undefined variable %r&#39;, &#39;undefined-variable&#39;,</span>
<span class="gd">-    &#39;Used when an undefined variable is accessed.&#39;), &#39;E0603&#39;: (</span>
<span class="gd">-    &#39;Undefined variable name %r in __all__&#39;, &#39;undefined-all-variable&#39;,</span>
<span class="gd">-    &#39;Used when an undefined variable name is referenced in __all__.&#39;),</span>
<span class="gd">-    &#39;E0604&#39;: (&#39;Invalid object %r in __all__, must contain only strings&#39;,</span>
<span class="gd">-    &#39;invalid-all-object&#39;,</span>
<span class="gd">-    &#39;Used when an invalid (non-string) object occurs in __all__.&#39;), &#39;E0605&#39;:</span>
<span class="gd">-    (&#39;Invalid format for __all__, must be tuple or list&#39;,</span>
<span class="gd">-    &#39;invalid-all-format&#39;, &#39;Used when __all__ has an invalid format.&#39;),</span>
<span class="gd">-    &#39;E0606&#39;: (&#39;Possibly using variable %r before assignment&#39;,</span>
<span class="gd">-    &#39;possibly-used-before-assignment&#39;,</span>
<span class="gd">-    &#39;Emitted when a local variable is accessed before its assignment took place in both branches of an if/else switch.&#39;</span>
<span class="gd">-    ), &#39;E0611&#39;: (&#39;No name %r in module %r&#39;, &#39;no-name-in-module&#39;,</span>
<span class="gd">-    &#39;Used when a name cannot be found in a module.&#39;), &#39;W0601&#39;: (</span>
<span class="gd">-    &#39;Global variable %r undefined at the module level&#39;,</span>
<span class="gd">-    &#39;global-variable-undefined&#39;,</span>
<span class="gd">-    &#39;Used when a variable is defined through the &quot;global&quot; statement but the variable is not defined in the module scope.&#39;</span>
<span class="gd">-    ), &#39;W0602&#39;: (&#39;Using global for %r but no assignment is done&#39;,</span>
<span class="gd">-    &#39;global-variable-not-assigned&#39;,</span>
<span class="gd">-    &quot;When a variable defined in the global scope is modified in an inner scope, the &#39;global&#39; keyword is required in the inner scope only if there is an assignment operation done in the inner scope.&quot;</span>
<span class="gd">-    ), &#39;W0603&#39;: (&#39;Using the global statement&#39;, &#39;global-statement&#39;,</span>
<span class="gd">-    &#39;Used when you use the &quot;global&quot; statement to update a global variable. Pylint discourages its usage. That doesn\&#39;t mean you cannot use it!&#39;</span>
<span class="gd">-    ), &#39;W0604&#39;: (&#39;Using the global statement at the module level&#39;,</span>
<span class="gd">-    &#39;global-at-module-level&#39;,</span>
<span class="gd">-    &#39;Used when you use the &quot;global&quot; statement at the module level since it has no effect.&#39;</span>
<span class="gd">-    ), &#39;W0611&#39;: (&#39;Unused %s&#39;, &#39;unused-import&#39;,</span>
<span class="gd">-    &#39;Used when an imported module or variable is not used.&#39;), &#39;W0612&#39;: (</span>
<span class="gd">-    &#39;Unused variable %r&#39;, &#39;unused-variable&#39;,</span>
<span class="gd">-    &#39;Used when a variable is defined but not used.&#39;), &#39;W0613&#39;: (</span>
<span class="gd">-    &#39;Unused argument %r&#39;, &#39;unused-argument&#39;,</span>
<span class="gd">-    &#39;Used when a function or method argument is not used.&#39;), &#39;W0614&#39;: (</span>
<span class="gd">-    &#39;Unused import(s) %s from wildcard import of %s&#39;,</span>
<span class="gd">-    &#39;unused-wildcard-import&#39;,</span>
<span class="gd">-    &quot;Used when an imported module or variable is not used from a `&#39;from X import *&#39;` style import.&quot;</span>
<span class="gd">-    ), &#39;W0621&#39;: (&#39;Redefining name %r from outer scope (line %s)&#39;,</span>
<span class="gd">-    &#39;redefined-outer-name&#39;,</span>
<span class="gd">-    &quot;Used when a variable&#39;s name hides a name defined in an outer scope or except handler.&quot;</span>
<span class="gd">-    ), &#39;W0622&#39;: (&#39;Redefining built-in %r&#39;, &#39;redefined-builtin&#39;,</span>
<span class="gd">-    &#39;Used when a variable or function override a built-in.&#39;), &#39;W0631&#39;: (</span>
<span class="gd">-    &#39;Using possibly undefined loop variable %r&#39;, &#39;undefined-loop-variable&#39;,</span>
<span class="gd">-    &#39;Used when a loop variable (i.e. defined by a for loop or a list comprehension or a generator expression) is used outside the loop.&#39;</span>
<span class="gd">-    ), &#39;W0632&#39;: (</span>
<span class="gd">-    &#39;Possible unbalanced tuple unpacking with sequence %s: left side has %d label%s, right side has %d value%s&#39;</span>
<span class="gd">-    , &#39;unbalanced-tuple-unpacking&#39;,</span>
<span class="gd">-    &#39;Used when there is an unbalanced tuple unpacking in assignment&#39;, {</span>
<span class="gd">-    &#39;old_names&#39;: [(&#39;E0632&#39;, &#39;old-unbalanced-tuple-unpacking&#39;)]}), &#39;E0633&#39;:</span>
<span class="gd">-    (&#39;Attempting to unpack a non-sequence%s&#39;, &#39;unpacking-non-sequence&#39;,</span>
<span class="gd">-    &#39;Used when something which is not a sequence is used in an unpack assignment&#39;</span>
<span class="gd">-    , {&#39;old_names&#39;: [(&#39;W0633&#39;, &#39;old-unpacking-non-sequence&#39;)]}), &#39;W0640&#39;: (</span>
<span class="gd">-    &#39;Cell variable %s defined in loop&#39;, &#39;cell-var-from-loop&#39;,</span>
<span class="gd">-    &#39;A variable used in a closure is defined in a loop. This will result in all closures using the same value for the closed-over variable.&#39;</span>
<span class="gd">-    ), &#39;W0641&#39;: (&#39;Possibly unused variable %r&#39;, &#39;possibly-unused-variable&#39;,</span>
<span class="gd">-    &#39;Used when a variable is defined but might not be used. The possibility comes from the fact that locals() might be used, which could consume or not the said variable&#39;</span>
<span class="gd">-    ), &#39;W0642&#39;: (&#39;Invalid assignment to %s in method&#39;,</span>
<span class="gd">-    &#39;self-cls-assignment&#39;,</span>
<span class="gd">-    &#39;Invalid assignment to self or cls in instance or class method respectively.&#39;</span>
<span class="gd">-    ), &#39;E0643&#39;: (&#39;Invalid index for iterable length&#39;,</span>
<span class="gd">-    &#39;potential-index-error&#39;,</span>
<span class="gd">-    &#39;Emitted when an index used on an iterable goes beyond the length of that iterable.&#39;</span>
<span class="gd">-    ), &#39;W0644&#39;: (</span>
<span class="gd">-    &#39;Possible unbalanced dict unpacking with %s: left side has %d label%s, right side has %d value%s&#39;</span>
<span class="gd">-    , &#39;unbalanced-dict-unpacking&#39;,</span>
<span class="gd">-    &#39;Used when there is an unbalanced dict unpacking in assignment or for loop&#39;</span>
<span class="gd">-    )}</span>
<span class="gi">+    name_node_scope = name_node.scope()</span>
<span class="gi">+    assign_stmts = name_node_scope.nodes_of_class(nodes.AssignName)</span>
<span class="gi">+    return any(a.name == name_node.name for a in assign_stmts) or _find_frame_imports(</span>
<span class="gi">+        name_node.name, name_node_scope</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _has_locals_call_after_node(stmt: nodes.NodeNG, scope: nodes.FunctionDef) -&gt; bool:</span>
<span class="gi">+    skip_nodes = (</span>
<span class="gi">+        nodes.FunctionDef,</span>
<span class="gi">+        nodes.ClassDef,</span>
<span class="gi">+        nodes.Import,</span>
<span class="gi">+        nodes.ImportFrom,</span>
<span class="gi">+    )</span>
<span class="gi">+    for call in scope.nodes_of_class(nodes.Call, skip_klass=skip_nodes):</span>
<span class="gi">+        inferred = utils.safe_infer(call.func)</span>
<span class="gi">+        if (</span>
<span class="gi">+            utils.is_builtin_object(inferred)</span>
<span class="gi">+            and getattr(inferred, &quot;name&quot;, None) == &quot;locals&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            if stmt.lineno &lt; call.lineno:</span>
<span class="gi">+                return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+    &quot;E0601&quot;: (</span>
<span class="gi">+        &quot;Using variable %r before assignment&quot;,</span>
<span class="gi">+        &quot;used-before-assignment&quot;,</span>
<span class="gi">+        &quot;Emitted when a local variable is accessed before its assignment took place. &quot;</span>
<span class="gi">+        &quot;Assignments in try blocks are assumed not to have occurred when evaluating &quot;</span>
<span class="gi">+        &quot;associated except/finally blocks. Assignments in except blocks are assumed &quot;</span>
<span class="gi">+        &quot;not to have occurred when evaluating statements outside the block, except &quot;</span>
<span class="gi">+        &quot;when the associated try block contains a return statement.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0602&quot;: (</span>
<span class="gi">+        &quot;Undefined variable %r&quot;,</span>
<span class="gi">+        &quot;undefined-variable&quot;,</span>
<span class="gi">+        &quot;Used when an undefined variable is accessed.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0603&quot;: (</span>
<span class="gi">+        &quot;Undefined variable name %r in __all__&quot;,</span>
<span class="gi">+        &quot;undefined-all-variable&quot;,</span>
<span class="gi">+        &quot;Used when an undefined variable name is referenced in __all__.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0604&quot;: (</span>
<span class="gi">+        &quot;Invalid object %r in __all__, must contain only strings&quot;,</span>
<span class="gi">+        &quot;invalid-all-object&quot;,</span>
<span class="gi">+        &quot;Used when an invalid (non-string) object occurs in __all__.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0605&quot;: (</span>
<span class="gi">+        &quot;Invalid format for __all__, must be tuple or list&quot;,</span>
<span class="gi">+        &quot;invalid-all-format&quot;,</span>
<span class="gi">+        &quot;Used when __all__ has an invalid format.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0606&quot;: (</span>
<span class="gi">+        &quot;Possibly using variable %r before assignment&quot;,</span>
<span class="gi">+        &quot;possibly-used-before-assignment&quot;,</span>
<span class="gi">+        &quot;Emitted when a local variable is accessed before its assignment took place &quot;</span>
<span class="gi">+        &quot;in both branches of an if/else switch.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0611&quot;: (</span>
<span class="gi">+        &quot;No name %r in module %r&quot;,</span>
<span class="gi">+        &quot;no-name-in-module&quot;,</span>
<span class="gi">+        &quot;Used when a name cannot be found in a module.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0601&quot;: (</span>
<span class="gi">+        &quot;Global variable %r undefined at the module level&quot;,</span>
<span class="gi">+        &quot;global-variable-undefined&quot;,</span>
<span class="gi">+        &#39;Used when a variable is defined through the &quot;global&quot; statement &#39;</span>
<span class="gi">+        &quot;but the variable is not defined in the module scope.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0602&quot;: (</span>
<span class="gi">+        &quot;Using global for %r but no assignment is done&quot;,</span>
<span class="gi">+        &quot;global-variable-not-assigned&quot;,</span>
<span class="gi">+        &quot;When a variable defined in the global scope is modified in an inner scope, &quot;</span>
<span class="gi">+        &quot;the &#39;global&#39; keyword is required in the inner scope only if there is an &quot;</span>
<span class="gi">+        &quot;assignment operation done in the inner scope.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0603&quot;: (</span>
<span class="gi">+        &quot;Using the global statement&quot;,  # W0121</span>
<span class="gi">+        &quot;global-statement&quot;,</span>
<span class="gi">+        &#39;Used when you use the &quot;global&quot; statement to update a global &#39;</span>
<span class="gi">+        &quot;variable. Pylint discourages its usage. That doesn&#39;t mean you cannot &quot;</span>
<span class="gi">+        &quot;use it!&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0604&quot;: (</span>
<span class="gi">+        &quot;Using the global statement at the module level&quot;,  # W0103</span>
<span class="gi">+        &quot;global-at-module-level&quot;,</span>
<span class="gi">+        &#39;Used when you use the &quot;global&quot; statement at the module level &#39;</span>
<span class="gi">+        &quot;since it has no effect.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0611&quot;: (</span>
<span class="gi">+        &quot;Unused %s&quot;,</span>
<span class="gi">+        &quot;unused-import&quot;,</span>
<span class="gi">+        &quot;Used when an imported module or variable is not used.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0612&quot;: (</span>
<span class="gi">+        &quot;Unused variable %r&quot;,</span>
<span class="gi">+        &quot;unused-variable&quot;,</span>
<span class="gi">+        &quot;Used when a variable is defined but not used.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0613&quot;: (</span>
<span class="gi">+        &quot;Unused argument %r&quot;,</span>
<span class="gi">+        &quot;unused-argument&quot;,</span>
<span class="gi">+        &quot;Used when a function or method argument is not used.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0614&quot;: (</span>
<span class="gi">+        &quot;Unused import(s) %s from wildcard import of %s&quot;,</span>
<span class="gi">+        &quot;unused-wildcard-import&quot;,</span>
<span class="gi">+        &quot;Used when an imported module or variable is not used from a &quot;</span>
<span class="gi">+        &quot;`&#39;from X import *&#39;` style import.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0621&quot;: (</span>
<span class="gi">+        &quot;Redefining name %r from outer scope (line %s)&quot;,</span>
<span class="gi">+        &quot;redefined-outer-name&quot;,</span>
<span class="gi">+        &quot;Used when a variable&#39;s name hides a name defined in an outer scope or except handler.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0622&quot;: (</span>
<span class="gi">+        &quot;Redefining built-in %r&quot;,</span>
<span class="gi">+        &quot;redefined-builtin&quot;,</span>
<span class="gi">+        &quot;Used when a variable or function override a built-in.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0631&quot;: (</span>
<span class="gi">+        &quot;Using possibly undefined loop variable %r&quot;,</span>
<span class="gi">+        &quot;undefined-loop-variable&quot;,</span>
<span class="gi">+        &quot;Used when a loop variable (i.e. defined by a for loop or &quot;</span>
<span class="gi">+        &quot;a list comprehension or a generator expression) is used outside &quot;</span>
<span class="gi">+        &quot;the loop.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0632&quot;: (</span>
<span class="gi">+        &quot;Possible unbalanced tuple unpacking with sequence %s: left side has %d &quot;</span>
<span class="gi">+        &quot;label%s, right side has %d value%s&quot;,</span>
<span class="gi">+        &quot;unbalanced-tuple-unpacking&quot;,</span>
<span class="gi">+        &quot;Used when there is an unbalanced tuple unpacking in assignment&quot;,</span>
<span class="gi">+        {&quot;old_names&quot;: [(&quot;E0632&quot;, &quot;old-unbalanced-tuple-unpacking&quot;)]},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0633&quot;: (</span>
<span class="gi">+        &quot;Attempting to unpack a non-sequence%s&quot;,</span>
<span class="gi">+        &quot;unpacking-non-sequence&quot;,</span>
<span class="gi">+        &quot;Used when something which is not a sequence is used in an unpack assignment&quot;,</span>
<span class="gi">+        {&quot;old_names&quot;: [(&quot;W0633&quot;, &quot;old-unpacking-non-sequence&quot;)]},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0640&quot;: (</span>
<span class="gi">+        &quot;Cell variable %s defined in loop&quot;,</span>
<span class="gi">+        &quot;cell-var-from-loop&quot;,</span>
<span class="gi">+        &quot;A variable used in a closure is defined in a loop. &quot;</span>
<span class="gi">+        &quot;This will result in all closures using the same value for &quot;</span>
<span class="gi">+        &quot;the closed-over variable.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0641&quot;: (</span>
<span class="gi">+        &quot;Possibly unused variable %r&quot;,</span>
<span class="gi">+        &quot;possibly-unused-variable&quot;,</span>
<span class="gi">+        &quot;Used when a variable is defined but might not be used. &quot;</span>
<span class="gi">+        &quot;The possibility comes from the fact that locals() might be used, &quot;</span>
<span class="gi">+        &quot;which could consume or not the said variable&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0642&quot;: (</span>
<span class="gi">+        &quot;Invalid assignment to %s in method&quot;,</span>
<span class="gi">+        &quot;self-cls-assignment&quot;,</span>
<span class="gi">+        &quot;Invalid assignment to self or cls in instance or class method &quot;</span>
<span class="gi">+        &quot;respectively.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0643&quot;: (</span>
<span class="gi">+        &quot;Invalid index for iterable length&quot;,</span>
<span class="gi">+        &quot;potential-index-error&quot;,</span>
<span class="gi">+        &quot;Emitted when an index used on an iterable goes beyond the length of that &quot;</span>
<span class="gi">+        &quot;iterable.&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0644&quot;: (</span>
<span class="gi">+        &quot;Possible unbalanced dict unpacking with %s: &quot;</span>
<span class="gi">+        &quot;left side has %d label%s, right side has %d value%s&quot;,</span>
<span class="gi">+        &quot;unbalanced-dict-unpacking&quot;,</span>
<span class="gi">+        &quot;Used when there is an unbalanced dict unpacking in assignment or for loop&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+}</span>


<span class="w"> </span>class ScopeConsumer(NamedTuple):
<span class="w"> </span>    &quot;&quot;&quot;Store nodes and their consumption states.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    to_consume: dict[str, list[nodes.NodeNG]]
<span class="w"> </span>    consumed: dict[str, list[nodes.NodeNG]]
<span class="w"> </span>    consumed_uncertain: defaultdict[str, list[nodes.NodeNG]]
<span class="gu">@@ -203,22 +538,23 @@ class ScopeConsumer(NamedTuple):</span>
<span class="w"> </span>class NamesConsumer:
<span class="w"> </span>    &quot;&quot;&quot;A simple class to handle consumed, to consume and scope type info of node locals.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, node: nodes.NodeNG, scope_type: str) -&gt;None:</span>
<span class="gd">-        self._atomic = ScopeConsumer(copy.copy(node.locals), {},</span>
<span class="gd">-            collections.defaultdict(list), scope_type)</span>
<span class="gi">+    def __init__(self, node: nodes.NodeNG, scope_type: str) -&gt; None:</span>
<span class="gi">+        self._atomic = ScopeConsumer(</span>
<span class="gi">+            copy.copy(node.locals), {}, collections.defaultdict(list), scope_type</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.node = node
<span class="w"> </span>        self.names_under_always_false_test: set[str] = set()
<span class="w"> </span>        self.names_defined_under_one_branch_only: set[str] = set()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        _to_consumes = [f&#39;{k}-&gt;{v}&#39; for k, v in self._atomic.to_consume.items()</span>
<span class="gd">-            ]</span>
<span class="gd">-        _consumed = [f&#39;{k}-&gt;{v}&#39; for k, v in self._atomic.consumed.items()]</span>
<span class="gd">-        _consumed_uncertain = [f&#39;{k}-&gt;{v}&#39; for k, v in self._atomic.</span>
<span class="gd">-            consumed_uncertain.items()]</span>
<span class="gd">-        to_consumes = &#39;, &#39;.join(_to_consumes)</span>
<span class="gd">-        consumed = &#39;, &#39;.join(_consumed)</span>
<span class="gd">-        consumed_uncertain = &#39;, &#39;.join(_consumed_uncertain)</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        _to_consumes = [f&quot;{k}-&gt;{v}&quot; for k, v in self._atomic.to_consume.items()]</span>
<span class="gi">+        _consumed = [f&quot;{k}-&gt;{v}&quot; for k, v in self._atomic.consumed.items()]</span>
<span class="gi">+        _consumed_uncertain = [</span>
<span class="gi">+            f&quot;{k}-&gt;{v}&quot; for k, v in self._atomic.consumed_uncertain.items()</span>
<span class="gi">+        ]</span>
<span class="gi">+        to_consumes = &quot;, &quot;.join(_to_consumes)</span>
<span class="gi">+        consumed = &quot;, &quot;.join(_consumed)</span>
<span class="gi">+        consumed_uncertain = &quot;, &quot;.join(_consumed_uncertain)</span>
<span class="w"> </span>        return f&quot;&quot;&quot;
<span class="w"> </span>to_consume : {to_consumes}
<span class="w"> </span>consumed : {consumed}
<span class="gu">@@ -226,11 +562,19 @@ consumed_uncertain: {consumed_uncertain}</span>
<span class="w"> </span>scope_type : {self._atomic.scope_type}
<span class="w"> </span>&quot;&quot;&quot;

<span class="gd">-    def __iter__(self) -&gt;Iterator[Any]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[Any]:</span>
<span class="w"> </span>        return iter(self._atomic)

<span class="w"> </span>    @property
<span class="gd">-    def consumed_uncertain(self) -&gt;defaultdict[str, list[nodes.NodeNG]]:</span>
<span class="gi">+    def to_consume(self) -&gt; dict[str, list[nodes.NodeNG]]:</span>
<span class="gi">+        return self._atomic.to_consume</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def consumed(self) -&gt; dict[str, list[nodes.NodeNG]]:</span>
<span class="gi">+        return self._atomic.consumed</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def consumed_uncertain(self) -&gt; defaultdict[str, list[nodes.NodeNG]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieves nodes filtered out by get_next_to_consume() that may not
<span class="w"> </span>        have executed.

<span class="gu">@@ -239,75 +583,439 @@ scope_type : {self._atomic.scope_type}</span>
<span class="w"> </span>        blocks). Checkers that want to treat the statements as executed
<span class="w"> </span>        (e.g. for unused-variable) may need to add them back.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._atomic.consumed_uncertain</span>

<span class="gd">-    def mark_as_consumed(self, name: str, consumed_nodes: list[nodes.NodeNG]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def scope_type(self) -&gt; str:</span>
<span class="gi">+        return self._atomic.scope_type</span>
<span class="gi">+</span>
<span class="gi">+    def mark_as_consumed(self, name: str, consumed_nodes: list[nodes.NodeNG]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Mark the given nodes as consumed for the name.

<span class="w"> </span>        If all of the nodes for the name were consumed, delete the name from
<span class="w"> </span>        the to_consume dictionary
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        unconsumed = [n for n in self.to_consume[name] if n not in set(consumed_nodes)]</span>
<span class="gi">+        self.consumed[name] = consumed_nodes</span>
<span class="gi">+</span>
<span class="gi">+        if unconsumed:</span>
<span class="gi">+            self.to_consume[name] = unconsumed</span>
<span class="gi">+        else:</span>
<span class="gi">+            del self.to_consume[name]</span>

<span class="gd">-    def get_next_to_consume(self, node: nodes.Name) -&gt;(list[nodes.NodeNG] |</span>
<span class="gd">-        None):</span>
<span class="gi">+    def get_next_to_consume(self, node: nodes.Name) -&gt; list[nodes.NodeNG] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of the nodes that define `node` from this scope.

<span class="w"> </span>        If it is uncertain whether a node will be consumed, such as for statements in
<span class="w"> </span>        except blocks, add it to self.consumed_uncertain instead of returning it.
<span class="w"> </span>        Return None to indicate a special case that needs to be handled by the caller.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = node.name</span>
<span class="gi">+        parent_node = node.parent</span>
<span class="gi">+        found_nodes = self.to_consume.get(name)</span>
<span class="gi">+        node_statement = node.statement()</span>
<span class="gi">+        if (</span>
<span class="gi">+            found_nodes</span>
<span class="gi">+            and isinstance(parent_node, nodes.Assign)</span>
<span class="gi">+            and parent_node == found_nodes[0].parent</span>
<span class="gi">+        ):</span>
<span class="gi">+            lhs = found_nodes[0].parent.targets[0]</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(lhs, nodes.AssignName) and lhs.name == name</span>
<span class="gi">+            ):  # this name is defined in this very statement</span>
<span class="gi">+                found_nodes = None</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            found_nodes</span>
<span class="gi">+            and isinstance(parent_node, nodes.For)</span>
<span class="gi">+            and parent_node.iter == node</span>
<span class="gi">+            and parent_node.target in found_nodes</span>
<span class="gi">+        ):</span>
<span class="gi">+            found_nodes = None</span>
<span class="gi">+</span>
<span class="gi">+        # Before filtering, check that this node&#39;s name is not a nonlocal</span>
<span class="gi">+        if any(</span>
<span class="gi">+            isinstance(child, nodes.Nonlocal) and node.name in child.names</span>
<span class="gi">+            for child in node.frame().get_children()</span>
<span class="gi">+        ):</span>
<span class="gi">+            return found_nodes</span>
<span class="gi">+</span>
<span class="gi">+        # And no comprehension is under the node&#39;s frame</span>
<span class="gi">+        if VariablesChecker._comprehension_between_frame_and_node(node):</span>
<span class="gi">+            return found_nodes</span>
<span class="gi">+</span>
<span class="gi">+        # Filter out assignments in ExceptHandlers that node is not contained in</span>
<span class="gi">+        if found_nodes:</span>
<span class="gi">+            found_nodes = [</span>
<span class="gi">+                n</span>
<span class="gi">+                for n in found_nodes</span>
<span class="gi">+                if not isinstance(n.statement(), nodes.ExceptHandler)</span>
<span class="gi">+                or n.statement().parent_of(node)</span>
<span class="gi">+            ]</span>

<span class="gd">-    def _inferred_to_define_name_raise_or_return(self, name: str, node:</span>
<span class="gd">-        nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+        # Filter out assignments guarded by always false conditions</span>
<span class="gi">+        if found_nodes:</span>
<span class="gi">+            uncertain_nodes = self._uncertain_nodes_if_tests(found_nodes, node)</span>
<span class="gi">+            self.consumed_uncertain[node.name] += uncertain_nodes</span>
<span class="gi">+            uncertain_nodes_set = set(uncertain_nodes)</span>
<span class="gi">+            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]</span>
<span class="gi">+</span>
<span class="gi">+        # Filter out assignments in an Except clause that the node is not</span>
<span class="gi">+        # contained in, assuming they may fail</span>
<span class="gi">+        if found_nodes:</span>
<span class="gi">+            uncertain_nodes = self._uncertain_nodes_in_except_blocks(</span>
<span class="gi">+                found_nodes, node, node_statement</span>
<span class="gi">+            )</span>
<span class="gi">+            self.consumed_uncertain[node.name] += uncertain_nodes</span>
<span class="gi">+            uncertain_nodes_set = set(uncertain_nodes)</span>
<span class="gi">+            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]</span>
<span class="gi">+</span>
<span class="gi">+        # If this node is in a Finally block of a Try/Finally,</span>
<span class="gi">+        # filter out assignments in the try portion, assuming they may fail</span>
<span class="gi">+        if found_nodes:</span>
<span class="gi">+            uncertain_nodes = (</span>
<span class="gi">+                self._uncertain_nodes_in_try_blocks_when_evaluating_finally_blocks(</span>
<span class="gi">+                    found_nodes, node_statement, name</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            self.consumed_uncertain[node.name] += uncertain_nodes</span>
<span class="gi">+            uncertain_nodes_set = set(uncertain_nodes)</span>
<span class="gi">+            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]</span>
<span class="gi">+</span>
<span class="gi">+        # If this node is in an ExceptHandler,</span>
<span class="gi">+        # filter out assignments in the try portion, assuming they may fail</span>
<span class="gi">+        if found_nodes:</span>
<span class="gi">+            uncertain_nodes = (</span>
<span class="gi">+                self._uncertain_nodes_in_try_blocks_when_evaluating_except_blocks(</span>
<span class="gi">+                    found_nodes, node_statement</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            self.consumed_uncertain[node.name] += uncertain_nodes</span>
<span class="gi">+            uncertain_nodes_set = set(uncertain_nodes)</span>
<span class="gi">+            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]</span>
<span class="gi">+</span>
<span class="gi">+        return found_nodes</span>
<span class="gi">+</span>
<span class="gi">+    def _inferred_to_define_name_raise_or_return(</span>
<span class="gi">+        self, name: str, node: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if there is a path under this `if_node`
<span class="w"> </span>        that is inferred to define `name`, raise, or return.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _uncertain_nodes_if_tests(self, found_nodes: list[nodes.NodeNG],</span>
<span class="gd">-        node: nodes.NodeNG) -&gt;list[nodes.NodeNG]:</span>
<span class="gi">+        # Handle try and with</span>
<span class="gi">+        if isinstance(node, nodes.Try):</span>
<span class="gi">+            # Allow either a path through try/else/finally OR a path through ALL except handlers</span>
<span class="gi">+            try_except_node = node</span>
<span class="gi">+            if node.finalbody:</span>
<span class="gi">+                try_except_node = next(</span>
<span class="gi">+                    (child for child in node.nodes_of_class(nodes.Try)),</span>
<span class="gi">+                    None,</span>
<span class="gi">+                )</span>
<span class="gi">+            handlers = try_except_node.handlers if try_except_node else []</span>
<span class="gi">+            return NamesConsumer._defines_name_raises_or_returns_recursive(</span>
<span class="gi">+                name, node</span>
<span class="gi">+            ) or all(</span>
<span class="gi">+                NamesConsumer._defines_name_raises_or_returns_recursive(name, handler)</span>
<span class="gi">+                for handler in handlers</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node, (nodes.With, nodes.For, nodes.While)):</span>
<span class="gi">+            return NamesConsumer._defines_name_raises_or_returns_recursive(name, node)</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(node, nodes.If):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Be permissive if there is a break or a continue</span>
<span class="gi">+        if any(node.nodes_of_class(nodes.Break, nodes.Continue)):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        # Is there an assignment in this node itself, e.g. in named expression?</span>
<span class="gi">+        if NamesConsumer._defines_name_raises_or_returns(name, node):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        test = node.test.value if isinstance(node.test, nodes.NamedExpr) else node.test</span>
<span class="gi">+        all_inferred = utils.infer_all(test)</span>
<span class="gi">+        only_search_if = False</span>
<span class="gi">+        only_search_else = True</span>
<span class="gi">+</span>
<span class="gi">+        for inferred in all_inferred:</span>
<span class="gi">+            if not isinstance(inferred, nodes.Const):</span>
<span class="gi">+                only_search_else = False</span>
<span class="gi">+                continue</span>
<span class="gi">+            val = inferred.value</span>
<span class="gi">+            only_search_if = only_search_if or (val != NotImplemented and val)</span>
<span class="gi">+            only_search_else = only_search_else and not val</span>
<span class="gi">+</span>
<span class="gi">+        # Only search else branch when test condition is inferred to be false</span>
<span class="gi">+        if all_inferred and only_search_else:</span>
<span class="gi">+            self.names_under_always_false_test.add(name)</span>
<span class="gi">+            return self._branch_handles_name(name, node.orelse)</span>
<span class="gi">+        # Search both if and else branches</span>
<span class="gi">+        if_branch_handles = self._branch_handles_name(name, node.body)</span>
<span class="gi">+        else_branch_handles = self._branch_handles_name(name, node.orelse)</span>
<span class="gi">+        if if_branch_handles ^ else_branch_handles:</span>
<span class="gi">+            self.names_defined_under_one_branch_only.add(name)</span>
<span class="gi">+        elif name in self.names_defined_under_one_branch_only:</span>
<span class="gi">+            self.names_defined_under_one_branch_only.remove(name)</span>
<span class="gi">+        return if_branch_handles and else_branch_handles</span>
<span class="gi">+</span>
<span class="gi">+    def _branch_handles_name(self, name: str, body: Iterable[nodes.NodeNG]) -&gt; bool:</span>
<span class="gi">+        return any(</span>
<span class="gi">+            NamesConsumer._defines_name_raises_or_returns(name, if_body_stmt)</span>
<span class="gi">+            or isinstance(</span>
<span class="gi">+                if_body_stmt,</span>
<span class="gi">+                (</span>
<span class="gi">+                    nodes.If,</span>
<span class="gi">+                    nodes.Try,</span>
<span class="gi">+                    nodes.With,</span>
<span class="gi">+                    nodes.For,</span>
<span class="gi">+                    nodes.While,</span>
<span class="gi">+                ),</span>
<span class="gi">+            )</span>
<span class="gi">+            and self._inferred_to_define_name_raise_or_return(name, if_body_stmt)</span>
<span class="gi">+            for if_body_stmt in body</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _uncertain_nodes_if_tests(</span>
<span class="gi">+        self, found_nodes: list[nodes.NodeNG], node: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; list[nodes.NodeNG]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Identify nodes of uncertain execution because they are defined under if
<span class="w"> </span>        tests.

<span class="w"> </span>        Don&#39;t identify a node if there is a path that is inferred to
<span class="w"> </span>        define the name, raise, or return (e.g. any executed if/elif/else branch).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        uncertain_nodes = []</span>
<span class="gi">+        for other_node in found_nodes:</span>
<span class="gi">+            if isinstance(other_node, nodes.AssignName):</span>
<span class="gi">+                name = other_node.name</span>
<span class="gi">+            elif isinstance(other_node, (nodes.Import, nodes.ImportFrom)):</span>
<span class="gi">+                name = node.name</span>
<span class="gi">+            else:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            all_if = [</span>
<span class="gi">+                n</span>
<span class="gi">+                for n in other_node.node_ancestors()</span>
<span class="gi">+                if isinstance(n, nodes.If) and not n.parent_of(node)</span>
<span class="gi">+            ]</span>
<span class="gi">+            if not all_if:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            closest_if = all_if[0]</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(node, nodes.AssignName)</span>
<span class="gi">+                and node.frame() is not closest_if.frame()</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if closest_if.parent_of(node):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            outer_if = all_if[-1]</span>
<span class="gi">+            if NamesConsumer._node_guarded_by_same_test(node, outer_if):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Name defined in the if/else control flow</span>
<span class="gi">+            if self._inferred_to_define_name_raise_or_return(name, outer_if):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            uncertain_nodes.append(other_node)</span>
<span class="gi">+</span>
<span class="gi">+        return uncertain_nodes</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _node_guarded_by_same_test(node: nodes.NodeNG, other_if: nodes.If</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def _node_guarded_by_same_test(node: nodes.NodeNG, other_if: nodes.If) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Identify if `node` is guarded by an equivalent test as `other_if`.

<span class="w"> </span>        Two tests are equivalent if their string representations are identical
<span class="w"> </span>        or if their inferred values consist only of constants and those constants
<span class="w"> </span>        are identical, and the if test guarding `node` is not a Name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        other_if_test_as_string = other_if.test.as_string()</span>
<span class="gi">+        other_if_test_all_inferred = utils.infer_all(other_if.test)</span>
<span class="gi">+        for ancestor in node.node_ancestors():</span>
<span class="gi">+            if not isinstance(ancestor, nodes.If):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if ancestor.test.as_string() == other_if_test_as_string:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if isinstance(ancestor.test, nodes.Name):</span>
<span class="gi">+                continue</span>
<span class="gi">+            all_inferred = utils.infer_all(ancestor.test)</span>
<span class="gi">+            if len(all_inferred) == len(other_if_test_all_inferred):</span>
<span class="gi">+                if any(</span>
<span class="gi">+                    not isinstance(test, nodes.Const)</span>
<span class="gi">+                    for test in (*all_inferred, *other_if_test_all_inferred)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if {test.value for test in all_inferred} != {</span>
<span class="gi">+                    test.value for test in other_if_test_all_inferred</span>
<span class="gi">+                }:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _uncertain_nodes_in_except_blocks(found_nodes: list[nodes.NodeNG],</span>
<span class="gd">-        node: nodes.NodeNG, node_statement: _base_nodes.Statement) -&gt;list[nodes</span>
<span class="gd">-        .NodeNG]:</span>
<span class="gi">+    def _uncertain_nodes_in_except_blocks(</span>
<span class="gi">+        found_nodes: list[nodes.NodeNG],</span>
<span class="gi">+        node: nodes.NodeNG,</span>
<span class="gi">+        node_statement: _base_nodes.Statement,</span>
<span class="gi">+    ) -&gt; list[nodes.NodeNG]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return any nodes in ``found_nodes`` that should be treated as uncertain
<span class="w"> </span>        because they are in an except block.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        uncertain_nodes = []</span>
<span class="gi">+        for other_node in found_nodes:</span>
<span class="gi">+            other_node_statement = other_node.statement()</span>
<span class="gi">+            # Only testing for statements in the except block of Try</span>
<span class="gi">+            closest_except_handler = utils.get_node_first_ancestor_of_type(</span>
<span class="gi">+                other_node_statement, nodes.ExceptHandler</span>
<span class="gi">+            )</span>
<span class="gi">+            if not closest_except_handler:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # If the other node is in the same scope as this node, assume it executes</span>
<span class="gi">+            if closest_except_handler.parent_of(node):</span>
<span class="gi">+                continue</span>
<span class="gi">+            closest_try_except: nodes.Try = closest_except_handler.parent</span>
<span class="gi">+            # If the try or else blocks return, assume the except blocks execute.</span>
<span class="gi">+            try_block_returns = any(</span>
<span class="gi">+                isinstance(try_statement, nodes.Return)</span>
<span class="gi">+                for try_statement in closest_try_except.body</span>
<span class="gi">+            )</span>
<span class="gi">+            else_block_returns = any(</span>
<span class="gi">+                isinstance(else_statement, nodes.Return)</span>
<span class="gi">+                for else_statement in closest_try_except.orelse</span>
<span class="gi">+            )</span>
<span class="gi">+            else_block_exits = any(</span>
<span class="gi">+                isinstance(else_statement, nodes.Expr)</span>
<span class="gi">+                and isinstance(else_statement.value, nodes.Call)</span>
<span class="gi">+                and utils.is_terminating_func(else_statement.value)</span>
<span class="gi">+                for else_statement in closest_try_except.orelse</span>
<span class="gi">+            )</span>
<span class="gi">+            else_block_continues = any(</span>
<span class="gi">+                isinstance(else_statement, nodes.Continue)</span>
<span class="gi">+                for else_statement in closest_try_except.orelse</span>
<span class="gi">+            )</span>
<span class="gi">+            if (</span>
<span class="gi">+                else_block_continues</span>
<span class="gi">+                and isinstance(node_statement.parent, (nodes.For, nodes.While))</span>
<span class="gi">+                and closest_try_except.parent.parent_of(node_statement)</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if try_block_returns or else_block_returns or else_block_exits:</span>
<span class="gi">+                # Exception: if this node is in the final block of the other_node_statement,</span>
<span class="gi">+                # it will execute before returning. Assume the except statements are uncertain.</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(node_statement.parent, nodes.Try)</span>
<span class="gi">+                    and node_statement in node_statement.parent.finalbody</span>
<span class="gi">+                    and closest_try_except.parent.parent_of(node_statement)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    uncertain_nodes.append(other_node)</span>
<span class="gi">+                # Or the node_statement is in the else block of the relevant Try</span>
<span class="gi">+                elif (</span>
<span class="gi">+                    isinstance(node_statement.parent, nodes.Try)</span>
<span class="gi">+                    and node_statement in node_statement.parent.orelse</span>
<span class="gi">+                    and closest_try_except.parent.parent_of(node_statement)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    uncertain_nodes.append(other_node)</span>
<span class="gi">+                # Assume the except blocks execute, so long as each handler</span>
<span class="gi">+                # defines the name, raises, or returns.</span>
<span class="gi">+                elif all(</span>
<span class="gi">+                    NamesConsumer._defines_name_raises_or_returns_recursive(</span>
<span class="gi">+                        node.name, handler</span>
<span class="gi">+                    )</span>
<span class="gi">+                    for handler in closest_try_except.handlers</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            if NamesConsumer._check_loop_finishes_via_except(node, closest_try_except):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Passed all tests for uncertain execution</span>
<span class="gi">+            uncertain_nodes.append(other_node)</span>
<span class="gi">+        return uncertain_nodes</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _defines_name_raises_or_returns(name: str, node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        if isinstance(node, (nodes.Raise, nodes.Assert, nodes.Return, nodes.Continue)):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(node, nodes.Expr) and isinstance(node.value, nodes.Call):</span>
<span class="gi">+            if utils.is_terminating_func(node.value):</span>
<span class="gi">+                return True</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(node.value.func, nodes.Name)</span>
<span class="gi">+                and node.value.func.name == &quot;assert_never&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, nodes.AnnAssign)</span>
<span class="gi">+            and node.value</span>
<span class="gi">+            and isinstance(node.target, nodes.AssignName)</span>
<span class="gi">+            and node.target.name == name</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(node, nodes.Assign):</span>
<span class="gi">+            for target in node.targets:</span>
<span class="gi">+                for elt in utils.get_all_elements(target):</span>
<span class="gi">+                    if isinstance(elt, nodes.Starred):</span>
<span class="gi">+                        elt = elt.value</span>
<span class="gi">+                    if isinstance(elt, nodes.AssignName) and elt.name == name:</span>
<span class="gi">+                        return True</span>
<span class="gi">+        if isinstance(node, nodes.If):</span>
<span class="gi">+            if any(</span>
<span class="gi">+                child_named_expr.target.name == name</span>
<span class="gi">+                for child_named_expr in node.nodes_of_class(nodes.NamedExpr)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+        if isinstance(node, (nodes.Import, nodes.ImportFrom)) and any(</span>
<span class="gi">+            (node_name[1] and node_name[1] == name) or (node_name[0] == name)</span>
<span class="gi">+            for node_name in node.names</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(node, nodes.With) and any(</span>
<span class="gi">+            isinstance(item[1], nodes.AssignName) and item[1].name == name</span>
<span class="gi">+            for item in node.items</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(node, (nodes.ClassDef, nodes.FunctionDef)) and node.name == name:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, nodes.ExceptHandler)</span>
<span class="gi">+            and node.name</span>
<span class="gi">+            and node.name.name == name</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _defines_name_raises_or_returns_recursive(name: str, node: nodes.NodeNG</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def _defines_name_raises_or_returns_recursive(</span>
<span class="gi">+        name: str, node: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if some child of `node` defines the name `name`,
<span class="w"> </span>        raises, or returns.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for stmt in node.get_children():</span>
<span class="gi">+            if NamesConsumer._defines_name_raises_or_returns(name, stmt):</span>
<span class="gi">+                return True</span>
<span class="gi">+            if isinstance(stmt, (nodes.If, nodes.With)):</span>
<span class="gi">+                if any(</span>
<span class="gi">+                    NamesConsumer._defines_name_raises_or_returns(name, nested_stmt)</span>
<span class="gi">+                    for nested_stmt in stmt.get_children()</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return True</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(stmt, nodes.Try)</span>
<span class="gi">+                and not stmt.finalbody</span>
<span class="gi">+                and NamesConsumer._defines_name_raises_or_returns_recursive(name, stmt)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _check_loop_finishes_via_except(node: nodes.NodeNG,</span>
<span class="gd">-        other_node_try_except: nodes.Try) -&gt;bool:</span>
<span class="gi">+    def _check_loop_finishes_via_except(</span>
<span class="gi">+        node: nodes.NodeNG, other_node_try_except: nodes.Try</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for a specific control flow scenario.

<span class="w"> </span>        Described in https://github.com/pylint-dev/pylint/issues/5683.
<span class="gu">@@ -327,28 +1035,187 @@ scope_type : {self._atomic.scope_type}</span>
<span class="w"> </span>        else:
<span class="w"> </span>            print(name)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not other_node_try_except.orelse:</span>
<span class="gi">+            return False</span>
<span class="gi">+        closest_loop: None | (nodes.For | nodes.While) = (</span>
<span class="gi">+            utils.get_node_first_ancestor_of_type(node, (nodes.For, nodes.While))</span>
<span class="gi">+        )</span>
<span class="gi">+        if closest_loop is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not any(</span>
<span class="gi">+            else_statement is node or else_statement.parent_of(node)</span>
<span class="gi">+            for else_statement in closest_loop.orelse</span>
<span class="gi">+        ):</span>
<span class="gi">+            # `node` not guarded by `else`</span>
<span class="gi">+            return False</span>
<span class="gi">+        for inner_else_statement in other_node_try_except.orelse:</span>
<span class="gi">+            if isinstance(inner_else_statement, nodes.Break):</span>
<span class="gi">+                break_stmt = inner_else_statement</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            # No break statement</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        def _try_in_loop_body(</span>
<span class="gi">+            other_node_try_except: nodes.Try, loop: nodes.For | nodes.While</span>
<span class="gi">+        ) -&gt; bool:</span>
<span class="gi">+            &quot;&quot;&quot;Return True if `other_node_try_except` is a descendant of `loop`.&quot;&quot;&quot;</span>
<span class="gi">+            return any(</span>
<span class="gi">+                loop_body_statement is other_node_try_except</span>
<span class="gi">+                or loop_body_statement.parent_of(other_node_try_except)</span>
<span class="gi">+                for loop_body_statement in loop.body</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not _try_in_loop_body(other_node_try_except, closest_loop):</span>
<span class="gi">+            for ancestor in closest_loop.node_ancestors():</span>
<span class="gi">+                if isinstance(ancestor, (nodes.For, nodes.While)):</span>
<span class="gi">+                    if _try_in_loop_body(other_node_try_except, ancestor):</span>
<span class="gi">+                        break</span>
<span class="gi">+            else:</span>
<span class="gi">+                # `other_node_try_except` didn&#39;t have a shared ancestor loop</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        for loop_stmt in closest_loop.body:</span>
<span class="gi">+            if NamesConsumer._recursive_search_for_continue_before_break(</span>
<span class="gi">+                loop_stmt, break_stmt</span>
<span class="gi">+            ):</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            # No continue found, so we arrived at our special case!</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _recursive_search_for_continue_before_break(stmt: _base_nodes.</span>
<span class="gd">-        Statement, break_stmt: nodes.Break) -&gt;bool:</span>
<span class="gi">+    def _recursive_search_for_continue_before_break(</span>
<span class="gi">+        stmt: _base_nodes.Statement, break_stmt: nodes.Break</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if any Continue node can be found in descendants of `stmt`
<span class="w"> </span>        before encountering `break_stmt`, ignoring any nested loops.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if stmt is break_stmt:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if isinstance(stmt, nodes.Continue):</span>
<span class="gi">+            return True</span>
<span class="gi">+        for child in stmt.get_children():</span>
<span class="gi">+            if isinstance(stmt, (nodes.For, nodes.While)):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if NamesConsumer._recursive_search_for_continue_before_break(</span>
<span class="gi">+                child, break_stmt</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _uncertain_nodes_in_try_blocks_when_evaluating_except_blocks(
<span class="w"> </span>        found_nodes: list[nodes.NodeNG], node_statement: _base_nodes.Statement
<span class="gd">-        ) -&gt;list[nodes.NodeNG]:</span>
<span class="gi">+    ) -&gt; list[nodes.NodeNG]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return any nodes in ``found_nodes`` that should be treated as uncertain.

<span class="w"> </span>        Nodes are uncertain when they are in a try block and the ``node_statement``
<span class="w"> </span>        being evaluated is in one of its except handlers.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        uncertain_nodes: list[nodes.NodeNG] = []</span>
<span class="gi">+        closest_except_handler = utils.get_node_first_ancestor_of_type(</span>
<span class="gi">+            node_statement, nodes.ExceptHandler</span>
<span class="gi">+        )</span>
<span class="gi">+        if closest_except_handler is None:</span>
<span class="gi">+            return uncertain_nodes</span>
<span class="gi">+        for other_node in found_nodes:</span>
<span class="gi">+            other_node_statement = other_node.statement()</span>
<span class="gi">+            # If the other statement is the except handler guarding `node`, it executes</span>
<span class="gi">+            if other_node_statement is closest_except_handler:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Ensure other_node is in a try block</span>
<span class="gi">+            (</span>
<span class="gi">+                other_node_try_ancestor,</span>
<span class="gi">+                other_node_try_ancestor_visited_child,</span>
<span class="gi">+            ) = utils.get_node_first_ancestor_of_type_and_its_child(</span>
<span class="gi">+                other_node_statement, nodes.Try</span>
<span class="gi">+            )</span>
<span class="gi">+            if other_node_try_ancestor is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if (</span>
<span class="gi">+                other_node_try_ancestor_visited_child</span>
<span class="gi">+                not in other_node_try_ancestor.body</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Make sure nesting is correct -- there should be at least one</span>
<span class="gi">+            # except handler that is a sibling attached to the try ancestor,</span>
<span class="gi">+            # or is an ancestor of the try ancestor.</span>
<span class="gi">+            if not any(</span>
<span class="gi">+                closest_except_handler in other_node_try_ancestor.handlers</span>
<span class="gi">+                or other_node_try_ancestor_except_handler</span>
<span class="gi">+                in closest_except_handler.node_ancestors()</span>
<span class="gi">+                for other_node_try_ancestor_except_handler in other_node_try_ancestor.handlers</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Passed all tests for uncertain execution</span>
<span class="gi">+            uncertain_nodes.append(other_node)</span>
<span class="gi">+        return uncertain_nodes</span>

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _uncertain_nodes_in_try_blocks_when_evaluating_finally_blocks(</span>
<span class="gi">+        found_nodes: list[nodes.NodeNG],</span>
<span class="gi">+        node_statement: _base_nodes.Statement,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+    ) -&gt; list[nodes.NodeNG]:</span>
<span class="gi">+        uncertain_nodes: list[nodes.NodeNG] = []</span>
<span class="gi">+        (</span>
<span class="gi">+            closest_try_finally_ancestor,</span>
<span class="gi">+            child_of_closest_try_finally_ancestor,</span>
<span class="gi">+        ) = utils.get_node_first_ancestor_of_type_and_its_child(</span>
<span class="gi">+            node_statement, nodes.Try</span>
<span class="gi">+        )</span>
<span class="gi">+        if closest_try_finally_ancestor is None:</span>
<span class="gi">+            return uncertain_nodes</span>
<span class="gi">+        if (</span>
<span class="gi">+            child_of_closest_try_finally_ancestor</span>
<span class="gi">+            not in closest_try_finally_ancestor.finalbody</span>
<span class="gi">+        ):</span>
<span class="gi">+            return uncertain_nodes</span>
<span class="gi">+        for other_node in found_nodes:</span>
<span class="gi">+            other_node_statement = other_node.statement()</span>
<span class="gi">+            (</span>
<span class="gi">+                other_node_try_finally_ancestor,</span>
<span class="gi">+                child_of_other_node_try_finally_ancestor,</span>
<span class="gi">+            ) = utils.get_node_first_ancestor_of_type_and_its_child(</span>
<span class="gi">+                other_node_statement, nodes.Try</span>
<span class="gi">+            )</span>
<span class="gi">+            if other_node_try_finally_ancestor is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # other_node needs to descend from the try of a try/finally.</span>
<span class="gi">+            if (</span>
<span class="gi">+                child_of_other_node_try_finally_ancestor</span>
<span class="gi">+                not in other_node_try_finally_ancestor.body</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            # If the two try/finally ancestors are not the same, then</span>
<span class="gi">+            # node_statement&#39;s closest try/finally ancestor needs to be in</span>
<span class="gi">+            # the final body of other_node&#39;s try/finally ancestor, or</span>
<span class="gi">+            # descend from one of the statements in that final body.</span>
<span class="gi">+            if (</span>
<span class="gi">+                other_node_try_finally_ancestor is not closest_try_finally_ancestor</span>
<span class="gi">+                and not any(</span>
<span class="gi">+                    other_node_final_statement is closest_try_finally_ancestor</span>
<span class="gi">+                    or other_node_final_statement.parent_of(</span>
<span class="gi">+                        closest_try_finally_ancestor</span>
<span class="gi">+                    )</span>
<span class="gi">+                    for other_node_final_statement in other_node_try_finally_ancestor.finalbody</span>
<span class="gi">+                )</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Is the name defined in all exception clauses?</span>
<span class="gi">+            if other_node_try_finally_ancestor.handlers and all(</span>
<span class="gi">+                NamesConsumer._defines_name_raises_or_returns_recursive(name, handler)</span>
<span class="gi">+                for handler in other_node_try_finally_ancestor.handlers</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Passed all tests for uncertain execution</span>
<span class="gi">+            uncertain_nodes.append(other_node)</span>
<span class="gi">+        return uncertain_nodes</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=too-many-public-methods</span>
<span class="w"> </span>class VariablesChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;BaseChecker for variables.

<span class="gu">@@ -360,221 +1227,1305 @@ class VariablesChecker(BaseChecker):</span>
<span class="w"> </span>    * __all__ consistency
<span class="w"> </span>    * self/cls assignment
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;variables&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;variables&quot;</span>
<span class="w"> </span>    msgs = MSGS
<span class="gd">-    options = (&#39;init-import&#39;, {&#39;default&#39;: False, &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Tells whether we should check for unused import in __init__ files.&#39;}</span>
<span class="gd">-        ), (&#39;dummy-variables-rgx&#39;, {&#39;default&#39;:</span>
<span class="gd">-        &#39;_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_&#39;,</span>
<span class="gd">-        &#39;type&#39;: &#39;regexp&#39;, &#39;metavar&#39;: &#39;&lt;regexp&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;A regular expression matching the name of dummy variables (i.e. expected to not be used).&#39;</span>
<span class="gd">-        }), (&#39;additional-builtins&#39;, {&#39;default&#39;: (), &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;comma separated list&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of additional names supposed to be defined in builtins. Remember that you should avoid defining new builtins when possible.&#39;</span>
<span class="gd">-        }), (&#39;callbacks&#39;, {&#39;default&#39;: (&#39;cb_&#39;, &#39;_cb&#39;), &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;callbacks&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of strings which can identify a callback function by name. A callback name must start or end with one of those strings.&#39;</span>
<span class="gd">-        }), (&#39;redefining-builtins-modules&#39;, {&#39;default&#39;: (&#39;six.moves&#39;,</span>
<span class="gd">-        &#39;past.builtins&#39;, &#39;future.builtins&#39;, &#39;builtins&#39;, &#39;io&#39;), &#39;type&#39;:</span>
<span class="gd">-        &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;comma separated list&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of qualified module names which can have objects that can redefine builtins.&#39;</span>
<span class="gd">-        }), (&#39;ignored-argument-names&#39;, {&#39;default&#39;: IGNORED_ARGUMENT_NAMES,</span>
<span class="gd">-        &#39;type&#39;: &#39;regexp&#39;, &#39;metavar&#39;: &#39;&lt;regexp&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Argument names that match this expression will be ignored.&#39;}), (</span>
<span class="gd">-        &#39;allow-global-unused-variables&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Tells whether unused global variables should be treated as a violation.&#39;</span>
<span class="gd">-        }), (&#39;allowed-redefined-builtins&#39;, {&#39;default&#39;: (), &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;comma separated list&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of names allowed to shadow builtins&#39;})</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;init-import&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Tells whether we should check for unused import in &quot;</span>
<span class="gi">+                &quot;__init__ files.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;dummy-variables-rgx&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;regexp&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;A regular expression matching the name of dummy &quot;</span>
<span class="gi">+                &quot;variables (i.e. expected to not be used).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;additional-builtins&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma separated list&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of additional names supposed to be defined in &quot;</span>
<span class="gi">+                &quot;builtins. Remember that you should avoid defining new builtins &quot;</span>
<span class="gi">+                &quot;when possible.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;callbacks&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (&quot;cb_&quot;, &quot;_cb&quot;),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;callbacks&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of strings which can identify a callback &quot;</span>
<span class="gi">+                &quot;function by name. A callback name must start or &quot;</span>
<span class="gi">+                &quot;end with one of those strings.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;redefining-builtins-modules&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (</span>
<span class="gi">+                    &quot;six.moves&quot;,</span>
<span class="gi">+                    &quot;past.builtins&quot;,</span>
<span class="gi">+                    &quot;future.builtins&quot;,</span>
<span class="gi">+                    &quot;builtins&quot;,</span>
<span class="gi">+                    &quot;io&quot;,</span>
<span class="gi">+                ),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma separated list&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of qualified module names which can have objects &quot;</span>
<span class="gi">+                &quot;that can redefine builtins.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignored-argument-names&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: IGNORED_ARGUMENT_NAMES,</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;regexp&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Argument names that match this expression will be ignored.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;allow-global-unused-variables&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Tells whether unused global variables should be treated as a violation.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;allowed-redefined-builtins&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma separated list&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of names allowed to shadow builtins&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="w"> </span>        self._to_consume: list[NamesConsumer] = []
<span class="w"> </span>        self._type_annotation_names: list[str] = []
<span class="gd">-        self._except_handler_names_queue: list[tuple[nodes.ExceptHandler,</span>
<span class="gd">-            nodes.AssignName]] = []</span>
<span class="gi">+        self._except_handler_names_queue: list[</span>
<span class="gi">+            tuple[nodes.ExceptHandler, nodes.AssignName]</span>
<span class="gi">+        ] = []</span>
<span class="w"> </span>        &quot;&quot;&quot;This is a queue, last in first out.&quot;&quot;&quot;
<span class="gd">-        self._evaluated_type_checking_scopes: dict[str, list[nodes.</span>
<span class="gd">-            LocalsDictNodeNG]] = {}</span>
<span class="gi">+        self._evaluated_type_checking_scopes: dict[</span>
<span class="gi">+            str, list[nodes.LocalsDictNodeNG]</span>
<span class="gi">+        ] = {}</span>
<span class="w"> </span>        self._postponed_evaluation_enabled = False

<span class="gd">-    def visit_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;unbalanced-dict-unpacking&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.target, nodes.Tuple):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        targets = node.target.elts</span>
<span class="gi">+</span>
<span class="gi">+        inferred = utils.safe_infer(node.iter)</span>
<span class="gi">+        if not isinstance(inferred, DICT_TYPES):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        values = self._nodes_to_unpack(inferred)</span>
<span class="gi">+        if not values:</span>
<span class="gi">+            # no dict items returned</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(inferred, astroid.objects.DictItems):</span>
<span class="gi">+            # dict.items() is a bit special because values will be a tuple</span>
<span class="gi">+            # So as long as there are always 2 targets and values each are</span>
<span class="gi">+            # a tuple with two items, this will unpack correctly.</span>
<span class="gi">+            # Example: `for key, val in {1: 2, 3: 4}.items()`</span>
<span class="gi">+            if len(targets) == 2 and all(len(x.elts) == 2 for x in values):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Starred nodes indicate ambiguous unpacking</span>
<span class="gi">+            # if `dict.items()` is used so we won&#39;t flag them.</span>
<span class="gi">+            if any(isinstance(target, nodes.Starred) for target in targets):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(inferred, nodes.Dict):</span>
<span class="gi">+            if isinstance(node.iter, nodes.Name):</span>
<span class="gi">+                # If this a case of &#39;dict-items-missing-iter&#39;, we don&#39;t want to</span>
<span class="gi">+                # report it as an &#39;unbalanced-dict-unpacking&#39; as well</span>
<span class="gi">+                # TODO (performance), merging both checks would streamline this</span>
<span class="gi">+                if len(targets) == 2:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            is_starred_targets = any(</span>
<span class="gi">+                isinstance(target, nodes.Starred) for target in targets</span>
<span class="gi">+            )</span>
<span class="gi">+            for value in values:</span>
<span class="gi">+                value_length = self._get_value_length(value)</span>
<span class="gi">+                is_valid_star_unpack = is_starred_targets and value_length &gt;= len(</span>
<span class="gi">+                    targets</span>
<span class="gi">+                )</span>
<span class="gi">+                if len(targets) != value_length and not is_valid_star_unpack:</span>
<span class="gi">+                    details = _get_unpacking_extra_info(node, inferred)</span>
<span class="gi">+                    self._report_unbalanced_unpacking(</span>
<span class="gi">+                        node, inferred, targets, value_length, details</span>
<span class="gi">+                    )</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+    def leave_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        self._store_type_annotation_names(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit module : update consumption analysis variable
<span class="w"> </span>        checks globals doesn&#39;t overrides builtins.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;unused-import&#39;,</span>
<span class="gd">-        &#39;unused-wildcard-import&#39;, &#39;redefined-builtin&#39;,</span>
<span class="gd">-        &#39;undefined-all-variable&#39;, &#39;invalid-all-object&#39;,</span>
<span class="gd">-        &#39;invalid-all-format&#39;, &#39;unused-variable&#39;, &#39;undefined-variable&#39;)</span>
<span class="gd">-    def leave_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+        self._to_consume = [NamesConsumer(node, &quot;module&quot;)]</span>
<span class="gi">+        self._postponed_evaluation_enabled = is_postponed_evaluation_enabled(node)</span>
<span class="gi">+</span>
<span class="gi">+        for name, stmts in node.locals.items():</span>
<span class="gi">+            if utils.is_builtin(name):</span>
<span class="gi">+                if self._should_ignore_redefined_builtin(stmts[0]) or name == &quot;__doc__&quot;:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.add_message(&quot;redefined-builtin&quot;, args=name, node=stmts[0])</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;unused-import&quot;,</span>
<span class="gi">+        &quot;unused-wildcard-import&quot;,</span>
<span class="gi">+        &quot;redefined-builtin&quot;,</span>
<span class="gi">+        &quot;undefined-all-variable&quot;,</span>
<span class="gi">+        &quot;invalid-all-object&quot;,</span>
<span class="gi">+        &quot;invalid-all-format&quot;,</span>
<span class="gi">+        &quot;unused-variable&quot;,</span>
<span class="gi">+        &quot;undefined-variable&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def leave_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Leave module: check globals.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert len(self._to_consume) == 1</span>
<span class="gi">+</span>
<span class="gi">+        self._check_metaclasses(node)</span>
<span class="gi">+        not_consumed = self._to_consume.pop().to_consume</span>
<span class="gi">+        # attempt to check for __all__ if defined</span>
<span class="gi">+        if &quot;__all__&quot; in node.locals:</span>
<span class="gi">+            self._check_all(node, not_consumed)</span>
<span class="gi">+</span>
<span class="gi">+        # check for unused globals</span>
<span class="gi">+        self._check_globals(not_consumed)</span>
<span class="gi">+</span>
<span class="gi">+        # don&#39;t check unused imports in __init__ files</span>
<span class="gi">+        if not self.linter.config.init_import and node.package:</span>
<span class="gi">+            return</span>

<span class="gd">-    def visit_classdef(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+        self._check_imports(not_consumed)</span>
<span class="gi">+        self._type_annotation_names = []</span>
<span class="gi">+</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit class: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._to_consume.append(NamesConsumer(node, &quot;class&quot;))</span>

<span class="gd">-    def leave_classdef(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    def leave_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Leave class: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_lambda(self, node: nodes.Lambda) -&gt;None:</span>
<span class="gi">+        # Check for hidden ancestor names</span>
<span class="gi">+        # e.g. &quot;six&quot; in: Class X(six.with_metaclass(ABCMeta, object)):</span>
<span class="gi">+        for name_node in node.nodes_of_class(nodes.Name):</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(name_node.parent, nodes.Call)</span>
<span class="gi">+                and isinstance(name_node.parent.func, nodes.Attribute)</span>
<span class="gi">+                and isinstance(name_node.parent.func.expr, nodes.Name)</span>
<span class="gi">+            ):</span>
<span class="gi">+                hidden_name_node = name_node.parent.func.expr</span>
<span class="gi">+                for consumer in self._to_consume:</span>
<span class="gi">+                    if hidden_name_node.name in consumer.to_consume:</span>
<span class="gi">+                        consumer.mark_as_consumed(</span>
<span class="gi">+                            hidden_name_node.name,</span>
<span class="gi">+                            consumer.to_consume[hidden_name_node.name],</span>
<span class="gi">+                        )</span>
<span class="gi">+                        break</span>
<span class="gi">+        self._to_consume.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_lambda(self, node: nodes.Lambda) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit lambda: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._to_consume.append(NamesConsumer(node, &quot;lambda&quot;))</span>

<span class="gd">-    def leave_lambda(self, _: nodes.Lambda) -&gt;None:</span>
<span class="gi">+    def leave_lambda(self, _: nodes.Lambda) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Leave lambda: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # do not check for not used locals here</span>
<span class="gi">+        self._to_consume.pop()</span>

<span class="gd">-    def visit_generatorexp(self, node: nodes.GeneratorExp) -&gt;None:</span>
<span class="gi">+    def visit_generatorexp(self, node: nodes.GeneratorExp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit genexpr: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._to_consume.append(NamesConsumer(node, &quot;comprehension&quot;))</span>

<span class="gd">-    def leave_generatorexp(self, _: nodes.GeneratorExp) -&gt;None:</span>
<span class="gi">+    def leave_generatorexp(self, _: nodes.GeneratorExp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Leave genexpr: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # do not check for not used locals here</span>
<span class="gi">+        self._to_consume.pop()</span>

<span class="gd">-    def visit_dictcomp(self, node: nodes.DictComp) -&gt;None:</span>
<span class="gi">+    def visit_dictcomp(self, node: nodes.DictComp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit dictcomp: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._to_consume.append(NamesConsumer(node, &quot;comprehension&quot;))</span>

<span class="gd">-    def leave_dictcomp(self, _: nodes.DictComp) -&gt;None:</span>
<span class="gi">+    def leave_dictcomp(self, _: nodes.DictComp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Leave dictcomp: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # do not check for not used locals here</span>
<span class="gi">+        self._to_consume.pop()</span>

<span class="gd">-    def visit_setcomp(self, node: nodes.SetComp) -&gt;None:</span>
<span class="gi">+    def visit_setcomp(self, node: nodes.SetComp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit setcomp: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._to_consume.append(NamesConsumer(node, &quot;comprehension&quot;))</span>

<span class="gd">-    def leave_setcomp(self, _: nodes.SetComp) -&gt;None:</span>
<span class="gi">+    def leave_setcomp(self, _: nodes.SetComp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Leave setcomp: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # do not check for not used locals here</span>
<span class="gi">+        self._to_consume.pop()</span>

<span class="gd">-    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit function: update consumption analysis variable and check locals.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def leave_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+        self._to_consume.append(NamesConsumer(node, &quot;function&quot;))</span>
<span class="gi">+        if not (</span>
<span class="gi">+            self.linter.is_message_enabled(&quot;redefined-outer-name&quot;)</span>
<span class="gi">+            or self.linter.is_message_enabled(&quot;redefined-builtin&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        globs = node.root().globals</span>
<span class="gi">+        for name, stmt in node.items():</span>
<span class="gi">+            if name in globs and not isinstance(stmt, nodes.Global):</span>
<span class="gi">+                definition = globs[name][0]</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(definition, nodes.ImportFrom)</span>
<span class="gi">+                    and definition.modname == FUTURE</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # It is a __future__ directive, not a symbol.</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # Do not take in account redefined names for the purpose</span>
<span class="gi">+                # of type checking.:</span>
<span class="gi">+                if any(</span>
<span class="gi">+                    in_type_checking_block(definition) for definition in globs[name]</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # Suppress emitting the message if the outer name is in the</span>
<span class="gi">+                # scope of an exception assignment.</span>
<span class="gi">+                # For example: the `e` in `except ValueError as e`</span>
<span class="gi">+                global_node = globs[name][0]</span>
<span class="gi">+                if isinstance(global_node, nodes.AssignName) and isinstance(</span>
<span class="gi">+                    global_node.parent, nodes.ExceptHandler</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                line = definition.fromlineno</span>
<span class="gi">+                if not self._is_name_ignored(stmt, name):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;redefined-outer-name&quot;, args=(name, line), node=stmt</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            elif (</span>
<span class="gi">+                utils.is_builtin(name)</span>
<span class="gi">+                and not self._allowed_redefined_builtin(name)</span>
<span class="gi">+                and not self._should_ignore_redefined_builtin(stmt)</span>
<span class="gi">+            ):</span>
<span class="gi">+                # do not print Redefining builtin for additional builtins</span>
<span class="gi">+                self.add_message(&quot;redefined-builtin&quot;, args=name, node=stmt)</span>
<span class="gi">+</span>
<span class="gi">+    def leave_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Leave function: check function&#39;s locals are consumed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_metaclasses(node)</span>
<span class="gi">+</span>
<span class="gi">+        if node.type_comment_returns:</span>
<span class="gi">+            self._store_type_annotation_node(node.type_comment_returns)</span>
<span class="gi">+        if node.type_comment_args:</span>
<span class="gi">+            for argument_annotation in node.type_comment_args:</span>
<span class="gi">+                self._store_type_annotation_node(argument_annotation)</span>
<span class="gi">+</span>
<span class="gi">+        not_consumed = self._to_consume.pop().to_consume</span>
<span class="gi">+        if not (</span>
<span class="gi">+            self.linter.is_message_enabled(&quot;unused-variable&quot;)</span>
<span class="gi">+            or self.linter.is_message_enabled(&quot;possibly-unused-variable&quot;)</span>
<span class="gi">+            or self.linter.is_message_enabled(&quot;unused-argument&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t check arguments of function which are only raising an exception.</span>
<span class="gi">+        if utils.is_error(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t check arguments of abstract methods or within an interface.</span>
<span class="gi">+        is_method = node.is_method()</span>
<span class="gi">+        if is_method and node.is_abstract():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        global_names = _flattened_scope_names(node.nodes_of_class(nodes.Global))</span>
<span class="gi">+        nonlocal_names = _flattened_scope_names(node.nodes_of_class(nodes.Nonlocal))</span>
<span class="gi">+        comprehension_target_names: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        for comprehension_scope in node.nodes_of_class(nodes.ComprehensionScope):</span>
<span class="gi">+            for generator in comprehension_scope.generators:</span>
<span class="gi">+                for name in utils.find_assigned_names_recursive(generator.target):</span>
<span class="gi">+                    comprehension_target_names.add(name)</span>
<span class="gi">+</span>
<span class="gi">+        for name, stmts in not_consumed.items():</span>
<span class="gi">+            self._check_is_unused(</span>
<span class="gi">+                name,</span>
<span class="gi">+                node,</span>
<span class="gi">+                stmts[0],</span>
<span class="gi">+                global_names,</span>
<span class="gi">+                nonlocal_names,</span>
<span class="gi">+                comprehension_target_names,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef
<span class="w"> </span>    leave_asyncfunctiondef = leave_functiondef

<span class="gd">-    @utils.only_required_for_messages(&#39;global-variable-undefined&#39;,</span>
<span class="gd">-        &#39;global-variable-not-assigned&#39;, &#39;global-statement&#39;,</span>
<span class="gd">-        &#39;global-at-module-level&#39;, &#39;redefined-builtin&#39;)</span>
<span class="gd">-    def visit_global(self, node: nodes.Global) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;global-variable-undefined&quot;,</span>
<span class="gi">+        &quot;global-variable-not-assigned&quot;,</span>
<span class="gi">+        &quot;global-statement&quot;,</span>
<span class="gi">+        &quot;global-at-module-level&quot;,</span>
<span class="gi">+        &quot;redefined-builtin&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_global(self, node: nodes.Global) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check names imported exists in the global scope.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_name(self, node: (nodes.Name | nodes.AssignName | nodes.DelName)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        frame = node.frame()</span>
<span class="gi">+        if isinstance(frame, nodes.Module):</span>
<span class="gi">+            self.add_message(&quot;global-at-module-level&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        module = frame.root()</span>
<span class="gi">+        default_message = True</span>
<span class="gi">+        locals_ = node.scope().locals</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            try:</span>
<span class="gi">+                assign_nodes = module.getattr(name)</span>
<span class="gi">+            except astroid.NotFoundError:</span>
<span class="gi">+                # unassigned global, skip</span>
<span class="gi">+                assign_nodes = []</span>
<span class="gi">+</span>
<span class="gi">+            not_defined_locally_by_import = not any(</span>
<span class="gi">+                isinstance(local, (nodes.Import, nodes.ImportFrom))</span>
<span class="gi">+                for local in locals_.get(name, ())</span>
<span class="gi">+            )</span>
<span class="gi">+            if (</span>
<span class="gi">+                not utils.is_reassigned_after_current(node, name)</span>
<span class="gi">+                and not utils.is_deleted_after_current(node, name)</span>
<span class="gi">+                and not_defined_locally_by_import</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;global-variable-not-assigned&quot;,</span>
<span class="gi">+                    args=name,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+                default_message = False</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            for anode in assign_nodes:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(anode, nodes.AssignName)</span>
<span class="gi">+                    and anode.name in module.special_attributes</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(&quot;redefined-builtin&quot;, args=name, node=node)</span>
<span class="gi">+                    break</span>
<span class="gi">+                if anode.frame() is module:</span>
<span class="gi">+                    # module level assignment</span>
<span class="gi">+                    break</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(anode, (nodes.ClassDef, nodes.FunctionDef))</span>
<span class="gi">+                    and anode.parent is module</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # module level function assignment</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not_defined_locally_by_import:</span>
<span class="gi">+                    # global undefined at the module scope</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;global-variable-undefined&quot;,</span>
<span class="gi">+                        args=name,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    default_message = False</span>
<span class="gi">+</span>
<span class="gi">+        if default_message:</span>
<span class="gi">+            self.add_message(&quot;global-statement&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_assignname(self, node: nodes.AssignName) -&gt; None:</span>
<span class="gi">+        if isinstance(node.assign_type(), nodes.AugAssign):</span>
<span class="gi">+            self.visit_name(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_delname(self, node: nodes.DelName) -&gt; None:</span>
<span class="gi">+        self.visit_name(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_name(self, node: nodes.Name | nodes.AssignName | nodes.DelName) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Don&#39;t add the &#39;utils.only_required_for_messages&#39; decorator here!

<span class="w"> </span>        It&#39;s important that all &#39;Name&#39; nodes are visited, otherwise the
<span class="w"> </span>        &#39;NamesConsumers&#39; won&#39;t be correct.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stmt = node.statement()</span>
<span class="gi">+        if stmt.fromlineno is None:</span>
<span class="gi">+            # name node from an astroid built from live code, skip</span>
<span class="gi">+            assert not stmt.root().file.endswith(&quot;.py&quot;)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._undefined_and_used_before_checker(node, stmt)</span>
<span class="gi">+        self._loopvar_name(node)</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;redefined-outer-name&quot;)</span>
<span class="gi">+    def visit_excepthandler(self, node: nodes.ExceptHandler) -&gt; None:</span>
<span class="gi">+        if not node.name or not isinstance(node.name, nodes.AssignName):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for outer_except, outer_except_assign_name in self._except_handler_names_queue:</span>
<span class="gi">+            if node.name.name == outer_except_assign_name.name:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;redefined-outer-name&quot;,</span>
<span class="gi">+                    args=(outer_except_assign_name.name, outer_except.fromlineno),</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>

<span class="gd">-    def _should_node_be_skipped(self, node: nodes.Name, consumer:</span>
<span class="gd">-        NamesConsumer, is_start_index: bool) -&gt;bool:</span>
<span class="gi">+        self._except_handler_names_queue.append((node, node.name))</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;redefined-outer-name&quot;)</span>
<span class="gi">+    def leave_excepthandler(self, node: nodes.ExceptHandler) -&gt; None:</span>
<span class="gi">+        if not node.name or not isinstance(node.name, nodes.AssignName):</span>
<span class="gi">+            return</span>
<span class="gi">+        self._except_handler_names_queue.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def _undefined_and_used_before_checker(</span>
<span class="gi">+        self, node: nodes.Name, stmt: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        frame = stmt.scope()</span>
<span class="gi">+        start_index = len(self._to_consume) - 1</span>
<span class="gi">+</span>
<span class="gi">+        # iterates through parent scopes, from the inner to the outer</span>
<span class="gi">+        base_scope_type = self._to_consume[start_index].scope_type</span>
<span class="gi">+</span>
<span class="gi">+        for i in range(start_index, -1, -1):</span>
<span class="gi">+            current_consumer = self._to_consume[i]</span>
<span class="gi">+</span>
<span class="gi">+            # Certain nodes shouldn&#39;t be checked as they get checked another time</span>
<span class="gi">+            if self._should_node_be_skipped(node, current_consumer, i == start_index):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            action, nodes_to_consume = self._check_consumer(</span>
<span class="gi">+                node, stmt, frame, current_consumer, base_scope_type</span>
<span class="gi">+            )</span>
<span class="gi">+            if nodes_to_consume:</span>
<span class="gi">+                # Any nodes added to consumed_uncertain by get_next_to_consume()</span>
<span class="gi">+                # should be added back so that they are marked as used.</span>
<span class="gi">+                # They will have already had a chance to emit used-before-assignment.</span>
<span class="gi">+                # We check here instead of before every single return in _check_consumer()</span>
<span class="gi">+                nodes_to_consume += current_consumer.consumed_uncertain[node.name]</span>
<span class="gi">+                current_consumer.mark_as_consumed(node.name, nodes_to_consume)</span>
<span class="gi">+            if action is VariableVisitConsumerAction.CONTINUE:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if action is VariableVisitConsumerAction.RETURN:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        # we have not found the name, if it isn&#39;t a builtin, that&#39;s an</span>
<span class="gi">+        # undefined name !</span>
<span class="gi">+        if not (</span>
<span class="gi">+            node.name in nodes.Module.scope_attrs</span>
<span class="gi">+            or utils.is_builtin(node.name)</span>
<span class="gi">+            or node.name in self.linter.config.additional_builtins</span>
<span class="gi">+            or (</span>
<span class="gi">+                node.name == &quot;__class__&quot;</span>
<span class="gi">+                and any(</span>
<span class="gi">+                    i.is_method()</span>
<span class="gi">+                    for i in node.node_ancestors()</span>
<span class="gi">+                    if isinstance(i, nodes.FunctionDef)</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        ) and not utils.node_ignores_exception(node, NameError):</span>
<span class="gi">+            self.add_message(&quot;undefined-variable&quot;, args=node.name, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def _should_node_be_skipped(</span>
<span class="gi">+        self, node: nodes.Name, consumer: NamesConsumer, is_start_index: bool</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Tests a consumer and node for various conditions in which the node shouldn&#39;t
<span class="w"> </span>        be checked for the undefined-variable and used-before-assignment checks.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_consumer(self, node: nodes.Name, stmt: nodes.NodeNG, frame:</span>
<span class="gd">-        nodes.LocalsDictNodeNG, current_consumer: NamesConsumer,</span>
<span class="gd">-        base_scope_type: str) -&gt;tuple[VariableVisitConsumerAction, list[</span>
<span class="gd">-        nodes.NodeNG] | None]:</span>
<span class="gi">+        if consumer.scope_type == &quot;class&quot;:</span>
<span class="gi">+            # The list of base classes in the class definition is not part</span>
<span class="gi">+            # of the class body.</span>
<span class="gi">+            # If the current scope is a class scope but it&#39;s not the inner</span>
<span class="gi">+            # scope, ignore it. This prevents to access this scope instead of</span>
<span class="gi">+            # the globals one in function members when there are some common</span>
<span class="gi">+            # names.</span>
<span class="gi">+            if utils.is_ancestor_name(consumer.node, node) or (</span>
<span class="gi">+                not is_start_index and self._ignore_class_scope(node)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+            # Ignore inner class scope for keywords in class definition</span>
<span class="gi">+            if isinstance(node.parent, nodes.Keyword) and isinstance(</span>
<span class="gi">+                node.parent.parent, nodes.ClassDef</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        elif consumer.scope_type == &quot;function&quot; and self._defined_in_function_definition(</span>
<span class="gi">+            node, consumer.node</span>
<span class="gi">+        ):</span>
<span class="gi">+            if any(node.name == param.name.name for param in consumer.node.type_params):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            # If the name node is used as a function default argument&#39;s value or as</span>
<span class="gi">+            # a decorator, then start from the parent frame of the function instead</span>
<span class="gi">+            # of the function frame - and thus open an inner class scope</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        elif consumer.scope_type == &quot;lambda&quot; and utils.is_default_argument(</span>
<span class="gi">+            node, consumer.node</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-return-statements, too-many-branches</span>
<span class="gi">+    def _check_consumer(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Name,</span>
<span class="gi">+        stmt: nodes.NodeNG,</span>
<span class="gi">+        frame: nodes.LocalsDictNodeNG,</span>
<span class="gi">+        current_consumer: NamesConsumer,</span>
<span class="gi">+        base_scope_type: str,</span>
<span class="gi">+    ) -&gt; tuple[VariableVisitConsumerAction, list[nodes.NodeNG] | None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks a consumer for conditions that should trigger messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _report_unfound_name_definition(self, node: nodes.NodeNG,</span>
<span class="gd">-        current_consumer: NamesConsumer) -&gt;None:</span>
<span class="gi">+        # If the name has already been consumed, only check it&#39;s not a loop</span>
<span class="gi">+        # variable used outside the loop.</span>
<span class="gi">+        if node.name in current_consumer.consumed:</span>
<span class="gi">+            # Avoid the case where there are homonyms inside function scope and</span>
<span class="gi">+            # comprehension current scope (avoid bug #1731)</span>
<span class="gi">+            if utils.is_func_decorator(current_consumer.node) or not isinstance(</span>
<span class="gi">+                node, nodes.ComprehensionScope</span>
<span class="gi">+            ):</span>
<span class="gi">+                self._check_late_binding_closure(node)</span>
<span class="gi">+                return (VariableVisitConsumerAction.RETURN, None)</span>
<span class="gi">+</span>
<span class="gi">+        found_nodes = current_consumer.get_next_to_consume(node)</span>
<span class="gi">+        if found_nodes is None:</span>
<span class="gi">+            return (VariableVisitConsumerAction.CONTINUE, None)</span>
<span class="gi">+        if not found_nodes:</span>
<span class="gi">+            self._report_unfound_name_definition(node, current_consumer)</span>
<span class="gi">+            # Mark for consumption any nodes added to consumed_uncertain by</span>
<span class="gi">+            # get_next_to_consume() because they might not have executed.</span>
<span class="gi">+            nodes_to_consume = current_consumer.consumed_uncertain[node.name]</span>
<span class="gi">+            nodes_to_consume = self._filter_type_checking_import_from_consumption(</span>
<span class="gi">+                node, nodes_to_consume</span>
<span class="gi">+            )</span>
<span class="gi">+            return (</span>
<span class="gi">+                VariableVisitConsumerAction.RETURN,</span>
<span class="gi">+                nodes_to_consume,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        self._check_late_binding_closure(node)</span>
<span class="gi">+</span>
<span class="gi">+        defnode = utils.assign_parent(found_nodes[0])</span>
<span class="gi">+        defstmt = defnode.statement()</span>
<span class="gi">+        defframe = defstmt.frame()</span>
<span class="gi">+</span>
<span class="gi">+        # The class reuses itself in the class scope.</span>
<span class="gi">+        is_recursive_klass: bool = (</span>
<span class="gi">+            frame is defframe</span>
<span class="gi">+            and defframe.parent_of(node)</span>
<span class="gi">+            and isinstance(defframe, nodes.ClassDef)</span>
<span class="gi">+            and node.name == defframe.name</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            is_recursive_klass</span>
<span class="gi">+            and utils.get_node_first_ancestor_of_type(node, nodes.Lambda)</span>
<span class="gi">+            and (</span>
<span class="gi">+                not utils.is_default_argument(node)</span>
<span class="gi">+                or node.scope().parent.scope() is not defframe</span>
<span class="gi">+            )</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Self-referential class references are fine in lambda&#39;s --</span>
<span class="gi">+            # As long as they are not part of the default argument directly</span>
<span class="gi">+            # under the scope of the parent self-referring class.</span>
<span class="gi">+            # Example of valid default argument:</span>
<span class="gi">+            # class MyName3:</span>
<span class="gi">+            #     myattr = 1</span>
<span class="gi">+            #     mylambda3 = lambda: lambda a=MyName3: a</span>
<span class="gi">+            # Example of invalid default argument:</span>
<span class="gi">+            # class MyName4:</span>
<span class="gi">+            #     myattr = 1</span>
<span class="gi">+            #     mylambda4 = lambda a=MyName4: lambda: a</span>
<span class="gi">+</span>
<span class="gi">+            # If the above conditional is True,</span>
<span class="gi">+            # there is no possibility of undefined-variable</span>
<span class="gi">+            # Also do not consume class name</span>
<span class="gi">+            # (since consuming blocks subsequent checks)</span>
<span class="gi">+            # -- quit</span>
<span class="gi">+            return (VariableVisitConsumerAction.RETURN, None)</span>
<span class="gi">+</span>
<span class="gi">+        (</span>
<span class="gi">+            maybe_before_assign,</span>
<span class="gi">+            annotation_return,</span>
<span class="gi">+            use_outer_definition,</span>
<span class="gi">+        ) = self._is_variable_violation(</span>
<span class="gi">+            node,</span>
<span class="gi">+            defnode,</span>
<span class="gi">+            stmt,</span>
<span class="gi">+            defstmt,</span>
<span class="gi">+            frame,</span>
<span class="gi">+            defframe,</span>
<span class="gi">+            base_scope_type,</span>
<span class="gi">+            is_recursive_klass,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if use_outer_definition:</span>
<span class="gi">+            return (VariableVisitConsumerAction.CONTINUE, None)</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            maybe_before_assign</span>
<span class="gi">+            and not utils.is_defined_before(node)</span>
<span class="gi">+            and not astroid.are_exclusive(stmt, defstmt, (&quot;NameError&quot;,))</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Used and defined in the same place, e.g `x += 1` and `del x`</span>
<span class="gi">+            defined_by_stmt = defstmt is stmt and isinstance(</span>
<span class="gi">+                node, (nodes.DelName, nodes.AssignName)</span>
<span class="gi">+            )</span>
<span class="gi">+            if (</span>
<span class="gi">+                is_recursive_klass</span>
<span class="gi">+                or defined_by_stmt</span>
<span class="gi">+                or annotation_return</span>
<span class="gi">+                or isinstance(defstmt, nodes.Delete)</span>
<span class="gi">+            ):</span>
<span class="gi">+                if not utils.node_ignores_exception(node, NameError):</span>
<span class="gi">+                    # Handle postponed evaluation of annotations</span>
<span class="gi">+                    if not (</span>
<span class="gi">+                        self._postponed_evaluation_enabled</span>
<span class="gi">+                        and isinstance(</span>
<span class="gi">+                            stmt,</span>
<span class="gi">+                            (</span>
<span class="gi">+                                nodes.AnnAssign,</span>
<span class="gi">+                                nodes.FunctionDef,</span>
<span class="gi">+                                nodes.Arguments,</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        )</span>
<span class="gi">+                        and node.name in node.root().locals</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        if defined_by_stmt:</span>
<span class="gi">+                            return (VariableVisitConsumerAction.CONTINUE, [node])</span>
<span class="gi">+                        return (VariableVisitConsumerAction.CONTINUE, None)</span>
<span class="gi">+</span>
<span class="gi">+            elif base_scope_type != &quot;lambda&quot;:</span>
<span class="gi">+                # E0601 may *not* occurs in lambda scope.</span>
<span class="gi">+</span>
<span class="gi">+                # Skip postponed evaluation of annotations</span>
<span class="gi">+                # and unevaluated annotations inside a function body</span>
<span class="gi">+                if not (</span>
<span class="gi">+                    self._postponed_evaluation_enabled</span>
<span class="gi">+                    and isinstance(stmt, (nodes.AnnAssign, nodes.FunctionDef))</span>
<span class="gi">+                ) and not (</span>
<span class="gi">+                    isinstance(stmt, nodes.AnnAssign)</span>
<span class="gi">+                    and utils.get_node_first_ancestor_of_type(stmt, nodes.FunctionDef)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;used-before-assignment&quot;,</span>
<span class="gi">+                        args=node.name,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    return (VariableVisitConsumerAction.RETURN, found_nodes)</span>
<span class="gi">+</span>
<span class="gi">+            elif base_scope_type == &quot;lambda&quot;:</span>
<span class="gi">+                # E0601 can occur in class-level scope in lambdas, as in</span>
<span class="gi">+                # the following example:</span>
<span class="gi">+                #   class A:</span>
<span class="gi">+                #      x = lambda attr: f + attr</span>
<span class="gi">+                #      f = 42</span>
<span class="gi">+                # We check lineno because doing the following is fine:</span>
<span class="gi">+                #   class A:</span>
<span class="gi">+                #      x = 42</span>
<span class="gi">+                #      y = lambda attr: x + attr</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(frame, nodes.ClassDef)</span>
<span class="gi">+                    and node.name in frame.locals</span>
<span class="gi">+                    and stmt.fromlineno &lt;= defstmt.fromlineno</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;used-before-assignment&quot;,</span>
<span class="gi">+                        args=node.name,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+        elif not self._is_builtin(node.name) and self._is_only_type_assignment(</span>
<span class="gi">+            node, defstmt</span>
<span class="gi">+        ):</span>
<span class="gi">+            if node.scope().locals.get(node.name):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;used-before-assignment&quot;, args=node.name, node=node, confidence=HIGH</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;undefined-variable&quot;, args=node.name, node=node, confidence=HIGH</span>
<span class="gi">+                )</span>
<span class="gi">+            return (VariableVisitConsumerAction.RETURN, found_nodes)</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(defstmt, nodes.ClassDef):</span>
<span class="gi">+            return self._is_first_level_self_reference(node, defstmt, found_nodes)</span>
<span class="gi">+</span>
<span class="gi">+        elif isinstance(defnode, nodes.NamedExpr):</span>
<span class="gi">+            if isinstance(defnode.parent, nodes.IfExp):</span>
<span class="gi">+                if self._is_never_evaluated(defnode, defnode.parent):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;undefined-variable&quot;,</span>
<span class="gi">+                        args=node.name,</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        confidence=INFERENCE,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    return (VariableVisitConsumerAction.RETURN, found_nodes)</span>
<span class="gi">+</span>
<span class="gi">+        return (VariableVisitConsumerAction.RETURN, found_nodes)</span>
<span class="gi">+</span>
<span class="gi">+    def _report_unfound_name_definition(</span>
<span class="gi">+        self, node: nodes.NodeNG, current_consumer: NamesConsumer</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reports used-before-assignment when all name definition nodes
<span class="w"> </span>        get filtered out by NamesConsumer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _filter_type_checking_import_from_consumption(self, node: nodes.</span>
<span class="gd">-        NodeNG, nodes_to_consume: list[nodes.NodeNG]) -&gt;list[nodes.NodeNG]:</span>
<span class="gi">+        if (</span>
<span class="gi">+            self._postponed_evaluation_enabled</span>
<span class="gi">+            and utils.is_node_in_type_annotation_context(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._is_builtin(node.name):</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._is_variable_annotation_in_function(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        if (</span>
<span class="gi">+            node.name in self._evaluated_type_checking_scopes</span>
<span class="gi">+            and node.scope() in self._evaluated_type_checking_scopes[node.name]</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        confidence = HIGH</span>
<span class="gi">+        if node.name in current_consumer.names_under_always_false_test:</span>
<span class="gi">+            confidence = INFERENCE</span>
<span class="gi">+        elif node.name in current_consumer.consumed_uncertain:</span>
<span class="gi">+            confidence = CONTROL_FLOW</span>
<span class="gi">+</span>
<span class="gi">+        if node.name in current_consumer.names_defined_under_one_branch_only:</span>
<span class="gi">+            msg = &quot;possibly-used-before-assignment&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = &quot;used-before-assignment&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            msg,</span>
<span class="gi">+            args=node.name,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            confidence=confidence,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _filter_type_checking_import_from_consumption(</span>
<span class="gi">+        self, node: nodes.NodeNG, nodes_to_consume: list[nodes.NodeNG]</span>
<span class="gi">+    ) -&gt; list[nodes.NodeNG]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do not consume type-checking import node as used-before-assignment
<span class="w"> </span>        may invoke in different scopes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;no-name-in-module&#39;)</span>
<span class="gd">-    def visit_import(self, node: nodes.Import) -&gt;None:</span>
<span class="gi">+        type_checking_import = next(</span>
<span class="gi">+            (</span>
<span class="gi">+                n</span>
<span class="gi">+                for n in nodes_to_consume</span>
<span class="gi">+                if isinstance(n, (nodes.Import, nodes.ImportFrom))</span>
<span class="gi">+                and in_type_checking_block(n)</span>
<span class="gi">+            ),</span>
<span class="gi">+            None,</span>
<span class="gi">+        )</span>
<span class="gi">+        # If used-before-assignment reported for usage of type checking import</span>
<span class="gi">+        # keep track of its scope</span>
<span class="gi">+        if type_checking_import and not self._is_variable_annotation_in_function(node):</span>
<span class="gi">+            self._evaluated_type_checking_scopes.setdefault(node.name, []).append(</span>
<span class="gi">+                node.scope()</span>
<span class="gi">+            )</span>
<span class="gi">+        nodes_to_consume = [n for n in nodes_to_consume if n != type_checking_import]</span>
<span class="gi">+        return nodes_to_consume</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;no-name-in-module&quot;)</span>
<span class="gi">+    def visit_import(self, node: nodes.Import) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check modules attribute accesses.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;no-name-in-module&#39;)</span>
<span class="gd">-    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:</span>
<span class="gi">+        if not self._analyse_fallback_blocks and utils.is_from_fallback_block(node):</span>
<span class="gi">+            # No need to verify this, since ImportError is already</span>
<span class="gi">+            # handled by the client code.</span>
<span class="gi">+            return</span>
<span class="gi">+        # Don&#39;t verify import if part of guarded import block</span>
<span class="gi">+        if in_type_checking_block(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node.parent, nodes.If) and is_sys_guard(node.parent):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for name, _ in node.names:</span>
<span class="gi">+            parts = name.split(&quot;.&quot;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                module = next(_infer_name_module(node, parts[0]))</span>
<span class="gi">+            except astroid.ResolveError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not isinstance(module, nodes.Module):</span>
<span class="gi">+                continue</span>
<span class="gi">+            self._check_module_attrs(node, module, parts[1:])</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;no-name-in-module&quot;)</span>
<span class="gi">+    def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check modules attribute accesses.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;unbalanced-tuple-unpacking&#39;,</span>
<span class="gd">-        &#39;unpacking-non-sequence&#39;, &#39;self-cls-assignment&#39;,</span>
<span class="gd">-        &#39;unbalanced_dict_unpacking&#39;)</span>
<span class="gd">-    def visit_assign(self, node: nodes.Assign) -&gt;None:</span>
<span class="gi">+        if not self._analyse_fallback_blocks and utils.is_from_fallback_block(node):</span>
<span class="gi">+            # No need to verify this, since ImportError is already</span>
<span class="gi">+            # handled by the client code.</span>
<span class="gi">+            return</span>
<span class="gi">+        # Don&#39;t verify import if part of guarded import block</span>
<span class="gi">+        # I.e. `sys.version_info` or `typing.TYPE_CHECKING`</span>
<span class="gi">+        if in_type_checking_block(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(node.parent, nodes.If) and is_sys_guard(node.parent):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        name_parts = node.modname.split(&quot;.&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            module = node.do_import_module(name_parts[0])</span>
<span class="gi">+        except astroid.AstroidBuildingError:</span>
<span class="gi">+            return</span>
<span class="gi">+        module = self._check_module_attrs(node, module, name_parts[1:])</span>
<span class="gi">+        if not module:</span>
<span class="gi">+            return</span>
<span class="gi">+        for name, _ in node.names:</span>
<span class="gi">+            if name == &quot;*&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            self._check_module_attrs(node, module, name.split(&quot;.&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;unbalanced-tuple-unpacking&quot;,</span>
<span class="gi">+        &quot;unpacking-non-sequence&quot;,</span>
<span class="gi">+        &quot;self-cls-assignment&quot;,</span>
<span class="gi">+        &quot;unbalanced_dict_unpacking&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check unbalanced tuple unpacking for assignments and unpacking
<span class="w"> </span>        non-sequences as well as in case self/cls get assigned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._check_self_cls_assign(node)</span>
<span class="gi">+        if not isinstance(node.targets[0], (nodes.Tuple, nodes.List)):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        targets = node.targets[0].itered()</span>

<span class="gd">-    def visit_listcomp(self, node: nodes.ListComp) -&gt;None:</span>
<span class="gi">+        # Check if we have starred nodes.</span>
<span class="gi">+        if any(isinstance(target, nodes.Starred) for target in targets):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            inferred = utils.safe_infer(node.value)</span>
<span class="gi">+            if inferred is not None:</span>
<span class="gi">+                self._check_unpacking(inferred, node, targets)</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+    # listcomp have now also their scope</span>
<span class="gi">+    def visit_listcomp(self, node: nodes.ListComp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit listcomp: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._to_consume.append(NamesConsumer(node, &quot;comprehension&quot;))</span>

<span class="gd">-    def leave_listcomp(self, _: nodes.ListComp) -&gt;None:</span>
<span class="gi">+    def leave_listcomp(self, _: nodes.ListComp) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Leave listcomp: update consumption analysis variable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # do not check for not used locals here</span>
<span class="gi">+        self._to_consume.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def leave_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        self._store_type_annotation_names(node)</span>
<span class="gi">+</span>
<span class="gi">+    def leave_with(self, node: nodes.With) -&gt; None:</span>
<span class="gi">+        self._store_type_annotation_names(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_arguments(self, node: nodes.Arguments) -&gt; None:</span>
<span class="gi">+        for annotation in node.type_comment_args:</span>
<span class="gi">+            self._store_type_annotation_node(annotation)</span>
<span class="gi">+</span>
<span class="gi">+    # Relying on other checker&#39;s options, which might not have been initialized yet.</span>
<span class="gi">+    @cached_property</span>
<span class="gi">+    def _analyse_fallback_blocks(self) -&gt; bool:</span>
<span class="gi">+        return bool(self.linter.config.analyse_fallback_blocks)</span>
<span class="gi">+</span>
<span class="gi">+    @cached_property</span>
<span class="gi">+    def _ignored_modules(self) -&gt; Iterable[str]:</span>
<span class="gi">+        return self.linter.config.ignored_modules  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    @cached_property</span>
<span class="gi">+    def _allow_global_unused_variables(self) -&gt; bool:</span>
<span class="gi">+        return bool(self.linter.config.allow_global_unused_variables)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _in_lambda_or_comprehension_body(node: nodes.NodeNG, frame: nodes.</span>
<span class="gd">-        NodeNG) -&gt;bool:</span>
<span class="gi">+    def _defined_in_function_definition(</span>
<span class="gi">+        node: nodes.NodeNG, frame: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        in_annotation_or_default_or_decorator = False</span>
<span class="gi">+        if isinstance(frame, nodes.FunctionDef) and node.statement() is frame:</span>
<span class="gi">+            in_annotation_or_default_or_decorator = (</span>
<span class="gi">+                (</span>
<span class="gi">+                    node in frame.args.annotations</span>
<span class="gi">+                    or node in frame.args.posonlyargs_annotations</span>
<span class="gi">+                    or node in frame.args.kwonlyargs_annotations</span>
<span class="gi">+                    or node is frame.args.varargannotation</span>
<span class="gi">+                    or node is frame.args.kwargannotation</span>
<span class="gi">+                )</span>
<span class="gi">+                or frame.args.parent_of(node)</span>
<span class="gi">+                or (frame.decorators and frame.decorators.parent_of(node))</span>
<span class="gi">+                or (</span>
<span class="gi">+                    frame.returns</span>
<span class="gi">+                    and (node is frame.returns or frame.returns.parent_of(node))</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        return in_annotation_or_default_or_decorator</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _in_lambda_or_comprehension_body(</span>
<span class="gi">+        node: nodes.NodeNG, frame: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if node within a lambda/comprehension body (or similar) and thus
<span class="w"> </span>        should not have access to class attributes in frame.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        child = node</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        while parent is not None:</span>
<span class="gi">+            if parent is frame:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if isinstance(parent, nodes.Lambda) and child is not parent.args:</span>
<span class="gi">+                # Body of lambda should not have access to class attributes.</span>
<span class="gi">+                return True</span>
<span class="gi">+            if isinstance(parent, nodes.Comprehension) and child is not parent.iter:</span>
<span class="gi">+                # Only iter of list/set/dict/generator comprehension should have access.</span>
<span class="gi">+                return True</span>
<span class="gi">+            if isinstance(parent, nodes.ComprehensionScope) and not (</span>
<span class="gi">+                parent.generators and child is parent.generators[0]</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Body of list/set/dict/generator comprehension should not have access to class attributes.</span>
<span class="gi">+                # Furthermore, only the first generator (if multiple) in comprehension should have access.</span>
<span class="gi">+                return True</span>
<span class="gi">+            child = parent</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _maybe_used_and_assigned_at_once(defstmt: _base_nodes.Statement</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def _is_variable_violation(</span>
<span class="gi">+        node: nodes.Name,</span>
<span class="gi">+        defnode: nodes.NodeNG,</span>
<span class="gi">+        stmt: _base_nodes.Statement,</span>
<span class="gi">+        defstmt: _base_nodes.Statement,</span>
<span class="gi">+        frame: nodes.LocalsDictNodeNG,  # scope of statement of node</span>
<span class="gi">+        defframe: nodes.LocalsDictNodeNG,</span>
<span class="gi">+        base_scope_type: str,</span>
<span class="gi">+        is_recursive_klass: bool,</span>
<span class="gi">+    ) -&gt; tuple[bool, bool, bool]:</span>
<span class="gi">+        maybe_before_assign = True</span>
<span class="gi">+        annotation_return = False</span>
<span class="gi">+        use_outer_definition = False</span>
<span class="gi">+        if frame is not defframe:</span>
<span class="gi">+            maybe_before_assign = _detect_global_scope(node, frame, defframe)</span>
<span class="gi">+        elif defframe.parent is None:</span>
<span class="gi">+            # we are at the module level, check the name is not</span>
<span class="gi">+            # defined in builtins</span>
<span class="gi">+            if (</span>
<span class="gi">+                node.name in defframe.scope_attrs</span>
<span class="gi">+                or astroid.builtin_lookup(node.name)[1]</span>
<span class="gi">+            ):</span>
<span class="gi">+                maybe_before_assign = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            # we are in a local scope, check the name is not</span>
<span class="gi">+            # defined in global or builtin scope</span>
<span class="gi">+            # skip this lookup if name is assigned later in function scope/lambda</span>
<span class="gi">+            # Note: the node.frame() is not the same as the `frame` argument which is</span>
<span class="gi">+            # equivalent to frame.statement().scope()</span>
<span class="gi">+            forbid_lookup = (</span>
<span class="gi">+                isinstance(frame, nodes.FunctionDef)</span>
<span class="gi">+                or isinstance(node.frame(), nodes.Lambda)</span>
<span class="gi">+            ) and _assigned_locally(node)</span>
<span class="gi">+            if not forbid_lookup and defframe.root().lookup(node.name)[1]:</span>
<span class="gi">+                maybe_before_assign = False</span>
<span class="gi">+                use_outer_definition = stmt == defstmt and not isinstance(</span>
<span class="gi">+                    defnode, nodes.Comprehension</span>
<span class="gi">+                )</span>
<span class="gi">+            # check if we have a nonlocal</span>
<span class="gi">+            elif node.name in defframe.locals:</span>
<span class="gi">+                maybe_before_assign = not any(</span>
<span class="gi">+                    isinstance(child, nodes.Nonlocal) and node.name in child.names</span>
<span class="gi">+                    for child in defframe.get_children()</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            base_scope_type == &quot;lambda&quot;</span>
<span class="gi">+            and isinstance(frame, nodes.ClassDef)</span>
<span class="gi">+            and node.name in frame.locals</span>
<span class="gi">+        ):</span>
<span class="gi">+            # This rule verifies that if the definition node of the</span>
<span class="gi">+            # checked name is an Arguments node and if the name</span>
<span class="gi">+            # is used a default value in the arguments defaults</span>
<span class="gi">+            # and the actual definition of the variable label</span>
<span class="gi">+            # is happening before the Arguments definition.</span>
<span class="gi">+            #</span>
<span class="gi">+            # bar = None</span>
<span class="gi">+            # foo = lambda bar=bar: bar</span>
<span class="gi">+            #</span>
<span class="gi">+            # In this case, maybe_before_assign should be False, otherwise</span>
<span class="gi">+            # it should be True.</span>
<span class="gi">+            maybe_before_assign = not (</span>
<span class="gi">+                isinstance(defnode, nodes.Arguments)</span>
<span class="gi">+                and node in defnode.defaults</span>
<span class="gi">+                and frame.locals[node.name][0].fromlineno &lt; defstmt.fromlineno</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(defframe, nodes.ClassDef) and isinstance(</span>
<span class="gi">+            frame, nodes.FunctionDef</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Special rule for function return annotations,</span>
<span class="gi">+            # using a name defined earlier in the class containing the function.</span>
<span class="gi">+            if node is frame.returns and defframe.parent_of(frame.returns):</span>
<span class="gi">+                annotation_return = True</span>
<span class="gi">+                if frame.returns.name in defframe.locals:</span>
<span class="gi">+                    definition = defframe.locals[node.name][0]</span>
<span class="gi">+                    if definition.lineno is None or definition.lineno &lt; frame.lineno:</span>
<span class="gi">+                        # Detect class assignments with a name defined earlier in the</span>
<span class="gi">+                        # class. In this case, no warning should be raised.</span>
<span class="gi">+                        maybe_before_assign = False</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        maybe_before_assign = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    maybe_before_assign = True</span>
<span class="gi">+            if isinstance(node.parent, nodes.Arguments):</span>
<span class="gi">+                maybe_before_assign = stmt.fromlineno &lt;= defstmt.fromlineno</span>
<span class="gi">+        elif is_recursive_klass:</span>
<span class="gi">+            maybe_before_assign = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            maybe_before_assign = (</span>
<span class="gi">+                maybe_before_assign and stmt.fromlineno &lt;= defstmt.fromlineno</span>
<span class="gi">+            )</span>
<span class="gi">+            if maybe_before_assign and stmt.fromlineno == defstmt.fromlineno:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(defframe, nodes.FunctionDef)</span>
<span class="gi">+                    and frame is defframe</span>
<span class="gi">+                    and defframe.parent_of(node)</span>
<span class="gi">+                    and (</span>
<span class="gi">+                        defnode in defframe.type_params</span>
<span class="gi">+                        # Single statement function, with the statement on the</span>
<span class="gi">+                        # same line as the function definition</span>
<span class="gi">+                        or stmt is not defstmt</span>
<span class="gi">+                    )</span>
<span class="gi">+                ):</span>
<span class="gi">+                    maybe_before_assign = False</span>
<span class="gi">+                elif (</span>
<span class="gi">+                    isinstance(defstmt, NODES_WITH_VALUE_ATTR)</span>
<span class="gi">+                    and VariablesChecker._maybe_used_and_assigned_at_once(defstmt)</span>
<span class="gi">+                    and frame is defframe</span>
<span class="gi">+                    and defframe.parent_of(node)</span>
<span class="gi">+                    and stmt is defstmt</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Single statement if, with assignment expression on same</span>
<span class="gi">+                    # line as assignment</span>
<span class="gi">+                    # x = b if (b := True) else False</span>
<span class="gi">+                    maybe_before_assign = False</span>
<span class="gi">+                elif (</span>
<span class="gi">+                    isinstance(  # pylint: disable=too-many-boolean-expressions</span>
<span class="gi">+                        defnode, nodes.NamedExpr</span>
<span class="gi">+                    )</span>
<span class="gi">+                    and frame is defframe</span>
<span class="gi">+                    and defframe.parent_of(stmt)</span>
<span class="gi">+                    and stmt is defstmt</span>
<span class="gi">+                    and (</span>
<span class="gi">+                        (</span>
<span class="gi">+                            defnode.lineno == node.lineno</span>
<span class="gi">+                            and defnode.col_offset &lt; node.col_offset</span>
<span class="gi">+                        )</span>
<span class="gi">+                        or (defnode.lineno &lt; node.lineno)</span>
<span class="gi">+                        or (</span>
<span class="gi">+                            # Issue in the `ast` module until py39</span>
<span class="gi">+                            # Nodes in a multiline string have the same lineno</span>
<span class="gi">+                            # Could be false-positive without check</span>
<span class="gi">+                            not PY39_PLUS</span>
<span class="gi">+                            and defnode.lineno == node.lineno</span>
<span class="gi">+                            and isinstance(</span>
<span class="gi">+                                defstmt,</span>
<span class="gi">+                                (</span>
<span class="gi">+                                    nodes.Assign,</span>
<span class="gi">+                                    nodes.AnnAssign,</span>
<span class="gi">+                                    nodes.AugAssign,</span>
<span class="gi">+                                    nodes.Return,</span>
<span class="gi">+                                ),</span>
<span class="gi">+                            )</span>
<span class="gi">+                            and isinstance(defstmt.value, nodes.JoinedStr)</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                ):</span>
<span class="gi">+                    # Relation of a name to the same name in a named expression</span>
<span class="gi">+                    # Could be used before assignment if self-referencing:</span>
<span class="gi">+                    # (b := b)</span>
<span class="gi">+                    # Otherwise, safe if used after assignment:</span>
<span class="gi">+                    # (b := 2) and b</span>
<span class="gi">+                    maybe_before_assign = defnode.value is node or any(</span>
<span class="gi">+                        anc is defnode.value for anc in node.node_ancestors()</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+        return maybe_before_assign, annotation_return, use_outer_definition</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _maybe_used_and_assigned_at_once(defstmt: _base_nodes.Statement) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if `defstmt` has the potential to use and assign a name in the
<span class="w"> </span>        same statement.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(defstmt, nodes.Match):</span>
<span class="gi">+            return any(case.guard for case in defstmt.cases)</span>
<span class="gi">+        if isinstance(defstmt, nodes.IfExp):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(defstmt, nodes.TypeAlias):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(defstmt.value, nodes.BaseContainer):</span>
<span class="gi">+            return any(</span>
<span class="gi">+                VariablesChecker._maybe_used_and_assigned_at_once(elt)</span>
<span class="gi">+                for elt in defstmt.value.elts</span>
<span class="gi">+                if isinstance(elt, (*NODES_WITH_VALUE_ATTR, nodes.IfExp, nodes.Match))</span>
<span class="gi">+            )</span>
<span class="gi">+        value = defstmt.value</span>
<span class="gi">+        if isinstance(value, nodes.IfExp):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(value, nodes.Lambda) and isinstance(value.body, nodes.IfExp):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if isinstance(value, nodes.Dict) and any(</span>
<span class="gi">+            isinstance(item[0], nodes.IfExp) or isinstance(item[1], nodes.IfExp)</span>
<span class="gi">+            for item in value.items</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if not isinstance(value, nodes.Call):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return any(</span>
<span class="gi">+            any(isinstance(kwarg.value, nodes.IfExp) for kwarg in call.keywords)</span>
<span class="gi">+            or any(isinstance(arg, nodes.IfExp) for arg in call.args)</span>
<span class="gi">+            or (</span>
<span class="gi">+                isinstance(call.func, nodes.Attribute)</span>
<span class="gi">+                and isinstance(call.func.expr, nodes.IfExp)</span>
<span class="gi">+            )</span>
<span class="gi">+            for call in value.nodes_of_class(klass=nodes.Call)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _is_builtin(self, name: str) -&gt; bool:</span>
<span class="gi">+        return name in self.linter.config.additional_builtins or utils.is_builtin(name)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_only_type_assignment(node: nodes.Name, defstmt: _base_nodes.</span>
<span class="gd">-        Statement) -&gt;bool:</span>
<span class="gi">+    def _is_only_type_assignment(</span>
<span class="gi">+        node: nodes.Name, defstmt: _base_nodes.Statement</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if variable only gets assigned a type and never a value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(defstmt, nodes.AnnAssign) or defstmt.value:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        defstmt_frame = defstmt.frame()</span>
<span class="gi">+        node_frame = node.frame()</span>
<span class="gi">+</span>
<span class="gi">+        parent = node</span>
<span class="gi">+        while parent is not defstmt_frame.parent:</span>
<span class="gi">+            parent_scope = parent.scope()</span>
<span class="gi">+</span>
<span class="gi">+            # Find out if any nonlocals receive values in nested functions</span>
<span class="gi">+            for inner_func in parent_scope.nodes_of_class(nodes.FunctionDef):</span>
<span class="gi">+                if inner_func is parent_scope:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if any(</span>
<span class="gi">+                    node.name in nl.names</span>
<span class="gi">+                    for nl in inner_func.nodes_of_class(nodes.Nonlocal)</span>
<span class="gi">+                ) and any(</span>
<span class="gi">+                    node.name == an.name</span>
<span class="gi">+                    for an in inner_func.nodes_of_class(nodes.AssignName)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+            local_refs = parent_scope.locals.get(node.name, [])</span>
<span class="gi">+            for ref_node in local_refs:</span>
<span class="gi">+                # If local ref is in the same frame as our node, but on a later lineno</span>
<span class="gi">+                # we don&#39;t actually care about this local ref.</span>
<span class="gi">+                # Local refs are ordered, so we break.</span>
<span class="gi">+                #     print(var)</span>
<span class="gi">+                #     var = 1  # &lt;- irrelevant</span>
<span class="gi">+                if defstmt_frame == node_frame and ref_node.lineno &gt; node.lineno:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+                # If the parent of the local reference is anything but an AnnAssign</span>
<span class="gi">+                # Or if the AnnAssign adds a value the variable will now have a value</span>
<span class="gi">+                #     var = 1  # OR</span>
<span class="gi">+                #     var: int = 1</span>
<span class="gi">+                if (</span>
<span class="gi">+                    not isinstance(ref_node.parent, nodes.AnnAssign)</span>
<span class="gi">+                    or ref_node.parent.value</span>
<span class="gi">+                ) and not (</span>
<span class="gi">+                    # EXCEPTION: will not have a value if a self-referencing named expression</span>
<span class="gi">+                    # var: int</span>
<span class="gi">+                    # if (var := var * var)  &lt;-- &quot;var&quot; still undefined</span>
<span class="gi">+                    isinstance(ref_node.parent, nodes.NamedExpr)</span>
<span class="gi">+                    and any(</span>
<span class="gi">+                        anc is ref_node.parent.value for anc in node.node_ancestors()</span>
<span class="gi">+                    )</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            parent = parent_scope.parent</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_first_level_self_reference(node: nodes.Name, defstmt: nodes.</span>
<span class="gd">-        ClassDef, found_nodes: list[nodes.NodeNG]) -&gt;tuple[</span>
<span class="gd">-        VariableVisitConsumerAction, list[nodes.NodeNG] | None]:</span>
<span class="gi">+    def _is_first_level_self_reference(</span>
<span class="gi">+        node: nodes.Name, defstmt: nodes.ClassDef, found_nodes: list[nodes.NodeNG]</span>
<span class="gi">+    ) -&gt; tuple[VariableVisitConsumerAction, list[nodes.NodeNG] | None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a first level method&#39;s annotation or default values
<span class="w"> </span>        refers to its own class, and return a consumer action.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.frame().parent == defstmt and node.statement() == node.frame():</span>
<span class="gi">+            # Check if used as type annotation</span>
<span class="gi">+            # Break if postponed evaluation is enabled</span>
<span class="gi">+            if utils.is_node_in_type_annotation_context(node):</span>
<span class="gi">+                if not utils.is_postponed_evaluation_enabled(node):</span>
<span class="gi">+                    return (VariableVisitConsumerAction.CONTINUE, None)</span>
<span class="gi">+                return (VariableVisitConsumerAction.RETURN, None)</span>
<span class="gi">+            # Check if used as default value by calling the class</span>
<span class="gi">+            if isinstance(node.parent, nodes.Call) and isinstance(</span>
<span class="gi">+                node.parent.parent, nodes.Arguments</span>
<span class="gi">+            ):</span>
<span class="gi">+                return (VariableVisitConsumerAction.CONTINUE, None)</span>
<span class="gi">+        return (VariableVisitConsumerAction.RETURN, found_nodes)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _is_never_evaluated(defnode: nodes.NamedExpr, defnode_parent: nodes</span>
<span class="gd">-        .IfExp) -&gt;bool:</span>
<span class="gi">+    def _is_never_evaluated(</span>
<span class="gi">+        defnode: nodes.NamedExpr, defnode_parent: nodes.IfExp</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if a NamedExpr is inside a side of if ... else that never
<span class="w"> </span>        gets evaluated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred_test = utils.safe_infer(defnode_parent.test)</span>
<span class="gi">+        if isinstance(inferred_test, nodes.Const):</span>
<span class="gi">+            if inferred_test.value is True and defnode == defnode_parent.orelse:</span>
<span class="gi">+                return True</span>
<span class="gi">+            if inferred_test.value is False and defnode == defnode_parent.body:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>

<span class="gd">-    def _ignore_class_scope(self, node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_variable_annotation_in_function(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        is_annotation = utils.get_node_first_ancestor_of_type(node, nodes.AnnAssign)</span>
<span class="gi">+        return (</span>
<span class="gi">+            is_annotation</span>
<span class="gi">+            and utils.get_node_first_ancestor_of_type(  # type: ignore[return-value]</span>
<span class="gi">+                is_annotation, nodes.FunctionDef</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _ignore_class_scope(self, node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if the node is in a local class scope, as an assignment.

<span class="w"> </span>        Detect if we are in a local class scope, as an assignment.
<span class="gu">@@ -598,65 +2549,884 @@ class VariablesChecker(BaseChecker):</span>
<span class="w"> </span>           class D(Tp):
<span class="w"> </span>               ...
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_late_binding_closure(self, node: nodes.Name) -&gt;None:</span>
<span class="gi">+        name = node.name</span>
<span class="gi">+        frame = node.statement().scope()</span>
<span class="gi">+        in_annotation_or_default_or_decorator = self._defined_in_function_definition(</span>
<span class="gi">+            node, frame</span>
<span class="gi">+        )</span>
<span class="gi">+        in_ancestor_list = utils.is_ancestor_name(frame, node)</span>
<span class="gi">+        if in_annotation_or_default_or_decorator or in_ancestor_list:</span>
<span class="gi">+            frame_locals = frame.parent.scope().locals</span>
<span class="gi">+        else:</span>
<span class="gi">+            frame_locals = frame.locals</span>
<span class="gi">+        return not (</span>
<span class="gi">+            (isinstance(frame, nodes.ClassDef) or in_annotation_or_default_or_decorator)</span>
<span class="gi">+            and not self._in_lambda_or_comprehension_body(node, frame)</span>
<span class="gi">+            and name in frame_locals</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable-next=too-many-branches,too-many-statements</span>
<span class="gi">+    def _loopvar_name(self, node: astroid.Name) -&gt; None:</span>
<span class="gi">+        # filter variables according to node&#39;s scope</span>
<span class="gi">+        astmts = [s for s in node.lookup(node.name)[1] if hasattr(s, &quot;assign_type&quot;)]</span>
<span class="gi">+        # If this variable usage exists inside a function definition</span>
<span class="gi">+        # that exists in the same loop,</span>
<span class="gi">+        # the usage is safe because the function will not be defined either if</span>
<span class="gi">+        # the variable is not defined.</span>
<span class="gi">+        scope = node.scope()</span>
<span class="gi">+        if isinstance(scope, (nodes.Lambda, nodes.FunctionDef)) and any(</span>
<span class="gi">+            asmt.scope().parent_of(scope) for asmt in astmts</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        # Filter variables according to their respective scope. Test parent</span>
<span class="gi">+        # and statement to avoid #74747. This is not a total fix, which would</span>
<span class="gi">+        # introduce a mechanism similar to special attribute lookup in</span>
<span class="gi">+        # modules. Also, in order to get correct inference in this case, the</span>
<span class="gi">+        # scope lookup rules would need to be changed to return the initial</span>
<span class="gi">+        # assignment (which does not exist in code per se) as well as any later</span>
<span class="gi">+        # modifications.</span>
<span class="gi">+        if (</span>
<span class="gi">+            not astmts  # pylint: disable=too-many-boolean-expressions</span>
<span class="gi">+            or (</span>
<span class="gi">+                astmts[0].parent == astmts[0].root()</span>
<span class="gi">+                and astmts[0].parent.parent_of(node)</span>
<span class="gi">+            )</span>
<span class="gi">+            or (</span>
<span class="gi">+                astmts[0].is_statement</span>
<span class="gi">+                or not isinstance(astmts[0].parent, nodes.Module)</span>
<span class="gi">+                and astmts[0].statement().parent_of(node)</span>
<span class="gi">+            )</span>
<span class="gi">+        ):</span>
<span class="gi">+            _astmts = []</span>
<span class="gi">+        else:</span>
<span class="gi">+            _astmts = astmts[:1]</span>
<span class="gi">+        for i, stmt in enumerate(astmts[1:]):</span>
<span class="gi">+            try:</span>
<span class="gi">+                astmt_statement = astmts[i].statement()</span>
<span class="gi">+            except astroid.exceptions.ParentMissingError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if astmt_statement.parent_of(stmt) and not utils.in_for_else_branch(</span>
<span class="gi">+                astmt_statement, stmt</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+            _astmts.append(stmt)</span>
<span class="gi">+        astmts = _astmts</span>
<span class="gi">+        if len(astmts) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        assign = astmts[0].assign_type()</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(assign, (nodes.For, nodes.Comprehension, nodes.GeneratorExp))</span>
<span class="gi">+            and assign.statement() is not node.statement()</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(assign, nodes.For):</span>
<span class="gi">+            self.add_message(&quot;undefined-loop-variable&quot;, args=node.name, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+        for else_stmt in assign.orelse:</span>
<span class="gi">+            if isinstance(</span>
<span class="gi">+                else_stmt, (nodes.Return, nodes.Raise, nodes.Break, nodes.Continue)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+            # TODO: 4.0: Consider using utils.is_terminating_func</span>
<span class="gi">+            if isinstance(else_stmt, nodes.Expr) and isinstance(</span>
<span class="gi">+                else_stmt.value, nodes.Call</span>
<span class="gi">+            ):</span>
<span class="gi">+                inferred_func = utils.safe_infer(else_stmt.value.func)</span>
<span class="gi">+                if (</span>
<span class="gi">+                    isinstance(inferred_func, nodes.FunctionDef)</span>
<span class="gi">+                    and inferred_func.returns</span>
<span class="gi">+                ):</span>
<span class="gi">+                    inferred_return = utils.safe_infer(inferred_func.returns)</span>
<span class="gi">+                    if isinstance(</span>
<span class="gi">+                        inferred_return, nodes.FunctionDef</span>
<span class="gi">+                    ) and inferred_return.qname() in {</span>
<span class="gi">+                        *TYPING_NORETURN,</span>
<span class="gi">+                        *TYPING_NEVER,</span>
<span class="gi">+                        &quot;typing._SpecialForm&quot;,</span>
<span class="gi">+                    }:</span>
<span class="gi">+                        return</span>
<span class="gi">+                    # typing_extensions.NoReturn returns a _SpecialForm</span>
<span class="gi">+                    if (</span>
<span class="gi">+                        isinstance(inferred_return, bases.Instance)</span>
<span class="gi">+                        and inferred_return.qname() == &quot;typing._SpecialForm&quot;</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return</span>
<span class="gi">+</span>
<span class="gi">+        maybe_walrus = utils.get_node_first_ancestor_of_type(node, nodes.NamedExpr)</span>
<span class="gi">+        if maybe_walrus:</span>
<span class="gi">+            maybe_comprehension = utils.get_node_first_ancestor_of_type(</span>
<span class="gi">+                maybe_walrus, nodes.Comprehension</span>
<span class="gi">+            )</span>
<span class="gi">+            if maybe_comprehension:</span>
<span class="gi">+                comprehension_scope = utils.get_node_first_ancestor_of_type(</span>
<span class="gi">+                    maybe_comprehension, nodes.ComprehensionScope</span>
<span class="gi">+                )</span>
<span class="gi">+                if comprehension_scope is None:</span>
<span class="gi">+                    # Should not be possible.</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif (</span>
<span class="gi">+                    comprehension_scope.parent.scope() is scope</span>
<span class="gi">+                    and node.name in comprehension_scope.locals</span>
<span class="gi">+                ):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+        # For functions we can do more by inferring the length of the itered object</span>
<span class="gi">+        try:</span>
<span class="gi">+            inferred = next(assign.iter.infer())</span>
<span class="gi">+            # Prefer the target of enumerate() rather than the enumerate object itself</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(inferred, astroid.Instance)</span>
<span class="gi">+                and inferred.qname() == &quot;builtins.enumerate&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                likely_call = assign.iter</span>
<span class="gi">+                if isinstance(assign.iter, nodes.IfExp):</span>
<span class="gi">+                    likely_call = assign.iter.body</span>
<span class="gi">+                if isinstance(likely_call, nodes.Call):</span>
<span class="gi">+                    inferred = next(likely_call.args[0].infer())</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            self.add_message(&quot;undefined-loop-variable&quot;, args=node.name, node=node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(inferred, astroid.Instance)</span>
<span class="gi">+                and inferred.qname() == BUILTIN_RANGE</span>
<span class="gi">+            ):</span>
<span class="gi">+                # Consider range() objects safe, even if they might not yield any results.</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Consider sequences.</span>
<span class="gi">+            sequences = (</span>
<span class="gi">+                nodes.List,</span>
<span class="gi">+                nodes.Tuple,</span>
<span class="gi">+                nodes.Dict,</span>
<span class="gi">+                nodes.Set,</span>
<span class="gi">+                astroid.objects.FrozenSet,</span>
<span class="gi">+            )</span>
<span class="gi">+            if not isinstance(inferred, sequences):</span>
<span class="gi">+                self.add_message(&quot;undefined-loop-variable&quot;, args=node.name, node=node)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            elements = getattr(inferred, &quot;elts&quot;, getattr(inferred, &quot;items&quot;, []))</span>
<span class="gi">+            if not elements:</span>
<span class="gi">+                self.add_message(&quot;undefined-loop-variable&quot;, args=node.name, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-branches</span>
<span class="gi">+    def _check_is_unused(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        node: nodes.FunctionDef,</span>
<span class="gi">+        stmt: nodes.NodeNG,</span>
<span class="gi">+        global_names: set[str],</span>
<span class="gi">+        nonlocal_names: Iterable[str],</span>
<span class="gi">+        comprehension_target_names: Iterable[str],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # Ignore some special names specified by user configuration.</span>
<span class="gi">+        if self._is_name_ignored(stmt, name):</span>
<span class="gi">+            return</span>
<span class="gi">+        # Ignore names that were added dynamically to the Function scope</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, nodes.FunctionDef)</span>
<span class="gi">+            and name == &quot;__class__&quot;</span>
<span class="gi">+            and len(node.locals[&quot;__class__&quot;]) == 1</span>
<span class="gi">+            and isinstance(node.locals[&quot;__class__&quot;][0], nodes.ClassDef)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Ignore names imported by the global statement.</span>
<span class="gi">+        if isinstance(stmt, (nodes.Global, nodes.Import, nodes.ImportFrom)):</span>
<span class="gi">+            # Detect imports, assigned to global statements.</span>
<span class="gi">+            if global_names and _import_name_is_global(stmt, global_names):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        # Ignore names in comprehension targets</span>
<span class="gi">+        if name in comprehension_target_names:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Ignore names in string literal type annotation.</span>
<span class="gi">+        if name in self._type_annotation_names:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        argnames = node.argnames()</span>
<span class="gi">+        # Care about functions with unknown argument (builtins)</span>
<span class="gi">+        if name in argnames:</span>
<span class="gi">+            if node.name == &quot;__new__&quot;:</span>
<span class="gi">+                is_init_def = False</span>
<span class="gi">+                # Look for the `__init__` method in all the methods of the same class.</span>
<span class="gi">+                for n in node.parent.get_children():</span>
<span class="gi">+                    is_init_def = hasattr(n, &quot;name&quot;) and (n.name == &quot;__init__&quot;)</span>
<span class="gi">+                    if is_init_def:</span>
<span class="gi">+                        break</span>
<span class="gi">+                # Ignore unused arguments check for `__new__` if `__init__` is defined.</span>
<span class="gi">+                if is_init_def:</span>
<span class="gi">+                    return</span>
<span class="gi">+            self._check_unused_arguments(name, node, stmt, argnames, nonlocal_names)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if stmt.parent and isinstance(</span>
<span class="gi">+                stmt.parent, (nodes.Assign, nodes.AnnAssign, nodes.Tuple, nodes.For)</span>
<span class="gi">+            ):</span>
<span class="gi">+                if name in nonlocal_names:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            qname = asname = None</span>
<span class="gi">+            if isinstance(stmt, (nodes.Import, nodes.ImportFrom)):</span>
<span class="gi">+                # Need the complete name, which we don&#39;t have in .locals.</span>
<span class="gi">+                if len(stmt.names) &gt; 1:</span>
<span class="gi">+                    import_names = next(</span>
<span class="gi">+                        (names for names in stmt.names if name in names), None</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    import_names = stmt.names[0]</span>
<span class="gi">+                if import_names:</span>
<span class="gi">+                    qname, asname = import_names</span>
<span class="gi">+                    name = asname or qname</span>
<span class="gi">+</span>
<span class="gi">+            if _has_locals_call_after_node(stmt, node.scope()):</span>
<span class="gi">+                message_name = &quot;possibly-unused-variable&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                if isinstance(stmt, nodes.Import):</span>
<span class="gi">+                    if asname is not None:</span>
<span class="gi">+                        msg = f&quot;{qname} imported as {asname}&quot;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        msg = f&quot;import {name}&quot;</span>
<span class="gi">+                    self.add_message(&quot;unused-import&quot;, args=msg, node=stmt)</span>
<span class="gi">+                    return</span>
<span class="gi">+                if isinstance(stmt, nodes.ImportFrom):</span>
<span class="gi">+                    if asname is not None:</span>
<span class="gi">+                        msg = f&quot;{qname} imported from {stmt.modname} as {asname}&quot;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        msg = f&quot;{name} imported from {stmt.modname}&quot;</span>
<span class="gi">+                    self.add_message(&quot;unused-import&quot;, args=msg, node=stmt)</span>
<span class="gi">+                    return</span>
<span class="gi">+                message_name = &quot;unused-variable&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(stmt, nodes.FunctionDef) and stmt.decorators:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Don&#39;t check function stubs created only for type information</span>
<span class="gi">+            if utils.is_overload_stub(node):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Special case for exception variable</span>
<span class="gi">+            if isinstance(stmt.parent, nodes.ExceptHandler) and any(</span>
<span class="gi">+                n.name == name for n in stmt.parent.nodes_of_class(nodes.Name)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(message_name, args=name, node=stmt)</span>
<span class="gi">+</span>
<span class="gi">+    def _is_name_ignored(</span>
<span class="gi">+        self, stmt: nodes.NodeNG, name: str</span>
<span class="gi">+    ) -&gt; re.Pattern[str] | re.Match[str] | None:</span>
<span class="gi">+        authorized_rgx = self.linter.config.dummy_variables_rgx</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(stmt, nodes.AssignName)</span>
<span class="gi">+            and isinstance(stmt.parent, nodes.Arguments)</span>
<span class="gi">+            or isinstance(stmt, nodes.Arguments)</span>
<span class="gi">+        ):</span>
<span class="gi">+            regex: re.Pattern[str] = self.linter.config.ignored_argument_names</span>
<span class="gi">+        else:</span>
<span class="gi">+            regex = authorized_rgx</span>
<span class="gi">+        # See https://stackoverflow.com/a/47007761/2519059 to</span>
<span class="gi">+        # understand what this function return. Please do NOT use</span>
<span class="gi">+        # this elsewhere, this is confusing for no benefit</span>
<span class="gi">+        return regex and regex.match(name)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_unused_arguments(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        node: nodes.FunctionDef,</span>
<span class="gi">+        stmt: nodes.NodeNG,</span>
<span class="gi">+        argnames: list[str],</span>
<span class="gi">+        nonlocal_names: Iterable[str],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        is_method = node.is_method()</span>
<span class="gi">+        klass = node.parent.frame()</span>
<span class="gi">+        if is_method and isinstance(klass, nodes.ClassDef):</span>
<span class="gi">+            confidence = (</span>
<span class="gi">+                INFERENCE if utils.has_known_bases(klass) else INFERENCE_FAILURE</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            confidence = HIGH</span>
<span class="gi">+</span>
<span class="gi">+        if is_method:</span>
<span class="gi">+            # Don&#39;t warn for the first argument of a (non static) method</span>
<span class="gi">+            if node.type != &quot;staticmethod&quot; and name == argnames[0]:</span>
<span class="gi">+                return</span>
<span class="gi">+            # Don&#39;t warn for argument of an overridden method</span>
<span class="gi">+            overridden = overridden_method(klass, node.name)</span>
<span class="gi">+            if overridden is not None and name in overridden.argnames():</span>
<span class="gi">+                return</span>
<span class="gi">+            if node.name in utils.PYMETHODS and node.name not in (</span>
<span class="gi">+                &quot;__init__&quot;,</span>
<span class="gi">+                &quot;__new__&quot;,</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+        # Don&#39;t check callback arguments</span>
<span class="gi">+        if any(</span>
<span class="gi">+            node.name.startswith(cb) or node.name.endswith(cb)</span>
<span class="gi">+            for cb in self.linter.config.callbacks</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        # Don&#39;t check arguments of singledispatch.register function.</span>
<span class="gi">+        if utils.is_registered_in_singledispatch_function(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t check function stubs created only for type information</span>
<span class="gi">+        if utils.is_overload_stub(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t check protocol classes</span>
<span class="gi">+        if utils.is_protocol_class(klass):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if name in nonlocal_names:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;unused-argument&quot;, args=name, node=stmt, confidence=confidence)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_late_binding_closure(self, node: nodes.Name) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether node is a cell var that is assigned within a containing loop.

<span class="w"> </span>        Special cases where we don&#39;t care about the error:
<span class="w"> </span>        1. When the node&#39;s function is immediately called, e.g. (lambda: i)()
<span class="w"> </span>        2. When the node&#39;s function is returned from within the loop, e.g. return lambda: i
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.linter.is_message_enabled(&quot;cell-var-from-loop&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        node_scope = node.frame()</span>
<span class="gi">+</span>
<span class="gi">+        # If node appears in a default argument expression,</span>
<span class="gi">+        # look at the next enclosing frame instead</span>
<span class="gi">+        if utils.is_default_argument(node, node_scope):</span>
<span class="gi">+            node_scope = node_scope.parent.frame()</span>
<span class="gi">+</span>
<span class="gi">+        # Check if node is a cell var</span>
<span class="gi">+        if (</span>
<span class="gi">+            not isinstance(node_scope, (nodes.Lambda, nodes.FunctionDef))</span>
<span class="gi">+            or node.name in node_scope.locals</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        assign_scope, stmts = node.lookup(node.name)</span>
<span class="gi">+        if not stmts or not assign_scope.parent_of(node_scope):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if utils.is_comprehension(assign_scope):</span>
<span class="gi">+            self.add_message(&quot;cell-var-from-loop&quot;, node=node, args=node.name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Look for an enclosing For loop.</span>
<span class="gi">+            # Currently, we only consider the first assignment</span>
<span class="gi">+            assignment_node = stmts[0]</span>
<span class="gi">+</span>
<span class="gi">+            maybe_for = assignment_node</span>
<span class="gi">+            while maybe_for and not isinstance(maybe_for, nodes.For):</span>
<span class="gi">+                if maybe_for is assign_scope:</span>
<span class="gi">+                    break</span>
<span class="gi">+                maybe_for = maybe_for.parent</span>
<span class="gi">+            else:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    maybe_for</span>
<span class="gi">+                    and maybe_for.parent_of(node_scope)</span>
<span class="gi">+                    and not utils.is_being_called(node_scope)</span>
<span class="gi">+                    and node_scope.parent</span>
<span class="gi">+                    and not isinstance(node_scope.statement(), nodes.Return)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(&quot;cell-var-from-loop&quot;, node=node, args=node.name)</span>
<span class="gi">+</span>
<span class="gi">+    def _should_ignore_redefined_builtin(self, stmt: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        if not isinstance(stmt, nodes.ImportFrom):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return stmt.modname in self.linter.config.redefining_builtins_modules</span>
<span class="gi">+</span>
<span class="gi">+    def _allowed_redefined_builtin(self, name: str) -&gt; bool:</span>
<span class="gi">+        return name in self.linter.config.allowed_redefined_builtins</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _comprehension_between_frame_and_node(node: nodes.Name) -&gt;bool:</span>
<span class="gi">+    def _comprehension_between_frame_and_node(node: nodes.Name) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if a ComprehensionScope intervenes between `node` and its
<span class="w"> </span>        frame.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _store_type_annotation_node(self, type_annotation: nodes.NodeNG</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        closest_comprehension_scope = utils.get_node_first_ancestor_of_type(</span>
<span class="gi">+            node, nodes.ComprehensionScope</span>
<span class="gi">+        )</span>
<span class="gi">+        return closest_comprehension_scope is not None and node.frame().parent_of(</span>
<span class="gi">+            closest_comprehension_scope</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _store_type_annotation_node(self, type_annotation: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a type annotation, store all the name nodes it refers to.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_self_cls_assign(self, node: nodes.Assign) -&gt;None:</span>
<span class="gi">+        if isinstance(type_annotation, nodes.Name):</span>
<span class="gi">+            self._type_annotation_names.append(type_annotation.name)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(type_annotation, nodes.Attribute):</span>
<span class="gi">+            self._store_type_annotation_node(type_annotation.expr)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(type_annotation, nodes.Subscript):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(type_annotation.value, nodes.Attribute)</span>
<span class="gi">+            and isinstance(type_annotation.value.expr, nodes.Name)</span>
<span class="gi">+            and type_annotation.value.expr.name == TYPING_MODULE</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._type_annotation_names.append(TYPING_MODULE)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._type_annotation_names.extend(</span>
<span class="gi">+            annotation.name for annotation in type_annotation.nodes_of_class(nodes.Name)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _store_type_annotation_names(</span>
<span class="gi">+        self, node: nodes.For | nodes.Assign | nodes.With</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        type_annotation = node.type_annotation</span>
<span class="gi">+        if not type_annotation:</span>
<span class="gi">+            return</span>
<span class="gi">+        self._store_type_annotation_node(node.type_annotation)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_self_cls_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that self/cls don&#39;t get assigned.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_unpacking(self, inferred: InferenceResult, node: nodes.</span>
<span class="gd">-        Assign, targets: list[nodes.NodeNG]) -&gt;None:</span>
<span class="gi">+        assign_names: set[str | None] = set()</span>
<span class="gi">+        for target in node.targets:</span>
<span class="gi">+            if isinstance(target, nodes.AssignName):</span>
<span class="gi">+                assign_names.add(target.name)</span>
<span class="gi">+            elif isinstance(target, nodes.Tuple):</span>
<span class="gi">+                assign_names.update(</span>
<span class="gi">+                    elt.name for elt in target.elts if isinstance(elt, nodes.AssignName)</span>
<span class="gi">+                )</span>
<span class="gi">+        scope = node.scope()</span>
<span class="gi">+        nonlocals_with_same_name = node.scope().parent and any(</span>
<span class="gi">+            child for child in scope.body if isinstance(child, nodes.Nonlocal)</span>
<span class="gi">+        )</span>
<span class="gi">+        if nonlocals_with_same_name:</span>
<span class="gi">+            scope = node.scope().parent.scope()</span>
<span class="gi">+</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(scope, nodes.FunctionDef)</span>
<span class="gi">+            and scope.is_method()</span>
<span class="gi">+            and &quot;builtins.staticmethod&quot; not in scope.decoratornames()</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        argument_names = scope.argnames()</span>
<span class="gi">+        if not argument_names:</span>
<span class="gi">+            return</span>
<span class="gi">+        self_cls_name = argument_names[0]</span>
<span class="gi">+        if self_cls_name in assign_names:</span>
<span class="gi">+            self.add_message(&quot;self-cls-assignment&quot;, node=node, args=(self_cls_name,))</span>
<span class="gi">+</span>
<span class="gi">+    def _check_unpacking(</span>
<span class="gi">+        self, inferred: InferenceResult, node: nodes.Assign, targets: list[nodes.NodeNG]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for unbalanced tuple unpacking
<span class="w"> </span>        and unpacking non sequences.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if utils.is_inside_abstract_class(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        if utils.is_comprehension(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(inferred, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(inferred.parent, nodes.Arguments)</span>
<span class="gi">+            and isinstance(node.value, nodes.Name)</span>
<span class="gi">+            and node.value.name == inferred.parent.vararg</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Variable-length argument, we can&#39;t determine the length.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Attempt to check unpacking is properly balanced</span>
<span class="gi">+        values = self._nodes_to_unpack(inferred)</span>
<span class="gi">+        details = _get_unpacking_extra_info(node, inferred)</span>
<span class="gi">+</span>
<span class="gi">+        if values is not None:</span>
<span class="gi">+            if len(targets) != len(values):</span>
<span class="gi">+                self._report_unbalanced_unpacking(</span>
<span class="gi">+                    node, inferred, targets, len(values), details</span>
<span class="gi">+                )</span>
<span class="gi">+        # attempt to check unpacking may be possible (i.e. RHS is iterable)</span>
<span class="gi">+        elif not utils.is_iterable(inferred):</span>
<span class="gi">+            self._report_unpacking_non_sequence(node, details)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _nodes_to_unpack(node: nodes.NodeNG) -&gt;(list[nodes.NodeNG] | None):</span>
<span class="gd">-        &quot;&quot;&quot;Return the list of values of the `Assign` node.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def _get_value_length(value_node: nodes.NodeNG) -&gt; int:</span>
<span class="gi">+        value_subnodes = VariablesChecker._nodes_to_unpack(value_node)</span>
<span class="gi">+        if value_subnodes is not None:</span>
<span class="gi">+            return len(value_subnodes)</span>
<span class="gi">+        if isinstance(value_node, nodes.Const) and isinstance(</span>
<span class="gi">+            value_node.value, (str, bytes)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return len(value_node.value)</span>
<span class="gi">+        if isinstance(value_node, nodes.Subscript):</span>
<span class="gi">+            step = value_node.slice.step or 1</span>
<span class="gi">+            splice_range = value_node.slice.upper.value - value_node.slice.lower.value</span>
<span class="gi">+            splice_length = int(math.ceil(splice_range / step))</span>
<span class="gi">+            return splice_length</span>
<span class="gi">+        return 1</span>

<span class="gd">-    def _check_module_attrs(self, node: _base_nodes.ImportNode, module:</span>
<span class="gd">-        nodes.Module, module_names: list[str]) -&gt;(nodes.Module | None):</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _nodes_to_unpack(node: nodes.NodeNG) -&gt; list[nodes.NodeNG] | None:</span>
<span class="gi">+        &quot;&quot;&quot;Return the list of values of the `Assign` node.&quot;&quot;&quot;</span>
<span class="gi">+        if isinstance(node, (nodes.Tuple, nodes.List, nodes.Set, *DICT_TYPES)):</span>
<span class="gi">+            return node.itered()  # type: ignore[no-any-return]</span>
<span class="gi">+        if isinstance(node, astroid.Instance) and any(</span>
<span class="gi">+            ancestor.qname() == &quot;typing.NamedTuple&quot; for ancestor in node.ancestors()</span>
<span class="gi">+        ):</span>
<span class="gi">+            return [i for i in node.values() if isinstance(i, nodes.AssignName)]</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _report_unbalanced_unpacking(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.NodeNG,</span>
<span class="gi">+        inferred: InferenceResult,</span>
<span class="gi">+        targets: list[nodes.NodeNG],</span>
<span class="gi">+        values_count: int,</span>
<span class="gi">+        details: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        args = (</span>
<span class="gi">+            details,</span>
<span class="gi">+            len(targets),</span>
<span class="gi">+            &quot;&quot; if len(targets) == 1 else &quot;s&quot;,</span>
<span class="gi">+            values_count,</span>
<span class="gi">+            &quot;&quot; if values_count == 1 else &quot;s&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        symbol = (</span>
<span class="gi">+            &quot;unbalanced-dict-unpacking&quot;</span>
<span class="gi">+            if isinstance(inferred, DICT_TYPES)</span>
<span class="gi">+            else &quot;unbalanced-tuple-unpacking&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        self.add_message(symbol, node=node, args=args, confidence=INFERENCE)</span>
<span class="gi">+</span>
<span class="gi">+    def _report_unpacking_non_sequence(self, node: nodes.NodeNG, details: str) -&gt; None:</span>
<span class="gi">+        if details and not details.startswith(&quot; &quot;):</span>
<span class="gi">+            details = f&quot; {details}&quot;</span>
<span class="gi">+        self.add_message(&quot;unpacking-non-sequence&quot;, node=node, args=details)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_module_attrs(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: _base_nodes.ImportNode,</span>
<span class="gi">+        module: nodes.Module,</span>
<span class="gi">+        module_names: list[str],</span>
<span class="gi">+    ) -&gt; nodes.Module | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that module_names (list of string) are accessible through the
<span class="w"> </span>        given module, if the latest access name corresponds to a module, return it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_metaclasses(self, node: (nodes.Module | nodes.FunctionDef)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        while module_names:</span>
<span class="gi">+            name = module_names.pop(0)</span>
<span class="gi">+            if name == &quot;__dict__&quot;:</span>
<span class="gi">+                module = None</span>
<span class="gi">+                break</span>
<span class="gi">+            try:</span>
<span class="gi">+                module = module.getattr(name)[0]</span>
<span class="gi">+                if not isinstance(module, nodes.Module):</span>
<span class="gi">+                    module = next(module.infer())</span>
<span class="gi">+                    if not isinstance(module, nodes.Module):</span>
<span class="gi">+                        return None</span>
<span class="gi">+            except astroid.NotFoundError:</span>
<span class="gi">+                # Unable to import `name` from `module`. Since `name` may itself be a</span>
<span class="gi">+                # module, we first check if it matches the ignored modules.</span>
<span class="gi">+                if is_module_ignored(f&quot;{module.qname()}.{name}&quot;, self._ignored_modules):</span>
<span class="gi">+                    return None</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;no-name-in-module&quot;, args=(name, module.name), node=node</span>
<span class="gi">+                )</span>
<span class="gi">+                return None</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                return None</span>
<span class="gi">+        if module_names:</span>
<span class="gi">+            modname = module.name if module else &quot;__dict__&quot;</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;no-name-in-module&quot;, node=node, args=(&quot;.&quot;.join(module_names), modname)</span>
<span class="gi">+            )</span>
<span class="gi">+            return None</span>
<span class="gi">+        if isinstance(module, nodes.Module):</span>
<span class="gi">+            return module</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _check_all(</span>
<span class="gi">+        self, node: nodes.Module, not_consumed: dict[str, list[nodes.NodeNG]]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            assigned = next(node.igetattr(&quot;__all__&quot;))</span>
<span class="gi">+        except astroid.InferenceError:</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(assigned, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+        if assigned.pytype() not in {&quot;builtins.list&quot;, &quot;builtins.tuple&quot;}:</span>
<span class="gi">+            line, col = assigned.tolineno, assigned.col_offset</span>
<span class="gi">+            self.add_message(&quot;invalid-all-format&quot;, line=line, col_offset=col, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+        for elt in getattr(assigned, &quot;elts&quot;, ()):</span>
<span class="gi">+            try:</span>
<span class="gi">+                elt_name = next(elt.infer())</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if isinstance(elt_name, util.UninferableBase):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not elt_name.parent:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not isinstance(elt_name, nodes.Const) or not isinstance(</span>
<span class="gi">+                elt_name.value, str</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;invalid-all-object&quot;, args=elt.as_string(), node=elt)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            elt_name = elt_name.value</span>
<span class="gi">+            # If elt is in not_consumed, remove it from not_consumed</span>
<span class="gi">+            if elt_name in not_consumed:</span>
<span class="gi">+                del not_consumed[elt_name]</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if elt_name not in node.locals:</span>
<span class="gi">+                if not node.package:</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;undefined-all-variable&quot;, args=(elt_name,), node=elt</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    basename = os.path.splitext(node.file)[0]</span>
<span class="gi">+                    if os.path.basename(basename) == &quot;__init__&quot;:</span>
<span class="gi">+                        name = node.name + &quot;.&quot; + elt_name</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            astroid.modutils.file_from_modpath(name.split(&quot;.&quot;))</span>
<span class="gi">+                        except ImportError:</span>
<span class="gi">+                            self.add_message(</span>
<span class="gi">+                                &quot;undefined-all-variable&quot;, args=(elt_name,), node=elt</span>
<span class="gi">+                            )</span>
<span class="gi">+                        except SyntaxError:</span>
<span class="gi">+                            # don&#39;t yield a syntax-error warning,</span>
<span class="gi">+                            # because it will be later yielded</span>
<span class="gi">+                            # when the file will be checked</span>
<span class="gi">+                            pass</span>
<span class="gi">+</span>
<span class="gi">+    def _check_globals(self, not_consumed: dict[str, nodes.NodeNG]) -&gt; None:</span>
<span class="gi">+        if self._allow_global_unused_variables:</span>
<span class="gi">+            return</span>
<span class="gi">+        for name, node_lst in not_consumed.items():</span>
<span class="gi">+            for node in node_lst:</span>
<span class="gi">+                if in_type_checking_block(node):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.add_message(&quot;unused-variable&quot;, args=(name,), node=node)</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable = too-many-branches</span>
<span class="gi">+    def _check_imports(self, not_consumed: dict[str, list[nodes.NodeNG]]) -&gt; None:</span>
<span class="gi">+        local_names = _fix_dot_imports(not_consumed)</span>
<span class="gi">+        checked = set()</span>
<span class="gi">+        unused_wildcard_imports: defaultdict[</span>
<span class="gi">+            tuple[str, nodes.ImportFrom], list[str]</span>
<span class="gi">+        ] = collections.defaultdict(list)</span>
<span class="gi">+        for name, stmt in local_names:</span>
<span class="gi">+            for imports in stmt.names:</span>
<span class="gi">+                real_name = imported_name = imports[0]</span>
<span class="gi">+                if imported_name == &quot;*&quot;:</span>
<span class="gi">+                    real_name = name</span>
<span class="gi">+                as_name = imports[1]</span>
<span class="gi">+                if real_name in checked:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if name not in (real_name, as_name):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                checked.add(real_name)</span>
<span class="gi">+</span>
<span class="gi">+                is_type_annotation_import = (</span>
<span class="gi">+                    imported_name in self._type_annotation_names</span>
<span class="gi">+                    or as_name in self._type_annotation_names</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                is_dummy_import = (</span>
<span class="gi">+                    as_name</span>
<span class="gi">+                    and self.linter.config.dummy_variables_rgx</span>
<span class="gi">+                    and self.linter.config.dummy_variables_rgx.match(as_name)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                if isinstance(stmt, nodes.Import) or (</span>
<span class="gi">+                    isinstance(stmt, nodes.ImportFrom) and not stmt.modname</span>
<span class="gi">+                ):</span>
<span class="gi">+                    if isinstance(stmt, nodes.ImportFrom) and SPECIAL_OBJ.search(</span>
<span class="gi">+                        imported_name</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        # Filter special objects (__doc__, __all__) etc.,</span>
<span class="gi">+                        # because they can be imported for exporting.</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if is_type_annotation_import or is_dummy_import:</span>
<span class="gi">+                        # Most likely a typing import if it wasn&#39;t used so far.</span>
<span class="gi">+                        # Also filter dummy variables.</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if as_name is None:</span>
<span class="gi">+                        msg = f&quot;import {imported_name}&quot;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        msg = f&quot;{imported_name} imported as {as_name}&quot;</span>
<span class="gi">+                    if not in_type_checking_block(stmt):</span>
<span class="gi">+                        self.add_message(&quot;unused-import&quot;, args=msg, node=stmt)</span>
<span class="gi">+                elif isinstance(stmt, nodes.ImportFrom) and stmt.modname != FUTURE:</span>
<span class="gi">+                    if SPECIAL_OBJ.search(imported_name):</span>
<span class="gi">+                        # Filter special objects (__doc__, __all__) etc.,</span>
<span class="gi">+                        # because they can be imported for exporting.</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if _is_from_future_import(stmt, name):</span>
<span class="gi">+                        # Check if the name is in fact loaded from a</span>
<span class="gi">+                        # __future__ import in another module.</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if is_type_annotation_import or is_dummy_import:</span>
<span class="gi">+                        # Most likely a typing import if it wasn&#39;t used so far.</span>
<span class="gi">+                        # Also filter dummy variables.</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if imported_name == &quot;*&quot;:</span>
<span class="gi">+                        unused_wildcard_imports[(stmt.modname, stmt)].append(name)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if as_name is None:</span>
<span class="gi">+                            msg = f&quot;{imported_name} imported from {stmt.modname}&quot;</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            msg = f&quot;{imported_name} imported from {stmt.modname} as {as_name}&quot;</span>
<span class="gi">+                        if not in_type_checking_block(stmt):</span>
<span class="gi">+                            self.add_message(&quot;unused-import&quot;, args=msg, node=stmt)</span>
<span class="gi">+</span>
<span class="gi">+        # Construct string for unused-wildcard-import message</span>
<span class="gi">+        for module, unused_list in unused_wildcard_imports.items():</span>
<span class="gi">+            if len(unused_list) == 1:</span>
<span class="gi">+                arg_string = unused_list[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                arg_string = (</span>
<span class="gi">+                    f&quot;{&#39;, &#39;.join(i for i in unused_list[:-1])} and {unused_list[-1]}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;unused-wildcard-import&quot;, args=(arg_string, module[0]), node=module[1]</span>
<span class="gi">+            )</span>
<span class="gi">+        del self._to_consume</span>
<span class="gi">+</span>
<span class="gi">+    def _check_metaclasses(self, node: nodes.Module | nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Update consumption analysis for metaclasses.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_potential_index_error(self, node: nodes.Subscript,</span>
<span class="gd">-        inferred_slice: (nodes.NodeNG | None)) -&gt;None:</span>
<span class="gi">+        consumed: list[tuple[dict[str, list[nodes.NodeNG]], str]] = []</span>
<span class="gi">+</span>
<span class="gi">+        for child_node in node.get_children():</span>
<span class="gi">+            if isinstance(child_node, nodes.ClassDef):</span>
<span class="gi">+                consumed.extend(self._check_classdef_metaclasses(child_node, node))</span>
<span class="gi">+</span>
<span class="gi">+        # Pop the consumed items, in order to avoid having</span>
<span class="gi">+        # unused-import and unused-variable false positives</span>
<span class="gi">+        for scope_locals, name in consumed:</span>
<span class="gi">+            scope_locals.pop(name, None)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_classdef_metaclasses(</span>
<span class="gi">+        self, klass: nodes.ClassDef, parent_node: nodes.Module | nodes.FunctionDef</span>
<span class="gi">+    ) -&gt; list[tuple[dict[str, list[nodes.NodeNG]], str]]:</span>
<span class="gi">+        if not klass._metaclass:</span>
<span class="gi">+            # Skip if this class doesn&#39;t use explicitly a metaclass, but inherits it from ancestors</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        consumed: list[tuple[dict[str, list[nodes.NodeNG]], str]] = []</span>
<span class="gi">+        metaclass = klass.metaclass()</span>
<span class="gi">+        name = &quot;&quot;</span>
<span class="gi">+        if isinstance(klass._metaclass, nodes.Name):</span>
<span class="gi">+            name = klass._metaclass.name</span>
<span class="gi">+        elif isinstance(klass._metaclass, nodes.Attribute) and klass._metaclass.expr:</span>
<span class="gi">+            attr = klass._metaclass.expr</span>
<span class="gi">+            while not isinstance(attr, nodes.Name):</span>
<span class="gi">+                attr = attr.expr</span>
<span class="gi">+            name = attr.name</span>
<span class="gi">+        elif isinstance(klass._metaclass, nodes.Call) and isinstance(</span>
<span class="gi">+            klass._metaclass.func, nodes.Name</span>
<span class="gi">+        ):</span>
<span class="gi">+            name = klass._metaclass.func.name</span>
<span class="gi">+        elif metaclass:</span>
<span class="gi">+            name = metaclass.root().name</span>
<span class="gi">+</span>
<span class="gi">+        found = False</span>
<span class="gi">+        name = METACLASS_NAME_TRANSFORMS.get(name, name)</span>
<span class="gi">+        if name:</span>
<span class="gi">+            # check enclosing scopes starting from most local</span>
<span class="gi">+            for scope_locals, _, _, _ in self._to_consume[::-1]:</span>
<span class="gi">+                found_nodes = scope_locals.get(name, [])</span>
<span class="gi">+                for found_node in found_nodes:</span>
<span class="gi">+                    if found_node.lineno &lt;= klass.lineno:</span>
<span class="gi">+                        consumed.append((scope_locals, name))</span>
<span class="gi">+                        found = True</span>
<span class="gi">+                        break</span>
<span class="gi">+            # Check parent scope</span>
<span class="gi">+            nodes_in_parent_scope = parent_node.locals.get(name, [])</span>
<span class="gi">+            for found_node_parent in nodes_in_parent_scope:</span>
<span class="gi">+                if found_node_parent.lineno &lt;= klass.lineno:</span>
<span class="gi">+                    found = True</span>
<span class="gi">+                    break</span>
<span class="gi">+        if (</span>
<span class="gi">+            not found</span>
<span class="gi">+            and not metaclass</span>
<span class="gi">+            and not (</span>
<span class="gi">+                name in nodes.Module.scope_attrs</span>
<span class="gi">+                or utils.is_builtin(name)</span>
<span class="gi">+                or name in self.linter.config.additional_builtins</span>
<span class="gi">+            )</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;undefined-variable&quot;, node=klass, args=(name,))</span>
<span class="gi">+</span>
<span class="gi">+        return consumed</span>
<span class="gi">+</span>
<span class="gi">+    def visit_subscript(self, node: nodes.Subscript) -&gt; None:</span>
<span class="gi">+        inferred_slice = utils.safe_infer(node.slice)</span>
<span class="gi">+</span>
<span class="gi">+        self._check_potential_index_error(node, inferred_slice)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_potential_index_error(</span>
<span class="gi">+        self, node: nodes.Subscript, inferred_slice: nodes.NodeNG | None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for the potential-index-error message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    @utils.only_required_for_messages(&#39;unused-import&#39;, &#39;unused-variable&#39;)</span>
<span class="gd">-    def visit_const(self, node: nodes.Const) -&gt;None:</span>
<span class="gi">+        # Currently we only check simple slices of a single integer</span>
<span class="gi">+        if not isinstance(inferred_slice, nodes.Const) or not isinstance(</span>
<span class="gi">+            inferred_slice.value, int</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # If the node.value is a Tuple or List without inference it is defined in place</span>
<span class="gi">+        if isinstance(node.value, (nodes.Tuple, nodes.List)):</span>
<span class="gi">+            # Add 1 because iterables are 0-indexed</span>
<span class="gi">+            if len(node.value.elts) &lt; inferred_slice.value + 1:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;potential-index-error&quot;, node=node, confidence=INFERENCE</span>
<span class="gi">+                )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(</span>
<span class="gi">+        &quot;unused-import&quot;,</span>
<span class="gi">+        &quot;unused-variable&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_const(self, node: nodes.Const) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Take note of names that appear inside string literal type annotations
<span class="w"> </span>        unless the string is a parameter to `typing.Literal` or `typing.Annotation`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.pytype() != &quot;builtins.str&quot;:</span>
<span class="gi">+            return</span>
<span class="gi">+        if not utils.is_node_in_type_annotation_context(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Check if parent&#39;s or grandparent&#39;s first child is typing.Literal</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        if isinstance(parent, nodes.Tuple):</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        if isinstance(parent, nodes.Subscript):</span>
<span class="gi">+            origin = next(parent.get_children(), None)</span>
<span class="gi">+            if origin is not None and utils.is_typing_member(</span>
<span class="gi">+                origin, (&quot;Annotated&quot;, &quot;Literal&quot;)</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            annotation = extract_node(node.value)</span>
<span class="gi">+            self._store_type_annotation_node(annotation)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            # e.g. node.value is white space</span>
<span class="gi">+            pass</span>
<span class="gi">+        except astroid.AstroidSyntaxError:</span>
<span class="gi">+            # e.g. &quot;?&quot; or &quot;:&quot; in typing.Literal[&quot;?&quot;, &quot;:&quot;]</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(VariablesChecker(linter))</span>
<span class="gh">diff --git a/pylint/config/_breaking_changes.py b/pylint/config/_breaking_changes.py</span>
<span class="gh">index 441d4c3b4..943f708aa 100644</span>
<span class="gd">--- a/pylint/config/_breaking_changes.py</span>
<span class="gi">+++ b/pylint/config/_breaking_changes.py</span>
<span class="gu">@@ -1,25 +1,32 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;List the breaking changes in configuration files and their solutions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import enum
<span class="w"> </span>from typing import NamedTuple


<span class="w"> </span>class BreakingChange(enum.Enum):
<span class="gd">-    MESSAGE_MADE_DISABLED_BY_DEFAULT = (</span>
<span class="gd">-        &#39;{symbol} ({msgid}) was disabled by default&#39;)</span>
<span class="gd">-    MESSAGE_MADE_ENABLED_BY_DEFAULT = (</span>
<span class="gd">-        &#39;{symbol} ({msgid}) was enabled by default&#39;)</span>
<span class="gd">-    MESSAGE_MOVED_TO_EXTENSION = &#39;{symbol} ({msgid}) was moved to {extension}&#39;</span>
<span class="gd">-    EXTENSION_REMOVED = &#39;{extension} was removed&#39;</span>
<span class="gi">+    MESSAGE_MADE_DISABLED_BY_DEFAULT = &quot;{symbol} ({msgid}) was disabled by default&quot;</span>
<span class="gi">+    MESSAGE_MADE_ENABLED_BY_DEFAULT = &quot;{symbol} ({msgid}) was enabled by default&quot;</span>
<span class="gi">+    MESSAGE_MOVED_TO_EXTENSION = &quot;{symbol} ({msgid}) was moved to {extension}&quot;</span>
<span class="gi">+    EXTENSION_REMOVED = &quot;{extension} was removed&quot;</span>
<span class="gi">+    # This kind of upgrade is non-breaking but if we want to automatically upgrade it,</span>
<span class="gi">+    # then we should use the message store and old_names values instead of duplicating</span>
<span class="gi">+    # MESSAGE_RENAMED= &quot;{symbol} ({msgid}) was renamed&quot;</span>


<span class="w"> </span>class Condition(enum.Enum):
<span class="gd">-    MESSAGE_IS_ENABLED = &#39;{symbol} ({msgid}) is enabled&#39;</span>
<span class="gd">-    MESSAGE_IS_NOT_ENABLED = &#39;{symbol} ({msgid}) is not enabled&#39;</span>
<span class="gd">-    MESSAGE_IS_DISABLED = &#39;{symbol} ({msgid}) is disabled&#39;</span>
<span class="gd">-    MESSAGE_IS_NOT_DISABLED = &#39;{symbol} ({msgid}) is not disabled&#39;</span>
<span class="gd">-    EXTENSION_IS_LOADED = &#39;{extension} is loaded&#39;</span>
<span class="gd">-    EXTENSION_IS_NOT_LOADED = &#39;{extension} is not loaded&#39;</span>
<span class="gi">+    MESSAGE_IS_ENABLED = &quot;{symbol} ({msgid}) is enabled&quot;</span>
<span class="gi">+    MESSAGE_IS_NOT_ENABLED = &quot;{symbol} ({msgid}) is not enabled&quot;</span>
<span class="gi">+    MESSAGE_IS_DISABLED = &quot;{symbol} ({msgid}) is disabled&quot;</span>
<span class="gi">+    MESSAGE_IS_NOT_DISABLED = &quot;{symbol} ({msgid}) is not disabled&quot;</span>
<span class="gi">+    EXTENSION_IS_LOADED = &quot;{extension} is loaded&quot;</span>
<span class="gi">+    EXTENSION_IS_NOT_LOADED = &quot;{extension} is not loaded&quot;</span>


<span class="w"> </span>class Information(NamedTuple):
<span class="gu">@@ -31,33 +38,60 @@ class Solution(enum.Enum):</span>
<span class="w"> </span>    ADD_EXTENSION = &quot;Add {extension} in &#39;load-plugins&#39; option&quot;
<span class="w"> </span>    REMOVE_EXTENSION = &quot;Remove {extension} from the &#39;load-plugins&#39; option&quot;
<span class="w"> </span>    ENABLE_MESSAGE_EXPLICITLY = (
<span class="gd">-        &quot;{symbol} ({msgid}) should be added in the &#39;enable&#39; option&quot;)</span>
<span class="gi">+        &quot;{symbol} ({msgid}) should be added in the &#39;enable&#39; option&quot;</span>
<span class="gi">+    )</span>
<span class="w"> </span>    ENABLE_MESSAGE_IMPLICITLY = (
<span class="gd">-        &quot;{symbol} ({msgid}) should be removed from the &#39;disable&#39; option&quot;)</span>
<span class="gi">+        &quot;{symbol} ({msgid}) should be removed from the &#39;disable&#39; option&quot;</span>
<span class="gi">+    )</span>
<span class="w"> </span>    DISABLE_MESSAGE_EXPLICITLY = (
<span class="gd">-        &quot;{symbol} ({msgid}) should be added in the &#39;disable&#39; option&quot;)</span>
<span class="gi">+        &quot;{symbol} ({msgid}) should be added in the &#39;disable&#39; option&quot;</span>
<span class="gi">+    )</span>
<span class="w"> </span>    DISABLE_MESSAGE_IMPLICITLY = (
<span class="gd">-        &quot;{symbol} ({msgid}) should be removed from the &#39;enable&#39; option&quot;)</span>
<span class="gi">+        &quot;{symbol} ({msgid}) should be removed from the &#39;enable&#39; option&quot;</span>
<span class="gi">+    )</span>


<span class="w"> </span>ConditionsToBeAffected = list[Condition]
<span class="gi">+# A solution to a breaking change might imply multiple actions</span>
<span class="w"> </span>MultipleActionSolution = list[Solution]
<span class="gi">+# Sometimes there&#39;s multiple solutions and the user needs to choose</span>
<span class="w"> </span>Solutions = list[MultipleActionSolution]
<span class="gd">-BreakingChangeWithSolution = tuple[BreakingChange, Information,</span>
<span class="gd">-    ConditionsToBeAffected, Solutions]</span>
<span class="gd">-NO_SELF_USE = Information(msgid_or_symbol=&#39;no-self-use&#39;, extension=</span>
<span class="gd">-    &#39;pylint.extensions.no_self_use&#39;)</span>
<span class="gd">-COMPARE_TO_ZERO = Information(msgid_or_symbol=&#39;compare-to-zero&#39;, extension=</span>
<span class="gd">-    &#39;pylint.extensions.comparetozero&#39;)</span>
<span class="gd">-COMPARE_TO_EMPTY_STRING = Information(msgid_or_symbol=</span>
<span class="gd">-    &#39;compare-to-empty-string&#39;, extension=&#39;pylint.extensions.emptystring&#39;)</span>
<span class="gi">+BreakingChangeWithSolution = tuple[</span>
<span class="gi">+    BreakingChange, Information, ConditionsToBeAffected, Solutions</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+NO_SELF_USE = Information(</span>
<span class="gi">+    msgid_or_symbol=&quot;no-self-use&quot;, extension=&quot;pylint.extensions.no_self_use&quot;</span>
<span class="gi">+)</span>
<span class="gi">+COMPARE_TO_ZERO = Information(</span>
<span class="gi">+    msgid_or_symbol=&quot;compare-to-zero&quot;, extension=&quot;pylint.extensions.comparetozero&quot;</span>
<span class="gi">+)</span>
<span class="gi">+COMPARE_TO_EMPTY_STRING = Information(</span>
<span class="gi">+    msgid_or_symbol=&quot;compare-to-empty-string&quot;,</span>
<span class="gi">+    extension=&quot;pylint.extensions.emptystring&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>CONFIGURATION_BREAKING_CHANGES: dict[str, list[BreakingChangeWithSolution]] = {
<span class="gd">-    &#39;2.14.0&#39;: [(BreakingChange.MESSAGE_MOVED_TO_EXTENSION, NO_SELF_USE, [</span>
<span class="gd">-    Condition.MESSAGE_IS_ENABLED, Condition.EXTENSION_IS_NOT_LOADED], [[</span>
<span class="gd">-    Solution.ADD_EXTENSION], [Solution.DISABLE_MESSAGE_IMPLICITLY]])],</span>
<span class="gd">-    &#39;3.0.0&#39;: [(BreakingChange.EXTENSION_REMOVED, COMPARE_TO_ZERO, [</span>
<span class="gd">-    Condition.MESSAGE_IS_NOT_DISABLED, Condition.EXTENSION_IS_LOADED], [[</span>
<span class="gd">-    Solution.REMOVE_EXTENSION, Solution.ENABLE_MESSAGE_EXPLICITLY]]), (</span>
<span class="gd">-    BreakingChange.EXTENSION_REMOVED, COMPARE_TO_EMPTY_STRING, [Condition.</span>
<span class="gd">-    MESSAGE_IS_NOT_DISABLED, Condition.EXTENSION_IS_LOADED], [[Solution.</span>
<span class="gd">-    REMOVE_EXTENSION, Solution.ENABLE_MESSAGE_EXPLICITLY]])]}</span>
<span class="gi">+    &quot;2.14.0&quot;: [</span>
<span class="gi">+        (</span>
<span class="gi">+            BreakingChange.MESSAGE_MOVED_TO_EXTENSION,</span>
<span class="gi">+            NO_SELF_USE,</span>
<span class="gi">+            [Condition.MESSAGE_IS_ENABLED, Condition.EXTENSION_IS_NOT_LOADED],</span>
<span class="gi">+            [[Solution.ADD_EXTENSION], [Solution.DISABLE_MESSAGE_IMPLICITLY]],</span>
<span class="gi">+        ),</span>
<span class="gi">+    ],</span>
<span class="gi">+    &quot;3.0.0&quot;: [</span>
<span class="gi">+        (</span>
<span class="gi">+            BreakingChange.EXTENSION_REMOVED,</span>
<span class="gi">+            COMPARE_TO_ZERO,</span>
<span class="gi">+            [Condition.MESSAGE_IS_NOT_DISABLED, Condition.EXTENSION_IS_LOADED],</span>
<span class="gi">+            [[Solution.REMOVE_EXTENSION, Solution.ENABLE_MESSAGE_EXPLICITLY]],</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            BreakingChange.EXTENSION_REMOVED,</span>
<span class="gi">+            COMPARE_TO_EMPTY_STRING,</span>
<span class="gi">+            [Condition.MESSAGE_IS_NOT_DISABLED, Condition.EXTENSION_IS_LOADED],</span>
<span class="gi">+            [[Solution.REMOVE_EXTENSION, Solution.ENABLE_MESSAGE_EXPLICITLY]],</span>
<span class="gi">+        ),</span>
<span class="gi">+    ],</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/pylint/config/_pylint_config/generate_command.py b/pylint/config/_pylint_config/generate_command.py</span>
<span class="gh">index 51798cfff..d1b73c99b 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/generate_command.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/generate_command.py</span>
<span class="gu">@@ -1,13 +1,49 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Everything related to the &#39;pylint-config generate&#39; command.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from pylint.config._pylint_config import utils
<span class="w"> </span>from pylint.config._pylint_config.help_message import get_subparser_help
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter


<span class="gd">-def handle_generate_command(linter: PyLinter) -&gt;int:</span>
<span class="gi">+def generate_interactive_config(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    print(&quot;Starting interactive pylint configuration generation&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    format_type = utils.get_and_validate_format()</span>
<span class="gi">+    minimal = format_type == &quot;toml&quot; and utils.get_minimal_setting()</span>
<span class="gi">+    to_file, output_file_name = utils.get_and_validate_output_file()</span>
<span class="gi">+</span>
<span class="gi">+    if format_type == &quot;toml&quot;:</span>
<span class="gi">+        config_string = linter._generate_config_file(minimal=minimal)</span>
<span class="gi">+    else:</span>
<span class="gi">+        output_stream = StringIO()</span>
<span class="gi">+        linter._generate_config(stream=output_stream, skipsections=(&quot;Commands&quot;,))</span>
<span class="gi">+        config_string = output_stream.getvalue()</span>
<span class="gi">+</span>
<span class="gi">+    if to_file:</span>
<span class="gi">+        with open(output_file_name, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+            print(config_string, file=f)</span>
<span class="gi">+        print(f&quot;Wrote configuration file to {output_file_name.resolve()}&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        print(config_string)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def handle_generate_command(linter: PyLinter) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Handle &#39;pylint-config generate&#39;.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Interactively generate a pylint configuration</span>
<span class="gi">+    if linter.config.interactive:</span>
<span class="gi">+        generate_interactive_config(linter)</span>
<span class="gi">+        return 0</span>
<span class="gi">+    print(get_subparser_help(linter, &quot;generate&quot;))</span>
<span class="gi">+    return 32</span>
<span class="gh">diff --git a/pylint/config/_pylint_config/help_message.py b/pylint/config/_pylint_config/help_message.py</span>
<span class="gh">index ef3e26de2..7ba947429 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/help_message.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/help_message.py</span>
<span class="gu">@@ -1,19 +1,59 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Everything related to the &#39;pylint-config -h&#39; command and subcommands.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter


<span class="gd">-def get_subparser_help(linter: PyLinter, command: str) -&gt;str:</span>
<span class="gi">+def get_subparser_help(linter: PyLinter, command: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the help message for one of the subcommands.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Make sure subparsers are initialized properly</span>
<span class="gi">+    assert linter._arg_parser._subparsers</span>
<span class="gi">+    subparser_action = linter._arg_parser._subparsers._group_actions[0]</span>
<span class="gi">+    assert isinstance(subparser_action, argparse._SubParsersAction)</span>
<span class="gi">+</span>
<span class="gi">+    for name, subparser in subparser_action.choices.items():</span>
<span class="gi">+        assert isinstance(subparser, argparse.ArgumentParser)</span>
<span class="gi">+        if name == command:</span>
<span class="gi">+            # Remove last character which is an extra new line</span>
<span class="gi">+            return subparser.format_help()[:-1]</span>
<span class="gi">+    return &quot;&quot;  # pragma: no cover</span>


<span class="gd">-def get_help(parser: argparse.ArgumentParser) -&gt;str:</span>
<span class="gi">+def get_help(parser: argparse.ArgumentParser) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the help message for the main &#39;pylint-config&#39; command.

<span class="w"> </span>    Taken from argparse.ArgumentParser.format_help.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    formatter = parser._get_formatter()</span>
<span class="gi">+</span>
<span class="gi">+    # usage</span>
<span class="gi">+    formatter.add_usage(</span>
<span class="gi">+        parser.usage, parser._actions, parser._mutually_exclusive_groups</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # description</span>
<span class="gi">+    formatter.add_text(parser.description)</span>
<span class="gi">+</span>
<span class="gi">+    # positionals, optionals and user-defined groups</span>
<span class="gi">+    for action_group in parser._action_groups:</span>
<span class="gi">+        if action_group.title == &quot;Subcommands&quot;:</span>
<span class="gi">+            formatter.start_section(action_group.title)</span>
<span class="gi">+            formatter.add_text(action_group.description)</span>
<span class="gi">+            formatter.add_arguments(action_group._group_actions)</span>
<span class="gi">+            formatter.end_section()</span>
<span class="gi">+</span>
<span class="gi">+    # epilog</span>
<span class="gi">+    formatter.add_text(parser.epilog)</span>
<span class="gi">+</span>
<span class="gi">+    # determine help from format above</span>
<span class="gi">+    return formatter.format_help()</span>
<span class="gh">diff --git a/pylint/config/_pylint_config/main.py b/pylint/config/_pylint_config/main.py</span>
<span class="gh">index 37f7adc06..e562da2ef 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/main.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/main.py</span>
<span class="gu">@@ -1,12 +1,25 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Everything related to the &#39;pylint-config&#39; command.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from pylint.config._pylint_config.generate_command import handle_generate_command
<span class="w"> </span>from pylint.config._pylint_config.help_message import get_help
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter


<span class="gd">-def _handle_pylint_config_commands(linter: PyLinter) -&gt;int:</span>
<span class="gi">+def _handle_pylint_config_commands(linter: PyLinter) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Handle whichever command is passed to &#39;pylint-config&#39;.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if linter.config.config_subcommand == &quot;generate&quot;:</span>
<span class="gi">+        return handle_generate_command(linter)</span>
<span class="gi">+</span>
<span class="gi">+    print(get_help(linter._arg_parser))</span>
<span class="gi">+    return 32</span>
<span class="gh">diff --git a/pylint/config/_pylint_config/setup.py b/pylint/config/_pylint_config/setup.py</span>
<span class="gh">index def43d8bc..211f9bc6d 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/setup.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/setup.py</span>
<span class="gu">@@ -1,20 +1,49 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Everything related to the setup of the &#39;pylint-config&#39; command.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from pylint.config._pylint_config.help_message import get_help
<span class="w"> </span>from pylint.config.callback_actions import _AccessParserAction


<span class="w"> </span>class _HelpAction(_AccessParserAction):
<span class="gd">-</span>
<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--help&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--help&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        get_help(self.parser)


<span class="gd">-def _register_generate_config_options(parser: argparse.ArgumentParser) -&gt;None:</span>
<span class="gi">+def _register_generate_config_options(parser: argparse.ArgumentParser) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Registers the necessary arguments on the parser.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser.prog = &quot;pylint-config&quot;</span>
<span class="gi">+    # Overwrite the help command</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &quot;-h&quot;,</span>
<span class="gi">+        &quot;--help&quot;,</span>
<span class="gi">+        action=_HelpAction,</span>
<span class="gi">+        default=argparse.SUPPRESS,</span>
<span class="gi">+        help=&quot;show this help message and exit&quot;,</span>
<span class="gi">+        parser=parser,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    # We use subparsers to create various subcommands under &#39;pylint-config&#39;</span>
<span class="gi">+    subparsers = parser.add_subparsers(dest=&quot;config_subcommand&quot;, title=&quot;Subcommands&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Add the generate command</span>
<span class="gi">+    generate_parser = subparsers.add_parser(</span>
<span class="gi">+        &quot;generate&quot;, help=&quot;Generate a pylint configuration&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    generate_parser.add_argument(&quot;--interactive&quot;, action=&quot;store_true&quot;)</span>
<span class="gh">diff --git a/pylint/config/_pylint_config/utils.py b/pylint/config/_pylint_config/utils.py</span>
<span class="gh">index d36cab5cc..f9185e8b1 100644</span>
<span class="gd">--- a/pylint/config/_pylint_config/utils.py</span>
<span class="gi">+++ b/pylint/config/_pylint_config/utils.py</span>
<span class="gu">@@ -1,53 +1,115 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utils for the &#39;pylint-config&#39; command.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from collections.abc import Callable
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Literal, TypeVar
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):
<span class="w"> </span>    from typing import ParamSpec
<span class="w"> </span>else:
<span class="w"> </span>    from typing_extensions import ParamSpec
<span class="gd">-_P = ParamSpec(&#39;_P&#39;)</span>
<span class="gd">-_ReturnValueT = TypeVar(&#39;_ReturnValueT&#39;, bool, str)</span>
<span class="gd">-SUPPORTED_FORMATS = {&#39;t&#39;, &#39;toml&#39;, &#39;i&#39;, &#39;ini&#39;}</span>
<span class="gd">-YES_NO_ANSWERS = {&#39;y&#39;, &#39;yes&#39;, &#39;n&#39;, &#39;no&#39;}</span>
<span class="gi">+</span>
<span class="gi">+_P = ParamSpec(&quot;_P&quot;)</span>
<span class="gi">+_ReturnValueT = TypeVar(&quot;_ReturnValueT&quot;, bool, str)</span>
<span class="gi">+</span>
<span class="gi">+SUPPORTED_FORMATS = {&quot;t&quot;, &quot;toml&quot;, &quot;i&quot;, &quot;ini&quot;}</span>
<span class="gi">+YES_NO_ANSWERS = {&quot;y&quot;, &quot;yes&quot;, &quot;n&quot;, &quot;no&quot;}</span>


<span class="w"> </span>class InvalidUserInput(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised whenever a user input is invalid.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, valid_input: str, input_value: str, *args: object</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, valid_input: str, input_value: str, *args: object) -&gt; None:</span>
<span class="w"> </span>        self.valid = valid_input
<span class="w"> </span>        self.input = input_value
<span class="w"> </span>        super().__init__(*args)


<span class="gd">-def should_retry_after_invalid_input(func: Callable[_P, _ReturnValueT]</span>
<span class="gd">-    ) -&gt;Callable[_P, _ReturnValueT]:</span>
<span class="gi">+def should_retry_after_invalid_input(</span>
<span class="gi">+    func: Callable[_P, _ReturnValueT]</span>
<span class="gi">+) -&gt; Callable[_P, _ReturnValueT]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator that handles InvalidUserInput exceptions and retries.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def inner_function(*args: _P.args, **kwargs: _P.kwargs) -&gt; _ReturnValueT:</span>
<span class="gi">+        called_once = False</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return func(*args, **kwargs)</span>
<span class="gi">+            except InvalidUserInput as exc:</span>
<span class="gi">+                if called_once and exc.input == &quot;exit()&quot;:</span>
<span class="gi">+                    print(&quot;Stopping &#39;pylint-config&#39;.&quot;)</span>
<span class="gi">+                    sys.exit()</span>
<span class="gi">+                print(f&quot;Answer should be one of {exc.valid}.&quot;)</span>
<span class="gi">+                print(&quot;Type &#39;exit()&#39; if you want to exit the program.&quot;)</span>
<span class="gi">+                called_once = True</span>
<span class="gi">+</span>
<span class="gi">+    return inner_function</span>


<span class="w"> </span>@should_retry_after_invalid_input
<span class="gd">-def get_and_validate_format() -&gt;Literal[&#39;toml&#39;, &#39;ini&#39;]:</span>
<span class="gi">+def get_and_validate_format() -&gt; Literal[&quot;toml&quot;, &quot;ini&quot;]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make sure that the output format is either .toml or .ini.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # pylint: disable-next=bad-builtin</span>
<span class="gi">+    format_type = input(</span>
<span class="gi">+        &quot;Please choose the format of configuration, (T)oml or (I)ni (.cfg): &quot;</span>
<span class="gi">+    ).lower()</span>
<span class="gi">+</span>
<span class="gi">+    if format_type not in SUPPORTED_FORMATS:</span>
<span class="gi">+        raise InvalidUserInput(&quot;, &quot;.join(sorted(SUPPORTED_FORMATS)), format_type)</span>
<span class="gi">+</span>
<span class="gi">+    if format_type.startswith(&quot;t&quot;):</span>
<span class="gi">+        return &quot;toml&quot;</span>
<span class="gi">+    return &quot;ini&quot;</span>


<span class="w"> </span>@should_retry_after_invalid_input
<span class="gd">-def validate_yes_no(question: str, default: (Literal[&#39;yes&#39;, &#39;no&#39;] | None)</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def validate_yes_no(question: str, default: Literal[&quot;yes&quot;, &quot;no&quot;] | None) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Validate that a yes or no answer is correct.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    question = f&quot;{question} (y)es or (n)o &quot;</span>
<span class="gi">+    if default:</span>
<span class="gi">+        question += f&quot; (default={default}) &quot;</span>
<span class="gi">+    # pylint: disable-next=bad-builtin</span>
<span class="gi">+    answer = input(question).lower()</span>
<span class="gi">+</span>
<span class="gi">+    if not answer and default:</span>
<span class="gi">+        answer = default</span>
<span class="gi">+</span>
<span class="gi">+    if answer not in YES_NO_ANSWERS:</span>
<span class="gi">+        raise InvalidUserInput(&quot;, &quot;.join(sorted(YES_NO_ANSWERS)), answer)</span>
<span class="gi">+</span>
<span class="gi">+    return answer.startswith(&quot;y&quot;)</span>


<span class="gd">-def get_minimal_setting() -&gt;bool:</span>
<span class="gi">+def get_minimal_setting() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Ask the user if they want to use the minimal setting.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return validate_yes_no(</span>
<span class="gi">+        &quot;Do you want a minimal configuration without comments or default values?&quot;, &quot;no&quot;</span>
<span class="gi">+    )</span>


<span class="gd">-def get_and_validate_output_file() -&gt;tuple[bool, Path]:</span>
<span class="gi">+def get_and_validate_output_file() -&gt; tuple[bool, Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make sure that the output file is correct.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    to_file = validate_yes_no(&quot;Do you want to write the output to a file?&quot;, &quot;no&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not to_file:</span>
<span class="gi">+        return False, Path()</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable-next=bad-builtin</span>
<span class="gi">+    file_name = Path(input(&quot;What should the file be called: &quot;))</span>
<span class="gi">+    if file_name.exists():</span>
<span class="gi">+        overwrite = validate_yes_no(</span>
<span class="gi">+            f&quot;{file_name} already exists. Are you sure you want to overwrite?&quot;, &quot;no&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if not overwrite:</span>
<span class="gi">+            return False, file_name</span>
<span class="gi">+        return True, file_name</span>
<span class="gi">+</span>
<span class="gi">+    return True, file_name</span>
<span class="gh">diff --git a/pylint/config/argument.py b/pylint/config/argument.py</span>
<span class="gh">index 0ac2e1955..2d2a46a3f 100644</span>
<span class="gd">--- a/pylint/config/argument.py</span>
<span class="gi">+++ b/pylint/config/argument.py</span>
<span class="gu">@@ -1,8 +1,14 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Definition of an Argument class and transformers for various argument types.

<span class="w"> </span>An Argument instance represents a pylint option to be handled by an argparse.ArgumentParser
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import os
<span class="w"> </span>import pathlib
<span class="gu">@@ -10,80 +16,139 @@ import re</span>
<span class="w"> </span>from collections.abc import Callable
<span class="w"> </span>from glob import glob
<span class="w"> </span>from typing import Any, Literal, Pattern, Sequence, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>from pylint import interfaces
<span class="w"> </span>from pylint import utils as pylint_utils
<span class="w"> </span>from pylint.config.callback_actions import _CallbackAction
<span class="w"> </span>from pylint.config.deprecation_actions import _NewNamesAction, _OldNamesAction
<span class="gd">-_ArgumentTypes = Union[str, int, float, bool, Pattern[str], Sequence[str],</span>
<span class="gd">-    Sequence[Pattern[str]], Tuple[int, ...]]</span>
<span class="gi">+</span>
<span class="gi">+_ArgumentTypes = Union[</span>
<span class="gi">+    str,</span>
<span class="gi">+    int,</span>
<span class="gi">+    float,</span>
<span class="gi">+    bool,</span>
<span class="gi">+    Pattern[str],</span>
<span class="gi">+    Sequence[str],</span>
<span class="gi">+    Sequence[Pattern[str]],</span>
<span class="gi">+    Tuple[int, ...],</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;List of possible argument types.&quot;&quot;&quot;


<span class="gd">-def _confidence_transformer(value: str) -&gt;Sequence[str]:</span>
<span class="gi">+def _confidence_transformer(value: str) -&gt; Sequence[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated string of confidence values.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _csv_transformer(value: str) -&gt;Sequence[str]:</span>
<span class="gi">+    if not value:</span>
<span class="gi">+        return interfaces.CONFIDENCE_LEVEL_NAMES</span>
<span class="gi">+    values = pylint_utils._check_csv(value)</span>
<span class="gi">+    for confidence in values:</span>
<span class="gi">+        if confidence not in interfaces.CONFIDENCE_LEVEL_NAMES:</span>
<span class="gi">+            raise argparse.ArgumentTypeError(</span>
<span class="gi">+                f&quot;{value} should be in {*interfaces.CONFIDENCE_LEVEL_NAMES,}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+    return values</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _csv_transformer(value: str) -&gt; Sequence[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return pylint_utils._check_csv(value)</span>


<span class="gd">-YES_VALUES = {&#39;y&#39;, &#39;yes&#39;, &#39;true&#39;}</span>
<span class="gd">-NO_VALUES = {&#39;n&#39;, &#39;no&#39;, &#39;false&#39;}</span>
<span class="gi">+YES_VALUES = {&quot;y&quot;, &quot;yes&quot;, &quot;true&quot;}</span>
<span class="gi">+NO_VALUES = {&quot;n&quot;, &quot;no&quot;, &quot;false&quot;}</span>


<span class="gd">-def _yn_transformer(value: str) -&gt;bool:</span>
<span class="gi">+def _yn_transformer(value: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Transforms a yes/no or stringified bool into a bool.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value = value.lower()</span>
<span class="gi">+    if value in YES_VALUES:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if value in NO_VALUES:</span>
<span class="gi">+        return False</span>
<span class="gi">+    raise argparse.ArgumentTypeError(</span>
<span class="gi">+        None, f&quot;Invalid yn value &#39;{value}&#39;, should be in {*YES_VALUES, *NO_VALUES}&quot;</span>
<span class="gi">+    )</span>


<span class="gd">-def _non_empty_string_transformer(value: str) -&gt;str:</span>
<span class="gi">+def _non_empty_string_transformer(value: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check that a string is not empty and remove quotes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not value:</span>
<span class="gi">+        raise argparse.ArgumentTypeError(&quot;Option cannot be an empty string.&quot;)</span>
<span class="gi">+    return pylint_utils._unquote(value)</span>


<span class="gd">-def _path_transformer(value: str) -&gt;str:</span>
<span class="gi">+def _path_transformer(value: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Expand user and variables in a path.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return os.path.expandvars(os.path.expanduser(value))</span>


<span class="gd">-def _glob_paths_csv_transformer(value: str) -&gt;Sequence[str]:</span>
<span class="gi">+def _glob_paths_csv_transformer(value: str) -&gt; Sequence[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated list of paths while expanding user and
<span class="w"> </span>    variables and glob patterns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    paths: list[str] = []</span>
<span class="gi">+    for path in _csv_transformer(value):</span>
<span class="gi">+        paths.extend(glob(_path_transformer(path), recursive=True))</span>
<span class="gi">+    return paths</span>


<span class="gd">-def _py_version_transformer(value: str) -&gt;tuple[int, ...]:</span>
<span class="gi">+def _py_version_transformer(value: str) -&gt; tuple[int, ...]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Transforms a version string into a version tuple.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        version = tuple(int(val) for val in value.replace(&quot;,&quot;, &quot;.&quot;).split(&quot;.&quot;))</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise argparse.ArgumentTypeError(</span>
<span class="gi">+            f&quot;{value} has an invalid format, should be a version string. E.g., &#39;3.8&#39;&quot;</span>
<span class="gi">+        ) from None</span>
<span class="gi">+    return version</span>


<span class="gd">-def _regex_transformer(value: str) -&gt;Pattern[str]:</span>
<span class="gi">+def _regex_transformer(value: str) -&gt; Pattern[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return `re.compile(value)`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return re.compile(value)</span>
<span class="gi">+    except re.error as e:</span>
<span class="gi">+        msg = f&quot;Error in provided regular expression: {value} beginning at index {e.pos}: {e.msg}&quot;</span>
<span class="gi">+        raise argparse.ArgumentTypeError(msg) from e</span>


<span class="gd">-def _regexp_csv_transfomer(value: str) -&gt;Sequence[Pattern[str]]:</span>
<span class="gi">+def _regexp_csv_transfomer(value: str) -&gt; Sequence[Pattern[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated list of regular expressions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    patterns: list[Pattern[str]] = []</span>
<span class="gi">+    for pattern in pylint_utils._check_regexp_csv(value):</span>
<span class="gi">+        patterns.append(_regex_transformer(pattern))</span>
<span class="gi">+    return patterns</span>


<span class="gd">-def _regexp_paths_csv_transfomer(value: str) -&gt;Sequence[Pattern[str]]:</span>
<span class="gi">+def _regexp_paths_csv_transfomer(value: str) -&gt; Sequence[Pattern[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Transforms a comma separated list of regular expressions paths.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {&#39;choice&#39;:</span>
<span class="gd">-    str, &#39;csv&#39;: _csv_transformer, &#39;float&#39;: float, &#39;int&#39;: int, &#39;confidence&#39;:</span>
<span class="gd">-    _confidence_transformer, &#39;non_empty_string&#39;:</span>
<span class="gd">-    _non_empty_string_transformer, &#39;path&#39;: _path_transformer,</span>
<span class="gd">-    &#39;glob_paths_csv&#39;: _glob_paths_csv_transformer, &#39;py_version&#39;:</span>
<span class="gd">-    _py_version_transformer, &#39;regexp&#39;: _regex_transformer, &#39;regexp_csv&#39;:</span>
<span class="gd">-    _regexp_csv_transfomer, &#39;regexp_paths_csv&#39;:</span>
<span class="gd">-    _regexp_paths_csv_transfomer, &#39;string&#39;: pylint_utils._unquote, &#39;yn&#39;:</span>
<span class="gd">-    _yn_transformer}</span>
<span class="gi">+    patterns: list[Pattern[str]] = []</span>
<span class="gi">+    for pattern in _csv_transformer(value):</span>
<span class="gi">+        patterns.append(</span>
<span class="gi">+            re.compile(</span>
<span class="gi">+                str(pathlib.PureWindowsPath(pattern)).replace(&quot;\\&quot;, &quot;\\\\&quot;)</span>
<span class="gi">+                + &quot;|&quot;</span>
<span class="gi">+                + pathlib.PureWindowsPath(pattern).as_posix()</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    return patterns</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {</span>
<span class="gi">+    &quot;choice&quot;: str,</span>
<span class="gi">+    &quot;csv&quot;: _csv_transformer,</span>
<span class="gi">+    &quot;float&quot;: float,</span>
<span class="gi">+    &quot;int&quot;: int,</span>
<span class="gi">+    &quot;confidence&quot;: _confidence_transformer,</span>
<span class="gi">+    &quot;non_empty_string&quot;: _non_empty_string_transformer,</span>
<span class="gi">+    &quot;path&quot;: _path_transformer,</span>
<span class="gi">+    &quot;glob_paths_csv&quot;: _glob_paths_csv_transformer,</span>
<span class="gi">+    &quot;py_version&quot;: _py_version_transformer,</span>
<span class="gi">+    &quot;regexp&quot;: _regex_transformer,</span>
<span class="gi">+    &quot;regexp_csv&quot;: _regexp_csv_transfomer,</span>
<span class="gi">+    &quot;regexp_paths_csv&quot;: _regexp_paths_csv_transfomer,</span>
<span class="gi">+    &quot;string&quot;: pylint_utils._unquote,</span>
<span class="gi">+    &quot;yn&quot;: _yn_transformer,</span>
<span class="gi">+}</span>
<span class="w"> </span>&quot;&quot;&quot;Type transformers for all argument types.

<span class="w"> </span>A transformer should accept a string and return one of the supported
<span class="gu">@@ -101,16 +166,27 @@ class _Argument:</span>
<span class="w"> </span>    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, flags: list[str], arg_help: str, hide_help: bool,</span>
<span class="gd">-        section: (str | None)) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        flags: list[str],</span>
<span class="gi">+        arg_help: str,</span>
<span class="gi">+        hide_help: bool,</span>
<span class="gi">+        section: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.flags = flags
<span class="w"> </span>        &quot;&quot;&quot;The name of the argument.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.hide_help = hide_help
<span class="w"> </span>        &quot;&quot;&quot;Whether to hide this argument in the help message.&quot;&quot;&quot;
<span class="gd">-        self.help = arg_help.replace(&#39;%&#39;, &#39;%%&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # argparse uses % formatting on help strings, so a % needs to be escaped</span>
<span class="gi">+        self.help = arg_help.replace(&quot;%&quot;, &quot;%%&quot;)</span>
<span class="w"> </span>        &quot;&quot;&quot;The description of the argument.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        if hide_help:
<span class="w"> </span>            self.help = argparse.SUPPRESS
<span class="gi">+</span>
<span class="w"> </span>        self.section = section
<span class="w"> </span>        &quot;&quot;&quot;The section to add this argument to.&quot;&quot;&quot;

<span class="gu">@@ -123,13 +199,23 @@ class _BaseStoreArgument(_Argument):</span>
<span class="w"> </span>    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, flags: list[str], action: str, default:</span>
<span class="gd">-        _ArgumentTypes, arg_help: str, hide_help: bool, section: (str | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gd">-        super().__init__(flags=flags, arg_help=arg_help, hide_help=</span>
<span class="gd">-            hide_help, section=section)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        flags: list[str],</span>
<span class="gi">+        action: str,</span>
<span class="gi">+        default: _ArgumentTypes,</span>
<span class="gi">+        arg_help: str,</span>
<span class="gi">+        hide_help: bool,</span>
<span class="gi">+        section: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            flags=flags, arg_help=arg_help, hide_help=hide_help, section=section</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.action = action
<span class="w"> </span>        &quot;&quot;&quot;The action to perform with the argument.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.default = default
<span class="w"> </span>        &quot;&quot;&quot;The default value of the argument.&quot;&quot;&quot;

<span class="gu">@@ -142,19 +228,38 @@ class _StoreArgument(_BaseStoreArgument):</span>
<span class="w"> </span>    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, flags: list[str], action: str, default:</span>
<span class="gd">-        _ArgumentTypes, arg_type: str, choices: (list[str] | None),</span>
<span class="gd">-        arg_help: str, metavar: str, hide_help: bool, section: (str | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gd">-        super().__init__(flags=flags, action=action, default=default,</span>
<span class="gd">-            arg_help=arg_help, hide_help=hide_help, section=section)</span>
<span class="gi">+    # pylint: disable-next=too-many-arguments</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        flags: list[str],</span>
<span class="gi">+        action: str,</span>
<span class="gi">+        default: _ArgumentTypes,</span>
<span class="gi">+        arg_type: str,</span>
<span class="gi">+        choices: list[str] | None,</span>
<span class="gi">+        arg_help: str,</span>
<span class="gi">+        metavar: str,</span>
<span class="gi">+        hide_help: bool,</span>
<span class="gi">+        section: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            action=action,</span>
<span class="gi">+            default=default,</span>
<span class="gi">+            arg_help=arg_help,</span>
<span class="gi">+            hide_help=hide_help,</span>
<span class="gi">+            section=section,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.type = _TYPE_TRANSFORMERS[arg_type]
<span class="w"> </span>        &quot;&quot;&quot;A transformer function that returns a transformed type of the argument.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.choices = choices
<span class="w"> </span>        &quot;&quot;&quot;A list of possible choices for the argument.

<span class="w"> </span>        None if there are no restrictions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.metavar = metavar
<span class="w"> </span>        &quot;&quot;&quot;The metavar of the argument.

<span class="gu">@@ -172,11 +277,25 @@ class _StoreTrueArgument(_BaseStoreArgument):</span>
<span class="w"> </span>    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, flags: list[str], action: Literal[&#39;store_true&#39;],</span>
<span class="gd">-        default: _ArgumentTypes, arg_help: str, hide_help: bool, section: (</span>
<span class="gd">-        str | None)) -&gt;None:</span>
<span class="gd">-        super().__init__(flags=flags, action=action, default=default,</span>
<span class="gd">-            arg_help=arg_help, hide_help=hide_help, section=section)</span>
<span class="gi">+    # pylint: disable-next=useless-parent-delegation # We narrow down the type of action</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        flags: list[str],</span>
<span class="gi">+        action: Literal[&quot;store_true&quot;],</span>
<span class="gi">+        default: _ArgumentTypes,</span>
<span class="gi">+        arg_help: str,</span>
<span class="gi">+        hide_help: bool,</span>
<span class="gi">+        section: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            action=action,</span>
<span class="gi">+            default=default,</span>
<span class="gi">+            arg_help=arg_help,</span>
<span class="gi">+            hide_help=hide_help,</span>
<span class="gi">+            section=section,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class _DeprecationArgument(_Argument):
<span class="gu">@@ -187,23 +306,39 @@ class _DeprecationArgument(_Argument):</span>
<span class="w"> </span>    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, flags: list[str], action: type[argparse.Action],</span>
<span class="gd">-        default: _ArgumentTypes, arg_type: str, choices: (list[str] | None),</span>
<span class="gd">-        arg_help: str, metavar: str, hide_help: bool, section: (str | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gd">-        super().__init__(flags=flags, arg_help=arg_help, hide_help=</span>
<span class="gd">-            hide_help, section=section)</span>
<span class="gi">+    # pylint: disable-next=too-many-arguments</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        flags: list[str],</span>
<span class="gi">+        action: type[argparse.Action],</span>
<span class="gi">+        default: _ArgumentTypes,</span>
<span class="gi">+        arg_type: str,</span>
<span class="gi">+        choices: list[str] | None,</span>
<span class="gi">+        arg_help: str,</span>
<span class="gi">+        metavar: str,</span>
<span class="gi">+        hide_help: bool,</span>
<span class="gi">+        section: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            flags=flags, arg_help=arg_help, hide_help=hide_help, section=section</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.action = action
<span class="w"> </span>        &quot;&quot;&quot;The action to perform with the argument.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.default = default
<span class="w"> </span>        &quot;&quot;&quot;The default value of the argument.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.type = _TYPE_TRANSFORMERS[arg_type]
<span class="w"> </span>        &quot;&quot;&quot;A transformer function that returns a transformed type of the argument.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.choices = choices
<span class="w"> </span>        &quot;&quot;&quot;A list of possible choices for the argument.

<span class="w"> </span>        None if there are no restrictions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.metavar = metavar
<span class="w"> </span>        &quot;&quot;&quot;The metavar of the argument.

<span class="gu">@@ -220,16 +355,37 @@ class _ExtendArgument(_DeprecationArgument):</span>
<span class="w"> </span>    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, flags: list[str], action: Literal[&#39;extend&#39;],</span>
<span class="gd">-        default: _ArgumentTypes, arg_type: str, metavar: str, arg_help: str,</span>
<span class="gd">-        hide_help: bool, section: (str | None), choices: (list[str] | None),</span>
<span class="gd">-        dest: (str | None)) -&gt;None:</span>
<span class="gi">+    # pylint: disable-next=too-many-arguments</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        flags: list[str],</span>
<span class="gi">+        action: Literal[&quot;extend&quot;],</span>
<span class="gi">+        default: _ArgumentTypes,</span>
<span class="gi">+        arg_type: str,</span>
<span class="gi">+        metavar: str,</span>
<span class="gi">+        arg_help: str,</span>
<span class="gi">+        hide_help: bool,</span>
<span class="gi">+        section: str | None,</span>
<span class="gi">+        choices: list[str] | None,</span>
<span class="gi">+        dest: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        action_class = argparse._ExtendAction
<span class="gi">+</span>
<span class="w"> </span>        self.dest = dest
<span class="w"> </span>        &quot;&quot;&quot;The destination of the argument.&quot;&quot;&quot;
<span class="gd">-        super().__init__(flags=flags, action=action_class, default=default,</span>
<span class="gd">-            arg_type=arg_type, choices=choices, arg_help=arg_help, metavar=</span>
<span class="gd">-            metavar, hide_help=hide_help, section=section)</span>
<span class="gi">+</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            action=action_class,</span>
<span class="gi">+            default=default,</span>
<span class="gi">+            arg_type=arg_type,</span>
<span class="gi">+            choices=choices,</span>
<span class="gi">+            arg_help=arg_help,</span>
<span class="gi">+            metavar=metavar,</span>
<span class="gi">+            hide_help=hide_help,</span>
<span class="gi">+            section=section,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class _StoreOldNamesArgument(_DeprecationArgument):
<span class="gu">@@ -240,13 +396,32 @@ class _StoreOldNamesArgument(_DeprecationArgument):</span>
<span class="w"> </span>    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, flags: list[str], default: _ArgumentTypes,</span>
<span class="gd">-        arg_type: str, choices: (list[str] | None), arg_help: str, metavar:</span>
<span class="gd">-        str, hide_help: bool, kwargs: dict[str, Any], section: (str | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gd">-        super().__init__(flags=flags, action=_OldNamesAction, default=</span>
<span class="gd">-            default, arg_type=arg_type, choices=choices, arg_help=arg_help,</span>
<span class="gd">-            metavar=metavar, hide_help=hide_help, section=section)</span>
<span class="gi">+    # pylint: disable-next=too-many-arguments</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        flags: list[str],</span>
<span class="gi">+        default: _ArgumentTypes,</span>
<span class="gi">+        arg_type: str,</span>
<span class="gi">+        choices: list[str] | None,</span>
<span class="gi">+        arg_help: str,</span>
<span class="gi">+        metavar: str,</span>
<span class="gi">+        hide_help: bool,</span>
<span class="gi">+        kwargs: dict[str, Any],</span>
<span class="gi">+        section: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            action=_OldNamesAction,</span>
<span class="gi">+            default=default,</span>
<span class="gi">+            arg_type=arg_type,</span>
<span class="gi">+            choices=choices,</span>
<span class="gi">+            arg_help=arg_help,</span>
<span class="gi">+            metavar=metavar,</span>
<span class="gi">+            hide_help=hide_help,</span>
<span class="gi">+            section=section,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.kwargs = kwargs
<span class="w"> </span>        &quot;&quot;&quot;Any additional arguments passed to the action.&quot;&quot;&quot;

<span class="gu">@@ -259,13 +434,32 @@ class _StoreNewNamesArgument(_DeprecationArgument):</span>
<span class="w"> </span>    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, flags: list[str], default: _ArgumentTypes,</span>
<span class="gd">-        arg_type: str, choices: (list[str] | None), arg_help: str, metavar:</span>
<span class="gd">-        str, hide_help: bool, kwargs: dict[str, Any], section: (str | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gd">-        super().__init__(flags=flags, action=_NewNamesAction, default=</span>
<span class="gd">-            default, arg_type=arg_type, choices=choices, arg_help=arg_help,</span>
<span class="gd">-            metavar=metavar, hide_help=hide_help, section=section)</span>
<span class="gi">+    # pylint: disable-next=too-many-arguments</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        flags: list[str],</span>
<span class="gi">+        default: _ArgumentTypes,</span>
<span class="gi">+        arg_type: str,</span>
<span class="gi">+        choices: list[str] | None,</span>
<span class="gi">+        arg_help: str,</span>
<span class="gi">+        metavar: str,</span>
<span class="gi">+        hide_help: bool,</span>
<span class="gi">+        kwargs: dict[str, Any],</span>
<span class="gi">+        section: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            action=_NewNamesAction,</span>
<span class="gi">+            default=default,</span>
<span class="gi">+            arg_type=arg_type,</span>
<span class="gi">+            choices=choices,</span>
<span class="gi">+            arg_help=arg_help,</span>
<span class="gi">+            metavar=metavar,</span>
<span class="gi">+            hide_help=hide_help,</span>
<span class="gi">+            section=section,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.kwargs = kwargs
<span class="w"> </span>        &quot;&quot;&quot;Any additional arguments passed to the action.&quot;&quot;&quot;

<span class="gu">@@ -279,15 +473,27 @@ class _CallableArgument(_Argument):</span>
<span class="w"> </span>    https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *, flags: list[str], action: type[_CallbackAction],</span>
<span class="gd">-        arg_help: str, kwargs: dict[str, Any], hide_help: bool, section: (</span>
<span class="gd">-        str | None), metavar: str) -&gt;None:</span>
<span class="gd">-        super().__init__(flags=flags, arg_help=arg_help, hide_help=</span>
<span class="gd">-            hide_help, section=section)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        flags: list[str],</span>
<span class="gi">+        action: type[_CallbackAction],</span>
<span class="gi">+        arg_help: str,</span>
<span class="gi">+        kwargs: dict[str, Any],</span>
<span class="gi">+        hide_help: bool,</span>
<span class="gi">+        section: str | None,</span>
<span class="gi">+        metavar: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            flags=flags, arg_help=arg_help, hide_help=hide_help, section=section</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.action = action
<span class="w"> </span>        &quot;&quot;&quot;The action to perform with the argument.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.kwargs = kwargs
<span class="w"> </span>        &quot;&quot;&quot;Any additional arguments passed to the action.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.metavar = metavar
<span class="w"> </span>        &quot;&quot;&quot;The metavar of the argument.

<span class="gh">diff --git a/pylint/config/arguments_manager.py b/pylint/config/arguments_manager.py</span>
<span class="gh">index c9417f90a..aca8f5f87 100644</span>
<span class="gd">--- a/pylint/config/arguments_manager.py</span>
<span class="gi">+++ b/pylint/config/arguments_manager.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Arguments manager class used to handle command-line arguments and options.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="gu">@@ -7,18 +13,34 @@ import textwrap</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from typing import TYPE_CHECKING, Any, TextIO
<span class="gi">+</span>
<span class="w"> </span>import tomlkit
<span class="gi">+</span>
<span class="w"> </span>from pylint import utils
<span class="gd">-from pylint.config.argument import _Argument, _CallableArgument, _ExtendArgument, _StoreArgument, _StoreNewNamesArgument, _StoreOldNamesArgument, _StoreTrueArgument</span>
<span class="gd">-from pylint.config.exceptions import UnrecognizedArgumentAction, _UnrecognizedOptionError</span>
<span class="gi">+from pylint.config.argument import (</span>
<span class="gi">+    _Argument,</span>
<span class="gi">+    _CallableArgument,</span>
<span class="gi">+    _ExtendArgument,</span>
<span class="gi">+    _StoreArgument,</span>
<span class="gi">+    _StoreNewNamesArgument,</span>
<span class="gi">+    _StoreOldNamesArgument,</span>
<span class="gi">+    _StoreTrueArgument,</span>
<span class="gi">+)</span>
<span class="gi">+from pylint.config.exceptions import (</span>
<span class="gi">+    UnrecognizedArgumentAction,</span>
<span class="gi">+    _UnrecognizedOptionError,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.config.help_formatter import _HelpFormatter
<span class="w"> </span>from pylint.config.utils import _convert_option_to_argument, _parse_rich_type_value
<span class="w"> </span>from pylint.constants import MAIN_CHECKER_NAME
<span class="w"> </span>from pylint.typing import DirectoryNamespaceDict, OptionDict
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 11):
<span class="w"> </span>    import tomllib
<span class="w"> </span>else:
<span class="w"> </span>    import tomli as tomllib
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.config.arguments_provider import _ArgumentsProvider

<span class="gu">@@ -26,10 +48,12 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>class _ArgumentsManager:
<span class="w"> </span>    &quot;&quot;&quot;Arguments manager class used to handle command-line arguments and options.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, prog: str, usage: (str | None)=None, description: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, prog: str, usage: str | None = None, description: str | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._config = argparse.Namespace()
<span class="w"> </span>        &quot;&quot;&quot;Namespace for all options.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self._base_config = self._config
<span class="w"> </span>        &quot;&quot;&quot;Fall back Namespace object created during initialization.

<span class="gu">@@ -37,67 +61,342 @@ class _ArgumentsManager:</span>
<span class="w"> </span>        fail to match a file with a directory we fall back to the Namespace object
<span class="w"> </span>        created during initialization.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        self._arg_parser = argparse.ArgumentParser(prog=prog, usage=usage or</span>
<span class="gd">-            &#39;%(prog)s [options]&#39;, description=description, formatter_class=</span>
<span class="gd">-            _HelpFormatter, conflict_handler=&#39;resolve&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        self._arg_parser = argparse.ArgumentParser(</span>
<span class="gi">+            prog=prog,</span>
<span class="gi">+            usage=usage or &quot;%(prog)s [options]&quot;,</span>
<span class="gi">+            description=description,</span>
<span class="gi">+            formatter_class=_HelpFormatter,</span>
<span class="gi">+            # Needed to let &#39;pylint-config&#39; overwrite the -h command</span>
<span class="gi">+            conflict_handler=&quot;resolve&quot;,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        &quot;&quot;&quot;The command line argument parser.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self._argument_groups_dict: dict[str, argparse._ArgumentGroup] = {}
<span class="w"> </span>        &quot;&quot;&quot;Dictionary of all the argument groups.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self._option_dicts: dict[str, OptionDict] = {}
<span class="w"> </span>        &quot;&quot;&quot;All option dictionaries that have been registered.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self._directory_namespaces: DirectoryNamespaceDict = {}
<span class="w"> </span>        &quot;&quot;&quot;Mapping of directories and their respective namespace objects.&quot;&quot;&quot;

<span class="w"> </span>    @property
<span class="gd">-    def config(self) -&gt;argparse.Namespace:</span>
<span class="gi">+    def config(self) -&gt; argparse.Namespace:</span>
<span class="w"> </span>        &quot;&quot;&quot;Namespace for all options.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._config</span>
<span class="gi">+</span>
<span class="gi">+    @config.setter</span>
<span class="gi">+    def config(self, value: argparse.Namespace) -&gt; None:</span>
<span class="gi">+        self._config = value</span>

<span class="gd">-    def _register_options_provider(self, provider: _ArgumentsProvider) -&gt;None:</span>
<span class="gi">+    def _register_options_provider(self, provider: _ArgumentsProvider) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register an options provider and load its defaults.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for opt, optdict in provider.options:</span>
<span class="gi">+            self._option_dicts[opt] = optdict</span>
<span class="gi">+            argument = _convert_option_to_argument(opt, optdict)</span>
<span class="gi">+            section = argument.section or provider.name.capitalize()</span>
<span class="gi">+</span>
<span class="gi">+            section_desc = provider.option_groups_descs.get(section, None)</span>
<span class="gi">+</span>
<span class="gi">+            # We exclude main since its docstring comes from PyLinter</span>
<span class="gi">+            if provider.name != MAIN_CHECKER_NAME and provider.__doc__:</span>
<span class="gi">+                section_desc = provider.__doc__.split(&quot;\n\n&quot;)[0]</span>
<span class="gi">+</span>
<span class="gi">+            self._add_arguments_to_parser(section, section_desc, argument)</span>

<span class="gd">-    def _add_arguments_to_parser(self, section: str, section_desc: (str |</span>
<span class="gd">-        None), argument: _Argument) -&gt;None:</span>
<span class="gi">+        self._load_default_argument_values()</span>
<span class="gi">+</span>
<span class="gi">+    def _add_arguments_to_parser(</span>
<span class="gi">+        self, section: str, section_desc: str | None, argument: _Argument</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add an argument to the correct argument section/group.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            section_group = self._argument_groups_dict[section]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if section_desc:</span>
<span class="gi">+                section_group = self._arg_parser.add_argument_group(</span>
<span class="gi">+                    section, section_desc</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                section_group = self._arg_parser.add_argument_group(title=section)</span>
<span class="gi">+            self._argument_groups_dict[section] = section_group</span>
<span class="gi">+        self._add_parser_option(section_group, argument)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _add_parser_option(section_group: argparse._ArgumentGroup, argument:</span>
<span class="gd">-        _Argument) -&gt;None:</span>
<span class="gi">+    def _add_parser_option(</span>
<span class="gi">+        section_group: argparse._ArgumentGroup, argument: _Argument</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add an argument.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(argument, _StoreArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                action=argument.action,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+                metavar=argument.metavar,</span>
<span class="gi">+                choices=argument.choices,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(argument, _StoreOldNamesArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                **argument.kwargs,</span>
<span class="gi">+                action=argument.action,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+                metavar=argument.metavar,</span>
<span class="gi">+                choices=argument.choices,</span>
<span class="gi">+            )</span>
<span class="gi">+            # We add the old name as hidden option to make its default value get loaded when</span>
<span class="gi">+            # argparse initializes all options from the checker</span>
<span class="gi">+            assert argument.kwargs[&quot;old_names&quot;]</span>
<span class="gi">+            for old_name in argument.kwargs[&quot;old_names&quot;]:</span>
<span class="gi">+                section_group.add_argument(</span>
<span class="gi">+                    f&quot;--{old_name}&quot;,</span>
<span class="gi">+                    action=&quot;store&quot;,</span>
<span class="gi">+                    default=argument.default,</span>
<span class="gi">+                    type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed</span>
<span class="gi">+                    help=argparse.SUPPRESS,</span>
<span class="gi">+                    metavar=argument.metavar,</span>
<span class="gi">+                    choices=argument.choices,</span>
<span class="gi">+                )</span>
<span class="gi">+        elif isinstance(argument, _StoreNewNamesArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                **argument.kwargs,</span>
<span class="gi">+                action=argument.action,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+                metavar=argument.metavar,</span>
<span class="gi">+                choices=argument.choices,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(argument, _StoreTrueArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                action=argument.action,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(argument, _CallableArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                **argument.kwargs,</span>
<span class="gi">+                action=argument.action,</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+                metavar=argument.metavar,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif isinstance(argument, _ExtendArgument):</span>
<span class="gi">+            section_group.add_argument(</span>
<span class="gi">+                *argument.flags,</span>
<span class="gi">+                action=argument.action,</span>
<span class="gi">+                default=argument.default,</span>
<span class="gi">+                type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed</span>
<span class="gi">+                help=argument.help,</span>
<span class="gi">+                metavar=argument.metavar,</span>
<span class="gi">+                choices=argument.choices,</span>
<span class="gi">+                dest=argument.dest,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise UnrecognizedArgumentAction</span>

<span class="gd">-    def _load_default_argument_values(self) -&gt;None:</span>
<span class="gi">+    def _load_default_argument_values(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Loads the default values of all registered options.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.config = self._arg_parser.parse_args([], self.config)</span>

<span class="gd">-    def _parse_configuration_file(self, arguments: list[str]) -&gt;None:</span>
<span class="gi">+    def _parse_configuration_file(self, arguments: list[str]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the arguments found in a configuration file into the namespace.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.config, parsed_args = self._arg_parser.parse_known_args(</span>
<span class="gi">+                arguments, self.config</span>
<span class="gi">+            )</span>
<span class="gi">+        except SystemExit:</span>
<span class="gi">+            sys.exit(32)</span>
<span class="gi">+        unrecognized_options: list[str] = []</span>
<span class="gi">+        for opt in parsed_args:</span>
<span class="gi">+            if opt.startswith(&quot;--&quot;):</span>
<span class="gi">+                unrecognized_options.append(opt[2:])</span>
<span class="gi">+        if unrecognized_options:</span>
<span class="gi">+            raise _UnrecognizedOptionError(options=unrecognized_options)</span>

<span class="gd">-    def _parse_command_line_configuration(self, arguments: (Sequence[str] |</span>
<span class="gd">-        None)=None) -&gt;list[str]:</span>
<span class="gi">+    def _parse_command_line_configuration(</span>
<span class="gi">+        self, arguments: Sequence[str] | None = None</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the arguments found on the command line into the namespace.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        arguments = sys.argv[1:] if arguments is None else arguments</span>
<span class="gi">+</span>
<span class="gi">+        self.config, parsed_args = self._arg_parser.parse_known_args(</span>
<span class="gi">+            arguments, self.config</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return parsed_args</span>

<span class="gd">-    def _generate_config(self, stream: (TextIO | None)=None, skipsections:</span>
<span class="gd">-        tuple[str, ...]=()) -&gt;None:</span>
<span class="gi">+    def _generate_config(</span>
<span class="gi">+        self, stream: TextIO | None = None, skipsections: tuple[str, ...] = ()</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a configuration file according to the current configuration
<span class="w"> </span>        into the given stream or stdout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        options_by_section = {}</span>
<span class="gi">+        sections = []</span>
<span class="gi">+        for group in sorted(</span>
<span class="gi">+            self._arg_parser._action_groups,</span>
<span class="gi">+            key=lambda x: (x.title != &quot;Main&quot;, x.title),</span>
<span class="gi">+        ):</span>
<span class="gi">+            group_name = group.title</span>
<span class="gi">+            assert group_name</span>
<span class="gi">+            if group_name in skipsections:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            options = []</span>
<span class="gi">+            option_actions = [</span>
<span class="gi">+                i</span>
<span class="gi">+                for i in group._group_actions</span>
<span class="gi">+                if not isinstance(i, argparse._SubParsersAction)</span>
<span class="gi">+            ]</span>
<span class="gi">+            for opt in sorted(option_actions, key=lambda x: x.option_strings[0][2:]):</span>
<span class="gi">+                if &quot;--help&quot; in opt.option_strings:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                optname = opt.option_strings[0][2:]</span>

<span class="gd">-    def help(self) -&gt;str:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    optdict = self._option_dicts[optname]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                options.append(</span>
<span class="gi">+                    (</span>
<span class="gi">+                        optname,</span>
<span class="gi">+                        optdict,</span>
<span class="gi">+                        getattr(self.config, optname.replace(&quot;-&quot;, &quot;_&quot;)),</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                options = [</span>
<span class="gi">+                    (n, d, v) for (n, d, v) in options if not d.get(&quot;deprecated&quot;)</span>
<span class="gi">+                ]</span>
<span class="gi">+</span>
<span class="gi">+            if options:</span>
<span class="gi">+                sections.append(group_name)</span>
<span class="gi">+                options_by_section[group_name] = options</span>
<span class="gi">+        stream = stream or sys.stdout</span>
<span class="gi">+        printed = False</span>
<span class="gi">+        for section in sections:</span>
<span class="gi">+            if printed:</span>
<span class="gi">+                print(&quot;\n&quot;, file=stream)</span>
<span class="gi">+            with warnings.catch_warnings():</span>
<span class="gi">+                warnings.filterwarnings(&quot;ignore&quot;, category=DeprecationWarning)</span>
<span class="gi">+                utils.format_section(</span>
<span class="gi">+                    stream, section.upper(), sorted(options_by_section[section])</span>
<span class="gi">+                )</span>
<span class="gi">+            printed = True</span>
<span class="gi">+</span>
<span class="gi">+    def help(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the usage string based on the available options.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._arg_parser.format_help()</span>

<span class="gd">-    def _generate_config_file(self, *, minimal: bool=False) -&gt;str:</span>
<span class="gi">+    def _generate_config_file(self, *, minimal: bool = False) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a configuration file according to the current configuration into
<span class="w"> </span>        stdout.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        toml_doc = tomlkit.document()</span>
<span class="gi">+        tool_table = tomlkit.table(is_super_table=True)</span>
<span class="gi">+        toml_doc.add(tomlkit.key(&quot;tool&quot;), tool_table)</span>
<span class="gi">+</span>
<span class="gi">+        pylint_tool_table = tomlkit.table(is_super_table=True)</span>
<span class="gi">+        tool_table.add(tomlkit.key(&quot;pylint&quot;), pylint_tool_table)</span>
<span class="gi">+</span>
<span class="gi">+        for group in sorted(</span>
<span class="gi">+            self._arg_parser._action_groups,</span>
<span class="gi">+            key=lambda x: (x.title != &quot;Main&quot;, x.title),</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Skip the options section with the --help option</span>
<span class="gi">+            if group.title in {&quot;options&quot;, &quot;optional arguments&quot;, &quot;Commands&quot;}:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Skip sections without options such as &quot;positional arguments&quot;</span>
<span class="gi">+            if not group._group_actions:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            group_table = tomlkit.table()</span>
<span class="gi">+            option_actions = [</span>
<span class="gi">+                i</span>
<span class="gi">+                for i in group._group_actions</span>
<span class="gi">+                if not isinstance(i, argparse._SubParsersAction)</span>
<span class="gi">+            ]</span>
<span class="gi">+            for action in sorted(option_actions, key=lambda x: x.option_strings[0][2:]):</span>
<span class="gi">+                optname = action.option_strings[0][2:]</span>
<span class="gi">+</span>
<span class="gi">+                # We skip old name options that don&#39;t have their own optdict</span>
<span class="gi">+                try:</span>
<span class="gi">+                    optdict = self._option_dicts[optname]</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if optdict.get(&quot;hide_from_config_file&quot;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # Add help comment</span>
<span class="gi">+                if not minimal:</span>
<span class="gi">+                    help_msg = optdict.get(&quot;help&quot;, &quot;&quot;)</span>
<span class="gi">+                    assert isinstance(help_msg, str)</span>
<span class="gi">+                    help_text = textwrap.wrap(help_msg, width=79)</span>
<span class="gi">+                    for line in help_text:</span>
<span class="gi">+                        group_table.add(tomlkit.comment(line))</span>
<span class="gi">+</span>
<span class="gi">+                # Get current value of option</span>
<span class="gi">+                value = getattr(self.config, optname.replace(&quot;-&quot;, &quot;_&quot;))</span>
<span class="gi">+</span>
<span class="gi">+                # Create a comment if the option has no value</span>
<span class="gi">+                if not value:</span>
<span class="gi">+                    if not minimal:</span>
<span class="gi">+                        group_table.add(tomlkit.comment(f&quot;{optname} =&quot;))</span>
<span class="gi">+                        group_table.add(tomlkit.nl())</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # Skip deprecated options</span>
<span class="gi">+                if &quot;kwargs&quot; in optdict:</span>
<span class="gi">+                    assert isinstance(optdict[&quot;kwargs&quot;], dict)</span>
<span class="gi">+                    if &quot;new_names&quot; in optdict[&quot;kwargs&quot;]:</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                # Tomlkit doesn&#39;t support regular expressions</span>
<span class="gi">+                if isinstance(value, re.Pattern):</span>
<span class="gi">+                    value = value.pattern</span>
<span class="gi">+                elif isinstance(value, (list, tuple)) and isinstance(</span>
<span class="gi">+                    value[0], re.Pattern</span>
<span class="gi">+                ):</span>
<span class="gi">+                    value = [i.pattern for i in value]</span>
<span class="gi">+</span>
<span class="gi">+                # Handle tuples that should be strings</span>
<span class="gi">+                if optdict.get(&quot;type&quot;) == &quot;py_version&quot;:</span>
<span class="gi">+                    value = &quot;.&quot;.join(str(i) for i in value)</span>
<span class="gi">+</span>
<span class="gi">+                # Check if it is default value if we are in minimal mode</span>
<span class="gi">+                if minimal and value == optdict.get(&quot;default&quot;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                # Add to table</span>
<span class="gi">+                group_table.add(optname, value)</span>
<span class="gi">+                group_table.add(tomlkit.nl())</span>
<span class="gi">+</span>
<span class="gi">+            assert group.title</span>
<span class="gi">+            if group_table:</span>
<span class="gi">+                pylint_tool_table.add(group.title.lower(), group_table)</span>
<span class="gi">+</span>
<span class="gi">+        toml_string = tomlkit.dumps(toml_doc)</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure the string we produce is valid toml and can be parsed</span>
<span class="gi">+        tomllib.loads(toml_string)</span>
<span class="gi">+</span>
<span class="gi">+        return str(toml_string)</span>

<span class="gd">-    def set_option(self, optname: str, value: Any) -&gt;None:</span>
<span class="gi">+    def set_option(self, optname: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set an option on the namespace object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.config = self._arg_parser.parse_known_args(</span>
<span class="gi">+            [f&quot;--{optname.replace(&#39;_&#39;, &#39;-&#39;)}&quot;, _parse_rich_type_value(value)],</span>
<span class="gi">+            self.config,</span>
<span class="gi">+        )[0]</span>
<span class="gh">diff --git a/pylint/config/arguments_provider.py b/pylint/config/arguments_provider.py</span>
<span class="gh">index 2aa77d702..7f75718ca 100644</span>
<span class="gd">--- a/pylint/config/arguments_provider.py</span>
<span class="gi">+++ b/pylint/config/arguments_provider.py</span>
<span class="gu">@@ -1,39 +1,65 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Arguments provider class used to expose options.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Iterator
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from pylint.config.arguments_manager import _ArgumentsManager
<span class="w"> </span>from pylint.typing import OptionDict, Options


<span class="w"> </span>class _ArgumentsProvider:
<span class="w"> </span>    &quot;&quot;&quot;Base class for classes that provide arguments.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name: str
<span class="w"> </span>    &quot;&quot;&quot;Name of the provider.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    options: Options = ()
<span class="w"> </span>    &quot;&quot;&quot;Options provided by this provider.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    option_groups_descs: dict[str, str] = {}
<span class="w"> </span>    &quot;&quot;&quot;Option groups of this provider and their descriptions.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, arguments_manager: _ArgumentsManager) -&gt;None:</span>
<span class="gi">+    def __init__(self, arguments_manager: _ArgumentsManager) -&gt; None:</span>
<span class="w"> </span>        self._arguments_manager = arguments_manager
<span class="w"> </span>        &quot;&quot;&quot;The manager that will parse and register any options provided.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self._arguments_manager._register_options_provider(self)

<span class="gd">-    def _option_value(self, opt: str) -&gt;Any:</span>
<span class="gi">+    def _option_value(self, opt: str) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the current value for the given option.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return getattr(self._arguments_manager.config, opt.replace(&quot;-&quot;, &quot;_&quot;), None)</span>

<span class="gd">-    def _options_by_section(self) -&gt;Iterator[tuple[str, list[tuple[str,</span>
<span class="gd">-        OptionDict, Any]]] | tuple[None, dict[str, list[tuple[str,</span>
<span class="gd">-        OptionDict, Any]]]]]:</span>
<span class="gi">+    def _options_by_section(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; Iterator[</span>
<span class="gi">+        tuple[str, list[tuple[str, OptionDict, Any]]]</span>
<span class="gi">+        | tuple[None, dict[str, list[tuple[str, OptionDict, Any]]]]</span>
<span class="gi">+    ]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an iterator on options grouped by section.

<span class="w"> </span>        (section, [list of (optname, optdict, optvalue)])
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sections: dict[str, list[tuple[str, OptionDict, Any]]] = {}</span>
<span class="gi">+        for optname, optdict in self.options:</span>
<span class="gi">+            sections.setdefault(optdict.get(&quot;group&quot;), []).append(  # type: ignore[arg-type]</span>
<span class="gi">+                (optname, optdict, self._option_value(optname))</span>
<span class="gi">+            )</span>
<span class="gi">+        if None in sections:</span>
<span class="gi">+            yield None, sections.pop(None)  # type: ignore[call-overload]</span>
<span class="gi">+        for section, options in sorted(sections.items()):</span>
<span class="gi">+            yield section.upper(), options</span>

<span class="gd">-    def _options_and_values(self, options: (Options | None)=None) -&gt;Iterator[</span>
<span class="gd">-        tuple[str, OptionDict, Any]]:</span>
<span class="gi">+    def _options_and_values(</span>
<span class="gi">+        self, options: Options | None = None</span>
<span class="gi">+    ) -&gt; Iterator[tuple[str, OptionDict, Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;DEPRECATED.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if options is None:</span>
<span class="gi">+            options = self.options</span>
<span class="gi">+        for optname, optdict in options:</span>
<span class="gi">+            yield optname, optdict, self._option_value(optname)</span>
<span class="gh">diff --git a/pylint/config/callback_actions.py b/pylint/config/callback_actions.py</span>
<span class="gh">index 3fe67065b..bf2decd3c 100644</span>
<span class="gd">--- a/pylint/config/callback_actions.py</span>
<span class="gi">+++ b/pylint/config/callback_actions.py</span>
<span class="gu">@@ -1,12 +1,22 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=too-many-arguments, redefined-builtin, duplicate-code</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Callback actions for various options.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>import argparse
<span class="w"> </span>import sys
<span class="w"> </span>from collections.abc import Callable, Sequence
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from pylint import exceptions, extensions, interfaces, utils
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.config.help_formatter import _HelpFormatter
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gu">@@ -17,10 +27,14 @@ class _CallbackAction(argparse.Action):</span>
<span class="w"> </span>    &quot;&quot;&quot;Custom callback action.&quot;&quot;&quot;

<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gd">-        raise NotImplementedError</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>


<span class="w"> </span>class _DoNothingAction(_CallbackAction):
<span class="gu">@@ -30,44 +44,97 @@ class _DoNothingAction(_CallbackAction):</span>
<span class="w"> </span>    without erroring when they are then processed again by argparse.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        return None


<span class="w"> </span>class _AccessRunObjectAction(_CallbackAction):
<span class="w"> </span>    &quot;&quot;&quot;Action that has access to the Run object.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, option_strings: Sequence[str], dest: str, nargs:</span>
<span class="gd">-        None=None, const: None=None, default: None=None, type: None=None,</span>
<span class="gd">-        choices: None=None, required: bool=False, help: str=&#39;&#39;, metavar:</span>
<span class="gd">-        str=&#39;&#39;, **kwargs: Run) -&gt;None:</span>
<span class="gd">-        self.run = kwargs[&#39;Run&#39;]</span>
<span class="gd">-        super().__init__(option_strings, dest, 0, const, default, type,</span>
<span class="gd">-            choices, required, help, metavar)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        option_strings: Sequence[str],</span>
<span class="gi">+        dest: str,</span>
<span class="gi">+        nargs: None = None,</span>
<span class="gi">+        const: None = None,</span>
<span class="gi">+        default: None = None,</span>
<span class="gi">+        type: None = None,</span>
<span class="gi">+        choices: None = None,</span>
<span class="gi">+        required: bool = False,</span>
<span class="gi">+        help: str = &quot;&quot;,</span>
<span class="gi">+        metavar: str = &quot;&quot;,</span>
<span class="gi">+        **kwargs: Run,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.run = kwargs[&quot;Run&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            option_strings,</span>
<span class="gi">+            dest,</span>
<span class="gi">+            0,</span>
<span class="gi">+            const,</span>
<span class="gi">+            default,</span>
<span class="gi">+            type,</span>
<span class="gi">+            choices,</span>
<span class="gi">+            required,</span>
<span class="gi">+            help,</span>
<span class="gi">+            metavar,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gd">-        raise NotImplementedError</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>


<span class="w"> </span>class _MessageHelpAction(_CallbackAction):
<span class="w"> </span>    &quot;&quot;&quot;Display the help message of a message.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, option_strings: Sequence[str], dest: str, nargs:</span>
<span class="gd">-        None=None, const: None=None, default: None=None, type: None=None,</span>
<span class="gd">-        choices: None=None, required: bool=False, help: str=&#39;&#39;, metavar:</span>
<span class="gd">-        str=&#39;&#39;, **kwargs: Run) -&gt;None:</span>
<span class="gd">-        self.run = kwargs[&#39;Run&#39;]</span>
<span class="gd">-        super().__init__(option_strings, dest, &#39;+&#39;, const, default, type,</span>
<span class="gd">-            choices, required, help, metavar)</span>
<span class="gd">-</span>
<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[str] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--help-msg&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        option_strings: Sequence[str],</span>
<span class="gi">+        dest: str,</span>
<span class="gi">+        nargs: None = None,</span>
<span class="gi">+        const: None = None,</span>
<span class="gi">+        default: None = None,</span>
<span class="gi">+        type: None = None,</span>
<span class="gi">+        choices: None = None,</span>
<span class="gi">+        required: bool = False,</span>
<span class="gi">+        help: str = &quot;&quot;,</span>
<span class="gi">+        metavar: str = &quot;&quot;,</span>
<span class="gi">+        **kwargs: Run,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.run = kwargs[&quot;Run&quot;]</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            option_strings,</span>
<span class="gi">+            dest,</span>
<span class="gi">+            &quot;+&quot;,</span>
<span class="gi">+            const,</span>
<span class="gi">+            default,</span>
<span class="gi">+            type,</span>
<span class="gi">+            choices,</span>
<span class="gi">+            required,</span>
<span class="gi">+            help,</span>
<span class="gi">+            metavar,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[str] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--help-msg&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert isinstance(values, (list, tuple))
<span class="w"> </span>        values_to_print: list[str] = []
<span class="w"> </span>        for msg in values:
<span class="gu">@@ -80,9 +147,13 @@ class _MessageHelpAction(_CallbackAction):</span>
<span class="w"> </span>class _ListMessagesAction(_AccessRunObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Display all available messages.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--list-enabled&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--list-enabled&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.run.linter.msgs_store.list_messages()
<span class="w"> </span>        sys.exit(0)

<span class="gu">@@ -90,9 +161,13 @@ class _ListMessagesAction(_AccessRunObjectAction):</span>
<span class="w"> </span>class _ListMessagesEnabledAction(_AccessRunObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Display all enabled messages.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--list-msgs-enabled&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--list-msgs-enabled&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.run.linter.list_messages_enabled()
<span class="w"> </span>        sys.exit(0)

<span class="gu">@@ -100,9 +175,13 @@ class _ListMessagesEnabledAction(_AccessRunObjectAction):</span>
<span class="w"> </span>class _ListCheckGroupsAction(_AccessRunObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Display all the check groups that pylint knows about.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--list-groups&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--list-groups&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        for check in self.run.linter.get_checker_names():
<span class="w"> </span>            print(check)
<span class="w"> </span>        sys.exit(0)
<span class="gu">@@ -111,33 +190,45 @@ class _ListCheckGroupsAction(_AccessRunObjectAction):</span>
<span class="w"> </span>class _ListConfidenceLevelsAction(_AccessRunObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Display all the confidence levels that pylint knows about.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--list-conf-levels&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--list-conf-levels&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        for level in interfaces.CONFIDENCE_LEVELS:
<span class="gd">-            print(f&#39;%-18s: {level}&#39;)</span>
<span class="gi">+            print(f&quot;%-18s: {level}&quot;)</span>
<span class="w"> </span>        sys.exit(0)


<span class="w"> </span>class _ListExtensionsAction(_AccessRunObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Display all extensions under pylint.extensions.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--list-extensions&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--list-extensions&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        for filename in Path(extensions.__file__).parent.iterdir():
<span class="gd">-            if filename.suffix == &#39;.py&#39; and not filename.stem.startswith(&#39;_&#39;):</span>
<span class="gd">-                extension_name, _, _ = filename.stem.partition(&#39;.&#39;)</span>
<span class="gd">-                print(f&#39;pylint.extensions.{extension_name}&#39;)</span>
<span class="gi">+            if filename.suffix == &quot;.py&quot; and not filename.stem.startswith(&quot;_&quot;):</span>
<span class="gi">+                extension_name, _, _ = filename.stem.partition(&quot;.&quot;)</span>
<span class="gi">+                print(f&quot;pylint.extensions.{extension_name}&quot;)</span>
<span class="w"> </span>        sys.exit(0)


<span class="w"> </span>class _FullDocumentationAction(_AccessRunObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Display the full documentation.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--full-documentation&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--full-documentation&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        utils.print_full_documentation(self.run.linter)
<span class="w"> </span>        sys.exit(0)

<span class="gu">@@ -145,19 +236,29 @@ class _FullDocumentationAction(_AccessRunObjectAction):</span>
<span class="w"> </span>class _GenerateRCFileAction(_AccessRunObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Generate a pylintrc file.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--generate-rcfile&#39;) -&gt;None:</span>
<span class="gd">-        self.run.linter._generate_config(skipsections=(&#39;Commands&#39;,))</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--generate-rcfile&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # TODO: 4.x: Deprecate this after the auto-upgrade functionality of</span>
<span class="gi">+        # pylint-config is sufficient.</span>
<span class="gi">+        self.run.linter._generate_config(skipsections=(&quot;Commands&quot;,))</span>
<span class="w"> </span>        sys.exit(0)


<span class="w"> </span>class _GenerateConfigFileAction(_AccessRunObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Generate a .toml format configuration file.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--generate-toml-config&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--generate-toml-config&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        print(self.run.linter._generate_config_file())
<span class="w"> </span>        sys.exit(0)

<span class="gu">@@ -173,96 +274,195 @@ class _ErrorsOnlyModeAction(_AccessRunObjectAction):</span>
<span class="w"> </span>        * do not save execution information
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--errors-only&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--errors-only&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.run.linter._error_mode = True


<span class="w"> </span>class _LongHelpAction(_AccessRunObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Display the long help message.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--long-help&#39;) -&gt;None:</span>
<span class="gd">-        formatter: _HelpFormatter = self.run.linter._arg_parser._get_formatter(</span>
<span class="gd">-            )</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--long-help&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        formatter: _HelpFormatter = self.run.linter._arg_parser._get_formatter()  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+        # Add extra info as epilog to the help message</span>
<span class="w"> </span>        self.run.linter._arg_parser.epilog = formatter.get_long_description()
<span class="w"> </span>        print(self.run.linter.help())
<span class="gi">+</span>
<span class="w"> </span>        sys.exit(0)


<span class="w"> </span>class _AccessLinterObjectAction(_CallbackAction):
<span class="w"> </span>    &quot;&quot;&quot;Action that has access to the Linter object.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, option_strings: Sequence[str], dest: str, nargs:</span>
<span class="gd">-        None=None, const: None=None, default: None=None, type: None=None,</span>
<span class="gd">-        choices: None=None, required: bool=False, help: str=&#39;&#39;, metavar:</span>
<span class="gd">-        str=&#39;&#39;, **kwargs: PyLinter) -&gt;None:</span>
<span class="gd">-        self.linter = kwargs[&#39;linter&#39;]</span>
<span class="gd">-        super().__init__(option_strings, dest, 1, const, default, type,</span>
<span class="gd">-            choices, required, help, metavar)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        option_strings: Sequence[str],</span>
<span class="gi">+        dest: str,</span>
<span class="gi">+        nargs: None = None,</span>
<span class="gi">+        const: None = None,</span>
<span class="gi">+        default: None = None,</span>
<span class="gi">+        type: None = None,</span>
<span class="gi">+        choices: None = None,</span>
<span class="gi">+        required: bool = False,</span>
<span class="gi">+        help: str = &quot;&quot;,</span>
<span class="gi">+        metavar: str = &quot;&quot;,</span>
<span class="gi">+        **kwargs: PyLinter,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.linter = kwargs[&quot;linter&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            option_strings,</span>
<span class="gi">+            dest,</span>
<span class="gi">+            1,</span>
<span class="gi">+            const,</span>
<span class="gi">+            default,</span>
<span class="gi">+            type,</span>
<span class="gi">+            choices,</span>
<span class="gi">+            required,</span>
<span class="gi">+            help,</span>
<span class="gi">+            metavar,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gd">-        raise NotImplementedError</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>


<span class="w"> </span>class _XableAction(_AccessLinterObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Callback action for enabling or disabling a message.&quot;&quot;&quot;

<span class="gi">+    def _call(</span>
<span class="gi">+        self,</span>
<span class="gi">+        xabling_function: Callable[[str], None],</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        assert isinstance(values, (tuple, list))</span>
<span class="gi">+        for msgid in utils._check_csv(values[0]):</span>
<span class="gi">+            try:</span>
<span class="gi">+                xabling_function(msgid)</span>
<span class="gi">+            except (</span>
<span class="gi">+                exceptions.DeletedMessageError,</span>
<span class="gi">+                exceptions.MessageBecameExtensionError,</span>
<span class="gi">+            ) as e:</span>
<span class="gi">+                self.linter._stashed_messages[</span>
<span class="gi">+                    (self.linter.current_name, &quot;useless-option-value&quot;)</span>
<span class="gi">+                ].append((option_string, str(e)))</span>
<span class="gi">+            except exceptions.UnknownMessageError:</span>
<span class="gi">+                self.linter._stashed_messages[</span>
<span class="gi">+                    (self.linter.current_name, &quot;unknown-option-value&quot;)</span>
<span class="gi">+                ].append((option_string, msgid))</span>
<span class="gi">+</span>
<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--disable&#39;) -&gt;None:</span>
<span class="gd">-        raise NotImplementedError</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--disable&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>


<span class="w"> </span>class _DisableAction(_XableAction):
<span class="w"> </span>    &quot;&quot;&quot;Callback action for disabling a message.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--disable&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--disable&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._call(self.linter.disable, values, option_string)


<span class="w"> </span>class _EnableAction(_XableAction):
<span class="w"> </span>    &quot;&quot;&quot;Callback action for enabling a message.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--enable&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--enable&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._call(self.linter.enable, values, option_string)


<span class="w"> </span>class _OutputFormatAction(_AccessLinterObjectAction):
<span class="w"> </span>    &quot;&quot;&quot;Callback action for setting the output format.&quot;&quot;&quot;

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=&#39;--enable&#39;) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = &quot;--enable&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert isinstance(values, (tuple, list))
<span class="gd">-        assert isinstance(values[0], str</span>
<span class="gd">-            ), &quot;&#39;output-format&#39; should be a comma separated string of reporters&quot;</span>
<span class="gi">+        assert isinstance(</span>
<span class="gi">+            values[0], str</span>
<span class="gi">+        ), &quot;&#39;output-format&#39; should be a comma separated string of reporters&quot;</span>
<span class="w"> </span>        self.linter._load_reporters(values[0])


<span class="w"> </span>class _AccessParserAction(_CallbackAction):
<span class="w"> </span>    &quot;&quot;&quot;Action that has access to the ArgumentParser object.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, option_strings: Sequence[str], dest: str, nargs:</span>
<span class="gd">-        None=None, const: None=None, default: None=None, type: None=None,</span>
<span class="gd">-        choices: None=None, required: bool=False, help: str=&#39;&#39;, metavar:</span>
<span class="gd">-        str=&#39;&#39;, **kwargs: argparse.ArgumentParser) -&gt;None:</span>
<span class="gd">-        self.parser = kwargs[&#39;parser&#39;]</span>
<span class="gd">-        super().__init__(option_strings, dest, 0, const, default, type,</span>
<span class="gd">-            choices, required, help, metavar)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        option_strings: Sequence[str],</span>
<span class="gi">+        dest: str,</span>
<span class="gi">+        nargs: None = None,</span>
<span class="gi">+        const: None = None,</span>
<span class="gi">+        default: None = None,</span>
<span class="gi">+        type: None = None,</span>
<span class="gi">+        choices: None = None,</span>
<span class="gi">+        required: bool = False,</span>
<span class="gi">+        help: str = &quot;&quot;,</span>
<span class="gi">+        metavar: str = &quot;&quot;,</span>
<span class="gi">+        **kwargs: argparse.ArgumentParser,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.parser = kwargs[&quot;parser&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            option_strings,</span>
<span class="gi">+            dest,</span>
<span class="gi">+            0,</span>
<span class="gi">+            const,</span>
<span class="gi">+            default,</span>
<span class="gi">+            type,</span>
<span class="gi">+            choices,</span>
<span class="gi">+            required,</span>
<span class="gi">+            help,</span>
<span class="gi">+            metavar,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @abc.abstractmethod
<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gd">-        raise NotImplementedError</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError  # pragma: no cover</span>
<span class="gh">diff --git a/pylint/config/config_file_parser.py b/pylint/config/config_file_parser.py</span>
<span class="gh">index 1f6cefb0d..efc085e59 100644</span>
<span class="gd">--- a/pylint/config/config_file_parser.py</span>
<span class="gi">+++ b/pylint/config/config_file_parser.py</span>
<span class="gu">@@ -1,17 +1,27 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Configuration file parser class.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import configparser
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Dict, List, Tuple
<span class="gi">+</span>
<span class="w"> </span>from pylint.config.utils import _parse_rich_type_value
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 11):
<span class="w"> </span>    import tomllib
<span class="w"> </span>else:
<span class="w"> </span>    import tomli as tomllib
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="w"> </span>PylintConfigFileData = Tuple[Dict[str, str], List[str]]


<span class="gu">@@ -19,44 +29,101 @@ class _RawConfParser:</span>
<span class="w"> </span>    &quot;&quot;&quot;Class to parse various formats of configuration files.&quot;&quot;&quot;

<span class="w"> </span>    @staticmethod
<span class="gd">-    def parse_ini_file(file_path: Path) -&gt;PylintConfigFileData:</span>
<span class="gi">+    def parse_ini_file(file_path: Path) -&gt; PylintConfigFileData:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse and handle errors of an ini configuration file.

<span class="w"> </span>        Raises ``configparser.Error``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser = configparser.ConfigParser(inline_comment_prefixes=(&quot;#&quot;, &quot;;&quot;))</span>
<span class="gi">+        # Use this encoding in order to strip the BOM marker, if any.</span>
<span class="gi">+        with open(file_path, encoding=&quot;utf_8_sig&quot;) as fp:</span>
<span class="gi">+            parser.read_file(fp)</span>
<span class="gi">+</span>
<span class="gi">+        config_content: dict[str, str] = {}</span>
<span class="gi">+        options: list[str] = []</span>
<span class="gi">+        ini_file_with_sections = _RawConfParser._ini_file_with_sections(file_path)</span>
<span class="gi">+        for section in parser.sections():</span>
<span class="gi">+            if ini_file_with_sections and not section.startswith(&quot;pylint&quot;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            for option, value in parser[section].items():</span>
<span class="gi">+                config_content[option] = value</span>
<span class="gi">+                options += [f&quot;--{option}&quot;, value]</span>
<span class="gi">+        return config_content, options</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _ini_file_with_sections(file_path: Path) -&gt;bool:</span>
<span class="gi">+    def _ini_file_with_sections(file_path: Path) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return whether the file uses sections.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &quot;setup.cfg&quot; in file_path.parts:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if &quot;tox.ini&quot; in file_path.parts:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def parse_toml_file(file_path: Path) -&gt;PylintConfigFileData:</span>
<span class="gi">+    def parse_toml_file(file_path: Path) -&gt; PylintConfigFileData:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse and handle errors of a toml configuration file.

<span class="w"> </span>        Raises ``tomllib.TOMLDecodeError``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(file_path, mode=&quot;rb&quot;) as fp:</span>
<span class="gi">+            content = tomllib.load(fp)</span>
<span class="gi">+        try:</span>
<span class="gi">+            sections_values = content[&quot;tool&quot;][&quot;pylint&quot;]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return {}, []</span>
<span class="gi">+</span>
<span class="gi">+        config_content: dict[str, str] = {}</span>
<span class="gi">+        options: list[str] = []</span>
<span class="gi">+        for opt, values in sections_values.items():</span>
<span class="gi">+            if isinstance(values, dict):</span>
<span class="gi">+                for config, value in values.items():</span>
<span class="gi">+                    value = _parse_rich_type_value(value)</span>
<span class="gi">+                    config_content[config] = value</span>
<span class="gi">+                    options += [f&quot;--{config}&quot;, value]</span>
<span class="gi">+            else:</span>
<span class="gi">+                values = _parse_rich_type_value(values)</span>
<span class="gi">+                config_content[opt] = values</span>
<span class="gi">+                options += [f&quot;--{opt}&quot;, values]</span>
<span class="gi">+        return config_content, options</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def parse_config_file(file_path: (Path | None), verbose: bool</span>
<span class="gd">-        ) -&gt;PylintConfigFileData:</span>
<span class="gi">+    def parse_config_file(</span>
<span class="gi">+        file_path: Path | None, verbose: bool</span>
<span class="gi">+    ) -&gt; PylintConfigFileData:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse a config file and return str-str pairs.

<span class="w"> </span>        Raises ``tomllib.TOMLDecodeError``, ``configparser.Error``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if file_path is None:</span>
<span class="gi">+            if verbose:</span>
<span class="gi">+                print(</span>
<span class="gi">+                    &quot;No config file found, using default configuration&quot;, file=sys.stderr</span>
<span class="gi">+                )</span>
<span class="gi">+            return {}, []</span>
<span class="gi">+</span>
<span class="gi">+        file_path = Path(os.path.expandvars(file_path)).expanduser()</span>
<span class="gi">+        if not file_path.exists():</span>
<span class="gi">+            raise OSError(f&quot;The config file {file_path} doesn&#39;t exist!&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if verbose:</span>
<span class="gi">+            print(f&quot;Using config file {file_path}&quot;, file=sys.stderr)</span>
<span class="gi">+</span>
<span class="gi">+        if file_path.suffix == &quot;.toml&quot;:</span>
<span class="gi">+            return _RawConfParser.parse_toml_file(file_path)</span>
<span class="gi">+        return _RawConfParser.parse_ini_file(file_path)</span>


<span class="w"> </span>class _ConfigurationFileParser:
<span class="w"> </span>    &quot;&quot;&quot;Class to parse various formats of configuration files.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, verbose: bool, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, verbose: bool, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        self.verbose_mode = verbose
<span class="w"> </span>        self.linter = linter

<span class="gd">-    def parse_config_file(self, file_path: (Path | None)</span>
<span class="gd">-        ) -&gt;PylintConfigFileData:</span>
<span class="gi">+    def parse_config_file(self, file_path: Path | None) -&gt; PylintConfigFileData:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse a config file and return str-str pairs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _RawConfParser.parse_config_file(file_path, self.verbose_mode)</span>
<span class="gi">+        except (configparser.Error, tomllib.TOMLDecodeError) as e:</span>
<span class="gi">+            self.linter.add_message(&quot;config-parse-error&quot;, line=0, args=str(e))</span>
<span class="gi">+            return {}, []</span>
<span class="gh">diff --git a/pylint/config/config_initialization.py b/pylint/config/config_initialization.py</span>
<span class="gh">index 526dbe95e..9656ea564 100644</span>
<span class="gd">--- a/pylint/config/config_initialization.py</span>
<span class="gi">+++ b/pylint/config/config_initialization.py</span>
<span class="gu">@@ -1,29 +1,163 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from glob import glob
<span class="w"> </span>from itertools import chain
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from pylint import reporters
<span class="w"> </span>from pylint.config.config_file_parser import _ConfigurationFileParser
<span class="gd">-from pylint.config.exceptions import ArgumentPreprocessingError, _UnrecognizedOptionError</span>
<span class="gi">+from pylint.config.exceptions import (</span>
<span class="gi">+    ArgumentPreprocessingError,</span>
<span class="gi">+    _UnrecognizedOptionError,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.utils import utils
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="gd">-def _config_initialization(linter: PyLinter, args_list: list[str], reporter:</span>
<span class="gd">-    (reporters.BaseReporter | reporters.MultiReporter | None)=None,</span>
<span class="gd">-    config_file: (None | str | Path)=None, verbose_mode: bool=False) -&gt;list[str</span>
<span class="gd">-    ]:</span>
<span class="gi">+def _config_initialization(</span>
<span class="gi">+    linter: PyLinter,</span>
<span class="gi">+    args_list: list[str],</span>
<span class="gi">+    reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,</span>
<span class="gi">+    config_file: None | str | Path = None,</span>
<span class="gi">+    verbose_mode: bool = False,</span>
<span class="gi">+) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse all available options, read config files and command line arguments and
<span class="w"> </span>    set options accordingly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    config_file = Path(config_file) if config_file else None</span>
<span class="gi">+</span>
<span class="gi">+    # Set the current module to the configuration file</span>
<span class="gi">+    # to allow raising messages on the configuration file.</span>
<span class="gi">+    linter.set_current_module(str(config_file) if config_file else &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Read the configuration file</span>
<span class="gi">+    config_file_parser = _ConfigurationFileParser(verbose_mode, linter)</span>
<span class="gi">+    try:</span>
<span class="gi">+        config_data, config_args = config_file_parser.parse_config_file(</span>
<span class="gi">+            file_path=config_file</span>
<span class="gi">+        )</span>
<span class="gi">+    except OSError as ex:</span>
<span class="gi">+        print(ex, file=sys.stderr)</span>
<span class="gi">+        sys.exit(32)</span>
<span class="gi">+</span>
<span class="gi">+    # Order --enable=all or --disable=all to come first.</span>
<span class="gi">+    config_args = _order_all_first(config_args, joined=False)</span>
<span class="gi">+</span>
<span class="gi">+    # Run init hook, if present, before loading plugins</span>
<span class="gi">+    if &quot;init-hook&quot; in config_data:</span>
<span class="gi">+        exec(utils._unquote(config_data[&quot;init-hook&quot;]))  # pylint: disable=exec-used</span>
<span class="gi">+</span>
<span class="gi">+    # Load plugins if specified in the config file</span>
<span class="gi">+    if &quot;load-plugins&quot; in config_data:</span>
<span class="gi">+        linter.load_plugin_modules(utils._splitstrip(config_data[&quot;load-plugins&quot;]))</span>
<span class="gi">+</span>
<span class="gi">+    unrecognized_options_message = None</span>
<span class="gi">+    # First we parse any options from a configuration file</span>
<span class="gi">+    try:</span>
<span class="gi">+        linter._parse_configuration_file(config_args)</span>
<span class="gi">+    except _UnrecognizedOptionError as exc:</span>
<span class="gi">+        unrecognized_options_message = &quot;, &quot;.join(exc.options)</span>
<span class="gi">+</span>
<span class="gi">+    # Then, if a custom reporter is provided as argument, it may be overridden</span>
<span class="gi">+    # by file parameters, so we re-set it here. We do this before command line</span>
<span class="gi">+    # parsing, so it&#39;s still overridable by command line options</span>
<span class="gi">+    if reporter:</span>
<span class="gi">+        linter.set_reporter(reporter)</span>
<span class="gi">+</span>
<span class="gi">+    # Set the current module to the command line</span>
<span class="gi">+    # to allow raising messages on it</span>
<span class="gi">+    linter.set_current_module(&quot;Command line&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Now we parse any options from the command line, so they can override</span>
<span class="gi">+    # the configuration file</span>
<span class="gi">+    args_list = _order_all_first(args_list, joined=True)</span>
<span class="gi">+    parsed_args_list = linter._parse_command_line_configuration(args_list)</span>
<span class="gi">+</span>
<span class="gi">+    # Remove the positional arguments separator from the list of arguments if it exists</span>
<span class="gi">+    try:</span>
<span class="gi">+        parsed_args_list.remove(&quot;--&quot;)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Check if there are any options that we do not recognize</span>
<span class="gi">+    unrecognized_options: list[str] = []</span>
<span class="gi">+    for opt in parsed_args_list:</span>
<span class="gi">+        if opt.startswith(&quot;--&quot;):</span>
<span class="gi">+            unrecognized_options.append(opt[2:])</span>
<span class="gi">+        elif opt.startswith(&quot;-&quot;):</span>
<span class="gi">+            unrecognized_options.append(opt[1:])</span>
<span class="gi">+    if unrecognized_options:</span>
<span class="gi">+        msg = &quot;, &quot;.join(unrecognized_options)</span>
<span class="gi">+        try:</span>
<span class="gi">+            linter._arg_parser.error(f&quot;Unrecognized option found: {msg}&quot;)</span>
<span class="gi">+        except SystemExit:</span>
<span class="gi">+            sys.exit(32)</span>
<span class="gi">+</span>
<span class="gi">+    # Now that config file and command line options have been loaded</span>
<span class="gi">+    # with all disables, it is safe to emit messages</span>
<span class="gi">+    if unrecognized_options_message is not None:</span>
<span class="gi">+        linter.set_current_module(str(config_file) if config_file else &quot;&quot;)</span>
<span class="gi">+        linter.add_message(</span>
<span class="gi">+            &quot;unrecognized-option&quot;, args=unrecognized_options_message, line=0</span>
<span class="gi">+        )</span>

<span class="gi">+    # TODO: Change this to be checked only when upgrading the configuration</span>
<span class="gi">+    for exc_name in linter.config.overgeneral_exceptions:</span>
<span class="gi">+        if &quot;.&quot; not in exc_name:</span>
<span class="gi">+            warnings.warn_explicit(</span>
<span class="gi">+                f&quot;&#39;{exc_name}&#39; is not a proper value for the &#39;overgeneral-exceptions&#39; option. &quot;</span>
<span class="gi">+                f&quot;Use fully qualified name (maybe &#39;builtins.{exc_name}&#39; ?) instead. &quot;</span>
<span class="gi">+                &quot;This will cease to be checked at runtime when the configuration &quot;</span>
<span class="gi">+                &quot;upgrader is released.&quot;,</span>
<span class="gi">+                category=UserWarning,</span>
<span class="gi">+                filename=&quot;pylint: Command line or configuration file&quot;,</span>
<span class="gi">+                lineno=1,</span>
<span class="gi">+                module=&quot;pylint&quot;,</span>
<span class="gi">+            )</span>

<span class="gd">-def _order_all_first(config_args: list[str], *, joined: bool) -&gt;list[str]:</span>
<span class="gi">+    linter._emit_stashed_messages()</span>
<span class="gi">+</span>
<span class="gi">+    # Set the current module to configuration as we don&#39;t know where</span>
<span class="gi">+    # the --load-plugins key is coming from</span>
<span class="gi">+    linter.set_current_module(&quot;Command line or configuration file&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # We have loaded configuration from config file and command line. Now, we can</span>
<span class="gi">+    # load plugin specific configuration.</span>
<span class="gi">+    linter.load_plugin_configuration()</span>
<span class="gi">+</span>
<span class="gi">+    # Now that plugins are loaded, get list of all fail_on messages, and</span>
<span class="gi">+    # enable them</span>
<span class="gi">+    linter.enable_fail_on_messages()</span>
<span class="gi">+</span>
<span class="gi">+    linter._parse_error_mode()</span>
<span class="gi">+</span>
<span class="gi">+    # Link the base Namespace object on the current directory</span>
<span class="gi">+    linter._directory_namespaces[Path().resolve()] = (linter.config, {})</span>
<span class="gi">+</span>
<span class="gi">+    # parsed_args_list should now only be a list of inputs to lint.</span>
<span class="gi">+    # All other options have been removed from the list.</span>
<span class="gi">+    return list(</span>
<span class="gi">+        chain.from_iterable(</span>
<span class="gi">+            # NOTE: &#39;or [arg]&#39; is needed in the case the input file or directory does</span>
<span class="gi">+            # not exist and &#39;glob(arg)&#39; cannot find anything. Without this we would</span>
<span class="gi">+            # not be able to output the fatal import error for this module later on,</span>
<span class="gi">+            # as it would get silently ignored.</span>
<span class="gi">+            glob(arg, recursive=True) or [arg]</span>
<span class="gi">+            for arg in parsed_args_list</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _order_all_first(config_args: list[str], *, joined: bool) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Reorder config_args such that --enable=all or --disable=all comes first.

<span class="w"> </span>    Raise if both are given.
<span class="gu">@@ -31,4 +165,38 @@ def _order_all_first(config_args: list[str], *, joined: bool) -&gt;list[str]:</span>
<span class="w"> </span>    If joined is True, expect args in the form &#39;--enable=all,for-any-all&#39;.
<span class="w"> </span>    If joined is False, expect args in the form &#39;--enable&#39;, &#39;all,for-any-all&#39;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    indexes_to_prepend = []</span>
<span class="gi">+    all_action = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    for i, arg in enumerate(config_args):</span>
<span class="gi">+        if joined and arg.startswith((&quot;--enable=&quot;, &quot;--disable=&quot;)):</span>
<span class="gi">+            value = arg.split(&quot;=&quot;)[1]</span>
<span class="gi">+        elif arg in {&quot;--enable&quot;, &quot;--disable&quot;}:</span>
<span class="gi">+            value = config_args[i + 1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;all&quot; not in (msg.strip() for msg in value.split(&quot;,&quot;)):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        arg = arg.split(&quot;=&quot;)[0]</span>
<span class="gi">+        if all_action and (arg != all_action):</span>
<span class="gi">+            raise ArgumentPreprocessingError(</span>
<span class="gi">+                &quot;--enable=all and --disable=all are incompatible.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        all_action = arg</span>
<span class="gi">+</span>
<span class="gi">+        indexes_to_prepend.append(i)</span>
<span class="gi">+        if not joined:</span>
<span class="gi">+            indexes_to_prepend.append(i + 1)</span>
<span class="gi">+</span>
<span class="gi">+    returned_args = []</span>
<span class="gi">+    for i in indexes_to_prepend:</span>
<span class="gi">+        returned_args.append(config_args[i])</span>
<span class="gi">+</span>
<span class="gi">+    for i, arg in enumerate(config_args):</span>
<span class="gi">+        if i in indexes_to_prepend:</span>
<span class="gi">+            continue</span>
<span class="gi">+        returned_args.append(arg)</span>
<span class="gi">+</span>
<span class="gi">+    return returned_args</span>
<span class="gh">diff --git a/pylint/config/deprecation_actions.py b/pylint/config/deprecation_actions.py</span>
<span class="gh">index 442ad474c..85a77cc78 100644</span>
<span class="gd">--- a/pylint/config/deprecation_actions.py</span>
<span class="gi">+++ b/pylint/config/deprecation_actions.py</span>
<span class="gu">@@ -1,5 +1,13 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=too-many-arguments, redefined-builtin</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Deprecated option actions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import warnings
<span class="w"> </span>from collections.abc import Sequence
<span class="gu">@@ -9,18 +17,42 @@ from typing import Any</span>
<span class="w"> </span>class _OldNamesAction(argparse._StoreAction):
<span class="w"> </span>    &quot;&quot;&quot;Store action that also sets the value to old names.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, option_strings: Sequence[str], dest: str, nargs:</span>
<span class="gd">-        None=None, const: None=None, default: None=None, type: None=None,</span>
<span class="gd">-        choices: None=None, required: bool=False, help: str=&#39;&#39;, metavar:</span>
<span class="gd">-        str=&#39;&#39;, old_names: (list[str] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        option_strings: Sequence[str],</span>
<span class="gi">+        dest: str,</span>
<span class="gi">+        nargs: None = None,</span>
<span class="gi">+        const: None = None,</span>
<span class="gi">+        default: None = None,</span>
<span class="gi">+        type: None = None,</span>
<span class="gi">+        choices: None = None,</span>
<span class="gi">+        required: bool = False,</span>
<span class="gi">+        help: str = &quot;&quot;,</span>
<span class="gi">+        metavar: str = &quot;&quot;,</span>
<span class="gi">+        old_names: list[str] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert old_names
<span class="w"> </span>        self.old_names = old_names
<span class="gd">-        super().__init__(option_strings, dest, 1, const, default, type,</span>
<span class="gd">-            choices, required, help, metavar)</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            option_strings,</span>
<span class="gi">+            dest,</span>
<span class="gi">+            1,</span>
<span class="gi">+            const,</span>
<span class="gi">+            default,</span>
<span class="gi">+            type,</span>
<span class="gi">+            choices,</span>
<span class="gi">+            required,</span>
<span class="gi">+            help,</span>
<span class="gi">+            metavar,</span>
<span class="gi">+        )</span>

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert isinstance(values, list)
<span class="w"> </span>        setattr(namespace, self.dest, values[0])
<span class="w"> </span>        for old_name in self.old_names:
<span class="gu">@@ -30,20 +62,47 @@ class _OldNamesAction(argparse._StoreAction):</span>
<span class="w"> </span>class _NewNamesAction(argparse._StoreAction):
<span class="w"> </span>    &quot;&quot;&quot;Store action that also emits a deprecation warning about a new name.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, option_strings: Sequence[str], dest: str, nargs:</span>
<span class="gd">-        None=None, const: None=None, default: None=None, type: None=None,</span>
<span class="gd">-        choices: None=None, required: bool=False, help: str=&#39;&#39;, metavar:</span>
<span class="gd">-        str=&#39;&#39;, new_names: (list[str] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        option_strings: Sequence[str],</span>
<span class="gi">+        dest: str,</span>
<span class="gi">+        nargs: None = None,</span>
<span class="gi">+        const: None = None,</span>
<span class="gi">+        default: None = None,</span>
<span class="gi">+        type: None = None,</span>
<span class="gi">+        choices: None = None,</span>
<span class="gi">+        required: bool = False,</span>
<span class="gi">+        help: str = &quot;&quot;,</span>
<span class="gi">+        metavar: str = &quot;&quot;,</span>
<span class="gi">+        new_names: list[str] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert new_names
<span class="w"> </span>        self.new_names = new_names
<span class="gd">-        super().__init__(option_strings, dest, 1, const, default, type,</span>
<span class="gd">-            choices, required, help, metavar)</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            option_strings,</span>
<span class="gi">+            dest,</span>
<span class="gi">+            1,</span>
<span class="gi">+            const,</span>
<span class="gi">+            default,</span>
<span class="gi">+            type,</span>
<span class="gi">+            choices,</span>
<span class="gi">+            required,</span>
<span class="gi">+            help,</span>
<span class="gi">+            metavar,</span>
<span class="gi">+        )</span>

<span class="gd">-    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse</span>
<span class="gd">-        .Namespace, values: (str | Sequence[Any] | None), option_string: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parser: argparse.ArgumentParser,</span>
<span class="gi">+        namespace: argparse.Namespace,</span>
<span class="gi">+        values: str | Sequence[Any] | None,</span>
<span class="gi">+        option_string: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert isinstance(values, list)
<span class="w"> </span>        setattr(namespace, self.dest, values[0])
<span class="w"> </span>        warnings.warn(
<span class="gd">-            f&quot;{self.option_strings[0]} has been deprecated. Please look into using any of the following options: {&#39;, &#39;.join(self.new_names)}.&quot;</span>
<span class="gd">-            , DeprecationWarning, stacklevel=2)</span>
<span class="gi">+            f&quot;{self.option_strings[0]} has been deprecated. Please look into &quot;</span>
<span class="gi">+            f&quot;using any of the following options: {&#39;, &#39;.join(self.new_names)}.&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/pylint/config/exceptions.py b/pylint/config/exceptions.py</span>
<span class="gh">index 9b05b9670..982e3f494 100644</span>
<span class="gd">--- a/pylint/config/exceptions.py</span>
<span class="gi">+++ b/pylint/config/exceptions.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations


<span class="gu">@@ -12,7 +16,7 @@ class _UnrecognizedOptionError(Exception):</span>
<span class="w"> </span>    unknown.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, options: list[str], *args: object) -&gt;None:</span>
<span class="gi">+    def __init__(self, options: list[str], *args: object) -&gt; None:</span>
<span class="w"> </span>        self.options = options
<span class="w"> </span>        super().__init__(*args)

<span class="gh">diff --git a/pylint/config/find_default_config_files.py b/pylint/config/find_default_config_files.py</span>
<span class="gh">index feee8e083..346393cf9 100644</span>
<span class="gd">--- a/pylint/config/find_default_config_files.py</span>
<span class="gi">+++ b/pylint/config/find_default_config_files.py</span>
<span class="gu">@@ -1,45 +1,144 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import configparser
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from collections.abc import Iterator
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 11):
<span class="w"> </span>    import tomllib
<span class="w"> </span>else:
<span class="w"> </span>    import tomli as tomllib
<span class="gd">-RC_NAMES = Path(&#39;pylintrc&#39;), Path(&#39;pylintrc.toml&#39;), Path(&#39;.pylintrc&#39;), Path(</span>
<span class="gd">-    &#39;.pylintrc.toml&#39;)</span>
<span class="gd">-PYPROJECT_NAME = Path(&#39;pyproject.toml&#39;)</span>
<span class="gd">-CONFIG_NAMES = *RC_NAMES, PYPROJECT_NAME, Path(&#39;setup.cfg&#39;)</span>
<span class="gi">+</span>
<span class="gi">+RC_NAMES = (</span>
<span class="gi">+    Path(&quot;pylintrc&quot;),</span>
<span class="gi">+    Path(&quot;pylintrc.toml&quot;),</span>
<span class="gi">+    Path(&quot;.pylintrc&quot;),</span>
<span class="gi">+    Path(&quot;.pylintrc.toml&quot;),</span>
<span class="gi">+)</span>
<span class="gi">+PYPROJECT_NAME = Path(&quot;pyproject.toml&quot;)</span>
<span class="gi">+CONFIG_NAMES = (*RC_NAMES, PYPROJECT_NAME, Path(&quot;setup.cfg&quot;))</span>


<span class="gd">-def _find_pyproject() -&gt;Path:</span>
<span class="gi">+def _find_pyproject() -&gt; Path:</span>
<span class="w"> </span>    &quot;&quot;&quot;Search for file pyproject.toml in the parent directories recursively.

<span class="w"> </span>    It resolves symlinks, so if there is any symlink up in the tree, it does not respect them
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    current_dir = Path.cwd().resolve()</span>
<span class="gi">+    is_root = False</span>
<span class="gi">+    while not is_root:</span>
<span class="gi">+        if (current_dir / PYPROJECT_NAME).is_file():</span>
<span class="gi">+            return current_dir / PYPROJECT_NAME</span>
<span class="gi">+        is_root = (</span>
<span class="gi">+            current_dir == current_dir.parent</span>
<span class="gi">+            or (current_dir / &quot;.git&quot;).is_dir()</span>
<span class="gi">+            or (current_dir / &quot;.hg&quot;).is_dir()</span>
<span class="gi">+        )</span>
<span class="gi">+        current_dir = current_dir.parent</span>
<span class="gi">+</span>
<span class="gi">+    return current_dir</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _toml_has_config(path: Path | str) -&gt; bool:</span>
<span class="gi">+    with open(path, mode=&quot;rb&quot;) as toml_handle:</span>
<span class="gi">+        try:</span>
<span class="gi">+            content = tomllib.load(toml_handle)</span>
<span class="gi">+        except tomllib.TOMLDecodeError as error:</span>
<span class="gi">+            print(f&quot;Failed to load &#39;{path}&#39;: {error}&quot;)</span>
<span class="gi">+            return False</span>
<span class="gi">+    return &quot;pylint&quot; in content.get(&quot;tool&quot;, [])</span>
<span class="gi">+</span>

<span class="gi">+def _cfg_has_config(path: Path | str) -&gt; bool:</span>
<span class="gi">+    parser = configparser.ConfigParser()</span>
<span class="gi">+    try:</span>
<span class="gi">+        parser.read(path, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+    except configparser.Error:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return any(section.startswith(&quot;pylint.&quot;) for section in parser.sections())</span>

<span class="gd">-def _yield_default_files() -&gt;Iterator[Path]:</span>
<span class="gi">+</span>
<span class="gi">+def _yield_default_files() -&gt; Iterator[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Iterate over the default config file names and see if they exist.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for config_name in CONFIG_NAMES:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if config_name.is_file():</span>
<span class="gi">+                if config_name.suffix == &quot;.toml&quot; and not _toml_has_config(config_name):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if config_name.suffix == &quot;.cfg&quot; and not _cfg_has_config(config_name):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                yield config_name.resolve()</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            pass</span>


<span class="gd">-def _find_project_config() -&gt;Iterator[Path]:</span>
<span class="gi">+def _find_project_config() -&gt; Iterator[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Traverse up the directory tree to find a config file.

<span class="w"> </span>    Stop if no &#39;__init__&#39; is found and thus we are no longer in a package.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if Path(&quot;__init__.py&quot;).is_file():</span>
<span class="gi">+        curdir = Path(os.getcwd()).resolve()</span>
<span class="gi">+        while (curdir / &quot;__init__.py&quot;).is_file():</span>
<span class="gi">+            curdir = curdir.parent</span>
<span class="gi">+            for rc_name in RC_NAMES:</span>
<span class="gi">+                rc_path = curdir / rc_name</span>
<span class="gi">+                if rc_path.is_file():</span>
<span class="gi">+                    yield rc_path.resolve()</span>


<span class="gd">-def _find_config_in_home_or_environment() -&gt;Iterator[Path]:</span>
<span class="gi">+def _find_config_in_home_or_environment() -&gt; Iterator[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find a config file in the specified environment var or the home directory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;PYLINTRC&quot; in os.environ and Path(os.environ[&quot;PYLINTRC&quot;]).exists():</span>
<span class="gi">+        if Path(os.environ[&quot;PYLINTRC&quot;]).is_file():</span>
<span class="gi">+            yield Path(os.environ[&quot;PYLINTRC&quot;]).resolve()</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            user_home = Path.home()</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            # If the home directory does not exist a RuntimeError will be raised</span>
<span class="gi">+            user_home = None</span>
<span class="gi">+</span>
<span class="gi">+        if user_home is not None and str(user_home) not in (&quot;~&quot;, &quot;/root&quot;):</span>
<span class="gi">+            home_rc = user_home / &quot;.pylintrc&quot;</span>
<span class="gi">+            if home_rc.is_file():</span>
<span class="gi">+                yield home_rc.resolve()</span>
<span class="gi">+</span>
<span class="gi">+            home_rc = user_home / &quot;.config&quot; / &quot;pylintrc&quot;</span>
<span class="gi">+            if home_rc.is_file():</span>
<span class="gi">+                yield home_rc.resolve()</span>


<span class="gd">-def find_default_config_files() -&gt;Iterator[Path]:</span>
<span class="gi">+def find_default_config_files() -&gt; Iterator[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find all possible config files.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yield from _yield_default_files()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield from _find_project_config()</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        parent_pyproject = _find_pyproject()</span>
<span class="gi">+        if parent_pyproject.is_file() and _toml_has_config(parent_pyproject):</span>
<span class="gi">+            yield parent_pyproject.resolve()</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield from _find_config_in_home_or_environment()</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if os.path.isfile(&quot;/etc/pylintrc&quot;):</span>
<span class="gi">+            yield Path(&quot;/etc/pylintrc&quot;).resolve()</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        pass</span>
<span class="gh">diff --git a/pylint/config/help_formatter.py b/pylint/config/help_formatter.py</span>
<span class="gh">index 0bcc08da4..78d43d178 100644</span>
<span class="gd">--- a/pylint/config/help_formatter.py</span>
<span class="gi">+++ b/pylint/config/help_formatter.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="gi">+</span>
<span class="w"> </span>from pylint.config.callback_actions import _CallbackAction
<span class="w"> </span>from pylint.constants import DEFAULT_PYLINT_HOME

<span class="gu">@@ -7,6 +13,52 @@ from pylint.constants import DEFAULT_PYLINT_HOME</span>
<span class="w"> </span>class _HelpFormatter(argparse.RawDescriptionHelpFormatter):
<span class="w"> </span>    &quot;&quot;&quot;Formatter for the help message emitted by argparse.&quot;&quot;&quot;

<span class="gd">-    def _get_help_string(self, action: argparse.Action) -&gt;(str | None):</span>
<span class="gi">+    def _get_help_string(self, action: argparse.Action) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Copied from argparse.ArgumentDefaultsHelpFormatter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert action.help</span>
<span class="gi">+        help_string = action.help</span>
<span class="gi">+</span>
<span class="gi">+        # CallbackActions don&#39;t have a default</span>
<span class="gi">+        if isinstance(action, _CallbackAction):</span>
<span class="gi">+            return help_string</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;%(default)&quot; not in help_string:</span>
<span class="gi">+            if action.default is not argparse.SUPPRESS:</span>
<span class="gi">+                defaulting_nargs = [argparse.OPTIONAL, argparse.ZERO_OR_MORE]</span>
<span class="gi">+                if action.option_strings or action.nargs in defaulting_nargs:</span>
<span class="gi">+                    help_string += &quot; (default: %(default)s)&quot;</span>
<span class="gi">+        return help_string</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def get_long_description() -&gt; str:</span>
<span class="gi">+        return f&quot;&quot;&quot;</span>
<span class="gi">+Environment variables:</span>
<span class="gi">+    The following environment variables are used:</span>
<span class="gi">+        * PYLINTHOME    Path to the directory where persistent data for the run will</span>
<span class="gi">+                        be stored. If not found, it defaults to &#39;{DEFAULT_PYLINT_HOME}&#39;.</span>
<span class="gi">+        * PYLINTRC      Path to the configuration file. See the documentation for the method used</span>
<span class="gi">+                        to search for configuration file.</span>
<span class="gi">+</span>
<span class="gi">+Output:</span>
<span class="gi">+    Using the default text output, the message format is :</span>
<span class="gi">+</span>
<span class="gi">+        MESSAGE_TYPE: LINE_NUM:[OBJECT:] MESSAGE</span>
<span class="gi">+</span>
<span class="gi">+    There are 5 kind of message types :</span>
<span class="gi">+        * (I) info,         for informational messages</span>
<span class="gi">+        * (C) convention,   for programming standard violation</span>
<span class="gi">+        * (R) refactor,     for bad code smell</span>
<span class="gi">+        * (W) warning,      for python specific problems</span>
<span class="gi">+        * (E) error,        for probable bugs in the code</span>
<span class="gi">+        * (F) fatal,        if an error occurred which prevented pylint from doing further processing.</span>
<span class="gi">+</span>
<span class="gi">+Output status code:</span>
<span class="gi">+    Pylint should leave with following bitwise status codes:</span>
<span class="gi">+        * 0 if everything went fine</span>
<span class="gi">+        * 1 if a fatal message was issued</span>
<span class="gi">+        * 2 if an error message was issued</span>
<span class="gi">+        * 4 if a warning message was issued</span>
<span class="gi">+        * 8 if a refactor message was issued</span>
<span class="gi">+        * 16 if a convention message was issued</span>
<span class="gi">+        * 32 on usage error</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gh">diff --git a/pylint/config/utils.py b/pylint/config/utils.py</span>
<span class="gh">index 3da9282b3..91e4ff86f 100644</span>
<span class="gd">--- a/pylint/config/utils.py</span>
<span class="gi">+++ b/pylint/config/utils.py</span>
<span class="gu">@@ -1,65 +1,259 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utils for arguments/options parsing and handling.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from collections.abc import Callable, Sequence
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from pylint import extensions, utils
<span class="gd">-from pylint.config.argument import _CallableArgument, _ExtendArgument, _StoreArgument, _StoreNewNamesArgument, _StoreOldNamesArgument, _StoreTrueArgument</span>
<span class="gi">+from pylint.config.argument import (</span>
<span class="gi">+    _CallableArgument,</span>
<span class="gi">+    _ExtendArgument,</span>
<span class="gi">+    _StoreArgument,</span>
<span class="gi">+    _StoreNewNamesArgument,</span>
<span class="gi">+    _StoreOldNamesArgument,</span>
<span class="gi">+    _StoreTrueArgument,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.config.callback_actions import _CallbackAction
<span class="w"> </span>from pylint.config.exceptions import ArgumentPreprocessingError
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.run import Run


<span class="gd">-def _convert_option_to_argument(opt: str, optdict: dict[str, Any]) -&gt;(</span>
<span class="gd">-    _StoreArgument | _StoreTrueArgument | _CallableArgument |</span>
<span class="gd">-    _StoreOldNamesArgument | _StoreNewNamesArgument | _ExtendArgument):</span>
<span class="gi">+def _convert_option_to_argument(</span>
<span class="gi">+    opt: str, optdict: dict[str, Any]</span>
<span class="gi">+) -&gt; (</span>
<span class="gi">+    _StoreArgument</span>
<span class="gi">+    | _StoreTrueArgument</span>
<span class="gi">+    | _CallableArgument</span>
<span class="gi">+    | _StoreOldNamesArgument</span>
<span class="gi">+    | _StoreNewNamesArgument</span>
<span class="gi">+    | _ExtendArgument</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert an optdict to an Argument class instance.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get the long and short flags</span>
<span class="gi">+    flags = [f&quot;--{opt}&quot;]</span>
<span class="gi">+    if &quot;short&quot; in optdict:</span>
<span class="gi">+        flags += [f&quot;-{optdict[&#39;short&#39;]}&quot;]</span>

<span class="gi">+    # Get the action type</span>
<span class="gi">+    action = optdict.get(&quot;action&quot;, &quot;store&quot;)</span>

<span class="gd">-def _parse_rich_type_value(value: Any) -&gt;str:</span>
<span class="gi">+    if action == &quot;store_true&quot;:</span>
<span class="gi">+        return _StoreTrueArgument(</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            action=action,</span>
<span class="gi">+            default=optdict.get(&quot;default&quot;, True),</span>
<span class="gi">+            arg_help=optdict.get(&quot;help&quot;, &quot;&quot;),</span>
<span class="gi">+            hide_help=optdict.get(&quot;hide&quot;, False),</span>
<span class="gi">+            section=optdict.get(&quot;group&quot;, None),</span>
<span class="gi">+        )</span>
<span class="gi">+    if not isinstance(action, str) and issubclass(action, _CallbackAction):</span>
<span class="gi">+        return _CallableArgument(</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            action=action,</span>
<span class="gi">+            arg_help=optdict.get(&quot;help&quot;, &quot;&quot;),</span>
<span class="gi">+            kwargs=optdict.get(&quot;kwargs&quot;, {}),</span>
<span class="gi">+            hide_help=optdict.get(&quot;hide&quot;, False),</span>
<span class="gi">+            section=optdict.get(&quot;group&quot;, None),</span>
<span class="gi">+            metavar=optdict.get(&quot;metavar&quot;, None),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    default = optdict[&quot;default&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    if action == &quot;extend&quot;:</span>
<span class="gi">+        return _ExtendArgument(</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            action=action,</span>
<span class="gi">+            default=[] if default is None else default,</span>
<span class="gi">+            arg_type=optdict[&quot;type&quot;],</span>
<span class="gi">+            choices=optdict.get(&quot;choices&quot;, None),</span>
<span class="gi">+            arg_help=optdict.get(&quot;help&quot;, &quot;&quot;),</span>
<span class="gi">+            metavar=optdict.get(&quot;metavar&quot;, &quot;&quot;),</span>
<span class="gi">+            hide_help=optdict.get(&quot;hide&quot;, False),</span>
<span class="gi">+            section=optdict.get(&quot;group&quot;, None),</span>
<span class="gi">+            dest=optdict.get(&quot;dest&quot;, None),</span>
<span class="gi">+        )</span>
<span class="gi">+    if &quot;kwargs&quot; in optdict:</span>
<span class="gi">+        if &quot;old_names&quot; in optdict[&quot;kwargs&quot;]:</span>
<span class="gi">+            return _StoreOldNamesArgument(</span>
<span class="gi">+                flags=flags,</span>
<span class="gi">+                default=default,</span>
<span class="gi">+                arg_type=optdict[&quot;type&quot;],</span>
<span class="gi">+                choices=optdict.get(&quot;choices&quot;, None),</span>
<span class="gi">+                arg_help=optdict.get(&quot;help&quot;, &quot;&quot;),</span>
<span class="gi">+                metavar=optdict.get(&quot;metavar&quot;, &quot;&quot;),</span>
<span class="gi">+                hide_help=optdict.get(&quot;hide&quot;, False),</span>
<span class="gi">+                kwargs=optdict.get(&quot;kwargs&quot;, {}),</span>
<span class="gi">+                section=optdict.get(&quot;group&quot;, None),</span>
<span class="gi">+            )</span>
<span class="gi">+        if &quot;new_names&quot; in optdict[&quot;kwargs&quot;]:</span>
<span class="gi">+            return _StoreNewNamesArgument(</span>
<span class="gi">+                flags=flags,</span>
<span class="gi">+                default=default,</span>
<span class="gi">+                arg_type=optdict[&quot;type&quot;],</span>
<span class="gi">+                choices=optdict.get(&quot;choices&quot;, None),</span>
<span class="gi">+                arg_help=optdict.get(&quot;help&quot;, &quot;&quot;),</span>
<span class="gi">+                metavar=optdict.get(&quot;metavar&quot;, &quot;&quot;),</span>
<span class="gi">+                hide_help=optdict.get(&quot;hide&quot;, False),</span>
<span class="gi">+                kwargs=optdict.get(&quot;kwargs&quot;, {}),</span>
<span class="gi">+                section=optdict.get(&quot;group&quot;, None),</span>
<span class="gi">+            )</span>
<span class="gi">+    if &quot;dest&quot; in optdict:</span>
<span class="gi">+        return _StoreOldNamesArgument(</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+            default=default,</span>
<span class="gi">+            arg_type=optdict[&quot;type&quot;],</span>
<span class="gi">+            choices=optdict.get(&quot;choices&quot;, None),</span>
<span class="gi">+            arg_help=optdict.get(&quot;help&quot;, &quot;&quot;),</span>
<span class="gi">+            metavar=optdict.get(&quot;metavar&quot;, &quot;&quot;),</span>
<span class="gi">+            hide_help=optdict.get(&quot;hide&quot;, False),</span>
<span class="gi">+            kwargs={&quot;old_names&quot;: [optdict[&quot;dest&quot;]]},</span>
<span class="gi">+            section=optdict.get(&quot;group&quot;, None),</span>
<span class="gi">+        )</span>
<span class="gi">+    return _StoreArgument(</span>
<span class="gi">+        flags=flags,</span>
<span class="gi">+        action=action,</span>
<span class="gi">+        default=default,</span>
<span class="gi">+        arg_type=optdict[&quot;type&quot;],</span>
<span class="gi">+        choices=optdict.get(&quot;choices&quot;, None),</span>
<span class="gi">+        arg_help=optdict.get(&quot;help&quot;, &quot;&quot;),</span>
<span class="gi">+        metavar=optdict.get(&quot;metavar&quot;, &quot;&quot;),</span>
<span class="gi">+        hide_help=optdict.get(&quot;hide&quot;, False),</span>
<span class="gi">+        section=optdict.get(&quot;group&quot;, None),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_rich_type_value(value: Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse rich (toml) types into strings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, (list, tuple)):</span>
<span class="gi">+        return &quot;,&quot;.join(_parse_rich_type_value(i) for i in value)</span>
<span class="gi">+    if isinstance(value, re.Pattern):</span>
<span class="gi">+        return str(value.pattern)</span>
<span class="gi">+    if isinstance(value, dict):</span>
<span class="gi">+        return &quot;,&quot;.join(f&quot;{k}:{v}&quot; for k, v in value.items())</span>
<span class="gi">+    return str(value)</span>


<span class="gd">-def _init_hook(run: Run, value: (str | None)) -&gt;None:</span>
<span class="gi">+# pylint: disable-next=unused-argument</span>
<span class="gi">+def _init_hook(run: Run, value: str | None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Execute arbitrary code from the init_hook.

<span class="w"> </span>    This can be used to set the &#39;sys.path&#39; for example.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert value is not None</span>
<span class="gi">+    exec(value)  # pylint: disable=exec-used</span>


<span class="gd">-def _set_rcfile(run: Run, value: (str | None)) -&gt;None:</span>
<span class="gi">+def _set_rcfile(run: Run, value: str | None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set the rcfile.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert value is not None</span>
<span class="gi">+    run._rcfile = value</span>


<span class="gd">-def _set_output(run: Run, value: (str | None)) -&gt;None:</span>
<span class="gi">+def _set_output(run: Run, value: str | None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Set the output.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert value is not None</span>
<span class="gi">+    run._output = value</span>


<span class="gd">-def _add_plugins(run: Run, value: (str | None)) -&gt;None:</span>
<span class="gi">+def _add_plugins(run: Run, value: str | None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add plugins to the list of loadable plugins.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert value is not None</span>
<span class="gi">+    run._plugins.extend(utils._splitstrip(value))</span>
<span class="gi">+</span>

<span class="gi">+def _set_verbose_mode(run: Run, value: str | None) -&gt; None:</span>
<span class="gi">+    assert value is None</span>
<span class="gi">+    run.verbose = True</span>

<span class="gd">-def _enable_all_extensions(run: Run, value: (str | None)) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def _enable_all_extensions(run: Run, value: str | None) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Enable all extensions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert value is None</span>
<span class="gi">+    for filename in Path(extensions.__file__).parent.iterdir():</span>
<span class="gi">+        if filename.suffix == &quot;.py&quot; and not filename.stem.startswith(&quot;_&quot;):</span>
<span class="gi">+            extension_name = f&quot;pylint.extensions.{filename.stem}&quot;</span>
<span class="gi">+            if extension_name not in run._plugins:</span>
<span class="gi">+                run._plugins.append(extension_name)</span>


<span class="gd">-PREPROCESSABLE_OPTIONS: dict[str, tuple[bool, Callable[[Run, str | None],</span>
<span class="gd">-    None], int]] = {&#39;--init-hook&#39;: (True, _init_hook, 8), &#39;--rcfile&#39;: (True,</span>
<span class="gd">-    _set_rcfile, 4), &#39;--output&#39;: (True, _set_output, 0), &#39;--load-plugins&#39;:</span>
<span class="gd">-    (True, _add_plugins, 5), &#39;--verbose&#39;: (False, _set_verbose_mode, 4),</span>
<span class="gd">-    &#39;-v&#39;: (False, _set_verbose_mode, 2), &#39;--enable-all-extensions&#39;: (False,</span>
<span class="gd">-    _enable_all_extensions, 9)}</span>
<span class="gi">+PREPROCESSABLE_OPTIONS: dict[</span>
<span class="gi">+    str, tuple[bool, Callable[[Run, str | None], None], int]</span>
<span class="gi">+] = {  # pylint: disable=consider-using-namedtuple-or-dataclass</span>
<span class="gi">+    # pylint: disable=useless-suppression, wrong-spelling-in-comment</span>
<span class="gi">+    # Argparse by default allows abbreviations. It behaves differently</span>
<span class="gi">+    # if you turn this off, so we also turn it on. We mimic this</span>
<span class="gi">+    # by allowing some abbreviations or incorrect spelling here.</span>
<span class="gi">+    # The integer at the end of the tuple indicates how many letters</span>
<span class="gi">+    # should match, include the &#39;-&#39;. 0 indicates a full match.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Clashes with --init-(import)</span>
<span class="gi">+    &quot;--init-hook&quot;: (True, _init_hook, 8),</span>
<span class="gi">+    # Clashes with --r(ecursive)</span>
<span class="gi">+    &quot;--rcfile&quot;: (True, _set_rcfile, 4),</span>
<span class="gi">+    # Clashes with --output(-format)</span>
<span class="gi">+    &quot;--output&quot;: (True, _set_output, 0),</span>
<span class="gi">+    # Clashes with --lo(ng-help)</span>
<span class="gi">+    &quot;--load-plugins&quot;: (True, _add_plugins, 5),</span>
<span class="gi">+    # Clashes with --v(ariable-rgx)</span>
<span class="gi">+    &quot;--verbose&quot;: (False, _set_verbose_mode, 4),</span>
<span class="gi">+    &quot;-v&quot;: (False, _set_verbose_mode, 2),</span>
<span class="gi">+    # Clashes with --enable</span>
<span class="gi">+    &quot;--enable-all-extensions&quot;: (False, _enable_all_extensions, 9),</span>
<span class="gi">+}</span>
<span class="gi">+# pylint: enable=wrong-spelling-in-comment</span>


<span class="gd">-def _preprocess_options(run: Run, args: Sequence[str]) -&gt;list[str]:</span>
<span class="gi">+def _preprocess_options(run: Run, args: Sequence[str]) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pre-process options before full config parsing has started.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    processed_args: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    while i &lt; len(args):</span>
<span class="gi">+        argument = args[i]</span>
<span class="gi">+        if not argument.startswith(&quot;-&quot;):</span>
<span class="gi">+            processed_args.append(argument)</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            option, value = argument.split(&quot;=&quot;, 1)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            option, value = argument, None</span>
<span class="gi">+</span>
<span class="gi">+        matched_option = None</span>
<span class="gi">+        for option_name, data in PREPROCESSABLE_OPTIONS.items():</span>
<span class="gi">+            to_match = data[2]</span>
<span class="gi">+            if to_match == 0:</span>
<span class="gi">+                if option == option_name:</span>
<span class="gi">+                    matched_option = option_name</span>
<span class="gi">+            elif option.startswith(option_name[:to_match]):</span>
<span class="gi">+                matched_option = option_name</span>
<span class="gi">+</span>
<span class="gi">+        if matched_option is None:</span>
<span class="gi">+            processed_args.append(argument)</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        takearg, cb, _ = PREPROCESSABLE_OPTIONS[matched_option]</span>
<span class="gi">+</span>
<span class="gi">+        if takearg and value is None:</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            if i &gt;= len(args) or args[i].startswith(&quot;-&quot;):</span>
<span class="gi">+                raise ArgumentPreprocessingError(f&quot;Option {option} expects a value&quot;)</span>
<span class="gi">+            value = args[i]</span>
<span class="gi">+        elif not takearg and value is not None:</span>
<span class="gi">+            raise ArgumentPreprocessingError(f&quot;Option {option} doesn&#39;t expect a value&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        cb(run, value)</span>
<span class="gi">+        i += 1</span>
<span class="gi">+</span>
<span class="gi">+    return processed_args</span>
<span class="gh">diff --git a/pylint/constants.py b/pylint/constants.py</span>
<span class="gh">index 915082479..f147e5189 100644</span>
<span class="gd">--- a/pylint/constants.py</span>
<span class="gi">+++ b/pylint/constants.py</span>
<span class="gu">@@ -1,130 +1,279 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import platform
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>import platformdirs
<span class="gi">+</span>
<span class="w"> </span>from pylint.__pkginfo__ import __version__
<span class="w"> </span>from pylint.typing import MessageTypesFullName
<span class="gi">+</span>
<span class="w"> </span>PY38_PLUS = sys.version_info[:2] &gt;= (3, 8)
<span class="w"> </span>PY39_PLUS = sys.version_info[:2] &gt;= (3, 9)
<span class="w"> </span>PY310_PLUS = sys.version_info[:2] &gt;= (3, 10)
<span class="w"> </span>PY311_PLUS = sys.version_info[:2] &gt;= (3, 11)
<span class="w"> </span>PY312_PLUS = sys.version_info[:2] &gt;= (3, 12)
<span class="gd">-IS_PYPY = platform.python_implementation() == &#39;PyPy&#39;</span>
<span class="gd">-PY_EXTS = &#39;.py&#39;, &#39;.pyc&#39;, &#39;.pyo&#39;, &#39;.pyw&#39;, &#39;.so&#39;, &#39;.dll&#39;</span>
<span class="gi">+</span>
<span class="gi">+IS_PYPY = platform.python_implementation() == &quot;PyPy&quot;</span>
<span class="gi">+</span>
<span class="gi">+PY_EXTS = (&quot;.py&quot;, &quot;.pyc&quot;, &quot;.pyo&quot;, &quot;.pyw&quot;, &quot;.so&quot;, &quot;.dll&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>MSG_STATE_CONFIDENCE = 2
<span class="gd">-_MSG_ORDER = &#39;EWRCIF&#39;</span>
<span class="gi">+_MSG_ORDER = &quot;EWRCIF&quot;</span>
<span class="w"> </span>MSG_STATE_SCOPE_CONFIG = 0
<span class="w"> </span>MSG_STATE_SCOPE_MODULE = 1
<span class="gd">-_SCOPE_EXEMPT = &#39;FR&#39;</span>
<span class="gd">-MSG_TYPES: dict[str, MessageTypesFullName] = {&#39;I&#39;: &#39;info&#39;, &#39;C&#39;:</span>
<span class="gd">-    &#39;convention&#39;, &#39;R&#39;: &#39;refactor&#39;, &#39;W&#39;: &#39;warning&#39;, &#39;E&#39;: &#39;error&#39;, &#39;F&#39;: &#39;fatal&#39;}</span>
<span class="gi">+</span>
<span class="gi">+# The line/node distinction does not apply to fatal errors and reports.</span>
<span class="gi">+_SCOPE_EXEMPT = &quot;FR&quot;</span>
<span class="gi">+</span>
<span class="gi">+MSG_TYPES: dict[str, MessageTypesFullName] = {</span>
<span class="gi">+    &quot;I&quot;: &quot;info&quot;,</span>
<span class="gi">+    &quot;C&quot;: &quot;convention&quot;,</span>
<span class="gi">+    &quot;R&quot;: &quot;refactor&quot;,</span>
<span class="gi">+    &quot;W&quot;: &quot;warning&quot;,</span>
<span class="gi">+    &quot;E&quot;: &quot;error&quot;,</span>
<span class="gi">+    &quot;F&quot;: &quot;fatal&quot;,</span>
<span class="gi">+}</span>
<span class="w"> </span>MSG_TYPES_LONG: dict[str, str] = {v: k for k, v in MSG_TYPES.items()}
<span class="gd">-MSG_TYPES_STATUS = {&#39;I&#39;: 0, &#39;C&#39;: 16, &#39;R&#39;: 8, &#39;W&#39;: 4, &#39;E&#39;: 2, &#39;F&#39;: 1}</span>
<span class="gd">-MAIN_CHECKER_NAME = &#39;main&#39;</span>
<span class="gd">-DEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(&#39;pylint&#39;)</span>
<span class="gd">-DEFAULT_IGNORE_LIST = &#39;CVS&#39;,</span>
<span class="gi">+</span>
<span class="gi">+MSG_TYPES_STATUS = {&quot;I&quot;: 0, &quot;C&quot;: 16, &quot;R&quot;: 8, &quot;W&quot;: 4, &quot;E&quot;: 2, &quot;F&quot;: 1}</span>
<span class="gi">+</span>
<span class="gi">+# You probably don&#39;t want to change the MAIN_CHECKER_NAME</span>
<span class="gi">+# This would affect rcfile generation and retro-compatibility</span>
<span class="gi">+# on all project using [MAIN] in their rcfile.</span>
<span class="gi">+MAIN_CHECKER_NAME = &quot;main&quot;</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_PYLINT_HOME = platformdirs.user_cache_dir(&quot;pylint&quot;)</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_IGNORE_LIST = (&quot;CVS&quot;,)</span>


<span class="w"> </span>class WarningScope:
<span class="gd">-    LINE = &#39;line-based-msg&#39;</span>
<span class="gd">-    NODE = &#39;node-based-msg&#39;</span>
<span class="gi">+    LINE = &quot;line-based-msg&quot;</span>
<span class="gi">+    NODE = &quot;node-based-msg&quot;</span>


<span class="w"> </span>full_version = f&quot;&quot;&quot;pylint {__version__}
<span class="w"> </span>astroid {astroid.__version__}
<span class="w"> </span>Python {sys.version}&quot;&quot;&quot;
<span class="gd">-HUMAN_READABLE_TYPES = {&#39;file&#39;: &#39;file&#39;, &#39;module&#39;: &#39;module&#39;, &#39;const&#39;:</span>
<span class="gd">-    &#39;constant&#39;, &#39;class&#39;: &#39;class&#39;, &#39;function&#39;: &#39;function&#39;, &#39;method&#39;:</span>
<span class="gd">-    &#39;method&#39;, &#39;attr&#39;: &#39;attribute&#39;, &#39;argument&#39;: &#39;argument&#39;, &#39;variable&#39;:</span>
<span class="gd">-    &#39;variable&#39;, &#39;class_attribute&#39;: &#39;class attribute&#39;, &#39;class_const&#39;:</span>
<span class="gd">-    &#39;class constant&#39;, &#39;inlinevar&#39;: &#39;inline iteration&#39;, &#39;typevar&#39;:</span>
<span class="gd">-    &#39;type variable&#39;, &#39;typealias&#39;: &#39;type alias&#39;}</span>
<span class="gd">-INCOMPATIBLE_WITH_USELESS_SUPPRESSION = frozenset([&#39;R0401&#39;, &#39;W0402&#39;,</span>
<span class="gd">-    &#39;W1505&#39;, &#39;W1511&#39;, &#39;W1512&#39;, &#39;W1513&#39;, &#39;R0801&#39;])</span>

<span class="gi">+HUMAN_READABLE_TYPES = {</span>
<span class="gi">+    &quot;file&quot;: &quot;file&quot;,</span>
<span class="gi">+    &quot;module&quot;: &quot;module&quot;,</span>
<span class="gi">+    &quot;const&quot;: &quot;constant&quot;,</span>
<span class="gi">+    &quot;class&quot;: &quot;class&quot;,</span>
<span class="gi">+    &quot;function&quot;: &quot;function&quot;,</span>
<span class="gi">+    &quot;method&quot;: &quot;method&quot;,</span>
<span class="gi">+    &quot;attr&quot;: &quot;attribute&quot;,</span>
<span class="gi">+    &quot;argument&quot;: &quot;argument&quot;,</span>
<span class="gi">+    &quot;variable&quot;: &quot;variable&quot;,</span>
<span class="gi">+    &quot;class_attribute&quot;: &quot;class attribute&quot;,</span>
<span class="gi">+    &quot;class_const&quot;: &quot;class constant&quot;,</span>
<span class="gi">+    &quot;inlinevar&quot;: &quot;inline iteration&quot;,</span>
<span class="gi">+    &quot;typevar&quot;: &quot;type variable&quot;,</span>
<span class="gi">+    &quot;typealias&quot;: &quot;type alias&quot;,</span>
<span class="gi">+}</span>

<span class="gd">-def _get_pylint_home() -&gt;str:</span>
<span class="gi">+# ignore some messages when emitting useless-suppression:</span>
<span class="gi">+# - cyclic-import: can show false positives due to incomplete context</span>
<span class="gi">+# - deprecated-{module, argument, class, method, decorator}:</span>
<span class="gi">+#   can cause false positives for multi-interpreter projects</span>
<span class="gi">+#   when linting with an interpreter on a lower python version</span>
<span class="gi">+INCOMPATIBLE_WITH_USELESS_SUPPRESSION = frozenset(</span>
<span class="gi">+    [</span>
<span class="gi">+        &quot;R0401&quot;,  # cyclic-import</span>
<span class="gi">+        &quot;W0402&quot;,  # deprecated-module</span>
<span class="gi">+        &quot;W1505&quot;,  # deprecated-method</span>
<span class="gi">+        &quot;W1511&quot;,  # deprecated-argument</span>
<span class="gi">+        &quot;W1512&quot;,  # deprecated-class</span>
<span class="gi">+        &quot;W1513&quot;,  # deprecated-decorator</span>
<span class="gi">+        &quot;R0801&quot;,  # duplicate-code</span>
<span class="gi">+    ]</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_pylint_home() -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the pylint home.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &quot;PYLINTHOME&quot; in os.environ:</span>
<span class="gi">+        return os.environ[&quot;PYLINTHOME&quot;]</span>
<span class="gi">+    return DEFAULT_PYLINT_HOME</span>


<span class="w"> </span>PYLINT_HOME = _get_pylint_home()
<span class="gd">-TYPING_NORETURN = frozenset((&#39;typing.NoReturn&#39;, &#39;typing_extensions.NoReturn&#39;))</span>
<span class="gd">-TYPING_NEVER = frozenset((&#39;typing.Never&#39;, &#39;typing_extensions.Never&#39;))</span>
<span class="gd">-DUNDER_METHODS: dict[tuple[int, int], dict[str, str]] = {(0, 0): {</span>
<span class="gd">-    &#39;__init__&#39;: &#39;Instantiate class directly&#39;, &#39;__del__&#39;: &#39;Use del keyword&#39;,</span>
<span class="gd">-    &#39;__repr__&#39;: &#39;Use repr built-in function&#39;, &#39;__str__&#39;:</span>
<span class="gd">-    &#39;Use str built-in function&#39;, &#39;__bytes__&#39;: &#39;Use bytes built-in function&#39;,</span>
<span class="gd">-    &#39;__format__&#39;:</span>
<span class="gd">-    &#39;Use format built-in function, format string method, or f-string&#39;,</span>
<span class="gd">-    &#39;__lt__&#39;: &#39;Use &lt; operator&#39;, &#39;__le__&#39;: &#39;Use &lt;= operator&#39;, &#39;__eq__&#39;:</span>
<span class="gd">-    &#39;Use == operator&#39;, &#39;__ne__&#39;: &#39;Use != operator&#39;, &#39;__gt__&#39;:</span>
<span class="gd">-    &#39;Use &gt; operator&#39;, &#39;__ge__&#39;: &#39;Use &gt;= operator&#39;, &#39;__hash__&#39;:</span>
<span class="gd">-    &#39;Use hash built-in function&#39;, &#39;__bool__&#39;: &#39;Use bool built-in function&#39;,</span>
<span class="gd">-    &#39;__getattr__&#39;:</span>
<span class="gd">-    &#39;Access attribute directly or use getattr built-in function&#39;,</span>
<span class="gd">-    &#39;__getattribute__&#39;:</span>
<span class="gd">-    &#39;Access attribute directly or use getattr built-in function&#39;,</span>
<span class="gd">-    &#39;__setattr__&#39;:</span>
<span class="gd">-    &#39;Set attribute directly or use setattr built-in function&#39;,</span>
<span class="gd">-    &#39;__delattr__&#39;: &#39;Use del keyword&#39;, &#39;__dir__&#39;:</span>
<span class="gd">-    &#39;Use dir built-in function&#39;, &#39;__get__&#39;: &#39;Use get method&#39;, &#39;__set__&#39;:</span>
<span class="gd">-    &#39;Use set method&#39;, &#39;__delete__&#39;: &#39;Use del keyword&#39;, &#39;__instancecheck__&#39;:</span>
<span class="gd">-    &#39;Use isinstance built-in function&#39;, &#39;__subclasscheck__&#39;:</span>
<span class="gd">-    &#39;Use issubclass built-in function&#39;, &#39;__call__&#39;:</span>
<span class="gd">-    &#39;Invoke instance directly&#39;, &#39;__len__&#39;: &#39;Use len built-in function&#39;,</span>
<span class="gd">-    &#39;__length_hint__&#39;: &#39;Use length_hint method&#39;, &#39;__getitem__&#39;:</span>
<span class="gd">-    &#39;Access item via subscript&#39;, &#39;__setitem__&#39;: &#39;Set item via subscript&#39;,</span>
<span class="gd">-    &#39;__delitem__&#39;: &#39;Use del keyword&#39;, &#39;__iter__&#39;:</span>
<span class="gd">-    &#39;Use iter built-in function&#39;, &#39;__next__&#39;: &#39;Use next built-in function&#39;,</span>
<span class="gd">-    &#39;__reversed__&#39;: &#39;Use reversed built-in function&#39;, &#39;__contains__&#39;:</span>
<span class="gd">-    &#39;Use in keyword&#39;, &#39;__add__&#39;: &#39;Use + operator&#39;, &#39;__sub__&#39;:</span>
<span class="gd">-    &#39;Use - operator&#39;, &#39;__mul__&#39;: &#39;Use * operator&#39;, &#39;__matmul__&#39;:</span>
<span class="gd">-    &#39;Use @ operator&#39;, &#39;__truediv__&#39;: &#39;Use / operator&#39;, &#39;__floordiv__&#39;:</span>
<span class="gd">-    &#39;Use // operator&#39;, &#39;__mod__&#39;: &#39;Use % operator&#39;, &#39;__divmod__&#39;:</span>
<span class="gd">-    &#39;Use divmod built-in function&#39;, &#39;__pow__&#39;:</span>
<span class="gd">-    &#39;Use ** operator or pow built-in function&#39;, &#39;__lshift__&#39;:</span>
<span class="gd">-    &#39;Use &lt;&lt; operator&#39;, &#39;__rshift__&#39;: &#39;Use &gt;&gt; operator&#39;, &#39;__and__&#39;:</span>
<span class="gd">-    &#39;Use &amp; operator&#39;, &#39;__xor__&#39;: &#39;Use ^ operator&#39;, &#39;__or__&#39;:</span>
<span class="gd">-    &#39;Use | operator&#39;, &#39;__radd__&#39;: &#39;Use + operator&#39;, &#39;__rsub__&#39;:</span>
<span class="gd">-    &#39;Use - operator&#39;, &#39;__rmul__&#39;: &#39;Use * operator&#39;, &#39;__rmatmul__&#39;:</span>
<span class="gd">-    &#39;Use @ operator&#39;, &#39;__rtruediv__&#39;: &#39;Use / operator&#39;, &#39;__rfloordiv__&#39;:</span>
<span class="gd">-    &#39;Use // operator&#39;, &#39;__rmod__&#39;: &#39;Use % operator&#39;, &#39;__rdivmod__&#39;:</span>
<span class="gd">-    &#39;Use divmod built-in function&#39;, &#39;__rpow__&#39;:</span>
<span class="gd">-    &#39;Use ** operator or pow built-in function&#39;, &#39;__rlshift__&#39;:</span>
<span class="gd">-    &#39;Use &lt;&lt; operator&#39;, &#39;__rrshift__&#39;: &#39;Use &gt;&gt; operator&#39;, &#39;__rand__&#39;:</span>
<span class="gd">-    &#39;Use &amp; operator&#39;, &#39;__rxor__&#39;: &#39;Use ^ operator&#39;, &#39;__ror__&#39;:</span>
<span class="gd">-    &#39;Use | operator&#39;, &#39;__iadd__&#39;: &#39;Use += operator&#39;, &#39;__isub__&#39;:</span>
<span class="gd">-    &#39;Use -= operator&#39;, &#39;__imul__&#39;: &#39;Use *= operator&#39;, &#39;__imatmul__&#39;:</span>
<span class="gd">-    &#39;Use @= operator&#39;, &#39;__itruediv__&#39;: &#39;Use /= operator&#39;, &#39;__ifloordiv__&#39;:</span>
<span class="gd">-    &#39;Use //= operator&#39;, &#39;__imod__&#39;: &#39;Use %= operator&#39;, &#39;__ipow__&#39;:</span>
<span class="gd">-    &#39;Use **= operator&#39;, &#39;__ilshift__&#39;: &#39;Use &lt;&lt;= operator&#39;, &#39;__irshift__&#39;:</span>
<span class="gd">-    &#39;Use &gt;&gt;= operator&#39;, &#39;__iand__&#39;: &#39;Use &amp;= operator&#39;, &#39;__ixor__&#39;:</span>
<span class="gd">-    &#39;Use ^= operator&#39;, &#39;__ior__&#39;: &#39;Use |= operator&#39;, &#39;__neg__&#39;:</span>
<span class="gd">-    &#39;Multiply by -1 instead&#39;, &#39;__pos__&#39;: &#39;Multiply by +1 instead&#39;,</span>
<span class="gd">-    &#39;__abs__&#39;: &#39;Use abs built-in function&#39;, &#39;__invert__&#39;: &#39;Use ~ operator&#39;,</span>
<span class="gd">-    &#39;__complex__&#39;: &#39;Use complex built-in function&#39;, &#39;__int__&#39;:</span>
<span class="gd">-    &#39;Use int built-in function&#39;, &#39;__float__&#39;: &#39;Use float built-in function&#39;,</span>
<span class="gd">-    &#39;__round__&#39;: &#39;Use round built-in function&#39;, &#39;__trunc__&#39;:</span>
<span class="gd">-    &#39;Use math.trunc function&#39;, &#39;__floor__&#39;: &#39;Use math.floor function&#39;,</span>
<span class="gd">-    &#39;__ceil__&#39;: &#39;Use math.ceil function&#39;, &#39;__enter__&#39;:</span>
<span class="gd">-    &#39;Invoke context manager directly&#39;, &#39;__aenter__&#39;:</span>
<span class="gd">-    &#39;Invoke context manager directly&#39;, &#39;__copy__&#39;: &#39;Use copy.copy function&#39;,</span>
<span class="gd">-    &#39;__deepcopy__&#39;: &#39;Use copy.deepcopy function&#39;, &#39;__fspath__&#39;:</span>
<span class="gd">-    &#39;Use os.fspath function instead&#39;}, (3, 10): {&#39;__aiter__&#39;:</span>
<span class="gd">-    &#39;Use aiter built-in function&#39;, &#39;__anext__&#39;: &#39;Use anext built-in function&#39;}}</span>
<span class="gd">-EXTRA_DUNDER_METHODS = [&#39;__new__&#39;, &#39;__subclasses__&#39;, &#39;__init_subclass__&#39;,</span>
<span class="gd">-    &#39;__set_name__&#39;, &#39;__class_getitem__&#39;, &#39;__missing__&#39;, &#39;__exit__&#39;,</span>
<span class="gd">-    &#39;__await__&#39;, &#39;__aexit__&#39;, &#39;__getnewargs_ex__&#39;, &#39;__getnewargs__&#39;,</span>
<span class="gd">-    &#39;__getstate__&#39;, &#39;__index__&#39;, &#39;__setstate__&#39;, &#39;__reduce__&#39;,</span>
<span class="gd">-    &#39;__reduce_ex__&#39;, &#39;__post_init__&#39;]</span>
<span class="gd">-DUNDER_PROPERTIES = [&#39;__class__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;, &#39;__format__&#39;,</span>
<span class="gd">-    &#39;__module__&#39;, &#39;__sizeof__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;]</span>
<span class="gd">-UNNECESSARY_DUNDER_CALL_LAMBDA_EXCEPTIONS = [&#39;__init__&#39;, &#39;__del__&#39;,</span>
<span class="gd">-    &#39;__delattr__&#39;, &#39;__set__&#39;, &#39;__delete__&#39;, &#39;__setitem__&#39;, &#39;__delitem__&#39;,</span>
<span class="gd">-    &#39;__iadd__&#39;, &#39;__isub__&#39;, &#39;__imul__&#39;, &#39;__imatmul__&#39;, &#39;__itruediv__&#39;,</span>
<span class="gd">-    &#39;__ifloordiv__&#39;, &#39;__imod__&#39;, &#39;__ipow__&#39;, &#39;__ilshift__&#39;, &#39;__irshift__&#39;,</span>
<span class="gd">-    &#39;__iand__&#39;, &#39;__ixor__&#39;, &#39;__ior__&#39;]</span>
<span class="gi">+</span>
<span class="gi">+TYPING_NORETURN = frozenset(</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;typing.NoReturn&quot;,</span>
<span class="gi">+        &quot;typing_extensions.NoReturn&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+)</span>
<span class="gi">+TYPING_NEVER = frozenset(</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;typing.Never&quot;,</span>
<span class="gi">+        &quot;typing_extensions.Never&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+DUNDER_METHODS: dict[tuple[int, int], dict[str, str]] = {</span>
<span class="gi">+    (0, 0): {</span>
<span class="gi">+        &quot;__init__&quot;: &quot;Instantiate class directly&quot;,</span>
<span class="gi">+        &quot;__del__&quot;: &quot;Use del keyword&quot;,</span>
<span class="gi">+        &quot;__repr__&quot;: &quot;Use repr built-in function&quot;,</span>
<span class="gi">+        &quot;__str__&quot;: &quot;Use str built-in function&quot;,</span>
<span class="gi">+        &quot;__bytes__&quot;: &quot;Use bytes built-in function&quot;,</span>
<span class="gi">+        &quot;__format__&quot;: &quot;Use format built-in function, format string method, or f-string&quot;,</span>
<span class="gi">+        &quot;__lt__&quot;: &quot;Use &lt; operator&quot;,</span>
<span class="gi">+        &quot;__le__&quot;: &quot;Use &lt;= operator&quot;,</span>
<span class="gi">+        &quot;__eq__&quot;: &quot;Use == operator&quot;,</span>
<span class="gi">+        &quot;__ne__&quot;: &quot;Use != operator&quot;,</span>
<span class="gi">+        &quot;__gt__&quot;: &quot;Use &gt; operator&quot;,</span>
<span class="gi">+        &quot;__ge__&quot;: &quot;Use &gt;= operator&quot;,</span>
<span class="gi">+        &quot;__hash__&quot;: &quot;Use hash built-in function&quot;,</span>
<span class="gi">+        &quot;__bool__&quot;: &quot;Use bool built-in function&quot;,</span>
<span class="gi">+        &quot;__getattr__&quot;: &quot;Access attribute directly or use getattr built-in function&quot;,</span>
<span class="gi">+        &quot;__getattribute__&quot;: &quot;Access attribute directly or use getattr built-in function&quot;,</span>
<span class="gi">+        &quot;__setattr__&quot;: &quot;Set attribute directly or use setattr built-in function&quot;,</span>
<span class="gi">+        &quot;__delattr__&quot;: &quot;Use del keyword&quot;,</span>
<span class="gi">+        &quot;__dir__&quot;: &quot;Use dir built-in function&quot;,</span>
<span class="gi">+        &quot;__get__&quot;: &quot;Use get method&quot;,</span>
<span class="gi">+        &quot;__set__&quot;: &quot;Use set method&quot;,</span>
<span class="gi">+        &quot;__delete__&quot;: &quot;Use del keyword&quot;,</span>
<span class="gi">+        &quot;__instancecheck__&quot;: &quot;Use isinstance built-in function&quot;,</span>
<span class="gi">+        &quot;__subclasscheck__&quot;: &quot;Use issubclass built-in function&quot;,</span>
<span class="gi">+        &quot;__call__&quot;: &quot;Invoke instance directly&quot;,</span>
<span class="gi">+        &quot;__len__&quot;: &quot;Use len built-in function&quot;,</span>
<span class="gi">+        &quot;__length_hint__&quot;: &quot;Use length_hint method&quot;,</span>
<span class="gi">+        &quot;__getitem__&quot;: &quot;Access item via subscript&quot;,</span>
<span class="gi">+        &quot;__setitem__&quot;: &quot;Set item via subscript&quot;,</span>
<span class="gi">+        &quot;__delitem__&quot;: &quot;Use del keyword&quot;,</span>
<span class="gi">+        &quot;__iter__&quot;: &quot;Use iter built-in function&quot;,</span>
<span class="gi">+        &quot;__next__&quot;: &quot;Use next built-in function&quot;,</span>
<span class="gi">+        &quot;__reversed__&quot;: &quot;Use reversed built-in function&quot;,</span>
<span class="gi">+        &quot;__contains__&quot;: &quot;Use in keyword&quot;,</span>
<span class="gi">+        &quot;__add__&quot;: &quot;Use + operator&quot;,</span>
<span class="gi">+        &quot;__sub__&quot;: &quot;Use - operator&quot;,</span>
<span class="gi">+        &quot;__mul__&quot;: &quot;Use * operator&quot;,</span>
<span class="gi">+        &quot;__matmul__&quot;: &quot;Use @ operator&quot;,</span>
<span class="gi">+        &quot;__truediv__&quot;: &quot;Use / operator&quot;,</span>
<span class="gi">+        &quot;__floordiv__&quot;: &quot;Use // operator&quot;,</span>
<span class="gi">+        &quot;__mod__&quot;: &quot;Use % operator&quot;,</span>
<span class="gi">+        &quot;__divmod__&quot;: &quot;Use divmod built-in function&quot;,</span>
<span class="gi">+        &quot;__pow__&quot;: &quot;Use ** operator or pow built-in function&quot;,</span>
<span class="gi">+        &quot;__lshift__&quot;: &quot;Use &lt;&lt; operator&quot;,</span>
<span class="gi">+        &quot;__rshift__&quot;: &quot;Use &gt;&gt; operator&quot;,</span>
<span class="gi">+        &quot;__and__&quot;: &quot;Use &amp; operator&quot;,</span>
<span class="gi">+        &quot;__xor__&quot;: &quot;Use ^ operator&quot;,</span>
<span class="gi">+        &quot;__or__&quot;: &quot;Use | operator&quot;,</span>
<span class="gi">+        &quot;__radd__&quot;: &quot;Use + operator&quot;,</span>
<span class="gi">+        &quot;__rsub__&quot;: &quot;Use - operator&quot;,</span>
<span class="gi">+        &quot;__rmul__&quot;: &quot;Use * operator&quot;,</span>
<span class="gi">+        &quot;__rmatmul__&quot;: &quot;Use @ operator&quot;,</span>
<span class="gi">+        &quot;__rtruediv__&quot;: &quot;Use / operator&quot;,</span>
<span class="gi">+        &quot;__rfloordiv__&quot;: &quot;Use // operator&quot;,</span>
<span class="gi">+        &quot;__rmod__&quot;: &quot;Use % operator&quot;,</span>
<span class="gi">+        &quot;__rdivmod__&quot;: &quot;Use divmod built-in function&quot;,</span>
<span class="gi">+        &quot;__rpow__&quot;: &quot;Use ** operator or pow built-in function&quot;,</span>
<span class="gi">+        &quot;__rlshift__&quot;: &quot;Use &lt;&lt; operator&quot;,</span>
<span class="gi">+        &quot;__rrshift__&quot;: &quot;Use &gt;&gt; operator&quot;,</span>
<span class="gi">+        &quot;__rand__&quot;: &quot;Use &amp; operator&quot;,</span>
<span class="gi">+        &quot;__rxor__&quot;: &quot;Use ^ operator&quot;,</span>
<span class="gi">+        &quot;__ror__&quot;: &quot;Use | operator&quot;,</span>
<span class="gi">+        &quot;__iadd__&quot;: &quot;Use += operator&quot;,</span>
<span class="gi">+        &quot;__isub__&quot;: &quot;Use -= operator&quot;,</span>
<span class="gi">+        &quot;__imul__&quot;: &quot;Use *= operator&quot;,</span>
<span class="gi">+        &quot;__imatmul__&quot;: &quot;Use @= operator&quot;,</span>
<span class="gi">+        &quot;__itruediv__&quot;: &quot;Use /= operator&quot;,</span>
<span class="gi">+        &quot;__ifloordiv__&quot;: &quot;Use //= operator&quot;,</span>
<span class="gi">+        &quot;__imod__&quot;: &quot;Use %= operator&quot;,</span>
<span class="gi">+        &quot;__ipow__&quot;: &quot;Use **= operator&quot;,</span>
<span class="gi">+        &quot;__ilshift__&quot;: &quot;Use &lt;&lt;= operator&quot;,</span>
<span class="gi">+        &quot;__irshift__&quot;: &quot;Use &gt;&gt;= operator&quot;,</span>
<span class="gi">+        &quot;__iand__&quot;: &quot;Use &amp;= operator&quot;,</span>
<span class="gi">+        &quot;__ixor__&quot;: &quot;Use ^= operator&quot;,</span>
<span class="gi">+        &quot;__ior__&quot;: &quot;Use |= operator&quot;,</span>
<span class="gi">+        &quot;__neg__&quot;: &quot;Multiply by -1 instead&quot;,</span>
<span class="gi">+        &quot;__pos__&quot;: &quot;Multiply by +1 instead&quot;,</span>
<span class="gi">+        &quot;__abs__&quot;: &quot;Use abs built-in function&quot;,</span>
<span class="gi">+        &quot;__invert__&quot;: &quot;Use ~ operator&quot;,</span>
<span class="gi">+        &quot;__complex__&quot;: &quot;Use complex built-in function&quot;,</span>
<span class="gi">+        &quot;__int__&quot;: &quot;Use int built-in function&quot;,</span>
<span class="gi">+        &quot;__float__&quot;: &quot;Use float built-in function&quot;,</span>
<span class="gi">+        &quot;__round__&quot;: &quot;Use round built-in function&quot;,</span>
<span class="gi">+        &quot;__trunc__&quot;: &quot;Use math.trunc function&quot;,</span>
<span class="gi">+        &quot;__floor__&quot;: &quot;Use math.floor function&quot;,</span>
<span class="gi">+        &quot;__ceil__&quot;: &quot;Use math.ceil function&quot;,</span>
<span class="gi">+        &quot;__enter__&quot;: &quot;Invoke context manager directly&quot;,</span>
<span class="gi">+        &quot;__aenter__&quot;: &quot;Invoke context manager directly&quot;,</span>
<span class="gi">+        &quot;__copy__&quot;: &quot;Use copy.copy function&quot;,</span>
<span class="gi">+        &quot;__deepcopy__&quot;: &quot;Use copy.deepcopy function&quot;,</span>
<span class="gi">+        &quot;__fspath__&quot;: &quot;Use os.fspath function instead&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+    (3, 10): {</span>
<span class="gi">+        &quot;__aiter__&quot;: &quot;Use aiter built-in function&quot;,</span>
<span class="gi">+        &quot;__anext__&quot;: &quot;Use anext built-in function&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+EXTRA_DUNDER_METHODS = [</span>
<span class="gi">+    &quot;__new__&quot;,</span>
<span class="gi">+    &quot;__subclasses__&quot;,</span>
<span class="gi">+    &quot;__init_subclass__&quot;,</span>
<span class="gi">+    &quot;__set_name__&quot;,</span>
<span class="gi">+    &quot;__class_getitem__&quot;,</span>
<span class="gi">+    &quot;__missing__&quot;,</span>
<span class="gi">+    &quot;__exit__&quot;,</span>
<span class="gi">+    &quot;__await__&quot;,</span>
<span class="gi">+    &quot;__aexit__&quot;,</span>
<span class="gi">+    &quot;__getnewargs_ex__&quot;,</span>
<span class="gi">+    &quot;__getnewargs__&quot;,</span>
<span class="gi">+    &quot;__getstate__&quot;,</span>
<span class="gi">+    &quot;__index__&quot;,</span>
<span class="gi">+    &quot;__setstate__&quot;,</span>
<span class="gi">+    &quot;__reduce__&quot;,</span>
<span class="gi">+    &quot;__reduce_ex__&quot;,</span>
<span class="gi">+    &quot;__post_init__&quot;,  # part of `dataclasses` module</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+DUNDER_PROPERTIES = [</span>
<span class="gi">+    &quot;__class__&quot;,</span>
<span class="gi">+    &quot;__dict__&quot;,</span>
<span class="gi">+    &quot;__doc__&quot;,</span>
<span class="gi">+    &quot;__format__&quot;,</span>
<span class="gi">+    &quot;__module__&quot;,</span>
<span class="gi">+    &quot;__sizeof__&quot;,</span>
<span class="gi">+    &quot;__subclasshook__&quot;,</span>
<span class="gi">+    &quot;__weakref__&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# C2801 rule exceptions as their corresponding function/method/operator</span>
<span class="gi">+# is not valid python syntax in a lambda definition</span>
<span class="gi">+UNNECESSARY_DUNDER_CALL_LAMBDA_EXCEPTIONS = [</span>
<span class="gi">+    &quot;__init__&quot;,</span>
<span class="gi">+    &quot;__del__&quot;,</span>
<span class="gi">+    &quot;__delattr__&quot;,</span>
<span class="gi">+    &quot;__set__&quot;,</span>
<span class="gi">+    &quot;__delete__&quot;,</span>
<span class="gi">+    &quot;__setitem__&quot;,</span>
<span class="gi">+    &quot;__delitem__&quot;,</span>
<span class="gi">+    &quot;__iadd__&quot;,</span>
<span class="gi">+    &quot;__isub__&quot;,</span>
<span class="gi">+    &quot;__imul__&quot;,</span>
<span class="gi">+    &quot;__imatmul__&quot;,</span>
<span class="gi">+    &quot;__itruediv__&quot;,</span>
<span class="gi">+    &quot;__ifloordiv__&quot;,</span>
<span class="gi">+    &quot;__imod__&quot;,</span>
<span class="gi">+    &quot;__ipow__&quot;,</span>
<span class="gi">+    &quot;__ilshift__&quot;,</span>
<span class="gi">+    &quot;__irshift__&quot;,</span>
<span class="gi">+    &quot;__iand__&quot;,</span>
<span class="gi">+    &quot;__ixor__&quot;,</span>
<span class="gi">+    &quot;__ior__&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>MAX_NUMBER_OF_IMPORT_SHOWN = 6
<span class="gh">diff --git a/pylint/exceptions.py b/pylint/exceptions.py</span>
<span class="gh">index 2721a6072..2bfbfa8cc 100644</span>
<span class="gd">--- a/pylint/exceptions.py</span>
<span class="gi">+++ b/pylint/exceptions.py</span>
<span class="gu">@@ -1,3 +1,7 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Exception classes raised by various operations within pylint.&quot;&quot;&quot;


<span class="gu">@@ -17,7 +21,7 @@ class DeletedMessageError(UnknownMessageError):</span>
<span class="w"> </span>    def __init__(self, msgid_or_symbol: str, removal_explanation: str):
<span class="w"> </span>        super().__init__(
<span class="w"> </span>            f&quot;&#39;{msgid_or_symbol}&#39; was removed from pylint, see {removal_explanation}.&quot;
<span class="gd">-            )</span>
<span class="gi">+        )</span>


<span class="w"> </span>class MessageBecameExtensionError(UnknownMessageError):
<span class="gu">@@ -28,7 +32,7 @@ class MessageBecameExtensionError(UnknownMessageError):</span>
<span class="w"> </span>    def __init__(self, msgid_or_symbol: str, moved_explanation: str):
<span class="w"> </span>        super().__init__(
<span class="w"> </span>            f&quot;&#39;{msgid_or_symbol}&#39; was moved to an optional extension, see {moved_explanation}.&quot;
<span class="gd">-            )</span>
<span class="gi">+        )</span>


<span class="w"> </span>class EmptyReportError(Exception):
<span class="gh">diff --git a/pylint/extensions/_check_docs_utils.py b/pylint/extensions/_check_docs_utils.py</span>
<span class="gh">index 4e60e6372..9b4b3e0db 100644</span>
<span class="gd">--- a/pylint/extensions/_check_docs_utils.py</span>
<span class="gi">+++ b/pylint/extensions/_check_docs_utils.py</span>
<span class="gu">@@ -1,15 +1,23 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utility methods for docstring checking.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import itertools
<span class="w"> </span>import re
<span class="w"> </span>from collections.abc import Iterable
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="w"> </span>from astroid.util import UninferableBase
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import utils


<span class="gd">-def space_indentation(s: str) -&gt;int:</span>
<span class="gi">+def space_indentation(s: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;The number of leading spaces in a string.

<span class="w"> </span>    :param str s: input string
<span class="gu">@@ -17,10 +25,10 @@ def space_indentation(s: str) -&gt;int:</span>
<span class="w"> </span>    :rtype: int
<span class="w"> </span>    :return: number of leading spaces
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return len(s) - len(s.lstrip(&quot; &quot;))</span>


<span class="gd">-def get_setters_property_name(node: nodes.FunctionDef) -&gt;(str | None):</span>
<span class="gi">+def get_setters_property_name(node: nodes.FunctionDef) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the name of the property that the given node is a setter for.

<span class="w"> </span>    :param node: The node to get the property name for.
<span class="gu">@@ -30,10 +38,18 @@ def get_setters_property_name(node: nodes.FunctionDef) -&gt;(str | None):</span>
<span class="w"> </span>    :returns: The name of the property that the node is a setter for,
<span class="w"> </span>        or None if one could not be found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def get_setters_property(node: nodes.FunctionDef) -&gt;(nodes.FunctionDef | None):</span>
<span class="gi">+    decorators = node.decorators.nodes if node.decorators else []</span>
<span class="gi">+    for decorator in decorators:</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(decorator, nodes.Attribute)</span>
<span class="gi">+            and decorator.attrname == &quot;setter&quot;</span>
<span class="gi">+            and isinstance(decorator.expr, nodes.Name)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return decorator.expr.name  # type: ignore[no-any-return]</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_setters_property(node: nodes.FunctionDef) -&gt; nodes.FunctionDef | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the property node for the given setter node.

<span class="w"> </span>    :param node: The node to get the property for.
<span class="gu">@@ -43,10 +59,21 @@ def get_setters_property(node: nodes.FunctionDef) -&gt;(nodes.FunctionDef | None):</span>
<span class="w"> </span>    :returns: The node relating to the property of the given setter node,
<span class="w"> </span>        or None if one could not be found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    property_ = None</span>
<span class="gi">+</span>
<span class="gi">+    property_name = get_setters_property_name(node)</span>
<span class="gi">+    class_node = utils.node_frame_class(node)</span>
<span class="gi">+    if property_name and class_node:</span>
<span class="gi">+        class_attrs: list[nodes.FunctionDef] = class_node.getattr(node.name)</span>
<span class="gi">+        for attr in class_attrs:</span>
<span class="gi">+            if utils.decorated_with_property(attr):</span>
<span class="gi">+                property_ = attr</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    return property_</span>


<span class="gd">-def returns_something(return_node: nodes.Return) -&gt;bool:</span>
<span class="gi">+def returns_something(return_node: nodes.Return) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if a return node returns a value other than None.

<span class="w"> </span>    :param return_node: The return node to check.
<span class="gu">@@ -56,10 +83,28 @@ def returns_something(return_node: nodes.Return) -&gt;bool:</span>
<span class="w"> </span>    :return: True if the return node returns a value other than None,
<span class="w"> </span>        False otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    returns = return_node.value</span>

<span class="gi">+    if returns is None:</span>
<span class="gi">+        return False</span>

<span class="gd">-def possible_exc_types(node: nodes.NodeNG) -&gt;set[nodes.ClassDef]:</span>
<span class="gi">+    return not (isinstance(returns, nodes.Const) and returns.value is None)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_raise_target(node: nodes.NodeNG) -&gt; nodes.NodeNG | UninferableBase | None:</span>
<span class="gi">+    if isinstance(node.exc, nodes.Call):</span>
<span class="gi">+        func = node.exc.func</span>
<span class="gi">+        if isinstance(func, (nodes.Name, nodes.Attribute)):</span>
<span class="gi">+            return utils.safe_infer(func)</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _split_multiple_exc_types(target: str) -&gt; list[str]:</span>
<span class="gi">+    delimiters = r&quot;(\s*,(?:\s*or\s)?\s*|\s+or\s+)&quot;</span>
<span class="gi">+    return re.split(delimiters, target)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def possible_exc_types(node: nodes.NodeNG) -&gt; set[nodes.ClassDef]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Gets all the possible raised exception types for the given raise node.

<span class="w"> </span>    .. note::
<span class="gu">@@ -70,10 +115,69 @@ def possible_exc_types(node: nodes.NodeNG) -&gt;set[nodes.ClassDef]:</span>

<span class="w"> </span>    :returns: A list of exception types possibly raised by :param:`node`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _annotations_list(args_node: nodes.Arguments) -&gt;list[nodes.NodeNG]:</span>
<span class="gi">+    exceptions = []</span>
<span class="gi">+    if isinstance(node.exc, nodes.Name):</span>
<span class="gi">+        inferred = utils.safe_infer(node.exc)</span>
<span class="gi">+        if inferred:</span>
<span class="gi">+            exceptions = [inferred]</span>
<span class="gi">+    elif node.exc is None:</span>
<span class="gi">+        handler = node.parent</span>
<span class="gi">+        while handler and not isinstance(handler, nodes.ExceptHandler):</span>
<span class="gi">+            handler = handler.parent</span>
<span class="gi">+</span>
<span class="gi">+        if handler and handler.type:</span>
<span class="gi">+            try:</span>
<span class="gi">+                for exception in astroid.unpack_infer(handler.type):</span>
<span class="gi">+                    if not isinstance(exception, UninferableBase):</span>
<span class="gi">+                        exceptions.append(exception)</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        target = _get_raise_target(node)</span>
<span class="gi">+        if isinstance(target, nodes.ClassDef):</span>
<span class="gi">+            exceptions = [target]</span>
<span class="gi">+        elif isinstance(target, nodes.FunctionDef):</span>
<span class="gi">+            for ret in target.nodes_of_class(nodes.Return):</span>
<span class="gi">+                if ret.value is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if ret.frame() != target:</span>
<span class="gi">+                    # return from inner function - ignore it</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                val = utils.safe_infer(ret.value)</span>
<span class="gi">+                if val and utils.inherit_from_std_ex(val):</span>
<span class="gi">+                    if isinstance(val, nodes.ClassDef):</span>
<span class="gi">+                        exceptions.append(val)</span>
<span class="gi">+                    elif isinstance(val, astroid.Instance):</span>
<span class="gi">+                        exceptions.append(val.getattr(&quot;__class__&quot;)[0])</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return {</span>
<span class="gi">+            exc</span>
<span class="gi">+            for exc in exceptions</span>
<span class="gi">+            if not utils.node_ignores_exception(node, exc.name)</span>
<span class="gi">+        }</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return set()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_ellipsis(node: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+    return isinstance(node, nodes.Const) and node.value == Ellipsis</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _merge_annotations(</span>
<span class="gi">+    annotations: Iterable[nodes.NodeNG], comment_annotations: Iterable[nodes.NodeNG]</span>
<span class="gi">+) -&gt; Iterable[nodes.NodeNG | None]:</span>
<span class="gi">+    for ann, comment_ann in itertools.zip_longest(annotations, comment_annotations):</span>
<span class="gi">+        if ann and not _is_ellipsis(ann):</span>
<span class="gi">+            yield ann</span>
<span class="gi">+        elif comment_ann and not _is_ellipsis(comment_ann):</span>
<span class="gi">+            yield comment_ann</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _annotations_list(args_node: nodes.Arguments) -&gt; list[nodes.NodeNG]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get a merged list of annotations.

<span class="w"> </span>    The annotations can come from:
<span class="gu">@@ -85,103 +189,298 @@ def _annotations_list(args_node: nodes.Arguments) -&gt;list[nodes.NodeNG]:</span>
<span class="w"> </span>    :param args_node: The node to get the annotations for.
<span class="w"> </span>    :returns: The annotations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    plain_annotations = args_node.annotations or ()</span>
<span class="gi">+    func_comment_annotations = args_node.parent.type_comment_args or ()</span>
<span class="gi">+    comment_annotations = args_node.type_comment_posonlyargs</span>
<span class="gi">+    comment_annotations += args_node.type_comment_args or []</span>
<span class="gi">+    comment_annotations += args_node.type_comment_kwonlyargs</span>
<span class="gi">+    return list(</span>
<span class="gi">+        _merge_annotations(</span>
<span class="gi">+            plain_annotations,</span>
<span class="gi">+            _merge_annotations(func_comment_annotations, comment_annotations),</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def args_with_annotation(args_node: nodes.Arguments) -&gt; set[str]:</span>
<span class="gi">+    result = set()</span>
<span class="gi">+    annotations = _annotations_list(args_node)</span>
<span class="gi">+    annotation_offset = 0</span>
<span class="gi">+</span>
<span class="gi">+    if args_node.posonlyargs:</span>
<span class="gi">+        posonlyargs_annotations = args_node.posonlyargs_annotations</span>
<span class="gi">+        if not any(args_node.posonlyargs_annotations):</span>
<span class="gi">+            num_args = len(args_node.posonlyargs)</span>
<span class="gi">+            posonlyargs_annotations = annotations[</span>
<span class="gi">+                annotation_offset : annotation_offset + num_args</span>
<span class="gi">+            ]</span>
<span class="gi">+            annotation_offset += num_args</span>
<span class="gi">+</span>
<span class="gi">+        for arg, annotation in zip(args_node.posonlyargs, posonlyargs_annotations):</span>
<span class="gi">+            if annotation:</span>
<span class="gi">+                result.add(arg.name)</span>
<span class="gi">+</span>
<span class="gi">+    if args_node.args:</span>
<span class="gi">+        num_args = len(args_node.args)</span>
<span class="gi">+        for arg, annotation in zip(</span>
<span class="gi">+            args_node.args,</span>
<span class="gi">+            annotations[annotation_offset : annotation_offset + num_args],</span>
<span class="gi">+        ):</span>
<span class="gi">+            if annotation:</span>
<span class="gi">+                result.add(arg.name)</span>
<span class="gi">+</span>
<span class="gi">+        annotation_offset += num_args</span>
<span class="gi">+</span>
<span class="gi">+    if args_node.vararg:</span>
<span class="gi">+        if args_node.varargannotation:</span>
<span class="gi">+            result.add(args_node.vararg)</span>
<span class="gi">+        elif len(annotations) &gt; annotation_offset and annotations[annotation_offset]:</span>
<span class="gi">+            result.add(args_node.vararg)</span>
<span class="gi">+            annotation_offset += 1</span>
<span class="gi">+</span>
<span class="gi">+    if args_node.kwonlyargs:</span>
<span class="gi">+        kwonlyargs_annotations = args_node.kwonlyargs_annotations</span>
<span class="gi">+        if not any(args_node.kwonlyargs_annotations):</span>
<span class="gi">+            num_args = len(args_node.kwonlyargs)</span>
<span class="gi">+            kwonlyargs_annotations = annotations[</span>
<span class="gi">+                annotation_offset : annotation_offset + num_args</span>
<span class="gi">+            ]</span>
<span class="gi">+            annotation_offset += num_args</span>
<span class="gi">+</span>
<span class="gi">+        for arg, annotation in zip(args_node.kwonlyargs, kwonlyargs_annotations):</span>
<span class="gi">+            if annotation:</span>
<span class="gi">+                result.add(arg.name)</span>
<span class="gi">+</span>
<span class="gi">+    if args_node.kwarg:</span>
<span class="gi">+        if args_node.kwargannotation:</span>
<span class="gi">+            result.add(args_node.kwarg)</span>
<span class="gi">+        elif len(annotations) &gt; annotation_offset and annotations[annotation_offset]:</span>
<span class="gi">+            result.add(args_node.kwarg)</span>
<span class="gi">+            annotation_offset += 1</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def docstringify(</span>
<span class="gi">+    docstring: nodes.Const | None, default_type: str = &quot;default&quot;</span>
<span class="gi">+) -&gt; Docstring:</span>
<span class="gi">+    best_match = (0, DOCSTRING_TYPES.get(default_type, Docstring)(docstring))</span>
<span class="gi">+    for docstring_type in (</span>
<span class="gi">+        SphinxDocstring,</span>
<span class="gi">+        EpytextDocstring,</span>
<span class="gi">+        GoogleDocstring,</span>
<span class="gi">+        NumpyDocstring,</span>
<span class="gi">+    ):</span>
<span class="gi">+        instance = docstring_type(docstring)</span>
<span class="gi">+        matching_sections = instance.matching_sections()</span>
<span class="gi">+        if matching_sections &gt; best_match[0]:</span>
<span class="gi">+            best_match = (matching_sections, instance)</span>
<span class="gi">+</span>
<span class="gi">+    return best_match[1]</span>


<span class="w"> </span>class Docstring:
<span class="w"> </span>    re_for_parameters_see = re.compile(
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        For\\s+the\\s+(other)?\\s*parameters\\s*,\\s+see</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        , re.X | re.S)</span>
<span class="gi">+        r&quot;&quot;&quot;</span>
<span class="gi">+        For\s+the\s+(other)?\s*parameters\s*,\s+see</span>
<span class="gi">+        &quot;&quot;&quot;,</span>
<span class="gi">+        re.X | re.S,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    supports_yields: bool = False
<span class="w"> </span>    &quot;&quot;&quot;True if the docstring supports a &quot;yield&quot; section.

<span class="w"> </span>    False if the docstring uses the returns section to document generators.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, doc: (nodes.Const | None)) -&gt;None:</span>
<span class="gd">-        docstring: str = doc.value if doc else &#39;&#39;</span>
<span class="gi">+    # These methods are designed to be overridden</span>
<span class="gi">+    def __init__(self, doc: nodes.Const | None) -&gt; None:</span>
<span class="gi">+        docstring: str = doc.value if doc else &quot;&quot;</span>
<span class="w"> </span>        self.doc = docstring.expandtabs()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&quot;&lt;{self.__class__.__name__}:&#39;&#39;&#39;{self.doc}&#39;&#39;&#39;&gt;&quot;

<span class="gd">-    def matching_sections(self) -&gt;int:</span>
<span class="gi">+    def matching_sections(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of matching docstring sections.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    def exceptions(self) -&gt; set[str]:</span>
<span class="gi">+        return set()</span>
<span class="gi">+</span>
<span class="gi">+    def has_params(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def has_returns(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def has_rtype(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def has_property_returns(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def has_property_type(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def has_yields(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def has_yields_type(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def match_param_docs(self) -&gt; tuple[set[str], set[str]]:</span>
<span class="gi">+        return set(), set()</span>
<span class="gi">+</span>
<span class="gi">+    def params_documented_elsewhere(self) -&gt; bool:</span>
<span class="gi">+        return self.re_for_parameters_see.search(self.doc) is not None</span>


<span class="w"> </span>class SphinxDocstring(Docstring):
<span class="gd">-    re_type = &quot;&quot;&quot;</span>
<span class="gi">+    re_type = r&quot;&quot;&quot;</span>
<span class="w"> </span>        [~!.]?               # Optional link style prefix
<span class="gd">-        \\w(?:\\w|\\.[^\\.])*    # Valid python name</span>
<span class="gi">+        \w(?:\w|\.[^\.])*    # Valid python name</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-    re_simple_container_type = f&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    re_simple_container_type = rf&quot;&quot;&quot;</span>
<span class="w"> </span>        {re_type}                     # a container type
<span class="gd">-        [\\(\\[] [^\\n\\s]+ [\\)\\]]        # with the contents of the container</span>
<span class="gi">+        [\(\[] [^\n\s]+ [\)\]]        # with the contents of the container</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    re_multiple_simple_type = f&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    re_multiple_simple_type = rf&quot;&quot;&quot;</span>
<span class="w"> </span>        (?:{re_simple_container_type}|{re_type})
<span class="gd">-        (?:(?:\\s+(?:of|or)\\s+|\\s*,\\s*|\\s+\\|\\s+)(?:{re_simple_container_type}|{re_type}))*</span>
<span class="gi">+        (?:(?:\s+(?:of|or)\s+|\s*,\s*|\s+\|\s+)(?:{re_simple_container_type}|{re_type}))*</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    re_xref = f&quot;&quot;&quot;</span>
<span class="gd">-        (?::\\w+:)?                    # optional tag</span>
<span class="gi">+</span>
<span class="gi">+    re_xref = rf&quot;&quot;&quot;</span>
<span class="gi">+        (?::\w+:)?                    # optional tag</span>
<span class="w"> </span>        `{re_type}`                   # what to reference
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-    re_param_raw = f&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    re_param_raw = rf&quot;&quot;&quot;</span>
<span class="w"> </span>        :                       # initial colon
<span class="w"> </span>        (?:                     # Sphinx keywords
<span class="w"> </span>        param|parameter|
<span class="w"> </span>        arg|argument|
<span class="w"> </span>        key|keyword
<span class="w"> </span>        )
<span class="gd">-        \\s+                     # whitespace</span>
<span class="gi">+        \s+                     # whitespace</span>

<span class="w"> </span>        (?:                     # optional type declaration
<span class="w"> </span>        ({re_type}|{re_simple_container_type})
<span class="gd">-        \\s+</span>
<span class="gi">+        \s+</span>
<span class="w"> </span>        )?

<span class="gd">-        ((\\\\\\*{{0,2}}\\w+)|(\\w+))  # Parameter name with potential asterisks</span>
<span class="gd">-        \\s*                       # whitespace</span>
<span class="gi">+        ((\\\*{{0,2}}\w+)|(\w+))  # Parameter name with potential asterisks</span>
<span class="gi">+        \s*                       # whitespace</span>
<span class="w"> </span>        :                         # final colon
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>    re_param_in_docstring = re.compile(re_param_raw, re.X | re.S)
<span class="gd">-    re_type_raw = f&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    re_type_raw = rf&quot;&quot;&quot;</span>
<span class="w"> </span>        :type                           # Sphinx keyword
<span class="gd">-        \\s+                             # whitespace</span>
<span class="gi">+        \s+                             # whitespace</span>
<span class="w"> </span>        ({re_multiple_simple_type})     # Parameter name
<span class="gd">-        \\s*                             # whitespace</span>
<span class="gi">+        \s*                             # whitespace</span>
<span class="w"> </span>        :                               # final colon
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>    re_type_in_docstring = re.compile(re_type_raw, re.X | re.S)
<span class="gd">-    re_property_type_raw = f&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    re_property_type_raw = rf&quot;&quot;&quot;</span>
<span class="w"> </span>        :type:                      # Sphinx keyword
<span class="gd">-        \\s+                         # whitespace</span>
<span class="gi">+        \s+                         # whitespace</span>
<span class="w"> </span>        {re_multiple_simple_type}   # type declaration
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-    re_property_type_in_docstring = re.compile(re_property_type_raw, re.X |</span>
<span class="gd">-        re.S)</span>
<span class="gd">-    re_raise_raw = f&quot;&quot;&quot;</span>
<span class="gi">+    re_property_type_in_docstring = re.compile(re_property_type_raw, re.X | re.S)</span>
<span class="gi">+</span>
<span class="gi">+    re_raise_raw = rf&quot;&quot;&quot;</span>
<span class="w"> </span>        :                               # initial colon
<span class="w"> </span>        (?:                             # Sphinx keyword
<span class="w"> </span>        raises?|
<span class="w"> </span>        except|exception
<span class="w"> </span>        )
<span class="gd">-        \\s+                             # whitespace</span>
<span class="gi">+        \s+                             # whitespace</span>
<span class="w"> </span>        ({re_multiple_simple_type})     # exception type
<span class="gd">-        \\s*                             # whitespace</span>
<span class="gi">+        \s*                             # whitespace</span>
<span class="w"> </span>        :                               # final colon
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>    re_raise_in_docstring = re.compile(re_raise_raw, re.X | re.S)
<span class="gd">-    re_rtype_in_docstring = re.compile(&#39;:rtype:&#39;)</span>
<span class="gd">-    re_returns_in_docstring = re.compile(&#39;:returns?:&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    re_rtype_in_docstring = re.compile(r&quot;:rtype:&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    re_returns_in_docstring = re.compile(r&quot;:returns?:&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>    supports_yields = False

<span class="gd">-    def matching_sections(self) -&gt;int:</span>
<span class="gi">+    def matching_sections(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of matching docstring sections.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sum(</span>
<span class="gi">+            bool(i)</span>
<span class="gi">+            for i in (</span>
<span class="gi">+                self.re_param_in_docstring.search(self.doc),</span>
<span class="gi">+                self.re_raise_in_docstring.search(self.doc),</span>
<span class="gi">+                self.re_rtype_in_docstring.search(self.doc),</span>
<span class="gi">+                self.re_returns_in_docstring.search(self.doc),</span>
<span class="gi">+                self.re_property_type_in_docstring.search(self.doc),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def exceptions(self) -&gt; set[str]:</span>
<span class="gi">+        types: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        for match in re.finditer(self.re_raise_in_docstring, self.doc):</span>
<span class="gi">+            raise_type = match.group(1)</span>
<span class="gi">+            types.update(_split_multiple_exc_types(raise_type))</span>
<span class="gi">+</span>
<span class="gi">+        return types</span>
<span class="gi">+</span>
<span class="gi">+    def has_params(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return self.re_param_in_docstring.search(self.doc) is not None</span>
<span class="gi">+</span>
<span class="gi">+    def has_returns(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return bool(self.re_returns_in_docstring.search(self.doc))</span>
<span class="gi">+</span>
<span class="gi">+    def has_rtype(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return bool(self.re_rtype_in_docstring.search(self.doc))</span>
<span class="gi">+</span>
<span class="gi">+    def has_property_returns(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # The summary line is the return doc,</span>
<span class="gi">+        # so the first line must not be a known directive.</span>
<span class="gi">+        return not self.doc.lstrip().startswith(&quot;:&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def has_property_type(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return bool(self.re_property_type_in_docstring.search(self.doc))</span>
<span class="gi">+</span>
<span class="gi">+    def match_param_docs(self) -&gt; tuple[set[str], set[str]]:</span>
<span class="gi">+        params_with_doc = set()</span>
<span class="gi">+        params_with_type = set()</span>
<span class="gi">+</span>
<span class="gi">+        for match in re.finditer(self.re_param_in_docstring, self.doc):</span>
<span class="gi">+            name = match.group(2)</span>
<span class="gi">+            # Remove escape characters necessary for asterisks</span>
<span class="gi">+            name = name.replace(&quot;\\&quot;, &quot;&quot;)</span>
<span class="gi">+            params_with_doc.add(name)</span>
<span class="gi">+            param_type = match.group(1)</span>
<span class="gi">+            if param_type is not None:</span>
<span class="gi">+                params_with_type.add(name)</span>
<span class="gi">+</span>
<span class="gi">+        params_with_type.update(re.findall(self.re_type_in_docstring, self.doc))</span>
<span class="gi">+        return params_with_doc, params_with_type</span>


<span class="w"> </span>class EpytextDocstring(SphinxDocstring):
<span class="gu">@@ -195,144 +494,452 @@ class EpytextDocstring(SphinxDocstring):</span>
<span class="w"> </span>        https://www.jetbrains.com/help/pycharm/2016.1/creating-documentation-comments.html#d848203e314
<span class="w"> </span>        https://www.jetbrains.com/help/pycharm/2016.1/using-docstrings-to-specify-types.html
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    re_param_in_docstring = re.compile(SphinxDocstring.re_param_raw.replace</span>
<span class="gd">-        (&#39;:&#39;, &#39;@&#39;, 1), re.X | re.S)</span>
<span class="gd">-    re_type_in_docstring = re.compile(SphinxDocstring.re_type_raw.replace(</span>
<span class="gd">-        &#39;:&#39;, &#39;@&#39;, 1), re.X | re.S)</span>
<span class="gd">-    re_property_type_in_docstring = re.compile(SphinxDocstring.</span>
<span class="gd">-        re_property_type_raw.replace(&#39;:&#39;, &#39;@&#39;, 1), re.X | re.S)</span>
<span class="gd">-    re_raise_in_docstring = re.compile(SphinxDocstring.re_raise_raw.replace</span>
<span class="gd">-        (&#39;:&#39;, &#39;@&#39;, 1), re.X | re.S)</span>
<span class="gi">+</span>
<span class="gi">+    re_param_in_docstring = re.compile(</span>
<span class="gi">+        SphinxDocstring.re_param_raw.replace(&quot;:&quot;, &quot;@&quot;, 1), re.X | re.S</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_type_in_docstring = re.compile(</span>
<span class="gi">+        SphinxDocstring.re_type_raw.replace(&quot;:&quot;, &quot;@&quot;, 1), re.X | re.S</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_property_type_in_docstring = re.compile(</span>
<span class="gi">+        SphinxDocstring.re_property_type_raw.replace(&quot;:&quot;, &quot;@&quot;, 1), re.X | re.S</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_raise_in_docstring = re.compile(</span>
<span class="gi">+        SphinxDocstring.re_raise_raw.replace(&quot;:&quot;, &quot;@&quot;, 1), re.X | re.S</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    re_rtype_in_docstring = re.compile(
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        r&quot;&quot;&quot;</span>
<span class="w"> </span>        @                       # initial &quot;at&quot; symbol
<span class="w"> </span>        (?:                     # Epytext keyword
<span class="w"> </span>        rtype|returntype
<span class="w"> </span>        )
<span class="w"> </span>        :                       # final colon
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        , re.X | re.S)</span>
<span class="gd">-    re_returns_in_docstring = re.compile(&#39;@returns?:&#39;)</span>
<span class="gi">+        &quot;&quot;&quot;,</span>
<span class="gi">+        re.X | re.S,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_returns_in_docstring = re.compile(r&quot;@returns?:&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def has_property_returns(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # If this is a property docstring, the summary is the return doc.</span>
<span class="gi">+        if self.has_property_type():</span>
<span class="gi">+            # The summary line is the return doc,</span>
<span class="gi">+            # so the first line must not be a known directive.</span>
<span class="gi">+            return not self.doc.lstrip().startswith(&quot;@&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>


<span class="w"> </span>class GoogleDocstring(Docstring):
<span class="w"> </span>    re_type = SphinxDocstring.re_type
<span class="gi">+</span>
<span class="w"> </span>    re_xref = SphinxDocstring.re_xref
<span class="gd">-    re_container_type = f&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    re_container_type = rf&quot;&quot;&quot;</span>
<span class="w"> </span>        (?:{re_type}|{re_xref})       # a container type
<span class="gd">-        [\\(\\[] [^\\n]+ [\\)\\]]          # with the contents of the container</span>
<span class="gi">+        [\(\[] [^\n]+ [\)\]]          # with the contents of the container</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    re_multiple_type = f&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    re_multiple_type = rf&quot;&quot;&quot;</span>
<span class="w"> </span>        (?:{re_container_type}|{re_type}|{re_xref})
<span class="gd">-        (?:(?:\\s+(?:of|or)\\s+|\\s*,\\s*|\\s+\\|\\s+)(?:{re_container_type}|{re_type}|{re_xref}))*</span>
<span class="gi">+        (?:(?:\s+(?:of|or)\s+|\s*,\s*|\s+\|\s+)(?:{re_container_type}|{re_type}|{re_xref}))*</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _re_section_template = &quot;&quot;&quot;</span>
<span class="gd">-        ^([ ]*)   {0} \\s*:   \\s*$     # Google parameter header</span>
<span class="gi">+</span>
<span class="gi">+    _re_section_template = r&quot;&quot;&quot;</span>
<span class="gi">+        ^([ ]*)   {0} \s*:   \s*$     # Google parameter header</span>
<span class="w"> </span>        (  .* )                       # section
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-    re_param_section = re.compile(_re_section_template.format(</span>
<span class="gd">-        &#39;(?:Args|Arguments|Parameters)&#39;), re.X | re.S | re.M)</span>
<span class="gd">-    re_keyword_param_section = re.compile(_re_section_template.format(</span>
<span class="gd">-        &#39;Keyword\\s(?:Args|Arguments|Parameters)&#39;), re.X | re.S | re.M)</span>
<span class="gi">+</span>
<span class="gi">+    re_param_section = re.compile(</span>
<span class="gi">+        _re_section_template.format(r&quot;(?:Args|Arguments|Parameters)&quot;),</span>
<span class="gi">+        re.X | re.S | re.M,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_keyword_param_section = re.compile(</span>
<span class="gi">+        _re_section_template.format(r&quot;Keyword\s(?:Args|Arguments|Parameters)&quot;),</span>
<span class="gi">+        re.X | re.S | re.M,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    re_param_line = re.compile(
<span class="gd">-        f&quot;&quot;&quot;</span>
<span class="gd">-        \\s*  ((?:\\\\?\\*{{0,2}})?[\\w\\\\]+) # identifier potentially with asterisks or escaped `\\`</span>
<span class="gd">-        \\s*  ( [(]</span>
<span class="gi">+        rf&quot;&quot;&quot;</span>
<span class="gi">+        \s*  ((?:\\?\*{{0,2}})?[\w\\]+) # identifier potentially with asterisks or escaped `\`</span>
<span class="gi">+        \s*  ( [(]</span>
<span class="w"> </span>            {re_multiple_type}
<span class="gd">-            (?:,\\s+optional)?</span>
<span class="gd">-            [)] )? \\s* :                # optional type declaration</span>
<span class="gd">-        \\s*  (.*)                       # beginning of optional description</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        , re.X | re.S | re.M)</span>
<span class="gd">-    re_raise_section = re.compile(_re_section_template.format(&#39;Raises&#39;), re</span>
<span class="gd">-        .X | re.S | re.M)</span>
<span class="gi">+            (?:,\s+optional)?</span>
<span class="gi">+            [)] )? \s* :                # optional type declaration</span>
<span class="gi">+        \s*  (.*)                       # beginning of optional description</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+        re.X | re.S | re.M,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_raise_section = re.compile(</span>
<span class="gi">+        _re_section_template.format(r&quot;Raises&quot;), re.X | re.S | re.M</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    re_raise_line = re.compile(
<span class="gd">-        f&quot;&quot;&quot;</span>
<span class="gd">-        \\s*  ({re_multiple_type}) \\s* :  # identifier</span>
<span class="gd">-        \\s*  (.*)                        # beginning of optional description</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        , re.X | re.S | re.M)</span>
<span class="gd">-    re_returns_section = re.compile(_re_section_template.format(&#39;Returns?&#39;),</span>
<span class="gd">-        re.X | re.S | re.M)</span>
<span class="gi">+        rf&quot;&quot;&quot;</span>
<span class="gi">+        \s*  ({re_multiple_type}) \s* :  # identifier</span>
<span class="gi">+        \s*  (.*)                        # beginning of optional description</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+        re.X | re.S | re.M,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_returns_section = re.compile(</span>
<span class="gi">+        _re_section_template.format(r&quot;Returns?&quot;), re.X | re.S | re.M</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    re_returns_line = re.compile(
<span class="gd">-        f&quot;&quot;&quot;</span>
<span class="gd">-        \\s* ({re_multiple_type}:)?        # identifier</span>
<span class="gd">-        \\s* (.*)                          # beginning of description</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        , re.X | re.S | re.M)</span>
<span class="gi">+        rf&quot;&quot;&quot;</span>
<span class="gi">+        \s* ({re_multiple_type}:)?        # identifier</span>
<span class="gi">+        \s* (.*)                          # beginning of description</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+        re.X | re.S | re.M,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    re_property_returns_line = re.compile(
<span class="gd">-        f&quot;&quot;&quot;</span>
<span class="gi">+        rf&quot;&quot;&quot;</span>
<span class="w"> </span>        ^{re_multiple_type}:           # identifier
<span class="gd">-        \\s* (.*)                       # Summary line / description</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        , re.X | re.S | re.M)</span>
<span class="gd">-    re_yields_section = re.compile(_re_section_template.format(&#39;Yields?&#39;), </span>
<span class="gd">-        re.X | re.S | re.M)</span>
<span class="gi">+        \s* (.*)                       # Summary line / description</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+        re.X | re.S | re.M,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_yields_section = re.compile(</span>
<span class="gi">+        _re_section_template.format(r&quot;Yields?&quot;), re.X | re.S | re.M</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    re_yields_line = re_returns_line
<span class="gi">+</span>
<span class="w"> </span>    supports_yields = True

<span class="gd">-    def matching_sections(self) -&gt;int:</span>
<span class="gi">+    def matching_sections(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the number of matching docstring sections.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sum(</span>
<span class="gi">+            bool(i)</span>
<span class="gi">+            for i in (</span>
<span class="gi">+                self.re_param_section.search(self.doc),</span>
<span class="gi">+                self.re_raise_section.search(self.doc),</span>
<span class="gi">+                self.re_returns_section.search(self.doc),</span>
<span class="gi">+                self.re_yields_section.search(self.doc),</span>
<span class="gi">+                self.re_property_returns_line.search(self._first_line()),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def has_params(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return self.re_param_section.search(self.doc) is not None</span>
<span class="gi">+</span>
<span class="gi">+    def has_returns(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        entries = self._parse_section(self.re_returns_section)</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            match = self.re_returns_line.match(entry)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            return_desc = match.group(2)</span>
<span class="gi">+            if return_desc:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def has_rtype(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        entries = self._parse_section(self.re_returns_section)</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            match = self.re_returns_line.match(entry)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            return_type = match.group(1)</span>
<span class="gi">+            if return_type:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def has_property_returns(self) -&gt; bool:</span>
<span class="gi">+        # The summary line is the return doc,</span>
<span class="gi">+        # so the first line must not be a known directive.</span>
<span class="gi">+        first_line = self._first_line()</span>
<span class="gi">+        return not bool(</span>
<span class="gi">+            self.re_param_section.search(first_line)</span>
<span class="gi">+            or self.re_raise_section.search(first_line)</span>
<span class="gi">+            or self.re_returns_section.search(first_line)</span>
<span class="gi">+            or self.re_yields_section.search(first_line)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def has_property_type(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return bool(self.re_property_returns_line.match(self._first_line()))</span>
<span class="gi">+</span>
<span class="gi">+    def has_yields(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        entries = self._parse_section(self.re_yields_section)</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            match = self.re_yields_line.match(entry)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            yield_desc = match.group(2)</span>
<span class="gi">+            if yield_desc:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def has_yields_type(self) -&gt; bool:</span>
<span class="gi">+        if not self.doc:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        entries = self._parse_section(self.re_yields_section)</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            match = self.re_yields_line.match(entry)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            yield_type = match.group(1)</span>
<span class="gi">+            if yield_type:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def exceptions(self) -&gt; set[str]:</span>
<span class="gi">+        types: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        entries = self._parse_section(self.re_raise_section)</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            match = self.re_raise_line.match(entry)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            exc_type = match.group(1)</span>
<span class="gi">+            exc_desc = match.group(2)</span>
<span class="gi">+            if exc_desc:</span>
<span class="gi">+                types.update(_split_multiple_exc_types(exc_type))</span>
<span class="gi">+</span>
<span class="gi">+        return types</span>
<span class="gi">+</span>
<span class="gi">+    def match_param_docs(self) -&gt; tuple[set[str], set[str]]:</span>
<span class="gi">+        params_with_doc: set[str] = set()</span>
<span class="gi">+        params_with_type: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        entries = self._parse_section(self.re_param_section)</span>
<span class="gi">+        entries.extend(self._parse_section(self.re_keyword_param_section))</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            match = self.re_param_line.match(entry)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            param_name = match.group(1)</span>
<span class="gi">+            # Remove escape characters necessary for asterisks</span>
<span class="gi">+            param_name = param_name.replace(&quot;\\&quot;, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            param_type = match.group(2)</span>
<span class="gi">+            param_desc = match.group(3)</span>
<span class="gi">+</span>
<span class="gi">+            if param_type:</span>
<span class="gi">+                params_with_type.add(param_name)</span>
<span class="gi">+</span>
<span class="gi">+            if param_desc:</span>
<span class="gi">+                params_with_doc.add(param_name)</span>
<span class="gi">+</span>
<span class="gi">+        return params_with_doc, params_with_type</span>
<span class="gi">+</span>
<span class="gi">+    def _first_line(self) -&gt; str:</span>
<span class="gi">+        return self.doc.lstrip().split(&quot;\n&quot;, 1)[0]</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def min_section_indent(section_match: re.Match[str]) -&gt; int:</span>
<span class="gi">+        return len(section_match.group(1)) + 1</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_section_header(_: str) -&gt; bool:</span>
<span class="gi">+        # Google parsing does not need to detect section headers,</span>
<span class="gi">+        # because it works off of indentation level only</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_section(self, section_re: re.Pattern[str]) -&gt; list[str]:</span>
<span class="gi">+        section_match = section_re.search(self.doc)</span>
<span class="gi">+        if section_match is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        min_indentation = self.min_section_indent(section_match)</span>
<span class="gi">+</span>
<span class="gi">+        entries: list[str] = []</span>
<span class="gi">+        entry: list[str] = []</span>
<span class="gi">+        is_first = True</span>
<span class="gi">+        for line in section_match.group(2).splitlines():</span>
<span class="gi">+            if not line.strip():</span>
<span class="gi">+                continue</span>
<span class="gi">+            indentation = space_indentation(line)</span>
<span class="gi">+            if indentation &lt; min_indentation:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            # The first line after the header defines the minimum</span>
<span class="gi">+            # indentation.</span>
<span class="gi">+            if is_first:</span>
<span class="gi">+                min_indentation = indentation</span>
<span class="gi">+                is_first = False</span>
<span class="gi">+</span>
<span class="gi">+            if indentation == min_indentation:</span>
<span class="gi">+                if self._is_section_header(line):</span>
<span class="gi">+                    break</span>
<span class="gi">+                # Lines with minimum indentation must contain the beginning</span>
<span class="gi">+                # of a new parameter documentation.</span>
<span class="gi">+                if entry:</span>
<span class="gi">+                    entries.append(&quot;\n&quot;.join(entry))</span>
<span class="gi">+                    entry = []</span>
<span class="gi">+</span>
<span class="gi">+            entry.append(line)</span>
<span class="gi">+</span>
<span class="gi">+        if entry:</span>
<span class="gi">+            entries.append(&quot;\n&quot;.join(entry))</span>
<span class="gi">+</span>
<span class="gi">+        return entries</span>


<span class="w"> </span>class NumpyDocstring(GoogleDocstring):
<span class="gd">-    _re_section_template = &quot;&quot;&quot;</span>
<span class="gd">-        ^([ ]*)   {0}   \\s*?$          # Numpy parameters header</span>
<span class="gd">-        \\s*     [-=]+   \\s*?$          # underline</span>
<span class="gi">+    _re_section_template = r&quot;&quot;&quot;</span>
<span class="gi">+        ^([ ]*)   {0}   \s*?$          # Numpy parameters header</span>
<span class="gi">+        \s*     [-=]+   \s*?$          # underline</span>
<span class="w"> </span>        (  .* )                        # section
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    re_param_section = re.compile(_re_section_template.format(</span>
<span class="gd">-        &#39;(?:Args|Arguments|Parameters)&#39;), re.X | re.S | re.M)</span>
<span class="gd">-    re_default_value = &#39;(([\&#39;&quot;]\\w+\\s*[\&#39;&quot;])|(\\d+)|(True)|(False)|(None))&#39;</span>
<span class="gi">+</span>
<span class="gi">+    re_param_section = re.compile(</span>
<span class="gi">+        _re_section_template.format(r&quot;(?:Args|Arguments|Parameters)&quot;),</span>
<span class="gi">+        re.X | re.S | re.M,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_default_value = r&quot;&quot;&quot;(([&#39;&quot;]\w+\s*[&#39;&quot;])|(\d+)|(True)|(False)|(None))&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    re_param_line = re.compile(
<span class="gd">-        f&quot;&quot;&quot;</span>
<span class="gd">-        \\s*  (?P&lt;param_name&gt;\\*{{0,2}}\\w+)(\\s?(:|\\n)) # identifier with potential asterisks</span>
<span class="gd">-        \\s*</span>
<span class="gi">+        rf&quot;&quot;&quot;</span>
<span class="gi">+        \s*  (?P&lt;param_name&gt;\*{{0,2}}\w+)(\s?(:|\n)) # identifier with potential asterisks</span>
<span class="gi">+        \s*</span>
<span class="w"> </span>        (?P&lt;param_type&gt;
<span class="w"> </span>         (
<span class="w"> </span>          ({GoogleDocstring.re_multiple_type})      # default type declaration
<span class="gd">-          (,\\s+optional)?                           # optional &#39;optional&#39; indication</span>
<span class="gi">+          (,\s+optional)?                           # optional &#39;optional&#39; indication</span>
<span class="w"> </span>         )?
<span class="w"> </span>         (
<span class="gd">-          {{({re_default_value},?\\s*)+}}            # set of default values</span>
<span class="gi">+          {{({re_default_value},?\s*)+}}            # set of default values</span>
<span class="w"> </span>         )?
<span class="gd">-         (?:$|\\n)</span>
<span class="gi">+         (?:$|\n)</span>
<span class="w"> </span>        )?
<span class="w"> </span>        (
<span class="gd">-         \\s* (?P&lt;param_desc&gt;.*)                     # optional description</span>
<span class="gi">+         \s* (?P&lt;param_desc&gt;.*)                     # optional description</span>
<span class="w"> </span>        )?
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        , re.X | re.S)</span>
<span class="gd">-    re_raise_section = re.compile(_re_section_template.format(&#39;Raises&#39;), re</span>
<span class="gd">-        .X | re.S | re.M)</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+        re.X | re.S,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_raise_section = re.compile(</span>
<span class="gi">+        _re_section_template.format(r&quot;Raises&quot;), re.X | re.S | re.M</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    re_raise_line = re.compile(
<span class="gd">-        f&quot;&quot;&quot;</span>
<span class="gd">-        \\s* ({GoogleDocstring.re_type})$   # type declaration</span>
<span class="gd">-        \\s* (.*)                           # optional description</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        , re.X | re.S | re.M)</span>
<span class="gd">-    re_returns_section = re.compile(_re_section_template.format(&#39;Returns?&#39;),</span>
<span class="gd">-        re.X | re.S | re.M)</span>
<span class="gi">+        rf&quot;&quot;&quot;</span>
<span class="gi">+        \s* ({GoogleDocstring.re_type})$   # type declaration</span>
<span class="gi">+        \s* (.*)                           # optional description</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+        re.X | re.S | re.M,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_returns_section = re.compile(</span>
<span class="gi">+        _re_section_template.format(r&quot;Returns?&quot;), re.X | re.S | re.M</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    re_returns_line = re.compile(
<span class="gd">-        f&quot;&quot;&quot;</span>
<span class="gd">-        \\s* (?:\\w+\\s+:\\s+)? # optional name</span>
<span class="gi">+        rf&quot;&quot;&quot;</span>
<span class="gi">+        \s* (?:\w+\s+:\s+)? # optional name</span>
<span class="w"> </span>        ({GoogleDocstring.re_multiple_type})$   # type declaration
<span class="gd">-        \\s* (.*)                                # optional description</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        , re.X | re.S | re.M)</span>
<span class="gd">-    re_yields_section = re.compile(_re_section_template.format(&#39;Yields?&#39;), </span>
<span class="gd">-        re.X | re.S | re.M)</span>
<span class="gi">+        \s* (.*)                                # optional description</span>
<span class="gi">+    &quot;&quot;&quot;,</span>
<span class="gi">+        re.X | re.S | re.M,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    re_yields_section = re.compile(</span>
<span class="gi">+        _re_section_template.format(r&quot;Yields?&quot;), re.X | re.S | re.M</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    re_yields_line = re_returns_line
<span class="gi">+</span>
<span class="w"> </span>    supports_yields = True

<span class="gd">-    def match_param_docs(self) -&gt;tuple[set[str], set[str]]:</span>
<span class="gi">+    def match_param_docs(self) -&gt; tuple[set[str], set[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Matches parameter documentation section to parameter documentation rules.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-DOCSTRING_TYPES = {&#39;sphinx&#39;: SphinxDocstring, &#39;epytext&#39;: EpytextDocstring,</span>
<span class="gd">-    &#39;google&#39;: GoogleDocstring, &#39;numpy&#39;: NumpyDocstring, &#39;default&#39;: Docstring}</span>
<span class="gi">+        params_with_doc = set()</span>
<span class="gi">+        params_with_type = set()</span>
<span class="gi">+</span>
<span class="gi">+        entries = self._parse_section(self.re_param_section)</span>
<span class="gi">+        entries.extend(self._parse_section(self.re_keyword_param_section))</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            match = self.re_param_line.match(entry)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # check if parameter has description only</span>
<span class="gi">+            re_only_desc = re.match(r&quot;\s*(\*{0,2}\w+)\s*:?\n\s*\w*$&quot;, entry)</span>
<span class="gi">+            if re_only_desc:</span>
<span class="gi">+                param_name = match.group(&quot;param_name&quot;)</span>
<span class="gi">+                param_desc = match.group(&quot;param_type&quot;)</span>
<span class="gi">+                param_type = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                param_name = match.group(&quot;param_name&quot;)</span>
<span class="gi">+                param_type = match.group(&quot;param_type&quot;)</span>
<span class="gi">+                param_desc = match.group(&quot;param_desc&quot;)</span>
<span class="gi">+                # The re_param_line pattern needs to match multi-line which removes the ability</span>
<span class="gi">+                # to match a single line description like &#39;arg : a number type.&#39;</span>
<span class="gi">+                # We are not trying to determine whether &#39;a number type&#39; is correct typing</span>
<span class="gi">+                # but we do accept it as typing as it is in the place where typing</span>
<span class="gi">+                # should be</span>
<span class="gi">+                if param_type is None and re.match(r&quot;\s*(\*{0,2}\w+)\s*:.+$&quot;, entry):</span>
<span class="gi">+                    param_type = param_desc</span>
<span class="gi">+                # If the description is &quot;&quot; but we have a type description</span>
<span class="gi">+                # we consider the description to be the type</span>
<span class="gi">+                if not param_desc and param_type:</span>
<span class="gi">+                    param_desc = param_type</span>
<span class="gi">+</span>
<span class="gi">+            if param_type:</span>
<span class="gi">+                params_with_type.add(param_name)</span>
<span class="gi">+</span>
<span class="gi">+            if param_desc:</span>
<span class="gi">+                params_with_doc.add(param_name)</span>
<span class="gi">+</span>
<span class="gi">+        return params_with_doc, params_with_type</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def min_section_indent(section_match: re.Match[str]) -&gt; int:</span>
<span class="gi">+        return len(section_match.group(1))</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_section_header(line: str) -&gt; bool:</span>
<span class="gi">+        return bool(re.match(r&quot;\s*-+$&quot;, line))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+DOCSTRING_TYPES = {</span>
<span class="gi">+    &quot;sphinx&quot;: SphinxDocstring,</span>
<span class="gi">+    &quot;epytext&quot;: EpytextDocstring,</span>
<span class="gi">+    &quot;google&quot;: GoogleDocstring,</span>
<span class="gi">+    &quot;numpy&quot;: NumpyDocstring,</span>
<span class="gi">+    &quot;default&quot;: Docstring,</span>
<span class="gi">+}</span>
<span class="w"> </span>&quot;&quot;&quot;A map of the name of the docstring type to its class.

<span class="w"> </span>:type: dict(str, type)
<span class="gh">diff --git a/pylint/extensions/bad_builtin.py b/pylint/extensions/bad_builtin.py</span>
<span class="gh">index 89b47f852..79cc5d9f4 100644</span>
<span class="gd">--- a/pylint/extensions/bad_builtin.py</span>
<span class="gi">+++ b/pylint/extensions/bad_builtin.py</span>
<span class="gu">@@ -1,22 +1,65 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checker for deprecated builtins.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-BAD_FUNCTIONS = [&#39;map&#39;, &#39;filter&#39;]</span>
<span class="gd">-LIST_COMP_MSG = &#39;Using a list comprehension can be clearer.&#39;</span>
<span class="gd">-BUILTIN_HINTS = {&#39;map&#39;: LIST_COMP_MSG, &#39;filter&#39;: LIST_COMP_MSG}</span>
<span class="gi">+</span>
<span class="gi">+BAD_FUNCTIONS = [&quot;map&quot;, &quot;filter&quot;]</span>
<span class="gi">+# Some hints regarding the use of bad builtins.</span>
<span class="gi">+LIST_COMP_MSG = &quot;Using a list comprehension can be clearer.&quot;</span>
<span class="gi">+BUILTIN_HINTS = {&quot;map&quot;: LIST_COMP_MSG, &quot;filter&quot;: LIST_COMP_MSG}</span>


<span class="w"> </span>class BadBuiltinChecker(BaseChecker):
<span class="gd">-    name = &#39;deprecated_builtins&#39;</span>
<span class="gd">-    msgs = {&#39;W0141&#39;: (&#39;Used builtin function %s&#39;, &#39;bad-builtin&#39;,</span>
<span class="gd">-        &#39;Used when a disallowed builtin function is used (see the bad-function option). Usual disallowed functions are the ones like map, or filter , where Python offers now some cleaner alternative like list comprehension.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-    options = (&#39;bad-functions&#39;, {&#39;default&#39;: BAD_FUNCTIONS, &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;builtin function names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;List of builtins function names that should not be used, separated by a comma&#39;</span>
<span class="gd">-        }),</span>
<span class="gi">+    name = &quot;deprecated_builtins&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W0141&quot;: (</span>
<span class="gi">+            &quot;Used builtin function %s&quot;,</span>
<span class="gi">+            &quot;bad-builtin&quot;,</span>
<span class="gi">+            &quot;Used when a disallowed builtin function is used (see the &quot;</span>
<span class="gi">+            &quot;bad-function option). Usual disallowed functions are the ones &quot;</span>
<span class="gi">+            &quot;like map, or filter , where Python offers now some cleaner &quot;</span>
<span class="gi">+            &quot;alternative like list comprehension.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;bad-functions&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: BAD_FUNCTIONS,</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;builtin function names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of builtins function names that should not be &quot;</span>
<span class="gi">+                &quot;used, separated by a comma&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;bad-builtin&quot;)</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if isinstance(node.func, nodes.Name):</span>
<span class="gi">+            name = node.func.name</span>
<span class="gi">+            # ignore the name if it&#39;s not a builtin (i.e. not defined in the</span>
<span class="gi">+            # locals nor globals scope)</span>
<span class="gi">+            if not (name in node.frame() or name in node.root()):</span>
<span class="gi">+                if name in self.linter.config.bad_functions:</span>
<span class="gi">+                    hint = BUILTIN_HINTS.get(name)</span>
<span class="gi">+                    args = f&quot;{name!r}. {hint}&quot; if hint else repr(name)</span>
<span class="gi">+                    self.add_message(&quot;bad-builtin&quot;, node=node, args=args)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(BadBuiltinChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/broad_try_clause.py b/pylint/extensions/broad_try_clause.py</span>
<span class="gh">index 554ff6a38..90168909a 100644</span>
<span class="gd">--- a/pylint/extensions/broad_try_clause.py</span>
<span class="gi">+++ b/pylint/extensions/broad_try_clause.py</span>
<span class="gu">@@ -1,8 +1,17 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Looks for try/except statements with too much code in the try clause.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -14,9 +23,51 @@ class BroadTryClauseChecker(checkers.BaseChecker):</span>
<span class="w"> </span>    amount of code. This checker enforces a maximum number of statements within
<span class="w"> </span>    ``try`` clauses.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;broad_try_clause&#39;</span>
<span class="gd">-    msgs = {&#39;W0717&#39;: (&#39;%s&#39;, &#39;too-many-try-statements&#39;,</span>
<span class="gd">-        &#39;Try clause contains too many statements.&#39;)}</span>
<span class="gd">-    options = (&#39;max-try-statements&#39;, {&#39;default&#39;: 1, &#39;type&#39;: &#39;int&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;int&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Maximum number of statements allowed in a try clause&#39;}),</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;broad_try_clause&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W0717&quot;: (</span>
<span class="gi">+            &quot;%s&quot;,</span>
<span class="gi">+            &quot;too-many-try-statements&quot;,</span>
<span class="gi">+            &quot;Try clause contains too many statements.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-try-statements&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 1,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Maximum number of statements allowed in a try clause&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def _count_statements(</span>
<span class="gi">+        self, node: nodes.For | nodes.If | nodes.Try | nodes.While | nodes.With</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        statement_count = len(node.body)</span>
<span class="gi">+</span>
<span class="gi">+        for body_node in node.body:</span>
<span class="gi">+            if isinstance(body_node, (nodes.For, nodes.If, nodes.While, nodes.With)):</span>
<span class="gi">+                statement_count += self._count_statements(body_node)</span>
<span class="gi">+</span>
<span class="gi">+        return statement_count</span>
<span class="gi">+</span>
<span class="gi">+    def visit_try(self, node: nodes.Try) -&gt; None:</span>
<span class="gi">+        try_clause_statements = self._count_statements(node)</span>
<span class="gi">+        if try_clause_statements &gt; self.linter.config.max_try_statements:</span>
<span class="gi">+            msg = (</span>
<span class="gi">+                f&quot;try clause contains {try_clause_statements} statements, expected at&quot;</span>
<span class="gi">+                f&quot; most {self.linter.config.max_try_statements}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-many-try-statements&quot;, node.lineno, node=node, args=msg</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(BroadTryClauseChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/check_elif.py b/pylint/extensions/check_elif.py</span>
<span class="gh">index b9e5190a4..de20ed8ec 100644</span>
<span class="gd">--- a/pylint/extensions/check_elif.py</span>
<span class="gi">+++ b/pylint/extensions/check_elif.py</span>
<span class="gu">@@ -1,33 +1,64 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import tokenize
<span class="w"> </span>from tokenize import TokenInfo
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseTokenChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class ElseifUsedChecker(BaseTokenChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks for use of &quot;else if&quot; when an &quot;elif&quot; could be used.&quot;&quot;&quot;
<span class="gd">-    name = &#39;else_if_used&#39;</span>
<span class="gd">-    msgs = {&#39;R5501&#39;: (</span>
<span class="gd">-        &#39;Consider using &quot;elif&quot; instead of &quot;else&quot; then &quot;if&quot; to remove one indentation level&#39;</span>
<span class="gd">-        , &#39;else-if-used&#39;,</span>
<span class="gd">-        &#39;Used when an else statement is immediately followed by an if statement and does not contain statements that would be unrelated to it.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;else_if_used&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R5501&quot;: (</span>
<span class="gi">+            &#39;Consider using &quot;elif&quot; instead of &quot;else&quot; then &quot;if&quot; to remove one indentation level&#39;,</span>
<span class="gi">+            &quot;else-if-used&quot;,</span>
<span class="gi">+            &quot;Used when an else statement is immediately followed by &quot;</span>
<span class="gi">+            &quot;an if statement and does not contain statements that &quot;</span>
<span class="gi">+            &quot;would be unrelated to it.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="w"> </span>        self._init()

<span class="gd">-    def process_tokens(self, tokens: list[TokenInfo]) -&gt;None:</span>
<span class="gi">+    def _init(self) -&gt; None:</span>
<span class="gi">+        self._elifs: dict[tokenize._Position, str] = {}</span>
<span class="gi">+</span>
<span class="gi">+    def process_tokens(self, tokens: list[TokenInfo]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process tokens and look for &#39;if&#39; or &#39;elif&#39;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._elifs = {</span>
<span class="gi">+            begin: token for _, token, begin, _, _ in tokens if token in {&quot;elif&quot;, &quot;if&quot;}</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def leave_module(self, _: nodes.Module) -&gt; None:</span>
<span class="gi">+        self._init()</span>

<span class="gd">-    @only_required_for_messages(&#39;else-if-used&#39;)</span>
<span class="gd">-    def visit_if(self, node: nodes.If) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;else-if-used&quot;)</span>
<span class="gi">+    def visit_if(self, node: nodes.If) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Current if node must directly follow an &#39;else&#39;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node.parent, nodes.If)</span>
<span class="gi">+            and node.parent.orelse == [node]</span>
<span class="gi">+            and (node.lineno, node.col_offset) in self._elifs</span>
<span class="gi">+            and self._elifs[(node.lineno, node.col_offset)] == &quot;if&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;else-if-used&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(ElseifUsedChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/code_style.py b/pylint/extensions/code_style.py</span>
<span class="gh">index cc8634462..622601c75 100644</span>
<span class="gd">--- a/pylint/extensions/code_style.py</span>
<span class="gi">+++ b/pylint/extensions/code_style.py</span>
<span class="gu">@@ -1,12 +1,21 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING, Tuple, Type, cast
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages, safe_infer
<span class="w"> </span>from pylint.interfaces import INFERENCE
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 10):
<span class="w"> </span>    from typing import TypeGuard
<span class="w"> </span>else:
<span class="gu">@@ -28,37 +37,177 @@ class CodeStyleChecker(BaseChecker):</span>
<span class="w"> </span>       and therefore preferred =&gt; this is the right place
<span class="w"> </span>    3. Everything else should go into another extension
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;code_style&#39;</span>
<span class="gd">-    msgs = {&#39;R6101&#39;: (</span>
<span class="gd">-        &#39;Consider using namedtuple or dataclass for dictionary values&#39;,</span>
<span class="gd">-        &#39;consider-using-namedtuple-or-dataclass&#39;,</span>
<span class="gd">-        &#39;Emitted when dictionary values can be replaced by namedtuples or dataclass instances.&#39;</span>
<span class="gd">-        ), &#39;R6102&#39;: (&#39;Consider using an in-place tuple instead of list&#39;,</span>
<span class="gd">-        &#39;consider-using-tuple&#39;,</span>
<span class="gd">-        &#39;Only for style consistency! Emitted where an in-place defined ``list`` can be replaced by a ``tuple``. Due to optimizations by CPython, there is no performance benefit from it.&#39;</span>
<span class="gd">-        ), &#39;R6103&#39;: (&quot;Use &#39;%s&#39; instead&quot;, &#39;consider-using-assignment-expr&#39;,</span>
<span class="gd">-        &#39;Emitted when an if assignment is directly followed by an if statement and both can be combined by using an assignment expression ``:=``. Requires Python 3.8 and ``py-version &gt;= 3.8``.&#39;</span>
<span class="gd">-        ), &#39;R6104&#39;: (&quot;Use &#39;%s&#39; to do an augmented assign directly&quot;,</span>
<span class="gd">-        &#39;consider-using-augmented-assign&#39;,</span>
<span class="gd">-        &quot;&quot;&quot;Emitted when an assignment is referring to the object that it is assigning to. This can be changed to be an augmented assign.</span>
<span class="gd">-Disabled by default!&quot;&quot;&quot;</span>
<span class="gd">-        , {&#39;default_enabled&#39;: False}), &#39;R6105&#39;: (</span>
<span class="gd">-        &quot;Prefer &#39;typing.NamedTuple&#39; over &#39;collections.namedtuple&#39;&quot;,</span>
<span class="gd">-        &#39;prefer-typing-namedtuple&#39;,</span>
<span class="gd">-        &quot;&quot;&quot;&#39;typing.NamedTuple&#39; uses the well-known &#39;class&#39; keyword with type-hints for readability (it&#39;s also faster as it avoids an internal exec call).</span>
<span class="gd">-Disabled by default!&quot;&quot;&quot;</span>
<span class="gd">-        , {&#39;default_enabled&#39;: False})}</span>
<span class="gd">-    options = (&#39;max-line-length-suggestions&#39;, {&#39;type&#39;: &#39;int&#39;, &#39;default&#39;: 0,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;int&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Max line length for which to sill emit suggestions. Used to prevent optional suggestions which would get split by a code formatter (e.g., black). Will default to the setting for ``max-line-length``.&#39;</span>
<span class="gd">-        }),</span>
<span class="gd">-</span>
<span class="gd">-    def _check_dict_consider_namedtuple_dataclass(self, node: nodes.Dict</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;code_style&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R6101&quot;: (</span>
<span class="gi">+            &quot;Consider using namedtuple or dataclass for dictionary values&quot;,</span>
<span class="gi">+            &quot;consider-using-namedtuple-or-dataclass&quot;,</span>
<span class="gi">+            &quot;Emitted when dictionary values can be replaced by namedtuples or dataclass instances.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R6102&quot;: (</span>
<span class="gi">+            &quot;Consider using an in-place tuple instead of list&quot;,</span>
<span class="gi">+            &quot;consider-using-tuple&quot;,</span>
<span class="gi">+            &quot;Only for style consistency! &quot;</span>
<span class="gi">+            &quot;Emitted where an in-place defined ``list`` can be replaced by a ``tuple``. &quot;</span>
<span class="gi">+            &quot;Due to optimizations by CPython, there is no performance benefit from it.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R6103&quot;: (</span>
<span class="gi">+            &quot;Use &#39;%s&#39; instead&quot;,</span>
<span class="gi">+            &quot;consider-using-assignment-expr&quot;,</span>
<span class="gi">+            &quot;Emitted when an if assignment is directly followed by an if statement and &quot;</span>
<span class="gi">+            &quot;both can be combined by using an assignment expression ``:=``. &quot;</span>
<span class="gi">+            &quot;Requires Python 3.8 and ``py-version &gt;= 3.8``.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R6104&quot;: (</span>
<span class="gi">+            &quot;Use &#39;%s&#39; to do an augmented assign directly&quot;,</span>
<span class="gi">+            &quot;consider-using-augmented-assign&quot;,</span>
<span class="gi">+            &quot;Emitted when an assignment is referring to the object that it is assigning &quot;</span>
<span class="gi">+            &quot;to. This can be changed to be an augmented assign.\n&quot;</span>
<span class="gi">+            &quot;Disabled by default!&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default_enabled&quot;: False,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R6105&quot;: (</span>
<span class="gi">+            &quot;Prefer &#39;typing.NamedTuple&#39; over &#39;collections.namedtuple&#39;&quot;,</span>
<span class="gi">+            &quot;prefer-typing-namedtuple&quot;,</span>
<span class="gi">+            &quot;&#39;typing.NamedTuple&#39; uses the well-known &#39;class&#39; keyword &quot;</span>
<span class="gi">+            &quot;with type-hints for readability (it&#39;s also faster as it avoids &quot;</span>
<span class="gi">+            &quot;an internal exec call).\n&quot;</span>
<span class="gi">+            &quot;Disabled by default!&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default_enabled&quot;: False,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-line-length-suggestions&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;default&quot;: 0,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Max line length for which to sill emit suggestions. &quot;</span>
<span class="gi">+                    &quot;Used to prevent optional suggestions which would get split &quot;</span>
<span class="gi">+                    &quot;by a code formatter (e.g., black). &quot;</span>
<span class="gi">+                    &quot;Will default to the setting for ``max-line-length``.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        py_version = self.linter.config.py_version</span>
<span class="gi">+        self._py36_plus = py_version &gt;= (3, 6)</span>
<span class="gi">+        self._py38_plus = py_version &gt;= (3, 8)</span>
<span class="gi">+        self._max_length: int = (</span>
<span class="gi">+            self.linter.config.max_line_length_suggestions</span>
<span class="gi">+            or self.linter.config.max_line_length</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;prefer-typing-namedtuple&quot;)</span>
<span class="gi">+    def visit_call(self, node: nodes.Call) -&gt; None:</span>
<span class="gi">+        if self._py36_plus:</span>
<span class="gi">+            called = safe_infer(node.func)</span>
<span class="gi">+            if called and called.qname() == &quot;collections.namedtuple&quot;:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;prefer-typing-namedtuple&quot;, node=node, confidence=INFERENCE</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;consider-using-namedtuple-or-dataclass&quot;)</span>
<span class="gi">+    def visit_dict(self, node: nodes.Dict) -&gt; None:</span>
<span class="gi">+        self._check_dict_consider_namedtuple_dataclass(node)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;consider-using-tuple&quot;)</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        if isinstance(node.iter, nodes.List):</span>
<span class="gi">+            self.add_message(&quot;consider-using-tuple&quot;, node=node.iter)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;consider-using-tuple&quot;)</span>
<span class="gi">+    def visit_comprehension(self, node: nodes.Comprehension) -&gt; None:</span>
<span class="gi">+        if isinstance(node.iter, nodes.List):</span>
<span class="gi">+            self.add_message(&quot;consider-using-tuple&quot;, node=node.iter)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;consider-using-assignment-expr&quot;)</span>
<span class="gi">+    def visit_if(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        if self._py38_plus:</span>
<span class="gi">+            self._check_consider_using_assignment_expr(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_dict_consider_namedtuple_dataclass(self, node: nodes.Dict) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if dictionary values can be replaced by Namedtuple or Dataclass.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(node.parent, (nodes.Assign, nodes.AnnAssign))</span>
<span class="gi">+            and isinstance(node.parent.parent, nodes.Module)</span>
<span class="gi">+            or isinstance(node.parent, nodes.AnnAssign)</span>
<span class="gi">+            and isinstance(node.parent.target, nodes.AssignName)</span>
<span class="gi">+            and utils.is_assign_name_annotated_with(node.parent.target, &quot;Final&quot;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            # If dict is not part of an &#39;Assign&#39; or &#39;AnnAssign&#39; node in</span>
<span class="gi">+            # a module context OR &#39;AnnAssign&#39; with &#39;Final&#39; annotation, skip check.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # All dict_values are itself dict nodes</span>
<span class="gi">+        if len(node.items) &gt; 1 and all(</span>
<span class="gi">+            isinstance(dict_value, nodes.Dict) for _, dict_value in node.items</span>
<span class="gi">+        ):</span>
<span class="gi">+            KeyTupleT = Tuple[Type[nodes.NodeNG], str]</span>

<span class="gd">-    def _check_consider_using_assignment_expr(self, node: nodes.If) -&gt;None:</span>
<span class="gi">+            # Makes sure all keys are &#39;Const&#39; string nodes</span>
<span class="gi">+            keys_checked: set[KeyTupleT] = set()</span>
<span class="gi">+            for _, dict_value in node.items:</span>
<span class="gi">+                dict_value = cast(nodes.Dict, dict_value)</span>
<span class="gi">+                for key, _ in dict_value.items:</span>
<span class="gi">+                    key_tuple = (type(key), key.as_string())</span>
<span class="gi">+                    if key_tuple in keys_checked:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    inferred = safe_infer(key)</span>
<span class="gi">+                    if not (</span>
<span class="gi">+                        isinstance(inferred, nodes.Const)</span>
<span class="gi">+                        and inferred.pytype() == &quot;builtins.str&quot;</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        return</span>
<span class="gi">+                    keys_checked.add(key_tuple)</span>
<span class="gi">+</span>
<span class="gi">+            # Makes sure all subdicts have at least 1 common key</span>
<span class="gi">+            key_tuples: list[tuple[KeyTupleT, ...]] = []</span>
<span class="gi">+            for _, dict_value in node.items:</span>
<span class="gi">+                dict_value = cast(nodes.Dict, dict_value)</span>
<span class="gi">+                key_tuples.append(</span>
<span class="gi">+                    tuple((type(key), key.as_string()) for key, _ in dict_value.items)</span>
<span class="gi">+                )</span>
<span class="gi">+            keys_intersection: set[KeyTupleT] = set(key_tuples[0])</span>
<span class="gi">+            for sub_key_tuples in key_tuples[1:]:</span>
<span class="gi">+                keys_intersection.intersection_update(sub_key_tuples)</span>
<span class="gi">+            if not keys_intersection:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(&quot;consider-using-namedtuple-or-dataclass&quot;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # All dict_values are itself either list or tuple nodes</span>
<span class="gi">+        if len(node.items) &gt; 1 and all(</span>
<span class="gi">+            isinstance(dict_value, (nodes.List, nodes.Tuple))</span>
<span class="gi">+            for _, dict_value in node.items</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Make sure all sublists have the same length &gt; 0</span>
<span class="gi">+            list_length = len(node.items[0][1].elts)</span>
<span class="gi">+            if list_length == 0:</span>
<span class="gi">+                return</span>
<span class="gi">+            for _, dict_value in node.items[1:]:</span>
<span class="gi">+                if len(dict_value.elts) != list_length:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            # Make sure at least one list entry isn&#39;t a dict</span>
<span class="gi">+            for _, dict_value in node.items:</span>
<span class="gi">+                if all(isinstance(entry, nodes.Dict) for entry in dict_value.elts):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(&quot;consider-using-namedtuple-or-dataclass&quot;, node=node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+    def _check_consider_using_assignment_expr(self, node: nodes.If) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if an assignment expression (walrus operator) can be used.

<span class="w"> </span>        For example if an assignment is directly followed by an if statement:
<span class="gu">@@ -72,23 +221,130 @@ Disabled by default!&quot;&quot;&quot;</span>

<span class="w"> </span>        Note: Assignment expressions were added in Python 3.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Check if `node.test` contains a `Name` node</span>
<span class="gi">+        node_name: nodes.Name | None = None</span>
<span class="gi">+        if isinstance(node.test, nodes.Name):</span>
<span class="gi">+            node_name = node.test</span>
<span class="gi">+        elif (</span>
<span class="gi">+            isinstance(node.test, nodes.UnaryOp)</span>
<span class="gi">+            and node.test.op == &quot;not&quot;</span>
<span class="gi">+            and isinstance(node.test.operand, nodes.Name)</span>
<span class="gi">+        ):</span>
<span class="gi">+            node_name = node.test.operand</span>
<span class="gi">+        elif (</span>
<span class="gi">+            isinstance(node.test, nodes.Compare)</span>
<span class="gi">+            and isinstance(node.test.left, nodes.Name)</span>
<span class="gi">+            and len(node.test.ops) == 1</span>
<span class="gi">+        ):</span>
<span class="gi">+            node_name = node.test.left</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Make sure the previous node is an assignment to the same name</span>
<span class="gi">+        # used in `node.test`. Furthermore, ignore if assignment spans multiple lines.</span>
<span class="gi">+        prev_sibling = node.previous_sibling()</span>
<span class="gi">+        if CodeStyleChecker._check_prev_sibling_to_if_stmt(</span>
<span class="gi">+            prev_sibling, node_name.name</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Check if match statement would be a better fit.</span>
<span class="gi">+            # I.e. multiple ifs that test the same name.</span>
<span class="gi">+            if CodeStyleChecker._check_ignore_assignment_expr_suggestion(</span>
<span class="gi">+                node, node_name.name</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # Build suggestion string. Check length of suggestion</span>
<span class="gi">+            # does not exceed max-line-length-suggestions</span>
<span class="gi">+            test_str = node.test.as_string().replace(</span>
<span class="gi">+                node_name.name,</span>
<span class="gi">+                f&quot;({node_name.name} := {prev_sibling.value.as_string()})&quot;,</span>
<span class="gi">+                1,</span>
<span class="gi">+            )</span>
<span class="gi">+            suggestion = f&quot;if {test_str}:&quot;</span>
<span class="gi">+            if (</span>
<span class="gi">+                node.col_offset is not None</span>
<span class="gi">+                and len(suggestion) + node.col_offset &gt; self._max_length</span>
<span class="gi">+                or len(suggestion) &gt; self._max_length</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-using-assignment-expr&quot;,</span>
<span class="gi">+                node=node_name,</span>
<span class="gi">+                args=(suggestion,),</span>
<span class="gi">+            )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _check_prev_sibling_to_if_stmt(prev_sibling: (nodes.NodeNG | None),</span>
<span class="gd">-        name: (str | None)) -&gt;TypeGuard[nodes.Assign | nodes.AnnAssign]:</span>
<span class="gi">+    def _check_prev_sibling_to_if_stmt(</span>
<span class="gi">+        prev_sibling: nodes.NodeNG | None, name: str | None</span>
<span class="gi">+    ) -&gt; TypeGuard[nodes.Assign | nodes.AnnAssign]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if previous sibling is an assignment with the same name.

<span class="w"> </span>        Ignore statements which span multiple lines.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if prev_sibling is None or prev_sibling.tolineno - prev_sibling.fromlineno != 0:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(prev_sibling, nodes.Assign)</span>
<span class="gi">+            and len(prev_sibling.targets) == 1</span>
<span class="gi">+            and isinstance(prev_sibling.targets[0], nodes.AssignName)</span>
<span class="gi">+            and prev_sibling.targets[0].name == name</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(prev_sibling, nodes.AnnAssign)</span>
<span class="gi">+            and isinstance(prev_sibling.target, nodes.AssignName)</span>
<span class="gi">+            and prev_sibling.target.name == name</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _check_ignore_assignment_expr_suggestion(node: nodes.If, name: (str |</span>
<span class="gd">-        None)) -&gt;bool:</span>
<span class="gi">+    def _check_ignore_assignment_expr_suggestion(</span>
<span class="gi">+        node: nodes.If, name: str | None</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True if suggestion for assignment expr should be ignored.

<span class="w"> </span>        E.g., in cases where a match statement would be a better fit
<span class="w"> </span>        (multiple conditions).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node.test, nodes.Compare):</span>
<span class="gi">+            next_if_node: nodes.If | None = None</span>
<span class="gi">+            next_sibling = node.next_sibling()</span>
<span class="gi">+            if len(node.orelse) == 1 and isinstance(node.orelse[0], nodes.If):</span>
<span class="gi">+                # elif block</span>
<span class="gi">+                next_if_node = node.orelse[0]</span>
<span class="gi">+            elif isinstance(next_sibling, nodes.If):</span>
<span class="gi">+                # separate if block</span>
<span class="gi">+                next_if_node = next_sibling</span>
<span class="gi">+</span>
<span class="gi">+            if (  # pylint: disable=too-many-boolean-expressions</span>
<span class="gi">+                next_if_node is not None</span>
<span class="gi">+                and (</span>
<span class="gi">+                    isinstance(next_if_node.test, nodes.Compare)</span>
<span class="gi">+                    and isinstance(next_if_node.test.left, nodes.Name)</span>
<span class="gi">+                    and next_if_node.test.left.name == name</span>
<span class="gi">+                    or isinstance(next_if_node.test, nodes.Name)</span>
<span class="gi">+                    and next_if_node.test.name == name</span>
<span class="gi">+                )</span>
<span class="gi">+            ):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;consider-using-augmented-assign&quot;)</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        is_aug, op = utils.is_augmented_assign(node)</span>
<span class="gi">+        if is_aug:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-using-augmented-assign&quot;,</span>
<span class="gi">+                args=f&quot;{op}=&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                line=node.lineno,</span>
<span class="gi">+                col_offset=node.col_offset,</span>
<span class="gi">+                confidence=INFERENCE,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(CodeStyleChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/comparison_placement.py b/pylint/extensions/comparison_placement.py</span>
<span class="gh">index 205610473..f7ecceae3 100644</span>
<span class="gd">--- a/pylint/extensions/comparison_placement.py</span>
<span class="gi">+++ b/pylint/extensions/comparison_placement.py</span>
<span class="gu">@@ -1,21 +1,69 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checks for yoda comparisons (variable before constant)
<span class="w"> </span>See https://en.wikipedia.org/wiki/Yoda_conditions.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-REVERSED_COMPS = {&#39;&lt;&#39;: &#39;&gt;&#39;, &#39;&lt;=&#39;: &#39;&gt;=&#39;, &#39;&gt;&#39;: &#39;&lt;&#39;, &#39;&gt;=&#39;: &#39;&lt;=&#39;}</span>
<span class="gd">-COMPARISON_OPERATORS = frozenset((&#39;==&#39;, &#39;!=&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;))</span>
<span class="gi">+</span>
<span class="gi">+REVERSED_COMPS = {&quot;&lt;&quot;: &quot;&gt;&quot;, &quot;&lt;=&quot;: &quot;&gt;=&quot;, &quot;&gt;&quot;: &quot;&lt;&quot;, &quot;&gt;=&quot;: &quot;&lt;=&quot;}</span>
<span class="gi">+COMPARISON_OPERATORS = frozenset((&quot;==&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;))</span>


<span class="w"> </span>class MisplacedComparisonConstantChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks the placement of constants in comparisons.&quot;&quot;&quot;
<span class="gd">-    name = &#39;comparison-placement&#39;</span>
<span class="gd">-    msgs = {&#39;C2201&#39;: (&#39;Comparison should be %s&#39;,</span>
<span class="gd">-        &#39;misplaced-comparison-constant&#39;,</span>
<span class="gd">-        &#39;Used when the constant is placed on the left side of a comparison. It is usually clearer in intent to place it in the right hand side of the comparison.&#39;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;C0122&#39;, &#39;old-misplaced-comparison-constant&#39;)]})}</span>
<span class="gi">+</span>
<span class="gi">+    # configuration section name</span>
<span class="gi">+    name = &quot;comparison-placement&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C2201&quot;: (</span>
<span class="gi">+            &quot;Comparison should be %s&quot;,</span>
<span class="gi">+            &quot;misplaced-comparison-constant&quot;,</span>
<span class="gi">+            &quot;Used when the constant is placed on the left side &quot;</span>
<span class="gi">+            &quot;of a comparison. It is usually clearer in intent to &quot;</span>
<span class="gi">+            &quot;place it in the right hand side of the comparison.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;C0122&quot;, &quot;old-misplaced-comparison-constant&quot;)]},</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    options = ()
<span class="gi">+</span>
<span class="gi">+    def _check_misplaced_constant(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Compare,</span>
<span class="gi">+        left: nodes.NodeNG,</span>
<span class="gi">+        right: nodes.NodeNG,</span>
<span class="gi">+        operator: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if isinstance(right, nodes.Const):</span>
<span class="gi">+            return</span>
<span class="gi">+        operator = REVERSED_COMPS.get(operator, operator)</span>
<span class="gi">+        suggestion = f&quot;{right.as_string()} {operator} {left.value!r}&quot;</span>
<span class="gi">+        self.add_message(&quot;misplaced-comparison-constant&quot;, node=node, args=(suggestion,))</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;misplaced-comparison-constant&quot;)</span>
<span class="gi">+    def visit_compare(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        # NOTE: this checker only works with binary comparisons like &#39;x == 42&#39;</span>
<span class="gi">+        # but not &#39;x == y == 42&#39;</span>
<span class="gi">+        if len(node.ops) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        left = node.left</span>
<span class="gi">+        operator, right = node.ops[0]</span>
<span class="gi">+        if operator in COMPARISON_OPERATORS and isinstance(left, nodes.Const):</span>
<span class="gi">+            self._check_misplaced_constant(node, left, right, operator)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(MisplacedComparisonConstantChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/confusing_elif.py b/pylint/extensions/confusing_elif.py</span>
<span class="gh">index d45d9ec2c..287547eaa 100644</span>
<span class="gd">--- a/pylint/extensions/confusing_elif.py</span>
<span class="gi">+++ b/pylint/extensions/confusing_elif.py</span>
<span class="gu">@@ -1,8 +1,16 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -11,9 +19,37 @@ class ConfusingConsecutiveElifChecker(BaseChecker):</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if &quot;elif&quot; is used right after an indented block that finishes with &quot;if&quot; or
<span class="w"> </span>    &quot;elif&quot; itself.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;confusing_elif&#39;</span>
<span class="gd">-    msgs = {&#39;R5601&#39;: (</span>
<span class="gd">-        &#39;Consecutive elif with differing indentation level, consider creating a function to separate the inner elif&#39;</span>
<span class="gd">-        , &#39;confusing-consecutive-elif&#39;,</span>
<span class="gd">-        &#39;Used when an elif statement follows right after an indented block which itself ends with if or elif. It may not be obvious if the elif statement was willingly or mistakenly unindented. Extracting the indented if statement into a separate function might avoid confusion and prevent errors.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;confusing_elif&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R5601&quot;: (</span>
<span class="gi">+            &quot;Consecutive elif with differing indentation level, consider creating a function to separate the inner&quot;</span>
<span class="gi">+            &quot; elif&quot;,</span>
<span class="gi">+            &quot;confusing-consecutive-elif&quot;,</span>
<span class="gi">+            &quot;Used when an elif statement follows right after an indented block which itself ends with if or elif. &quot;</span>
<span class="gi">+            &quot;It may not be obvious if the elif statement was willingly or mistakenly unindented. &quot;</span>
<span class="gi">+            &quot;Extracting the indented if statement into a separate function might avoid confusion and prevent &quot;</span>
<span class="gi">+            &quot;errors.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;confusing-consecutive-elif&quot;)</span>
<span class="gi">+    def visit_if(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        body_ends_with_if = isinstance(</span>
<span class="gi">+            node.body[-1], nodes.If</span>
<span class="gi">+        ) and self._has_no_else_clause(node.body[-1])</span>
<span class="gi">+        if node.has_elif_block() and body_ends_with_if:</span>
<span class="gi">+            self.add_message(&quot;confusing-consecutive-elif&quot;, node=node.orelse[0])</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _has_no_else_clause(node: nodes.If) -&gt; bool:</span>
<span class="gi">+        orelse = node.orelse</span>
<span class="gi">+        while orelse and isinstance(orelse[0], nodes.If):</span>
<span class="gi">+            orelse = orelse[0].orelse</span>
<span class="gi">+        if not orelse or isinstance(orelse[0], nodes.If):</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(ConfusingConsecutiveElifChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/consider_refactoring_into_while_condition.py b/pylint/extensions/consider_refactoring_into_while_condition.py</span>
<span class="gh">index c2135c90d..b7e905e8a 100644</span>
<span class="gd">--- a/pylint/extensions/consider_refactoring_into_while_condition.py</span>
<span class="gi">+++ b/pylint/extensions/consider_refactoring_into_while_condition.py</span>
<span class="gu">@@ -1,10 +1,19 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Looks for try/except statements with too much code in the try clause.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -20,13 +29,65 @@ class ConsiderRefactorIntoWhileConditionChecker(checkers.BaseChecker):</span>

<span class="w"> </span>    The if statement(s) can be refactored into the while loop.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;consider_refactoring_into_while&#39;</span>
<span class="gd">-    msgs = {&#39;R3501&#39;: (</span>
<span class="gd">-        &quot;Consider using &#39;while %s&#39; instead of &#39;while %s:&#39; an &#39;if&#39;, and a &#39;break&#39;&quot;</span>
<span class="gd">-        , &#39;consider-refactoring-into-while-condition&#39;,</span>
<span class="gd">-        &#39;Emitted when `while True:` loop is used and the first statement is a break condition. The ``if / break`` construct can be removed if the check is inverted and moved to the ``while`` statement.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-</span>
<span class="gd">-    def _check_breaking_after_while_true(self, node: nodes.While) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;consider_refactoring_into_while&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R3501&quot;: (</span>
<span class="gi">+            &quot;Consider using &#39;while %s&#39; instead of &#39;while %s:&#39; an &#39;if&#39;, and a &#39;break&#39;&quot;,</span>
<span class="gi">+            &quot;consider-refactoring-into-while-condition&quot;,</span>
<span class="gi">+            &quot;Emitted when `while True:` loop is used and the first statement is a break condition. &quot;</span>
<span class="gi">+            &quot;The ``if / break`` construct can be removed if the check is inverted and moved to &quot;</span>
<span class="gi">+            &quot;the ``while`` statement.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;consider-refactoring-into-while-condition&quot;)</span>
<span class="gi">+    def visit_while(self, node: nodes.While) -&gt; None:</span>
<span class="gi">+        self._check_breaking_after_while_true(node)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_breaking_after_while_true(self, node: nodes.While) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that any loop with an ``if`` clause has a break statement.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.test, nodes.Const) or not node.test.bool_value():</span>
<span class="gi">+            return</span>
<span class="gi">+        pri_candidates: list[nodes.If] = []</span>
<span class="gi">+        for n in node.body:</span>
<span class="gi">+            if not isinstance(n, nodes.If):</span>
<span class="gi">+                break</span>
<span class="gi">+            pri_candidates.append(n)</span>
<span class="gi">+        candidates = []</span>
<span class="gi">+        tainted = False</span>
<span class="gi">+        for c in pri_candidates:</span>
<span class="gi">+            if tainted or not isinstance(c.body[0], nodes.Break):</span>
<span class="gi">+                break</span>
<span class="gi">+            candidates.append(c)</span>
<span class="gi">+            orelse = c.orelse</span>
<span class="gi">+            while orelse:</span>
<span class="gi">+                orelse_node = orelse[0]</span>
<span class="gi">+                if not isinstance(orelse_node, nodes.If):</span>
<span class="gi">+                    tainted = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    candidates.append(orelse_node)</span>
<span class="gi">+                if not isinstance(orelse_node, nodes.If):</span>
<span class="gi">+                    break</span>
<span class="gi">+                orelse = orelse_node.orelse</span>
<span class="gi">+</span>
<span class="gi">+        candidates = [n for n in candidates if isinstance(n.body[0], nodes.Break)]</span>
<span class="gi">+        msg = &quot; and &quot;.join(</span>
<span class="gi">+            [f&quot;({utils.not_condition_as_string(c.test)})&quot; for c in candidates]</span>
<span class="gi">+        )</span>
<span class="gi">+        if len(candidates) == 1:</span>
<span class="gi">+            msg = utils.not_condition_as_string(candidates[0].test)</span>
<span class="gi">+        if not msg:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;consider-refactoring-into-while-condition&quot;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            line=node.lineno,</span>
<span class="gi">+            args=(msg, node.test.as_string()),</span>
<span class="gi">+            confidence=HIGH,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(ConsiderRefactorIntoWhileConditionChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/consider_ternary_expression.py b/pylint/extensions/consider_ternary_expression.py</span>
<span class="gh">index ffe0b05dc..83046ce38 100644</span>
<span class="gd">--- a/pylint/extensions/consider_ternary_expression.py</span>
<span class="gi">+++ b/pylint/extensions/consider_ternary_expression.py</span>
<span class="gu">@@ -1,15 +1,56 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Check for if / assign blocks that can be rewritten with if-expressions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class ConsiderTernaryExpressionChecker(BaseChecker):
<span class="gd">-    name = &#39;consider_ternary_expression&#39;</span>
<span class="gd">-    msgs = {&#39;W0160&#39;: (&#39;Consider rewriting as a ternary expression&#39;,</span>
<span class="gd">-        &#39;consider-ternary-expression&#39;,</span>
<span class="gd">-        &#39;Multiple assign statements spread across if/else blocks can be rewritten with a single assignment and ternary expression&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+    name = &quot;consider_ternary_expression&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W0160&quot;: (</span>
<span class="gi">+            &quot;Consider rewriting as a ternary expression&quot;,</span>
<span class="gi">+            &quot;consider-ternary-expression&quot;,</span>
<span class="gi">+            &quot;Multiple assign statements spread across if/else blocks can be &quot;</span>
<span class="gi">+            &quot;rewritten with a single assignment and ternary expression&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def visit_if(self, node: nodes.If) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.If):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if len(node.body) != 1 or len(node.orelse) != 1:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        bst = node.body[0]</span>
<span class="gi">+        ost = node.orelse[0]</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(bst, nodes.Assign) or not isinstance(ost, nodes.Assign):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for bname, oname in zip(bst.targets, ost.targets):</span>
<span class="gi">+            if not isinstance(bname, nodes.AssignName) or not isinstance(</span>
<span class="gi">+                oname, nodes.AssignName</span>
<span class="gi">+            ):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if bname.name != oname.name:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;consider-ternary-expression&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(ConsiderTernaryExpressionChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/dict_init_mutate.py b/pylint/extensions/dict_init_mutate.py</span>
<span class="gh">index e54d20198..4977e234b 100644</span>
<span class="gd">--- a/pylint/extensions/dict_init_mutate.py</span>
<span class="gi">+++ b/pylint/extensions/dict_init_mutate.py</span>
<span class="gu">@@ -1,27 +1,66 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Check for use of dictionary mutation after initialization.&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter


<span class="w"> </span>class DictInitMutateChecker(BaseChecker):
<span class="gd">-    name = &#39;dict-init-mutate&#39;</span>
<span class="gd">-    msgs = {&#39;C3401&#39;: (</span>
<span class="gd">-        &#39;Declare all known key/values when initializing the dictionary.&#39;,</span>
<span class="gd">-        &#39;dict-init-mutate&#39;,</span>
<span class="gd">-        &#39;Dictionaries can be initialized with a single statement using dictionary literal syntax.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-</span>
<span class="gd">-    @only_required_for_messages(&#39;dict-init-mutate&#39;)</span>
<span class="gd">-    def visit_assign(self, node: nodes.Assign) -&gt;None:</span>
<span class="gi">+    name = &quot;dict-init-mutate&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C3401&quot;: (</span>
<span class="gi">+            &quot;Declare all known key/values when initializing the dictionary.&quot;,</span>
<span class="gi">+            &quot;dict-init-mutate&quot;,</span>
<span class="gi">+            &quot;Dictionaries can be initialized with a single statement &quot;</span>
<span class="gi">+            &quot;using dictionary literal syntax.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;dict-init-mutate&quot;)</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Detect dictionary mutation immediately after initialization.

<span class="w"> </span>        At this time, detecting nested mutation is not supported.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.value, nodes.Dict):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        dict_name = node.targets[0]</span>
<span class="gi">+        if len(node.targets) != 1 or not isinstance(dict_name, nodes.AssignName):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        first_sibling = node.next_sibling()</span>
<span class="gi">+        if (</span>
<span class="gi">+            not first_sibling</span>
<span class="gi">+            or not isinstance(first_sibling, nodes.Assign)</span>
<span class="gi">+            or len(first_sibling.targets) != 1</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        sibling_target = first_sibling.targets[0]</span>
<span class="gi">+        if not isinstance(sibling_target, nodes.Subscript):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        sibling_name = sibling_target.value</span>
<span class="gi">+        if not isinstance(sibling_name, nodes.Name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if sibling_name.name == dict_name.name:</span>
<span class="gi">+            self.add_message(&quot;dict-init-mutate&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(DictInitMutateChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/docparams.py b/pylint/extensions/docparams.py</span>
<span class="gh">index 2c5c09d6b..5d672131a 100644</span>
<span class="gd">--- a/pylint/extensions/docparams.py</span>
<span class="gi">+++ b/pylint/extensions/docparams.py</span>
<span class="gu">@@ -1,14 +1,23 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Pylint plugin for checking in Sphinx, Google, or Numpy style docstrings.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers import utils as checker_utils
<span class="w"> </span>from pylint.extensions import _check_docs_utils as utils
<span class="w"> </span>from pylint.extensions._check_docs_utils import Docstring
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -33,80 +42,361 @@ class DocstringParameterChecker(BaseChecker):</span>

<span class="w"> </span>    to the ``MAIN`` section of your ``.pylintrc``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;parameter_documentation&#39;</span>
<span class="gd">-    msgs = {&#39;W9005&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; has constructor parameters documented in class and __init__&#39;,</span>
<span class="gd">-        &#39;multiple-constructor-doc&#39;,</span>
<span class="gd">-        &#39;Please remove parameter declarations in the class or constructor.&#39;</span>
<span class="gd">-        ), &#39;W9006&#39;: (&#39;&quot;%s&quot; not documented as being raised&#39;,</span>
<span class="gd">-        &#39;missing-raises-doc&#39;,</span>
<span class="gd">-        &#39;Please document exceptions for all raised exception types.&#39;),</span>
<span class="gd">-        &#39;W9008&#39;: (&#39;Redundant returns documentation&#39;,</span>
<span class="gd">-        &#39;redundant-returns-doc&#39;,</span>
<span class="gd">-        &#39;Please remove the return/rtype documentation from this method.&#39;),</span>
<span class="gd">-        &#39;W9010&#39;: (&#39;Redundant yields documentation&#39;, &#39;redundant-yields-doc&#39;,</span>
<span class="gd">-        &#39;Please remove the yields documentation from this method.&#39;),</span>
<span class="gd">-        &#39;W9011&#39;: (&#39;Missing return documentation&#39;, &#39;missing-return-doc&#39;,</span>
<span class="gd">-        &#39;Please add documentation about what this method returns.&#39;, {</span>
<span class="gd">-        &#39;old_names&#39;: [(&#39;W9007&#39;, &#39;old-missing-returns-doc&#39;)]}), &#39;W9012&#39;: (</span>
<span class="gd">-        &#39;Missing return type documentation&#39;, &#39;missing-return-type-doc&#39;,</span>
<span class="gd">-        &#39;Please document the type returned by this method.&#39;), &#39;W9013&#39;: (</span>
<span class="gd">-        &#39;Missing yield documentation&#39;, &#39;missing-yield-doc&#39;,</span>
<span class="gd">-        &#39;Please add documentation about what this generator yields.&#39;, {</span>
<span class="gd">-        &#39;old_names&#39;: [(&#39;W9009&#39;, &#39;old-missing-yields-doc&#39;)]}), &#39;W9014&#39;: (</span>
<span class="gd">-        &#39;Missing yield type documentation&#39;, &#39;missing-yield-type-doc&#39;,</span>
<span class="gd">-        &#39;Please document the type yielded by this method.&#39;), &#39;W9015&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; missing in parameter documentation&#39;, &#39;missing-param-doc&#39;,</span>
<span class="gd">-        &#39;Please add parameter declarations for all parameters.&#39;, {</span>
<span class="gd">-        &#39;old_names&#39;: [(&#39;W9003&#39;, &#39;old-missing-param-doc&#39;)]}), &#39;W9016&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; missing in parameter type documentation&#39;, &#39;missing-type-doc&#39;,</span>
<span class="gd">-        &#39;Please add parameter type declarations for all parameters.&#39;, {</span>
<span class="gd">-        &#39;old_names&#39;: [(&#39;W9004&#39;, &#39;old-missing-type-doc&#39;)]}), &#39;W9017&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; differing in parameter documentation&#39;, &#39;differing-param-doc&#39;,</span>
<span class="gd">-        &#39;Please check parameter names in declarations.&#39;), &#39;W9018&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; differing in parameter type documentation&#39;,</span>
<span class="gd">-        &#39;differing-type-doc&#39;,</span>
<span class="gd">-        &#39;Please check parameter names in type declarations.&#39;), &#39;W9019&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; useless ignored parameter documentation&#39;, &#39;useless-param-doc&#39;,</span>
<span class="gd">-        &#39;Please remove the ignored parameter documentation.&#39;), &#39;W9020&#39;: (</span>
<span class="gd">-        &#39;&quot;%s&quot; useless ignored parameter type documentation&#39;,</span>
<span class="gd">-        &#39;useless-type-doc&#39;,</span>
<span class="gd">-        &#39;Please remove the ignored parameter type documentation.&#39;), &#39;W9021&#39;:</span>
<span class="gd">-        (&#39;Missing any documentation in &quot;%s&quot;&#39;, &#39;missing-any-param-doc&#39;,</span>
<span class="gd">-        &#39;Please add parameter and/or type documentation.&#39;)}</span>
<span class="gd">-    options = (&#39;accept-no-param-doc&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Whether to accept totally missing parameter documentation in the docstring of a function that has parameters.&#39;</span>
<span class="gd">-        }), (&#39;accept-no-raise-doc&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Whether to accept totally missing raises documentation in the docstring of a function that raises an exception.&#39;</span>
<span class="gd">-        }), (&#39;accept-no-return-doc&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Whether to accept totally missing return documentation in the docstring of a function that returns a statement.&#39;</span>
<span class="gd">-        }), (&#39;accept-no-yields-doc&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Whether to accept totally missing yields documentation in the docstring of a generator.&#39;</span>
<span class="gd">-        }), (&#39;default-docstring-type&#39;, {&#39;type&#39;: &#39;choice&#39;, &#39;default&#39;:</span>
<span class="gd">-        &#39;default&#39;, &#39;metavar&#39;: &#39;&lt;docstring type&gt;&#39;, &#39;choices&#39;: list(utils.</span>
<span class="gd">-        DOCSTRING_TYPES), &#39;help&#39;:</span>
<span class="gd">-        &#39;If the docstring type cannot be guessed the specified docstring type will be used.&#39;</span>
<span class="gd">-        })</span>
<span class="gd">-    constructor_names = {&#39;__init__&#39;, &#39;__new__&#39;}</span>
<span class="gd">-    not_needed_param_in_docstring = {&#39;self&#39;, &#39;cls&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;parameter_documentation&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W9005&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; has constructor parameters documented in class and __init__&#39;,</span>
<span class="gi">+            &quot;multiple-constructor-doc&quot;,</span>
<span class="gi">+            &quot;Please remove parameter declarations in the class or constructor.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9006&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; not documented as being raised&#39;,</span>
<span class="gi">+            &quot;missing-raises-doc&quot;,</span>
<span class="gi">+            &quot;Please document exceptions for all raised exception types.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9008&quot;: (</span>
<span class="gi">+            &quot;Redundant returns documentation&quot;,</span>
<span class="gi">+            &quot;redundant-returns-doc&quot;,</span>
<span class="gi">+            &quot;Please remove the return/rtype documentation from this method.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9010&quot;: (</span>
<span class="gi">+            &quot;Redundant yields documentation&quot;,</span>
<span class="gi">+            &quot;redundant-yields-doc&quot;,</span>
<span class="gi">+            &quot;Please remove the yields documentation from this method.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9011&quot;: (</span>
<span class="gi">+            &quot;Missing return documentation&quot;,</span>
<span class="gi">+            &quot;missing-return-doc&quot;,</span>
<span class="gi">+            &quot;Please add documentation about what this method returns.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W9007&quot;, &quot;old-missing-returns-doc&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9012&quot;: (</span>
<span class="gi">+            &quot;Missing return type documentation&quot;,</span>
<span class="gi">+            &quot;missing-return-type-doc&quot;,</span>
<span class="gi">+            &quot;Please document the type returned by this method.&quot;,</span>
<span class="gi">+            # we can&#39;t use the same old_name for two different warnings</span>
<span class="gi">+            # {&#39;old_names&#39;: [(&#39;W9007&#39;, &#39;missing-returns-doc&#39;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9013&quot;: (</span>
<span class="gi">+            &quot;Missing yield documentation&quot;,</span>
<span class="gi">+            &quot;missing-yield-doc&quot;,</span>
<span class="gi">+            &quot;Please add documentation about what this generator yields.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W9009&quot;, &quot;old-missing-yields-doc&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9014&quot;: (</span>
<span class="gi">+            &quot;Missing yield type documentation&quot;,</span>
<span class="gi">+            &quot;missing-yield-type-doc&quot;,</span>
<span class="gi">+            &quot;Please document the type yielded by this method.&quot;,</span>
<span class="gi">+            # we can&#39;t use the same old_name for two different warnings</span>
<span class="gi">+            # {&#39;old_names&#39;: [(&#39;W9009&#39;, &#39;missing-yields-doc&#39;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9015&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; missing in parameter documentation&#39;,</span>
<span class="gi">+            &quot;missing-param-doc&quot;,</span>
<span class="gi">+            &quot;Please add parameter declarations for all parameters.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W9003&quot;, &quot;old-missing-param-doc&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9016&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; missing in parameter type documentation&#39;,</span>
<span class="gi">+            &quot;missing-type-doc&quot;,</span>
<span class="gi">+            &quot;Please add parameter type declarations for all parameters.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;W9004&quot;, &quot;old-missing-type-doc&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9017&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; differing in parameter documentation&#39;,</span>
<span class="gi">+            &quot;differing-param-doc&quot;,</span>
<span class="gi">+            &quot;Please check parameter names in declarations.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9018&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; differing in parameter type documentation&#39;,</span>
<span class="gi">+            &quot;differing-type-doc&quot;,</span>
<span class="gi">+            &quot;Please check parameter names in type declarations.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9019&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; useless ignored parameter documentation&#39;,</span>
<span class="gi">+            &quot;useless-param-doc&quot;,</span>
<span class="gi">+            &quot;Please remove the ignored parameter documentation.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9020&quot;: (</span>
<span class="gi">+            &#39;&quot;%s&quot; useless ignored parameter type documentation&#39;,</span>
<span class="gi">+            &quot;useless-type-doc&quot;,</span>
<span class="gi">+            &quot;Please remove the ignored parameter type documentation.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;W9021&quot;: (</span>
<span class="gi">+            &#39;Missing any documentation in &quot;%s&quot;&#39;,</span>
<span class="gi">+            &quot;missing-any-param-doc&quot;,</span>
<span class="gi">+            &quot;Please add parameter and/or type documentation.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;accept-no-param-doc&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Whether to accept totally missing parameter &quot;</span>
<span class="gi">+                &quot;documentation in the docstring of a function that has &quot;</span>
<span class="gi">+                &quot;parameters.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;accept-no-raise-doc&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Whether to accept totally missing raises &quot;</span>
<span class="gi">+                &quot;documentation in the docstring of a function that &quot;</span>
<span class="gi">+                &quot;raises an exception.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;accept-no-return-doc&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Whether to accept totally missing return &quot;</span>
<span class="gi">+                &quot;documentation in the docstring of a function that &quot;</span>
<span class="gi">+                &quot;returns a statement.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;accept-no-yields-doc&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Whether to accept totally missing yields &quot;</span>
<span class="gi">+                &quot;documentation in the docstring of a generator.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;default-docstring-type&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;choice&quot;,</span>
<span class="gi">+                &quot;default&quot;: &quot;default&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;docstring type&gt;&quot;,</span>
<span class="gi">+                &quot;choices&quot;: list(utils.DOCSTRING_TYPES),</span>
<span class="gi">+                &quot;help&quot;: &quot;If the docstring type cannot be guessed &quot;</span>
<span class="gi">+                &quot;the specified docstring type will be used.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    constructor_names = {&quot;__init__&quot;, &quot;__new__&quot;}</span>
<span class="gi">+    not_needed_param_in_docstring = {&quot;self&quot;, &quot;cls&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called for function and method definitions (def).

<span class="w"> </span>        :param node: Node for a function or method definition in the AST
<span class="w"> </span>        :type node: :class:`astroid.scoped_nodes.Function`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if checker_utils.is_overload_stub(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        node_doc = utils.docstringify(</span>
<span class="gi">+            node.doc_node, self.linter.config.default_docstring_type</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # skip functions that match the &#39;no-docstring-rgx&#39; config option</span>
<span class="gi">+        no_docstring_rgx = self.linter.config.no_docstring_rgx</span>
<span class="gi">+        if no_docstring_rgx and re.match(no_docstring_rgx, node.name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # skip functions smaller than &#39;docstring-min-length&#39;</span>
<span class="gi">+        lines = checker_utils.get_node_last_lineno(node) - node.lineno</span>
<span class="gi">+        max_lines = self.linter.config.docstring_min_length</span>
<span class="gi">+        if max_lines &gt; -1 and lines &lt; max_lines:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.check_functiondef_params(node, node_doc)</span>
<span class="gi">+        self.check_functiondef_returns(node, node_doc)</span>
<span class="gi">+        self.check_functiondef_yields(node, node_doc)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef
<span class="gi">+</span>
<span class="gi">+    def check_functiondef_params(</span>
<span class="gi">+        self, node: nodes.FunctionDef, node_doc: Docstring</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        node_allow_no_param = None</span>
<span class="gi">+        if node.name in self.constructor_names:</span>
<span class="gi">+            class_node = checker_utils.node_frame_class(node)</span>
<span class="gi">+            if class_node is not None:</span>
<span class="gi">+                class_doc = utils.docstringify(</span>
<span class="gi">+                    class_node.doc_node, self.linter.config.default_docstring_type</span>
<span class="gi">+                )</span>
<span class="gi">+                self.check_single_constructor_params(class_doc, node_doc, class_node)</span>
<span class="gi">+</span>
<span class="gi">+                # __init__ or class docstrings can have no parameters documented</span>
<span class="gi">+                # as long as the other documents them.</span>
<span class="gi">+                node_allow_no_param = (</span>
<span class="gi">+                    class_doc.has_params()</span>
<span class="gi">+                    or class_doc.params_documented_elsewhere()</span>
<span class="gi">+                    or None</span>
<span class="gi">+                )</span>
<span class="gi">+                class_allow_no_param = (</span>
<span class="gi">+                    node_doc.has_params()</span>
<span class="gi">+                    or node_doc.params_documented_elsewhere()</span>
<span class="gi">+                    or None</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                self.check_arguments_in_docstring(</span>
<span class="gi">+                    class_doc, node.args, class_node, class_allow_no_param</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        self.check_arguments_in_docstring(</span>
<span class="gi">+            node_doc, node.args, node, node_allow_no_param</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def check_functiondef_returns(</span>
<span class="gi">+        self, node: nodes.FunctionDef, node_doc: Docstring</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if (not node_doc.supports_yields and node.is_generator()) or node.is_abstract():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        return_nodes = node.nodes_of_class(astroid.Return)</span>
<span class="gi">+        if (node_doc.has_returns() or node_doc.has_rtype()) and not any(</span>
<span class="gi">+            utils.returns_something(ret_node) for ret_node in return_nodes</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;redundant-returns-doc&quot;, node=node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    def check_functiondef_yields(</span>
<span class="gi">+        self, node: nodes.FunctionDef, node_doc: Docstring</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if not node_doc.supports_yields or node.is_abstract():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            node_doc.has_yields() or node_doc.has_yields_type()</span>
<span class="gi">+        ) and not node.is_generator():</span>
<span class="gi">+            self.add_message(&quot;redundant-yields-doc&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_raise(self, node: nodes.Raise) -&gt; None:</span>
<span class="gi">+        func_node = node.frame()</span>
<span class="gi">+        if not isinstance(func_node, astroid.FunctionDef):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # skip functions that match the &#39;no-docstring-rgx&#39; config option</span>
<span class="gi">+        no_docstring_rgx = self.linter.config.no_docstring_rgx</span>
<span class="gi">+        if no_docstring_rgx and re.match(no_docstring_rgx, func_node.name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        expected_excs = utils.possible_exc_types(node)</span>
<span class="gi">+</span>
<span class="gi">+        if not expected_excs:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not func_node.doc_node:</span>
<span class="gi">+            # If this is a property setter,</span>
<span class="gi">+            # the property should have the docstring instead.</span>
<span class="gi">+            property_ = utils.get_setters_property(func_node)</span>
<span class="gi">+            if property_:</span>
<span class="gi">+                func_node = property_</span>
<span class="gi">+</span>
<span class="gi">+        doc = utils.docstringify(</span>
<span class="gi">+            func_node.doc_node, self.linter.config.default_docstring_type</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if self.linter.config.accept_no_raise_doc and not doc.exceptions():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not doc.matching_sections():</span>
<span class="gi">+            if doc.doc:</span>
<span class="gi">+                missing = {exc.name for exc in expected_excs}</span>
<span class="gi">+                self._add_raise_message(missing, func_node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        found_excs_full_names = doc.exceptions()</span>
<span class="gi">+</span>
<span class="gi">+        # Extract just the class name, e.g. &quot;error&quot; from &quot;re.error&quot;</span>
<span class="gi">+        found_excs_class_names = {exc.split(&quot;.&quot;)[-1] for exc in found_excs_full_names}</span>
<span class="gi">+</span>
<span class="gi">+        missing_excs = set()</span>
<span class="gi">+        for expected in expected_excs:</span>
<span class="gi">+            for found_exc in found_excs_class_names:</span>
<span class="gi">+                if found_exc == expected.name:</span>
<span class="gi">+                    break</span>
<span class="gi">+                if any(found_exc == ancestor.name for ancestor in expected.ancestors()):</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                missing_excs.add(expected.name)</span>
<span class="gi">+</span>
<span class="gi">+        self._add_raise_message(missing_excs, func_node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_return(self, node: nodes.Return) -&gt; None:</span>
<span class="gi">+        if not utils.returns_something(node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self.linter.config.accept_no_return_doc:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        func_node: astroid.FunctionDef = node.frame()</span>
<span class="gi">+</span>
<span class="gi">+        # skip functions that match the &#39;no-docstring-rgx&#39; config option</span>
<span class="gi">+        no_docstring_rgx = self.linter.config.no_docstring_rgx</span>
<span class="gi">+        if no_docstring_rgx and re.match(no_docstring_rgx, func_node.name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        doc = utils.docstringify(</span>
<span class="gi">+            func_node.doc_node, self.linter.config.default_docstring_type</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        is_property = checker_utils.decorated_with_property(func_node)</span>
<span class="gi">+</span>
<span class="gi">+        if not (doc.has_returns() or (doc.has_property_returns() and is_property)):</span>
<span class="gi">+            self.add_message(&quot;missing-return-doc&quot;, node=func_node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+        if func_node.returns or func_node.type_comment_returns:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not (doc.has_rtype() or (doc.has_property_type() and is_property)):</span>
<span class="gi">+            self.add_message(&quot;missing-return-type-doc&quot;, node=func_node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_yield(self, node: nodes.Yield | nodes.YieldFrom) -&gt; None:</span>
<span class="gi">+        if self.linter.config.accept_no_yields_doc:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        func_node: astroid.FunctionDef = node.frame()</span>
<span class="gi">+</span>
<span class="gi">+        # skip functions that match the &#39;no-docstring-rgx&#39; config option</span>
<span class="gi">+        no_docstring_rgx = self.linter.config.no_docstring_rgx</span>
<span class="gi">+        if no_docstring_rgx and re.match(no_docstring_rgx, func_node.name):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        doc = utils.docstringify(</span>
<span class="gi">+            func_node.doc_node, self.linter.config.default_docstring_type</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if doc.supports_yields:</span>
<span class="gi">+            doc_has_yields = doc.has_yields()</span>
<span class="gi">+            doc_has_yields_type = doc.has_yields_type()</span>
<span class="gi">+        else:</span>
<span class="gi">+            doc_has_yields = doc.has_returns()</span>
<span class="gi">+            doc_has_yields_type = doc.has_rtype()</span>
<span class="gi">+</span>
<span class="gi">+        if not doc_has_yields:</span>
<span class="gi">+            self.add_message(&quot;missing-yield-doc&quot;, node=func_node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+        if not (</span>
<span class="gi">+            doc_has_yields_type or func_node.returns or func_node.type_comment_returns</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(&quot;missing-yield-type-doc&quot;, node=func_node, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_yieldfrom = visit_yield

<span class="gd">-    def _compare_missing_args(self, found_argument_names: set[str],</span>
<span class="gd">-        message_id: str, not_needed_names: set[str],</span>
<span class="gd">-        expected_argument_names: set[str], warning_node: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+    def _compare_missing_args(</span>
<span class="gi">+        self,</span>
<span class="gi">+        found_argument_names: set[str],</span>
<span class="gi">+        message_id: str,</span>
<span class="gi">+        not_needed_names: set[str],</span>
<span class="gi">+        expected_argument_names: set[str],</span>
<span class="gi">+        warning_node: nodes.NodeNG,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compare the found argument names with the expected ones and
<span class="w"> </span>        generate a message if there are arguments missing.

<span class="gu">@@ -120,11 +410,33 @@ class DocstringParameterChecker(BaseChecker):</span>

<span class="w"> </span>        :param warning_node: The node to be analyzed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        potential_missing_argument_names = (</span>
<span class="gi">+            expected_argument_names - found_argument_names</span>
<span class="gi">+        ) - not_needed_names</span>
<span class="gi">+</span>
<span class="gi">+        # Handle variadic and keyword args without asterisks</span>
<span class="gi">+        missing_argument_names = set()</span>
<span class="gi">+        for name in potential_missing_argument_names:</span>
<span class="gi">+            if name.replace(&quot;*&quot;, &quot;&quot;) in found_argument_names:</span>
<span class="gi">+                continue</span>
<span class="gi">+            missing_argument_names.add(name)</span>

<span class="gd">-    def _compare_different_args(self, found_argument_names: set[str],</span>
<span class="gd">-        message_id: str, not_needed_names: set[str],</span>
<span class="gd">-        expected_argument_names: set[str], warning_node: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+        if missing_argument_names:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                message_id,</span>
<span class="gi">+                args=(&quot;, &quot;.join(sorted(missing_argument_names)),),</span>
<span class="gi">+                node=warning_node,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _compare_different_args(</span>
<span class="gi">+        self,</span>
<span class="gi">+        found_argument_names: set[str],</span>
<span class="gi">+        message_id: str,</span>
<span class="gi">+        not_needed_names: set[str],</span>
<span class="gi">+        expected_argument_names: set[str],</span>
<span class="gi">+        warning_node: nodes.NodeNG,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compare the found argument names with the expected ones and
<span class="w"> </span>        generate a message if there are extra arguments found.

<span class="gu">@@ -138,11 +450,35 @@ class DocstringParameterChecker(BaseChecker):</span>

<span class="w"> </span>        :param warning_node: The node to be analyzed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Handle variadic and keyword args without asterisks</span>
<span class="gi">+        modified_expected_argument_names: set[str] = set()</span>
<span class="gi">+        for name in expected_argument_names:</span>
<span class="gi">+            if name.replace(&quot;*&quot;, &quot;&quot;) in found_argument_names:</span>
<span class="gi">+                modified_expected_argument_names.add(name.replace(&quot;*&quot;, &quot;&quot;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                modified_expected_argument_names.add(name)</span>
<span class="gi">+</span>
<span class="gi">+        differing_argument_names = (</span>
<span class="gi">+            (modified_expected_argument_names ^ found_argument_names)</span>
<span class="gi">+            - not_needed_names</span>
<span class="gi">+            - expected_argument_names</span>
<span class="gi">+        )</span>

<span class="gd">-    def _compare_ignored_args(self, found_argument_names: set[str],</span>
<span class="gd">-        message_id: str, ignored_argument_names: set[str], warning_node:</span>
<span class="gd">-        nodes.NodeNG) -&gt;None:</span>
<span class="gi">+        if differing_argument_names:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                message_id,</span>
<span class="gi">+                args=(&quot;, &quot;.join(sorted(differing_argument_names)),),</span>
<span class="gi">+                node=warning_node,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _compare_ignored_args(  # pylint: disable=useless-param-doc</span>
<span class="gi">+        self,</span>
<span class="gi">+        found_argument_names: set[str],</span>
<span class="gi">+        message_id: str,</span>
<span class="gi">+        ignored_argument_names: set[str],</span>
<span class="gi">+        warning_node: nodes.NodeNG,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Compare the found argument names with the ignored ones and
<span class="w"> </span>        generate a message if there are ignored arguments found.

<span class="gu">@@ -151,11 +487,23 @@ class DocstringParameterChecker(BaseChecker):</span>
<span class="w"> </span>        :param ignored_argument_names: Expected argument names
<span class="w"> </span>        :param warning_node: The node to be analyzed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        existing_ignored_argument_names = ignored_argument_names &amp; found_argument_names</span>
<span class="gi">+</span>
<span class="gi">+        if existing_ignored_argument_names:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                message_id,</span>
<span class="gi">+                args=(&quot;, &quot;.join(sorted(existing_ignored_argument_names)),),</span>
<span class="gi">+                node=warning_node,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>

<span class="gd">-    def check_arguments_in_docstring(self, doc: Docstring, arguments_node:</span>
<span class="gd">-        astroid.Arguments, warning_node: astroid.NodeNG,</span>
<span class="gd">-        accept_no_param_doc: (bool | None)=None) -&gt;None:</span>
<span class="gi">+    def check_arguments_in_docstring(</span>
<span class="gi">+        self,</span>
<span class="gi">+        doc: Docstring,</span>
<span class="gi">+        arguments_node: astroid.Arguments,</span>
<span class="gi">+        warning_node: astroid.NodeNG,</span>
<span class="gi">+        accept_no_param_doc: bool | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check that all parameters are consistent with the parameters mentioned
<span class="w"> </span>        in the parameter documentation (e.g. the Sphinx tags &#39;param&#39; and &#39;type&#39;).

<span class="gu">@@ -186,13 +534,140 @@ class DocstringParameterChecker(BaseChecker):</span>
<span class="w"> </span>            documented. If None then this value is read from the configuration.
<span class="w"> </span>        :type accept_no_param_doc: bool or None
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Tolerate missing param or type declarations if there is a link to</span>
<span class="gi">+        # another method carrying the same name.</span>
<span class="gi">+        if not doc.doc:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if accept_no_param_doc is None:</span>
<span class="gi">+            accept_no_param_doc = self.linter.config.accept_no_param_doc</span>
<span class="gi">+        tolerate_missing_params = doc.params_documented_elsewhere()</span>
<span class="gi">+</span>
<span class="gi">+        # Collect the function arguments.</span>
<span class="gi">+        expected_argument_names = {arg.name for arg in arguments_node.args}</span>
<span class="gi">+        expected_argument_names.update(</span>
<span class="gi">+            a.name for a in arguments_node.posonlyargs + arguments_node.kwonlyargs</span>
<span class="gi">+        )</span>
<span class="gi">+        not_needed_type_in_docstring = self.not_needed_param_in_docstring.copy()</span>

<span class="gd">-    def _add_raise_message(self, missing_exceptions: set[str], node: nodes.</span>
<span class="gd">-        FunctionDef) -&gt;None:</span>
<span class="gi">+        expected_but_ignored_argument_names = set()</span>
<span class="gi">+        ignored_argument_names = self.linter.config.ignored_argument_names</span>
<span class="gi">+        if ignored_argument_names:</span>
<span class="gi">+            expected_but_ignored_argument_names = {</span>
<span class="gi">+                arg</span>
<span class="gi">+                for arg in expected_argument_names</span>
<span class="gi">+                if ignored_argument_names.match(arg)</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        if arguments_node.vararg is not None:</span>
<span class="gi">+            expected_argument_names.add(f&quot;*{arguments_node.vararg}&quot;)</span>
<span class="gi">+            not_needed_type_in_docstring.add(f&quot;*{arguments_node.vararg}&quot;)</span>
<span class="gi">+        if arguments_node.kwarg is not None:</span>
<span class="gi">+            expected_argument_names.add(f&quot;**{arguments_node.kwarg}&quot;)</span>
<span class="gi">+            not_needed_type_in_docstring.add(f&quot;**{arguments_node.kwarg}&quot;)</span>
<span class="gi">+        params_with_doc, params_with_type = doc.match_param_docs()</span>
<span class="gi">+        # Tolerate no parameter documentation at all.</span>
<span class="gi">+        if not params_with_doc and not params_with_type and accept_no_param_doc:</span>
<span class="gi">+            tolerate_missing_params = True</span>
<span class="gi">+</span>
<span class="gi">+        # This is before the update of params_with_type because this must check only</span>
<span class="gi">+        # the type documented in a docstring, not the one using pep484</span>
<span class="gi">+        # See #4117 and #4593</span>
<span class="gi">+        self._compare_ignored_args(</span>
<span class="gi">+            params_with_type,</span>
<span class="gi">+            &quot;useless-type-doc&quot;,</span>
<span class="gi">+            expected_but_ignored_argument_names,</span>
<span class="gi">+            warning_node,</span>
<span class="gi">+        )</span>
<span class="gi">+        params_with_type |= utils.args_with_annotation(arguments_node)</span>
<span class="gi">+</span>
<span class="gi">+        if not tolerate_missing_params:</span>
<span class="gi">+            missing_param_doc = (expected_argument_names - params_with_doc) - (</span>
<span class="gi">+                self.not_needed_param_in_docstring | expected_but_ignored_argument_names</span>
<span class="gi">+            )</span>
<span class="gi">+            missing_type_doc = (expected_argument_names - params_with_type) - (</span>
<span class="gi">+                not_needed_type_in_docstring | expected_but_ignored_argument_names</span>
<span class="gi">+            )</span>
<span class="gi">+            if (</span>
<span class="gi">+                missing_param_doc == expected_argument_names == missing_type_doc</span>
<span class="gi">+                and len(expected_argument_names) != 0</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;missing-any-param-doc&quot;,</span>
<span class="gi">+                    args=(warning_node.name,),</span>
<span class="gi">+                    node=warning_node,</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._compare_missing_args(</span>
<span class="gi">+                    params_with_doc,</span>
<span class="gi">+                    &quot;missing-param-doc&quot;,</span>
<span class="gi">+                    self.not_needed_param_in_docstring</span>
<span class="gi">+                    | expected_but_ignored_argument_names,</span>
<span class="gi">+                    expected_argument_names,</span>
<span class="gi">+                    warning_node,</span>
<span class="gi">+                )</span>
<span class="gi">+                self._compare_missing_args(</span>
<span class="gi">+                    params_with_type,</span>
<span class="gi">+                    &quot;missing-type-doc&quot;,</span>
<span class="gi">+                    not_needed_type_in_docstring | expected_but_ignored_argument_names,</span>
<span class="gi">+                    expected_argument_names,</span>
<span class="gi">+                    warning_node,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        self._compare_different_args(</span>
<span class="gi">+            params_with_doc,</span>
<span class="gi">+            &quot;differing-param-doc&quot;,</span>
<span class="gi">+            self.not_needed_param_in_docstring,</span>
<span class="gi">+            expected_argument_names,</span>
<span class="gi">+            warning_node,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._compare_different_args(</span>
<span class="gi">+            params_with_type,</span>
<span class="gi">+            &quot;differing-type-doc&quot;,</span>
<span class="gi">+            not_needed_type_in_docstring,</span>
<span class="gi">+            expected_argument_names,</span>
<span class="gi">+            warning_node,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._compare_ignored_args(</span>
<span class="gi">+            params_with_doc,</span>
<span class="gi">+            &quot;useless-param-doc&quot;,</span>
<span class="gi">+            expected_but_ignored_argument_names,</span>
<span class="gi">+            warning_node,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def check_single_constructor_params(</span>
<span class="gi">+        self, class_doc: Docstring, init_doc: Docstring, class_node: nodes.ClassDef</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if class_doc.has_params() and init_doc.has_params():</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;multiple-constructor-doc&quot;,</span>
<span class="gi">+                args=(class_node.name,),</span>
<span class="gi">+                node=class_node,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _add_raise_message(</span>
<span class="gi">+        self, missing_exceptions: set[str], node: nodes.FunctionDef</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a message on :param:`node` for the missing exception type.

<span class="w"> </span>        :param missing_exceptions: A list of missing exception types.
<span class="w"> </span>        :param node: The node show the message on.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.is_abstract():</span>
<span class="gi">+            try:</span>
<span class="gi">+                missing_exceptions.remove(&quot;NotImplementedError&quot;)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        if missing_exceptions:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;missing-raises-doc&quot;,</span>
<span class="gi">+                args=(&quot;, &quot;.join(sorted(missing_exceptions)),),</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(DocstringParameterChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/docstyle.py b/pylint/extensions/docstyle.py</span>
<span class="gh">index c00ca565d..c54ab93b2 100644</span>
<span class="gd">--- a/pylint/extensions/docstyle.py</span>
<span class="gi">+++ b/pylint/extensions/docstyle.py</span>
<span class="gu">@@ -1,21 +1,89 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import linecache
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class DocStringStyleChecker(checkers.BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks format of docstrings based on PEP 0257.&quot;&quot;&quot;
<span class="gd">-    name = &#39;docstyle&#39;</span>
<span class="gd">-    msgs = {&#39;C0198&#39;: (&#39;Bad docstring quotes in %s, expected &quot;&quot;&quot;, given %s&#39;,</span>
<span class="gd">-        &#39;bad-docstring-quotes&#39;,</span>
<span class="gd">-        &#39;Used when a docstring does not have triple double quotes.&#39;),</span>
<span class="gd">-        &#39;C0199&#39;: (&#39;First line empty in %s docstring&#39;,</span>
<span class="gd">-        &#39;docstring-first-line-empty&#39;,</span>
<span class="gd">-        &#39;Used when a blank line is found at the beginning of a docstring.&#39;)}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;docstyle&quot;</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C0198&quot;: (</span>
<span class="gi">+            &#39;Bad docstring quotes in %s, expected &quot;&quot;&quot;, given %s&#39;,</span>
<span class="gi">+            &quot;bad-docstring-quotes&quot;,</span>
<span class="gi">+            &quot;Used when a docstring does not have triple double quotes.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;C0199&quot;: (</span>
<span class="gi">+            &quot;First line empty in %s docstring&quot;,</span>
<span class="gi">+            &quot;docstring-first-line-empty&quot;,</span>
<span class="gi">+            &quot;Used when a blank line is found at the beginning of a docstring.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;docstring-first-line-empty&quot;, &quot;bad-docstring-quotes&quot;)</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="gi">+        self._check_docstring(&quot;module&quot;, node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        self._check_docstring(&quot;class&quot;, node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        ftype = &quot;method&quot; if node.is_method() else &quot;function&quot;</span>
<span class="gi">+        self._check_docstring(ftype, node)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef
<span class="gi">+</span>
<span class="gi">+    def _check_docstring(</span>
<span class="gi">+        self, node_type: str, node: nodes.Module | nodes.ClassDef | nodes.FunctionDef</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        docstring = node.doc_node.value if node.doc_node else None</span>
<span class="gi">+        if docstring and docstring[0] == &quot;\n&quot;:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;docstring-first-line-empty&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(node_type,),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Use &quot;linecache&quot;, instead of node.as_string(), because the latter</span>
<span class="gi">+        # looses the original form of the docstrings.</span>
<span class="gi">+</span>
<span class="gi">+        if docstring:</span>
<span class="gi">+            lineno = node.fromlineno + 1</span>
<span class="gi">+            line = linecache.getline(node.root().file, lineno).lstrip()</span>
<span class="gi">+            if line and line.find(&#39;&quot;&quot;&quot;&#39;) == 0:</span>
<span class="gi">+                return</span>
<span class="gi">+            if line and &quot;&#39;&#39;&#39;&quot; in line:</span>
<span class="gi">+                quotes = &quot;&#39;&#39;&#39;&quot;</span>
<span class="gi">+            elif line and line[0] == &#39;&quot;&#39;:</span>
<span class="gi">+                quotes = &#39;&quot;&#39;</span>
<span class="gi">+            elif line and line[0] == &quot;&#39;&quot;:</span>
<span class="gi">+                quotes = &quot;&#39;&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                quotes = &quot;&quot;</span>
<span class="gi">+            if quotes:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;bad-docstring-quotes&quot;,</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    args=(node_type, quotes),</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(DocStringStyleChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/dunder.py b/pylint/extensions/dunder.py</span>
<span class="gh">index 40e8f7fe8..1683f8147 100644</span>
<span class="gd">--- a/pylint/extensions/dunder.py</span>
<span class="gi">+++ b/pylint/extensions/dunder.py</span>
<span class="gu">@@ -1,26 +1,76 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.constants import DUNDER_METHODS, DUNDER_PROPERTIES, EXTRA_DUNDER_METHODS
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class DunderChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks related to dunder methods.&quot;&quot;&quot;
<span class="gd">-    name = &#39;dunder&#39;</span>
<span class="gd">-    msgs = {&#39;W3201&#39;: (&#39;Bad or misspelled dunder method name %s.&#39;,</span>
<span class="gd">-        &#39;bad-dunder-name&#39;,</span>
<span class="gd">-        &#39;Used when a dunder method is misspelled or defined with a name not within the predefined list of dunder names.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-    options = (&#39;good-dunder-names&#39;, {&#39;default&#39;: [], &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-        &#39;metavar&#39;: &#39;&lt;comma-separated names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &#39;Good dunder names which should always be accepted.&#39;}),</span>
<span class="gd">-</span>
<span class="gd">-    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;dunder&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W3201&quot;: (</span>
<span class="gi">+            &quot;Bad or misspelled dunder method name %s.&quot;,</span>
<span class="gi">+            &quot;bad-dunder-name&quot;,</span>
<span class="gi">+            &quot;Used when a dunder method is misspelled or defined with a name &quot;</span>
<span class="gi">+            &quot;not within the predefined list of dunder names.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;good-dunder-names&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: [],</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;comma-separated names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Good dunder names which should always be accepted.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        self._dunder_methods = (</span>
<span class="gi">+            EXTRA_DUNDER_METHODS</span>
<span class="gi">+            + DUNDER_PROPERTIES</span>
<span class="gi">+            + self.linter.config.good_dunder_names</span>
<span class="gi">+        )</span>
<span class="gi">+        for since_vers, dunder_methods in DUNDER_METHODS.items():</span>
<span class="gi">+            if since_vers &lt;= self.linter.config.py_version:</span>
<span class="gi">+                self._dunder_methods.extend(list(dunder_methods.keys()))</span>
<span class="gi">+</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if known dunder method is misspelled or dunder name is not one
<span class="w"> </span>        of the pre-defined names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # ignore module-level functions</span>
<span class="gi">+        if not node.is_method():</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Detect something that could be a bad dunder method</span>
<span class="gi">+        if (</span>
<span class="gi">+            node.name.startswith(&quot;_&quot;)</span>
<span class="gi">+            and node.name.endswith(&quot;_&quot;)</span>
<span class="gi">+            and node.name not in self._dunder_methods</span>
<span class="gi">+        ):</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;bad-dunder-name&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(node.name),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(DunderChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/empty_comment.py b/pylint/extensions/empty_comment.py</span>
<span class="gh">index 54f595eb6..7f54322ae 100644</span>
<span class="gd">--- a/pylint/extensions/empty_comment.py</span>
<span class="gi">+++ b/pylint/extensions/empty_comment.py</span>
<span class="gu">@@ -1,24 +1,63 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseRawFileChecker
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="gd">-def is_line_commented(line: bytes) -&gt;bool:</span>
<span class="gi">+def is_line_commented(line: bytes) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if a `# symbol that is not part of a string was found in line.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    comment_idx = line.find(b&quot;#&quot;)</span>
<span class="gi">+    if comment_idx == -1:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if comment_part_of_string(line, comment_idx):</span>
<span class="gi">+        return is_line_commented(line[:comment_idx] + line[comment_idx + 1 :])</span>
<span class="gi">+    return True</span>


<span class="gd">-def comment_part_of_string(line: bytes, comment_idx: int) -&gt;bool:</span>
<span class="gi">+def comment_part_of_string(line: bytes, comment_idx: int) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if the symbol at comment_idx is part of a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (</span>
<span class="gi">+        line[:comment_idx].count(b&quot;&#39;&quot;) % 2 == 1</span>
<span class="gi">+        and line[comment_idx:].count(b&quot;&#39;&quot;) % 2 == 1</span>
<span class="gi">+    ) or (</span>
<span class="gi">+        line[:comment_idx].count(b&#39;&quot;&#39;) % 2 == 1</span>
<span class="gi">+        and line[comment_idx:].count(b&#39;&quot;&#39;) % 2 == 1</span>
<span class="gi">+    ):</span>
<span class="gi">+        return True</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class CommentChecker(BaseRawFileChecker):
<span class="gd">-    name = &#39;empty-comment&#39;</span>
<span class="gd">-    msgs = {&#39;R2044&#39;: (&#39;Line with empty comment&#39;, &#39;empty-comment&#39;,</span>
<span class="gd">-        &#39;Used when a # symbol appears on a line not followed by an actual comment&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+    name = &quot;empty-comment&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R2044&quot;: (</span>
<span class="gi">+            &quot;Line with empty comment&quot;,</span>
<span class="gi">+            &quot;empty-comment&quot;,</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;Used when a # symbol appears on a line not followed by an actual comment&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="w"> </span>    options = ()
<span class="gi">+</span>
<span class="gi">+    def process_module(self, node: nodes.Module) -&gt; None:</span>
<span class="gi">+        with node.stream() as stream:</span>
<span class="gi">+            for line_num, line in enumerate(stream):</span>
<span class="gi">+                line = line.rstrip()</span>
<span class="gi">+                if line.endswith(b&quot;#&quot;):</span>
<span class="gi">+                    if not is_line_commented(line[:-1]):</span>
<span class="gi">+                        self.add_message(&quot;empty-comment&quot;, line=line_num + 1)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(CommentChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/eq_without_hash.py b/pylint/extensions/eq_without_hash.py</span>
<span class="gh">index 39c430d15..5f39dfa3e 100644</span>
<span class="gd">--- a/pylint/extensions/eq_without_hash.py</span>
<span class="gi">+++ b/pylint/extensions/eq_without_hash.py</span>
<span class="gu">@@ -1,19 +1,39 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;This is the remnant of the python3 checker.

<span class="w"> </span>It was removed because the transition from python 2 to python3 is
<span class="w"> </span>behind us, but some checks are still useful in python3 after all.
<span class="w"> </span>See https://github.com/pylint-dev/pylint/issues/5025
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers, interfaces
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.lint import PyLinter


<span class="w"> </span>class EqWithoutHash(checkers.BaseChecker):
<span class="gd">-    name = &#39;eq-without-hash&#39;</span>
<span class="gd">-    msgs = {&#39;W1641&#39;: (</span>
<span class="gd">-        &#39;Implementing __eq__ without also implementing __hash__&#39;,</span>
<span class="gd">-        &#39;eq-without-hash&#39;,</span>
<span class="gd">-        &#39;Used when a class implements __eq__ but not __hash__. Objects get None as their default __hash__ implementation if they also implement __eq__.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+    name = &quot;eq-without-hash&quot;</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W1641&quot;: (</span>
<span class="gi">+            &quot;Implementing __eq__ without also implementing __hash__&quot;,</span>
<span class="gi">+            &quot;eq-without-hash&quot;,</span>
<span class="gi">+            &quot;Used when a class implements __eq__ but not __hash__. Objects get &quot;</span>
<span class="gi">+            &quot;None as their default __hash__ implementation if they also implement __eq__.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;eq-without-hash&quot;)</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        locals_and_methods = set(node.locals).union(x.name for x in node.mymethods())</span>
<span class="gi">+        if &quot;__eq__&quot; in locals_and_methods and &quot;__hash__&quot; not in locals_and_methods:</span>
<span class="gi">+            self.add_message(&quot;eq-without-hash&quot;, node=node, confidence=interfaces.HIGH)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(EqWithoutHash(linter))</span>
<span class="gh">diff --git a/pylint/extensions/for_any_all.py b/pylint/extensions/for_any_all.py</span>
<span class="gh">index 8176cac2e..2369a595d 100644</span>
<span class="gd">--- a/pylint/extensions/for_any_all.py</span>
<span class="gi">+++ b/pylint/extensions/for_any_all.py</span>
<span class="gu">@@ -1,24 +1,78 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Check for use of for loops that only check for a condition.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="gd">-from pylint.checkers.utils import assigned_bool, only_required_for_messages, returns_bool</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    assigned_bool,</span>
<span class="gi">+    only_required_for_messages,</span>
<span class="gi">+    returns_bool,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter


<span class="w"> </span>class ConsiderUsingAnyOrAllChecker(BaseChecker):
<span class="gd">-    name = &#39;consider-using-any-or-all&#39;</span>
<span class="gd">-    msgs = {&#39;C0501&#39;: (&#39;`for` loop could be `%s`&#39;,</span>
<span class="gd">-        &#39;consider-using-any-or-all&#39;,</span>
<span class="gd">-        &#39;A for loop that checks for a condition and return a bool can be replaced with any or all.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+    name = &quot;consider-using-any-or-all&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C0501&quot;: (</span>
<span class="gi">+            &quot;`for` loop could be `%s`&quot;,</span>
<span class="gi">+            &quot;consider-using-any-or-all&quot;,</span>
<span class="gi">+            &quot;A for loop that checks for a condition and return a bool can be replaced with any or all.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;consider-using-any-or-all&quot;)</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        if len(node.body) != 1:  # Only If node with no Else</span>
<span class="gi">+            return</span>
<span class="gi">+        if not isinstance(node.body[0], nodes.If):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if_children = list(node.body[0].get_children())</span>
<span class="gi">+        if any(isinstance(child, nodes.If) for child in if_children):</span>
<span class="gi">+            # an if node within the if-children indicates an elif clause,</span>
<span class="gi">+            # suggesting complex logic.</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        node_after_loop = node.next_sibling()</span>
<span class="gi">+</span>
<span class="gi">+        if self._assigned_reassigned_returned(node, if_children, node_after_loop):</span>
<span class="gi">+            final_return_bool = node_after_loop.value.name</span>
<span class="gi">+            suggested_string = self._build_suggested_string(node, final_return_bool)</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-using-any-or-all&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=suggested_string,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self._if_statement_returns_bool(if_children, node_after_loop):</span>
<span class="gi">+            final_return_bool = node_after_loop.value.value</span>
<span class="gi">+            suggested_string = self._build_suggested_string(node, final_return_bool)</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;consider-using-any-or-all&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=suggested_string,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _if_statement_returns_bool(if_children: list[nodes.NodeNG],</span>
<span class="gd">-        node_after_loop: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    def _if_statement_returns_bool(</span>
<span class="gi">+        if_children: list[nodes.NodeNG], node_after_loop: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Detect for-loop, if-statement, return pattern:

<span class="w"> </span>        Ex:
<span class="gu">@@ -28,11 +82,19 @@ class ConsiderUsingAnyOrAllChecker(BaseChecker):</span>
<span class="w"> </span>                        return True
<span class="w"> </span>                return False
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not len(if_children) == 2:</span>
<span class="gi">+            # The If node has only a comparison and return</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not returns_bool(if_children[1]):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Check for terminating boolean return right after the loop</span>
<span class="gi">+        return returns_bool(node_after_loop)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _assigned_reassigned_returned(node: nodes.For, if_children: list[</span>
<span class="gd">-        nodes.NodeNG], node_after_loop: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+    def _assigned_reassigned_returned(</span>
<span class="gi">+        node: nodes.For, if_children: list[nodes.NodeNG], node_after_loop: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Detect boolean-assign, for-loop, re-assign, return pattern:

<span class="w"> </span>        Ex:
<span class="gu">@@ -44,15 +106,57 @@ class ConsiderUsingAnyOrAllChecker(BaseChecker):</span>
<span class="w"> </span>                    # no elif / else statement
<span class="w"> </span>                return long_line
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node_before_loop = node.previous_sibling()</span>
<span class="gi">+</span>
<span class="gi">+        if not assigned_bool(node_before_loop):</span>
<span class="gi">+            # node before loop isn&#39;t assigning to boolean</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        assign_children = [x for x in if_children if isinstance(x, nodes.Assign)]</span>
<span class="gi">+        if not assign_children:</span>
<span class="gi">+            # if-nodes inside loop aren&#39;t assignments</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # We only care for the first assign node of the if-children. Otherwise it breaks the pattern.</span>
<span class="gi">+        first_target = assign_children[0].targets[0]</span>
<span class="gi">+        target_before_loop = node_before_loop.targets[0]</span>
<span class="gi">+</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(first_target, nodes.AssignName)</span>
<span class="gi">+            and isinstance(target_before_loop, nodes.AssignName)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        node_before_loop_name = node_before_loop.targets[0].name</span>
<span class="gi">+        return (</span>
<span class="gi">+            first_target.name == node_before_loop_name</span>
<span class="gi">+            and isinstance(node_after_loop, nodes.Return)</span>
<span class="gi">+            and isinstance(node_after_loop.value, nodes.Name)</span>
<span class="gi">+            and node_after_loop.value.name == node_before_loop_name</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _build_suggested_string(node: nodes.For, final_return_bool: bool</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+    def _build_suggested_string(node: nodes.For, final_return_bool: bool) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;When a nodes.For node can be rewritten as an any/all statement, return a
<span class="w"> </span>        suggestion for that statement.

<span class="w"> </span>        &#39;final_return_bool&#39; is the boolean literal returned after the for loop if all
<span class="w"> </span>        conditions fail.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        loop_var = node.target.as_string()</span>
<span class="gi">+        loop_iter = node.iter.as_string()</span>
<span class="gi">+        test_node = next(node.body[0].get_children())</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(test_node, nodes.UnaryOp) and test_node.op == &quot;not&quot;:</span>
<span class="gi">+            # The condition is negated. Advance the node to the operand and modify the suggestion</span>
<span class="gi">+            test_node = test_node.operand</span>
<span class="gi">+            suggested_function = &quot;all&quot; if final_return_bool else &quot;not all&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            suggested_function = &quot;not any&quot; if final_return_bool else &quot;any&quot;</span>
<span class="gi">+</span>
<span class="gi">+        test = test_node.as_string()</span>
<span class="gi">+        return f&quot;{suggested_function}({test} for {loop_var} in {loop_iter})&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(ConsiderUsingAnyOrAllChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/magic_value.py b/pylint/extensions/magic_value.py</span>
<span class="gh">index 285fb59f4..fd18476ae 100644</span>
<span class="gd">--- a/pylint/extensions/magic_value.py</span>
<span class="gi">+++ b/pylint/extensions/magic_value.py</span>
<span class="gu">@@ -1,35 +1,119 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Checks for magic values instead of literals.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from re import match as regex_match
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class MagicValueChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks for constants in comparisons.&quot;&quot;&quot;
<span class="gd">-    name = &#39;magic-value&#39;</span>
<span class="gd">-    msgs = {&#39;R2004&#39;: (</span>
<span class="gd">-        &quot;Consider using a named constant or an enum instead of &#39;%s&#39;.&quot;,</span>
<span class="gd">-        &#39;magic-value-comparison&#39;,</span>
<span class="gd">-        &#39;Using named constants instead of magic values helps improve readability and maintainability of your code, try to avoid them in comparisons.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-    options = (&#39;valid-magic-values&#39;, {&#39;default&#39;: (0, -1, 1, &#39;&#39;, &#39;__main__&#39;),</span>
<span class="gd">-        &#39;type&#39;: &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;argument names&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &quot;List of valid magic values that `magic-value-compare` will not detect. Supports integers, floats, negative numbers, for empty string enter ``&#39;&#39;``, for backslash values just use one backslash e.g \\n.&quot;</span>
<span class="gd">-        }),</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;magic-value&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R2004&quot;: (</span>
<span class="gi">+            &quot;Consider using a named constant or an enum instead of &#39;%s&#39;.&quot;,</span>
<span class="gi">+            &quot;magic-value-comparison&quot;,</span>
<span class="gi">+            &quot;Using named constants instead of magic values helps improve readability and maintainability of your&quot;</span>
<span class="gi">+            &quot; code, try to avoid them in comparisons.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;valid-magic-values&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (0, -1, 1, &quot;&quot;, &quot;__main__&quot;),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;argument names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of valid magic values that `magic-value-compare` will not detect. &quot;</span>
<span class="gi">+                &quot;Supports integers, floats, negative numbers, for empty string enter ``&#39;&#39;``,&quot;</span>
<span class="gi">+                &quot; for backslash values just use one backslash e.g \\n.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize checker instance.&quot;&quot;&quot;
<span class="w"> </span>        super().__init__(linter=linter)
<span class="w"> </span>        self.valid_magic_vals: tuple[float | str, ...] = ()

<span class="gd">-    def _check_constants_comparison(self, node: nodes.Compare) -&gt;None:</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        # Extra manipulation is needed in case of using external configuration like an rcfile</span>
<span class="gi">+        if self._magic_vals_ext_configured():</span>
<span class="gi">+            self.valid_magic_vals = tuple(</span>
<span class="gi">+                self._parse_rcfile_magic_numbers(value)</span>
<span class="gi">+                for value in self.linter.config.valid_magic_values</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.valid_magic_vals = self.linter.config.valid_magic_values</span>
<span class="gi">+</span>
<span class="gi">+    def _magic_vals_ext_configured(self) -&gt; bool:</span>
<span class="gi">+        return not isinstance(self.linter.config.valid_magic_values, tuple)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_constants_comparison(self, node: nodes.Compare) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Magic values in any side of the comparison should be avoided,
<span class="w"> </span>        Detects comparisons that `comparison-of-constants` core checker cannot detect.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        const_operands = []</span>
<span class="gi">+        LEFT_OPERAND = 0</span>
<span class="gi">+        RIGHT_OPERAND = 1</span>
<span class="gi">+</span>
<span class="gi">+        left_operand = node.left</span>
<span class="gi">+        const_operands.append(isinstance(left_operand, nodes.Const))</span>
<span class="gi">+</span>
<span class="gi">+        right_operand = node.ops[0][1]</span>
<span class="gi">+        const_operands.append(isinstance(right_operand, nodes.Const))</span>
<span class="gi">+</span>
<span class="gi">+        if all(const_operands):</span>
<span class="gi">+            # `comparison-of-constants` avoided</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        operand_value = None</span>
<span class="gi">+        if const_operands[LEFT_OPERAND] and self._is_magic_value(left_operand):</span>
<span class="gi">+            operand_value = left_operand.as_string()</span>
<span class="gi">+        elif const_operands[RIGHT_OPERAND] and self._is_magic_value(right_operand):</span>
<span class="gi">+            operand_value = right_operand.as_string()</span>
<span class="gi">+        if operand_value is not None:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;magic-value-comparison&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(operand_value),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _is_magic_value(self, node: nodes.Const) -&gt; bool:</span>
<span class="gi">+        return (not utils.is_singleton_const(node)) and (</span>
<span class="gi">+            node.value not in (self.valid_magic_vals)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _parse_rcfile_magic_numbers(parsed_val: str) -&gt; float | str:</span>
<span class="gi">+        parsed_val = parsed_val.encode().decode(&quot;unicode_escape&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if parsed_val.startswith(&quot;&#39;&quot;) and parsed_val.endswith(&quot;&#39;&quot;):</span>
<span class="gi">+            return parsed_val[1:-1]</span>
<span class="gi">+</span>
<span class="gi">+        is_number = regex_match(r&quot;[-+]?\d+(\.0*)?$&quot;, parsed_val)</span>
<span class="gi">+        return float(parsed_val) if is_number else parsed_val</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;magic-comparison&quot;)</span>
<span class="gi">+    def visit_compare(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        self._check_constants_comparison(node)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(MagicValueChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/mccabe.py b/pylint/extensions/mccabe.py</span>
<span class="gh">index 789246edf..9489f24d6 100644</span>
<span class="gd">--- a/pylint/extensions/mccabe.py</span>
<span class="gi">+++ b/pylint/extensions/mccabe.py</span>
<span class="gu">@@ -1,71 +1,212 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Module to add McCabe checker class for pylint.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from typing import TYPE_CHECKING, Any, TypeVar, Union
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="w"> </span>from mccabe import PathGraph as Mccabe_PathGraph
<span class="w"> </span>from mccabe import PathGraphingAstVisitor as Mccabe_PathGraphingAstVisitor
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gd">-_StatementNodes = Union[nodes.Assert, nodes.Assign, nodes.AugAssign, nodes.</span>
<span class="gd">-    Delete, nodes.Raise, nodes.Yield, nodes.Import, nodes.Call, nodes.</span>
<span class="gd">-    Subscript, nodes.Pass, nodes.Continue, nodes.Break, nodes.Global, nodes</span>
<span class="gd">-    .Return, nodes.Expr, nodes.Await]</span>
<span class="gd">-_SubGraphNodes = Union[nodes.If, nodes.Try, nodes.For, nodes.While]</span>
<span class="gd">-_AppendableNodeT = TypeVar(&#39;_AppendableNodeT&#39;, bound=Union[_StatementNodes,</span>
<span class="gd">-    nodes.While, nodes.FunctionDef])</span>

<span class="gi">+_StatementNodes = Union[</span>
<span class="gi">+    nodes.Assert,</span>
<span class="gi">+    nodes.Assign,</span>
<span class="gi">+    nodes.AugAssign,</span>
<span class="gi">+    nodes.Delete,</span>
<span class="gi">+    nodes.Raise,</span>
<span class="gi">+    nodes.Yield,</span>
<span class="gi">+    nodes.Import,</span>
<span class="gi">+    nodes.Call,</span>
<span class="gi">+    nodes.Subscript,</span>
<span class="gi">+    nodes.Pass,</span>
<span class="gi">+    nodes.Continue,</span>
<span class="gi">+    nodes.Break,</span>
<span class="gi">+    nodes.Global,</span>
<span class="gi">+    nodes.Return,</span>
<span class="gi">+    nodes.Expr,</span>
<span class="gi">+    nodes.Await,</span>
<span class="gi">+]</span>

<span class="gd">-class PathGraph(Mccabe_PathGraph):</span>
<span class="gi">+_SubGraphNodes = Union[nodes.If, nodes.Try, nodes.For, nodes.While]</span>
<span class="gi">+_AppendableNodeT = TypeVar(</span>
<span class="gi">+    &quot;_AppendableNodeT&quot;, bound=Union[_StatementNodes, nodes.While, nodes.FunctionDef]</span>
<span class="gi">+)</span>

<span class="gd">-    def __init__(self, node: (_SubGraphNodes | nodes.FunctionDef)):</span>
<span class="gd">-        super().__init__(name=&#39;&#39;, entity=&#39;&#39;, lineno=1)</span>
<span class="gd">-        self.root = node</span>

<span class="gi">+class PathGraph(Mccabe_PathGraph):  # type: ignore[misc]</span>
<span class="gi">+    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):</span>
<span class="gi">+        super().__init__(name=&quot;&quot;, entity=&quot;&quot;, lineno=1)</span>
<span class="gi">+        self.root = node</span>

<span class="gd">-class PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+class PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self._bottom_counter = 0
<span class="w"> </span>        self.graph: PathGraph | None = None
<span class="gi">+</span>
<span class="gi">+    def default(self, node: nodes.NodeNG, *args: Any) -&gt; None:</span>
<span class="gi">+        for child in node.get_children():</span>
<span class="gi">+            self.dispatch(child, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def dispatch(self, node: nodes.NodeNG, *args: Any) -&gt; Any:</span>
<span class="gi">+        self.node = node</span>
<span class="gi">+        klass = node.__class__</span>
<span class="gi">+        meth = self._cache.get(klass)</span>
<span class="gi">+        if meth is None:</span>
<span class="gi">+            class_name = klass.__name__</span>
<span class="gi">+            meth = getattr(self.visitor, &quot;visit&quot; + class_name, self.default)</span>
<span class="gi">+            self._cache[klass] = meth</span>
<span class="gi">+        return meth(node, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def visitFunctionDef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        if self.graph is not None:</span>
<span class="gi">+            # closure</span>
<span class="gi">+            pathnode = self._append_node(node)</span>
<span class="gi">+            self.tail = pathnode</span>
<span class="gi">+            self.dispatch_list(node.body)</span>
<span class="gi">+            bottom = f&quot;{self._bottom_counter}&quot;</span>
<span class="gi">+            self._bottom_counter += 1</span>
<span class="gi">+            self.graph.connect(self.tail, bottom)</span>
<span class="gi">+            self.graph.connect(node, bottom)</span>
<span class="gi">+            self.tail = bottom</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.graph = PathGraph(node)</span>
<span class="gi">+            self.tail = node</span>
<span class="gi">+            self.dispatch_list(node.body)</span>
<span class="gi">+            self.graphs[f&quot;{self.classname}{node.name}&quot;] = self.graph</span>
<span class="gi">+            self.reset()</span>
<span class="gi">+</span>
<span class="w"> </span>    visitAsyncFunctionDef = visitFunctionDef
<span class="gd">-    (visitAssert) = (visitAssign) = (visitAugAssign) = (visitDelete) = (</span>
<span class="gd">-        visitRaise) = (visitYield) = (visitImport) = (visitCall) = (</span>
<span class="gd">-        visitSubscript) = (visitPass) = (visitContinue) = (visitBreak) = (</span>
<span class="gd">-        visitGlobal) = (visitReturn) = (visitExpr) = (visitAwait</span>
<span class="gd">-        ) = visitSimpleStatement</span>
<span class="gi">+</span>
<span class="gi">+    def visitSimpleStatement(self, node: _StatementNodes) -&gt; None:</span>
<span class="gi">+        self._append_node(node)</span>
<span class="gi">+</span>
<span class="gi">+    visitAssert = visitAssign = visitAugAssign = visitDelete = visitRaise = (</span>
<span class="gi">+        visitYield</span>
<span class="gi">+    ) = visitImport = visitCall = visitSubscript = visitPass = visitContinue = (</span>
<span class="gi">+        visitBreak</span>
<span class="gi">+    ) = visitGlobal = visitReturn = visitExpr = visitAwait = visitSimpleStatement</span>
<span class="gi">+</span>
<span class="gi">+    def visitWith(self, node: nodes.With) -&gt; None:</span>
<span class="gi">+        self._append_node(node)</span>
<span class="gi">+        self.dispatch_list(node.body)</span>
<span class="gi">+</span>
<span class="w"> </span>    visitAsyncWith = visitWith

<span class="gd">-    def _subgraph(self, node: _SubGraphNodes, name: str, extra_blocks:</span>
<span class="gd">-        Sequence[nodes.ExceptHandler]=()) -&gt;None:</span>
<span class="gi">+    def _append_node(self, node: _AppendableNodeT) -&gt; _AppendableNodeT | None:</span>
<span class="gi">+        if not self.tail or not self.graph:</span>
<span class="gi">+            return None</span>
<span class="gi">+        self.graph.connect(self.tail, node)</span>
<span class="gi">+        self.tail = node</span>
<span class="gi">+        return node</span>
<span class="gi">+</span>
<span class="gi">+    def _subgraph(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: _SubGraphNodes,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        extra_blocks: Sequence[nodes.ExceptHandler] = (),</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the subgraphs representing any `if` and `for` statements.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.graph is None:</span>
<span class="gi">+            # global loop</span>
<span class="gi">+            self.graph = PathGraph(node)</span>
<span class="gi">+            self._subgraph_parse(node, node, extra_blocks)</span>
<span class="gi">+            self.graphs[f&quot;{self.classname}{name}&quot;] = self.graph</span>
<span class="gi">+            self.reset()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._append_node(node)</span>
<span class="gi">+            self._subgraph_parse(node, node, extra_blocks)</span>

<span class="gd">-    def _subgraph_parse(self, node: _SubGraphNodes, pathnode:</span>
<span class="gd">-        _SubGraphNodes, extra_blocks: Sequence[nodes.ExceptHandler]) -&gt;None:</span>
<span class="gi">+    def _subgraph_parse(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: _SubGraphNodes,</span>
<span class="gi">+        pathnode: _SubGraphNodes,</span>
<span class="gi">+        extra_blocks: Sequence[nodes.ExceptHandler],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the body and any `else` block of `if` and `for` statements.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        loose_ends = []</span>
<span class="gi">+        self.tail = node</span>
<span class="gi">+        self.dispatch_list(node.body)</span>
<span class="gi">+        loose_ends.append(self.tail)</span>
<span class="gi">+        for extra in extra_blocks:</span>
<span class="gi">+            self.tail = node</span>
<span class="gi">+            self.dispatch_list(extra.body)</span>
<span class="gi">+            loose_ends.append(self.tail)</span>
<span class="gi">+        if node.orelse:</span>
<span class="gi">+            self.tail = node</span>
<span class="gi">+            self.dispatch_list(node.orelse)</span>
<span class="gi">+            loose_ends.append(self.tail)</span>
<span class="gi">+        else:</span>
<span class="gi">+            loose_ends.append(node)</span>
<span class="gi">+        if node and self.graph:</span>
<span class="gi">+            bottom = f&quot;{self._bottom_counter}&quot;</span>
<span class="gi">+            self._bottom_counter += 1</span>
<span class="gi">+            for end in loose_ends:</span>
<span class="gi">+                self.graph.connect(end, bottom)</span>
<span class="gi">+            self.tail = bottom</span>


<span class="w"> </span>class McCabeMethodChecker(checkers.BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Checks McCabe complexity cyclomatic threshold in methods and functions
<span class="w"> </span>    to validate a too complex code.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;design&#39;</span>
<span class="gd">-    msgs = {&#39;R1260&#39;: (&#39;%s is too complex. The McCabe rating is %d&#39;,</span>
<span class="gd">-        &#39;too-complex&#39;,</span>
<span class="gd">-        &#39;Used when a method or function is too complex based on McCabe Complexity Cyclomatic&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-    options = (&#39;max-complexity&#39;, {&#39;default&#39;: 10, &#39;type&#39;: &#39;int&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;int&gt;&#39;, &#39;help&#39;: &#39;McCabe complexity cyclomatic threshold&#39;}),</span>
<span class="gd">-</span>
<span class="gd">-    @only_required_for_messages(&#39;too-complex&#39;)</span>
<span class="gd">-    def visit_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;design&quot;</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R1260&quot;: (</span>
<span class="gi">+            &quot;%s is too complex. The McCabe rating is %d&quot;,</span>
<span class="gi">+            &quot;too-complex&quot;,</span>
<span class="gi">+            &quot;Used when a method or function is too complex based on &quot;</span>
<span class="gi">+            &quot;McCabe Complexity Cyclomatic&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;max-complexity&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 10,</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;int&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;McCabe complexity cyclomatic threshold&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;too-complex&quot;)</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Module node to check too complex rating and
<span class="w"> </span>        add message if is greater than max_complexity stored from options.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        visitor = PathGraphingAstVisitor()</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            visitor.preorder(child, visitor)</span>
<span class="gi">+        for graph in visitor.graphs.values():</span>
<span class="gi">+            complexity = graph.complexity()</span>
<span class="gi">+            node = graph.root</span>
<span class="gi">+            if hasattr(node, &quot;name&quot;):</span>
<span class="gi">+                node_name = f&quot;&#39;{node.name}&#39;&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                node_name = f&quot;This &#39;{node.__class__.__name__.lower()}&#39;&quot;</span>
<span class="gi">+            if complexity &lt;= self.linter.config.max_complexity:</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;too-complex&quot;, node=node, confidence=HIGH, args=(node_name, complexity)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(McCabeMethodChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/no_self_use.py b/pylint/extensions/no_self_use.py</span>
<span class="gh">index 2f2372c39..28a6620a8 100644</span>
<span class="gd">--- a/pylint/extensions/no_self_use.py</span>
<span class="gi">+++ b/pylint/extensions/no_self_use.py</span>
<span class="gu">@@ -1,40 +1,111 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="gd">-from pylint.checkers.utils import PYMETHODS, decorated_with_property, is_overload_stub, is_protocol_class, overrides_a_method</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    PYMETHODS,</span>
<span class="gi">+    decorated_with_property,</span>
<span class="gi">+    is_overload_stub,</span>
<span class="gi">+    is_protocol_class,</span>
<span class="gi">+    overrides_a_method,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.interfaces import INFERENCE
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter


<span class="w"> </span>class NoSelfUseChecker(BaseChecker):
<span class="gd">-    name = &#39;no_self_use&#39;</span>
<span class="gd">-    msgs = {&#39;R6301&#39;: (&#39;Method could be a function&#39;, &#39;no-self-use&#39;,</span>
<span class="gd">-        &quot;Used when a method doesn&#39;t use its bound instance, and so could be written as a function.&quot;</span>
<span class="gd">-        , {&#39;old_names&#39;: [(&#39;R0201&#39;, &#39;old-no-self-use&#39;)]})}</span>
<span class="gi">+    name = &quot;no_self_use&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R6301&quot;: (</span>
<span class="gi">+            &quot;Method could be a function&quot;,</span>
<span class="gi">+            &quot;no-self-use&quot;,</span>
<span class="gi">+            &quot;Used when a method doesn&#39;t use its bound instance, and so could &quot;</span>
<span class="gi">+            &quot;be written as a function.&quot;,</span>
<span class="gi">+            {&quot;old_names&quot;: [(&quot;R0201&quot;, &quot;old-no-self-use&quot;)]},</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>

<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="w"> </span>        self._first_attrs: list[str | None] = []
<span class="w"> </span>        self._meth_could_be_func: bool | None = None

<span class="gd">-    def visit_name(self, node: nodes.Name) -&gt;None:</span>
<span class="gi">+    def visit_name(self, node: nodes.Name) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the name handle an access to a class member
<span class="w"> </span>        if so, register it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._first_attrs and (</span>
<span class="gi">+            node.name == self._first_attrs[-1] or not self._first_attrs[-1]</span>
<span class="gi">+        ):</span>
<span class="gi">+            self._meth_could_be_func = False</span>
<span class="gi">+</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="gi">+        if not node.is_method():</span>
<span class="gi">+            return</span>
<span class="gi">+        self._meth_could_be_func = True</span>
<span class="gi">+        self._check_first_arg_for_type(node)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_asyncfunctiondef = visit_functiondef

<span class="gd">-    def _check_first_arg_for_type(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    def _check_first_arg_for_type(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check the name of first argument.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # pylint: disable=duplicate-code</span>
<span class="gi">+        if node.args.posonlyargs:</span>
<span class="gi">+            first_arg = node.args.posonlyargs[0].name</span>
<span class="gi">+        elif node.args.args:</span>
<span class="gi">+            first_arg = node.argnames()[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            first_arg = None</span>
<span class="gi">+        self._first_attrs.append(first_arg)</span>
<span class="gi">+        # static method</span>
<span class="gi">+        if node.type == &quot;staticmethod&quot;:</span>
<span class="gi">+            self._first_attrs[-1] = None</span>

<span class="gd">-    def leave_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+    def leave_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;On method node, check if this method couldn&#39;t be a function.

<span class="w"> </span>        ignore class, static and abstract methods, initializer,
<span class="w"> </span>        methods overridden from a parent class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.is_method():</span>
<span class="gi">+            first = self._first_attrs.pop()</span>
<span class="gi">+            if first is None:</span>
<span class="gi">+                return</span>
<span class="gi">+            class_node = node.parent.frame()</span>
<span class="gi">+            if (</span>
<span class="gi">+                self._meth_could_be_func</span>
<span class="gi">+                and node.type == &quot;method&quot;</span>
<span class="gi">+                and node.name not in PYMETHODS</span>
<span class="gi">+                and not (</span>
<span class="gi">+                    node.is_abstract()</span>
<span class="gi">+                    or overrides_a_method(class_node, node.name)</span>
<span class="gi">+                    or decorated_with_property(node)</span>
<span class="gi">+                    or _has_bare_super_call(node)</span>
<span class="gi">+                    or is_protocol_class(class_node)</span>
<span class="gi">+                    or is_overload_stub(node)</span>
<span class="gi">+                )</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;no-self-use&quot;, node=node, confidence=INFERENCE)</span>
<span class="gi">+</span>
<span class="w"> </span>    leave_asyncfunctiondef = leave_functiondef
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _has_bare_super_call(fundef_node: nodes.FunctionDef) -&gt; bool:</span>
<span class="gi">+    for call in fundef_node.nodes_of_class(nodes.Call):</span>
<span class="gi">+        func = call.func</span>
<span class="gi">+        if isinstance(func, nodes.Name) and func.name == &quot;super&quot; and not call.args:</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(NoSelfUseChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/overlapping_exceptions.py b/pylint/extensions/overlapping_exceptions.py</span>
<span class="gh">index 518cd8c09..8d35e4ce3 100644</span>
<span class="gd">--- a/pylint/extensions/overlapping_exceptions.py</span>
<span class="gi">+++ b/pylint/extensions/overlapping_exceptions.py</span>
<span class="gu">@@ -1,11 +1,20 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Looks for overlapping exceptions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes, util
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.checkers.exceptions import _annotated_unpack_infer
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -16,12 +25,66 @@ class OverlappingExceptionsChecker(checkers.BaseChecker):</span>

<span class="w"> </span>    (i.e. overlapping).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;overlap-except&#39;</span>
<span class="gd">-    msgs = {&#39;W0714&#39;: (&#39;Overlapping exceptions (%s)&#39;, &#39;overlapping-except&#39;,</span>
<span class="gd">-        &#39;Used when exceptions in handler overlap or are identical&#39;)}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;overlap-except&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W0714&quot;: (</span>
<span class="gi">+            &quot;Overlapping exceptions (%s)&quot;,</span>
<span class="gi">+            &quot;overlapping-except&quot;,</span>
<span class="gi">+            &quot;Used when exceptions in handler overlap or are identical&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="w"> </span>    options = ()

<span class="gd">-    @utils.only_required_for_messages(&#39;overlapping-except&#39;)</span>
<span class="gd">-    def visit_try(self, node: nodes.Try) -&gt;None:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;overlapping-except&quot;)</span>
<span class="gi">+    def visit_try(self, node: nodes.Try) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for empty except.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for handler in node.handlers:</span>
<span class="gi">+            if handler.type is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if isinstance(handler.type, astroid.BoolOp):</span>
<span class="gi">+                continue</span>
<span class="gi">+            try:</span>
<span class="gi">+                excs = list(_annotated_unpack_infer(handler.type))</span>
<span class="gi">+            except astroid.InferenceError:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            handled_in_clause: list[tuple[Any, Any]] = []</span>
<span class="gi">+            for part, exc in excs:</span>
<span class="gi">+                if isinstance(exc, util.UninferableBase):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if isinstance(exc, astroid.Instance) and utils.inherit_from_std_ex(exc):</span>
<span class="gi">+                    exc = exc._proxied</span>
<span class="gi">+</span>
<span class="gi">+                if not isinstance(exc, astroid.ClassDef):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                exc_ancestors = [</span>
<span class="gi">+                    anc for anc in exc.ancestors() if isinstance(anc, astroid.ClassDef)</span>
<span class="gi">+                ]</span>
<span class="gi">+</span>
<span class="gi">+                for prev_part, prev_exc in handled_in_clause:</span>
<span class="gi">+                    prev_exc_ancestors = [</span>
<span class="gi">+                        anc</span>
<span class="gi">+                        for anc in prev_exc.ancestors()</span>
<span class="gi">+                        if isinstance(anc, astroid.ClassDef)</span>
<span class="gi">+                    ]</span>
<span class="gi">+                    if exc == prev_exc:</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;overlapping-except&quot;,</span>
<span class="gi">+                            node=handler.type,</span>
<span class="gi">+                            args=f&quot;{prev_part.as_string()} and {part.as_string()} are the same&quot;,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    elif prev_exc in exc_ancestors or exc in prev_exc_ancestors:</span>
<span class="gi">+                        ancestor = part if exc in prev_exc_ancestors else prev_part</span>
<span class="gi">+                        descendant = part if prev_exc in exc_ancestors else prev_part</span>
<span class="gi">+                        self.add_message(</span>
<span class="gi">+                            &quot;overlapping-except&quot;,</span>
<span class="gi">+                            node=handler.type,</span>
<span class="gi">+                            args=f&quot;{ancestor.as_string()} is an ancestor class of {descendant.as_string()}&quot;,</span>
<span class="gi">+                        )</span>
<span class="gi">+                handled_in_clause += [(part, exc)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(OverlappingExceptionsChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/private_import.py b/pylint/extensions/private_import.py</span>
<span class="gh">index 3390b4be5..962bfe1f1 100644</span>
<span class="gd">--- a/pylint/extensions/private_import.py</span>
<span class="gi">+++ b/pylint/extensions/private_import.py</span>
<span class="gu">@@ -1,73 +1,264 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Check for imports on private external modules and names.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker, utils
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter


<span class="w"> </span>class PrivateImportChecker(BaseChecker):
<span class="gd">-    name = &#39;import-private-name&#39;</span>
<span class="gd">-    msgs = {&#39;C2701&#39;: (&#39;Imported private %s (%s)&#39;, &#39;import-private-name&#39;,</span>
<span class="gd">-        &#39;Used when a private module or object prefixed with _ is imported. PEP8 guidance on Naming Conventions states that public attributes with leading underscores should be considered private.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+    name = &quot;import-private-name&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;C2701&quot;: (</span>
<span class="gi">+            &quot;Imported private %s (%s)&quot;,</span>
<span class="gi">+            &quot;import-private-name&quot;,</span>
<span class="gi">+            &quot;Used when a private module or object prefixed with _ is imported. &quot;</span>
<span class="gi">+            &quot;PEP8 guidance on Naming Conventions states that public attributes with &quot;</span>
<span class="gi">+            &quot;leading underscores should be considered private.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>

<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        BaseChecker.__init__(self, linter)
<span class="gi">+</span>
<span class="gi">+        # A mapping of private names used as a type annotation to whether it is an acceptable import</span>
<span class="w"> </span>        self.all_used_type_annotations: dict[str, bool] = {}
<span class="w"> </span>        self.populated_annotations = False

<span class="gd">-    def _get_private_imports(self, names: list[str]) -&gt;list[str]:</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;import-private-name&quot;)</span>
<span class="gi">+    def visit_import(self, node: nodes.Import) -&gt; None:</span>
<span class="gi">+        if utils.in_type_checking_block(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        names = [name[0] for name in node.names]</span>
<span class="gi">+        private_names = self._get_private_imports(names)</span>
<span class="gi">+        private_names = self._get_type_annotation_names(node, private_names)</span>
<span class="gi">+        if private_names:</span>
<span class="gi">+            imported_identifier = &quot;modules&quot; if len(private_names) &gt; 1 else &quot;module&quot;</span>
<span class="gi">+            private_name_string = &quot;, &quot;.join(private_names)</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;import-private-name&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(imported_identifier, private_name_string),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;import-private-name&quot;)</span>
<span class="gi">+    def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="gi">+        if utils.in_type_checking_block(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        # Only check imported names if the module is external</span>
<span class="gi">+        if self.same_root_dir(node, node.modname):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        names = [n[0] for n in node.names]</span>
<span class="gi">+</span>
<span class="gi">+        # Check the imported objects first. If they are all valid type annotations,</span>
<span class="gi">+        # the package can be private</span>
<span class="gi">+        private_names = self._get_type_annotation_names(node, names)</span>
<span class="gi">+        if not private_names:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # There are invalid imported objects, so check the name of the package</span>
<span class="gi">+        private_module_imports = self._get_private_imports([node.modname])</span>
<span class="gi">+        private_module_imports = self._get_type_annotation_names(</span>
<span class="gi">+            node, private_module_imports</span>
<span class="gi">+        )</span>
<span class="gi">+        if private_module_imports:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;import-private-name&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(&quot;module&quot;, private_module_imports[0]),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+            return  # Do not emit messages on the objects if the package is private</span>
<span class="gi">+</span>
<span class="gi">+        private_names = self._get_private_imports(private_names)</span>
<span class="gi">+</span>
<span class="gi">+        if private_names:</span>
<span class="gi">+            imported_identifier = &quot;objects&quot; if len(private_names) &gt; 1 else &quot;object&quot;</span>
<span class="gi">+            private_name_string = &quot;, &quot;.join(private_names)</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;import-private-name&quot;,</span>
<span class="gi">+                node=node,</span>
<span class="gi">+                args=(imported_identifier, private_name_string),</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_private_imports(self, names: list[str]) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the private names from input names by a simple string check.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [name for name in names if self._name_is_private(name)]</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _name_is_private(name: str) -&gt;bool:</span>
<span class="gi">+    def _name_is_private(name: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns true if the name exists, starts with `_`, and if len(name) &gt; 4
<span class="w"> </span>        it is not a dunder, i.e. it does not begin and end with two underscores.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            bool(name)</span>
<span class="gi">+            and name[0] == &quot;_&quot;</span>
<span class="gi">+            and (len(name) &lt;= 4 or name[1] != &quot;_&quot; or name[-2:] != &quot;__&quot;)</span>
<span class="gi">+        )</span>

<span class="gd">-    def _get_type_annotation_names(self, node: (nodes.Import | nodes.</span>
<span class="gd">-        ImportFrom), names: list[str]) -&gt;list[str]:</span>
<span class="gi">+    def _get_type_annotation_names(</span>
<span class="gi">+        self, node: nodes.Import | nodes.ImportFrom, names: list[str]</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Removes from names any names that are used as type annotations with no other
<span class="w"> </span>        illegal usages.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if names and not self.populated_annotations:</span>
<span class="gi">+            self._populate_type_annotations(node.root(), self.all_used_type_annotations)</span>
<span class="gi">+            self.populated_annotations = True</span>
<span class="gi">+</span>
<span class="gi">+        return [</span>
<span class="gi">+            n</span>
<span class="gi">+            for n in names</span>
<span class="gi">+            if n not in self.all_used_type_annotations</span>
<span class="gi">+            or (</span>
<span class="gi">+                n in self.all_used_type_annotations</span>
<span class="gi">+                and not self.all_used_type_annotations[n]</span>
<span class="gi">+            )</span>
<span class="gi">+        ]</span>

<span class="gd">-    def _populate_type_annotations(self, node: nodes.LocalsDictNodeNG,</span>
<span class="gd">-        all_used_type_annotations: dict[str, bool]) -&gt;None:</span>
<span class="gi">+    def _populate_type_annotations(</span>
<span class="gi">+        self, node: nodes.LocalsDictNodeNG, all_used_type_annotations: dict[str, bool]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds to `all_used_type_annotations` all names ever used as a type annotation
<span class="w"> </span>        in the node&#39;s (nested) scopes and whether they are only used as annotation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name in node.locals:</span>
<span class="gi">+            # If we find a private type annotation, make sure we do not mask illegal usages</span>
<span class="gi">+            private_name = None</span>
<span class="gi">+            # All the assignments using this variable that we might have to check for</span>
<span class="gi">+            # illegal usages later</span>
<span class="gi">+            name_assignments = []</span>
<span class="gi">+            for usage_node in node.locals[name]:</span>
<span class="gi">+                if isinstance(usage_node, nodes.AssignName) and isinstance(</span>
<span class="gi">+                    usage_node.parent, (nodes.AnnAssign, nodes.Assign)</span>
<span class="gi">+                ):</span>
<span class="gi">+                    assign_parent = usage_node.parent</span>
<span class="gi">+                    if isinstance(assign_parent, nodes.AnnAssign):</span>
<span class="gi">+                        name_assignments.append(assign_parent)</span>
<span class="gi">+                        private_name = self._populate_type_annotations_annotation(</span>
<span class="gi">+                            usage_node.parent.annotation, all_used_type_annotations</span>
<span class="gi">+                        )</span>
<span class="gi">+                    elif isinstance(assign_parent, nodes.Assign):</span>
<span class="gi">+                        name_assignments.append(assign_parent)</span>

<span class="gd">-    def _populate_type_annotations_function(self, node: nodes.FunctionDef,</span>
<span class="gd">-        all_used_type_annotations: dict[str, bool]) -&gt;None:</span>
<span class="gi">+                if isinstance(usage_node, nodes.FunctionDef):</span>
<span class="gi">+                    self._populate_type_annotations_function(</span>
<span class="gi">+                        usage_node, all_used_type_annotations</span>
<span class="gi">+                    )</span>
<span class="gi">+                if isinstance(usage_node, nodes.LocalsDictNodeNG):</span>
<span class="gi">+                    self._populate_type_annotations(</span>
<span class="gi">+                        usage_node, all_used_type_annotations</span>
<span class="gi">+                    )</span>
<span class="gi">+            if private_name is not None:</span>
<span class="gi">+                # Found a new private annotation, make sure we are not accessing it elsewhere</span>
<span class="gi">+                all_used_type_annotations[private_name] = (</span>
<span class="gi">+                    self._assignments_call_private_name(name_assignments, private_name)</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def _populate_type_annotations_function(</span>
<span class="gi">+        self, node: nodes.FunctionDef, all_used_type_annotations: dict[str, bool]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds all names used as type annotation in the arguments and return type of
<span class="w"> </span>        the function node into the dict `all_used_type_annotations`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.args and node.args.annotations:</span>
<span class="gi">+            for annotation in node.args.annotations:</span>
<span class="gi">+                self._populate_type_annotations_annotation(</span>
<span class="gi">+                    annotation, all_used_type_annotations</span>
<span class="gi">+                )</span>
<span class="gi">+        if node.returns:</span>
<span class="gi">+            self._populate_type_annotations_annotation(</span>
<span class="gi">+                node.returns, all_used_type_annotations</span>
<span class="gi">+            )</span>

<span class="gd">-    def _populate_type_annotations_annotation(self, node: (nodes.Attribute |</span>
<span class="gd">-        nodes.Subscript | nodes.Name | None), all_used_type_annotations:</span>
<span class="gd">-        dict[str, bool]) -&gt;(str | None):</span>
<span class="gi">+    def _populate_type_annotations_annotation(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Attribute | nodes.Subscript | nodes.Name | None,</span>
<span class="gi">+        all_used_type_annotations: dict[str, bool],</span>
<span class="gi">+    ) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles the possibility of an annotation either being a Name, i.e. just type,
<span class="w"> </span>        or a Subscript e.g. `Optional[type]` or an Attribute, e.g. `pylint.lint.linter`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(node, nodes.Name) and node.name not in all_used_type_annotations:</span>
<span class="gi">+            all_used_type_annotations[node.name] = True</span>
<span class="gi">+            return node.name  # type: ignore[no-any-return]</span>
<span class="gi">+        if isinstance(node, nodes.Subscript):  # e.g. Optional[List[str]]</span>
<span class="gi">+            # slice is the next nested type</span>
<span class="gi">+            self._populate_type_annotations_annotation(</span>
<span class="gi">+                node.slice, all_used_type_annotations</span>
<span class="gi">+            )</span>
<span class="gi">+            # value is the current type name: could be a Name or Attribute</span>
<span class="gi">+            return self._populate_type_annotations_annotation(</span>
<span class="gi">+                node.value, all_used_type_annotations</span>
<span class="gi">+            )</span>
<span class="gi">+        if isinstance(node, nodes.Attribute):</span>
<span class="gi">+            # An attribute is a type like `pylint.lint.pylinter`. node.expr is the next level</span>
<span class="gi">+            # up, could be another attribute</span>
<span class="gi">+            return self._populate_type_annotations_annotation(</span>
<span class="gi">+                node.expr, all_used_type_annotations</span>
<span class="gi">+            )</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _assignments_call_private_name(assignments: list[nodes.AnnAssign |</span>
<span class="gd">-        nodes.Assign], private_name: str) -&gt;bool:</span>
<span class="gi">+    def _assignments_call_private_name(</span>
<span class="gi">+        assignments: list[nodes.AnnAssign | nodes.Assign], private_name: str</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns True if no assignments involve accessing `private_name`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if all(not assignment.value for assignment in assignments):</span>
<span class="gi">+            # Variable annotated but unassigned is not allowed because there may be</span>
<span class="gi">+            # possible illegal access elsewhere</span>
<span class="gi">+            return False</span>
<span class="gi">+        for assignment in assignments:</span>
<span class="gi">+            current_attribute = None</span>
<span class="gi">+            if isinstance(assignment.value, nodes.Call):</span>
<span class="gi">+                current_attribute = assignment.value.func</span>
<span class="gi">+            elif isinstance(assignment.value, nodes.Attribute):</span>
<span class="gi">+                current_attribute = assignment.value</span>
<span class="gi">+            elif isinstance(assignment.value, nodes.Name):</span>
<span class="gi">+                current_attribute = assignment.value.name</span>
<span class="gi">+            if not current_attribute:</span>
<span class="gi">+                continue</span>
<span class="gi">+            while isinstance(current_attribute, (nodes.Attribute, nodes.Call)):</span>
<span class="gi">+                if isinstance(current_attribute, nodes.Call):</span>
<span class="gi">+                    current_attribute = current_attribute.func</span>
<span class="gi">+                if not isinstance(current_attribute, nodes.Name):</span>
<span class="gi">+                    current_attribute = current_attribute.expr</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(current_attribute, nodes.Name)</span>
<span class="gi">+                and current_attribute.name == private_name</span>
<span class="gi">+            ):</span>
<span class="gi">+                return False</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def same_root_dir(node: (nodes.Import | nodes.ImportFrom),</span>
<span class="gd">-        import_mod_name: str) -&gt;bool:</span>
<span class="gi">+    def same_root_dir(</span>
<span class="gi">+        node: nodes.Import | nodes.ImportFrom, import_mod_name: str</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Does the node&#39;s file&#39;s path contain the base name of `import_mod_name`?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not import_mod_name:  # from . import ...</span>
<span class="gi">+            return True</span>
<span class="gi">+        if node.level:  # from .foo import ..., from ..bar import ...</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        base_import_package = import_mod_name.split(&quot;.&quot;)[0]</span>
<span class="gi">+</span>
<span class="gi">+        return base_import_package in Path(node.root().file).parent.parts</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(PrivateImportChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/redefined_loop_name.py b/pylint/extensions/redefined_loop_name.py</span>
<span class="gh">index 4ab31da68..d03b80be3 100644</span>
<span class="gd">--- a/pylint/extensions/redefined_loop_name.py</span>
<span class="gi">+++ b/pylint/extensions/redefined_loop_name.py</span>
<span class="gu">@@ -1,6 +1,13 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Optional checker to warn when loop variables are overwritten in the loop&#39;s body.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.checkers import utils
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="gu">@@ -8,12 +15,74 @@ from pylint.lint import PyLinter</span>


<span class="w"> </span>class RedefinedLoopNameChecker(checkers.BaseChecker):
<span class="gd">-    name = &#39;redefined-loop-name&#39;</span>
<span class="gd">-    msgs = {&#39;W2901&#39;: (&#39;Redefining %r from loop (line %s)&#39;,</span>
<span class="gd">-        &#39;redefined-loop-name&#39;,</span>
<span class="gd">-        &#39;Used when a loop variable is overwritten in the loop body.&#39;)}</span>
<span class="gi">+    name = &quot;redefined-loop-name&quot;</span>
<span class="gi">+</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W2901&quot;: (</span>
<span class="gi">+            &quot;Redefining %r from loop (line %s)&quot;,</span>
<span class="gi">+            &quot;redefined-loop-name&quot;,</span>
<span class="gi">+            &quot;Used when a loop variable is overwritten in the loop body.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>

<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        super().__init__(linter)
<span class="gd">-        self._loop_variables: list[tuple[nodes.For, list[str], nodes.</span>
<span class="gd">-            LocalsDictNodeNG]] = []</span>
<span class="gi">+        self._loop_variables: list[</span>
<span class="gi">+            tuple[nodes.For, list[str], nodes.LocalsDictNodeNG]</span>
<span class="gi">+        ] = []</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;redefined-loop-name&quot;)</span>
<span class="gi">+    def visit_assignname(self, node: nodes.AssignName) -&gt; None:</span>
<span class="gi">+        assign_type = node.assign_type()</span>
<span class="gi">+        if not isinstance(assign_type, (nodes.Assign, nodes.AugAssign)):</span>
<span class="gi">+            return</span>
<span class="gi">+        node_scope = node.scope()</span>
<span class="gi">+        for outer_for, outer_variables, outer_for_scope in self._loop_variables:</span>
<span class="gi">+            if node_scope is not outer_for_scope:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if node.name in outer_variables and not utils.in_for_else_branch(</span>
<span class="gi">+                outer_for, node</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;redefined-loop-name&quot;,</span>
<span class="gi">+                    args=(node.name, outer_for.fromlineno),</span>
<span class="gi">+                    node=node,</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;redefined-loop-name&quot;)</span>
<span class="gi">+    def visit_for(self, node: nodes.For) -&gt; None:</span>
<span class="gi">+        assigned_to = [a.name for a in node.target.nodes_of_class(nodes.AssignName)]</span>
<span class="gi">+        # Only check variables that are used</span>
<span class="gi">+        assigned_to = [</span>
<span class="gi">+            var</span>
<span class="gi">+            for var in assigned_to</span>
<span class="gi">+            if not self.linter.config.dummy_variables_rgx.match(var)</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        node_scope = node.scope()</span>
<span class="gi">+        for variable in assigned_to:</span>
<span class="gi">+            for outer_for, outer_variables, outer_for_scope in self._loop_variables:</span>
<span class="gi">+                if node_scope is not outer_for_scope:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if variable in outer_variables and not utils.in_for_else_branch(</span>
<span class="gi">+                    outer_for, node</span>
<span class="gi">+                ):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;redefined-loop-name&quot;,</span>
<span class="gi">+                        args=(variable, outer_for.fromlineno),</span>
<span class="gi">+                        node=node,</span>
<span class="gi">+                        confidence=HIGH,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        self._loop_variables.append((node, assigned_to, node.scope()))</span>
<span class="gi">+</span>
<span class="gi">+    @utils.only_required_for_messages(&quot;redefined-loop-name&quot;)</span>
<span class="gi">+    def leave_for(self, node: nodes.For) -&gt; None:  # pylint: disable=unused-argument</span>
<span class="gi">+        self._loop_variables.pop()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(RedefinedLoopNameChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/redefined_variable_type.py b/pylint/extensions/redefined_variable_type.py</span>
<span class="gh">index 12432d681..ba5af3136 100644</span>
<span class="gd">--- a/pylint/extensions/redefined_variable_type.py</span>
<span class="gi">+++ b/pylint/extensions/redefined_variable_type.py</span>
<span class="gu">@@ -1,8 +1,16 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import is_none, node_type, only_required_for_messages
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -20,10 +28,81 @@ class MultipleTypesChecker(BaseChecker):</span>
<span class="w"> </span>      ifexpr, etc. Also, it would be great to have support for inference on
<span class="w"> </span>      str.split()
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;multiple_types&#39;</span>
<span class="gd">-    msgs = {&#39;R0204&#39;: (&#39;Redefinition of %s type from %s to %s&#39;,</span>
<span class="gd">-        &#39;redefined-variable-type&#39;,</span>
<span class="gd">-        &#39;Used when the type of a variable changes inside a method or a function.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;multiple_types&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R0204&quot;: (</span>
<span class="gi">+            &quot;Redefinition of %s type from %s to %s&quot;,</span>
<span class="gi">+            &quot;redefined-variable-type&quot;,</span>
<span class="gi">+            &quot;Used when the type of a variable changes inside a &quot;</span>
<span class="gi">+            &quot;method or a function.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def visit_classdef(self, _: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        self._assigns.append({})</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;redefined-variable-type&quot;)</span>
<span class="gi">+    def leave_classdef(self, _: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        self._check_and_add_messages()</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_functiondef = visit_asyncfunctiondef = visit_classdef
<span class="w"> </span>    leave_functiondef = leave_asyncfunctiondef = leave_module = leave_classdef
<span class="gi">+</span>
<span class="gi">+    def visit_module(self, _: nodes.Module) -&gt; None:</span>
<span class="gi">+        self._assigns: list[dict[str, list[tuple[nodes.Assign, str]]]] = [{}]</span>
<span class="gi">+</span>
<span class="gi">+    def _check_and_add_messages(self) -&gt; None:</span>
<span class="gi">+        assigns = self._assigns.pop()</span>
<span class="gi">+        for name, args in assigns.items():</span>
<span class="gi">+            if len(args) &lt;= 1:</span>
<span class="gi">+                continue</span>
<span class="gi">+            orig_node, orig_type = args[0]</span>
<span class="gi">+            # Check if there is a type in the following nodes that would be</span>
<span class="gi">+            # different from orig_type.</span>
<span class="gi">+            for redef_node, redef_type in args[1:]:</span>
<span class="gi">+                if redef_type == orig_type:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # if a variable is defined to several types in an if node,</span>
<span class="gi">+                # this is not actually redefining.</span>
<span class="gi">+                orig_parent = orig_node.parent</span>
<span class="gi">+                redef_parent = redef_node.parent</span>
<span class="gi">+                if isinstance(orig_parent, nodes.If):</span>
<span class="gi">+                    if orig_parent == redef_parent:</span>
<span class="gi">+                        if (</span>
<span class="gi">+                            redef_node in orig_parent.orelse</span>
<span class="gi">+                            and orig_node not in orig_parent.orelse</span>
<span class="gi">+                        ):</span>
<span class="gi">+                            orig_node, orig_type = redef_node, redef_type</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    elif isinstance(</span>
<span class="gi">+                        redef_parent, nodes.If</span>
<span class="gi">+                    ) and redef_parent in orig_parent.nodes_of_class(nodes.If):</span>
<span class="gi">+                        orig_node, orig_type = redef_node, redef_type</span>
<span class="gi">+                        continue</span>
<span class="gi">+                orig_type = orig_type.replace(&quot;builtins.&quot;, &quot;&quot;)</span>
<span class="gi">+                redef_type = redef_type.replace(&quot;builtins.&quot;, &quot;&quot;)</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;redefined-variable-type&quot;,</span>
<span class="gi">+                    node=redef_node,</span>
<span class="gi">+                    args=(name, orig_type, redef_type),</span>
<span class="gi">+                )</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def visit_assign(self, node: nodes.Assign) -&gt; None:</span>
<span class="gi">+        # we don&#39;t handle multiple assignment nor slice assignment</span>
<span class="gi">+        target = node.targets[0]</span>
<span class="gi">+        if isinstance(target, (nodes.Tuple, nodes.Subscript)):</span>
<span class="gi">+            return</span>
<span class="gi">+        # ignore NoneType</span>
<span class="gi">+        if is_none(node):</span>
<span class="gi">+            return</span>
<span class="gi">+        _type = node_type(node.value)</span>
<span class="gi">+        if _type:</span>
<span class="gi">+            self._assigns[-1].setdefault(target.as_string(), []).append(</span>
<span class="gi">+                (node, _type.pytype())</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(MultipleTypesChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/set_membership.py b/pylint/extensions/set_membership.py</span>
<span class="gh">index c38482bbd..b72f5aa18 100644</span>
<span class="gd">--- a/pylint/extensions/set_membership.py</span>
<span class="gi">+++ b/pylint/extensions/set_membership.py</span>
<span class="gu">@@ -1,23 +1,52 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class SetMembershipChecker(BaseChecker):
<span class="gd">-    name = &#39;set_membership&#39;</span>
<span class="gd">-    msgs = {&#39;R6201&#39;: (&#39;Consider using set for membership test&#39;,</span>
<span class="gd">-        &#39;use-set-for-membership&#39;,</span>
<span class="gd">-        &#39;Membership tests are more efficient when performed on a lookup optimized datatype like ``sets``.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+    name = &quot;set_membership&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;R6201&quot;: (</span>
<span class="gi">+            &quot;Consider using set for membership test&quot;,</span>
<span class="gi">+            &quot;use-set-for-membership&quot;,</span>
<span class="gi">+            &quot;Membership tests are more efficient when performed on &quot;</span>
<span class="gi">+            &quot;a lookup optimized datatype like ``sets``.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>

<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize checker instance.&quot;&quot;&quot;
<span class="w"> </span>        super().__init__(linter=linter)

<span class="gd">-    def _check_in_comparison(self, comparator: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+    @only_required_for_messages(&quot;use-set-for-membership&quot;)</span>
<span class="gi">+    def visit_compare(self, node: nodes.Compare) -&gt; None:</span>
<span class="gi">+        for op, comparator in node.ops:</span>
<span class="gi">+            if op == &quot;in&quot;:</span>
<span class="gi">+                self._check_in_comparison(comparator)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_in_comparison(self, comparator: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks for membership comparisons with in-place container objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(comparator, nodes.BaseContainer) or isinstance(</span>
<span class="gi">+            comparator, nodes.Set</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Heuristic - We need to be sure all items in set are hashable</span>
<span class="gi">+        if all(isinstance(item, nodes.Const) for item in comparator.elts):</span>
<span class="gi">+            self.add_message(&quot;use-set-for-membership&quot;, node=comparator)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(SetMembershipChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/typing.py b/pylint/extensions/typing.py</span>
<span class="gh">index 6458902ba..2956465cf 100644</span>
<span class="gd">--- a/pylint/extensions/typing.py</span>
<span class="gi">+++ b/pylint/extensions/typing.py</span>
<span class="gu">@@ -1,11 +1,25 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>import astroid.bases
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="gd">-from pylint.checkers.utils import in_type_checking_block, is_node_in_type_annotation_context, is_postponed_evaluation_enabled, only_required_for_messages, safe_infer</span>
<span class="gi">+from pylint.checkers.utils import (</span>
<span class="gi">+    in_type_checking_block,</span>
<span class="gi">+    is_node_in_type_annotation_context,</span>
<span class="gi">+    is_postponed_evaluation_enabled,</span>
<span class="gi">+    only_required_for_messages,</span>
<span class="gi">+    safe_infer,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.constants import TYPING_NORETURN
<span class="w"> </span>from pylint.interfaces import HIGH, INFERENCE
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter

<span class="gu">@@ -15,48 +29,53 @@ class TypingAlias(NamedTuple):</span>
<span class="w"> </span>    name_collision: bool


<span class="gd">-DEPRECATED_TYPING_ALIASES: dict[str, TypingAlias] = {&#39;typing.Tuple&#39;:</span>
<span class="gd">-    TypingAlias(&#39;tuple&#39;, False), &#39;typing.List&#39;: TypingAlias(&#39;list&#39;, False),</span>
<span class="gd">-    &#39;typing.Dict&#39;: TypingAlias(&#39;dict&#39;, False), &#39;typing.Set&#39;: TypingAlias(</span>
<span class="gd">-    &#39;set&#39;, False), &#39;typing.FrozenSet&#39;: TypingAlias(&#39;frozenset&#39;, False),</span>
<span class="gd">-    &#39;typing.Type&#39;: TypingAlias(&#39;type&#39;, False), &#39;typing.Deque&#39;: TypingAlias(</span>
<span class="gd">-    &#39;collections.deque&#39;, True), &#39;typing.DefaultDict&#39;: TypingAlias(</span>
<span class="gd">-    &#39;collections.defaultdict&#39;, True), &#39;typing.OrderedDict&#39;: TypingAlias(</span>
<span class="gd">-    &#39;collections.OrderedDict&#39;, True), &#39;typing.Counter&#39;: TypingAlias(</span>
<span class="gd">-    &#39;collections.Counter&#39;, True), &#39;typing.ChainMap&#39;: TypingAlias(</span>
<span class="gd">-    &#39;collections.ChainMap&#39;, True), &#39;typing.Awaitable&#39;: TypingAlias(</span>
<span class="gd">-    &#39;collections.abc.Awaitable&#39;, True), &#39;typing.Coroutine&#39;: TypingAlias(</span>
<span class="gd">-    &#39;collections.abc.Coroutine&#39;, True), &#39;typing.AsyncIterable&#39;: TypingAlias</span>
<span class="gd">-    (&#39;collections.abc.AsyncIterable&#39;, True), &#39;typing.AsyncIterator&#39;:</span>
<span class="gd">-    TypingAlias(&#39;collections.abc.AsyncIterator&#39;, True),</span>
<span class="gd">-    &#39;typing.AsyncGenerator&#39;: TypingAlias(&#39;collections.abc.AsyncGenerator&#39;, </span>
<span class="gd">-    True), &#39;typing.Iterable&#39;: TypingAlias(&#39;collections.abc.Iterable&#39;, True),</span>
<span class="gd">-    &#39;typing.Iterator&#39;: TypingAlias(&#39;collections.abc.Iterator&#39;, True),</span>
<span class="gd">-    &#39;typing.Generator&#39;: TypingAlias(&#39;collections.abc.Generator&#39;, True),</span>
<span class="gd">-    &#39;typing.Reversible&#39;: TypingAlias(&#39;collections.abc.Reversible&#39;, True),</span>
<span class="gd">-    &#39;typing.Container&#39;: TypingAlias(&#39;collections.abc.Container&#39;, True),</span>
<span class="gd">-    &#39;typing.Collection&#39;: TypingAlias(&#39;collections.abc.Collection&#39;, True),</span>
<span class="gd">-    &#39;typing.Callable&#39;: TypingAlias(&#39;collections.abc.Callable&#39;, True),</span>
<span class="gd">-    &#39;typing.AbstractSet&#39;: TypingAlias(&#39;collections.abc.Set&#39;, False),</span>
<span class="gd">-    &#39;typing.MutableSet&#39;: TypingAlias(&#39;collections.abc.MutableSet&#39;, True),</span>
<span class="gd">-    &#39;typing.Mapping&#39;: TypingAlias(&#39;collections.abc.Mapping&#39;, True),</span>
<span class="gd">-    &#39;typing.MutableMapping&#39;: TypingAlias(&#39;collections.abc.MutableMapping&#39;, </span>
<span class="gd">-    True), &#39;typing.Sequence&#39;: TypingAlias(&#39;collections.abc.Sequence&#39;, True),</span>
<span class="gd">-    &#39;typing.MutableSequence&#39;: TypingAlias(&#39;collections.abc.MutableSequence&#39;,</span>
<span class="gd">-    True), &#39;typing.ByteString&#39;: TypingAlias(&#39;collections.abc.ByteString&#39;, </span>
<span class="gd">-    True), &#39;typing.MappingView&#39;: TypingAlias(&#39;collections.abc.MappingView&#39;,</span>
<span class="gd">-    True), &#39;typing.KeysView&#39;: TypingAlias(&#39;collections.abc.KeysView&#39;, True),</span>
<span class="gd">-    &#39;typing.ItemsView&#39;: TypingAlias(&#39;collections.abc.ItemsView&#39;, True),</span>
<span class="gd">-    &#39;typing.ValuesView&#39;: TypingAlias(&#39;collections.abc.ValuesView&#39;, True),</span>
<span class="gd">-    &#39;typing.ContextManager&#39;: TypingAlias(</span>
<span class="gd">-    &#39;contextlib.AbstractContextManager&#39;, False),</span>
<span class="gd">-    &#39;typing.AsyncContextManager&#39;: TypingAlias(</span>
<span class="gd">-    &#39;contextlib.AbstractAsyncContextManager&#39;, False), &#39;typing.Pattern&#39;:</span>
<span class="gd">-    TypingAlias(&#39;re.Pattern&#39;, True), &#39;typing.Match&#39;: TypingAlias(&#39;re.Match&#39;,</span>
<span class="gd">-    True), &#39;typing.Hashable&#39;: TypingAlias(&#39;collections.abc.Hashable&#39;, True),</span>
<span class="gd">-    &#39;typing.Sized&#39;: TypingAlias(&#39;collections.abc.Sized&#39;, True)}</span>
<span class="gd">-ALIAS_NAMES = frozenset(key.split(&#39;.&#39;)[1] for key in DEPRECATED_TYPING_ALIASES)</span>
<span class="gd">-UNION_NAMES = &#39;Optional&#39;, &#39;Union&#39;</span>
<span class="gi">+DEPRECATED_TYPING_ALIASES: dict[str, TypingAlias] = {</span>
<span class="gi">+    &quot;typing.Tuple&quot;: TypingAlias(&quot;tuple&quot;, False),</span>
<span class="gi">+    &quot;typing.List&quot;: TypingAlias(&quot;list&quot;, False),</span>
<span class="gi">+    &quot;typing.Dict&quot;: TypingAlias(&quot;dict&quot;, False),</span>
<span class="gi">+    &quot;typing.Set&quot;: TypingAlias(&quot;set&quot;, False),</span>
<span class="gi">+    &quot;typing.FrozenSet&quot;: TypingAlias(&quot;frozenset&quot;, False),</span>
<span class="gi">+    &quot;typing.Type&quot;: TypingAlias(&quot;type&quot;, False),</span>
<span class="gi">+    &quot;typing.Deque&quot;: TypingAlias(&quot;collections.deque&quot;, True),</span>
<span class="gi">+    &quot;typing.DefaultDict&quot;: TypingAlias(&quot;collections.defaultdict&quot;, True),</span>
<span class="gi">+    &quot;typing.OrderedDict&quot;: TypingAlias(&quot;collections.OrderedDict&quot;, True),</span>
<span class="gi">+    &quot;typing.Counter&quot;: TypingAlias(&quot;collections.Counter&quot;, True),</span>
<span class="gi">+    &quot;typing.ChainMap&quot;: TypingAlias(&quot;collections.ChainMap&quot;, True),</span>
<span class="gi">+    &quot;typing.Awaitable&quot;: TypingAlias(&quot;collections.abc.Awaitable&quot;, True),</span>
<span class="gi">+    &quot;typing.Coroutine&quot;: TypingAlias(&quot;collections.abc.Coroutine&quot;, True),</span>
<span class="gi">+    &quot;typing.AsyncIterable&quot;: TypingAlias(&quot;collections.abc.AsyncIterable&quot;, True),</span>
<span class="gi">+    &quot;typing.AsyncIterator&quot;: TypingAlias(&quot;collections.abc.AsyncIterator&quot;, True),</span>
<span class="gi">+    &quot;typing.AsyncGenerator&quot;: TypingAlias(&quot;collections.abc.AsyncGenerator&quot;, True),</span>
<span class="gi">+    &quot;typing.Iterable&quot;: TypingAlias(&quot;collections.abc.Iterable&quot;, True),</span>
<span class="gi">+    &quot;typing.Iterator&quot;: TypingAlias(&quot;collections.abc.Iterator&quot;, True),</span>
<span class="gi">+    &quot;typing.Generator&quot;: TypingAlias(&quot;collections.abc.Generator&quot;, True),</span>
<span class="gi">+    &quot;typing.Reversible&quot;: TypingAlias(&quot;collections.abc.Reversible&quot;, True),</span>
<span class="gi">+    &quot;typing.Container&quot;: TypingAlias(&quot;collections.abc.Container&quot;, True),</span>
<span class="gi">+    &quot;typing.Collection&quot;: TypingAlias(&quot;collections.abc.Collection&quot;, True),</span>
<span class="gi">+    &quot;typing.Callable&quot;: TypingAlias(&quot;collections.abc.Callable&quot;, True),</span>
<span class="gi">+    &quot;typing.AbstractSet&quot;: TypingAlias(&quot;collections.abc.Set&quot;, False),</span>
<span class="gi">+    &quot;typing.MutableSet&quot;: TypingAlias(&quot;collections.abc.MutableSet&quot;, True),</span>
<span class="gi">+    &quot;typing.Mapping&quot;: TypingAlias(&quot;collections.abc.Mapping&quot;, True),</span>
<span class="gi">+    &quot;typing.MutableMapping&quot;: TypingAlias(&quot;collections.abc.MutableMapping&quot;, True),</span>
<span class="gi">+    &quot;typing.Sequence&quot;: TypingAlias(&quot;collections.abc.Sequence&quot;, True),</span>
<span class="gi">+    &quot;typing.MutableSequence&quot;: TypingAlias(&quot;collections.abc.MutableSequence&quot;, True),</span>
<span class="gi">+    &quot;typing.ByteString&quot;: TypingAlias(&quot;collections.abc.ByteString&quot;, True),</span>
<span class="gi">+    &quot;typing.MappingView&quot;: TypingAlias(&quot;collections.abc.MappingView&quot;, True),</span>
<span class="gi">+    &quot;typing.KeysView&quot;: TypingAlias(&quot;collections.abc.KeysView&quot;, True),</span>
<span class="gi">+    &quot;typing.ItemsView&quot;: TypingAlias(&quot;collections.abc.ItemsView&quot;, True),</span>
<span class="gi">+    &quot;typing.ValuesView&quot;: TypingAlias(&quot;collections.abc.ValuesView&quot;, True),</span>
<span class="gi">+    &quot;typing.ContextManager&quot;: TypingAlias(&quot;contextlib.AbstractContextManager&quot;, False),</span>
<span class="gi">+    &quot;typing.AsyncContextManager&quot;: TypingAlias(</span>
<span class="gi">+        &quot;contextlib.AbstractAsyncContextManager&quot;, False</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;typing.Pattern&quot;: TypingAlias(&quot;re.Pattern&quot;, True),</span>
<span class="gi">+    &quot;typing.Match&quot;: TypingAlias(&quot;re.Match&quot;, True),</span>
<span class="gi">+    &quot;typing.Hashable&quot;: TypingAlias(&quot;collections.abc.Hashable&quot;, True),</span>
<span class="gi">+    &quot;typing.Sized&quot;: TypingAlias(&quot;collections.abc.Sized&quot;, True),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+ALIAS_NAMES = frozenset(key.split(&quot;.&quot;)[1] for key in DEPRECATED_TYPING_ALIASES)</span>
<span class="gi">+UNION_NAMES = (&quot;Optional&quot;, &quot;Union&quot;)</span>


<span class="w"> </span>class DeprecatedTypingAliasMsg(NamedTuple):
<span class="gu">@@ -68,44 +87,81 @@ class DeprecatedTypingAliasMsg(NamedTuple):</span>

<span class="w"> </span>class TypingChecker(BaseChecker):
<span class="w"> </span>    &quot;&quot;&quot;Find issue specifically related to type annotations.&quot;&quot;&quot;
<span class="gd">-    name = &#39;typing&#39;</span>
<span class="gd">-    msgs = {&#39;W6001&#39;: (&quot;&#39;%s&#39; is deprecated, use &#39;%s&#39; instead&quot;,</span>
<span class="gd">-        &#39;deprecated-typing-alias&#39;,</span>
<span class="gd">-        &#39;Emitted when a deprecated typing alias is used.&#39;), &#39;R6002&#39;: (</span>
<span class="gd">-        &quot;&#39;%s&#39; will be deprecated with PY39, consider using &#39;%s&#39; instead%s&quot;,</span>
<span class="gd">-        &#39;consider-using-alias&#39;,</span>
<span class="gd">-        &quot;Only emitted if &#39;runtime-typing=no&#39; and a deprecated typing alias is used in a type annotation context in Python 3.7 or 3.8.&quot;</span>
<span class="gd">-        ), &#39;R6003&#39;: (</span>
<span class="gd">-        &quot;Consider using alternative Union syntax instead of &#39;%s&#39;%s&quot;,</span>
<span class="gd">-        &#39;consider-alternative-union-syntax&#39;,</span>
<span class="gd">-        &quot;Emitted when &#39;typing.Union&#39; or &#39;typing.Optional&#39; is used instead of the alternative Union syntax &#39;int | None&#39;.&quot;</span>
<span class="gd">-        ), &#39;E6004&#39;: (</span>
<span class="gd">-        &quot;&#39;NoReturn&#39; inside compound types is broken in 3.7.0 / 3.7.1&quot;,</span>
<span class="gd">-        &#39;broken-noreturn&#39;,</span>
<span class="gd">-        &quot;``typing.NoReturn`` inside compound types is broken in Python 3.7.0 and 3.7.1. If not dependent on runtime introspection, use string annotation instead. E.g. ``Callable[..., &#39;NoReturn&#39;]``. https://bugs.python.org/issue34921&quot;</span>
<span class="gd">-        ), &#39;E6005&#39;: (</span>
<span class="gd">-        &quot;&#39;collections.abc.Callable&#39; inside Optional and Union is broken in 3.9.0 / 3.9.1 (use &#39;typing.Callable&#39; instead)&quot;</span>
<span class="gd">-        , &#39;broken-collections-callable&#39;,</span>
<span class="gd">-        &#39;``collections.abc.Callable`` inside Optional and Union is broken in Python 3.9.0 and 3.9.1. Use ``typing.Callable`` for these cases instead. https://bugs.python.org/issue42965&#39;</span>
<span class="gd">-        ), &#39;R6006&#39;: (</span>
<span class="gd">-        &#39;Type `%s` is used more than once in union type annotation. Remove redundant typehints.&#39;</span>
<span class="gd">-        , &#39;redundant-typehint-argument&#39;,</span>
<span class="gd">-        &#39;Duplicated type arguments will be skipped by `mypy` tool, therefore should be removed to avoid confusion.&#39;</span>
<span class="gd">-        )}</span>
<span class="gd">-    options = (&#39;runtime-typing&#39;, {&#39;default&#39;: True, &#39;type&#39;: &#39;yn&#39;, &#39;metavar&#39;:</span>
<span class="gd">-        &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-        &quot;Set to ``no`` if the app / library does **NOT** need to support runtime introspection of type annotations. If you use type annotations **exclusively** for type checking of an application, you&#39;re probably fine. For libraries, evaluate if some users want to access the type hints at runtime first, e.g., through ``typing.get_type_hints``. Applies to Python versions 3.7 - 3.9&quot;</span>
<span class="gd">-        }),</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;typing&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W6001&quot;: (</span>
<span class="gi">+            &quot;&#39;%s&#39; is deprecated, use &#39;%s&#39; instead&quot;,</span>
<span class="gi">+            &quot;deprecated-typing-alias&quot;,</span>
<span class="gi">+            &quot;Emitted when a deprecated typing alias is used.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R6002&quot;: (</span>
<span class="gi">+            &quot;&#39;%s&#39; will be deprecated with PY39, consider using &#39;%s&#39; instead%s&quot;,</span>
<span class="gi">+            &quot;consider-using-alias&quot;,</span>
<span class="gi">+            &quot;Only emitted if &#39;runtime-typing=no&#39; and a deprecated &quot;</span>
<span class="gi">+            &quot;typing alias is used in a type annotation context in &quot;</span>
<span class="gi">+            &quot;Python 3.7 or 3.8.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R6003&quot;: (</span>
<span class="gi">+            &quot;Consider using alternative Union syntax instead of &#39;%s&#39;%s&quot;,</span>
<span class="gi">+            &quot;consider-alternative-union-syntax&quot;,</span>
<span class="gi">+            &quot;Emitted when &#39;typing.Union&#39; or &#39;typing.Optional&#39; is used &quot;</span>
<span class="gi">+            &quot;instead of the alternative Union syntax &#39;int | None&#39;.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E6004&quot;: (</span>
<span class="gi">+            &quot;&#39;NoReturn&#39; inside compound types is broken in 3.7.0 / 3.7.1&quot;,</span>
<span class="gi">+            &quot;broken-noreturn&quot;,</span>
<span class="gi">+            &quot;``typing.NoReturn`` inside compound types is broken in &quot;</span>
<span class="gi">+            &quot;Python 3.7.0 and 3.7.1. If not dependent on runtime introspection, &quot;</span>
<span class="gi">+            &quot;use string annotation instead. E.g. &quot;</span>
<span class="gi">+            &quot;``Callable[..., &#39;NoReturn&#39;]``. https://bugs.python.org/issue34921&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;E6005&quot;: (</span>
<span class="gi">+            &quot;&#39;collections.abc.Callable&#39; inside Optional and Union is broken in &quot;</span>
<span class="gi">+            &quot;3.9.0 / 3.9.1 (use &#39;typing.Callable&#39; instead)&quot;,</span>
<span class="gi">+            &quot;broken-collections-callable&quot;,</span>
<span class="gi">+            &quot;``collections.abc.Callable`` inside Optional and Union is broken in &quot;</span>
<span class="gi">+            &quot;Python 3.9.0 and 3.9.1. Use ``typing.Callable`` for these cases instead. &quot;</span>
<span class="gi">+            &quot;https://bugs.python.org/issue42965&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+        &quot;R6006&quot;: (</span>
<span class="gi">+            &quot;Type `%s` is used more than once in union type annotation. Remove redundant typehints.&quot;,</span>
<span class="gi">+            &quot;redundant-typehint-argument&quot;,</span>
<span class="gi">+            &quot;Duplicated type arguments will be skipped by `mypy` tool, therefore should be &quot;</span>
<span class="gi">+            &quot;removed to avoid confusion.&quot;,</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+    options = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;runtime-typing&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Set to ``no`` if the app / library does **NOT** need to &quot;</span>
<span class="gi">+                    &quot;support runtime introspection of type annotations. &quot;</span>
<span class="gi">+                    &quot;If you use type annotations **exclusively** for type checking &quot;</span>
<span class="gi">+                    &quot;of an application, you&#39;re probably fine. For libraries, &quot;</span>
<span class="gi">+                    &quot;evaluate if some users want to access the type hints &quot;</span>
<span class="gi">+                    &quot;at runtime first, e.g., through ``typing.get_type_hints``. &quot;</span>
<span class="gi">+                    &quot;Applies to Python versions 3.7 - 3.9&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>    _should_check_typing_alias: bool
<span class="w"> </span>    &quot;&quot;&quot;The use of type aliases (PEP 585) requires Python 3.9
<span class="w"> </span>    or Python 3.7+ with postponed evaluation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _should_check_alternative_union_syntax: bool
<span class="w"> </span>    &quot;&quot;&quot;The use of alternative union syntax (PEP 604) requires Python 3.10
<span class="w"> </span>    or Python 3.7+ with postponed evaluation.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize checker instance.&quot;&quot;&quot;
<span class="w"> </span>        super().__init__(linter=linter)
<span class="w"> </span>        self._found_broken_callable_location: bool = False
<span class="gu">@@ -113,12 +169,140 @@ class TypingChecker(BaseChecker):</span>
<span class="w"> </span>        self._deprecated_typing_alias_msgs: list[DeprecatedTypingAliasMsg] = []
<span class="w"> </span>        self._consider_using_alias_msgs: list[DeprecatedTypingAliasMsg] = []

<span class="gd">-    def _msg_postponed_eval_hint(self, node: nodes.NodeNG) -&gt;str:</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="gi">+        py_version = self.linter.config.py_version</span>
<span class="gi">+        self._py37_plus = py_version &gt;= (3, 7)</span>
<span class="gi">+        self._py39_plus = py_version &gt;= (3, 9)</span>
<span class="gi">+        self._py310_plus = py_version &gt;= (3, 10)</span>
<span class="gi">+</span>
<span class="gi">+        self._should_check_typing_alias = self._py39_plus or (</span>
<span class="gi">+            self._py37_plus and self.linter.config.runtime_typing is False</span>
<span class="gi">+        )</span>
<span class="gi">+        self._should_check_alternative_union_syntax = self._py310_plus or (</span>
<span class="gi">+            self._py37_plus and self.linter.config.runtime_typing is False</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self._should_check_noreturn = py_version &lt; (3, 7, 2)</span>
<span class="gi">+        self._should_check_callable = py_version &lt; (3, 9, 2)</span>
<span class="gi">+</span>
<span class="gi">+    def _msg_postponed_eval_hint(self, node: nodes.NodeNG) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Message hint if postponed evaluation isn&#39;t enabled.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._py310_plus or &quot;annotations&quot; in node.root().future_imports:</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+        return &quot;. Add &#39;from __future__ import annotations&#39; as well&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;deprecated-typing-alias&quot;,</span>
<span class="gi">+        &quot;consider-using-alias&quot;,</span>
<span class="gi">+        &quot;consider-alternative-union-syntax&quot;,</span>
<span class="gi">+        &quot;broken-noreturn&quot;,</span>
<span class="gi">+        &quot;broken-collections-callable&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_name(self, node: nodes.Name) -&gt; None:</span>
<span class="gi">+        if self._should_check_typing_alias and node.name in ALIAS_NAMES:</span>
<span class="gi">+            self._check_for_typing_alias(node)</span>
<span class="gi">+        if self._should_check_alternative_union_syntax and node.name in UNION_NAMES:</span>
<span class="gi">+            self._check_for_alternative_union_syntax(node, node.name)</span>
<span class="gi">+        if self._should_check_noreturn and node.name == &quot;NoReturn&quot;:</span>
<span class="gi">+            self._check_broken_noreturn(node)</span>
<span class="gi">+        if self._should_check_callable and node.name == &quot;Callable&quot;:</span>
<span class="gi">+            self._check_broken_callable(node)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(</span>
<span class="gi">+        &quot;deprecated-typing-alias&quot;,</span>
<span class="gi">+        &quot;consider-using-alias&quot;,</span>
<span class="gi">+        &quot;consider-alternative-union-syntax&quot;,</span>
<span class="gi">+        &quot;broken-noreturn&quot;,</span>
<span class="gi">+        &quot;broken-collections-callable&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    def visit_attribute(self, node: nodes.Attribute) -&gt; None:</span>
<span class="gi">+        if self._should_check_typing_alias and node.attrname in ALIAS_NAMES:</span>
<span class="gi">+            self._check_for_typing_alias(node)</span>
<span class="gi">+        if self._should_check_alternative_union_syntax and node.attrname in UNION_NAMES:</span>
<span class="gi">+            self._check_for_alternative_union_syntax(node, node.attrname)</span>
<span class="gi">+        if self._should_check_noreturn and node.attrname == &quot;NoReturn&quot;:</span>
<span class="gi">+            self._check_broken_noreturn(node)</span>
<span class="gi">+        if self._should_check_callable and node.attrname == &quot;Callable&quot;:</span>
<span class="gi">+            self._check_broken_callable(node)</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;redundant-typehint-argument&quot;)</span>
<span class="gi">+    def visit_annassign(self, node: nodes.AnnAssign) -&gt; None:</span>
<span class="gi">+        annotation = node.annotation</span>
<span class="gi">+        if self._is_deprecated_union_annotation(annotation, &quot;Optional&quot;):</span>
<span class="gi">+            if self._is_optional_none_annotation(annotation):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;redundant-typehint-argument&quot;,</span>
<span class="gi">+                    node=annotation,</span>
<span class="gi">+                    args=&quot;None&quot;,</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+            return</span>
<span class="gi">+        if self._is_deprecated_union_annotation(annotation, &quot;Union&quot;) and isinstance(</span>
<span class="gi">+            annotation.slice, nodes.Tuple</span>
<span class="gi">+        ):</span>
<span class="gi">+            types = annotation.slice.elts</span>
<span class="gi">+        elif self._is_binop_union_annotation(annotation):</span>
<span class="gi">+            types = self._parse_binops_typehints(annotation)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._check_union_types(types, node)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_deprecated_union_annotation(</span>
<span class="gi">+        annotation: nodes.NodeNG, union_name: str</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(annotation, nodes.Subscript)</span>
<span class="gi">+            and isinstance(annotation.value, nodes.Name)</span>
<span class="gi">+            and annotation.value.name == union_name</span>
<span class="gi">+        )</span>

<span class="gd">-    def _check_for_alternative_union_syntax(self, node: (nodes.Name | nodes</span>
<span class="gd">-        .Attribute), name: str) -&gt;None:</span>
<span class="gi">+    def _is_binop_union_annotation(self, annotation: nodes.NodeNG) -&gt; bool:</span>
<span class="gi">+        return self._should_check_alternative_union_syntax and isinstance(</span>
<span class="gi">+            annotation, nodes.BinOp</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _is_optional_none_annotation(annotation: nodes.Subscript) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(annotation.slice, nodes.Const) and annotation.slice.value is None</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_binops_typehints(</span>
<span class="gi">+        self, binop_node: nodes.BinOp, typehints_list: list[nodes.NodeNG] | None = None</span>
<span class="gi">+    ) -&gt; list[nodes.NodeNG]:</span>
<span class="gi">+        typehints_list = typehints_list or []</span>
<span class="gi">+        if isinstance(binop_node.left, nodes.BinOp):</span>
<span class="gi">+            typehints_list.extend(</span>
<span class="gi">+                self._parse_binops_typehints(binop_node.left, typehints_list)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            typehints_list.append(binop_node.left)</span>
<span class="gi">+        typehints_list.append(binop_node.right)</span>
<span class="gi">+        return typehints_list</span>
<span class="gi">+</span>
<span class="gi">+    def _check_union_types(</span>
<span class="gi">+        self, types: list[nodes.NodeNG], annotation: nodes.NodeNG</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        types_set = set()</span>
<span class="gi">+        for typehint in types:</span>
<span class="gi">+            typehint_str = typehint.as_string()</span>
<span class="gi">+            if typehint_str in types_set:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;redundant-typehint-argument&quot;,</span>
<span class="gi">+                    node=annotation,</span>
<span class="gi">+                    args=(typehint_str),</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                types_set.add(typehint_str)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_for_alternative_union_syntax(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Name | nodes.Attribute,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if alternative union syntax could be used.

<span class="w"> </span>        Requires
<span class="gu">@@ -126,10 +310,27 @@ class TypingChecker(BaseChecker):</span>
<span class="w"> </span>        - OR: Python 3.7+ with postponed evaluation in
<span class="w"> </span>              a type annotation context
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred = safe_infer(node)</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(inferred, nodes.FunctionDef)</span>
<span class="gi">+            and inferred.qname() in {&quot;typing.Optional&quot;, &quot;typing.Union&quot;}</span>
<span class="gi">+            or isinstance(inferred, astroid.bases.Instance)</span>
<span class="gi">+            and inferred.qname() == &quot;typing._SpecialForm&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+        if not (self._py310_plus or is_node_in_type_annotation_context(node)):</span>
<span class="gi">+            return</span>
<span class="gi">+        self.add_message(</span>
<span class="gi">+            &quot;consider-alternative-union-syntax&quot;,</span>
<span class="gi">+            node=node,</span>
<span class="gi">+            args=(name, self._msg_postponed_eval_hint(node)),</span>
<span class="gi">+            confidence=INFERENCE,</span>
<span class="gi">+        )</span>

<span class="gd">-    def _check_for_typing_alias(self, node: (nodes.Name | nodes.Attribute)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _check_for_typing_alias(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Name | nodes.Attribute,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if typing alias is deprecated or could be replaced.

<span class="w"> </span>        Requires
<span class="gu">@@ -141,29 +342,163 @@ class TypingChecker(BaseChecker):</span>
<span class="w"> </span>            any name collisions, only ever used in a type annotation
<span class="w"> </span>            context, and can safely be replaced.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred = safe_infer(node)</span>
<span class="gi">+        if not isinstance(inferred, nodes.ClassDef):</span>
<span class="gi">+            return</span>
<span class="gi">+        alias = DEPRECATED_TYPING_ALIASES.get(inferred.qname(), None)</span>
<span class="gi">+        if alias is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self._py39_plus:</span>
<span class="gi">+            if inferred.qname() == &quot;typing.Callable&quot; and self._broken_callable_location(</span>
<span class="gi">+                node</span>
<span class="gi">+            ):</span>
<span class="gi">+                self._found_broken_callable_location = True</span>
<span class="gi">+            self._deprecated_typing_alias_msgs.append(</span>
<span class="gi">+                DeprecatedTypingAliasMsg(</span>
<span class="gi">+                    node,</span>
<span class="gi">+                    inferred.qname(),</span>
<span class="gi">+                    alias.name,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>

<span class="gd">-    @only_required_for_messages(&#39;consider-using-alias&#39;,</span>
<span class="gd">-        &#39;deprecated-typing-alias&#39;)</span>
<span class="gd">-    def leave_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+        # For PY37+, check for type annotation context first</span>
<span class="gi">+        if not is_node_in_type_annotation_context(node) and isinstance(</span>
<span class="gi">+            node.parent, nodes.Subscript</span>
<span class="gi">+        ):</span>
<span class="gi">+            if alias.name_collision is True:</span>
<span class="gi">+                self._alias_name_collisions.add(inferred.qname())</span>
<span class="gi">+            return</span>
<span class="gi">+        self._consider_using_alias_msgs.append(</span>
<span class="gi">+            DeprecatedTypingAliasMsg(</span>
<span class="gi">+                node,</span>
<span class="gi">+                inferred.qname(),</span>
<span class="gi">+                alias.name,</span>
<span class="gi">+                isinstance(node.parent, nodes.Subscript),</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;consider-using-alias&quot;, &quot;deprecated-typing-alias&quot;)</span>
<span class="gi">+    def leave_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;After parsing of module is complete, add messages for
<span class="w"> </span>        &#39;consider-using-alias&#39; check.

<span class="w"> </span>        Make sure results are safe to recommend / collision free.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._py39_plus:</span>
<span class="gi">+            for msg in self._deprecated_typing_alias_msgs:</span>
<span class="gi">+                if (</span>
<span class="gi">+                    self._found_broken_callable_location</span>
<span class="gi">+                    and msg.qname == &quot;typing.Callable&quot;</span>
<span class="gi">+                ):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;deprecated-typing-alias&quot;,</span>
<span class="gi">+                    node=msg.node,</span>
<span class="gi">+                    args=(msg.qname, msg.alias),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        elif self._py37_plus:</span>
<span class="gi">+            msg_future_import = self._msg_postponed_eval_hint(node)</span>
<span class="gi">+            for msg in self._consider_using_alias_msgs:</span>
<span class="gi">+                if msg.qname in self._alias_name_collisions:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;consider-using-alias&quot;,</span>
<span class="gi">+                    node=msg.node,</span>
<span class="gi">+                    args=(</span>
<span class="gi">+                        msg.qname,</span>
<span class="gi">+                        msg.alias,</span>
<span class="gi">+                        msg_future_import if msg.parent_subscript else &quot;&quot;,</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    confidence=INFERENCE,</span>
<span class="gi">+                )</span>

<span class="gd">-    def _check_broken_noreturn(self, node: (nodes.Name | nodes.Attribute)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        # Clear all module cache variables</span>
<span class="gi">+        self._found_broken_callable_location = False</span>
<span class="gi">+        self._deprecated_typing_alias_msgs.clear()</span>
<span class="gi">+        self._alias_name_collisions.clear()</span>
<span class="gi">+        self._consider_using_alias_msgs.clear()</span>
<span class="gi">+</span>
<span class="gi">+    def _check_broken_noreturn(self, node: nodes.Name | nodes.Attribute) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for &#39;NoReturn&#39; inside compound types.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(node.parent, nodes.BaseContainer):</span>
<span class="gi">+            # NoReturn not part of a Union or Callable type</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            in_type_checking_block(node)</span>
<span class="gi">+            or is_postponed_evaluation_enabled(node)</span>
<span class="gi">+            and is_node_in_type_annotation_context(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>

<span class="gd">-    def _check_broken_callable(self, node: (nodes.Name | nodes.Attribute)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        for inferred in node.infer():</span>
<span class="gi">+            # To deal with typing_extensions, don&#39;t use safe_infer</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(inferred, (nodes.FunctionDef, nodes.ClassDef))</span>
<span class="gi">+                and inferred.qname() in TYPING_NORETURN</span>
<span class="gi">+                # In Python 3.7 - 3.8, NoReturn is alias of &#39;_SpecialForm&#39;</span>
<span class="gi">+                or isinstance(inferred, astroid.bases.BaseInstance)</span>
<span class="gi">+                and isinstance(inferred._proxied, nodes.ClassDef)</span>
<span class="gi">+                and inferred._proxied.qname() == &quot;typing._SpecialForm&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                self.add_message(&quot;broken-noreturn&quot;, node=node, confidence=INFERENCE)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def _check_broken_callable(self, node: nodes.Name | nodes.Attribute) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check for &#39;collections.abc.Callable&#39; inside Optional and Union.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        inferred = safe_infer(node)</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(inferred, nodes.ClassDef)</span>
<span class="gi">+            and inferred.qname() == &quot;_collections_abc.Callable&quot;</span>
<span class="gi">+            and self._broken_callable_location(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.add_message(&quot;broken-collections-callable&quot;, node=node, confidence=INFERENCE)</span>

<span class="gd">-    def _broken_callable_location(self, node: (nodes.Name | nodes.Attribute)</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def _broken_callable_location(self, node: nodes.Name | nodes.Attribute) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if node would be a broken location for collections.abc.Callable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if (</span>
<span class="gi">+            in_type_checking_block(node)</span>
<span class="gi">+            or is_postponed_evaluation_enabled(node)</span>
<span class="gi">+            and is_node_in_type_annotation_context(node)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Check first Callable arg is a list of arguments -&gt; Callable[[int], None]</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(node.parent, nodes.Subscript)</span>
<span class="gi">+            and isinstance(node.parent.slice, nodes.Tuple)</span>
<span class="gi">+            and len(node.parent.slice.elts) == 2</span>
<span class="gi">+            and isinstance(node.parent.slice.elts[0], nodes.List)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Check nested inside Optional or Union</span>
<span class="gi">+        parent_subscript = node.parent.parent</span>
<span class="gi">+        if isinstance(parent_subscript, nodes.BaseContainer):</span>
<span class="gi">+            parent_subscript = parent_subscript.parent</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(parent_subscript, nodes.Subscript)</span>
<span class="gi">+            and isinstance(parent_subscript.value, (nodes.Name, nodes.Attribute))</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        inferred_parent = safe_infer(parent_subscript.value)</span>
<span class="gi">+        if not (</span>
<span class="gi">+            isinstance(inferred_parent, nodes.FunctionDef)</span>
<span class="gi">+            and inferred_parent.qname() in {&quot;typing.Optional&quot;, &quot;typing.Union&quot;}</span>
<span class="gi">+            or isinstance(inferred_parent, astroid.bases.Instance)</span>
<span class="gi">+            and inferred_parent.qname() == &quot;typing._SpecialForm&quot;</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(TypingChecker(linter))</span>
<span class="gh">diff --git a/pylint/extensions/while_used.py b/pylint/extensions/while_used.py</span>
<span class="gh">index f121a899f..da1f9d59c 100644</span>
<span class="gd">--- a/pylint/extensions/while_used.py</span>
<span class="gi">+++ b/pylint/extensions/while_used.py</span>
<span class="gu">@@ -1,15 +1,37 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Check for use of while loops.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers import BaseChecker
<span class="w"> </span>from pylint.checkers.utils import only_required_for_messages
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter


<span class="w"> </span>class WhileChecker(BaseChecker):
<span class="gd">-    name = &#39;while_used&#39;</span>
<span class="gd">-    msgs = {&#39;W0149&#39;: (&#39;Used `while` loop&#39;, &#39;while-used&#39;,</span>
<span class="gd">-        &#39;Unbounded `while` loops can often be rewritten as bounded `for` loops. Exceptions can be made for cases such as event loops, listeners, etc.&#39;</span>
<span class="gd">-        )}</span>
<span class="gi">+    name = &quot;while_used&quot;</span>
<span class="gi">+    msgs = {</span>
<span class="gi">+        &quot;W0149&quot;: (</span>
<span class="gi">+            &quot;Used `while` loop&quot;,</span>
<span class="gi">+            &quot;while-used&quot;,</span>
<span class="gi">+            &quot;Unbounded `while` loops can often be rewritten as bounded `for` loops. &quot;</span>
<span class="gi">+            &quot;Exceptions can be made for cases such as event loops, listeners, etc.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @only_required_for_messages(&quot;while-used&quot;)</span>
<span class="gi">+    def visit_while(self, node: nodes.While) -&gt; None:</span>
<span class="gi">+        self.add_message(&quot;while-used&quot;, node=node)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_checker(WhileChecker(linter))</span>
<span class="gh">diff --git a/pylint/graph.py b/pylint/graph.py</span>
<span class="gh">index a76f38ae0..4112fadfa 100644</span>
<span class="gd">--- a/pylint/graph.py</span>
<span class="gi">+++ b/pylint/graph.py</span>
<span class="gu">@@ -1,8 +1,14 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Graph manipulation utilities.

<span class="w"> </span>(dot generation adapted from pypy/translator/tool/make_dot.py)
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import codecs
<span class="w"> </span>import os
<span class="w"> </span>import shutil
<span class="gu">@@ -12,44 +18,63 @@ from collections.abc import Sequence</span>
<span class="w"> </span>from typing import Any


<span class="gd">-def target_info_from_filename(filename: str) -&gt;tuple[str, str, str]:</span>
<span class="gi">+def target_info_from_filename(filename: str) -&gt; tuple[str, str, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Transforms /some/path/foo.png into (&#39;/some/path&#39;, &#39;foo.png&#39;, &#39;png&#39;).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    basename = os.path.basename(filename)</span>
<span class="gi">+    storedir = os.path.dirname(os.path.abspath(filename))</span>
<span class="gi">+    target = os.path.splitext(filename)[-1][1:]</span>
<span class="gi">+    return storedir, basename, target</span>


<span class="w"> </span>class DotBackend:
<span class="w"> </span>    &quot;&quot;&quot;Dot File back-end.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, graphname: str, rankdir: (str | None)=None, size:</span>
<span class="gd">-        Any=None, ratio: Any=None, charset: str=&#39;utf-8&#39;, renderer: str=</span>
<span class="gd">-        &#39;dot&#39;, additional_param: (dict[str, Any] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        graphname: str,</span>
<span class="gi">+        rankdir: str | None = None,</span>
<span class="gi">+        size: Any = None,</span>
<span class="gi">+        ratio: Any = None,</span>
<span class="gi">+        charset: str = &quot;utf-8&quot;,</span>
<span class="gi">+        renderer: str = &quot;dot&quot;,</span>
<span class="gi">+        additional_param: dict[str, Any] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if additional_param is None:
<span class="w"> </span>            additional_param = {}
<span class="w"> </span>        self.graphname = graphname
<span class="w"> </span>        self.renderer = renderer
<span class="w"> </span>        self.lines: list[str] = []
<span class="w"> </span>        self._source: str | None = None
<span class="gd">-        self.emit(f&#39;digraph {normalize_node_id(graphname)} {{&#39;)</span>
<span class="gi">+        self.emit(f&quot;digraph {normalize_node_id(graphname)} {{&quot;)</span>
<span class="w"> </span>        if rankdir:
<span class="gd">-            self.emit(f&#39;rankdir={rankdir}&#39;)</span>
<span class="gi">+            self.emit(f&quot;rankdir={rankdir}&quot;)</span>
<span class="w"> </span>        if ratio:
<span class="gd">-            self.emit(f&#39;ratio={ratio}&#39;)</span>
<span class="gi">+            self.emit(f&quot;ratio={ratio}&quot;)</span>
<span class="w"> </span>        if size:
<span class="w"> </span>            self.emit(f&#39;size=&quot;{size}&quot;&#39;)
<span class="w"> </span>        if charset:
<span class="gd">-            assert charset.lower() in {&#39;utf-8&#39;, &#39;iso-8859-1&#39;, &#39;latin1&#39;</span>
<span class="gd">-                }, f&#39;unsupported charset {charset}&#39;</span>
<span class="gi">+            assert charset.lower() in {</span>
<span class="gi">+                &quot;utf-8&quot;,</span>
<span class="gi">+                &quot;iso-8859-1&quot;,</span>
<span class="gi">+                &quot;latin1&quot;,</span>
<span class="gi">+            }, f&quot;unsupported charset {charset}&quot;</span>
<span class="w"> </span>            self.emit(f&#39;charset=&quot;{charset}&quot;&#39;)
<span class="w"> </span>        for param in additional_param.items():
<span class="gd">-            self.emit(&#39;=&#39;.join(param))</span>
<span class="gi">+            self.emit(&quot;=&quot;.join(param))</span>

<span class="gd">-    def get_source(self) -&gt;str:</span>
<span class="gi">+    def get_source(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns self._source.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._source is None:</span>
<span class="gi">+            self.emit(&quot;}\n&quot;)</span>
<span class="gi">+            self._source = &quot;\n&quot;.join(self.lines)</span>
<span class="gi">+            del self.lines</span>
<span class="gi">+        return self._source</span>
<span class="gi">+</span>
<span class="w"> </span>    source = property(get_source)

<span class="gd">-    def generate(self, outputfile: (str | None)=None, mapfile: (str | None)</span>
<span class="gd">-        =None) -&gt;str:</span>
<span class="gi">+    def generate(</span>
<span class="gi">+        self, outputfile: str | None = None, mapfile: str | None = None</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a graph file.

<span class="w"> </span>        :param str outputfile: filename and path [defaults to graphname.png]
<span class="gu">@@ -59,41 +84,129 @@ class DotBackend:</span>
<span class="w"> </span>        :return: a path to the generated file
<span class="w"> </span>        :raises RuntimeError: if the executable for rendering was not found
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def emit(self, line: str) -&gt;None:</span>
<span class="gi">+        # pylint: disable=duplicate-code</span>
<span class="gi">+        graphviz_extensions = (&quot;dot&quot;, &quot;gv&quot;)</span>
<span class="gi">+        name = self.graphname</span>
<span class="gi">+        if outputfile is None:</span>
<span class="gi">+            target = &quot;png&quot;</span>
<span class="gi">+            pdot, dot_sourcepath = tempfile.mkstemp(&quot;.gv&quot;, name)</span>
<span class="gi">+            ppng, outputfile = tempfile.mkstemp(&quot;.png&quot;, name)</span>
<span class="gi">+            os.close(pdot)</span>
<span class="gi">+            os.close(ppng)</span>
<span class="gi">+        else:</span>
<span class="gi">+            _, _, target = target_info_from_filename(outputfile)</span>
<span class="gi">+            if not target:</span>
<span class="gi">+                target = &quot;png&quot;</span>
<span class="gi">+                outputfile = outputfile + &quot;.&quot; + target</span>
<span class="gi">+            if target not in graphviz_extensions:</span>
<span class="gi">+                pdot, dot_sourcepath = tempfile.mkstemp(&quot;.gv&quot;, name)</span>
<span class="gi">+                os.close(pdot)</span>
<span class="gi">+            else:</span>
<span class="gi">+                dot_sourcepath = outputfile</span>
<span class="gi">+        with codecs.open(dot_sourcepath, &quot;w&quot;, encoding=&quot;utf8&quot;) as file:</span>
<span class="gi">+            file.write(self.source)</span>
<span class="gi">+        if target not in graphviz_extensions:</span>
<span class="gi">+            if shutil.which(self.renderer) is None:</span>
<span class="gi">+                raise RuntimeError(</span>
<span class="gi">+                    f&quot;Cannot generate `{outputfile}` because &#39;{self.renderer}&#39; &quot;</span>
<span class="gi">+                    &quot;executable not found. Install graphviz, or specify a `.gv` &quot;</span>
<span class="gi">+                    &quot;outputfile to produce the DOT source code.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if mapfile:</span>
<span class="gi">+                subprocess.run(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        self.renderer,</span>
<span class="gi">+                        &quot;-Tcmapx&quot;,</span>
<span class="gi">+                        &quot;-o&quot;,</span>
<span class="gi">+                        mapfile,</span>
<span class="gi">+                        &quot;-T&quot;,</span>
<span class="gi">+                        target,</span>
<span class="gi">+                        dot_sourcepath,</span>
<span class="gi">+                        &quot;-o&quot;,</span>
<span class="gi">+                        outputfile,</span>
<span class="gi">+                    ],</span>
<span class="gi">+                    check=True,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                subprocess.run(</span>
<span class="gi">+                    [self.renderer, &quot;-T&quot;, target, dot_sourcepath, &quot;-o&quot;, outputfile],</span>
<span class="gi">+                    check=True,</span>
<span class="gi">+                )</span>
<span class="gi">+            os.unlink(dot_sourcepath)</span>
<span class="gi">+        return outputfile</span>
<span class="gi">+</span>
<span class="gi">+    def emit(self, line: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds &lt;line&gt; to final output.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.lines.append(line)</span>

<span class="gd">-    def emit_edge(self, name1: str, name2: str, **props: Any) -&gt;None:</span>
<span class="gi">+    def emit_edge(self, name1: str, name2: str, **props: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit an edge from &lt;name1&gt; to &lt;name2&gt;.

<span class="w"> </span>        For edge properties: see https://www.graphviz.org/doc/info/attrs.html
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attrs = [f&#39;{prop}=&quot;{value}&quot;&#39; for prop, value in props.items()]</span>
<span class="gi">+        n_from, n_to = normalize_node_id(name1), normalize_node_id(name2)</span>
<span class="gi">+        self.emit(f&quot;{n_from} -&gt; {n_to} [{&#39;, &#39;.join(sorted(attrs))}];&quot;)</span>

<span class="gd">-    def emit_node(self, name: str, **props: Any) -&gt;None:</span>
<span class="gi">+    def emit_node(self, name: str, **props: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit a node with given properties.

<span class="w"> </span>        For node properties: see https://www.graphviz.org/doc/info/attrs.html
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        attrs = [f&#39;{prop}=&quot;{value}&quot;&#39; for prop, value in props.items()]</span>
<span class="gi">+        self.emit(f&quot;{normalize_node_id(name)} [{&#39;, &#39;.join(sorted(attrs))}];&quot;)</span>


<span class="gd">-def normalize_node_id(nid: str) -&gt;str:</span>
<span class="gi">+def normalize_node_id(nid: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns a suitable DOT node id for `nid`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return f&#39;&quot;{nid}&quot;&#39;</span>


<span class="gd">-def get_cycles(graph_dict: dict[str, set[str]], vertices: (list[str] | None</span>
<span class="gd">-    )=None) -&gt;Sequence[list[str]]:</span>
<span class="gi">+def get_cycles(</span>
<span class="gi">+    graph_dict: dict[str, set[str]], vertices: list[str] | None = None</span>
<span class="gi">+) -&gt; Sequence[list[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a list of detected cycles based on an ordered graph (i.e. keys are
<span class="w"> </span>    vertices and values are lists of destination vertices representing edges).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _get_cycles(graph_dict: dict[str, set[str]], path: list[str], visited:</span>
<span class="gd">-    set[str], result: list[list[str]], vertice: str) -&gt;None:</span>
<span class="gi">+    if not graph_dict:</span>
<span class="gi">+        return ()</span>
<span class="gi">+    result: list[list[str]] = []</span>
<span class="gi">+    if vertices is None:</span>
<span class="gi">+        vertices = list(graph_dict.keys())</span>
<span class="gi">+    for vertice in vertices:</span>
<span class="gi">+        _get_cycles(graph_dict, [], set(), result, vertice)</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_cycles(</span>
<span class="gi">+    graph_dict: dict[str, set[str]],</span>
<span class="gi">+    path: list[str],</span>
<span class="gi">+    visited: set[str],</span>
<span class="gi">+    result: list[list[str]],</span>
<span class="gi">+    vertice: str,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Recursive function doing the real work for get_cycles.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if vertice in path:</span>
<span class="gi">+        cycle = [vertice]</span>
<span class="gi">+        for node in path[::-1]:</span>
<span class="gi">+            if node == vertice:</span>
<span class="gi">+                break</span>
<span class="gi">+            cycle.insert(0, node)</span>
<span class="gi">+        # make a canonical representation</span>
<span class="gi">+        start_from = min(cycle)</span>
<span class="gi">+        index = cycle.index(start_from)</span>
<span class="gi">+        cycle = cycle[index:] + cycle[0:index]</span>
<span class="gi">+        # append it to result if not already in</span>
<span class="gi">+        if cycle not in result:</span>
<span class="gi">+            result.append(cycle)</span>
<span class="gi">+        return</span>
<span class="gi">+    path.append(vertice)</span>
<span class="gi">+    try:</span>
<span class="gi">+        for node in graph_dict[vertice]:</span>
<span class="gi">+            # don&#39;t check already visited nodes again</span>
<span class="gi">+            if node not in visited:</span>
<span class="gi">+                _get_cycles(graph_dict, path, visited, result, node)</span>
<span class="gi">+                visited.add(node)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    path.pop()</span>
<span class="gh">diff --git a/pylint/interfaces.py b/pylint/interfaces.py</span>
<span class="gh">index 73c93e32d..c47e297b4 100644</span>
<span class="gd">--- a/pylint/interfaces.py</span>
<span class="gi">+++ b/pylint/interfaces.py</span>
<span class="gu">@@ -1,7 +1,20 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import NamedTuple
<span class="gd">-__all__ = (&#39;HIGH&#39;, &#39;CONTROL_FLOW&#39;, &#39;INFERENCE&#39;, &#39;INFERENCE_FAILURE&#39;,</span>
<span class="gd">-    &#39;UNDEFINED&#39;, &#39;CONFIDENCE_LEVELS&#39;, &#39;CONFIDENCE_LEVEL_NAMES&#39;)</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (</span>
<span class="gi">+    &quot;HIGH&quot;,</span>
<span class="gi">+    &quot;CONTROL_FLOW&quot;,</span>
<span class="gi">+    &quot;INFERENCE&quot;,</span>
<span class="gi">+    &quot;INFERENCE_FAILURE&quot;,</span>
<span class="gi">+    &quot;UNDEFINED&quot;,</span>
<span class="gi">+    &quot;CONFIDENCE_LEVELS&quot;,</span>
<span class="gi">+    &quot;CONFIDENCE_LEVEL_NAMES&quot;,</span>
<span class="gi">+)</span>


<span class="w"> </span>class Confidence(NamedTuple):
<span class="gu">@@ -9,15 +22,17 @@ class Confidence(NamedTuple):</span>
<span class="w"> </span>    description: str


<span class="gd">-HIGH = Confidence(&#39;HIGH&#39;, &#39;Warning that is not based on inference result.&#39;)</span>
<span class="gd">-CONTROL_FLOW = Confidence(&#39;CONTROL_FLOW&#39;,</span>
<span class="gd">-    &#39;Warning based on assumptions about control flow.&#39;)</span>
<span class="gd">-INFERENCE = Confidence(&#39;INFERENCE&#39;, &#39;Warning based on inference result.&#39;)</span>
<span class="gd">-INFERENCE_FAILURE = Confidence(&#39;INFERENCE_FAILURE&#39;,</span>
<span class="gd">-    &#39;Warning based on inference with failures.&#39;)</span>
<span class="gd">-UNDEFINED = Confidence(&#39;UNDEFINED&#39;,</span>
<span class="gd">-    &#39;Warning without any associated confidence level.&#39;)</span>
<span class="gd">-CONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE,</span>
<span class="gd">-    UNDEFINED]</span>
<span class="gi">+# Warning Certainties</span>
<span class="gi">+HIGH = Confidence(&quot;HIGH&quot;, &quot;Warning that is not based on inference result.&quot;)</span>
<span class="gi">+CONTROL_FLOW = Confidence(</span>
<span class="gi">+    &quot;CONTROL_FLOW&quot;, &quot;Warning based on assumptions about control flow.&quot;</span>
<span class="gi">+)</span>
<span class="gi">+INFERENCE = Confidence(&quot;INFERENCE&quot;, &quot;Warning based on inference result.&quot;)</span>
<span class="gi">+INFERENCE_FAILURE = Confidence(</span>
<span class="gi">+    &quot;INFERENCE_FAILURE&quot;, &quot;Warning based on inference with failures.&quot;</span>
<span class="gi">+)</span>
<span class="gi">+UNDEFINED = Confidence(&quot;UNDEFINED&quot;, &quot;Warning without any associated confidence level.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+CONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]</span>
<span class="w"> </span>CONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]
<span class="w"> </span>CONFIDENCE_MAP = {i.name: i for i in CONFIDENCE_LEVELS}
<span class="gh">diff --git a/pylint/lint/base_options.py b/pylint/lint/base_options.py</span>
<span class="gh">index af170fd04..59a811d9c 100644</span>
<span class="gd">--- a/pylint/lint/base_options.py</span>
<span class="gi">+++ b/pylint/lint/base_options.py</span>
<span class="gu">@@ -1,20 +1,608 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Functions that creates the basic options for the Run and PyLinter classes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from pylint import constants, interfaces
<span class="gd">-from pylint.config.callback_actions import _DisableAction, _DoNothingAction, _EnableAction, _ErrorsOnlyModeAction, _FullDocumentationAction, _GenerateConfigFileAction, _GenerateRCFileAction, _ListCheckGroupsAction, _ListConfidenceLevelsAction, _ListExtensionsAction, _ListMessagesAction, _ListMessagesEnabledAction, _LongHelpAction, _MessageHelpAction, _OutputFormatAction</span>
<span class="gi">+from pylint.config.callback_actions import (</span>
<span class="gi">+    _DisableAction,</span>
<span class="gi">+    _DoNothingAction,</span>
<span class="gi">+    _EnableAction,</span>
<span class="gi">+    _ErrorsOnlyModeAction,</span>
<span class="gi">+    _FullDocumentationAction,</span>
<span class="gi">+    _GenerateConfigFileAction,</span>
<span class="gi">+    _GenerateRCFileAction,</span>
<span class="gi">+    _ListCheckGroupsAction,</span>
<span class="gi">+    _ListConfidenceLevelsAction,</span>
<span class="gi">+    _ListExtensionsAction,</span>
<span class="gi">+    _ListMessagesAction,</span>
<span class="gi">+    _ListMessagesEnabledAction,</span>
<span class="gi">+    _LongHelpAction,</span>
<span class="gi">+    _MessageHelpAction,</span>
<span class="gi">+    _OutputFormatAction,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.typing import Options
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter, Run


<span class="gd">-def _make_linter_options(linter: PyLinter) -&gt;Options:</span>
<span class="gi">+def _make_linter_options(linter: PyLinter) -&gt; Options:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the options used in a PyLinter class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;file&gt;[,&lt;file&gt;...]&quot;,</span>
<span class="gi">+                &quot;dest&quot;: &quot;black_list&quot;,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;old_names&quot;: [&quot;black_list&quot;]},</span>
<span class="gi">+                &quot;default&quot;: constants.DEFAULT_IGNORE_LIST,</span>
<span class="gi">+                &quot;help&quot;: &quot;Files or directories to be skipped. &quot;</span>
<span class="gi">+                &quot;They should be base names, not paths.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-patterns&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp_csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;pattern&gt;[,&lt;pattern&gt;...]&quot;,</span>
<span class="gi">+                &quot;dest&quot;: &quot;black_list_re&quot;,</span>
<span class="gi">+                &quot;default&quot;: (re.compile(r&quot;^\.#&quot;),),</span>
<span class="gi">+                &quot;help&quot;: &quot;Files or directories matching the regular expression patterns are&quot;</span>
<span class="gi">+                &quot; skipped. The regex matches against base names, not paths. The default value &quot;</span>
<span class="gi">+                &quot;ignores Emacs file locks&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignore-paths&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;regexp_paths_csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;pattern&gt;[,&lt;pattern&gt;...]&quot;,</span>
<span class="gi">+                &quot;default&quot;: [],</span>
<span class="gi">+                &quot;help&quot;: &quot;Add files or directories matching the regular expressions patterns to the &quot;</span>
<span class="gi">+                &quot;ignore-list. The regex matches against paths and can be in &quot;</span>
<span class="gi">+                &quot;Posix or Windows format. Because &#39;\\\\&#39; represents the directory delimiter &quot;</span>
<span class="gi">+                &quot;on Windows systems, it can&#39;t be used as an escape character.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;persistent&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Pickle collected data for later comparisons.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;load-plugins&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;modules&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;help&quot;: &quot;List of plugins (as comma separated values of &quot;</span>
<span class="gi">+                &quot;python module names) to load, usually to register &quot;</span>
<span class="gi">+                &quot;additional checkers.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;output-format&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;text&quot;,</span>
<span class="gi">+                &quot;action&quot;: _OutputFormatAction,</span>
<span class="gi">+                &quot;callback&quot;: lambda x: x,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;format&gt;&quot;,</span>
<span class="gi">+                &quot;short&quot;: &quot;f&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Reports&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Set the output format. Available formats are: text, &quot;</span>
<span class="gi">+                &quot;parseable, colorized, json2 (improved json format), json &quot;</span>
<span class="gi">+                &quot;(old json format) and msvs (visual studio). &quot;</span>
<span class="gi">+                &quot;You can also give a reporter class, e.g. mypackage.mymodule.&quot;</span>
<span class="gi">+                &quot;MyReporterClass.&quot;,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;linter&quot;: linter},</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;reports&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;short&quot;: &quot;r&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Reports&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Tells whether to display a full report or only the &quot;</span>
<span class="gi">+                &quot;messages.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;evaluation&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;python_expression&gt;&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Reports&quot;,</span>
<span class="gi">+                &quot;default&quot;: &quot;max(0, 0 if fatal else 10.0 - ((float(5 * error + warning + refactor + &quot;</span>
<span class="gi">+                &quot;convention) / statement) * 10))&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Python expression which should return a score less &quot;</span>
<span class="gi">+                &quot;than or equal to 10. You have access to the variables &#39;fatal&#39;, &quot;</span>
<span class="gi">+                &quot;&#39;error&#39;, &#39;warning&#39;, &#39;refactor&#39;, &#39;convention&#39;, and &#39;info&#39; which &quot;</span>
<span class="gi">+                &quot;contain the number of messages in each category, as well as &quot;</span>
<span class="gi">+                &quot;&#39;statement&#39; which is the total number of statements &quot;</span>
<span class="gi">+                &quot;analyzed. This score is used by the global &quot;</span>
<span class="gi">+                &quot;evaluation report (RP0004).&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;score&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;short&quot;: &quot;s&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Reports&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Activate the evaluation score.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;fail-under&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: 10,</span>
<span class="gi">+                &quot;type&quot;: &quot;float&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;score&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Specify a score threshold under which the program will exit with error.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;fail-on&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;msg ids&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Return non-zero exit code if any of these messages/categories are detected,&quot;</span>
<span class="gi">+                &quot; even if score is above --fail-under value. Syntax same as enable.&quot;</span>
<span class="gi">+                &quot; Messages specified are enabled, while categories only check already-enabled messages.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;confidence&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;confidence&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;levels&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: interfaces.CONFIDENCE_LEVEL_NAMES,</span>
<span class="gi">+                &quot;group&quot;: &quot;Messages control&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Only show warnings with the listed confidence levels.&quot;</span>
<span class="gi">+                f&quot; Leave empty to show all. Valid levels: {&#39;, &#39;.join(interfaces.CONFIDENCE_LEVEL_NAMES)}.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;enable&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _EnableAction,</span>
<span class="gi">+                &quot;callback&quot;: lambda x1, x2, x3, x4: x1,</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;msg ids&gt;&quot;,</span>
<span class="gi">+                &quot;short&quot;: &quot;e&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Messages control&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Enable the message, report, category or checker with the &quot;</span>
<span class="gi">+                &quot;given id(s). You can either give multiple identifier &quot;</span>
<span class="gi">+                &quot;separated by comma (,) or put this option multiple time &quot;</span>
<span class="gi">+                &quot;(only on the command line, not in the configuration file &quot;</span>
<span class="gi">+                &quot;where it should appear only once). &quot;</span>
<span class="gi">+                &#39;See also the &quot;--disable&quot; option for examples.&#39;,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;linter&quot;: linter},</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;disable&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _DisableAction,</span>
<span class="gi">+                &quot;callback&quot;: lambda x1, x2, x3, x4: x1,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;msg ids&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;short&quot;: &quot;d&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Messages control&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Disable the message, report, category or checker &quot;</span>
<span class="gi">+                &quot;with the given id(s). You can either give multiple identifiers &quot;</span>
<span class="gi">+                &quot;separated by comma (,) or put this option multiple times &quot;</span>
<span class="gi">+                &quot;(only on the command line, not in the configuration file &quot;</span>
<span class="gi">+                &quot;where it should appear only once). &quot;</span>
<span class="gi">+                &#39;You can also use &quot;--disable=all&quot; to disable everything first &#39;</span>
<span class="gi">+                &quot;and then re-enable specific checks. For example, if you want &quot;</span>
<span class="gi">+                &quot;to run only the similarities checker, you can use &quot;</span>
<span class="gi">+                &#39;&quot;--disable=all --enable=similarities&quot;. &#39;</span>
<span class="gi">+                &quot;If you want to run only the classes checker, but have no &quot;</span>
<span class="gi">+                &quot;Warning level messages displayed, use &quot;</span>
<span class="gi">+                &#39;&quot;--disable=all --enable=classes --disable=W&quot;.&#39;,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;linter&quot;: linter},</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;msg-template&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+                &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;template&gt;&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Reports&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Template used to display messages. &quot;</span>
<span class="gi">+                    &quot;This is a python new-style format string &quot;</span>
<span class="gi">+                    &quot;used to format the message information. &quot;</span>
<span class="gi">+                    &quot;See doc for all details.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;jobs&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;n-processes&gt;&quot;,</span>
<span class="gi">+                &quot;short&quot;: &quot;j&quot;,</span>
<span class="gi">+                &quot;default&quot;: 1,</span>
<span class="gi">+                &quot;help&quot;: &quot;Use multiple processes to speed up Pylint. Specifying 0 will &quot;</span>
<span class="gi">+                &quot;auto-detect the number of processors available to use, and will cap &quot;</span>
<span class="gi">+                &quot;the count on Windows to avoid hangs.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;unsafe-load-any-extension&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;hide&quot;: True,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Allow loading of arbitrary C extensions. Extensions&quot;</span>
<span class="gi">+                    &quot; are imported into the active Python interpreter and&quot;</span>
<span class="gi">+                    &quot; may run arbitrary code.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;limit-inference-results&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;number-of-results&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: 100,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Control the amount of potential inferred values when inferring &quot;</span>
<span class="gi">+                    &quot;a single object. This can help the performance when dealing with &quot;</span>
<span class="gi">+                    &quot;large functions or complex, nested conditions.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;extension-pkg-allow-list&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;pkg[,pkg]&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: [],</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;A comma-separated list of package or module names&quot;</span>
<span class="gi">+                    &quot; from where C extensions may be loaded. Extensions are&quot;</span>
<span class="gi">+                    &quot; loading into the active Python interpreter and may run&quot;</span>
<span class="gi">+                    &quot; arbitrary code.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;extension-pkg-whitelist&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;pkg[,pkg]&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: [],</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;A comma-separated list of package or module names&quot;</span>
<span class="gi">+                    &quot; from where C extensions may be loaded. Extensions are&quot;</span>
<span class="gi">+                    &quot; loading into the active Python interpreter and may run&quot;</span>
<span class="gi">+                    &quot; arbitrary code. (This is an alternative name to&quot;</span>
<span class="gi">+                    &quot; extension-pkg-allow-list for backward compatibility.)&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;suggestion-mode&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: True,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;When enabled, pylint would attempt to guess common &quot;</span>
<span class="gi">+                    &quot;misconfiguration and emit user-friendly hints instead &quot;</span>
<span class="gi">+                    &quot;of false-positive error messages.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;exit-zero&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;flag&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Always return a 0 (non-error) status code, even if &quot;</span>
<span class="gi">+                    &quot;lint errors are found. This is primarily useful in &quot;</span>
<span class="gi">+                    &quot;continuous integration scripts.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;from-stdin&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;flag&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Interpret the stdin as a python script, whose filename &quot;</span>
<span class="gi">+                    &quot;needs to be passed as the module_or_package argument.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;source-roots&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;glob_paths_csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;path&gt;[,&lt;path&gt;...]&quot;,</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;help&quot;: &quot;Add paths to the list of the source roots. Supports globbing patterns. &quot;</span>
<span class="gi">+                &quot;The source root is an absolute path or a path relative to the current working &quot;</span>
<span class="gi">+                &quot;directory used to determine a package namespace for modules located under the &quot;</span>
<span class="gi">+                &quot;source root.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;recursive&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;yn&gt;&quot;,</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;help&quot;: &quot;Discover python modules and packages in the file system subtree.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;py-version&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: sys.version_info[:2],</span>
<span class="gi">+                &quot;type&quot;: &quot;py_version&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;py_version&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: (</span>
<span class="gi">+                    &quot;Minimum Python version to use for version dependent checks. &quot;</span>
<span class="gi">+                    &quot;Will default to the version used to run pylint.&quot;</span>
<span class="gi">+                ),</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;ignored-modules&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: (),</span>
<span class="gi">+                &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;module names&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List of module names for which member attributes &quot;</span>
<span class="gi">+                &quot;should not be checked and will not be imported &quot;</span>
<span class="gi">+                &quot;(useful for modules/projects &quot;</span>
<span class="gi">+                &quot;where namespaces are manipulated during runtime and &quot;</span>
<span class="gi">+                &quot;thus existing member attributes cannot be &quot;</span>
<span class="gi">+                &quot;deduced by static analysis). It supports qualified &quot;</span>
<span class="gi">+                &quot;module names, as well as Unix pattern matching.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;analyse-fallback-blocks&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Analyse import fallback blocks. This can be used to &quot;</span>
<span class="gi">+                &quot;support both Python 2 and 3 compatible code, which &quot;</span>
<span class="gi">+                &quot;means that the block might have code that exists &quot;</span>
<span class="gi">+                &quot;only in one or another interpreter, leading to false &quot;</span>
<span class="gi">+                &quot;positives when analysed.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;clear-cache-post-run&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Clear in-memory caches upon conclusion of linting. &quot;</span>
<span class="gi">+                &quot;Useful if running pylint in a server-like mode.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;prefer-stubs&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;default&quot;: False,</span>
<span class="gi">+                &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Resolve imports to .pyi stubs if available. May &quot;</span>
<span class="gi">+                &quot;reduce no-member messages and increase not-an-iterable &quot;</span>
<span class="gi">+                &quot;messages.&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>


<span class="gd">-def _make_run_options(self: Run) -&gt;Options:</span>
<span class="gi">+def _make_run_options(self: Run) -&gt; Options:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the options used in a Run class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;rcfile&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _DoNothingAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Specify a configuration file to load.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;output&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _DoNothingAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Specify an output file.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;init-hook&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _DoNothingAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {},</span>
<span class="gi">+                &quot;help&quot;: &quot;Python code to execute, usually for sys.path &quot;</span>
<span class="gi">+                &quot;manipulation such as pygtk.require().&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;help-msg&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _MessageHelpAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Display a help message for the given message id and &quot;</span>
<span class="gi">+                &quot;exit. The value may be a comma separated list of message ids.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;list-msgs&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _ListMessagesAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Display a list of all pylint&#39;s messages divided by whether &quot;</span>
<span class="gi">+                &quot;they are emittable with the given interpreter.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;list-msgs-enabled&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _ListMessagesEnabledAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Display a list of what messages are enabled, &quot;</span>
<span class="gi">+                &quot;disabled and non-emittable with the given configuration.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;list-groups&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _ListCheckGroupsAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List pylint&#39;s message groups.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;list-conf-levels&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _ListConfidenceLevelsAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Generate pylint&#39;s confidence levels.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;list-extensions&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _ListExtensionsAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;List available extensions.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;full-documentation&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _FullDocumentationAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Generate pylint&#39;s full documentation.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;generate-rcfile&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _GenerateRCFileAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Generate a sample configuration file according to &quot;</span>
<span class="gi">+                &quot;the current configuration. You can put other options &quot;</span>
<span class="gi">+                &quot;before this one to get them in the generated &quot;</span>
<span class="gi">+                &quot;configuration.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;generate-toml-config&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _GenerateConfigFileAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;Generate a sample configuration file according to &quot;</span>
<span class="gi">+                &quot;the current configuration. You can put other options &quot;</span>
<span class="gi">+                &quot;before this one to get them in the generated &quot;</span>
<span class="gi">+                &quot;configuration. The config is in the .toml format.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;errors-only&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _ErrorsOnlyModeAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;short&quot;: &quot;E&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;In error mode, messages with a category besides &quot;</span>
<span class="gi">+                &quot;ERROR or FATAL are suppressed, and no reports are done by default. &quot;</span>
<span class="gi">+                &quot;Error mode is compatible with disabling specific errors. &quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;verbose&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _DoNothingAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {},</span>
<span class="gi">+                &quot;short&quot;: &quot;v&quot;,</span>
<span class="gi">+                &quot;help&quot;: &quot;In verbose mode, extra non-checker-related info &quot;</span>
<span class="gi">+                &quot;will be displayed.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;enable-all-extensions&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _DoNothingAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {},</span>
<span class="gi">+                &quot;help&quot;: &quot;Load and enable all available extensions. &quot;</span>
<span class="gi">+                &quot;Use --list-extensions to see a list all available extensions.&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+                &quot;metavar&quot;: &quot;&quot;,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;long-help&quot;,</span>
<span class="gi">+            {</span>
<span class="gi">+                &quot;action&quot;: _LongHelpAction,</span>
<span class="gi">+                &quot;kwargs&quot;: {&quot;Run&quot;: self},</span>
<span class="gi">+                &quot;help&quot;: &quot;Show more verbose help.&quot;,</span>
<span class="gi">+                &quot;group&quot;: &quot;Commands&quot;,</span>
<span class="gi">+                &quot;hide_from_config_file&quot;: True,</span>
<span class="gi">+            },</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pylint/lint/caching.py b/pylint/lint/caching.py</span>
<span class="gh">index c1d94e651..97c4503d1 100644</span>
<span class="gd">--- a/pylint/lint/caching.py</span>
<span class="gi">+++ b/pylint/lint/caching.py</span>
<span class="gu">@@ -1,8 +1,71 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import pickle
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from pylint.constants import PYLINT_HOME
<span class="w"> </span>from pylint.utils import LinterStats
<span class="gi">+</span>
<span class="w"> </span>PYLINT_HOME_AS_PATH = Path(PYLINT_HOME)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_pdata_path(</span>
<span class="gi">+    base_name: Path, recurs: int, pylint_home: Path = PYLINT_HOME_AS_PATH</span>
<span class="gi">+) -&gt; Path:</span>
<span class="gi">+    # We strip all characters that can&#39;t be used in a filename. Also strip &#39;/&#39; and</span>
<span class="gi">+    # &#39;\\&#39; because we want to create a single file, not sub-directories.</span>
<span class="gi">+    underscored_name = &quot;_&quot;.join(</span>
<span class="gi">+        str(p.replace(&quot;:&quot;, &quot;_&quot;).replace(&quot;/&quot;, &quot;_&quot;).replace(&quot;\\&quot;, &quot;_&quot;))</span>
<span class="gi">+        for p in base_name.parts</span>
<span class="gi">+    )</span>
<span class="gi">+    return pylint_home / f&quot;{underscored_name}_{recurs}.stats&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_results(</span>
<span class="gi">+    base: str | Path, pylint_home: str | Path = PYLINT_HOME</span>
<span class="gi">+) -&gt; LinterStats | None:</span>
<span class="gi">+    base = Path(base)</span>
<span class="gi">+    pylint_home = Path(pylint_home)</span>
<span class="gi">+    data_file = _get_pdata_path(base, 1, pylint_home)</span>
<span class="gi">+</span>
<span class="gi">+    if not data_file.exists():</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        with open(data_file, &quot;rb&quot;) as stream:</span>
<span class="gi">+            data = pickle.load(stream)</span>
<span class="gi">+            if not isinstance(data, LinterStats):</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    &quot;You&#39;re using an old pylint cache with invalid data following &quot;</span>
<span class="gi">+                    f&quot;an upgrade, please delete &#39;{data_file}&#39;.&quot;,</span>
<span class="gi">+                    UserWarning,</span>
<span class="gi">+                    stacklevel=2,</span>
<span class="gi">+                )</span>
<span class="gi">+                raise TypeError</span>
<span class="gi">+            return data</span>
<span class="gi">+    except Exception:  # pylint: disable=broad-except</span>
<span class="gi">+        # There&#39;s an issue with the cache but we just continue as if it isn&#39;t there</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def save_results(</span>
<span class="gi">+    results: LinterStats, base: str | Path, pylint_home: str | Path = PYLINT_HOME</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    base = Path(base)</span>
<span class="gi">+    pylint_home = Path(pylint_home)</span>
<span class="gi">+    try:</span>
<span class="gi">+        pylint_home.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+    except OSError:  # pragma: no cover</span>
<span class="gi">+        print(f&quot;Unable to create directory {pylint_home}&quot;, file=sys.stderr)</span>
<span class="gi">+    data_file = _get_pdata_path(base, 1)</span>
<span class="gi">+    try:</span>
<span class="gi">+        with open(data_file, &quot;wb&quot;) as stream:</span>
<span class="gi">+            pickle.dump(results, stream)</span>
<span class="gi">+    except OSError as ex:  # pragma: no cover</span>
<span class="gi">+        print(f&quot;Unable to create file {data_file}: {ex}&quot;, file=sys.stderr)</span>
<span class="gh">diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py</span>
<span class="gh">index e14142cd7..04e701884 100644</span>
<span class="gd">--- a/pylint/lint/expand_modules.py</span>
<span class="gi">+++ b/pylint/lint/expand_modules.py</span>
<span class="gu">@@ -1,29 +1,171 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from re import Pattern
<span class="gi">+</span>
<span class="w"> </span>from astroid import modutils
<span class="gi">+</span>
<span class="w"> </span>from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict


<span class="gd">-def discover_package_path(modulepath: str, source_roots: Sequence[str]) -&gt;str:</span>
<span class="gi">+def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -&gt; list[str]:</span>
<span class="gi">+    def _is_package_cb(inner_path: str, parts: list[str]) -&gt; bool:</span>
<span class="gi">+        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace</span>
<span class="gi">+</span>
<span class="gi">+    return modutils.modpath_from_file_with_callback(  # type: ignore[no-any-return]</span>
<span class="gi">+        filename, path=path, is_package_cb=_is_package_cb</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def discover_package_path(modulepath: str, source_roots: Sequence[str]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Discover package path from one its modules and source roots.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dirname = os.path.realpath(os.path.expanduser(modulepath))</span>
<span class="gi">+    if not os.path.isdir(dirname):</span>
<span class="gi">+        dirname = os.path.dirname(dirname)</span>

<span class="gi">+    # Look for a source root that contains the module directory</span>
<span class="gi">+    for source_root in source_roots:</span>
<span class="gi">+        source_root = os.path.realpath(os.path.expanduser(source_root))</span>
<span class="gi">+        if os.path.commonpath([source_root, dirname]) == source_root:</span>
<span class="gi">+            return source_root</span>

<span class="gd">-def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+    # Fall back to legacy discovery by looking for __init__.py upwards as</span>
<span class="gi">+    # it&#39;s the only way given that source root was not found or was not provided</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if not os.path.exists(os.path.join(dirname, &quot;__init__.py&quot;)):</span>
<span class="gi">+            return dirname</span>
<span class="gi">+        old_dirname = dirname</span>
<span class="gi">+        dirname = os.path.dirname(dirname)</span>
<span class="gi">+        if old_dirname == dirname:</span>
<span class="gi">+            return os.getcwd()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_in_ignore_list_re(element: str, ignore_list_re: list[Pattern[str]]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determines if the element is matched in a regex ignore-list.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(file_pattern.match(element) for file_pattern in ignore_list_re)</span>
<span class="gi">+</span>

<span class="gi">+def _is_ignored_file(</span>
<span class="gi">+    element: str,</span>
<span class="gi">+    ignore_list: list[str],</span>
<span class="gi">+    ignore_list_re: list[Pattern[str]],</span>
<span class="gi">+    ignore_list_paths_re: list[Pattern[str]],</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    element = os.path.normpath(element)</span>
<span class="gi">+    basename = Path(element).absolute().name</span>
<span class="gi">+    return (</span>
<span class="gi">+        basename in ignore_list</span>
<span class="gi">+        or _is_in_ignore_list_re(basename, ignore_list_re)</span>
<span class="gi">+        or _is_in_ignore_list_re(element, ignore_list_paths_re)</span>
<span class="gi">+    )</span>

<span class="gd">-def expand_modules(files_or_modules: Sequence[str], source_roots: Sequence[</span>
<span class="gd">-    str], ignore_list: list[str], ignore_list_re: list[Pattern[str]],</span>
<span class="gd">-    ignore_list_paths_re: list[Pattern[str]]) -&gt;tuple[dict[str,</span>
<span class="gd">-    ModuleDescriptionDict], list[ErrorDescriptionDict]]:</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable = too-many-locals, too-many-statements</span>
<span class="gi">+def expand_modules(</span>
<span class="gi">+    files_or_modules: Sequence[str],</span>
<span class="gi">+    source_roots: Sequence[str],</span>
<span class="gi">+    ignore_list: list[str],</span>
<span class="gi">+    ignore_list_re: list[Pattern[str]],</span>
<span class="gi">+    ignore_list_paths_re: list[Pattern[str]],</span>
<span class="gi">+) -&gt; tuple[dict[str, ModuleDescriptionDict], list[ErrorDescriptionDict]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Take a list of files/modules/packages and return the list of tuple
<span class="w"> </span>    (file, module name) which have to be actually checked.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result: dict[str, ModuleDescriptionDict] = {}</span>
<span class="gi">+    errors: list[ErrorDescriptionDict] = []</span>
<span class="gi">+    path = sys.path.copy()</span>
<span class="gi">+</span>
<span class="gi">+    for something in files_or_modules:</span>
<span class="gi">+        basename = os.path.basename(something)</span>
<span class="gi">+        if _is_ignored_file(</span>
<span class="gi">+            something, ignore_list, ignore_list_re, ignore_list_paths_re</span>
<span class="gi">+        ):</span>
<span class="gi">+            continue</span>
<span class="gi">+        module_package_path = discover_package_path(something, source_roots)</span>
<span class="gi">+        additional_search_path = [&quot;.&quot;, module_package_path, *path]</span>
<span class="gi">+        if os.path.exists(something):</span>
<span class="gi">+            # this is a file or a directory</span>
<span class="gi">+            try:</span>
<span class="gi">+                modname = &quot;.&quot;.join(</span>
<span class="gi">+                    modutils.modpath_from_file(something, path=additional_search_path)</span>
<span class="gi">+                )</span>
<span class="gi">+            except ImportError:</span>
<span class="gi">+                modname = os.path.splitext(basename)[0]</span>
<span class="gi">+            if os.path.isdir(something):</span>
<span class="gi">+                filepath = os.path.join(something, &quot;__init__.py&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                filepath = something</span>
<span class="gi">+        else:</span>
<span class="gi">+            # suppose it&#39;s a module or package</span>
<span class="gi">+            modname = something</span>
<span class="gi">+            try:</span>
<span class="gi">+                filepath = modutils.file_from_modpath(</span>
<span class="gi">+                    modname.split(&quot;.&quot;), path=additional_search_path</span>
<span class="gi">+                )</span>
<span class="gi">+                if filepath is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            except ImportError as ex:</span>
<span class="gi">+                errors.append({&quot;key&quot;: &quot;fatal&quot;, &quot;mod&quot;: modname, &quot;ex&quot;: ex})</span>
<span class="gi">+                continue</span>
<span class="gi">+        filepath = os.path.normpath(filepath)</span>
<span class="gi">+        modparts = (modname or something).split(&quot;.&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            spec = modutils.file_info_from_modpath(</span>
<span class="gi">+                modparts, path=additional_search_path</span>
<span class="gi">+            )</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            # Might not be acceptable, don&#39;t crash.</span>
<span class="gi">+            is_namespace = False</span>
<span class="gi">+            is_directory = os.path.isdir(something)</span>
<span class="gi">+        else:</span>
<span class="gi">+            is_namespace = modutils.is_namespace(spec)</span>
<span class="gi">+            is_directory = modutils.is_directory(spec)</span>
<span class="gi">+        if not is_namespace:</span>
<span class="gi">+            if filepath in result:</span>
<span class="gi">+                # Always set arg flag if module explicitly given.</span>
<span class="gi">+                result[filepath][&quot;isarg&quot;] = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                result[filepath] = {</span>
<span class="gi">+                    &quot;path&quot;: filepath,</span>
<span class="gi">+                    &quot;name&quot;: modname,</span>
<span class="gi">+                    &quot;isarg&quot;: True,</span>
<span class="gi">+                    &quot;basepath&quot;: filepath,</span>
<span class="gi">+                    &quot;basename&quot;: modname,</span>
<span class="gi">+                }</span>
<span class="gi">+        has_init = (</span>
<span class="gi">+            not (modname.endswith(&quot;.__init__&quot;) or modname == &quot;__init__&quot;)</span>
<span class="gi">+            and os.path.basename(filepath) == &quot;__init__.py&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        if has_init or is_namespace or is_directory:</span>
<span class="gi">+            for subfilepath in modutils.get_module_files(</span>
<span class="gi">+                os.path.dirname(filepath) or &quot;.&quot;, ignore_list, list_all=is_namespace</span>
<span class="gi">+            ):</span>
<span class="gi">+                subfilepath = os.path.normpath(subfilepath)</span>
<span class="gi">+                if filepath == subfilepath:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if _is_in_ignore_list_re(</span>
<span class="gi">+                    os.path.basename(subfilepath), ignore_list_re</span>
<span class="gi">+                ) or _is_in_ignore_list_re(subfilepath, ignore_list_paths_re):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                modpath = _modpath_from_file(</span>
<span class="gi">+                    subfilepath, is_namespace, path=additional_search_path</span>
<span class="gi">+                )</span>
<span class="gi">+                submodname = &quot;.&quot;.join(modpath)</span>
<span class="gi">+                # Preserve arg flag if module is also explicitly given.</span>
<span class="gi">+                isarg = subfilepath in result and result[subfilepath][&quot;isarg&quot;]</span>
<span class="gi">+                result[subfilepath] = {</span>
<span class="gi">+                    &quot;path&quot;: subfilepath,</span>
<span class="gi">+                    &quot;name&quot;: submodname,</span>
<span class="gi">+                    &quot;isarg&quot;: isarg,</span>
<span class="gi">+                    &quot;basepath&quot;: filepath,</span>
<span class="gi">+                    &quot;basename&quot;: modname,</span>
<span class="gi">+                }</span>
<span class="gi">+    return result, errors</span>
<span class="gh">diff --git a/pylint/lint/message_state_handler.py b/pylint/lint/message_state_handler.py</span>
<span class="gh">index db36d7947..2ddd7d4db 100644</span>
<span class="gd">--- a/pylint/lint/message_state_handler.py</span>
<span class="gi">+++ b/pylint/lint/message_state_handler.py</span>
<span class="gu">@@ -1,13 +1,31 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import tokenize
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from typing import TYPE_CHECKING, Literal
<span class="gi">+</span>
<span class="w"> </span>from pylint import exceptions, interfaces
<span class="gd">-from pylint.constants import MSG_STATE_CONFIDENCE, MSG_STATE_SCOPE_CONFIG, MSG_STATE_SCOPE_MODULE, MSG_TYPES, MSG_TYPES_LONG</span>
<span class="gi">+from pylint.constants import (</span>
<span class="gi">+    MSG_STATE_CONFIDENCE,</span>
<span class="gi">+    MSG_STATE_SCOPE_CONFIG,</span>
<span class="gi">+    MSG_STATE_SCOPE_MODULE,</span>
<span class="gi">+    MSG_TYPES,</span>
<span class="gi">+    MSG_TYPES_LONG,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="w"> </span>from pylint.message import MessageDefinition
<span class="w"> </span>from pylint.typing import ManagedMessage
<span class="gd">-from pylint.utils.pragma_parser import OPTION_PO, InvalidPragmaError, UnRecognizedOptionError, parse_pragma</span>
<span class="gi">+from pylint.utils.pragma_parser import (</span>
<span class="gi">+    OPTION_PO,</span>
<span class="gi">+    InvalidPragmaError,</span>
<span class="gi">+    UnRecognizedOptionError,</span>
<span class="gi">+    parse_pragma,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter

<span class="gu">@@ -17,16 +35,22 @@ class _MessageStateHandler:</span>
<span class="w"> </span>    pragma&#39;s.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="w"> </span>        self.linter = linter
<span class="w"> </span>        self._msgs_state: dict[str, bool] = {}
<span class="gd">-        self._options_methods = {&#39;enable&#39;: self.enable, &#39;disable&#39;: self.</span>
<span class="gd">-            disable, &#39;disable-next&#39;: self.disable_next}</span>
<span class="gd">-        self._bw_options_methods = {&#39;disable-msg&#39;: self._options_methods[</span>
<span class="gd">-            &#39;disable&#39;], &#39;enable-msg&#39;: self._options_methods[&#39;enable&#39;]}</span>
<span class="gi">+        self._options_methods = {</span>
<span class="gi">+            &quot;enable&quot;: self.enable,</span>
<span class="gi">+            &quot;disable&quot;: self.disable,</span>
<span class="gi">+            &quot;disable-next&quot;: self.disable_next,</span>
<span class="gi">+        }</span>
<span class="gi">+        self._bw_options_methods = {</span>
<span class="gi">+            &quot;disable-msg&quot;: self._options_methods[&quot;disable&quot;],</span>
<span class="gi">+            &quot;enable-msg&quot;: self._options_methods[&quot;enable&quot;],</span>
<span class="gi">+        }</span>
<span class="w"> </span>        self._pragma_lineno: dict[str, int] = {}
<span class="gd">-        self._stashed_messages: defaultdict[tuple[str, str], list[tuple[str |</span>
<span class="gd">-            None, str]]] = defaultdict(list)</span>
<span class="gi">+        self._stashed_messages: defaultdict[</span>
<span class="gi">+            tuple[str, str], list[tuple[str | None, str]]</span>
<span class="gi">+        ] = defaultdict(list)</span>
<span class="w"> </span>        &quot;&quot;&quot;Some messages in the options (for --enable and --disable) are encountered
<span class="w"> </span>        too early to warn about them.

<span class="gu">@@ -34,63 +58,253 @@ class _MessageStateHandler:</span>
<span class="w"> </span>        option_value and msg_id needed to (later) emit the messages keyed on module names.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-    def _set_one_msg_status(self, scope: str, msg: MessageDefinition, line:</span>
<span class="gd">-        (int | None), enable: bool) -&gt;None:</span>
<span class="gi">+    def _set_one_msg_status(</span>
<span class="gi">+        self, scope: str, msg: MessageDefinition, line: int | None, enable: bool</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the status of an individual message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if scope in {&quot;module&quot;, &quot;line&quot;}:</span>
<span class="gi">+            assert isinstance(line, int)  # should always be int inside module scope</span>
<span class="gi">+</span>
<span class="gi">+            self.linter.file_state.set_msg_status(msg, line, enable, scope)</span>
<span class="gi">+            if not enable and msg.symbol != &quot;locally-disabled&quot;:</span>
<span class="gi">+                self.linter.add_message(</span>
<span class="gi">+                    &quot;locally-disabled&quot;, line=line, args=(msg.symbol, msg.msgid)</span>
<span class="gi">+                )</span>
<span class="gi">+        else:</span>
<span class="gi">+            msgs = self._msgs_state</span>
<span class="gi">+            msgs[msg.msgid] = enable</span>

<span class="gd">-    def _get_messages_to_set(self, msgid: str, enable: bool, ignore_unknown:</span>
<span class="gd">-        bool=False) -&gt;list[MessageDefinition]:</span>
<span class="gi">+    def _get_messages_to_set(</span>
<span class="gi">+        self, msgid: str, enable: bool, ignore_unknown: bool = False</span>
<span class="gi">+    ) -&gt; list[MessageDefinition]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do some tests and find the actual messages of which the status should be set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message_definitions: list[MessageDefinition] = []</span>
<span class="gi">+        if msgid == &quot;all&quot;:</span>
<span class="gi">+            for _msgid in MSG_TYPES:</span>
<span class="gi">+                message_definitions.extend(</span>
<span class="gi">+                    self._get_messages_to_set(_msgid, enable, ignore_unknown)</span>
<span class="gi">+                )</span>
<span class="gi">+            return message_definitions</span>

<span class="gd">-    def _set_msg_status(self, msgid: str, enable: bool, scope: str=</span>
<span class="gd">-        &#39;package&#39;, line: (int | None)=None, ignore_unknown: bool=False) -&gt;None:</span>
<span class="gi">+        # msgid is a category?</span>
<span class="gi">+        category_id = msgid.upper()</span>
<span class="gi">+        if category_id not in MSG_TYPES:</span>
<span class="gi">+            category_id_formatted = MSG_TYPES_LONG.get(category_id)</span>
<span class="gi">+        else:</span>
<span class="gi">+            category_id_formatted = category_id</span>
<span class="gi">+        if category_id_formatted is not None:</span>
<span class="gi">+            for _msgid in self.linter.msgs_store._msgs_by_category[</span>
<span class="gi">+                category_id_formatted</span>
<span class="gi">+            ]:</span>
<span class="gi">+                message_definitions.extend(</span>
<span class="gi">+                    self._get_messages_to_set(_msgid, enable, ignore_unknown)</span>
<span class="gi">+                )</span>
<span class="gi">+            return message_definitions</span>
<span class="gi">+</span>
<span class="gi">+        # msgid is a checker name?</span>
<span class="gi">+        if msgid.lower() in self.linter._checkers:</span>
<span class="gi">+            for checker in self.linter._checkers[msgid.lower()]:</span>
<span class="gi">+                for _msgid in checker.msgs:</span>
<span class="gi">+                    message_definitions.extend(</span>
<span class="gi">+                        self._get_messages_to_set(_msgid, enable, ignore_unknown)</span>
<span class="gi">+                    )</span>
<span class="gi">+            return message_definitions</span>
<span class="gi">+</span>
<span class="gi">+        # msgid is report id?</span>
<span class="gi">+        if msgid.lower().startswith(&quot;rp&quot;):</span>
<span class="gi">+            if enable:</span>
<span class="gi">+                self.linter.enable_report(msgid)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.linter.disable_report(msgid)</span>
<span class="gi">+            return message_definitions</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # msgid is a symbolic or numeric msgid.</span>
<span class="gi">+            message_definitions = self.linter.msgs_store.get_message_definitions(msgid)</span>
<span class="gi">+        except exceptions.UnknownMessageError:</span>
<span class="gi">+            if not ignore_unknown:</span>
<span class="gi">+                raise</span>
<span class="gi">+        return message_definitions</span>
<span class="gi">+</span>
<span class="gi">+    def _set_msg_status(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        enable: bool,</span>
<span class="gi">+        scope: str = &quot;package&quot;,</span>
<span class="gi">+        line: int | None = None,</span>
<span class="gi">+        ignore_unknown: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do some tests and then iterate over message definitions to set state.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert scope in {&quot;package&quot;, &quot;module&quot;, &quot;line&quot;}</span>
<span class="gi">+</span>
<span class="gi">+        message_definitions = self._get_messages_to_set(msgid, enable, ignore_unknown)</span>

<span class="gd">-    def _register_by_id_managed_msg(self, msgid_or_symbol: str, line: (int |</span>
<span class="gd">-        None), is_disabled: bool=True) -&gt;None:</span>
<span class="gi">+        for message_definition in message_definitions:</span>
<span class="gi">+            self._set_one_msg_status(scope, message_definition, line, enable)</span>
<span class="gi">+</span>
<span class="gi">+        # sync configuration object</span>
<span class="gi">+        self.linter.config.enable = []</span>
<span class="gi">+        self.linter.config.disable = []</span>
<span class="gi">+        for msgid_or_symbol, is_enabled in self._msgs_state.items():</span>
<span class="gi">+            symbols = [</span>
<span class="gi">+                m.symbol</span>
<span class="gi">+                for m in self.linter.msgs_store.get_message_definitions(msgid_or_symbol)</span>
<span class="gi">+            ]</span>
<span class="gi">+            if is_enabled:</span>
<span class="gi">+                self.linter.config.enable += symbols</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.linter.config.disable += symbols</span>
<span class="gi">+</span>
<span class="gi">+    def _register_by_id_managed_msg(</span>
<span class="gi">+        self, msgid_or_symbol: str, line: int | None, is_disabled: bool = True</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;If the msgid is a numeric one, then register it to inform the user
<span class="w"> </span>        it could furnish instead a symbolic msgid.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msgid_or_symbol[1:].isdigit():</span>
<span class="gi">+            try:</span>
<span class="gi">+                symbol = self.linter.msgs_store.message_id_store.get_symbol(</span>
<span class="gi">+                    msgid=msgid_or_symbol</span>
<span class="gi">+                )</span>
<span class="gi">+            except exceptions.UnknownMessageError:</span>
<span class="gi">+                return</span>
<span class="gi">+            managed = ManagedMessage(</span>
<span class="gi">+                self.linter.current_name, msgid_or_symbol, symbol, line, is_disabled</span>
<span class="gi">+            )</span>
<span class="gi">+            self.linter._by_id_managed_msgs.append(managed)</span>

<span class="gd">-    def disable(self, msgid: str, scope: str=&#39;package&#39;, line: (int | None)=</span>
<span class="gd">-        None, ignore_unknown: bool=False) -&gt;None:</span>
<span class="gi">+    def disable(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        scope: str = &quot;package&quot;,</span>
<span class="gi">+        line: int | None = None,</span>
<span class="gi">+        ignore_unknown: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Disable a message for a scope.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_msg_status(</span>
<span class="gi">+            msgid, enable=False, scope=scope, line=line, ignore_unknown=ignore_unknown</span>
<span class="gi">+        )</span>
<span class="gi">+        self._register_by_id_managed_msg(msgid, line)</span>

<span class="gd">-    def disable_next(self, msgid: str, _: str=&#39;package&#39;, line: (int | None)</span>
<span class="gd">-        =None, ignore_unknown: bool=False) -&gt;None:</span>
<span class="gi">+    def disable_next(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        _: str = &quot;package&quot;,</span>
<span class="gi">+        line: int | None = None,</span>
<span class="gi">+        ignore_unknown: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Disable a message for the next line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not line:</span>
<span class="gi">+            raise exceptions.NoLineSuppliedError</span>
<span class="gi">+        self._set_msg_status(</span>
<span class="gi">+            msgid,</span>
<span class="gi">+            enable=False,</span>
<span class="gi">+            scope=&quot;line&quot;,</span>
<span class="gi">+            line=line + 1,</span>
<span class="gi">+            ignore_unknown=ignore_unknown,</span>
<span class="gi">+        )</span>
<span class="gi">+        self._register_by_id_managed_msg(msgid, line + 1)</span>

<span class="gd">-    def enable(self, msgid: str, scope: str=&#39;package&#39;, line: (int | None)=</span>
<span class="gd">-        None, ignore_unknown: bool=False) -&gt;None:</span>
<span class="gi">+    def enable(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        scope: str = &quot;package&quot;,</span>
<span class="gi">+        line: int | None = None,</span>
<span class="gi">+        ignore_unknown: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Enable a message for a scope.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._set_msg_status(</span>
<span class="gi">+            msgid, enable=True, scope=scope, line=line, ignore_unknown=ignore_unknown</span>
<span class="gi">+        )</span>
<span class="gi">+        self._register_by_id_managed_msg(msgid, line, is_disabled=False)</span>

<span class="gd">-    def disable_noerror_messages(self) -&gt;None:</span>
<span class="gi">+    def disable_noerror_messages(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Disable message categories other than `error` and `fatal`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for msgcat in self.linter.msgs_store._msgs_by_category:</span>
<span class="gi">+            if msgcat in {&quot;E&quot;, &quot;F&quot;}:</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.disable(msgcat)</span>
<span class="gi">+</span>
<span class="gi">+    def list_messages_enabled(self) -&gt; None:</span>
<span class="gi">+        emittable, non_emittable = self.linter.msgs_store.find_emittable_messages()</span>
<span class="gi">+        enabled: list[str] = []</span>
<span class="gi">+        disabled: list[str] = []</span>
<span class="gi">+        for message in emittable:</span>
<span class="gi">+            if self.is_message_enabled(message.msgid):</span>
<span class="gi">+                enabled.append(f&quot;  {message.symbol} ({message.msgid})&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                disabled.append(f&quot;  {message.symbol} ({message.msgid})&quot;)</span>
<span class="gi">+        print(&quot;Enabled messages:&quot;)</span>
<span class="gi">+        for msg in enabled:</span>
<span class="gi">+            print(msg)</span>
<span class="gi">+        print(&quot;\nDisabled messages:&quot;)</span>
<span class="gi">+        for msg in disabled:</span>
<span class="gi">+            print(msg)</span>
<span class="gi">+        print(&quot;\nNon-emittable messages with current interpreter:&quot;)</span>
<span class="gi">+        for msg_def in non_emittable:</span>
<span class="gi">+            print(f&quot;  {msg_def.symbol} ({msg_def.msgid})&quot;)</span>
<span class="gi">+        print(&quot;&quot;)</span>

<span class="gd">-    def _get_message_state_scope(self, msgid: str, line: (int | None)=None,</span>
<span class="gd">-        confidence: (interfaces.Confidence | None)=None) -&gt;(Literal[0, 1, 2</span>
<span class="gd">-        ] | None):</span>
<span class="gi">+    def _get_message_state_scope(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        line: int | None = None,</span>
<span class="gi">+        confidence: interfaces.Confidence | None = None,</span>
<span class="gi">+    ) -&gt; Literal[0, 1, 2] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the scope at which a message was enabled/disabled.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if confidence is None:</span>
<span class="gi">+            confidence = interfaces.UNDEFINED</span>
<span class="gi">+        if confidence.name not in self.linter.config.confidence:</span>
<span class="gi">+            return MSG_STATE_CONFIDENCE  # type: ignore[return-value] # mypy does not infer Literal correctly</span>
<span class="gi">+        try:</span>
<span class="gi">+            if line in self.linter.file_state._module_msgs_state[msgid]:</span>
<span class="gi">+                return MSG_STATE_SCOPE_MODULE  # type: ignore[return-value]</span>
<span class="gi">+        except (KeyError, TypeError):</span>
<span class="gi">+            return MSG_STATE_SCOPE_CONFIG  # type: ignore[return-value]</span>
<span class="gi">+        return None</span>

<span class="gd">-    def _is_one_message_enabled(self, msgid: str, line: (int | None)) -&gt;bool:</span>
<span class="gi">+    def _is_one_message_enabled(self, msgid: str, line: int | None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks state of a single message for the current file.

<span class="w"> </span>        This function can&#39;t be cached as it depends on self.file_state which can
<span class="w"> </span>        change.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if line is None:</span>
<span class="gi">+            return self._msgs_state.get(msgid, True)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.linter.file_state._module_msgs_state[msgid][line]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # Check if the message&#39;s line is after the maximum line existing in ast tree.</span>
<span class="gi">+            # This line won&#39;t appear in the ast tree and won&#39;t be referred in</span>
<span class="gi">+            # self.file_state._module_msgs_state</span>
<span class="gi">+            # This happens for example with a commented line at the end of a module.</span>
<span class="gi">+            max_line_number = self.linter.file_state.get_effective_max_line_number()</span>
<span class="gi">+            if max_line_number and line &gt; max_line_number:</span>
<span class="gi">+                fallback = True</span>
<span class="gi">+                lines = self.linter.file_state._raw_module_msgs_state.get(msgid, {})</span>
<span class="gi">+</span>
<span class="gi">+                # Doesn&#39;t consider scopes, as a &#39;disable&#39; can be in a</span>
<span class="gi">+                # different scope than that of the current line.</span>
<span class="gi">+                closest_lines = reversed(</span>
<span class="gi">+                    [</span>
<span class="gi">+                        (message_line, enable)</span>
<span class="gi">+                        for message_line, enable in lines.items()</span>
<span class="gi">+                        if message_line &lt;= line</span>
<span class="gi">+                    ]</span>
<span class="gi">+                )</span>
<span class="gi">+                _, fallback_iter = next(closest_lines, (None, None))</span>
<span class="gi">+                if fallback_iter is not None:</span>
<span class="gi">+                    fallback = fallback_iter</span>
<span class="gi">+</span>
<span class="gi">+                return self._msgs_state.get(msgid, fallback)</span>
<span class="gi">+            return self._msgs_state.get(msgid, True)</span>

<span class="gd">-    def is_message_enabled(self, msg_descr: str, line: (int | None)=None,</span>
<span class="gd">-        confidence: (interfaces.Confidence | None)=None) -&gt;bool:</span>
<span class="gi">+    def is_message_enabled(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg_descr: str,</span>
<span class="gi">+        line: int | None = None,</span>
<span class="gi">+        confidence: interfaces.Confidence | None = None,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Is this message enabled for the current file ?

<span class="w"> </span>        Optionally, is it enabled for this line and confidence level ?
<span class="gu">@@ -104,12 +318,114 @@ class _MessageStateHandler:</span>
<span class="w"> </span>        :param line: The line of the currently analysed file
<span class="w"> </span>        :param confidence: The confidence of the message
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if confidence and confidence.name not in self.linter.config.confidence:</span>
<span class="gi">+            return False</span>
<span class="gi">+        try:</span>
<span class="gi">+            msgids = self.linter.msgs_store.message_id_store.get_active_msgids(</span>
<span class="gi">+                msg_descr</span>
<span class="gi">+            )</span>
<span class="gi">+        except exceptions.UnknownMessageError:</span>
<span class="gi">+            # The linter checks for messages that are not registered</span>
<span class="gi">+            # due to version mismatch, just treat them as message IDs</span>
<span class="gi">+            # for now.</span>
<span class="gi">+            msgids = [msg_descr]</span>
<span class="gi">+        return any(self._is_one_message_enabled(msgid, line) for msgid in msgids)</span>

<span class="gd">-    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt;None:</span>
<span class="gi">+    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process tokens from the current module to search for module/block level
<span class="w"> </span>        options.

<span class="w"> </span>        See func_block_disable_msg.py test case for expected behaviour.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        control_pragmas = {&quot;disable&quot;, &quot;disable-next&quot;, &quot;enable&quot;}</span>
<span class="gi">+        prev_line = None</span>
<span class="gi">+        saw_newline = True</span>
<span class="gi">+        seen_newline = True</span>
<span class="gi">+        for tok_type, content, start, _, _ in tokens:</span>
<span class="gi">+            if prev_line and prev_line != start[0]:</span>
<span class="gi">+                saw_newline = seen_newline</span>
<span class="gi">+                seen_newline = False</span>
<span class="gi">+</span>
<span class="gi">+            prev_line = start[0]</span>
<span class="gi">+            if tok_type in (tokenize.NL, tokenize.NEWLINE):</span>
<span class="gi">+                seen_newline = True</span>
<span class="gi">+</span>
<span class="gi">+            if tok_type != tokenize.COMMENT:</span>
<span class="gi">+                continue</span>
<span class="gi">+            match = OPTION_PO.search(content)</span>
<span class="gi">+            if match is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            try:  # pylint: disable = too-many-try-statements</span>
<span class="gi">+                for pragma_repr in parse_pragma(match.group(2)):</span>
<span class="gi">+                    if pragma_repr.action in {&quot;disable-all&quot;, &quot;skip-file&quot;}:</span>
<span class="gi">+                        if pragma_repr.action == &quot;disable-all&quot;:</span>
<span class="gi">+                            self.linter.add_message(</span>
<span class="gi">+                                &quot;deprecated-pragma&quot;,</span>
<span class="gi">+                                line=start[0],</span>
<span class="gi">+                                args=(&quot;disable-all&quot;, &quot;skip-file&quot;),</span>
<span class="gi">+                            )</span>
<span class="gi">+                        self.linter.add_message(&quot;file-ignored&quot;, line=start[0])</span>
<span class="gi">+                        self._ignore_file = True</span>
<span class="gi">+                        return</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        meth = self._options_methods[pragma_repr.action]</span>
<span class="gi">+                    except KeyError:</span>
<span class="gi">+                        meth = self._bw_options_methods[pragma_repr.action]</span>
<span class="gi">+                        # found a &quot;(dis|en)able-msg&quot; pragma deprecated suppression</span>
<span class="gi">+                        self.linter.add_message(</span>
<span class="gi">+                            &quot;deprecated-pragma&quot;,</span>
<span class="gi">+                            line=start[0],</span>
<span class="gi">+                            args=(</span>
<span class="gi">+                                pragma_repr.action,</span>
<span class="gi">+                                pragma_repr.action.replace(&quot;-msg&quot;, &quot;&quot;),</span>
<span class="gi">+                            ),</span>
<span class="gi">+                        )</span>
<span class="gi">+                    for msgid in pragma_repr.messages:</span>
<span class="gi">+                        # Add the line where a control pragma was encountered.</span>
<span class="gi">+                        if pragma_repr.action in control_pragmas:</span>
<span class="gi">+                            self._pragma_lineno[msgid] = start[0]</span>
<span class="gi">+</span>
<span class="gi">+                        if (pragma_repr.action, msgid) == (&quot;disable&quot;, &quot;all&quot;):</span>
<span class="gi">+                            self.linter.add_message(</span>
<span class="gi">+                                &quot;deprecated-pragma&quot;,</span>
<span class="gi">+                                line=start[0],</span>
<span class="gi">+                                args=(&quot;disable=all&quot;, &quot;skip-file&quot;),</span>
<span class="gi">+                            )</span>
<span class="gi">+                            self.linter.add_message(&quot;file-ignored&quot;, line=start[0])</span>
<span class="gi">+                            self._ignore_file = True</span>
<span class="gi">+                            return</span>
<span class="gi">+                            # If we did not see a newline between the previous line and now,</span>
<span class="gi">+                            # we saw a backslash so treat the two lines as one.</span>
<span class="gi">+                        l_start = start[0]</span>
<span class="gi">+                        if not saw_newline:</span>
<span class="gi">+                            l_start -= 1</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            meth(msgid, &quot;module&quot;, l_start)</span>
<span class="gi">+                        except (</span>
<span class="gi">+                            exceptions.DeletedMessageError,</span>
<span class="gi">+                            exceptions.MessageBecameExtensionError,</span>
<span class="gi">+                        ) as e:</span>
<span class="gi">+                            self.linter.add_message(</span>
<span class="gi">+                                &quot;useless-option-value&quot;,</span>
<span class="gi">+                                args=(pragma_repr.action, e),</span>
<span class="gi">+                                line=start[0],</span>
<span class="gi">+                                confidence=HIGH,</span>
<span class="gi">+                            )</span>
<span class="gi">+                        except exceptions.UnknownMessageError:</span>
<span class="gi">+                            self.linter.add_message(</span>
<span class="gi">+                                &quot;unknown-option-value&quot;,</span>
<span class="gi">+                                args=(pragma_repr.action, msgid),</span>
<span class="gi">+                                line=start[0],</span>
<span class="gi">+                                confidence=HIGH,</span>
<span class="gi">+                            )</span>
<span class="gi">+</span>
<span class="gi">+            except UnRecognizedOptionError as err:</span>
<span class="gi">+                self.linter.add_message(</span>
<span class="gi">+                    &quot;unrecognized-inline-option&quot;, args=err.token, line=start[0]</span>
<span class="gi">+                )</span>
<span class="gi">+                continue</span>
<span class="gi">+            except InvalidPragmaError as err:</span>
<span class="gi">+                self.linter.add_message(</span>
<span class="gi">+                    &quot;bad-inline-option&quot;, args=err.token, line=start[0]</span>
<span class="gi">+                )</span>
<span class="gi">+                continue</span>
<span class="gh">diff --git a/pylint/lint/parallel.py b/pylint/lint/parallel.py</span>
<span class="gh">index a5b179dbe..af381494c 100644</span>
<span class="gd">--- a/pylint/lint/parallel.py</span>
<span class="gi">+++ b/pylint/lint/parallel.py</span>
<span class="gu">@@ -1,48 +1,173 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from collections.abc import Iterable, Sequence
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>import dill
<span class="gi">+</span>
<span class="w"> </span>from pylint import reporters
<span class="w"> </span>from pylint.lint.utils import _augment_sys_path
<span class="w"> </span>from pylint.message import Message
<span class="w"> </span>from pylint.typing import FileItem
<span class="w"> </span>from pylint.utils import LinterStats, merge_stats
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import multiprocessing
<span class="w"> </span>except ImportError:
<span class="gd">-    multiprocessing = None</span>
<span class="gi">+    multiprocessing = None  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from concurrent.futures import ProcessPoolExecutor
<span class="w"> </span>except ImportError:
<span class="gd">-    ProcessPoolExecutor = None</span>
<span class="gi">+    ProcessPoolExecutor = None  # type: ignore[assignment,misc]</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="gi">+# PyLinter object used by worker processes when checking files using parallel mode</span>
<span class="gi">+# should only be used by the worker processes</span>
<span class="w"> </span>_worker_linter: PyLinter | None = None


<span class="gd">-def _worker_initialize(linter: bytes, extra_packages_paths: (Sequence[str] |</span>
<span class="gd">-    None)=None) -&gt;None:</span>
<span class="gi">+def _worker_initialize(</span>
<span class="gi">+    linter: bytes, extra_packages_paths: Sequence[str] | None = None</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Function called to initialize a worker for a Process within a concurrent Pool.

<span class="w"> </span>    :param linter: A linter-class (PyLinter) instance pickled with dill
<span class="w"> </span>    :param extra_packages_paths: Extra entries to be added to `sys.path`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _worker_linter  # pylint: disable=global-statement</span>
<span class="gi">+    _worker_linter = dill.loads(linter)</span>
<span class="gi">+    assert _worker_linter</span>

<span class="gi">+    # On the worker process side the messages are just collected and passed back to</span>
<span class="gi">+    # parent process as _worker_check_file function&#39;s return value</span>
<span class="gi">+    _worker_linter.set_reporter(reporters.CollectingReporter())</span>
<span class="gi">+    _worker_linter.open()</span>

<span class="gd">-def _merge_mapreduce_data(linter: PyLinter, all_mapreduce_data: defaultdict</span>
<span class="gd">-    [int, list[defaultdict[str, list[Any]]]]) -&gt;None:</span>
<span class="gi">+    # Re-register dynamic plugins, since the pool does not have access to the</span>
<span class="gi">+    # astroid module that existed when the linter was pickled.</span>
<span class="gi">+    _worker_linter.load_plugin_modules(_worker_linter._dynamic_plugins, force=True)</span>
<span class="gi">+    _worker_linter.load_plugin_configuration()</span>
<span class="gi">+</span>
<span class="gi">+    if extra_packages_paths:</span>
<span class="gi">+        _augment_sys_path(extra_packages_paths)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _worker_check_single_file(</span>
<span class="gi">+    file_item: FileItem,</span>
<span class="gi">+) -&gt; tuple[</span>
<span class="gi">+    int,</span>
<span class="gi">+    str,</span>
<span class="gi">+    str,</span>
<span class="gi">+    str,</span>
<span class="gi">+    list[Message],</span>
<span class="gi">+    LinterStats,</span>
<span class="gi">+    int,</span>
<span class="gi">+    defaultdict[str, list[Any]],</span>
<span class="gi">+]:</span>
<span class="gi">+    if not _worker_linter:</span>
<span class="gi">+        raise RuntimeError(&quot;Worker linter not yet initialised&quot;)</span>
<span class="gi">+    _worker_linter.open()</span>
<span class="gi">+    _worker_linter.check_single_file_item(file_item)</span>
<span class="gi">+    mapreduce_data = defaultdict(list)</span>
<span class="gi">+    for checker in _worker_linter.get_checkers():</span>
<span class="gi">+        data = checker.get_map_data()</span>
<span class="gi">+        if data is not None:</span>
<span class="gi">+            mapreduce_data[checker.name].append(data)</span>
<span class="gi">+    msgs = _worker_linter.reporter.messages</span>
<span class="gi">+    assert isinstance(_worker_linter.reporter, reporters.CollectingReporter)</span>
<span class="gi">+    _worker_linter.reporter.reset()</span>
<span class="gi">+    return (</span>
<span class="gi">+        id(multiprocessing.current_process()),</span>
<span class="gi">+        _worker_linter.current_name,</span>
<span class="gi">+        file_item.filepath,</span>
<span class="gi">+        _worker_linter.file_state.base_name,</span>
<span class="gi">+        msgs,</span>
<span class="gi">+        _worker_linter.stats,</span>
<span class="gi">+        _worker_linter.msg_status,</span>
<span class="gi">+        mapreduce_data,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _merge_mapreduce_data(</span>
<span class="gi">+    linter: PyLinter,</span>
<span class="gi">+    all_mapreduce_data: defaultdict[int, list[defaultdict[str, list[Any]]]],</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Merges map/reduce data across workers, invoking relevant APIs on checkers.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # First collate the data and prepare it, so we can send it to the checkers for</span>
<span class="gi">+    # validation. The intent here is to collect all the mapreduce data for all checker-</span>
<span class="gi">+    # runs across processes - that will then be passed to a static method on the</span>
<span class="gi">+    # checkers to be reduced and further processed.</span>
<span class="gi">+    collated_map_reduce_data: defaultdict[str, list[Any]] = defaultdict(list)</span>
<span class="gi">+    for linter_data in all_mapreduce_data.values():</span>
<span class="gi">+        for run_data in linter_data:</span>
<span class="gi">+            for checker_name, data in run_data.items():</span>
<span class="gi">+                collated_map_reduce_data[checker_name].extend(data)</span>
<span class="gi">+</span>
<span class="gi">+    # Send the data to checkers that support/require consolidated data</span>
<span class="gi">+    original_checkers = linter.get_checkers()</span>
<span class="gi">+    for checker in original_checkers:</span>
<span class="gi">+        if checker.name in collated_map_reduce_data:</span>
<span class="gi">+            # Assume that if the check has returned map/reduce data that it has the</span>
<span class="gi">+            # reducer function</span>
<span class="gi">+            checker.reduce_map_data(linter, collated_map_reduce_data[checker.name])</span>


<span class="gd">-def check_parallel(linter: PyLinter, jobs: int, files: Iterable[FileItem],</span>
<span class="gd">-    extra_packages_paths: (Sequence[str] | None)=None) -&gt;None:</span>
<span class="gi">+def check_parallel(</span>
<span class="gi">+    linter: PyLinter,</span>
<span class="gi">+    jobs: int,</span>
<span class="gi">+    files: Iterable[FileItem],</span>
<span class="gi">+    extra_packages_paths: Sequence[str] | None = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use the given linter to lint the files with given amount of workers (jobs).

<span class="w"> </span>    This splits the work filestream-by-filestream. If you need to do work across
<span class="w"> </span>    multiple files, as in the similarity-checker, then implement the map/reduce functionality.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # The linter is inherited by all the pool&#39;s workers, i.e. the linter</span>
<span class="gi">+    # is identical to the linter object here. This is required so that</span>
<span class="gi">+    # a custom PyLinter object can be used.</span>
<span class="gi">+    initializer = functools.partial(</span>
<span class="gi">+        _worker_initialize, extra_packages_paths=extra_packages_paths</span>
<span class="gi">+    )</span>
<span class="gi">+    with ProcessPoolExecutor(</span>
<span class="gi">+        max_workers=jobs, initializer=initializer, initargs=(dill.dumps(linter),)</span>
<span class="gi">+    ) as executor:</span>
<span class="gi">+        linter.open()</span>
<span class="gi">+        all_stats = []</span>
<span class="gi">+        all_mapreduce_data: defaultdict[int, list[defaultdict[str, list[Any]]]] = (</span>
<span class="gi">+            defaultdict(list)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Maps each file to be worked on by a single _worker_check_single_file() call,</span>
<span class="gi">+        # collecting any map/reduce data by checker module so that we can &#39;reduce&#39; it</span>
<span class="gi">+        # later.</span>
<span class="gi">+        for (</span>
<span class="gi">+            worker_idx,  # used to merge map/reduce data across workers</span>
<span class="gi">+            module,</span>
<span class="gi">+            file_path,</span>
<span class="gi">+            base_name,</span>
<span class="gi">+            messages,</span>
<span class="gi">+            stats,</span>
<span class="gi">+            msg_status,</span>
<span class="gi">+            mapreduce_data,</span>
<span class="gi">+        ) in executor.map(_worker_check_single_file, files):</span>
<span class="gi">+            linter.file_state.base_name = base_name</span>
<span class="gi">+            linter.file_state._is_base_filestate = False</span>
<span class="gi">+            linter.set_current_module(module, file_path)</span>
<span class="gi">+            for msg in messages:</span>
<span class="gi">+                linter.reporter.handle_message(msg)</span>
<span class="gi">+            all_stats.append(stats)</span>
<span class="gi">+            all_mapreduce_data[worker_idx].append(mapreduce_data)</span>
<span class="gi">+            linter.msg_status |= msg_status</span>
<span class="gi">+</span>
<span class="gi">+    _merge_mapreduce_data(linter, all_mapreduce_data)</span>
<span class="gi">+    linter.stats = merge_stats([linter.stats, *all_stats])</span>
<span class="gh">diff --git a/pylint/lint/pylinter.py b/pylint/lint/pylinter.py</span>
<span class="gh">index 3f632fa03..eff15cc44 100644</span>
<span class="gd">--- a/pylint/lint/pylinter.py</span>
<span class="gi">+++ b/pylint/lint/pylinter.py</span>
<span class="gu">@@ -1,4 +1,9 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import collections
<span class="w"> </span>import contextlib
<span class="gu">@@ -14,97 +19,245 @@ from pathlib import Path</span>
<span class="w"> </span>from re import Pattern
<span class="w"> </span>from types import ModuleType
<span class="w"> </span>from typing import Any, Protocol
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers, exceptions, interfaces, reporters
<span class="w"> </span>from pylint.checkers.base_checker import BaseChecker
<span class="w"> </span>from pylint.config.arguments_manager import _ArgumentsManager
<span class="gd">-from pylint.constants import MAIN_CHECKER_NAME, MSG_TYPES, MSG_TYPES_STATUS, WarningScope</span>
<span class="gi">+from pylint.constants import (</span>
<span class="gi">+    MAIN_CHECKER_NAME,</span>
<span class="gi">+    MSG_TYPES,</span>
<span class="gi">+    MSG_TYPES_STATUS,</span>
<span class="gi">+    WarningScope,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.interfaces import HIGH
<span class="w"> </span>from pylint.lint.base_options import _make_linter_options
<span class="w"> </span>from pylint.lint.caching import load_results, save_results
<span class="gd">-from pylint.lint.expand_modules import _is_ignored_file, discover_package_path, expand_modules</span>
<span class="gi">+from pylint.lint.expand_modules import (</span>
<span class="gi">+    _is_ignored_file,</span>
<span class="gi">+    discover_package_path,</span>
<span class="gi">+    expand_modules,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.lint.message_state_handler import _MessageStateHandler
<span class="w"> </span>from pylint.lint.parallel import check_parallel
<span class="gd">-from pylint.lint.report_functions import report_messages_by_module_stats, report_messages_stats, report_total_messages_stats</span>
<span class="gd">-from pylint.lint.utils import _is_relative_to, augmented_sys_path, get_fatal_error_message, prepare_crash_report</span>
<span class="gi">+from pylint.lint.report_functions import (</span>
<span class="gi">+    report_messages_by_module_stats,</span>
<span class="gi">+    report_messages_stats,</span>
<span class="gi">+    report_total_messages_stats,</span>
<span class="gi">+)</span>
<span class="gi">+from pylint.lint.utils import (</span>
<span class="gi">+    _is_relative_to,</span>
<span class="gi">+    augmented_sys_path,</span>
<span class="gi">+    get_fatal_error_message,</span>
<span class="gi">+    prepare_crash_report,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.message import Message, MessageDefinition, MessageDefinitionStore
<span class="w"> </span>from pylint.reporters.base_reporter import BaseReporter
<span class="w"> </span>from pylint.reporters.text import TextReporter
<span class="w"> </span>from pylint.reporters.ureports import nodes as report_nodes
<span class="gd">-from pylint.typing import DirectoryNamespaceDict, FileItem, ManagedMessage, MessageDefinitionTuple, MessageLocationTuple, ModuleDescriptionDict, Options</span>
<span class="gi">+from pylint.typing import (</span>
<span class="gi">+    DirectoryNamespaceDict,</span>
<span class="gi">+    FileItem,</span>
<span class="gi">+    ManagedMessage,</span>
<span class="gi">+    MessageDefinitionTuple,</span>
<span class="gi">+    MessageLocationTuple,</span>
<span class="gi">+    ModuleDescriptionDict,</span>
<span class="gi">+    Options,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.utils import ASTWalker, FileState, LinterStats, utils
<span class="gi">+</span>
<span class="w"> </span>MANAGER = astroid.MANAGER


<span class="w"> </span>class GetAstProtocol(Protocol):
<span class="gd">-</span>
<span class="gd">-    def __call__(self, filepath: str, modname: str, data: (str | None)=None</span>
<span class="gd">-        ) -&gt;nodes.Module:</span>
<span class="gd">-        ...</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-MSGS: dict[str, MessageDefinitionTuple] = {&#39;F0001&#39;: (&#39;%s&#39;, &#39;fatal&#39;,</span>
<span class="gd">-    &#39;Used when an error occurred preventing the analysis of a               module (unable to find it for instance).&#39;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE}), &#39;F0002&#39;: (&#39;%s: %s&#39;, &#39;astroid-error&#39;,</span>
<span class="gd">-    &#39;Used when an unexpected error occurred while building the Astroid  representation. This is usually accompanied by a traceback. Please report such errors !&#39;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE}), &#39;F0010&#39;: (</span>
<span class="gd">-    &#39;error while code parsing: %s&#39;, &#39;parse-error&#39;,</span>
<span class="gd">-    &#39;Used when an exception occurred while building the Astroid representation which could be handled by astroid.&#39;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE}), &#39;F0011&#39;: (</span>
<span class="gd">-    &#39;error while parsing the configuration: %s&#39;, &#39;config-parse-error&#39;,</span>
<span class="gd">-    &#39;Used when an exception occurred while parsing a pylint configuration file.&#39;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE}), &#39;I0001&#39;: (</span>
<span class="gd">-    &#39;Unable to run raw checkers on built-in module %s&#39;,</span>
<span class="gd">-    &#39;raw-checker-failed&#39;,</span>
<span class="gd">-    &#39;Used to inform that a built-in module has not been checked using the raw checkers.&#39;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE, &#39;default_enabled&#39;: False}), &#39;I0010&#39;: (</span>
<span class="gd">-    &#39;Unable to consider inline option %r&#39;, &#39;bad-inline-option&#39;,</span>
<span class="gd">-    &quot;Used when an inline option is either badly formatted or can&#39;t be used inside modules.&quot;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE, &#39;default_enabled&#39;: False}), &#39;I0011&#39;: (</span>
<span class="gd">-    &#39;Locally disabling %s (%s)&#39;, &#39;locally-disabled&#39;,</span>
<span class="gd">-    &#39;Used when an inline option disables a message or a messages category.&#39;,</span>
<span class="gd">-    {&#39;scope&#39;: WarningScope.LINE, &#39;default_enabled&#39;: False}), &#39;I0013&#39;: (</span>
<span class="gd">-    &#39;Ignoring entire file&#39;, &#39;file-ignored&#39;,</span>
<span class="gd">-    &#39;Used to inform that the file will not be checked&#39;, {&#39;scope&#39;:</span>
<span class="gd">-    WarningScope.LINE, &#39;default_enabled&#39;: False}), &#39;I0020&#39;: (</span>
<span class="gd">-    &#39;Suppressed %s (from line %d)&#39;, &#39;suppressed-message&#39;,</span>
<span class="gd">-    &#39;A message was triggered on a line, but suppressed explicitly by a disable= comment in the file. This message is not generated for messages that are ignored due to configuration settings.&#39;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE, &#39;default_enabled&#39;: False}), &#39;I0021&#39;: (</span>
<span class="gd">-    &#39;Useless suppression of %s&#39;, &#39;useless-suppression&#39;,</span>
<span class="gd">-    &#39;Reported when a message is explicitly disabled for a line or a block of code, but never triggered.&#39;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE, &#39;default_enabled&#39;: False}), &#39;I0022&#39;: (</span>
<span class="gd">-    &#39;Pragma &quot;%s&quot; is deprecated, use &quot;%s&quot; instead&#39;, &#39;deprecated-pragma&#39;,</span>
<span class="gd">-    &#39;Some inline pylint options have been renamed or reworked, only the most recent form should be used. NOTE:skip-all is only available with pylint &gt;= 0.26&#39;</span>
<span class="gd">-    , {&#39;old_names&#39;: [(&#39;I0014&#39;, &#39;deprecated-disable-all&#39;)], &#39;scope&#39;:</span>
<span class="gd">-    WarningScope.LINE, &#39;default_enabled&#39;: False}), &#39;E0001&#39;: (&#39;%s&#39;,</span>
<span class="gd">-    &#39;syntax-error&#39;, &#39;Used when a syntax error is raised for a module.&#39;, {</span>
<span class="gd">-    &#39;scope&#39;: WarningScope.LINE}), &#39;E0011&#39;: (&#39;Unrecognized file option %r&#39;,</span>
<span class="gd">-    &#39;unrecognized-inline-option&#39;,</span>
<span class="gd">-    &#39;Used when an unknown inline option is encountered.&#39;, {&#39;scope&#39;:</span>
<span class="gd">-    WarningScope.LINE}), &#39;W0012&#39;: (</span>
<span class="gd">-    &quot;Unknown option value for &#39;%s&#39;, expected a valid pylint message and got &#39;%s&#39;&quot;</span>
<span class="gd">-    , &#39;unknown-option-value&#39;,</span>
<span class="gd">-    &#39;Used when an unknown value is encountered for an option.&#39;, {&#39;scope&#39;:</span>
<span class="gd">-    WarningScope.LINE, &#39;old_names&#39;: [(&#39;E0012&#39;, &#39;bad-option-value&#39;)]}),</span>
<span class="gd">-    &#39;R0022&#39;: (&quot;Useless option value for &#39;%s&#39;, %s&quot;, &#39;useless-option-value&#39;,</span>
<span class="gd">-    &#39;Used when a value for an option that is now deleted from pylint is encountered.&#39;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE, &#39;old_names&#39;: [(&#39;E0012&#39;,</span>
<span class="gd">-    &#39;bad-option-value&#39;)]}), &#39;E0013&#39;: (</span>
<span class="gd">-    &quot;Plugin &#39;%s&#39; is impossible to load, is it installed ? (&#39;%s&#39;)&quot;,</span>
<span class="gd">-    &#39;bad-plugin-value&#39;, &quot;Used when a bad value is used in &#39;load-plugins&#39;.&quot;,</span>
<span class="gd">-    {&#39;scope&#39;: WarningScope.LINE}), &#39;E0014&#39;: (</span>
<span class="gd">-    &quot;Out-of-place setting encountered in top level configuration-section &#39;%s&#39; : &#39;%s&#39;&quot;</span>
<span class="gd">-    , &#39;bad-configuration-section&#39;,</span>
<span class="gd">-    &quot;Used when we detect a setting in the top level of a toml configuration that shouldn&#39;t be there.&quot;</span>
<span class="gd">-    , {&#39;scope&#39;: WarningScope.LINE}), &#39;E0015&#39;: (</span>
<span class="gd">-    &#39;Unrecognized option found: %s&#39;, &#39;unrecognized-option&#39;,</span>
<span class="gd">-    &#39;Used when we detect an option that we do not recognize.&#39;, {&#39;scope&#39;:</span>
<span class="gd">-    WarningScope.LINE})}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="gd">-    ReportsHandlerMixIn, checkers.BaseChecker):</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, filepath: str, modname: str, data: str | None = None</span>
<span class="gi">+    ) -&gt; nodes.Module: ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _read_stdin() -&gt; str:</span>
<span class="gi">+    # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion</span>
<span class="gi">+    assert isinstance(sys.stdin, TextIOWrapper)</span>
<span class="gi">+    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=&quot;utf-8&quot;)</span>
<span class="gi">+    return sys.stdin.read()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_reporter_by_class(reporter_class: str) -&gt; type[BaseReporter]:</span>
<span class="gi">+    qname = reporter_class</span>
<span class="gi">+    module_part = astroid.modutils.get_module_part(qname)</span>
<span class="gi">+    module = astroid.modutils.load_module_from_name(module_part)</span>
<span class="gi">+    class_name = qname.split(&quot;.&quot;)[-1]</span>
<span class="gi">+    klass = getattr(module, class_name)</span>
<span class="gi">+    assert issubclass(klass, BaseReporter), f&quot;{klass} is not a BaseReporter&quot;</span>
<span class="gi">+    return klass  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Python Linter class #########################################################</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable-next=consider-using-namedtuple-or-dataclass</span>
<span class="gi">+MSGS: dict[str, MessageDefinitionTuple] = {</span>
<span class="gi">+    &quot;F0001&quot;: (</span>
<span class="gi">+        &quot;%s&quot;,</span>
<span class="gi">+        &quot;fatal&quot;,</span>
<span class="gi">+        &quot;Used when an error occurred preventing the analysis of a \</span>
<span class="gi">+              module (unable to find it for instance).&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.LINE},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;F0002&quot;: (</span>
<span class="gi">+        &quot;%s: %s&quot;,</span>
<span class="gi">+        &quot;astroid-error&quot;,</span>
<span class="gi">+        &quot;Used when an unexpected error occurred while building the &quot;</span>
<span class="gi">+        &quot;Astroid  representation. This is usually accompanied by a &quot;</span>
<span class="gi">+        &quot;traceback. Please report such errors !&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.LINE},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;F0010&quot;: (</span>
<span class="gi">+        &quot;error while code parsing: %s&quot;,</span>
<span class="gi">+        &quot;parse-error&quot;,</span>
<span class="gi">+        &quot;Used when an exception occurred while building the Astroid &quot;</span>
<span class="gi">+        &quot;representation which could be handled by astroid.&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.LINE},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;F0011&quot;: (</span>
<span class="gi">+        &quot;error while parsing the configuration: %s&quot;,</span>
<span class="gi">+        &quot;config-parse-error&quot;,</span>
<span class="gi">+        &quot;Used when an exception occurred while parsing a pylint configuration file.&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.LINE},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;I0001&quot;: (</span>
<span class="gi">+        &quot;Unable to run raw checkers on built-in module %s&quot;,</span>
<span class="gi">+        &quot;raw-checker-failed&quot;,</span>
<span class="gi">+        &quot;Used to inform that a built-in module has not been checked &quot;</span>
<span class="gi">+        &quot;using the raw checkers.&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;scope&quot;: WarningScope.LINE,</span>
<span class="gi">+            &quot;default_enabled&quot;: False,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;I0010&quot;: (</span>
<span class="gi">+        &quot;Unable to consider inline option %r&quot;,</span>
<span class="gi">+        &quot;bad-inline-option&quot;,</span>
<span class="gi">+        &quot;Used when an inline option is either badly formatted or can&#39;t &quot;</span>
<span class="gi">+        &quot;be used inside modules.&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;scope&quot;: WarningScope.LINE,</span>
<span class="gi">+            &quot;default_enabled&quot;: False,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;I0011&quot;: (</span>
<span class="gi">+        &quot;Locally disabling %s (%s)&quot;,</span>
<span class="gi">+        &quot;locally-disabled&quot;,</span>
<span class="gi">+        &quot;Used when an inline option disables a message or a messages category.&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;scope&quot;: WarningScope.LINE,</span>
<span class="gi">+            &quot;default_enabled&quot;: False,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;I0013&quot;: (</span>
<span class="gi">+        &quot;Ignoring entire file&quot;,</span>
<span class="gi">+        &quot;file-ignored&quot;,</span>
<span class="gi">+        &quot;Used to inform that the file will not be checked&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;scope&quot;: WarningScope.LINE,</span>
<span class="gi">+            &quot;default_enabled&quot;: False,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;I0020&quot;: (</span>
<span class="gi">+        &quot;Suppressed %s (from line %d)&quot;,</span>
<span class="gi">+        &quot;suppressed-message&quot;,</span>
<span class="gi">+        &quot;A message was triggered on a line, but suppressed explicitly &quot;</span>
<span class="gi">+        &quot;by a disable= comment in the file. This message is not &quot;</span>
<span class="gi">+        &quot;generated for messages that are ignored due to configuration &quot;</span>
<span class="gi">+        &quot;settings.&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;scope&quot;: WarningScope.LINE,</span>
<span class="gi">+            &quot;default_enabled&quot;: False,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;I0021&quot;: (</span>
<span class="gi">+        &quot;Useless suppression of %s&quot;,</span>
<span class="gi">+        &quot;useless-suppression&quot;,</span>
<span class="gi">+        &quot;Reported when a message is explicitly disabled for a line or &quot;</span>
<span class="gi">+        &quot;a block of code, but never triggered.&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;scope&quot;: WarningScope.LINE,</span>
<span class="gi">+            &quot;default_enabled&quot;: False,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;I0022&quot;: (</span>
<span class="gi">+        &#39;Pragma &quot;%s&quot; is deprecated, use &quot;%s&quot; instead&#39;,</span>
<span class="gi">+        &quot;deprecated-pragma&quot;,</span>
<span class="gi">+        &quot;Some inline pylint options have been renamed or reworked, &quot;</span>
<span class="gi">+        &quot;only the most recent form should be used. &quot;</span>
<span class="gi">+        &quot;NOTE:skip-all is only available with pylint &gt;= 0.26&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;old_names&quot;: [(&quot;I0014&quot;, &quot;deprecated-disable-all&quot;)],</span>
<span class="gi">+            &quot;scope&quot;: WarningScope.LINE,</span>
<span class="gi">+            &quot;default_enabled&quot;: False,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0001&quot;: (</span>
<span class="gi">+        &quot;%s&quot;,</span>
<span class="gi">+        &quot;syntax-error&quot;,</span>
<span class="gi">+        &quot;Used when a syntax error is raised for a module.&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.LINE},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0011&quot;: (</span>
<span class="gi">+        &quot;Unrecognized file option %r&quot;,</span>
<span class="gi">+        &quot;unrecognized-inline-option&quot;,</span>
<span class="gi">+        &quot;Used when an unknown inline option is encountered.&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.LINE},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;W0012&quot;: (</span>
<span class="gi">+        &quot;Unknown option value for &#39;%s&#39;, expected a valid pylint message and got &#39;%s&#39;&quot;,</span>
<span class="gi">+        &quot;unknown-option-value&quot;,</span>
<span class="gi">+        &quot;Used when an unknown value is encountered for an option.&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;scope&quot;: WarningScope.LINE,</span>
<span class="gi">+            &quot;old_names&quot;: [(&quot;E0012&quot;, &quot;bad-option-value&quot;)],</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;R0022&quot;: (</span>
<span class="gi">+        &quot;Useless option value for &#39;%s&#39;, %s&quot;,</span>
<span class="gi">+        &quot;useless-option-value&quot;,</span>
<span class="gi">+        &quot;Used when a value for an option that is now deleted from pylint&quot;</span>
<span class="gi">+        &quot; is encountered.&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;scope&quot;: WarningScope.LINE,</span>
<span class="gi">+            &quot;old_names&quot;: [(&quot;E0012&quot;, &quot;bad-option-value&quot;)],</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0013&quot;: (</span>
<span class="gi">+        &quot;Plugin &#39;%s&#39; is impossible to load, is it installed ? (&#39;%s&#39;)&quot;,</span>
<span class="gi">+        &quot;bad-plugin-value&quot;,</span>
<span class="gi">+        &quot;Used when a bad value is used in &#39;load-plugins&#39;.&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.LINE},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0014&quot;: (</span>
<span class="gi">+        &quot;Out-of-place setting encountered in top level configuration-section &#39;%s&#39; : &#39;%s&#39;&quot;,</span>
<span class="gi">+        &quot;bad-configuration-section&quot;,</span>
<span class="gi">+        &quot;Used when we detect a setting in the top level of a toml configuration that&quot;</span>
<span class="gi">+        &quot; shouldn&#39;t be there.&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.LINE},</span>
<span class="gi">+    ),</span>
<span class="gi">+    &quot;E0015&quot;: (</span>
<span class="gi">+        &quot;Unrecognized option found: %s&quot;,</span>
<span class="gi">+        &quot;unrecognized-option&quot;,</span>
<span class="gi">+        &quot;Used when we detect an option that we do not recognize.&quot;,</span>
<span class="gi">+        {&quot;scope&quot;: WarningScope.LINE},</span>
<span class="gi">+    ),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=too-many-instance-attributes,too-many-public-methods</span>
<span class="gi">+class PyLinter(</span>
<span class="gi">+    _ArgumentsManager,</span>
<span class="gi">+    _MessageStateHandler,</span>
<span class="gi">+    reporters.ReportsHandlerMixIn,</span>
<span class="gi">+    checkers.BaseChecker,</span>
<span class="gi">+):</span>
<span class="w"> </span>    &quot;&quot;&quot;Lint Python modules using external checkers.

<span class="w"> </span>    This is the main checker controlling the other ones and the reports
<span class="gu">@@ -120,18 +273,32 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>    This class needs to support pickling for parallel linting to work. The exception
<span class="w"> </span>    is reporter member; see check_parallel function for more details.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = MAIN_CHECKER_NAME
<span class="w"> </span>    msgs = MSGS
<span class="gd">-    crash_file_path: str = &#39;pylint-crash-%Y-%m-%d-%H-%M-%S.txt&#39;</span>
<span class="gd">-    option_groups_descs = {&#39;Messages control&#39;:</span>
<span class="gd">-        &#39;Options controlling analysis messages&#39;, &#39;Reports&#39;:</span>
<span class="gd">-        &#39;Options related to output formatting and reporting&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options: Options=(), reporter: (reporters.</span>
<span class="gd">-        BaseReporter | reporters.MultiReporter | None)=None, option_groups:</span>
<span class="gd">-        tuple[tuple[str, str], ...]=(), pylintrc: (str | None)=None) -&gt;None:</span>
<span class="gd">-        _ArgumentsManager.__init__(self, prog=&#39;pylint&#39;)</span>
<span class="gi">+    # Will be used like this : datetime.now().strftime(crash_file_path)</span>
<span class="gi">+    crash_file_path: str = &quot;pylint-crash-%Y-%m-%d-%H-%M-%S.txt&quot;</span>
<span class="gi">+</span>
<span class="gi">+    option_groups_descs = {</span>
<span class="gi">+        &quot;Messages control&quot;: &quot;Options controlling analysis messages&quot;,</span>
<span class="gi">+        &quot;Reports&quot;: &quot;Options related to output formatting and reporting&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        options: Options = (),</span>
<span class="gi">+        reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,</span>
<span class="gi">+        option_groups: tuple[tuple[str, str], ...] = (),</span>
<span class="gi">+        # TODO: Deprecate passing the pylintrc parameter</span>
<span class="gi">+        pylintrc: str | None = None,  # pylint: disable=unused-argument</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        _ArgumentsManager.__init__(self, prog=&quot;pylint&quot;)</span>
<span class="w"> </span>        _MessageStateHandler.__init__(self, self)
<span class="gi">+</span>
<span class="gi">+        # Some stuff has to be done before initialization of other ancestors...</span>
<span class="gi">+        # messages store / checkers / reporter / astroid manager</span>
<span class="gi">+</span>
<span class="gi">+        # Attributes for reporters</span>
<span class="w"> </span>        self.reporter: reporters.BaseReporter | reporters.MultiReporter
<span class="w"> </span>        if reporter:
<span class="w"> </span>            self.set_reporter(reporter)
<span class="gu">@@ -139,41 +306,63 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>            self.set_reporter(TextReporter())
<span class="w"> </span>        self._reporters: dict[str, type[reporters.BaseReporter]] = {}
<span class="w"> </span>        &quot;&quot;&quot;Dictionary of possible but non-initialized reporters.&quot;&quot;&quot;
<span class="gd">-        self._checkers: defaultdict[str, list[checkers.BaseChecker]</span>
<span class="gd">-            ] = collections.defaultdict(list)</span>
<span class="gi">+</span>
<span class="gi">+        # Attributes for checkers and plugins</span>
<span class="gi">+        self._checkers: defaultdict[str, list[checkers.BaseChecker]] = (</span>
<span class="gi">+            collections.defaultdict(list)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        &quot;&quot;&quot;Dictionary of registered and initialized checkers.&quot;&quot;&quot;
<span class="gd">-        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError |</span>
<span class="gd">-            bool] = {}</span>
<span class="gi">+        self._dynamic_plugins: dict[str, ModuleType | ModuleNotFoundError | bool] = {}</span>
<span class="w"> </span>        &quot;&quot;&quot;Set of loaded plugin names.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+        # Attributes related to stats</span>
<span class="w"> </span>        self.stats = LinterStats()
<span class="gi">+</span>
<span class="gi">+        # Attributes related to (command-line) options and their parsing</span>
<span class="w"> </span>        self.options: Options = options + _make_linter_options(self)
<span class="w"> </span>        for opt_group in option_groups:
<span class="w"> </span>            self.option_groups_descs[opt_group[0]] = opt_group[1]
<span class="gd">-        self._option_groups: tuple[tuple[str, str], ...] = (*option_groups,</span>
<span class="gd">-            (&#39;Messages control&#39;, &#39;Options controlling analysis messages&#39;),</span>
<span class="gd">-            (&#39;Reports&#39;, &#39;Options related to output formatting and reporting&#39;))</span>
<span class="gi">+        self._option_groups: tuple[tuple[str, str], ...] = (</span>
<span class="gi">+            *option_groups,</span>
<span class="gi">+            (&quot;Messages control&quot;, &quot;Options controlling analysis messages&quot;),</span>
<span class="gi">+            (&quot;Reports&quot;, &quot;Options related to output formatting and reporting&quot;),</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.fail_on_symbols: list[str] = []
<span class="w"> </span>        &quot;&quot;&quot;List of message symbols on which pylint should fail, set by --fail-on.&quot;&quot;&quot;
<span class="w"> </span>        self._error_mode = False
<span class="gi">+</span>
<span class="w"> </span>        reporters.ReportsHandlerMixIn.__init__(self)
<span class="w"> </span>        checkers.BaseChecker.__init__(self, self)
<span class="gd">-        self.reports = (&#39;RP0001&#39;, &#39;Messages by category&#39;,</span>
<span class="gd">-            report_total_messages_stats), (&#39;RP0002&#39;,</span>
<span class="gd">-            &#39;% errors / warnings by module&#39;, report_messages_by_module_stats</span>
<span class="gd">-            ), (&#39;RP0003&#39;, &#39;Messages&#39;, report_messages_stats)</span>
<span class="gi">+        # provided reports</span>
<span class="gi">+        self.reports = (</span>
<span class="gi">+            (&quot;RP0001&quot;, &quot;Messages by category&quot;, report_total_messages_stats),</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;RP0002&quot;,</span>
<span class="gi">+                &quot;% errors / warnings by module&quot;,</span>
<span class="gi">+                report_messages_by_module_stats,</span>
<span class="gi">+            ),</span>
<span class="gi">+            (&quot;RP0003&quot;, &quot;Messages&quot;, report_messages_stats),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Attributes related to registering messages and their handling</span>
<span class="w"> </span>        self.msgs_store = MessageDefinitionStore(self.config.py_version)
<span class="w"> </span>        self.msg_status = 0
<span class="w"> </span>        self._by_id_managed_msgs: list[ManagedMessage] = []
<span class="gd">-        self.file_state = FileState(&#39;&#39;, self.msgs_store, is_base_filestate=True</span>
<span class="gd">-            )</span>
<span class="gd">-        self.current_name: str = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Attributes related to visiting files</span>
<span class="gi">+        self.file_state = FileState(&quot;&quot;, self.msgs_store, is_base_filestate=True)</span>
<span class="gi">+        self.current_name: str = &quot;&quot;</span>
<span class="w"> </span>        self.current_file: str | None = None
<span class="w"> </span>        self._ignore_file = False
<span class="w"> </span>        self._ignore_paths: list[Pattern[str]] = []
<span class="gi">+</span>
<span class="w"> </span>        self.register_checker(self)

<span class="gd">-    def load_plugin_modules(self, modnames: Iterable[str], force: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def load_default_plugins(self) -&gt; None:</span>
<span class="gi">+        checkers.initialize(self)</span>
<span class="gi">+        reporters.initialize(self)</span>
<span class="gi">+</span>
<span class="gi">+    def load_plugin_modules(self, modnames: Iterable[str], force: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check a list of pylint plugins modules, load and register them.

<span class="w"> </span>        If a module cannot be loaded, never try to load it again and instead
<span class="gu">@@ -183,9 +372,17 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>        If `force` is True (useful when multiprocessing), then the plugin is
<span class="w"> </span>        reloaded regardless if an entry exists in self._dynamic_plugins.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def load_plugin_configuration(self) -&gt;None:</span>
<span class="gi">+        for modname in modnames:</span>
<span class="gi">+            if modname in self._dynamic_plugins and not force:</span>
<span class="gi">+                continue</span>
<span class="gi">+            try:</span>
<span class="gi">+                module = astroid.modutils.load_module_from_name(modname)</span>
<span class="gi">+                module.register(self)</span>
<span class="gi">+                self._dynamic_plugins[modname] = module</span>
<span class="gi">+            except ModuleNotFoundError as mnf_e:</span>
<span class="gi">+                self._dynamic_plugins[modname] = mnf_e</span>
<span class="gi">+</span>
<span class="gi">+    def load_plugin_configuration(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call the configuration hook for plugins.

<span class="w"> </span>        This walks through the list of plugins, grabs the &quot;load_configuration&quot;
<span class="gu">@@ -201,60 +398,190 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>            in GitHub issue #7264. Making it use the stored result is more efficient, and
<span class="w"> </span>            means that we avoid the ``init-hook`` problems from before.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _load_reporters(self, reporter_names: str) -&gt;None:</span>
<span class="gi">+        for modname, module_or_error in self._dynamic_plugins.items():</span>
<span class="gi">+            if isinstance(module_or_error, ModuleNotFoundError):</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;bad-plugin-value&quot;, args=(modname, module_or_error), line=0</span>
<span class="gi">+                )</span>
<span class="gi">+            elif hasattr(module_or_error, &quot;load_configuration&quot;):</span>
<span class="gi">+                module_or_error.load_configuration(self)</span>
<span class="gi">+</span>
<span class="gi">+        # We re-set all the dictionary values to True here to make sure the dict</span>
<span class="gi">+        # is pickle-able. This is only a problem in multiprocessing/parallel mode.</span>
<span class="gi">+        # (e.g. invoking pylint -j 2)</span>
<span class="gi">+        self._dynamic_plugins = {</span>
<span class="gi">+            modname: not isinstance(val, ModuleNotFoundError)</span>
<span class="gi">+            for modname, val in self._dynamic_plugins.items()</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def _load_reporters(self, reporter_names: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load the reporters if they are available on _reporters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._reporters:</span>
<span class="gi">+            return</span>
<span class="gi">+        sub_reporters = []</span>
<span class="gi">+        output_files = []</span>
<span class="gi">+        with contextlib.ExitStack() as stack:</span>
<span class="gi">+            for reporter_name in reporter_names.split(&quot;,&quot;):</span>
<span class="gi">+                reporter_name, *reporter_output = reporter_name.split(&quot;:&quot;, 1)</span>
<span class="gi">+</span>
<span class="gi">+                reporter = self._load_reporter_by_name(reporter_name)</span>
<span class="gi">+                sub_reporters.append(reporter)</span>
<span class="gi">+                if reporter_output:</span>
<span class="gi">+                    output_file = stack.enter_context(</span>
<span class="gi">+                        open(reporter_output[0], &quot;w&quot;, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+                    )</span>
<span class="gi">+                    reporter.out = output_file</span>
<span class="gi">+                    output_files.append(output_file)</span>
<span class="gi">+</span>
<span class="gi">+            # Extend the lifetime of all opened output files</span>
<span class="gi">+            close_output_files = stack.pop_all().close</span>
<span class="gi">+</span>
<span class="gi">+        if len(sub_reporters) &gt; 1 or output_files:</span>
<span class="gi">+            self.set_reporter(</span>
<span class="gi">+                reporters.MultiReporter(</span>
<span class="gi">+                    sub_reporters,</span>
<span class="gi">+                    close_output_files,</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.set_reporter(sub_reporters[0])</span>
<span class="gi">+</span>
<span class="gi">+    def _load_reporter_by_name(self, reporter_name: str) -&gt; reporters.BaseReporter:</span>
<span class="gi">+        name = reporter_name.lower()</span>
<span class="gi">+        if name in self._reporters:</span>
<span class="gi">+            return self._reporters[name]()</span>

<span class="gd">-    def set_reporter(self, reporter: (reporters.BaseReporter | reporters.</span>
<span class="gd">-        MultiReporter)) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            reporter_class = _load_reporter_by_class(reporter_name)</span>
<span class="gi">+        except (ImportError, AttributeError, AssertionError) as e:</span>
<span class="gi">+            raise exceptions.InvalidReporterError(name) from e</span>
<span class="gi">+</span>
<span class="gi">+        return reporter_class()</span>
<span class="gi">+</span>
<span class="gi">+    def set_reporter(</span>
<span class="gi">+        self, reporter: reporters.BaseReporter | reporters.MultiReporter</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the reporter used to display messages and reports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.reporter = reporter</span>
<span class="gi">+        reporter.linter = self</span>

<span class="gd">-    def register_reporter(self, reporter_class: type[reporters.BaseReporter]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def register_reporter(self, reporter_class: type[reporters.BaseReporter]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Registers a reporter class on the _reporters attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._reporters[reporter_class.name] = reporter_class</span>
<span class="gi">+</span>
<span class="gi">+    def report_order(self) -&gt; list[BaseChecker]:</span>
<span class="gi">+        reports = sorted(self._reports, key=lambda x: getattr(x, &quot;name&quot;, &quot;&quot;))</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Remove the current reporter and add it</span>
<span class="gi">+            # at the end of the list.</span>
<span class="gi">+            reports.pop(reports.index(self))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            reports.append(self)</span>
<span class="gi">+        return reports</span>

<span class="gd">-    def register_checker(self, checker: checkers.BaseChecker) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;This method auto registers the checker.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    # checkers manipulation methods ############################################</span>

<span class="gd">-    def enable_fail_on_messages(self) -&gt;None:</span>
<span class="gi">+    def register_checker(self, checker: checkers.BaseChecker) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;This method auto registers the checker.&quot;&quot;&quot;</span>
<span class="gi">+        self._checkers[checker.name].append(checker)</span>
<span class="gi">+        for r_id, r_title, r_cb in checker.reports:</span>
<span class="gi">+            self.register_report(r_id, r_title, r_cb, checker)</span>
<span class="gi">+        if hasattr(checker, &quot;msgs&quot;):</span>
<span class="gi">+            self.msgs_store.register_messages_from_checker(checker)</span>
<span class="gi">+            for message in checker.messages:</span>
<span class="gi">+                if not message.default_enabled:</span>
<span class="gi">+                    self.disable(message.msgid)</span>
<span class="gi">+        # Register the checker, but disable all of its messages.</span>
<span class="gi">+        if not getattr(checker, &quot;enabled&quot;, True):</span>
<span class="gi">+            self.disable(checker.name)</span>
<span class="gi">+</span>
<span class="gi">+    def enable_fail_on_messages(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Enable &#39;fail on&#39; msgs.

<span class="w"> </span>        Convert values in config.fail_on (which might be msg category, msg id,
<span class="w"> </span>        or symbol) to specific msgs, then enable and flag them for later.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def disable_reporters(self) -&gt;None:</span>
<span class="gi">+        fail_on_vals = self.config.fail_on</span>
<span class="gi">+        if not fail_on_vals:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        fail_on_cats = set()</span>
<span class="gi">+        fail_on_msgs = set()</span>
<span class="gi">+        for val in fail_on_vals:</span>
<span class="gi">+            # If value is a category, add category, else add message</span>
<span class="gi">+            if val in MSG_TYPES:</span>
<span class="gi">+                fail_on_cats.add(val)</span>
<span class="gi">+            else:</span>
<span class="gi">+                fail_on_msgs.add(val)</span>
<span class="gi">+</span>
<span class="gi">+        # For every message in every checker, if cat or msg flagged, enable check</span>
<span class="gi">+        for all_checkers in self._checkers.values():</span>
<span class="gi">+            for checker in all_checkers:</span>
<span class="gi">+                for msg in checker.messages:</span>
<span class="gi">+                    if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:</span>
<span class="gi">+                        # message id/symbol matched, enable and flag it</span>
<span class="gi">+                        self.enable(msg.msgid)</span>
<span class="gi">+                        self.fail_on_symbols.append(msg.symbol)</span>
<span class="gi">+                    elif msg.msgid[0] in fail_on_cats:</span>
<span class="gi">+                        # message starts with a category value, flag (but do not enable) it</span>
<span class="gi">+                        self.fail_on_symbols.append(msg.symbol)</span>
<span class="gi">+</span>
<span class="gi">+    def any_fail_on_issues(self) -&gt; bool:</span>
<span class="gi">+        return any(x in self.fail_on_symbols for x in self.stats.by_msg.keys())</span>
<span class="gi">+</span>
<span class="gi">+    def disable_reporters(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Disable all reporters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for _reporters in self._reports.values():</span>
<span class="gi">+            for report_id, _, _ in _reporters:</span>
<span class="gi">+                self.disable_report(report_id)</span>

<span class="gd">-    def _parse_error_mode(self) -&gt;None:</span>
<span class="gi">+    def _parse_error_mode(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the current state of the error mode.

<span class="w"> </span>        Error mode: enable only errors; no reports, no persistent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._error_mode:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self.disable_noerror_messages()</span>
<span class="gi">+        self.disable(&quot;miscellaneous&quot;)</span>
<span class="gi">+        self.set_option(&quot;reports&quot;, False)</span>
<span class="gi">+        self.set_option(&quot;persistent&quot;, False)</span>
<span class="gi">+        self.set_option(&quot;score&quot;, False)</span>
<span class="gi">+</span>
<span class="gi">+    # code checking methods ###################################################</span>

<span class="gd">-    def get_checkers(self) -&gt;list[BaseChecker]:</span>
<span class="gi">+    def get_checkers(self) -&gt; list[BaseChecker]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return all available checkers as an ordered list.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return sorted(c for _checkers in self._checkers.values() for c in _checkers)</span>

<span class="gd">-    def get_checker_names(self) -&gt;list[str]:</span>
<span class="gi">+    def get_checker_names(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get all the checker names that this linter knows about.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def prepare_checkers(self) -&gt;list[BaseChecker]:</span>
<span class="gi">+        return sorted(</span>
<span class="gi">+            {</span>
<span class="gi">+                checker.name</span>
<span class="gi">+                for checker in self.get_checkers()</span>
<span class="gi">+                if checker.name != MAIN_CHECKER_NAME</span>
<span class="gi">+            }</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def prepare_checkers(self) -&gt; list[BaseChecker]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return checkers needed for activated messages and reports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gi">+        if not self.config.reports:</span>
<span class="gi">+            self.disable_reporters()</span>
<span class="gi">+        # get needed checkers</span>
<span class="gi">+        needed_checkers: list[BaseChecker] = [self]</span>
<span class="gi">+        for checker in self.get_checkers()[1:]:</span>
<span class="gi">+            messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}</span>
<span class="gi">+            if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):</span>
<span class="gi">+                needed_checkers.append(checker)</span>
<span class="gi">+        return needed_checkers</span>
<span class="gi">+</span>
<span class="gi">+    # pylint: disable=unused-argument</span>
<span class="w"> </span>    @staticmethod
<span class="gd">-    def should_analyze_file(modname: str, path: str, is_argument: bool=False</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def should_analyze_file(modname: str, path: str, is_argument: bool = False) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns whether a module should be checked.

<span class="w"> </span>        This implementation returns True for all python source files (.py and .pyi),
<span class="gu">@@ -270,50 +597,176 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>                                 checked, since the user requested it explicitly.
<span class="w"> </span>        :returns: True if the module should be checked.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if is_argument:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return path.endswith((&quot;.py&quot;, &quot;.pyi&quot;))</span>

<span class="gd">-    def initialize(self) -&gt;None:</span>
<span class="gi">+    # pylint: enable=unused-argument</span>
<span class="gi">+</span>
<span class="gi">+    def initialize(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize linter for linting.

<span class="w"> </span>        This method is called before any linting is done.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _discover_files(self, files_or_modules: Sequence[str]) -&gt;Iterator[str]:</span>
<span class="gi">+        self._ignore_paths = self.config.ignore_paths</span>
<span class="gi">+        # initialize msgs_state now that all messages have been registered into</span>
<span class="gi">+        # the store</span>
<span class="gi">+        for msg in self.msgs_store.messages:</span>
<span class="gi">+            if not msg.may_be_emitted(self.config.py_version):</span>
<span class="gi">+                self._msgs_state[msg.msgid] = False</span>
<span class="gi">+</span>
<span class="gi">+    def _discover_files(self, files_or_modules: Sequence[str]) -&gt; Iterator[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Discover python modules and packages in sub-directory.

<span class="w"> </span>        Returns iterator of paths to discovered modules and packages.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def check(self, files_or_modules: Sequence[str]) -&gt;None:</span>
<span class="gi">+        for something in files_or_modules:</span>
<span class="gi">+            if os.path.isdir(something) and not os.path.isfile(</span>
<span class="gi">+                os.path.join(something, &quot;__init__.py&quot;)</span>
<span class="gi">+            ):</span>
<span class="gi">+                skip_subtrees: list[str] = []</span>
<span class="gi">+                for root, _, files in os.walk(something):</span>
<span class="gi">+                    if any(root.startswith(s) for s in skip_subtrees):</span>
<span class="gi">+                        # Skip subtree of already discovered package.</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if _is_ignored_file(</span>
<span class="gi">+                        root,</span>
<span class="gi">+                        self.config.ignore,</span>
<span class="gi">+                        self.config.ignore_patterns,</span>
<span class="gi">+                        self.config.ignore_paths,</span>
<span class="gi">+                    ):</span>
<span class="gi">+                        skip_subtrees.append(root)</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    if &quot;__init__.py&quot; in files:</span>
<span class="gi">+                        skip_subtrees.append(root)</span>
<span class="gi">+                        yield root</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield from (</span>
<span class="gi">+                            os.path.join(root, file)</span>
<span class="gi">+                            for file in files</span>
<span class="gi">+                            if file.endswith((&quot;.py&quot;, &quot;.pyi&quot;))</span>
<span class="gi">+                        )</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield something</span>
<span class="gi">+</span>
<span class="gi">+    def check(self, files_or_modules: Sequence[str]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Main checking entry: check a list of files or modules from their name.

<span class="w"> </span>        files_or_modules is either a string or list of strings presenting modules to check.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_asts(self, fileitems: Iterator[FileItem], data: (str | None)</span>
<span class="gd">-        ) -&gt;dict[FileItem, nodes.Module | None]:</span>
<span class="gi">+        self.initialize()</span>
<span class="gi">+        if self.config.recursive:</span>
<span class="gi">+            files_or_modules = tuple(self._discover_files(files_or_modules))</span>
<span class="gi">+        if self.config.from_stdin:</span>
<span class="gi">+            if len(files_or_modules) != 1:</span>
<span class="gi">+                raise exceptions.InvalidArgsError(</span>
<span class="gi">+                    &quot;Missing filename required for --from-stdin&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        extra_packages_paths = list(</span>
<span class="gi">+            {</span>
<span class="gi">+                discover_package_path(file_or_module, self.config.source_roots)</span>
<span class="gi">+                for file_or_module in files_or_modules</span>
<span class="gi">+            }</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # TODO: Move the parallel invocation into step 3 of the checking process</span>
<span class="gi">+        if not self.config.from_stdin and self.config.jobs &gt; 1:</span>
<span class="gi">+            original_sys_path = sys.path[:]</span>
<span class="gi">+            check_parallel(</span>
<span class="gi">+                self,</span>
<span class="gi">+                self.config.jobs,</span>
<span class="gi">+                self._iterate_file_descrs(files_or_modules),</span>
<span class="gi">+                extra_packages_paths,</span>
<span class="gi">+            )</span>
<span class="gi">+            sys.path = original_sys_path</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # 1) Get all FileItems</span>
<span class="gi">+        with augmented_sys_path(extra_packages_paths):</span>
<span class="gi">+            if self.config.from_stdin:</span>
<span class="gi">+                fileitems = self._get_file_descr_from_stdin(files_or_modules[0])</span>
<span class="gi">+                data: str | None = _read_stdin()</span>
<span class="gi">+            else:</span>
<span class="gi">+                fileitems = self._iterate_file_descrs(files_or_modules)</span>
<span class="gi">+                data = None</span>
<span class="gi">+</span>
<span class="gi">+        # The contextmanager also opens all checkers and sets up the PyLinter class</span>
<span class="gi">+        with augmented_sys_path(extra_packages_paths):</span>
<span class="gi">+            with self._astroid_module_checker() as check_astroid_module:</span>
<span class="gi">+                # 2) Get the AST for each FileItem</span>
<span class="gi">+                ast_per_fileitem = self._get_asts(fileitems, data)</span>
<span class="gi">+</span>
<span class="gi">+                # 3) Lint each ast</span>
<span class="gi">+                self._lint_files(ast_per_fileitem, check_astroid_module)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_asts(</span>
<span class="gi">+        self, fileitems: Iterator[FileItem], data: str | None</span>
<span class="gi">+    ) -&gt; dict[FileItem, nodes.Module | None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the AST for all given FileItems.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def check_single_file_item(self, file: FileItem) -&gt;None:</span>
<span class="gi">+        ast_per_fileitem: dict[FileItem, nodes.Module | None] = {}</span>
<span class="gi">+</span>
<span class="gi">+        for fileitem in fileitems:</span>
<span class="gi">+            self.set_current_module(fileitem.name, fileitem.filepath)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                ast_per_fileitem[fileitem] = self.get_ast(</span>
<span class="gi">+                    fileitem.filepath, fileitem.name, data</span>
<span class="gi">+                )</span>
<span class="gi">+            except astroid.AstroidBuildingError as ex:</span>
<span class="gi">+                template_path = prepare_crash_report(</span>
<span class="gi">+                    ex, fileitem.filepath, self.crash_file_path</span>
<span class="gi">+                )</span>
<span class="gi">+                msg = get_fatal_error_message(fileitem.filepath, template_path)</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    &quot;astroid-error&quot;,</span>
<span class="gi">+                    args=(fileitem.filepath, msg),</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        return ast_per_fileitem</span>
<span class="gi">+</span>
<span class="gi">+    def check_single_file_item(self, file: FileItem) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check single file item.

<span class="w"> </span>        The arguments are the same that are documented in _check_files

<span class="w"> </span>        initialize() should be called before calling this method
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _lint_files(self, ast_mapping: dict[FileItem, nodes.Module | None],</span>
<span class="gd">-        check_astroid_module: Callable[[nodes.Module], bool | None]) -&gt;None:</span>
<span class="gi">+        with self._astroid_module_checker() as check_astroid_module:</span>
<span class="gi">+            self._check_file(self.get_ast, check_astroid_module, file)</span>
<span class="gi">+</span>
<span class="gi">+    def _lint_files(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ast_mapping: dict[FileItem, nodes.Module | None],</span>
<span class="gi">+        check_astroid_module: Callable[[nodes.Module], bool | None],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Lint all AST modules from a mapping..&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _lint_file(self, file: FileItem, module: nodes.Module,</span>
<span class="gd">-        check_astroid_module: Callable[[nodes.Module], bool | None]) -&gt;None:</span>
<span class="gi">+        for fileitem, module in ast_mapping.items():</span>
<span class="gi">+            if module is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            try:</span>
<span class="gi">+                self._lint_file(fileitem, module, check_astroid_module)</span>
<span class="gi">+            except Exception as ex:  # pylint: disable=broad-except</span>
<span class="gi">+                template_path = prepare_crash_report(</span>
<span class="gi">+                    ex, fileitem.filepath, self.crash_file_path</span>
<span class="gi">+                )</span>
<span class="gi">+                msg = get_fatal_error_message(fileitem.filepath, template_path)</span>
<span class="gi">+                if isinstance(ex, astroid.AstroidError):</span>
<span class="gi">+                    self.add_message(</span>
<span class="gi">+                        &quot;astroid-error&quot;, args=(fileitem.filepath, msg), confidence=HIGH</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.add_message(&quot;fatal&quot;, args=msg, confidence=HIGH)</span>
<span class="gi">+</span>
<span class="gi">+    def _lint_file(</span>
<span class="gi">+        self,</span>
<span class="gi">+        file: FileItem,</span>
<span class="gi">+        module: nodes.Module,</span>
<span class="gi">+        check_astroid_module: Callable[[nodes.Module], bool | None],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Lint a file using the passed utility function check_astroid_module).

<span class="w"> </span>        :param FileItem file: data about the file
<span class="gu">@@ -323,10 +776,31 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>        - ast: AST of the module
<span class="w"> </span>        :raises AstroidError: for any failures stemming from astroid
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_file(self, get_ast: GetAstProtocol, check_astroid_module:</span>
<span class="gd">-        Callable[[nodes.Module], bool | None], file: FileItem) -&gt;None:</span>
<span class="gi">+        self.set_current_module(file.name, file.filepath)</span>
<span class="gi">+        self._ignore_file = False</span>
<span class="gi">+        self.file_state = FileState(file.modpath, self.msgs_store, module)</span>
<span class="gi">+        # fix the current file (if the source file was not available or</span>
<span class="gi">+        # if it&#39;s actually a c extension)</span>
<span class="gi">+        self.current_file = module.file</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            check_astroid_module(module)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise astroid.AstroidError from e</span>
<span class="gi">+</span>
<span class="gi">+        # warn about spurious inline messages handling</span>
<span class="gi">+        spurious_messages = self.file_state.iter_spurious_suppression_messages(</span>
<span class="gi">+            self.msgs_store</span>
<span class="gi">+        )</span>
<span class="gi">+        for msgid, line, args in spurious_messages:</span>
<span class="gi">+            self.add_message(msgid, line, None, args)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_file(</span>
<span class="gi">+        self,</span>
<span class="gi">+        get_ast: GetAstProtocol,</span>
<span class="gi">+        check_astroid_module: Callable[[nodes.Module], bool | None],</span>
<span class="gi">+        file: FileItem,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check a file using the passed utility functions (get_ast and
<span class="w"> </span>        check_astroid_module).

<span class="gu">@@ -340,49 +814,153 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>        :param FileItem file: data about the file
<span class="w"> </span>        :raises AstroidError: for any failures stemming from astroid
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.set_current_module(file.name, file.filepath)</span>
<span class="gi">+        # get the module representation</span>
<span class="gi">+        ast_node = get_ast(file.filepath, file.name)</span>
<span class="gi">+        if ast_node is None:</span>
<span class="gi">+            return</span>

<span class="gd">-    def _get_file_descr_from_stdin(self, filepath: str) -&gt;Iterator[FileItem]:</span>
<span class="gi">+        self._ignore_file = False</span>
<span class="gi">+</span>
<span class="gi">+        self.file_state = FileState(file.modpath, self.msgs_store, ast_node)</span>
<span class="gi">+        # fix the current file (if the source file was not available or</span>
<span class="gi">+        # if it&#39;s actually a c extension)</span>
<span class="gi">+        self.current_file = ast_node.file</span>
<span class="gi">+        try:</span>
<span class="gi">+            check_astroid_module(ast_node)</span>
<span class="gi">+        except Exception as e:  # pragma: no cover</span>
<span class="gi">+            raise astroid.AstroidError from e</span>
<span class="gi">+        # warn about spurious inline messages handling</span>
<span class="gi">+        spurious_messages = self.file_state.iter_spurious_suppression_messages(</span>
<span class="gi">+            self.msgs_store</span>
<span class="gi">+        )</span>
<span class="gi">+        for msgid, line, args in spurious_messages:</span>
<span class="gi">+            self.add_message(msgid, line, None, args)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_file_descr_from_stdin(self, filepath: str) -&gt; Iterator[FileItem]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return file description (tuple of module name, file path, base name) from
<span class="w"> </span>        given file path.

<span class="w"> </span>        This method is used for creating suitable file description for _check_files when the
<span class="w"> </span>        source is standard input.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _iterate_file_descrs(self, files_or_modules: Sequence[str]) -&gt;Iterator[</span>
<span class="gd">-        FileItem]:</span>
<span class="gi">+        if _is_ignored_file(</span>
<span class="gi">+            filepath,</span>
<span class="gi">+            self.config.ignore,</span>
<span class="gi">+            self.config.ignore_patterns,</span>
<span class="gi">+            self.config.ignore_paths,</span>
<span class="gi">+        ):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Note that this function does not really perform an</span>
<span class="gi">+            # __import__ but may raise an ImportError exception, which</span>
<span class="gi">+            # we want to catch here.</span>
<span class="gi">+            modname = &quot;.&quot;.join(astroid.modutils.modpath_from_file(filepath))</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            modname = os.path.splitext(os.path.basename(filepath))[0]</span>
<span class="gi">+</span>
<span class="gi">+        yield FileItem(modname, filepath, filepath)</span>
<span class="gi">+</span>
<span class="gi">+    def _iterate_file_descrs(</span>
<span class="gi">+        self, files_or_modules: Sequence[str]</span>
<span class="gi">+    ) -&gt; Iterator[FileItem]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return generator yielding file descriptions (tuples of module name, file
<span class="w"> </span>        path, base name).

<span class="w"> </span>        The returned generator yield one item for each Python module that should be linted.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _expand_files(self, files_or_modules: Sequence[str]) -&gt;dict[str,</span>
<span class="gd">-        ModuleDescriptionDict]:</span>
<span class="gi">+        for descr in self._expand_files(files_or_modules).values():</span>
<span class="gi">+            name, filepath, is_arg = descr[&quot;name&quot;], descr[&quot;path&quot;], descr[&quot;isarg&quot;]</span>
<span class="gi">+            if self.should_analyze_file(name, filepath, is_argument=is_arg):</span>
<span class="gi">+                yield FileItem(name, filepath, descr[&quot;basename&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    def _expand_files(</span>
<span class="gi">+        self, files_or_modules: Sequence[str]</span>
<span class="gi">+    ) -&gt; dict[str, ModuleDescriptionDict]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get modules and errors from a list of modules and handle errors.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_current_module(self, modname: str, filepath: (str | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        result, errors = expand_modules(</span>
<span class="gi">+            files_or_modules,</span>
<span class="gi">+            self.config.source_roots,</span>
<span class="gi">+            self.config.ignore,</span>
<span class="gi">+            self.config.ignore_patterns,</span>
<span class="gi">+            self._ignore_paths,</span>
<span class="gi">+        )</span>
<span class="gi">+        for error in errors:</span>
<span class="gi">+            message = modname = error[&quot;mod&quot;]</span>
<span class="gi">+            key = error[&quot;key&quot;]</span>
<span class="gi">+            self.set_current_module(modname)</span>
<span class="gi">+            if key == &quot;fatal&quot;:</span>
<span class="gi">+                message = str(error[&quot;ex&quot;]).replace(os.getcwd() + os.sep, &quot;&quot;)</span>
<span class="gi">+            self.add_message(key, args=message)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def set_current_module(self, modname: str, filepath: str | None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the name of the currently analyzed module and
<span class="w"> </span>        init statistics for it.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not modname and filepath is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.reporter.on_set_current_module(modname or &quot;&quot;, filepath)</span>
<span class="gi">+        self.current_name = modname</span>
<span class="gi">+        self.current_file = filepath or modname</span>
<span class="gi">+        self.stats.init_single_module(modname or &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # If there is an actual filepath we might need to update the config attribute</span>
<span class="gi">+        if filepath:</span>
<span class="gi">+            namespace = self._get_namespace_for_file(</span>
<span class="gi">+                Path(filepath), self._directory_namespaces</span>
<span class="gi">+            )</span>
<span class="gi">+            if namespace:</span>
<span class="gi">+                self.config = namespace or self._base_config</span>
<span class="gi">+</span>
<span class="gi">+    def _get_namespace_for_file(</span>
<span class="gi">+        self, filepath: Path, namespaces: DirectoryNamespaceDict</span>
<span class="gi">+    ) -&gt; argparse.Namespace | None:</span>
<span class="gi">+        for directory in namespaces:</span>
<span class="gi">+            if _is_relative_to(filepath, directory):</span>
<span class="gi">+                namespace = self._get_namespace_for_file(</span>
<span class="gi">+                    filepath, namespaces[directory][1]</span>
<span class="gi">+                )</span>
<span class="gi">+                if namespace is None:</span>
<span class="gi">+                    return namespaces[directory][0]</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    @contextlib.contextmanager
<span class="gd">-    def _astroid_module_checker(self) -&gt;Iterator[Callable[[nodes.Module], </span>
<span class="gd">-        bool | None]]:</span>
<span class="gi">+    def _astroid_module_checker(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; Iterator[Callable[[nodes.Module], bool | None]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Context manager for checking ASTs.

<span class="w"> </span>        The value in the context is callable accepting AST as its only argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_ast(self, filepath: str, modname: str, data: (str | None)=None) -&gt;(</span>
<span class="gd">-        nodes.Module | None):</span>
<span class="gi">+        walker = ASTWalker(self)</span>
<span class="gi">+        _checkers = self.prepare_checkers()</span>
<span class="gi">+        tokencheckers = [</span>
<span class="gi">+            c for c in _checkers if isinstance(c, checkers.BaseTokenChecker)</span>
<span class="gi">+        ]</span>
<span class="gi">+        rawcheckers = [</span>
<span class="gi">+            c for c in _checkers if isinstance(c, checkers.BaseRawFileChecker)</span>
<span class="gi">+        ]</span>
<span class="gi">+        for checker in _checkers:</span>
<span class="gi">+            checker.open()</span>
<span class="gi">+            walker.add_checker(checker)</span>
<span class="gi">+</span>
<span class="gi">+        yield functools.partial(</span>
<span class="gi">+            self.check_astroid_module,</span>
<span class="gi">+            walker=walker,</span>
<span class="gi">+            tokencheckers=tokencheckers,</span>
<span class="gi">+            rawcheckers=rawcheckers,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # notify global end</span>
<span class="gi">+        self.stats.statement = walker.nbstatements</span>
<span class="gi">+        for checker in reversed(_checkers):</span>
<span class="gi">+            checker.close()</span>
<span class="gi">+</span>
<span class="gi">+    def get_ast(</span>
<span class="gi">+        self, filepath: str, modname: str, data: str | None = None</span>
<span class="gi">+    ) -&gt; nodes.Module | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an ast(roid) representation of a module or a string.

<span class="w"> </span>        :param filepath: path to checked file.
<span class="gu">@@ -392,20 +970,65 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>        :rtype: astroid.nodes.Module
<span class="w"> </span>        :raises AstroidBuildingError: Whenever we encounter an unexpected exception
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def check_astroid_module(self, ast_node: nodes.Module, walker:</span>
<span class="gd">-        ASTWalker, rawcheckers: list[checkers.BaseRawFileChecker],</span>
<span class="gd">-        tokencheckers: list[checkers.BaseTokenChecker]) -&gt;(bool | None):</span>
<span class="gi">+        try:</span>
<span class="gi">+            if data is None:</span>
<span class="gi">+                return MANAGER.ast_from_file(filepath, modname, source=True)</span>
<span class="gi">+            return astroid.builder.AstroidBuilder(MANAGER).string_build(</span>
<span class="gi">+                data, modname, filepath</span>
<span class="gi">+            )</span>
<span class="gi">+        except astroid.AstroidSyntaxError as ex:</span>
<span class="gi">+            line = getattr(ex.error, &quot;lineno&quot;, None)</span>
<span class="gi">+            if line is None:</span>
<span class="gi">+                line = 0</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;syntax-error&quot;,</span>
<span class="gi">+                line=line,</span>
<span class="gi">+                col_offset=getattr(ex.error, &quot;offset&quot;, None),</span>
<span class="gi">+                args=f&quot;Parsing failed: &#39;{ex.error}&#39;&quot;,</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+        except astroid.AstroidBuildingError as ex:</span>
<span class="gi">+            self.add_message(&quot;parse-error&quot;, args=ex)</span>
<span class="gi">+        except Exception as ex:</span>
<span class="gi">+            traceback.print_exc()</span>
<span class="gi">+            # We raise BuildingError here as this is essentially an astroid issue</span>
<span class="gi">+            # Creating an issue template and adding the &#39;astroid-error&#39; message is handled</span>
<span class="gi">+            # by caller: _check_files</span>
<span class="gi">+            raise astroid.AstroidBuildingError(</span>
<span class="gi">+                &quot;Building error when trying to create ast representation of module &#39;{modname}&#39;&quot;,</span>
<span class="gi">+                modname=modname,</span>
<span class="gi">+            ) from ex</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def check_astroid_module(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ast_node: nodes.Module,</span>
<span class="gi">+        walker: ASTWalker,</span>
<span class="gi">+        rawcheckers: list[checkers.BaseRawFileChecker],</span>
<span class="gi">+        tokencheckers: list[checkers.BaseTokenChecker],</span>
<span class="gi">+    ) -&gt; bool | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check a module from its astroid representation.

<span class="w"> </span>        For return value see _check_astroid_module
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _check_astroid_module(self, node: nodes.Module, walker: ASTWalker,</span>
<span class="gd">-        rawcheckers: list[checkers.BaseRawFileChecker], tokencheckers: list</span>
<span class="gd">-        [checkers.BaseTokenChecker]) -&gt;(bool | None):</span>
<span class="gi">+        before_check_statements = walker.nbstatements</span>
<span class="gi">+</span>
<span class="gi">+        retval = self._check_astroid_module(</span>
<span class="gi">+            ast_node, walker, rawcheckers, tokencheckers</span>
<span class="gi">+        )</span>
<span class="gi">+        self.stats.by_module[self.current_name][&quot;statement&quot;] = (</span>
<span class="gi">+            walker.nbstatements - before_check_statements</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return retval</span>
<span class="gi">+</span>
<span class="gi">+    def _check_astroid_module(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: nodes.Module,</span>
<span class="gi">+        walker: ASTWalker,</span>
<span class="gi">+        rawcheckers: list[checkers.BaseRawFileChecker],</span>
<span class="gi">+        tokencheckers: list[checkers.BaseTokenChecker],</span>
<span class="gi">+    ) -&gt; bool | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check given AST node with given walker and checkers.

<span class="w"> </span>        :param astroid.nodes.Module node: AST node of the module to check
<span class="gu">@@ -416,37 +1039,220 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>        :returns: True if the module was checked, False if ignored,
<span class="w"> </span>            None if the module contents could not be parsed
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            tokens = utils.tokenize_module(node)</span>
<span class="gi">+        except tokenize.TokenError as ex:</span>
<span class="gi">+            self.add_message(</span>
<span class="gi">+                &quot;syntax-error&quot;,</span>
<span class="gi">+                line=ex.args[1][0],</span>
<span class="gi">+                col_offset=ex.args[1][1],</span>
<span class="gi">+                args=ex.args[0],</span>
<span class="gi">+                confidence=HIGH,</span>
<span class="gi">+            )</span>
<span class="gi">+            return None</span>

<span class="gd">-    def open(self) -&gt;None:</span>
<span class="gi">+        if not node.pure_python:</span>
<span class="gi">+            self.add_message(&quot;raw-checker-failed&quot;, args=node.name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # assert astroid.file.endswith(&#39;.py&#39;)</span>
<span class="gi">+            # Parse module/block level option pragma&#39;s</span>
<span class="gi">+            self.process_tokens(tokens)</span>
<span class="gi">+            if self._ignore_file:</span>
<span class="gi">+                return False</span>
<span class="gi">+            # run raw and tokens checkers</span>
<span class="gi">+            for raw_checker in rawcheckers:</span>
<span class="gi">+                raw_checker.process_module(node)</span>
<span class="gi">+            for token_checker in tokencheckers:</span>
<span class="gi">+                token_checker.process_tokens(tokens)</span>
<span class="gi">+        # generate events to astroid checkers</span>
<span class="gi">+        walker.walk(node)</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def open(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize counters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        MANAGER.always_load_extensions = self.config.unsafe_load_any_extension</span>
<span class="gi">+        MANAGER.max_inferable_values = self.config.limit_inference_results</span>
<span class="gi">+        MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)</span>
<span class="gi">+        MANAGER.module_denylist.update(self.config.ignored_modules)</span>
<span class="gi">+        MANAGER.prefer_stubs = self.config.prefer_stubs</span>
<span class="gi">+        if self.config.extension_pkg_whitelist:</span>
<span class="gi">+            MANAGER.extension_package_whitelist.update(</span>
<span class="gi">+                self.config.extension_pkg_whitelist</span>
<span class="gi">+            )</span>
<span class="gi">+        self.stats.reset_message_count()</span>

<span class="gd">-    def generate_reports(self, verbose: bool=False) -&gt;(int | None):</span>
<span class="gi">+    def generate_reports(self, verbose: bool = False) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Close the whole package /module, it&#39;s time to make reports !

<span class="w"> </span>        if persistent run, pickle results for later comparison
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Display whatever messages are left on the reporter.</span>
<span class="gi">+        self.reporter.display_messages(report_nodes.Section())</span>
<span class="gi">+        if not self.file_state._is_base_filestate:</span>
<span class="gi">+            # load previous results if any</span>
<span class="gi">+            previous_stats = load_results(self.file_state.base_name)</span>
<span class="gi">+            self.reporter.on_close(self.stats, previous_stats)</span>
<span class="gi">+            if self.config.reports:</span>
<span class="gi">+                sect = self.make_reports(self.stats, previous_stats)</span>
<span class="gi">+            else:</span>
<span class="gi">+                sect = report_nodes.Section()</span>
<span class="gi">+</span>
<span class="gi">+            if self.config.reports:</span>
<span class="gi">+                self.reporter.display_reports(sect)</span>
<span class="gi">+            score_value = self._report_evaluation(verbose)</span>
<span class="gi">+            # save results if persistent run</span>
<span class="gi">+            if self.config.persistent:</span>
<span class="gi">+                save_results(self.stats, self.file_state.base_name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.reporter.on_close(self.stats, LinterStats())</span>
<span class="gi">+            score_value = None</span>
<span class="gi">+        return score_value</span>

<span class="gd">-    def _report_evaluation(self, verbose: bool=False) -&gt;(int | None):</span>
<span class="gi">+    def _report_evaluation(self, verbose: bool = False) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Make the global evaluation report.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _add_one_message(self, message_definition: MessageDefinition, line:</span>
<span class="gd">-        (int | None), node: (nodes.NodeNG | None), args: (Any | None),</span>
<span class="gd">-        confidence: (interfaces.Confidence | None), col_offset: (int | None</span>
<span class="gd">-        ), end_lineno: (int | None), end_col_offset: (int | None)) -&gt;None:</span>
<span class="gi">+        # check with at least a statement (usually 0 when there is a</span>
<span class="gi">+        # syntax error preventing pylint from further processing)</span>
<span class="gi">+        note = None</span>
<span class="gi">+        previous_stats = load_results(self.file_state.base_name)</span>
<span class="gi">+        if self.stats.statement == 0:</span>
<span class="gi">+            return note</span>
<span class="gi">+</span>
<span class="gi">+        # get a global note for the code</span>
<span class="gi">+        evaluation = self.config.evaluation</span>
<span class="gi">+        try:</span>
<span class="gi">+            stats_dict = {</span>
<span class="gi">+                &quot;fatal&quot;: self.stats.fatal,</span>
<span class="gi">+                &quot;error&quot;: self.stats.error,</span>
<span class="gi">+                &quot;warning&quot;: self.stats.warning,</span>
<span class="gi">+                &quot;refactor&quot;: self.stats.refactor,</span>
<span class="gi">+                &quot;convention&quot;: self.stats.convention,</span>
<span class="gi">+                &quot;statement&quot;: self.stats.statement,</span>
<span class="gi">+                &quot;info&quot;: self.stats.info,</span>
<span class="gi">+            }</span>
<span class="gi">+            note = eval(evaluation, {}, stats_dict)  # pylint: disable=eval-used</span>
<span class="gi">+        except Exception as ex:  # pylint: disable=broad-except</span>
<span class="gi">+            msg = f&quot;An exception occurred while rating: {ex}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.stats.global_note = note</span>
<span class="gi">+            msg = f&quot;Your code has been rated at {note:.2f}/10&quot;</span>
<span class="gi">+            if previous_stats:</span>
<span class="gi">+                pnote = previous_stats.global_note</span>
<span class="gi">+                if pnote is not None:</span>
<span class="gi">+                    msg += f&quot; (previous run: {pnote:.2f}/10, {note - pnote:+.2f})&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if verbose:</span>
<span class="gi">+                checked_files_count = self.stats.node_count[&quot;module&quot;]</span>
<span class="gi">+                unchecked_files_count = self.stats.undocumented[&quot;module&quot;]</span>
<span class="gi">+                msg += f&quot;\nChecked {checked_files_count} files, skipped {unchecked_files_count} files&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if self.config.score:</span>
<span class="gi">+            sect = report_nodes.EvaluationSection(msg)</span>
<span class="gi">+            self.reporter.display_reports(sect)</span>
<span class="gi">+        return note</span>
<span class="gi">+</span>
<span class="gi">+    def _add_one_message(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message_definition: MessageDefinition,</span>
<span class="gi">+        line: int | None,</span>
<span class="gi">+        node: nodes.NodeNG | None,</span>
<span class="gi">+        args: Any | None,</span>
<span class="gi">+        confidence: interfaces.Confidence | None,</span>
<span class="gi">+        col_offset: int | None,</span>
<span class="gi">+        end_lineno: int | None,</span>
<span class="gi">+        end_col_offset: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;After various checks have passed a single Message is
<span class="w"> </span>        passed to the reporter and added to stats.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_message(self, msgid: str, line: (int | None)=None, node: (nodes</span>
<span class="gd">-        .NodeNG | None)=None, args: (Any | None)=None, confidence: (</span>
<span class="gd">-        interfaces.Confidence | None)=None, col_offset: (int | None)=None,</span>
<span class="gd">-        end_lineno: (int | None)=None, end_col_offset: (int | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        message_definition.check_message_definition(line, node)</span>
<span class="gi">+</span>
<span class="gi">+        # Look up &quot;location&quot; data of node if not yet supplied</span>
<span class="gi">+        if node:</span>
<span class="gi">+            if node.position:</span>
<span class="gi">+                if not line:</span>
<span class="gi">+                    line = node.position.lineno</span>
<span class="gi">+                if not col_offset:</span>
<span class="gi">+                    col_offset = node.position.col_offset</span>
<span class="gi">+                if not end_lineno:</span>
<span class="gi">+                    end_lineno = node.position.end_lineno</span>
<span class="gi">+                if not end_col_offset:</span>
<span class="gi">+                    end_col_offset = node.position.end_col_offset</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not line:</span>
<span class="gi">+                    line = node.fromlineno</span>
<span class="gi">+                if not col_offset:</span>
<span class="gi">+                    col_offset = node.col_offset</span>
<span class="gi">+                if not end_lineno:</span>
<span class="gi">+                    end_lineno = node.end_lineno</span>
<span class="gi">+                if not end_col_offset:</span>
<span class="gi">+                    end_col_offset = node.end_col_offset</span>
<span class="gi">+</span>
<span class="gi">+        # should this message be displayed</span>
<span class="gi">+        if not self.is_message_enabled(message_definition.msgid, line, confidence):</span>
<span class="gi">+            self.file_state.handle_ignored_message(</span>
<span class="gi">+                self._get_message_state_scope(</span>
<span class="gi">+                    message_definition.msgid, line, confidence</span>
<span class="gi">+                ),</span>
<span class="gi">+                message_definition.msgid,</span>
<span class="gi">+                line,</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # update stats</span>
<span class="gi">+        msg_cat = MSG_TYPES[message_definition.msgid[0]]</span>
<span class="gi">+        self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]</span>
<span class="gi">+        self.stats.increase_single_message_count(msg_cat, 1)</span>
<span class="gi">+        self.stats.increase_single_module_message_count(self.current_name, msg_cat, 1)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.stats.by_msg[message_definition.symbol] += 1</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            self.stats.by_msg[message_definition.symbol] = 1</span>
<span class="gi">+        # Interpolate arguments into message string</span>
<span class="gi">+        msg = message_definition.msg</span>
<span class="gi">+        if args is not None:</span>
<span class="gi">+            msg %= args</span>
<span class="gi">+        # get module and object</span>
<span class="gi">+        if node is None:</span>
<span class="gi">+            module, obj = self.current_name, &quot;&quot;</span>
<span class="gi">+            abspath = self.current_file</span>
<span class="gi">+        else:</span>
<span class="gi">+            module, obj = utils.get_module_and_frameid(node)</span>
<span class="gi">+            abspath = node.root().file</span>
<span class="gi">+        if abspath is not None:</span>
<span class="gi">+            path = abspath.replace(self.reporter.path_strip_prefix, &quot;&quot;, 1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            path = &quot;configuration&quot;</span>
<span class="gi">+        # add the message</span>
<span class="gi">+        self.reporter.handle_message(</span>
<span class="gi">+            Message(</span>
<span class="gi">+                message_definition.msgid,</span>
<span class="gi">+                message_definition.symbol,</span>
<span class="gi">+                MessageLocationTuple(</span>
<span class="gi">+                    abspath or &quot;&quot;,</span>
<span class="gi">+                    path,</span>
<span class="gi">+                    module or &quot;&quot;,</span>
<span class="gi">+                    obj,</span>
<span class="gi">+                    line or 1,</span>
<span class="gi">+                    col_offset or 0,</span>
<span class="gi">+                    end_lineno,</span>
<span class="gi">+                    end_col_offset,</span>
<span class="gi">+                ),</span>
<span class="gi">+                msg,</span>
<span class="gi">+                confidence,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def add_message(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        line: int | None = None,</span>
<span class="gi">+        node: nodes.NodeNG | None = None,</span>
<span class="gi">+        args: Any | None = None,</span>
<span class="gi">+        confidence: interfaces.Confidence | None = None,</span>
<span class="gi">+        col_offset: int | None = None,</span>
<span class="gi">+        end_lineno: int | None = None,</span>
<span class="gi">+        end_col_offset: int | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a message given by ID or name.

<span class="w"> </span>        If provided, the message string is expanded using args.
<span class="gu">@@ -455,11 +1261,28 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>        provide line if the line number is different), raw and token checkers
<span class="w"> </span>        must provide the line argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if confidence is None:</span>
<span class="gi">+            confidence = interfaces.UNDEFINED</span>
<span class="gi">+        message_definitions = self.msgs_store.get_message_definitions(msgid)</span>
<span class="gi">+        for message_definition in message_definitions:</span>
<span class="gi">+            self._add_one_message(</span>
<span class="gi">+                message_definition,</span>
<span class="gi">+                line,</span>
<span class="gi">+                node,</span>
<span class="gi">+                args,</span>
<span class="gi">+                confidence,</span>
<span class="gi">+                col_offset,</span>
<span class="gi">+                end_lineno,</span>
<span class="gi">+                end_col_offset,</span>
<span class="gi">+            )</span>

<span class="gd">-    def add_ignored_message(self, msgid: str, line: int, node: (nodes.</span>
<span class="gd">-        NodeNG | None)=None, confidence: (interfaces.Confidence | None)=</span>
<span class="gd">-        interfaces.UNDEFINED) -&gt;None:</span>
<span class="gi">+    def add_ignored_message(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        line: int,</span>
<span class="gi">+        node: nodes.NodeNG | None = None,</span>
<span class="gi">+        confidence: interfaces.Confidence | None = interfaces.UNDEFINED,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepares a message to be added to the ignored message storage.

<span class="w"> </span>        Some checks return early in special cases and never reach add_message(),
<span class="gu">@@ -467,4 +1290,26 @@ class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.</span>
<span class="w"> </span>        This creates false positives for useless-suppression.
<span class="w"> </span>        This function avoids this by adding those message to the ignored msgs attribute
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message_definitions = self.msgs_store.get_message_definitions(msgid)</span>
<span class="gi">+        for message_definition in message_definitions:</span>
<span class="gi">+            message_definition.check_message_definition(line, node)</span>
<span class="gi">+            self.file_state.handle_ignored_message(</span>
<span class="gi">+                self._get_message_state_scope(</span>
<span class="gi">+                    message_definition.msgid, line, confidence</span>
<span class="gi">+                ),</span>
<span class="gi">+                message_definition.msgid,</span>
<span class="gi">+                line,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def _emit_stashed_messages(self) -&gt; None:</span>
<span class="gi">+        for keys, values in self._stashed_messages.items():</span>
<span class="gi">+            modname, symbol = keys</span>
<span class="gi">+            self.linter.set_current_module(modname)</span>
<span class="gi">+            for args in values:</span>
<span class="gi">+                self.add_message(</span>
<span class="gi">+                    symbol,</span>
<span class="gi">+                    args=args,</span>
<span class="gi">+                    line=0,</span>
<span class="gi">+                    confidence=HIGH,</span>
<span class="gi">+                )</span>
<span class="gi">+        self._stashed_messages = collections.defaultdict(list)</span>
<span class="gh">diff --git a/pylint/lint/report_functions.py b/pylint/lint/report_functions.py</span>
<span class="gh">index eec3528bf..72734e468 100644</span>
<span class="gd">--- a/pylint/lint/report_functions.py</span>
<span class="gi">+++ b/pylint/lint/report_functions.py</span>
<span class="gu">@@ -1,26 +1,88 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from typing import cast
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers, exceptions
<span class="w"> </span>from pylint.reporters.ureports.nodes import Section, Table
<span class="w"> </span>from pylint.typing import MessageTypesFullName
<span class="w"> </span>from pylint.utils import LinterStats


<span class="gd">-def report_total_messages_stats(sect: Section, stats: LinterStats,</span>
<span class="gd">-    previous_stats: (LinterStats | None)) -&gt;None:</span>
<span class="gi">+def report_total_messages_stats(</span>
<span class="gi">+    sect: Section,</span>
<span class="gi">+    stats: LinterStats,</span>
<span class="gi">+    previous_stats: LinterStats | None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make total errors / warnings report.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = [&quot;type&quot;, &quot;number&quot;, &quot;previous&quot;, &quot;difference&quot;]</span>
<span class="gi">+    lines += checkers.table_lines_from_stats(stats, previous_stats, &quot;message_types&quot;)</span>
<span class="gi">+    sect.append(Table(children=lines, cols=4, rheaders=1))</span>


<span class="gd">-def report_messages_stats(sect: Section, stats: LinterStats, _: (</span>
<span class="gd">-    LinterStats | None)) -&gt;None:</span>
<span class="gi">+def report_messages_stats(</span>
<span class="gi">+    sect: Section,</span>
<span class="gi">+    stats: LinterStats,</span>
<span class="gi">+    _: LinterStats | None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make messages type report.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    by_msg_stats = stats.by_msg</span>
<span class="gi">+    in_order = sorted(</span>
<span class="gi">+        (value, msg_id)</span>
<span class="gi">+        for msg_id, value in by_msg_stats.items()</span>
<span class="gi">+        if not msg_id.startswith(&quot;I&quot;)</span>
<span class="gi">+    )</span>
<span class="gi">+    in_order.reverse()</span>
<span class="gi">+    lines = [&quot;message id&quot;, &quot;occurrences&quot;]</span>
<span class="gi">+    for value, msg_id in in_order:</span>
<span class="gi">+        lines += [msg_id, str(value)]</span>
<span class="gi">+    sect.append(Table(children=lines, cols=2, rheaders=1))</span>


<span class="gd">-def report_messages_by_module_stats(sect: Section, stats: LinterStats, _: (</span>
<span class="gd">-    LinterStats | None)) -&gt;None:</span>
<span class="gi">+def report_messages_by_module_stats(</span>
<span class="gi">+    sect: Section,</span>
<span class="gi">+    stats: LinterStats,</span>
<span class="gi">+    _: LinterStats | None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Make errors / warnings by modules report.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module_stats = stats.by_module</span>
<span class="gi">+    if len(module_stats) == 1:</span>
<span class="gi">+        # don&#39;t print this report when we are analysing a single module</span>
<span class="gi">+        raise exceptions.EmptyReportError()</span>
<span class="gi">+    by_mod: defaultdict[str, dict[str, int | float]] = collections.defaultdict(dict)</span>
<span class="gi">+    for m_type in (&quot;fatal&quot;, &quot;error&quot;, &quot;warning&quot;, &quot;refactor&quot;, &quot;convention&quot;):</span>
<span class="gi">+        m_type = cast(MessageTypesFullName, m_type)</span>
<span class="gi">+        total = stats.get_global_message_count(m_type)</span>
<span class="gi">+        for module in module_stats.keys():</span>
<span class="gi">+            mod_total = stats.get_module_message_count(module, m_type)</span>
<span class="gi">+            percent = 0 if total == 0 else float(mod_total * 100) / total</span>
<span class="gi">+            by_mod[module][m_type] = percent</span>
<span class="gi">+    sorted_result = []</span>
<span class="gi">+    for module, mod_info in by_mod.items():</span>
<span class="gi">+        sorted_result.append(</span>
<span class="gi">+            (</span>
<span class="gi">+                mod_info[&quot;error&quot;],</span>
<span class="gi">+                mod_info[&quot;warning&quot;],</span>
<span class="gi">+                mod_info[&quot;refactor&quot;],</span>
<span class="gi">+                mod_info[&quot;convention&quot;],</span>
<span class="gi">+                module,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    sorted_result.sort()</span>
<span class="gi">+    sorted_result.reverse()</span>
<span class="gi">+    lines = [&quot;module&quot;, &quot;error&quot;, &quot;warning&quot;, &quot;refactor&quot;, &quot;convention&quot;]</span>
<span class="gi">+    for line in sorted_result:</span>
<span class="gi">+        # Don&#39;t report clean modules.</span>
<span class="gi">+        if all(entry == 0 for entry in line[:-1]):</span>
<span class="gi">+            continue</span>
<span class="gi">+        lines.append(line[-1])</span>
<span class="gi">+        for val in line[:-1]:</span>
<span class="gi">+            lines.append(f&quot;{val:.2f}&quot;)</span>
<span class="gi">+    if len(lines) == 5:</span>
<span class="gi">+        raise exceptions.EmptyReportError()</span>
<span class="gi">+    sect.append(Table(children=lines, cols=5, rheaders=1))</span>
<span class="gh">diff --git a/pylint/lint/run.py b/pylint/lint/run.py</span>
<span class="gh">index 646f5ae00..1a8d594a0 100644</span>
<span class="gd">--- a/pylint/lint/run.py</span>
<span class="gi">+++ b/pylint/lint/run.py</span>
<span class="gu">@@ -1,13 +1,22 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import ClassVar
<span class="gi">+</span>
<span class="w"> </span>from pylint import config
<span class="w"> </span>from pylint.checkers.utils import clear_lru_caches
<span class="gd">-from pylint.config._pylint_config import _handle_pylint_config_commands, _register_generate_config_options</span>
<span class="gi">+from pylint.config._pylint_config import (</span>
<span class="gi">+    _handle_pylint_config_commands,</span>
<span class="gi">+    _register_generate_config_options,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.config.config_initialization import _config_initialization
<span class="w"> </span>from pylint.config.exceptions import ArgumentPreprocessingError
<span class="w"> </span>from pylint.config.utils import _preprocess_options
<span class="gu">@@ -15,99 +24,183 @@ from pylint.constants import full_version</span>
<span class="w"> </span>from pylint.lint.base_options import _make_run_options
<span class="w"> </span>from pylint.lint.pylinter import MANAGER, PyLinter
<span class="w"> </span>from pylint.reporters.base_reporter import BaseReporter
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import multiprocessing
<span class="gd">-    from multiprocessing import synchronize</span>
<span class="gi">+    from multiprocessing import synchronize  # noqa pylint: disable=unused-import</span>
<span class="w"> </span>except ImportError:
<span class="gd">-    multiprocessing = None</span>
<span class="gi">+    multiprocessing = None  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from concurrent.futures import ProcessPoolExecutor
<span class="w"> </span>except ImportError:
<span class="gd">-    ProcessPoolExecutor = None</span>
<span class="gi">+    ProcessPoolExecutor = None  # type: ignore[assignment,misc]</span>


<span class="gd">-def _query_cpu() -&gt;(int | None):</span>
<span class="gi">+def _query_cpu() -&gt; int | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Try to determine number of CPUs allotted in a docker container.

<span class="w"> </span>    This is based on discussion and copied from suggestions in
<span class="w"> </span>    https://bugs.python.org/issue36054.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cpu_quota, avail_cpu = None, None</span>
<span class="gi">+</span>
<span class="gi">+    if Path(&quot;/sys/fs/cgroup/cpu/cpu.cfs_quota_us&quot;).is_file():</span>
<span class="gi">+        with open(&quot;/sys/fs/cgroup/cpu/cpu.cfs_quota_us&quot;, encoding=&quot;utf-8&quot;) as file:</span>
<span class="gi">+            # Not useful for AWS Batch based jobs as result is -1, but works on local linux systems</span>
<span class="gi">+            cpu_quota = int(file.read().rstrip())</span>

<span class="gi">+    if (</span>
<span class="gi">+        cpu_quota</span>
<span class="gi">+        and cpu_quota != -1</span>
<span class="gi">+        and Path(&quot;/sys/fs/cgroup/cpu/cpu.cfs_period_us&quot;).is_file()</span>
<span class="gi">+    ):</span>
<span class="gi">+        with open(&quot;/sys/fs/cgroup/cpu/cpu.cfs_period_us&quot;, encoding=&quot;utf-8&quot;) as file:</span>
<span class="gi">+            cpu_period = int(file.read().rstrip())</span>
<span class="gi">+        # Divide quota by period and you should get num of allotted CPU to the container,</span>
<span class="gi">+        # rounded down if fractional.</span>
<span class="gi">+        avail_cpu = int(cpu_quota / cpu_period)</span>
<span class="gi">+    elif Path(&quot;/sys/fs/cgroup/cpu/cpu.shares&quot;).is_file():</span>
<span class="gi">+        with open(&quot;/sys/fs/cgroup/cpu/cpu.shares&quot;, encoding=&quot;utf-8&quot;) as file:</span>
<span class="gi">+            cpu_shares = int(file.read().rstrip())</span>
<span class="gi">+        # For AWS, gives correct value * 1024.</span>
<span class="gi">+        avail_cpu = int(cpu_shares / 1024)</span>

<span class="gd">-def _cpu_count() -&gt;int:</span>
<span class="gi">+    # In K8s Pods also a fraction of a single core could be available</span>
<span class="gi">+    # As multiprocessing is not able to run only a &quot;fraction&quot; of process</span>
<span class="gi">+    # assume we have 1 CPU available</span>
<span class="gi">+    if avail_cpu == 0:</span>
<span class="gi">+        avail_cpu = 1</span>
<span class="gi">+</span>
<span class="gi">+    return avail_cpu</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _cpu_count() -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Use sched_affinity if available for virtualized or containerized
<span class="w"> </span>    environments.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cpu_share = _query_cpu()</span>
<span class="gi">+    cpu_count = None</span>
<span class="gi">+    sched_getaffinity = getattr(os, &quot;sched_getaffinity&quot;, None)</span>
<span class="gi">+    # pylint: disable=not-callable,using-constant-test,useless-suppression</span>
<span class="gi">+    if sched_getaffinity:</span>
<span class="gi">+        cpu_count = len(sched_getaffinity(0))</span>
<span class="gi">+    elif multiprocessing:</span>
<span class="gi">+        cpu_count = multiprocessing.cpu_count()</span>
<span class="gi">+    else:</span>
<span class="gi">+        cpu_count = 1</span>
<span class="gi">+    if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+        # See also https://github.com/python/cpython/issues/94242</span>
<span class="gi">+        cpu_count = min(cpu_count, 56)  # pragma: no cover</span>
<span class="gi">+    if cpu_share is not None:</span>
<span class="gi">+        return min(cpu_share, cpu_count)</span>
<span class="gi">+    return cpu_count</span>


<span class="w"> </span>class Run:
<span class="w"> </span>    &quot;&quot;&quot;Helper class to use as main for pylint with &#39;run(*sys.argv[1:])&#39;.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    LinterClass = PyLinter
<span class="gd">-    option_groups = (&#39;Commands&#39;,</span>
<span class="gd">-        &#39;Options which are actually commands. Options in this group are mutually exclusive.&#39;</span>
<span class="gi">+    option_groups = (</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;Commands&quot;,</span>
<span class="gi">+            &quot;Options which are actually commands. Options in this \</span>
<span class="gi">+group are mutually exclusive.&quot;,</span>
<span class="w"> </span>        ),
<span class="gi">+    )</span>
<span class="w"> </span>    _is_pylint_config: ClassVar[bool] = False
<span class="w"> </span>    &quot;&quot;&quot;Boolean whether or not this is a &#39;pylint-config&#39; run.

<span class="w"> </span>    Used by _PylintConfigRun to make the &#39;pylint-config&#39; command work.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, args: Sequence[str], reporter: (BaseReporter | None)</span>
<span class="gd">-        =None, exit: bool=True) -&gt;None:</span>
<span class="gd">-        if &#39;--version&#39; in args:</span>
<span class="gi">+    # pylint: disable = too-many-statements, too-many-branches</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        args: Sequence[str],</span>
<span class="gi">+        reporter: BaseReporter | None = None,</span>
<span class="gi">+        exit: bool = True,  # pylint: disable=redefined-builtin</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # Immediately exit if user asks for version</span>
<span class="gi">+        if &quot;--version&quot; in args:</span>
<span class="w"> </span>            print(full_version)
<span class="w"> </span>            sys.exit(0)
<span class="gi">+</span>
<span class="w"> </span>        self._rcfile: str | None = None
<span class="w"> </span>        self._output: str | None = None
<span class="w"> </span>        self._plugins: list[str] = []
<span class="w"> </span>        self.verbose: bool = False
<span class="gi">+</span>
<span class="gi">+        # Pre-process certain options and remove them from args list</span>
<span class="w"> </span>        try:
<span class="w"> </span>            args = _preprocess_options(self, args)
<span class="w"> </span>        except ArgumentPreprocessingError as ex:
<span class="w"> </span>            print(ex, file=sys.stderr)
<span class="w"> </span>            sys.exit(32)
<span class="gi">+</span>
<span class="gi">+        # Determine configuration file</span>
<span class="w"> </span>        if self._rcfile is None:
<span class="w"> </span>            default_file = next(config.find_default_config_files(), None)
<span class="w"> </span>            if default_file:
<span class="w"> </span>                self._rcfile = str(default_file)
<span class="gd">-        self.linter = linter = self.LinterClass(_make_run_options(self),</span>
<span class="gd">-            option_groups=self.option_groups, pylintrc=self._rcfile)</span>
<span class="gi">+</span>
<span class="gi">+        self.linter = linter = self.LinterClass(</span>
<span class="gi">+            _make_run_options(self),</span>
<span class="gi">+            option_groups=self.option_groups,</span>
<span class="gi">+            pylintrc=self._rcfile,</span>
<span class="gi">+        )</span>
<span class="gi">+        # register standard checkers</span>
<span class="w"> </span>        linter.load_default_plugins()
<span class="gi">+        # load command line plugins</span>
<span class="w"> </span>        linter.load_plugin_modules(self._plugins)
<span class="gi">+</span>
<span class="gi">+        # Register the options needed for &#39;pylint-config&#39;</span>
<span class="gi">+        # By not registering them by default they don&#39;t show up in the normal usage message</span>
<span class="w"> </span>        if self._is_pylint_config:
<span class="w"> </span>            _register_generate_config_options(linter._arg_parser)
<span class="gd">-        args = _config_initialization(linter, args, reporter, config_file=</span>
<span class="gd">-            self._rcfile, verbose_mode=self.verbose)</span>
<span class="gi">+</span>
<span class="gi">+        args = _config_initialization(</span>
<span class="gi">+            linter, args, reporter, config_file=self._rcfile, verbose_mode=self.verbose</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Handle the &#39;pylint-config&#39; command</span>
<span class="w"> </span>        if self._is_pylint_config:
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &quot;NOTE: The &#39;pylint-config&#39; command is experimental and usage can change&quot;</span>
<span class="gd">-                , UserWarning, stacklevel=2)</span>
<span class="gi">+                &quot;NOTE: The &#39;pylint-config&#39; command is experimental and usage can change&quot;,</span>
<span class="gi">+                UserWarning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            code = _handle_pylint_config_commands(linter)
<span class="w"> </span>            if exit:
<span class="w"> </span>                sys.exit(code)
<span class="w"> </span>            return
<span class="gd">-        if not args or len(linter.config.disable) == len(linter.msgs_store.</span>
<span class="gd">-            _messages_definitions):</span>
<span class="gd">-            print(&#39;No files to lint: exiting.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Display help if there are no files to lint or no checks enabled</span>
<span class="gi">+        if not args or len(linter.config.disable) == len(</span>
<span class="gi">+            linter.msgs_store._messages_definitions</span>
<span class="gi">+        ):</span>
<span class="gi">+            print(&quot;No files to lint: exiting.&quot;)</span>
<span class="w"> </span>            sys.exit(32)
<span class="gi">+</span>
<span class="w"> </span>        if linter.config.jobs &lt; 0:
<span class="w"> </span>            print(
<span class="gd">-                f&#39;Jobs number ({linter.config.jobs}) should be greater than or equal to 0&#39;</span>
<span class="gd">-                , file=sys.stderr)</span>
<span class="gi">+                f&quot;Jobs number ({linter.config.jobs}) should be greater than or equal to 0&quot;,</span>
<span class="gi">+                file=sys.stderr,</span>
<span class="gi">+            )</span>
<span class="w"> </span>            sys.exit(32)
<span class="w"> </span>        if linter.config.jobs &gt; 1 or linter.config.jobs == 0:
<span class="w"> </span>            if ProcessPoolExecutor is None:
<span class="w"> </span>                print(
<span class="gd">-                    &#39;concurrent.futures module is missing, fallback to single process&#39;</span>
<span class="gd">-                    , file=sys.stderr)</span>
<span class="gd">-                linter.set_option(&#39;jobs&#39;, 1)</span>
<span class="gi">+                    &quot;concurrent.futures module is missing, fallback to single process&quot;,</span>
<span class="gi">+                    file=sys.stderr,</span>
<span class="gi">+                )</span>
<span class="gi">+                linter.set_option(&quot;jobs&quot;, 1)</span>
<span class="w"> </span>            elif linter.config.jobs == 0:
<span class="w"> </span>                linter.config.jobs = _cpu_count()
<span class="gi">+</span>
<span class="w"> </span>        if self._output:
<span class="w"> </span>            try:
<span class="gd">-                with open(self._output, &#39;w&#39;, encoding=&#39;utf-8&#39;) as output:</span>
<span class="gi">+                with open(self._output, &quot;w&quot;, encoding=&quot;utf-8&quot;) as output:</span>
<span class="w"> </span>                    linter.reporter.out = output
<span class="w"> </span>                    linter.check(args)
<span class="w"> </span>                    score_value = linter.generate_reports(verbose=self.verbose)
<span class="gu">@@ -120,15 +213,20 @@ class Run:</span>
<span class="w"> </span>        if linter.config.clear_cache_post_run:
<span class="w"> </span>            clear_lru_caches()
<span class="w"> </span>            MANAGER.clear_cache()
<span class="gi">+</span>
<span class="w"> </span>        if exit:
<span class="w"> </span>            if linter.config.exit_zero:
<span class="w"> </span>                sys.exit(0)
<span class="w"> </span>            elif linter.any_fail_on_issues():
<span class="gi">+                # We need to make sure we return a failing exit code in this case.</span>
<span class="gi">+                # So we use self.linter.msg_status if that is non-zero, otherwise we just return 1.</span>
<span class="w"> </span>                sys.exit(self.linter.msg_status or 1)
<span class="w"> </span>            elif score_value is not None:
<span class="w"> </span>                if score_value &gt;= linter.config.fail_under:
<span class="w"> </span>                    sys.exit(0)
<span class="w"> </span>                else:
<span class="gi">+                    # We need to make sure we return a failing exit code in this case.</span>
<span class="gi">+                    # So we use self.linter.msg_status if that is non-zero, otherwise we just return 1.</span>
<span class="w"> </span>                    sys.exit(self.linter.msg_status or 1)
<span class="w"> </span>            else:
<span class="w"> </span>                sys.exit(self.linter.msg_status)
<span class="gu">@@ -136,6 +234,7 @@ class Run:</span>

<span class="w"> </span>class _PylintConfigRun(Run):
<span class="w"> </span>    &quot;&quot;&quot;A private wrapper for the &#39;pylint-config&#39; command.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _is_pylint_config: ClassVar[bool] = True
<span class="w"> </span>    &quot;&quot;&quot;Boolean whether or not this is a &#39;pylint-config&#39; run.

<span class="gh">diff --git a/pylint/lint/utils.py b/pylint/lint/utils.py</span>
<span class="gh">index ec27fb7a9..a7fbfd0bc 100644</span>
<span class="gd">--- a/pylint/lint/utils.py</span>
<span class="gi">+++ b/pylint/lint/utils.py</span>
<span class="gu">@@ -1,4 +1,9 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import platform
<span class="w"> </span>import sys
<span class="gu">@@ -6,19 +11,138 @@ import traceback</span>
<span class="w"> </span>from collections.abc import Iterator, Sequence
<span class="w"> </span>from datetime import datetime
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from pylint.constants import PYLINT_HOME, full_version


<span class="gi">+def prepare_crash_report(ex: Exception, filepath: str, crash_file_path: str) -&gt; Path:</span>
<span class="gi">+    issue_template_path = (</span>
<span class="gi">+        Path(PYLINT_HOME) / datetime.now().strftime(str(crash_file_path))</span>
<span class="gi">+    ).resolve()</span>
<span class="gi">+    with open(filepath, encoding=&quot;utf8&quot;) as f:</span>
<span class="gi">+        file_content = f.read()</span>
<span class="gi">+    template = &quot;&quot;</span>
<span class="gi">+    if not issue_template_path.exists():</span>
<span class="gi">+        template = &quot;&quot;&quot;\</span>
<span class="gi">+First, please verify that the bug is not already filled:</span>
<span class="gi">+https://github.com/pylint-dev/pylint/issues/</span>
<span class="gi">+</span>
<span class="gi">+Then create a new issue:</span>
<span class="gi">+https://github.com/pylint-dev/pylint/issues/new?labels=Crash 💥%2CNeeds triage 📥</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+    template += f&quot;&quot;&quot;</span>
<span class="gi">+Issue title:</span>
<span class="gi">+Crash ``{ex}`` (if possible, be more specific about what made pylint crash)</span>
<span class="gi">+</span>
<span class="gi">+### Bug description</span>
<span class="gi">+</span>
<span class="gi">+When parsing the following ``a.py``:</span>
<span class="gi">+</span>
<span class="gi">+&lt;!--</span>
<span class="gi">+ If sharing the code is not an option, please state so,</span>
<span class="gi">+ but providing only the stacktrace would still be helpful.</span>
<span class="gi">+ --&gt;</span>
<span class="gi">+</span>
<span class="gi">+```python</span>
<span class="gi">+{file_content}</span>
<span class="gi">+```</span>
<span class="gi">+</span>
<span class="gi">+### Command used</span>
<span class="gi">+</span>
<span class="gi">+```shell</span>
<span class="gi">+pylint a.py</span>
<span class="gi">+```</span>
<span class="gi">+</span>
<span class="gi">+### Pylint output</span>
<span class="gi">+</span>
<span class="gi">+&lt;details open&gt;</span>
<span class="gi">+    &lt;summary&gt;</span>
<span class="gi">+        pylint crashed with a ``{ex.__class__.__name__}`` and with the following stacktrace:</span>
<span class="gi">+    &lt;/summary&gt;</span>
<span class="gi">+</span>
<span class="gi">+```python</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+    template += traceback.format_exc()</span>
<span class="gi">+    template += f&quot;&quot;&quot;</span>
<span class="gi">+```</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+&lt;/details&gt;</span>
<span class="gi">+</span>
<span class="gi">+### Expected behavior</span>
<span class="gi">+</span>
<span class="gi">+No crash.</span>
<span class="gi">+</span>
<span class="gi">+### Pylint version</span>
<span class="gi">+</span>
<span class="gi">+```shell</span>
<span class="gi">+{full_version}</span>
<span class="gi">+```</span>
<span class="gi">+</span>
<span class="gi">+### OS / Environment</span>
<span class="gi">+</span>
<span class="gi">+{sys.platform} ({platform.system()})</span>
<span class="gi">+</span>
<span class="gi">+### Additional dependencies</span>
<span class="gi">+</span>
<span class="gi">+&lt;!--</span>
<span class="gi">+Please remove this part if you&#39;re not using any of</span>
<span class="gi">+your dependencies in the example.</span>
<span class="gi">+ --&gt;</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        with open(issue_template_path, &quot;a&quot;, encoding=&quot;utf8&quot;) as f:</span>
<span class="gi">+            f.write(template)</span>
<span class="gi">+    except Exception as exc:  # pylint: disable=broad-except</span>
<span class="gi">+        print(</span>
<span class="gi">+            f&quot;Can&#39;t write the issue template for the crash in {issue_template_path} &quot;</span>
<span class="gi">+            f&quot;because of: &#39;{exc}&#39;\nHere&#39;s the content anyway:\n{template}.&quot;,</span>
<span class="gi">+            file=sys.stderr,</span>
<span class="gi">+        )</span>
<span class="gi">+    return issue_template_path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_fatal_error_message(filepath: str, issue_template_path: Path) -&gt; str:</span>
<span class="gi">+    return (</span>
<span class="gi">+        f&quot;Fatal error while checking &#39;{filepath}&#39;. &quot;</span>
<span class="gi">+        f&quot;Please open an issue in our bug tracker so we address this. &quot;</span>
<span class="gi">+        f&quot;There is a pre-filled template that you can use in &#39;{issue_template_path}&#39;.&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _augment_sys_path(additional_paths: Sequence[str]) -&gt; list[str]:</span>
<span class="gi">+    original = list(sys.path)</span>
<span class="gi">+    changes = []</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for additional_path in additional_paths:</span>
<span class="gi">+        if additional_path not in seen:</span>
<span class="gi">+            changes.append(additional_path)</span>
<span class="gi">+            seen.add(additional_path)</span>
<span class="gi">+</span>
<span class="gi">+    sys.path[:] = changes + sys.path</span>
<span class="gi">+    return original</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>@contextlib.contextmanager
<span class="gd">-def augmented_sys_path(additional_paths: Sequence[str]) -&gt;Iterator[None]:</span>
<span class="gi">+def augmented_sys_path(additional_paths: Sequence[str]) -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Augment &#39;sys.path&#39; by adding non-existent entries from additional_paths.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    original = _augment_sys_path(additional_paths)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        sys.path[:] = original</span>


<span class="gd">-def _is_relative_to(self: Path, *other: Path) -&gt;bool:</span>
<span class="gi">+def _is_relative_to(self: Path, *other: Path) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Checks if self is relative to other.

<span class="w"> </span>    Backport of pathlib.Path.is_relative_to for Python &lt;3.9
<span class="w"> </span>    TODO: py39: Remove this backport and use stdlib function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        self.relative_to(*other)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/pylint/message/_deleted_message_ids.py b/pylint/message/_deleted_message_ids.py</span>
<span class="gh">index dbcd3d0ab..60289e805 100644</span>
<span class="gd">--- a/pylint/message/_deleted_message_ids.py</span>
<span class="gi">+++ b/pylint/message/_deleted_message_ids.py</span>
<span class="gu">@@ -1,4 +1,9 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from functools import lru_cache
<span class="w"> </span>from typing import NamedTuple

<span class="gu">@@ -10,98 +15,165 @@ class DeletedMessage(NamedTuple):</span>


<span class="w"> </span>DELETED_MSGID_PREFIXES: list[int] = []
<span class="gd">-DELETED_MESSAGES_IDS = {&#39;https://github.com/pylint-dev/pylint/pull/4942&#39;: [</span>
<span class="gd">-    DeletedMessage(&#39;W1601&#39;, &#39;apply-builtin&#39;), DeletedMessage(&#39;E1601&#39;,</span>
<span class="gd">-    &#39;print-statement&#39;), DeletedMessage(&#39;E1602&#39;, &#39;parameter-unpacking&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;E1603&#39;, &#39;unpacking-in-except&#39;, [(&#39;W0712&#39;,</span>
<span class="gd">-    &#39;old-unpacking-in-except&#39;)]), DeletedMessage(&#39;E1604&#39;,</span>
<span class="gd">-    &#39;old-raise-syntax&#39;, [(&#39;W0121&#39;, &#39;old-old-raise-syntax&#39;)]),</span>
<span class="gd">-    DeletedMessage(&#39;E1605&#39;, &#39;backtick&#39;, [(&#39;W0333&#39;, &#39;old-backtick&#39;)]),</span>
<span class="gd">-    DeletedMessage(&#39;E1609&#39;, &#39;import-star-module-level&#39;), DeletedMessage(</span>
<span class="gd">-    &#39;W1601&#39;, &#39;apply-builtin&#39;), DeletedMessage(&#39;W1602&#39;, &#39;basestring-builtin&#39;</span>
<span class="gd">-    ), DeletedMessage(&#39;W1603&#39;, &#39;buffer-builtin&#39;), DeletedMessage(&#39;W1604&#39;,</span>
<span class="gd">-    &#39;cmp-builtin&#39;), DeletedMessage(&#39;W1605&#39;, &#39;coerce-builtin&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1606&#39;, &#39;execfile-builtin&#39;), DeletedMessage(&#39;W1607&#39;,</span>
<span class="gd">-    &#39;file-builtin&#39;), DeletedMessage(&#39;W1608&#39;, &#39;long-builtin&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1609&#39;, &#39;raw_input-builtin&#39;), DeletedMessage(&#39;W1610&#39;,</span>
<span class="gd">-    &#39;reduce-builtin&#39;), DeletedMessage(&#39;W1611&#39;, &#39;standarderror-builtin&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1612&#39;, &#39;unicode-builtin&#39;), DeletedMessage(&#39;W1613&#39;,</span>
<span class="gd">-    &#39;xrange-builtin&#39;), DeletedMessage(&#39;W1614&#39;, &#39;coerce-method&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1615&#39;, &#39;delslice-method&#39;), DeletedMessage(&#39;W1616&#39;,</span>
<span class="gd">-    &#39;getslice-method&#39;), DeletedMessage(&#39;W1617&#39;, &#39;setslice-method&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1618&#39;, &#39;no-absolute-import&#39;), DeletedMessage(&#39;W1619&#39;,</span>
<span class="gd">-    &#39;old-division&#39;), DeletedMessage(&#39;W1620&#39;, &#39;dict-iter-method&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1621&#39;, &#39;dict-view-method&#39;), DeletedMessage(&#39;W1622&#39;,</span>
<span class="gd">-    &#39;next-method-called&#39;), DeletedMessage(&#39;W1623&#39;, &#39;metaclass-assignment&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1624&#39;, &#39;indexing-exception&#39;, [(&#39;W0713&#39;,</span>
<span class="gd">-    &#39;old-indexing-exception&#39;)]), DeletedMessage(&#39;W1625&#39;, &#39;raising-string&#39;,</span>
<span class="gd">-    [(&#39;W0701&#39;, &#39;old-raising-string&#39;)]), DeletedMessage(&#39;W1626&#39;,</span>
<span class="gd">-    &#39;reload-builtin&#39;), DeletedMessage(&#39;W1627&#39;, &#39;oct-method&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1628&#39;, &#39;hex-method&#39;), DeletedMessage(&#39;W1629&#39;,</span>
<span class="gd">-    &#39;nonzero-method&#39;), DeletedMessage(&#39;W1630&#39;, &#39;cmp-method&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1632&#39;, &#39;input-builtin&#39;), DeletedMessage(&#39;W1633&#39;,</span>
<span class="gd">-    &#39;round-builtin&#39;), DeletedMessage(&#39;W1634&#39;, &#39;intern-builtin&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1635&#39;, &#39;unichr-builtin&#39;), DeletedMessage(&#39;W1636&#39;,</span>
<span class="gd">-    &#39;map-builtin-not-iterating&#39;, [(&#39;W1631&#39;, &#39;implicit-map-evaluation&#39;)]),</span>
<span class="gd">-    DeletedMessage(&#39;W1637&#39;, &#39;zip-builtin-not-iterating&#39;), DeletedMessage(</span>
<span class="gd">-    &#39;W1638&#39;, &#39;range-builtin-not-iterating&#39;), DeletedMessage(&#39;W1639&#39;,</span>
<span class="gd">-    &#39;filter-builtin-not-iterating&#39;), DeletedMessage(&#39;W1640&#39;,</span>
<span class="gd">-    &#39;using-cmp-argument&#39;), DeletedMessage(&#39;W1642&#39;, &#39;div-method&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1643&#39;, &#39;idiv-method&#39;), DeletedMessage(&#39;W1644&#39;,</span>
<span class="gd">-    &#39;rdiv-method&#39;), DeletedMessage(&#39;W1645&#39;, &#39;exception-message-attribute&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1646&#39;, &#39;invalid-str-codec&#39;), DeletedMessage(&#39;W1647&#39;,</span>
<span class="gd">-    &#39;sys-max-int&#39;), DeletedMessage(&#39;W1648&#39;, &#39;bad-python3-import&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1649&#39;, &#39;deprecated-string-function&#39;), DeletedMessage(</span>
<span class="gd">-    &#39;W1650&#39;, &#39;deprecated-str-translate-call&#39;), DeletedMessage(&#39;W1651&#39;,</span>
<span class="gd">-    &#39;deprecated-itertools-function&#39;), DeletedMessage(&#39;W1652&#39;,</span>
<span class="gd">-    &#39;deprecated-types-field&#39;), DeletedMessage(&#39;W1653&#39;,</span>
<span class="gd">-    &#39;next-method-defined&#39;), DeletedMessage(&#39;W1654&#39;,</span>
<span class="gd">-    &#39;dict-items-not-iterating&#39;), DeletedMessage(&#39;W1655&#39;,</span>
<span class="gd">-    &#39;dict-keys-not-iterating&#39;), DeletedMessage(&#39;W1656&#39;,</span>
<span class="gd">-    &#39;dict-values-not-iterating&#39;), DeletedMessage(&#39;W1657&#39;,</span>
<span class="gd">-    &#39;deprecated-operator-function&#39;), DeletedMessage(&#39;W1658&#39;,</span>
<span class="gd">-    &#39;deprecated-urllib-function&#39;), DeletedMessage(&#39;W1659&#39;,</span>
<span class="gd">-    &#39;xreadlines-attribute&#39;), DeletedMessage(&#39;W1660&#39;,</span>
<span class="gd">-    &#39;deprecated-sys-function&#39;), DeletedMessage(&#39;W1661&#39;, &#39;exception-escape&#39;),</span>
<span class="gd">-    DeletedMessage(&#39;W1662&#39;, &#39;comprehension-escape&#39;)],</span>
<span class="gd">-    &#39;https://github.com/pylint-dev/pylint/pull/3578&#39;: [DeletedMessage(</span>
<span class="gd">-    &#39;W0312&#39;, &#39;mixed-indentation&#39;)],</span>
<span class="gd">-    &#39;https://github.com/pylint-dev/pylint/pull/3577&#39;: [DeletedMessage(</span>
<span class="gd">-    &#39;C0326&#39;, &#39;bad-whitespace&#39;, [(&#39;C0323&#39;, &#39;no-space-after-operator&#39;), (</span>
<span class="gd">-    &#39;C0324&#39;, &#39;no-space-after-comma&#39;), (&#39;C0322&#39;, &#39;no-space-before-operator&#39;)</span>
<span class="gd">-    ])], &#39;https://github.com/pylint-dev/pylint/pull/3571&#39;: [DeletedMessage(</span>
<span class="gd">-    &#39;C0330&#39;, &#39;bad-continuation&#39;)],</span>
<span class="gd">-    &#39;https://pylint.readthedocs.io/en/latest/whatsnew/1/1.4.html#what-s-new-in-pylint-1-4-3&#39;</span>
<span class="gd">-    : [DeletedMessage(&#39;R0921&#39;, &#39;abstract-class-not-used&#39;), DeletedMessage(</span>
<span class="gd">-    &#39;R0922&#39;, &#39;abstract-class-little-used&#39;), DeletedMessage(&#39;W0142&#39;,</span>
<span class="gd">-    &#39;star-args&#39;)], &#39;https://github.com/pylint-dev/pylint/issues/2409&#39;: [</span>
<span class="gd">-    DeletedMessage(&#39;W0232&#39;, &#39;no-init&#39;)],</span>
<span class="gd">-    &#39;https://github.com/pylint-dev/pylint/pull/6421&#39;: [DeletedMessage(</span>
<span class="gd">-    &#39;W0111&#39;, &#39;assign-to-new-keyword&#39;)]}</span>
<span class="gi">+</span>
<span class="gi">+DELETED_MESSAGES_IDS = {</span>
<span class="gi">+    # Everything until the next comment is from the PY3K+ checker</span>
<span class="gi">+    &quot;https://github.com/pylint-dev/pylint/pull/4942&quot;: [</span>
<span class="gi">+        DeletedMessage(&quot;W1601&quot;, &quot;apply-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;E1601&quot;, &quot;print-statement&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;E1602&quot;, &quot;parameter-unpacking&quot;),</span>
<span class="gi">+        DeletedMessage(</span>
<span class="gi">+            &quot;E1603&quot;, &quot;unpacking-in-except&quot;, [(&quot;W0712&quot;, &quot;old-unpacking-in-except&quot;)]</span>
<span class="gi">+        ),</span>
<span class="gi">+        DeletedMessage(</span>
<span class="gi">+            &quot;E1604&quot;, &quot;old-raise-syntax&quot;, [(&quot;W0121&quot;, &quot;old-old-raise-syntax&quot;)]</span>
<span class="gi">+        ),</span>
<span class="gi">+        DeletedMessage(&quot;E1605&quot;, &quot;backtick&quot;, [(&quot;W0333&quot;, &quot;old-backtick&quot;)]),</span>
<span class="gi">+        DeletedMessage(&quot;E1609&quot;, &quot;import-star-module-level&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1601&quot;, &quot;apply-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1602&quot;, &quot;basestring-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1603&quot;, &quot;buffer-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1604&quot;, &quot;cmp-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1605&quot;, &quot;coerce-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1606&quot;, &quot;execfile-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1607&quot;, &quot;file-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1608&quot;, &quot;long-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1609&quot;, &quot;raw_input-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1610&quot;, &quot;reduce-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1611&quot;, &quot;standarderror-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1612&quot;, &quot;unicode-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1613&quot;, &quot;xrange-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1614&quot;, &quot;coerce-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1615&quot;, &quot;delslice-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1616&quot;, &quot;getslice-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1617&quot;, &quot;setslice-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1618&quot;, &quot;no-absolute-import&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1619&quot;, &quot;old-division&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1620&quot;, &quot;dict-iter-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1621&quot;, &quot;dict-view-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1622&quot;, &quot;next-method-called&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1623&quot;, &quot;metaclass-assignment&quot;),</span>
<span class="gi">+        DeletedMessage(</span>
<span class="gi">+            &quot;W1624&quot;, &quot;indexing-exception&quot;, [(&quot;W0713&quot;, &quot;old-indexing-exception&quot;)]</span>
<span class="gi">+        ),</span>
<span class="gi">+        DeletedMessage(&quot;W1625&quot;, &quot;raising-string&quot;, [(&quot;W0701&quot;, &quot;old-raising-string&quot;)]),</span>
<span class="gi">+        DeletedMessage(&quot;W1626&quot;, &quot;reload-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1627&quot;, &quot;oct-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1628&quot;, &quot;hex-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1629&quot;, &quot;nonzero-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1630&quot;, &quot;cmp-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1632&quot;, &quot;input-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1633&quot;, &quot;round-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1634&quot;, &quot;intern-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1635&quot;, &quot;unichr-builtin&quot;),</span>
<span class="gi">+        DeletedMessage(</span>
<span class="gi">+            &quot;W1636&quot;, &quot;map-builtin-not-iterating&quot;, [(&quot;W1631&quot;, &quot;implicit-map-evaluation&quot;)]</span>
<span class="gi">+        ),</span>
<span class="gi">+        DeletedMessage(&quot;W1637&quot;, &quot;zip-builtin-not-iterating&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1638&quot;, &quot;range-builtin-not-iterating&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1639&quot;, &quot;filter-builtin-not-iterating&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1640&quot;, &quot;using-cmp-argument&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1642&quot;, &quot;div-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1643&quot;, &quot;idiv-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1644&quot;, &quot;rdiv-method&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1645&quot;, &quot;exception-message-attribute&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1646&quot;, &quot;invalid-str-codec&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1647&quot;, &quot;sys-max-int&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1648&quot;, &quot;bad-python3-import&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1649&quot;, &quot;deprecated-string-function&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1650&quot;, &quot;deprecated-str-translate-call&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1651&quot;, &quot;deprecated-itertools-function&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1652&quot;, &quot;deprecated-types-field&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1653&quot;, &quot;next-method-defined&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1654&quot;, &quot;dict-items-not-iterating&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1655&quot;, &quot;dict-keys-not-iterating&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1656&quot;, &quot;dict-values-not-iterating&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1657&quot;, &quot;deprecated-operator-function&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1658&quot;, &quot;deprecated-urllib-function&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1659&quot;, &quot;xreadlines-attribute&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1660&quot;, &quot;deprecated-sys-function&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1661&quot;, &quot;exception-escape&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W1662&quot;, &quot;comprehension-escape&quot;),</span>
<span class="gi">+    ],</span>
<span class="gi">+    &quot;https://github.com/pylint-dev/pylint/pull/3578&quot;: [</span>
<span class="gi">+        DeletedMessage(&quot;W0312&quot;, &quot;mixed-indentation&quot;),</span>
<span class="gi">+    ],</span>
<span class="gi">+    &quot;https://github.com/pylint-dev/pylint/pull/3577&quot;: [</span>
<span class="gi">+        DeletedMessage(</span>
<span class="gi">+            &quot;C0326&quot;,</span>
<span class="gi">+            &quot;bad-whitespace&quot;,</span>
<span class="gi">+            [</span>
<span class="gi">+                (&quot;C0323&quot;, &quot;no-space-after-operator&quot;),</span>
<span class="gi">+                (&quot;C0324&quot;, &quot;no-space-after-comma&quot;),</span>
<span class="gi">+                (&quot;C0322&quot;, &quot;no-space-before-operator&quot;),</span>
<span class="gi">+            ],</span>
<span class="gi">+        ),</span>
<span class="gi">+    ],</span>
<span class="gi">+    &quot;https://github.com/pylint-dev/pylint/pull/3571&quot;: [</span>
<span class="gi">+        DeletedMessage(&quot;C0330&quot;, &quot;bad-continuation&quot;)</span>
<span class="gi">+    ],</span>
<span class="gi">+    &quot;https://pylint.readthedocs.io/en/latest/whatsnew/1/1.4.html#what-s-new-in-pylint-1-4-3&quot;: [</span>
<span class="gi">+        DeletedMessage(&quot;R0921&quot;, &quot;abstract-class-not-used&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;R0922&quot;, &quot;abstract-class-little-used&quot;),</span>
<span class="gi">+        DeletedMessage(&quot;W0142&quot;, &quot;star-args&quot;),</span>
<span class="gi">+    ],</span>
<span class="gi">+    &quot;https://github.com/pylint-dev/pylint/issues/2409&quot;: [</span>
<span class="gi">+        DeletedMessage(&quot;W0232&quot;, &quot;no-init&quot;),</span>
<span class="gi">+    ],</span>
<span class="gi">+    &quot;https://github.com/pylint-dev/pylint/pull/6421&quot;: [</span>
<span class="gi">+        DeletedMessage(&quot;W0111&quot;, &quot;assign-to-new-keyword&quot;),</span>
<span class="gi">+    ],</span>
<span class="gi">+}</span>
<span class="w"> </span>MOVED_TO_EXTENSIONS = {
<span class="gd">-    &#39;https://pylint.readthedocs.io/en/latest/whatsnew/2/2.14/summary.html#removed-checkers&#39;</span>
<span class="gd">-    : [DeletedMessage(&#39;R0201&#39;, &#39;no-self-use&#39;)]}</span>
<span class="gi">+    &quot;https://pylint.readthedocs.io/en/latest/whatsnew/2/2.14/summary.html#removed-checkers&quot;: [</span>
<span class="gi">+        DeletedMessage(&quot;R0201&quot;, &quot;no-self-use&quot;)</span>
<span class="gi">+    ],</span>
<span class="gi">+}</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="gd">-def is_deleted_symbol(symbol: str) -&gt;(str | None):</span>
<span class="gi">+def is_deleted_symbol(symbol: str) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the explanation for removal if the message was removed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for explanation, deleted_messages in DELETED_MESSAGES_IDS.items():</span>
<span class="gi">+        for deleted_message in deleted_messages:</span>
<span class="gi">+            if symbol == deleted_message.symbol or any(</span>
<span class="gi">+                symbol == m[1] for m in deleted_message.old_names</span>
<span class="gi">+            ):</span>
<span class="gi">+                return explanation</span>
<span class="gi">+    return None</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="gd">-def is_deleted_msgid(msgid: str) -&gt;(str | None):</span>
<span class="gi">+def is_deleted_msgid(msgid: str) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the explanation for removal if the message was removed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for explanation, deleted_messages in DELETED_MESSAGES_IDS.items():</span>
<span class="gi">+        for deleted_message in deleted_messages:</span>
<span class="gi">+            if msgid == deleted_message.msgid or any(</span>
<span class="gi">+                msgid == m[0] for m in deleted_message.old_names</span>
<span class="gi">+            ):</span>
<span class="gi">+                return explanation</span>
<span class="gi">+    return None</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="gd">-def is_moved_symbol(symbol: str) -&gt;(str | None):</span>
<span class="gi">+def is_moved_symbol(symbol: str) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the explanation for moving if the message was moved to extensions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for explanation, moved_messages in MOVED_TO_EXTENSIONS.items():</span>
<span class="gi">+        for moved_message in moved_messages:</span>
<span class="gi">+            if symbol == moved_message.symbol or any(</span>
<span class="gi">+                symbol == m[1] for m in moved_message.old_names</span>
<span class="gi">+            ):</span>
<span class="gi">+                return explanation</span>
<span class="gi">+    return None</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="gd">-def is_moved_msgid(msgid: str) -&gt;(str | None):</span>
<span class="gi">+def is_moved_msgid(msgid: str) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the explanation for moving if the message was moved to extensions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for explanation, moved_messages in MOVED_TO_EXTENSIONS.items():</span>
<span class="gi">+        for moved_message in moved_messages:</span>
<span class="gi">+            if msgid == moved_message.msgid or any(</span>
<span class="gi">+                msgid == m[0] for m in moved_message.old_names</span>
<span class="gi">+            ):</span>
<span class="gi">+                return explanation</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/pylint/message/message.py b/pylint/message/message.py</span>
<span class="gh">index f8eac91be..6ee8c5f78 100644</span>
<span class="gd">--- a/pylint/message/message.py</span>
<span class="gi">+++ b/pylint/message/message.py</span>
<span class="gu">@@ -1,13 +1,20 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from dataclasses import asdict, dataclass
<span class="gi">+</span>
<span class="w"> </span>from pylint.constants import MSG_TYPES
<span class="w"> </span>from pylint.interfaces import UNDEFINED, Confidence
<span class="w"> </span>from pylint.typing import MessageLocationTuple


<span class="w"> </span>@dataclass(unsafe_hash=True)
<span class="gd">-class Message:</span>
<span class="gi">+class Message:  # pylint: disable=too-many-instance-attributes</span>
<span class="w"> </span>    &quot;&quot;&quot;This class represent a message to be issued by the reporters.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    msg_id: str
<span class="w"> </span>    symbol: str
<span class="w"> </span>    msg: str
<span class="gu">@@ -23,9 +30,14 @@ class Message:</span>
<span class="w"> </span>    end_line: int | None
<span class="w"> </span>    end_column: int | None

<span class="gd">-    def __init__(self, msg_id: str, symbol: str, location:</span>
<span class="gd">-        MessageLocationTuple, msg: str, confidence: (Confidence | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg_id: str,</span>
<span class="gi">+        symbol: str,</span>
<span class="gi">+        location: MessageLocationTuple,</span>
<span class="gi">+        msg: str,</span>
<span class="gi">+        confidence: Confidence | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.msg_id = msg_id
<span class="w"> </span>        self.symbol = symbol
<span class="w"> </span>        self.msg = msg
<span class="gu">@@ -41,10 +53,23 @@ class Message:</span>
<span class="w"> </span>        self.end_line = location.end_line
<span class="w"> </span>        self.end_column = location.end_column

<span class="gd">-    def format(self, template: str) -&gt;str:</span>
<span class="gi">+    def format(self, template: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Format the message according to the given template.

<span class="w"> </span>        The template format is the one of the format method :
<span class="w"> </span>        cf. https://docs.python.org/2/library/string.html#formatstrings
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return template.format(**asdict(self))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def location(self) -&gt; MessageLocationTuple:</span>
<span class="gi">+        return MessageLocationTuple(</span>
<span class="gi">+            self.abspath,</span>
<span class="gi">+            self.path,</span>
<span class="gi">+            self.module,</span>
<span class="gi">+            self.obj,</span>
<span class="gi">+            self.line,</span>
<span class="gi">+            self.column,</span>
<span class="gi">+            self.end_line,</span>
<span class="gi">+            self.end_column,</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/pylint/message/message_definition.py b/pylint/message/message_definition.py</span>
<span class="gh">index 4ae7655d2..a318cc83f 100644</span>
<span class="gd">--- a/pylint/message/message_definition.py</span>
<span class="gi">+++ b/pylint/message/message_definition.py</span>
<span class="gu">@@ -1,21 +1,38 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.constants import _SCOPE_EXEMPT, MSG_TYPES, WarningScope
<span class="w"> </span>from pylint.exceptions import InvalidMessageError
<span class="w"> </span>from pylint.utils import normalize_text
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.checkers import BaseChecker


<span class="w"> </span>class MessageDefinition:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, checker: BaseChecker, msgid: str, msg: str,</span>
<span class="gd">-        description: str, symbol: str, scope: str, minversion: (tuple[int,</span>
<span class="gd">-        int] | None)=None, maxversion: (tuple[int, int] | None)=None,</span>
<span class="gd">-        old_names: (list[tuple[str, str]] | None)=None, shared: bool=False,</span>
<span class="gd">-        default_enabled: bool=True) -&gt;None:</span>
<span class="gi">+    # pylint: disable-next=too-many-arguments</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        checker: BaseChecker,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        msg: str,</span>
<span class="gi">+        description: str,</span>
<span class="gi">+        symbol: str,</span>
<span class="gi">+        scope: str,</span>
<span class="gi">+        minversion: tuple[int, int] | None = None,</span>
<span class="gi">+        maxversion: tuple[int, int] | None = None,</span>
<span class="gi">+        old_names: list[tuple[str, str]] | None = None,</span>
<span class="gi">+        shared: bool = False,</span>
<span class="gi">+        default_enabled: bool = True,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.checker_name = checker.name
<span class="w"> </span>        self.check_msgid(msgid)
<span class="w"> </span>        self.msgid = msgid
<span class="gu">@@ -31,28 +48,84 @@ class MessageDefinition:</span>
<span class="w"> </span>        if old_names:
<span class="w"> </span>            for old_msgid, old_symbol in old_names:
<span class="w"> </span>                self.check_msgid(old_msgid)
<span class="gd">-                self.old_names.append((old_msgid, old_symbol))</span>
<span class="gi">+                self.old_names.append(</span>
<span class="gi">+                    (old_msgid, old_symbol),</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def check_msgid(msgid: str) -&gt; None:</span>
<span class="gi">+        if len(msgid) != 5:</span>
<span class="gi">+            raise InvalidMessageError(f&quot;Invalid message id {msgid!r}&quot;)</span>
<span class="gi">+        if msgid[0] not in MSG_TYPES:</span>
<span class="gi">+            raise InvalidMessageError(f&quot;Bad message type {msgid[0]} in {msgid!r}&quot;)</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gd">-        return isinstance(other, MessageDefinition</span>
<span class="gd">-            ) and self.msgid == other.msgid and self.symbol == other.symbol</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            isinstance(other, MessageDefinition)</span>
<span class="gi">+            and self.msgid == other.msgid</span>
<span class="gi">+            and self.symbol == other.symbol</span>
<span class="gi">+        )</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;MessageDefinition:{self.symbol} ({self.msgid})&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;MessageDefinition:{self.symbol} ({self.msgid})&quot;</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;{self!r}:\n{self.msg} {self.description}&#39;</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self!r}:\n{self.msg} {self.description}&quot;</span>

<span class="gd">-    def may_be_emitted(self, py_version: (tuple[int, ...] | sys._version_info)</span>
<span class="gd">-        ) -&gt;bool:</span>
<span class="gi">+    def may_be_emitted(self, py_version: tuple[int, ...] | sys._version_info) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;May the message be emitted using the configured py_version?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.minversion is not None and self.minversion &gt; py_version:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if self.maxversion is not None and self.maxversion &lt;= py_version:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>

<span class="gd">-    def format_help(self, checkerref: bool=False) -&gt;str:</span>
<span class="gi">+    def format_help(self, checkerref: bool = False) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the help string for the given message id.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        desc = self.description</span>
<span class="gi">+        if checkerref:</span>
<span class="gi">+            desc += f&quot; This message belongs to the {self.checker_name} checker.&quot;</span>
<span class="gi">+        title = self.msg</span>
<span class="gi">+        if self.minversion or self.maxversion:</span>
<span class="gi">+            restr = []</span>
<span class="gi">+            if self.minversion:</span>
<span class="gi">+                restr.append(f&quot;&lt; {&#39;.&#39;.join(str(n) for n in self.minversion)}&quot;)</span>
<span class="gi">+            if self.maxversion:</span>
<span class="gi">+                restr.append(f&quot;&gt;= {&#39;.&#39;.join(str(n) for n in self.maxversion)}&quot;)</span>
<span class="gi">+            restriction = &quot; or &quot;.join(restr)</span>
<span class="gi">+            if checkerref:</span>
<span class="gi">+                desc += f&quot; It can&#39;t be emitted when using Python {restriction}.&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                desc += (</span>
<span class="gi">+                    f&quot; This message can&#39;t be emitted when using Python {restriction}.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        msg_help = normalize_text(&quot; &quot;.join(desc.split()), indent=&quot;  &quot;)</span>
<span class="gi">+        message_id = f&quot;{self.symbol} ({self.msgid})&quot;</span>
<span class="gi">+        if title != &quot;%s&quot;:</span>
<span class="gi">+            title = title.splitlines()[0]</span>
<span class="gi">+            return f&quot;:{message_id}: *{title.rstrip(&#39; &#39;)}*\n{msg_help}&quot;</span>
<span class="gi">+        return f&quot;:{message_id}:\n{msg_help}&quot;</span>

<span class="gd">-    def check_message_definition(self, line: (int | None), node: (nodes.</span>
<span class="gd">-        NodeNG | None)) -&gt;None:</span>
<span class="gi">+    def check_message_definition(</span>
<span class="gi">+        self, line: int | None, node: nodes.NodeNG | None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check MessageDefinition for possible errors.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.msgid[0] not in _SCOPE_EXEMPT:</span>
<span class="gi">+            # Fatal messages and reports are special, the node/scope distinction</span>
<span class="gi">+            # does not apply to them.</span>
<span class="gi">+            if self.scope == WarningScope.LINE:</span>
<span class="gi">+                if line is None:</span>
<span class="gi">+                    raise InvalidMessageError(</span>
<span class="gi">+                        f&quot;Message {self.msgid} must provide line, got None&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                if node is not None:</span>
<span class="gi">+                    raise InvalidMessageError(</span>
<span class="gi">+                        f&quot;Message {self.msgid} must only provide line, &quot;</span>
<span class="gi">+                        f&quot;got line={line}, node={node}&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+            elif self.scope == WarningScope.NODE:</span>
<span class="gi">+                # Node-based warnings may provide an override line.</span>
<span class="gi">+                if node is None:</span>
<span class="gi">+                    raise InvalidMessageError(</span>
<span class="gi">+                        f&quot;Message {self.msgid} must provide Node, got None&quot;</span>
<span class="gi">+                    )</span>
<span class="gh">diff --git a/pylint/message/message_definition_store.py b/pylint/message/message_definition_store.py</span>
<span class="gh">index 98137664d..cf271d7ff 100644</span>
<span class="gd">--- a/pylint/message/message_definition_store.py</span>
<span class="gi">+++ b/pylint/message/message_definition_store.py</span>
<span class="gu">@@ -1,12 +1,19 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import functools
<span class="w"> </span>import sys
<span class="w"> </span>from collections.abc import Sequence, ValuesView
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from pylint.exceptions import UnknownMessageError
<span class="w"> </span>from pylint.message.message_definition import MessageDefinition
<span class="w"> </span>from pylint.message.message_id_store import MessageIdStore
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.checkers import BaseChecker

<span class="gu">@@ -16,51 +23,98 @@ class MessageDefinitionStore:</span>
<span class="w"> </span>    has no particular state during analysis.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, py_version: (tuple[int, ...] | sys._version_info)=</span>
<span class="gd">-        sys.version_info) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, py_version: tuple[int, ...] | sys._version_info = sys.version_info</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.message_id_store: MessageIdStore = MessageIdStore()
<span class="gi">+        # Primary registry for all active messages definitions.</span>
<span class="gi">+        # It contains the 1:1 mapping from msgid to MessageDefinition.</span>
<span class="gi">+        # Keys are msgid, values are MessageDefinition</span>
<span class="w"> </span>        self._messages_definitions: dict[str, MessageDefinition] = {}
<span class="gd">-        self._msgs_by_category: dict[str, list[str]] = collections.defaultdict(</span>
<span class="gd">-            list)</span>
<span class="gi">+        # MessageDefinition kept by category</span>
<span class="gi">+        self._msgs_by_category: dict[str, list[str]] = collections.defaultdict(list)</span>
<span class="w"> </span>        self.py_version = py_version

<span class="w"> </span>    @property
<span class="gd">-    def messages(self) -&gt;ValuesView[MessageDefinition]:</span>
<span class="gi">+    def messages(self) -&gt; ValuesView[MessageDefinition]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The list of all active messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._messages_definitions.values()</span>

<span class="gd">-    def register_messages_from_checker(self, checker: BaseChecker) -&gt;None:</span>
<span class="gi">+    def register_messages_from_checker(self, checker: BaseChecker) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register all messages definitions from a checker.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        checker.check_consistency()</span>
<span class="gi">+        for message in checker.messages:</span>
<span class="gi">+            self.register_message(message)</span>

<span class="gd">-    def register_message(self, message: MessageDefinition) -&gt;None:</span>
<span class="gi">+    def register_message(self, message: MessageDefinition) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a MessageDefinition with consistency in mind.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.message_id_store.register_message_definition(</span>
<span class="gi">+            message.msgid, message.symbol, message.old_names</span>
<span class="gi">+        )</span>
<span class="gi">+        self._messages_definitions[message.msgid] = message</span>
<span class="gi">+        self._msgs_by_category[message.msgid[0]].append(message.msgid)</span>

<span class="gd">-    @functools.lru_cache(maxsize=None)</span>
<span class="gd">-    def get_message_definitions(self, msgid_or_symbol: str) -&gt;list[</span>
<span class="gd">-        MessageDefinition]:</span>
<span class="gi">+    # Since MessageDefinitionStore is only initialized once</span>
<span class="gi">+    # and the arguments are relatively small we do not run the</span>
<span class="gi">+    # risk of creating a large memory leak.</span>
<span class="gi">+    # See discussion in: https://github.com/pylint-dev/pylint/pull/5673</span>
<span class="gi">+    @functools.lru_cache(  # pylint: disable=method-cache-max-size-none # noqa: B019</span>
<span class="gi">+        maxsize=None</span>
<span class="gi">+    )</span>
<span class="gi">+    def get_message_definitions(self, msgid_or_symbol: str) -&gt; list[MessageDefinition]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the Message definition for either a numeric or symbolic id.

<span class="w"> </span>        The cache has no limit as its size will likely stay minimal. For each message we store
<span class="w"> </span>        about 1000 characters, so even if we would have 1000 messages the cache would only
<span class="w"> </span>        take up ~= 1 Mb.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [</span>
<span class="gi">+            self._messages_definitions[m]</span>
<span class="gi">+            for m in self.message_id_store.get_active_msgids(msgid_or_symbol)</span>
<span class="gi">+        ]</span>

<span class="gd">-    def get_msg_display_string(self, msgid_or_symbol: str) -&gt;str:</span>
<span class="gi">+    def get_msg_display_string(self, msgid_or_symbol: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a user-consumable representation of a message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        message_definitions = self.get_message_definitions(msgid_or_symbol)</span>
<span class="gi">+        if len(message_definitions) == 1:</span>
<span class="gi">+            return repr(message_definitions[0].symbol)</span>
<span class="gi">+        return repr([md.symbol for md in message_definitions])</span>

<span class="gd">-    def help_message(self, msgids_or_symbols: Sequence[str]) -&gt;None:</span>
<span class="gi">+    def help_message(self, msgids_or_symbols: Sequence[str]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display help messages for the given message identifiers.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for msgids_or_symbol in msgids_or_symbols:</span>
<span class="gi">+            try:</span>
<span class="gi">+                for message_definition in self.get_message_definitions(</span>
<span class="gi">+                    msgids_or_symbol</span>
<span class="gi">+                ):</span>
<span class="gi">+                    print(message_definition.format_help(checkerref=True))</span>
<span class="gi">+                    print(&quot;&quot;)</span>
<span class="gi">+            except UnknownMessageError as ex:</span>
<span class="gi">+                print(ex)</span>
<span class="gi">+                print(&quot;&quot;)</span>
<span class="gi">+                continue</span>

<span class="gd">-    def list_messages(self) -&gt;None:</span>
<span class="gi">+    def list_messages(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Output full messages list documentation in ReST format.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        emittable, non_emittable = self.find_emittable_messages()</span>
<span class="gi">+        print(&quot;Emittable messages with current interpreter:&quot;)</span>
<span class="gi">+        for msg in emittable:</span>
<span class="gi">+            print(msg.format_help(checkerref=False))</span>
<span class="gi">+        print(&quot;\nNon-emittable messages with current interpreter:&quot;)</span>
<span class="gi">+        for msg in non_emittable:</span>
<span class="gi">+            print(msg.format_help(checkerref=False))</span>
<span class="gi">+        print(&quot;&quot;)</span>

<span class="gd">-    def find_emittable_messages(self) -&gt;tuple[list[MessageDefinition], list</span>
<span class="gd">-        [MessageDefinition]]:</span>
<span class="gi">+    def find_emittable_messages(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; tuple[list[MessageDefinition], list[MessageDefinition]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Finds all emittable and non-emittable messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        messages = sorted(self._messages_definitions.values(), key=lambda m: m.msgid)</span>
<span class="gi">+        emittable = []</span>
<span class="gi">+        non_emittable = []</span>
<span class="gi">+        for message in messages:</span>
<span class="gi">+            if message.may_be_emitted(self.py_version):</span>
<span class="gi">+                emittable.append(message)</span>
<span class="gi">+            else:</span>
<span class="gi">+                non_emittable.append(message)</span>
<span class="gi">+        return emittable, non_emittable</span>
<span class="gh">diff --git a/pylint/message/message_id_store.py b/pylint/message/message_id_store.py</span>
<span class="gh">index 64562013d..b07a9c3f7 100644</span>
<span class="gd">--- a/pylint/message/message_id_store.py</span>
<span class="gi">+++ b/pylint/message/message_id_store.py</span>
<span class="gu">@@ -1,7 +1,23 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import NoReturn
<span class="gd">-from pylint.exceptions import DeletedMessageError, InvalidMessageError, MessageBecameExtensionError, UnknownMessageError</span>
<span class="gd">-from pylint.message._deleted_message_ids import is_deleted_msgid, is_deleted_symbol, is_moved_msgid, is_moved_symbol</span>
<span class="gi">+</span>
<span class="gi">+from pylint.exceptions import (</span>
<span class="gi">+    DeletedMessageError,</span>
<span class="gi">+    InvalidMessageError,</span>
<span class="gi">+    MessageBecameExtensionError,</span>
<span class="gi">+    UnknownMessageError,</span>
<span class="gi">+)</span>
<span class="gi">+from pylint.message._deleted_message_ids import (</span>
<span class="gi">+    is_deleted_msgid,</span>
<span class="gi">+    is_deleted_symbol,</span>
<span class="gi">+    is_moved_msgid,</span>
<span class="gi">+    is_moved_symbol,</span>
<span class="gi">+)</span>


<span class="w"> </span>class MessageIdStore:
<span class="gu">@@ -9,54 +25,138 @@ class MessageIdStore:</span>
<span class="w"> </span>    between msgid and symbol.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.__msgid_to_symbol: dict[str, str] = {}
<span class="w"> </span>        self.__symbol_to_msgid: dict[str, str] = {}
<span class="w"> </span>        self.__old_names: dict[str, list[str]] = {}
<span class="w"> </span>        self.__active_msgids: dict[str, list[str]] = {}

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self.__msgid_to_symbol)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        result = &#39;MessageIdStore: [\n&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        result = &quot;MessageIdStore: [\n&quot;</span>
<span class="w"> </span>        for msgid, symbol in self.__msgid_to_symbol.items():
<span class="gd">-            result += f&#39;  - {msgid} ({symbol})\n&#39;</span>
<span class="gd">-        result += &#39;]&#39;</span>
<span class="gi">+            result += f&quot;  - {msgid} ({symbol})\n&quot;</span>
<span class="gi">+        result += &quot;]&quot;</span>
<span class="w"> </span>        return result

<span class="gd">-    def add_msgid_and_symbol(self, msgid: str, symbol: str) -&gt;None:</span>
<span class="gi">+    def get_symbol(self, msgid: str) -&gt; str:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.__msgid_to_symbol[msgid.upper()]</span>
<span class="gi">+        except KeyError as e:</span>
<span class="gi">+            msg = f&quot;&#39;{msgid}&#39; is not stored in the message store.&quot;</span>
<span class="gi">+            raise UnknownMessageError(msg) from e</span>
<span class="gi">+</span>
<span class="gi">+    def get_msgid(self, symbol: str) -&gt; str:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.__symbol_to_msgid[symbol]</span>
<span class="gi">+        except KeyError as e:</span>
<span class="gi">+            msg = f&quot;&#39;{symbol}&#39; is not stored in the message store.&quot;</span>
<span class="gi">+            raise UnknownMessageError(msg) from e</span>
<span class="gi">+</span>
<span class="gi">+    def register_message_definition(</span>
<span class="gi">+        self, msgid: str, symbol: str, old_names: list[tuple[str, str]]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.check_msgid_and_symbol(msgid, symbol)</span>
<span class="gi">+        self.add_msgid_and_symbol(msgid, symbol)</span>
<span class="gi">+        for old_msgid, old_symbol in old_names:</span>
<span class="gi">+            self.check_msgid_and_symbol(old_msgid, old_symbol)</span>
<span class="gi">+            self.add_legacy_msgid_and_symbol(old_msgid, old_symbol, msgid)</span>
<span class="gi">+</span>
<span class="gi">+    def add_msgid_and_symbol(self, msgid: str, symbol: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add valid message id.

<span class="w"> </span>        There is a little duplication with add_legacy_msgid_and_symbol to avoid a function call,
<span class="w"> </span>        this is called a lot at initialization.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__msgid_to_symbol[msgid] = symbol</span>
<span class="gi">+        self.__symbol_to_msgid[symbol] = msgid</span>

<span class="gd">-    def add_legacy_msgid_and_symbol(self, msgid: str, symbol: str,</span>
<span class="gd">-        new_msgid: str) -&gt;None:</span>
<span class="gi">+    def add_legacy_msgid_and_symbol(</span>
<span class="gi">+        self, msgid: str, symbol: str, new_msgid: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add valid legacy message id.

<span class="w"> </span>        There is a little duplication with add_msgid_and_symbol to avoid a function call,
<span class="w"> </span>        this is called a lot at initialization.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__msgid_to_symbol[msgid] = symbol</span>
<span class="gi">+        self.__symbol_to_msgid[symbol] = msgid</span>
<span class="gi">+        existing_old_names = self.__old_names.get(msgid, [])</span>
<span class="gi">+        existing_old_names.append(new_msgid)</span>
<span class="gi">+        self.__old_names[msgid] = existing_old_names</span>
<span class="gi">+</span>
<span class="gi">+    def check_msgid_and_symbol(self, msgid: str, symbol: str) -&gt; None:</span>
<span class="gi">+        existing_msgid: str | None = self.__symbol_to_msgid.get(symbol)</span>
<span class="gi">+        existing_symbol: str | None = self.__msgid_to_symbol.get(msgid)</span>
<span class="gi">+        if existing_symbol is None and existing_msgid is None:</span>
<span class="gi">+            return  # both symbol and msgid are usable</span>
<span class="gi">+        if existing_msgid is not None:</span>
<span class="gi">+            if existing_msgid != msgid:</span>
<span class="gi">+                self._raise_duplicate_msgid(symbol, msgid, existing_msgid)</span>
<span class="gi">+        if existing_symbol and existing_symbol != symbol:</span>
<span class="gi">+            # See https://github.com/python/mypy/issues/10559</span>
<span class="gi">+            self._raise_duplicate_symbol(msgid, symbol, existing_symbol)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _raise_duplicate_symbol(msgid: str, symbol: str, other_symbol: str</span>
<span class="gd">-        ) -&gt;NoReturn:</span>
<span class="gi">+    def _raise_duplicate_symbol(msgid: str, symbol: str, other_symbol: str) -&gt; NoReturn:</span>
<span class="w"> </span>        &quot;&quot;&quot;Raise an error when a symbol is duplicated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        symbols = [symbol, other_symbol]</span>
<span class="gi">+        symbols.sort()</span>
<span class="gi">+        error_message = f&quot;Message id &#39;{msgid}&#39; cannot have both &quot;</span>
<span class="gi">+        error_message += f&quot;&#39;{symbols[0]}&#39; and &#39;{symbols[1]}&#39; as symbolic name.&quot;</span>
<span class="gi">+        raise InvalidMessageError(error_message)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _raise_duplicate_msgid(symbol: str, msgid: str, other_msgid: str</span>
<span class="gd">-        ) -&gt;NoReturn:</span>
<span class="gi">+    def _raise_duplicate_msgid(symbol: str, msgid: str, other_msgid: str) -&gt; NoReturn:</span>
<span class="w"> </span>        &quot;&quot;&quot;Raise an error when a msgid is duplicated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        msgids = [msgid, other_msgid]</span>
<span class="gi">+        msgids.sort()</span>
<span class="gi">+        error_message = (</span>
<span class="gi">+            f&quot;Message symbol &#39;{symbol}&#39; cannot be used for &quot;</span>
<span class="gi">+            f&quot;&#39;{msgids[0]}&#39; and &#39;{msgids[1]}&#39; at the same time.&quot;</span>
<span class="gi">+            f&quot; If you&#39;re creating an &#39;old_names&#39; use &#39;old-{symbol}&#39; as the old symbol.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        raise InvalidMessageError(error_message)</span>

<span class="gd">-    def get_active_msgids(self, msgid_or_symbol: str) -&gt;list[str]:</span>
<span class="gi">+    def get_active_msgids(self, msgid_or_symbol: str) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return msgids but the input can be a symbol.

<span class="w"> </span>        self.__active_msgids is used to implement a primitive cache for this function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.__active_msgids[msgid_or_symbol]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # If we don&#39;t have a cached value yet we compute it</span>
<span class="gi">+        msgid: str | None</span>
<span class="gi">+        deletion_reason = None</span>
<span class="gi">+        moved_reason = None</span>
<span class="gi">+        if msgid_or_symbol[1:].isdigit():</span>
<span class="gi">+            # Only msgid can have a digit as second letter</span>
<span class="gi">+            msgid = msgid_or_symbol.upper()</span>
<span class="gi">+            symbol = self.__msgid_to_symbol.get(msgid)</span>
<span class="gi">+            if not symbol:</span>
<span class="gi">+                deletion_reason = is_deleted_msgid(msgid)</span>
<span class="gi">+                if deletion_reason is None:</span>
<span class="gi">+                    moved_reason = is_moved_msgid(msgid)</span>
<span class="gi">+        else:</span>
<span class="gi">+            symbol = msgid_or_symbol</span>
<span class="gi">+            msgid = self.__symbol_to_msgid.get(msgid_or_symbol)</span>
<span class="gi">+            if not msgid:</span>
<span class="gi">+                deletion_reason = is_deleted_symbol(symbol)</span>
<span class="gi">+                if deletion_reason is None:</span>
<span class="gi">+                    moved_reason = is_moved_symbol(symbol)</span>
<span class="gi">+        if not msgid or not symbol:</span>
<span class="gi">+            if deletion_reason is not None:</span>
<span class="gi">+                raise DeletedMessageError(msgid_or_symbol, deletion_reason)</span>
<span class="gi">+            if moved_reason is not None:</span>
<span class="gi">+                raise MessageBecameExtensionError(msgid_or_symbol, moved_reason)</span>
<span class="gi">+            error_msg = f&quot;No such message id or symbol &#39;{msgid_or_symbol}&#39;.&quot;</span>
<span class="gi">+            raise UnknownMessageError(error_msg)</span>
<span class="gi">+        ids = self.__old_names.get(msgid, [msgid])</span>
<span class="gi">+        # Add to cache</span>
<span class="gi">+        self.__active_msgids[msgid_or_symbol] = ids</span>
<span class="gi">+        return ids</span>
<span class="gh">diff --git a/pylint/pyreverse/diadefslib.py b/pylint/pyreverse/diadefslib.py</span>
<span class="gh">index 4865d5ddc..88aea482e 100644</span>
<span class="gd">--- a/pylint/pyreverse/diadefslib.py</span>
<span class="gi">+++ b/pylint/pyreverse/diadefslib.py</span>
<span class="gu">@@ -1,65 +1,127 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Handle diagram generation options for class diagram or default diagrams.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>from collections.abc import Generator
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="w"> </span>from astroid.modutils import is_stdlib_module
<span class="gi">+</span>
<span class="w"> </span>from pylint.pyreverse.diagrams import ClassDiagram, PackageDiagram
<span class="w"> </span>from pylint.pyreverse.inspector import Linker, Project
<span class="w"> </span>from pylint.pyreverse.utils import LocalsVisitor

<span class="gi">+# diagram generators ##########################################################</span>
<span class="gi">+</span>

<span class="w"> </span>class DiaDefGenerator:
<span class="w"> </span>    &quot;&quot;&quot;Handle diagram generation options.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, linker: Linker, handler: DiadefsHandler) -&gt;None:</span>
<span class="gi">+    def __init__(self, linker: Linker, handler: DiadefsHandler) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Common Diagram Handler initialization.&quot;&quot;&quot;
<span class="w"> </span>        self.config = handler.config
<span class="w"> </span>        self.module_names: bool = False
<span class="w"> </span>        self._set_default_options()
<span class="w"> </span>        self.linker = linker
<span class="gd">-        self.classdiagram: ClassDiagram</span>
<span class="gi">+        self.classdiagram: ClassDiagram  # defined by subclasses</span>

<span class="gd">-    def get_title(self, node: nodes.ClassDef) -&gt;str:</span>
<span class="gi">+    def get_title(self, node: nodes.ClassDef) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get title for objects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        title = node.name</span>
<span class="gi">+        if self.module_names:</span>
<span class="gi">+            title = f&quot;{node.root().name}.{title}&quot;</span>
<span class="gi">+        return title  # type: ignore[no-any-return]</span>

<span class="gd">-    def _set_option(self, option: (bool | None)) -&gt;bool:</span>
<span class="gi">+    def _set_option(self, option: bool | None) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Activate some options if not explicitly deactivated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # if we have a class diagram, we want more information by default;</span>
<span class="gi">+        # so if the option is None, we return True</span>
<span class="gi">+        if option is None:</span>
<span class="gi">+            return bool(self.config.classes)</span>
<span class="gi">+        return option</span>

<span class="gd">-    def _set_default_options(self) -&gt;None:</span>
<span class="gi">+    def _set_default_options(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set different default options with _default dictionary.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_levels(self) -&gt;tuple[int, int]:</span>
<span class="gi">+        self.module_names = self._set_option(self.config.module_names)</span>
<span class="gi">+        all_ancestors = self._set_option(self.config.all_ancestors)</span>
<span class="gi">+        all_associated = self._set_option(self.config.all_associated)</span>
<span class="gi">+        anc_level, association_level = (0, 0)</span>
<span class="gi">+        if all_ancestors:</span>
<span class="gi">+            anc_level = -1</span>
<span class="gi">+        if all_associated:</span>
<span class="gi">+            association_level = -1</span>
<span class="gi">+        if self.config.show_ancestors is not None:</span>
<span class="gi">+            anc_level = self.config.show_ancestors</span>
<span class="gi">+        if self.config.show_associated is not None:</span>
<span class="gi">+            association_level = self.config.show_associated</span>
<span class="gi">+        self.anc_level, self.association_level = anc_level, association_level</span>
<span class="gi">+</span>
<span class="gi">+    def _get_levels(self) -&gt; tuple[int, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Help function for search levels.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.anc_level, self.association_level</span>

<span class="gd">-    def show_node(self, node: nodes.ClassDef) -&gt;bool:</span>
<span class="gi">+    def show_node(self, node: nodes.ClassDef) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Determine if node should be shown based on config.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node.root().name == &quot;builtins&quot;:</span>
<span class="gi">+            return self.config.show_builtin  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+        if is_stdlib_module(node.root().name):</span>
<span class="gi">+            return self.config.show_stdlib  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>

<span class="gd">-    def add_class(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    def add_class(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit one class and add it to diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.linker.visit(node)</span>
<span class="gi">+        self.classdiagram.add_object(self.get_title(node), node)</span>

<span class="gd">-    def get_ancestors(self, node: nodes.ClassDef, level: int) -&gt;Generator[</span>
<span class="gd">-        nodes.ClassDef, None, None]:</span>
<span class="gi">+    def get_ancestors(</span>
<span class="gi">+        self, node: nodes.ClassDef, level: int</span>
<span class="gi">+    ) -&gt; Generator[nodes.ClassDef, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return ancestor nodes of a class node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_associated(self, klass_node: nodes.ClassDef, level: int</span>
<span class="gd">-        ) -&gt;Generator[nodes.ClassDef, None, None]:</span>
<span class="gi">+        if level == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        for ancestor in node.ancestors(recurs=False):</span>
<span class="gi">+            if not self.show_node(ancestor):</span>
<span class="gi">+                continue</span>
<span class="gi">+            yield ancestor</span>
<span class="gi">+</span>
<span class="gi">+    def get_associated(</span>
<span class="gi">+        self, klass_node: nodes.ClassDef, level: int</span>
<span class="gi">+    ) -&gt; Generator[nodes.ClassDef, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return associated nodes of a class node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def extract_classes(self, klass_node: nodes.ClassDef, anc_level: int,</span>
<span class="gd">-        association_level: int) -&gt;None:</span>
<span class="gi">+        if level == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        for association_nodes in list(klass_node.instance_attrs_type.values()) + list(</span>
<span class="gi">+            klass_node.locals_type.values()</span>
<span class="gi">+        ):</span>
<span class="gi">+            for node in association_nodes:</span>
<span class="gi">+                if isinstance(node, astroid.Instance):</span>
<span class="gi">+                    node = node._proxied</span>
<span class="gi">+                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                yield node</span>
<span class="gi">+</span>
<span class="gi">+    def extract_classes(</span>
<span class="gi">+        self, klass_node: nodes.ClassDef, anc_level: int, association_level: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Extract recursively classes related to klass_node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.classdiagram.has_node(klass_node) or not self.show_node(klass_node):</span>
<span class="gi">+            return</span>
<span class="gi">+        self.add_class(klass_node)</span>
<span class="gi">+</span>
<span class="gi">+        for ancestor in self.get_ancestors(klass_node, anc_level):</span>
<span class="gi">+            self.extract_classes(ancestor, anc_level - 1, association_level)</span>
<span class="gi">+</span>
<span class="gi">+        for node in self.get_associated(klass_node, association_level):</span>
<span class="gi">+            self.extract_classes(node, anc_level, association_level - 1)</span>


<span class="w"> </span>class DefaultDiadefGenerator(LocalsVisitor, DiaDefGenerator):
<span class="gu">@@ -69,41 +131,54 @@ class DefaultDiadefGenerator(LocalsVisitor, DiaDefGenerator):</span>
<span class="w"> </span>    * a class diagram including project&#39;s classes
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, linker: Linker, handler: DiadefsHandler) -&gt;None:</span>
<span class="gi">+    def __init__(self, linker: Linker, handler: DiadefsHandler) -&gt; None:</span>
<span class="w"> </span>        DiaDefGenerator.__init__(self, linker, handler)
<span class="w"> </span>        LocalsVisitor.__init__(self)

<span class="gd">-    def visit_project(self, node: Project) -&gt;None:</span>
<span class="gi">+    def visit_project(self, node: Project) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit a pyreverse.utils.Project node.

<span class="w"> </span>        create a diagram definition for packages
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def leave_project(self, _: Project) -&gt;Any:</span>
<span class="gi">+        mode = self.config.mode</span>
<span class="gi">+        if len(node.modules) &gt; 1:</span>
<span class="gi">+            self.pkgdiagram: PackageDiagram | None = PackageDiagram(</span>
<span class="gi">+                f&quot;packages {node.name}&quot;, mode</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.pkgdiagram = None</span>
<span class="gi">+        self.classdiagram = ClassDiagram(f&quot;classes {node.name}&quot;, mode)</span>
<span class="gi">+</span>
<span class="gi">+    def leave_project(self, _: Project) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Leave the pyreverse.utils.Project node.

<span class="w"> </span>        return the generated diagram definition
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.pkgdiagram:</span>
<span class="gi">+            return self.pkgdiagram, self.classdiagram</span>
<span class="gi">+        return (self.classdiagram,)</span>

<span class="gd">-    def visit_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Module node.

<span class="w"> </span>        add this class to the package diagram definition
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.pkgdiagram:</span>
<span class="gi">+            self.linker.visit(node)</span>
<span class="gi">+            self.pkgdiagram.add_object(node.name, node)</span>

<span class="gd">-    def visit_classdef(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Class node.

<span class="w"> </span>        add this class to the class diagram definition
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        anc_level, association_level = self._get_levels()</span>
<span class="gi">+        self.extract_classes(node, anc_level, association_level)</span>

<span class="gd">-    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:</span>
<span class="gi">+    def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit astroid.ImportFrom  and catch modules for package diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.pkgdiagram:</span>
<span class="gi">+            self.pkgdiagram.add_from_depend(node, node.modname)</span>


<span class="w"> </span>class ClassDiadefGenerator(DiaDefGenerator):
<span class="gu">@@ -111,20 +186,32 @@ class ClassDiadefGenerator(DiaDefGenerator):</span>
<span class="w"> </span>    given class.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def class_diagram(self, project: Project, klass: nodes.ClassDef</span>
<span class="gd">-        ) -&gt;ClassDiagram:</span>
<span class="gi">+    def class_diagram(self, project: Project, klass: nodes.ClassDef) -&gt; ClassDiagram:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a class diagram definition for the class and related classes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.classdiagram = ClassDiagram(klass, self.config.mode)</span>
<span class="gi">+        if len(project.modules) &gt; 1:</span>
<span class="gi">+            module, klass = klass.rsplit(&quot;.&quot;, 1)</span>
<span class="gi">+            module = project.get_module(module)</span>
<span class="gi">+        else:</span>
<span class="gi">+            module = project.modules[0]</span>
<span class="gi">+            klass = klass.split(&quot;.&quot;)[-1]</span>
<span class="gi">+        klass = next(module.ilookup(klass))</span>
<span class="gi">+</span>
<span class="gi">+        anc_level, association_level = self._get_levels()</span>
<span class="gi">+        self.extract_classes(klass, anc_level, association_level)</span>
<span class="gi">+        return self.classdiagram</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# diagram handler #############################################################</span>


<span class="w"> </span>class DiadefsHandler:
<span class="w"> </span>    &quot;&quot;&quot;Get diagram definitions from user (i.e. xml files) or generate them.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, config: argparse.Namespace) -&gt;None:</span>
<span class="gi">+    def __init__(self, config: argparse.Namespace) -&gt; None:</span>
<span class="w"> </span>        self.config = config

<span class="gd">-    def get_diadefs(self, project: Project, linker: Linker) -&gt;list[ClassDiagram</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def get_diadefs(self, project: Project, linker: Linker) -&gt; list[ClassDiagram]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the diagram&#39;s configuration data.

<span class="w"> </span>        :param project:The pyreverse project
<span class="gu">@@ -135,4 +222,13 @@ class DiadefsHandler:</span>
<span class="w"> </span>        :returns: The list of diagram definitions
<span class="w"> </span>        :rtype: list(:class:`pylint.pyreverse.diagrams.ClassDiagram`)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        #  read and interpret diagram definitions (Diadefs)</span>
<span class="gi">+        diagrams = []</span>
<span class="gi">+        generator = ClassDiadefGenerator(linker, self)</span>
<span class="gi">+        for klass in self.config.classes:</span>
<span class="gi">+            diagrams.append(generator.class_diagram(project, klass))</span>
<span class="gi">+        if not diagrams:</span>
<span class="gi">+            diagrams = DefaultDiadefGenerator(linker, self).visit(project)</span>
<span class="gi">+        for diagram in diagrams:</span>
<span class="gi">+            diagram.extract_relationships()</span>
<span class="gi">+        return diagrams</span>
<span class="gh">diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py</span>
<span class="gh">index e1f5e7682..278102cab 100644</span>
<span class="gd">--- a/pylint/pyreverse/diagrams.py</span>
<span class="gi">+++ b/pylint/pyreverse/diagrams.py</span>
<span class="gu">@@ -1,9 +1,17 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Diagram objects.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Iterable
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes, util
<span class="gi">+</span>
<span class="w"> </span>from pylint.checkers.utils import decorated_with_property, in_type_checking_block
<span class="w"> </span>from pylint.pyreverse.utils import FilterMixIn

<span class="gu">@@ -11,15 +19,20 @@ from pylint.pyreverse.utils import FilterMixIn</span>
<span class="w"> </span>class Figure:
<span class="w"> </span>    &quot;&quot;&quot;Base class for counter handling.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self.fig_id: str = &#39;&#39;</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self.fig_id: str = &quot;&quot;</span>


<span class="w"> </span>class Relationship(Figure):
<span class="w"> </span>    &quot;&quot;&quot;A relationship from an object in the diagram to another.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, from_object: DiagramEntity, to_object: DiagramEntity,</span>
<span class="gd">-        relation_type: str, name: (str | None)=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        from_object: DiagramEntity,</span>
<span class="gi">+        to_object: DiagramEntity,</span>
<span class="gi">+        relation_type: str,</span>
<span class="gi">+        name: str | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.from_object = from_object
<span class="w"> </span>        self.to_object = to_object
<span class="gu">@@ -29,27 +42,36 @@ class Relationship(Figure):</span>

<span class="w"> </span>class DiagramEntity(Figure):
<span class="w"> </span>    &quot;&quot;&quot;A diagram object, i.e. a label associated to an astroid node.&quot;&quot;&quot;
<span class="gd">-    default_shape = &#39;&#39;</span>

<span class="gd">-    def __init__(self, title: str=&#39;No name&#39;, node: (nodes.NodeNG | None)=None</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    default_shape = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, title: str = &quot;No name&quot;, node: nodes.NodeNG | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.title = title
<span class="gd">-        self.node: nodes.NodeNG = node or nodes.NodeNG(lineno=None,</span>
<span class="gd">-            col_offset=None, end_lineno=None, end_col_offset=None, parent=None)</span>
<span class="gi">+        self.node: nodes.NodeNG = node or nodes.NodeNG(</span>
<span class="gi">+            lineno=None,</span>
<span class="gi">+            col_offset=None,</span>
<span class="gi">+            end_lineno=None,</span>
<span class="gi">+            end_col_offset=None,</span>
<span class="gi">+            parent=None,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.shape = self.default_shape


<span class="w"> </span>class PackageEntity(DiagramEntity):
<span class="w"> </span>    &quot;&quot;&quot;A diagram object representing a package.&quot;&quot;&quot;
<span class="gd">-    default_shape = &#39;package&#39;</span>
<span class="gi">+</span>
<span class="gi">+    default_shape = &quot;package&quot;</span>


<span class="w"> </span>class ClassEntity(DiagramEntity):
<span class="w"> </span>    &quot;&quot;&quot;A diagram object representing a class.&quot;&quot;&quot;
<span class="gd">-    default_shape = &#39;class&#39;</span>

<span class="gd">-    def __init__(self, title: str, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+    default_shape = &quot;class&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, title: str, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        super().__init__(title=title, node=node)
<span class="w"> </span>        self.attrs: list[str] = []
<span class="w"> </span>        self.methods: list[nodes.FunctionDef] = []
<span class="gu">@@ -57,89 +79,253 @@ class ClassEntity(DiagramEntity):</span>

<span class="w"> </span>class ClassDiagram(Figure, FilterMixIn):
<span class="w"> </span>    &quot;&quot;&quot;Main class diagram handling.&quot;&quot;&quot;
<span class="gd">-    TYPE = &#39;class&#39;</span>

<span class="gd">-    def __init__(self, title: str, mode: str) -&gt;None:</span>
<span class="gi">+    TYPE = &quot;class&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, title: str, mode: str) -&gt; None:</span>
<span class="w"> </span>        FilterMixIn.__init__(self, mode)
<span class="w"> </span>        Figure.__init__(self)
<span class="w"> </span>        self.title = title
<span class="gi">+        # TODO: Specify &#39;Any&#39; after refactor of `DiagramEntity`</span>
<span class="w"> </span>        self.objects: list[Any] = []
<span class="w"> </span>        self.relationships: dict[str, list[Relationship]] = {}
<span class="w"> </span>        self._nodes: dict[nodes.NodeNG, DiagramEntity] = {}

<span class="gd">-    def add_relationship(self, from_object: DiagramEntity, to_object:</span>
<span class="gd">-        DiagramEntity, relation_type: str, name: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def get_relationships(self, role: str) -&gt; Iterable[Relationship]:</span>
<span class="gi">+        # sorted to get predictable (hence testable) results</span>
<span class="gi">+        return sorted(</span>
<span class="gi">+            self.relationships.get(role, ()),</span>
<span class="gi">+            key=lambda x: (x.from_object.fig_id, x.to_object.fig_id),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def add_relationship(</span>
<span class="gi">+        self,</span>
<span class="gi">+        from_object: DiagramEntity,</span>
<span class="gi">+        to_object: DiagramEntity,</span>
<span class="gi">+        relation_type: str,</span>
<span class="gi">+        name: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a relationship.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rel = Relationship(from_object, to_object, relation_type, name)</span>
<span class="gi">+        self.relationships.setdefault(relation_type, []).append(rel)</span>

<span class="gd">-    def get_relationship(self, from_object: DiagramEntity, relation_type: str</span>
<span class="gd">-        ) -&gt;Relationship:</span>
<span class="gi">+    def get_relationship(</span>
<span class="gi">+        self, from_object: DiagramEntity, relation_type: str</span>
<span class="gi">+    ) -&gt; Relationship:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a relationship or None.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rel in self.relationships.get(relation_type, ()):</span>
<span class="gi">+            if rel.from_object is from_object:</span>
<span class="gi">+                return rel</span>
<span class="gi">+        raise KeyError(relation_type)</span>

<span class="gd">-    def get_attrs(self, node: nodes.ClassDef) -&gt;list[str]:</span>
<span class="gi">+    def get_attrs(self, node: nodes.ClassDef) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return visible attributes, possibly with class name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_methods(self, node: nodes.ClassDef) -&gt;list[nodes.FunctionDef]:</span>
<span class="gi">+        attrs = []</span>
<span class="gi">+        properties = {</span>
<span class="gi">+            local_name: local_node</span>
<span class="gi">+            for local_name, local_node in node.items()</span>
<span class="gi">+            if isinstance(local_node, nodes.FunctionDef)</span>
<span class="gi">+            and decorated_with_property(local_node)</span>
<span class="gi">+        }</span>
<span class="gi">+        for attr_name, attr_type in list(node.locals_type.items()) + list(</span>
<span class="gi">+            node.instance_attrs_type.items()</span>
<span class="gi">+        ):</span>
<span class="gi">+            if attr_name not in properties:</span>
<span class="gi">+                properties[attr_name] = attr_type</span>
<span class="gi">+</span>
<span class="gi">+        for node_name, associated_nodes in properties.items():</span>
<span class="gi">+            if not self.show_attr(node_name):</span>
<span class="gi">+                continue</span>
<span class="gi">+            names = self.class_names(associated_nodes)</span>
<span class="gi">+            if names:</span>
<span class="gi">+                node_name = f&quot;{node_name} : {&#39;, &#39;.join(names)}&quot;</span>
<span class="gi">+            attrs.append(node_name)</span>
<span class="gi">+        return sorted(attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def get_methods(self, node: nodes.ClassDef) -&gt; list[nodes.FunctionDef]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return visible methods.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_object(self, title: str, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+        methods = [</span>
<span class="gi">+            m</span>
<span class="gi">+            for m in node.values()</span>
<span class="gi">+            if isinstance(m, nodes.FunctionDef)</span>
<span class="gi">+            and not isinstance(m, astroid.objects.Property)</span>
<span class="gi">+            and not decorated_with_property(m)</span>
<span class="gi">+            and self.show_attr(m.name)</span>
<span class="gi">+        ]</span>
<span class="gi">+        return sorted(methods, key=lambda n: n.name)</span>
<span class="gi">+</span>
<span class="gi">+    def add_object(self, title: str, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a diagram object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert node not in self._nodes</span>
<span class="gi">+        ent = ClassEntity(title, node)</span>
<span class="gi">+        self._nodes[node] = ent</span>
<span class="gi">+        self.objects.append(ent)</span>

<span class="gd">-    def class_names(self, nodes_lst: Iterable[nodes.NodeNG]) -&gt;list[str]:</span>
<span class="gi">+    def class_names(self, nodes_lst: Iterable[nodes.NodeNG]) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return class names if needed in diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def has_node(self, node: nodes.NodeNG) -&gt;bool:</span>
<span class="gi">+        names = []</span>
<span class="gi">+        for node in nodes_lst:</span>
<span class="gi">+            if isinstance(node, astroid.Instance):</span>
<span class="gi">+                node = node._proxied</span>
<span class="gi">+            if (</span>
<span class="gi">+                isinstance(</span>
<span class="gi">+                    node, (nodes.ClassDef, nodes.Name, nodes.Subscript, nodes.BinOp)</span>
<span class="gi">+                )</span>
<span class="gi">+                and hasattr(node, &quot;name&quot;)</span>
<span class="gi">+                and not self.has_node(node)</span>
<span class="gi">+            ):</span>
<span class="gi">+                if node.name not in names:</span>
<span class="gi">+                    node_name = node.name</span>
<span class="gi">+                    names.append(node_name)</span>
<span class="gi">+        # sorted to get predictable (hence testable) results</span>
<span class="gi">+        return sorted(</span>
<span class="gi">+            name</span>
<span class="gi">+            for name in names</span>
<span class="gi">+            if all(name not in other or name == other for other in names)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def has_node(self, node: nodes.NodeNG) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return true if the given node is included in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return node in self._nodes</span>

<span class="gd">-    def object_from_node(self, node: nodes.NodeNG) -&gt;DiagramEntity:</span>
<span class="gi">+    def object_from_node(self, node: nodes.NodeNG) -&gt; DiagramEntity:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the diagram object mapped to node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._nodes[node]</span>

<span class="gd">-    def classes(self) -&gt;list[ClassEntity]:</span>
<span class="gi">+    def classes(self) -&gt; list[ClassEntity]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return all class nodes in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [o for o in self.objects if isinstance(o, ClassEntity)]</span>

<span class="gd">-    def classe(self, name: str) -&gt;ClassEntity:</span>
<span class="gi">+    def classe(self, name: str) -&gt; ClassEntity:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a class by its name, raise KeyError if not found.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for klass in self.classes():</span>
<span class="gi">+            if klass.node.name == name:</span>
<span class="gi">+                return klass</span>
<span class="gi">+        raise KeyError(name)</span>

<span class="gd">-    def extract_relationships(self) -&gt;None:</span>
<span class="gi">+    def extract_relationships(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Extract relationships between nodes in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for obj in self.classes():</span>
<span class="gi">+            node = obj.node</span>
<span class="gi">+            obj.attrs = self.get_attrs(node)</span>
<span class="gi">+            obj.methods = self.get_methods(node)</span>
<span class="gi">+            obj.shape = &quot;class&quot;</span>
<span class="gi">+            # inheritance link</span>
<span class="gi">+            for par_node in node.ancestors(recurs=False):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    par_obj = self.object_from_node(par_node)</span>
<span class="gi">+                    self.add_relationship(obj, par_obj, &quot;specialization&quot;)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            # associations &amp; aggregations links</span>
<span class="gi">+            for name, values in list(node.aggregations_type.items()):</span>
<span class="gi">+                for value in values:</span>
<span class="gi">+                    self.assign_association_relationship(</span>
<span class="gi">+                        value, obj, name, &quot;aggregation&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+            associations = node.associations_type.copy()</span>
<span class="gi">+</span>
<span class="gi">+            for name, values in node.locals_type.items():</span>
<span class="gi">+                if name not in associations:</span>
<span class="gi">+                    associations[name] = values</span>
<span class="gi">+</span>
<span class="gi">+            for name, values in associations.items():</span>
<span class="gi">+                for value in values:</span>
<span class="gi">+                    self.assign_association_relationship(</span>
<span class="gi">+                        value, obj, name, &quot;association&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    def assign_association_relationship(</span>
<span class="gi">+        self, value: astroid.NodeNG, obj: ClassEntity, name: str, type_relationship: str</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if isinstance(value, util.UninferableBase):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(value, astroid.Instance):</span>
<span class="gi">+            value = value._proxied</span>
<span class="gi">+        try:</span>
<span class="gi">+            associated_obj = self.object_from_node(value)</span>
<span class="gi">+            self.add_relationship(associated_obj, obj, type_relationship, name)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return</span>


<span class="w"> </span>class PackageDiagram(ClassDiagram):
<span class="w"> </span>    &quot;&quot;&quot;Package diagram handling.&quot;&quot;&quot;
<span class="gd">-    TYPE = &#39;package&#39;</span>

<span class="gd">-    def modules(self) -&gt;list[PackageEntity]:</span>
<span class="gi">+    TYPE = &quot;package&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def modules(self) -&gt; list[PackageEntity]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return all module nodes in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [o for o in self.objects if isinstance(o, PackageEntity)]</span>

<span class="gd">-    def module(self, name: str) -&gt;PackageEntity:</span>
<span class="gi">+    def module(self, name: str) -&gt; PackageEntity:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a module by its name, raise KeyError if not found.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for mod in self.modules():</span>
<span class="gi">+            if mod.node.name == name:</span>
<span class="gi">+                return mod</span>
<span class="gi">+        raise KeyError(name)</span>

<span class="gd">-    def add_object(self, title: str, node: nodes.Module) -&gt;None:</span>
<span class="gi">+    def add_object(self, title: str, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a diagram object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert node not in self._nodes</span>
<span class="gi">+        ent = PackageEntity(title, node)</span>
<span class="gi">+        self._nodes[node] = ent</span>
<span class="gi">+        self.objects.append(ent)</span>

<span class="gd">-    def get_module(self, name: str, node: nodes.Module) -&gt;PackageEntity:</span>
<span class="gi">+    def get_module(self, name: str, node: nodes.Module) -&gt; PackageEntity:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a module by its name, looking also for relative imports;
<span class="w"> </span>        raise KeyError if not found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_from_depend(self, node: nodes.ImportFrom, from_module: str) -&gt;None:</span>
<span class="gi">+        for mod in self.modules():</span>
<span class="gi">+            mod_name = mod.node.name</span>
<span class="gi">+            if mod_name == name:</span>
<span class="gi">+                return mod</span>
<span class="gi">+            # search for fullname of relative import modules</span>
<span class="gi">+            package = node.root().name</span>
<span class="gi">+            if mod_name == f&quot;{package}.{name}&quot;:</span>
<span class="gi">+                return mod</span>
<span class="gi">+            if mod_name == f&quot;{package.rsplit(&#39;.&#39;, 1)[0]}.{name}&quot;:</span>
<span class="gi">+                return mod</span>
<span class="gi">+        raise KeyError(name)</span>
<span class="gi">+</span>
<span class="gi">+    def add_from_depend(self, node: nodes.ImportFrom, from_module: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add dependencies created by from-imports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        mod_name = node.root().name</span>
<span class="gi">+        package = self.module(mod_name).node</span>
<span class="gi">+</span>
<span class="gi">+        if from_module in package.depends:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not in_type_checking_block(node):</span>
<span class="gi">+            package.depends.append(from_module)</span>
<span class="gi">+        elif from_module not in package.type_depends:</span>
<span class="gi">+            package.type_depends.append(from_module)</span>

<span class="gd">-    def extract_relationships(self) -&gt;None:</span>
<span class="gi">+    def extract_relationships(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Extract relationships between nodes in the diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        super().extract_relationships()</span>
<span class="gi">+        for class_obj in self.classes():</span>
<span class="gi">+            # ownership</span>
<span class="gi">+            try:</span>
<span class="gi">+                mod = self.object_from_node(class_obj.node.root())</span>
<span class="gi">+                self.add_relationship(class_obj, mod, &quot;ownership&quot;)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                continue</span>
<span class="gi">+        for package_obj in self.modules():</span>
<span class="gi">+            package_obj.shape = &quot;package&quot;</span>
<span class="gi">+            # dependencies</span>
<span class="gi">+            for dep_name in package_obj.node.depends:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    dep = self.get_module(dep_name, package_obj.node)</span>
<span class="gi">+                except KeyError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.add_relationship(package_obj, dep, &quot;depends&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            for dep_name in package_obj.node.type_depends:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    dep = self.get_module(dep_name, package_obj.node)</span>
<span class="gi">+                except KeyError:  # pragma: no cover</span>
<span class="gi">+                    continue</span>
<span class="gi">+                self.add_relationship(package_obj, dep, &quot;type_depends&quot;)</span>
<span class="gh">diff --git a/pylint/pyreverse/dot_printer.py b/pylint/pyreverse/dot_printer.py</span>
<span class="gh">index 30da959a1..4baed6c3c 100644</span>
<span class="gd">--- a/pylint/pyreverse/dot_printer.py</span>
<span class="gi">+++ b/pylint/pyreverse/dot_printer.py</span>
<span class="gu">@@ -1,11 +1,19 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class to generate files in dot format and image formats supported by Graphviz.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess
<span class="w"> </span>import tempfile
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.pyreverse.printer import EdgeType, Layout, NodeProperties, NodeType, Printer
<span class="w"> </span>from pylint.pyreverse.utils import get_annotation_label

<span class="gu">@@ -14,44 +22,163 @@ class HTMLLabels(Enum):</span>
<span class="w"> </span>    LINEBREAK_LEFT = &#39;&lt;br ALIGN=&quot;LEFT&quot;/&gt;&#39;


<span class="gd">-ALLOWED_CHARSETS: frozenset[str] = frozenset((&#39;utf-8&#39;, &#39;iso-8859-1&#39;, &#39;latin1&#39;))</span>
<span class="gd">-SHAPES: dict[NodeType, str] = {NodeType.PACKAGE: &#39;box&#39;, NodeType.CLASS:</span>
<span class="gd">-    &#39;record&#39;}</span>
<span class="gd">-ARROWS: dict[EdgeType, dict[str, str]] = {EdgeType.INHERITS: {&#39;arrowtail&#39;:</span>
<span class="gd">-    &#39;none&#39;, &#39;arrowhead&#39;: &#39;empty&#39;}, EdgeType.ASSOCIATION: {&#39;fontcolor&#39;:</span>
<span class="gd">-    &#39;green&#39;, &#39;arrowtail&#39;: &#39;none&#39;, &#39;arrowhead&#39;: &#39;diamond&#39;, &#39;style&#39;: &#39;solid&#39;},</span>
<span class="gd">-    EdgeType.AGGREGATION: {&#39;fontcolor&#39;: &#39;green&#39;, &#39;arrowtail&#39;: &#39;none&#39;,</span>
<span class="gd">-    &#39;arrowhead&#39;: &#39;odiamond&#39;, &#39;style&#39;: &#39;solid&#39;}, EdgeType.USES: {&#39;arrowtail&#39;:</span>
<span class="gd">-    &#39;none&#39;, &#39;arrowhead&#39;: &#39;open&#39;}, EdgeType.TYPE_DEPENDENCY: {&#39;arrowtail&#39;:</span>
<span class="gd">-    &#39;none&#39;, &#39;arrowhead&#39;: &#39;open&#39;, &#39;style&#39;: &#39;dashed&#39;}}</span>
<span class="gi">+ALLOWED_CHARSETS: frozenset[str] = frozenset((&quot;utf-8&quot;, &quot;iso-8859-1&quot;, &quot;latin1&quot;))</span>
<span class="gi">+SHAPES: dict[NodeType, str] = {</span>
<span class="gi">+    NodeType.PACKAGE: &quot;box&quot;,</span>
<span class="gi">+    NodeType.CLASS: &quot;record&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+# pylint: disable-next=consider-using-namedtuple-or-dataclass</span>
<span class="gi">+ARROWS: dict[EdgeType, dict[str, str]] = {</span>
<span class="gi">+    EdgeType.INHERITS: {&quot;arrowtail&quot;: &quot;none&quot;, &quot;arrowhead&quot;: &quot;empty&quot;},</span>
<span class="gi">+    EdgeType.ASSOCIATION: {</span>
<span class="gi">+        &quot;fontcolor&quot;: &quot;green&quot;,</span>
<span class="gi">+        &quot;arrowtail&quot;: &quot;none&quot;,</span>
<span class="gi">+        &quot;arrowhead&quot;: &quot;diamond&quot;,</span>
<span class="gi">+        &quot;style&quot;: &quot;solid&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+    EdgeType.AGGREGATION: {</span>
<span class="gi">+        &quot;fontcolor&quot;: &quot;green&quot;,</span>
<span class="gi">+        &quot;arrowtail&quot;: &quot;none&quot;,</span>
<span class="gi">+        &quot;arrowhead&quot;: &quot;odiamond&quot;,</span>
<span class="gi">+        &quot;style&quot;: &quot;solid&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+    EdgeType.USES: {&quot;arrowtail&quot;: &quot;none&quot;, &quot;arrowhead&quot;: &quot;open&quot;},</span>
<span class="gi">+    EdgeType.TYPE_DEPENDENCY: {</span>
<span class="gi">+        &quot;arrowtail&quot;: &quot;none&quot;,</span>
<span class="gi">+        &quot;arrowhead&quot;: &quot;open&quot;,</span>
<span class="gi">+        &quot;style&quot;: &quot;dashed&quot;,</span>
<span class="gi">+    },</span>
<span class="gi">+}</span>


<span class="w"> </span>class DotPrinter(Printer):
<span class="gd">-    DEFAULT_COLOR = &#39;black&#39;</span>
<span class="gi">+    DEFAULT_COLOR = &quot;black&quot;</span>

<span class="gd">-    def __init__(self, title: str, layout: (Layout | None)=None,</span>
<span class="gd">-        use_automatic_namespace: (bool | None)=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        title: str,</span>
<span class="gi">+        layout: Layout | None = None,</span>
<span class="gi">+        use_automatic_namespace: bool | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        layout = layout or Layout.BOTTOM_TO_TOP
<span class="gd">-        self.charset = &#39;utf-8&#39;</span>
<span class="gi">+        self.charset = &quot;utf-8&quot;</span>
<span class="w"> </span>        super().__init__(title, layout, use_automatic_namespace)

<span class="gd">-    def _open_graph(self) -&gt;None:</span>
<span class="gi">+    def _open_graph(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit the header lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.emit(f&#39;digraph &quot;{self.title}&quot; {{&#39;)</span>
<span class="gi">+        if self.layout:</span>
<span class="gi">+            self.emit(f&quot;rankdir={self.layout.value}&quot;)</span>
<span class="gi">+        if self.charset:</span>
<span class="gi">+            assert (</span>
<span class="gi">+                self.charset.lower() in ALLOWED_CHARSETS</span>
<span class="gi">+            ), f&quot;unsupported charset {self.charset}&quot;</span>
<span class="gi">+            self.emit(f&#39;charset=&quot;{self.charset}&quot;&#39;)</span>

<span class="gd">-    def emit_node(self, name: str, type_: NodeType, properties: (</span>
<span class="gd">-        NodeProperties | None)=None) -&gt;None:</span>
<span class="gi">+    def emit_node(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        type_: NodeType,</span>
<span class="gi">+        properties: NodeProperties | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new node.

<span class="w"> </span>        Nodes can be classes, packages, participants etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if properties is None:</span>
<span class="gi">+            properties = NodeProperties(label=name)</span>
<span class="gi">+        shape = SHAPES[type_]</span>
<span class="gi">+        color = properties.color if properties.color is not None else self.DEFAULT_COLOR</span>
<span class="gi">+        style = &quot;filled&quot; if color != self.DEFAULT_COLOR else &quot;solid&quot;</span>
<span class="gi">+        label = self._build_label_for_node(properties)</span>
<span class="gi">+        label_part = f&quot;, label=&lt;{label}&gt;&quot; if label else &quot;&quot;</span>
<span class="gi">+        fontcolor_part = (</span>
<span class="gi">+            f&#39;, fontcolor=&quot;{properties.fontcolor}&quot;&#39; if properties.fontcolor else &quot;&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        self.emit(</span>
<span class="gi">+            f&#39;&quot;{name}&quot; [color=&quot;{color}&quot;{fontcolor_part}{label_part}, shape=&quot;{shape}&quot;, style=&quot;{style}&quot;];&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _build_label_for_node(self, properties: NodeProperties) -&gt; str:</span>
<span class="gi">+        if not properties.label:</span>
<span class="gi">+            return &quot;&quot;</span>

<span class="gd">-    def emit_edge(self, from_node: str, to_node: str, type_: EdgeType,</span>
<span class="gd">-        label: (str | None)=None) -&gt;None:</span>
<span class="gi">+        label: str = properties.label</span>
<span class="gi">+        if properties.attrs is None and properties.methods is None:</span>
<span class="gi">+            # return a &quot;compact&quot; form which only displays the class name in a box</span>
<span class="gi">+            return label</span>
<span class="gi">+</span>
<span class="gi">+        # Add class attributes</span>
<span class="gi">+        attrs: list[str] = properties.attrs or []</span>
<span class="gi">+        attrs_string = rf&quot;{HTMLLabels.LINEBREAK_LEFT.value}&quot;.join(</span>
<span class="gi">+            attr.replace(&quot;|&quot;, r&quot;\|&quot;) for attr in attrs</span>
<span class="gi">+        )</span>
<span class="gi">+        label = rf&quot;{{{label}|{attrs_string}{HTMLLabels.LINEBREAK_LEFT.value}|&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Add class methods</span>
<span class="gi">+        methods: list[nodes.FunctionDef] = properties.methods or []</span>
<span class="gi">+        for func in methods:</span>
<span class="gi">+            args = &quot;, &quot;.join(self._get_method_arguments(func)).replace(&quot;|&quot;, r&quot;\|&quot;)</span>
<span class="gi">+            method_name = (</span>
<span class="gi">+                f&quot;&lt;I&gt;{func.name}&lt;/I&gt;&quot; if func.is_abstract() else f&quot;{func.name}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            label += rf&quot;{method_name}({args})&quot;</span>
<span class="gi">+            if func.returns:</span>
<span class="gi">+                annotation_label = get_annotation_label(func.returns)</span>
<span class="gi">+                label += &quot;: &quot; + self._escape_annotation_label(annotation_label)</span>
<span class="gi">+            label += rf&quot;{HTMLLabels.LINEBREAK_LEFT.value}&quot;</span>
<span class="gi">+        label += &quot;}&quot;</span>
<span class="gi">+        return label</span>
<span class="gi">+</span>
<span class="gi">+    def _escape_annotation_label(self, annotation_label: str) -&gt; str:</span>
<span class="gi">+        # Escape vertical bar characters to make them appear as a literal characters</span>
<span class="gi">+        # otherwise it gets treated as field separator of record-based nodes</span>
<span class="gi">+        annotation_label = annotation_label.replace(&quot;|&quot;, r&quot;\|&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return annotation_label</span>
<span class="gi">+</span>
<span class="gi">+    def emit_edge(</span>
<span class="gi">+        self,</span>
<span class="gi">+        from_node: str,</span>
<span class="gi">+        to_node: str,</span>
<span class="gi">+        type_: EdgeType,</span>
<span class="gi">+        label: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an edge from one node to another to display relationships.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        arrowstyle = ARROWS[type_]</span>
<span class="gi">+        attrs = [f&#39;{prop}=&quot;{value}&quot;&#39; for prop, value in arrowstyle.items()]</span>
<span class="gi">+        if label:</span>
<span class="gi">+            attrs.append(f&#39;label=&quot;{label}&quot;&#39;)</span>
<span class="gi">+        self.emit(f&#39;&quot;{from_node}&quot; -&gt; &quot;{to_node}&quot; [{&quot;, &quot;.join(sorted(attrs))}];&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def generate(self, outputfile: str) -&gt; None:</span>
<span class="gi">+        self._close_graph()</span>
<span class="gi">+        graphviz_extensions = (&quot;dot&quot;, &quot;gv&quot;)</span>
<span class="gi">+        name = self.title</span>
<span class="gi">+        if outputfile is None:</span>
<span class="gi">+            target = &quot;png&quot;</span>
<span class="gi">+            pdot, dot_sourcepath = tempfile.mkstemp(&quot;.gv&quot;, name)</span>
<span class="gi">+            ppng, outputfile = tempfile.mkstemp(&quot;.png&quot;, name)</span>
<span class="gi">+            os.close(pdot)</span>
<span class="gi">+            os.close(ppng)</span>
<span class="gi">+        else:</span>
<span class="gi">+            target = Path(outputfile).suffix.lstrip(&quot;.&quot;)</span>
<span class="gi">+            if not target:</span>
<span class="gi">+                target = &quot;png&quot;</span>
<span class="gi">+                outputfile = outputfile + &quot;.&quot; + target</span>
<span class="gi">+            if target not in graphviz_extensions:</span>
<span class="gi">+                pdot, dot_sourcepath = tempfile.mkstemp(&quot;.gv&quot;, name)</span>
<span class="gi">+                os.close(pdot)</span>
<span class="gi">+            else:</span>
<span class="gi">+                dot_sourcepath = outputfile</span>
<span class="gi">+        with open(dot_sourcepath, &quot;w&quot;, encoding=&quot;utf8&quot;) as outfile:</span>
<span class="gi">+            outfile.writelines(self.lines)</span>
<span class="gi">+        if target not in graphviz_extensions:</span>
<span class="gi">+            subprocess.run(</span>
<span class="gi">+                [&quot;dot&quot;, &quot;-T&quot;, target, dot_sourcepath, &quot;-o&quot;, outputfile], check=True</span>
<span class="gi">+            )</span>
<span class="gi">+            os.unlink(dot_sourcepath)</span>

<span class="gd">-    def _close_graph(self) -&gt;None:</span>
<span class="gi">+    def _close_graph(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit the lines needed to properly close the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.emit(&quot;}\n&quot;)</span>
<span class="gh">diff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py</span>
<span class="gh">index 6af79d52a..23ccfa6f3 100644</span>
<span class="gd">--- a/pylint/pyreverse/inspector.py</span>
<span class="gi">+++ b/pylint/pyreverse/inspector.py</span>
<span class="gu">@@ -1,43 +1,70 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Visitor doing some post-processing on the astroid tree.

<span class="w"> </span>Try to resolve definitions (namespace) dictionary, relationship...
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import os
<span class="w"> </span>import traceback
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="w"> </span>from typing import Callable, Optional
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint import constants
<span class="w"> </span>from pylint.pyreverse import utils
<span class="gd">-_WrapperFuncT = Callable[[Callable[[str], nodes.Module], str, bool],</span>
<span class="gd">-    Optional[nodes.Module]]</span>
<span class="gi">+</span>
<span class="gi">+_WrapperFuncT = Callable[</span>
<span class="gi">+    [Callable[[str], nodes.Module], str, bool], Optional[nodes.Module]</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _astroid_wrapper(</span>
<span class="gi">+    func: Callable[[str], nodes.Module],</span>
<span class="gi">+    modname: str,</span>
<span class="gi">+    verbose: bool = False,</span>
<span class="gi">+) -&gt; nodes.Module | None:</span>
<span class="gi">+    if verbose:</span>
<span class="gi">+        print(f&quot;parsing {modname}...&quot;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return func(modname)</span>
<span class="gi">+    except astroid.exceptions.AstroidBuildingError as exc:</span>
<span class="gi">+        print(exc)</span>
<span class="gi">+    except Exception:  # pylint: disable=broad-except</span>
<span class="gi">+        traceback.print_exc()</span>
<span class="gi">+    return None</span>


<span class="w"> </span>class IdGeneratorMixIn:
<span class="w"> </span>    &quot;&quot;&quot;Mixin adding the ability to generate integer uid.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, start_value: int=0) -&gt;None:</span>
<span class="gi">+    def __init__(self, start_value: int = 0) -&gt; None:</span>
<span class="w"> </span>        self.id_count = start_value

<span class="gd">-    def init_counter(self, start_value: int=0) -&gt;None:</span>
<span class="gi">+    def init_counter(self, start_value: int = 0) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Init the id counter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.id_count = start_value</span>

<span class="gd">-    def generate_id(self) -&gt;int:</span>
<span class="gi">+    def generate_id(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a new identifier.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.id_count += 1</span>
<span class="gi">+        return self.id_count</span>


<span class="w"> </span>class Project:
<span class="w"> </span>    &quot;&quot;&quot;A project handle a set of modules / packages.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str=&#39;&#39;):</span>
<span class="gi">+    def __init__(self, name: str = &quot;&quot;):</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.uid: int | None = None
<span class="gd">-        self.path: str = &#39;&#39;</span>
<span class="gi">+        self.path: str = &quot;&quot;</span>
<span class="w"> </span>        self.modules: list[nodes.Module] = []
<span class="w"> </span>        self.locals: dict[str, nodes.Module] = {}
<span class="w"> </span>        self.__getitem__ = self.locals.__getitem__
<span class="gu">@@ -46,10 +73,18 @@ class Project:</span>
<span class="w"> </span>        self.keys = self.locals.keys
<span class="w"> </span>        self.items = self.locals.items

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;&lt;Project {self.name!r} at {id(self)} ({len(self.modules)} modules)&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def add_module(self, node: nodes.Module) -&gt; None:</span>
<span class="gi">+        self.locals[node.name] = node</span>
<span class="gi">+        self.modules.append(node)</span>
<span class="gi">+</span>
<span class="gi">+    def get_module(self, name: str) -&gt; nodes.Module:</span>
<span class="gi">+        return self.locals[name]</span>
<span class="gi">+</span>
<span class="gi">+    def get_children(self) -&gt; list[nodes.Module]:</span>
<span class="gi">+        return self.modules</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;Project {self.name!r} at {id(self)} ({len(self.modules)} modules)&gt;&quot;</span>


<span class="w"> </span>class Linker(IdGeneratorMixIn, utils.LocalsVisitor):
<span class="gu">@@ -78,88 +113,190 @@ class Linker(IdGeneratorMixIn, utils.LocalsVisitor):</span>
<span class="w"> </span>      as instance_attrs_type but for aggregations relationships
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, project: Project, tag: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(self, project: Project, tag: bool = False) -&gt; None:</span>
<span class="w"> </span>        IdGeneratorMixIn.__init__(self)
<span class="w"> </span>        utils.LocalsVisitor.__init__(self)
<span class="gi">+        # tag nodes or not</span>
<span class="w"> </span>        self.tag = tag
<span class="gi">+        # visited project</span>
<span class="w"> </span>        self.project = project
<span class="w"> </span>        self.associations_handler = AggregationsHandler()
<span class="w"> </span>        self.associations_handler.set_next(OtherAssociationsHandler())

<span class="gd">-    def visit_project(self, node: Project) -&gt;None:</span>
<span class="gi">+    def visit_project(self, node: Project) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit a pyreverse.utils.Project node.

<span class="w"> </span>        * optionally tag the node with a unique id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.tag:</span>
<span class="gi">+            node.uid = self.generate_id()</span>
<span class="gi">+        for module in node.modules:</span>
<span class="gi">+            self.visit(module)</span>

<span class="gd">-    def visit_module(self, node: nodes.Module) -&gt;None:</span>
<span class="gi">+    def visit_module(self, node: nodes.Module) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Module node.

<span class="w"> </span>        * set the locals_type mapping
<span class="w"> </span>        * set the depends mapping
<span class="w"> </span>        * optionally tag the node with a unique id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_classdef(self, node: nodes.ClassDef) -&gt;None:</span>
<span class="gi">+        if hasattr(node, &quot;locals_type&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        node.locals_type = collections.defaultdict(list)</span>
<span class="gi">+        node.depends = []</span>
<span class="gi">+        node.type_depends = []</span>
<span class="gi">+        if self.tag:</span>
<span class="gi">+            node.uid = self.generate_id()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_classdef(self, node: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Class node.

<span class="w"> </span>        * set the locals_type and instance_attrs_type mappings
<span class="w"> </span>        * optionally tag the node with a unique id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_functiondef(self, node: nodes.FunctionDef) -&gt;None:</span>
<span class="gi">+        if hasattr(node, &quot;locals_type&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        node.locals_type = collections.defaultdict(list)</span>
<span class="gi">+        if self.tag:</span>
<span class="gi">+            node.uid = self.generate_id()</span>
<span class="gi">+        # resolve ancestors</span>
<span class="gi">+        for baseobj in node.ancestors(recurs=False):</span>
<span class="gi">+            specializations = getattr(baseobj, &quot;specializations&quot;, [])</span>
<span class="gi">+            specializations.append(node)</span>
<span class="gi">+            baseobj.specializations = specializations</span>
<span class="gi">+        # resolve instance attributes</span>
<span class="gi">+        node.instance_attrs_type = collections.defaultdict(list)</span>
<span class="gi">+        node.aggregations_type = collections.defaultdict(list)</span>
<span class="gi">+        node.associations_type = collections.defaultdict(list)</span>
<span class="gi">+        for assignattrs in tuple(node.instance_attrs.values()):</span>
<span class="gi">+            for assignattr in assignattrs:</span>
<span class="gi">+                if not isinstance(assignattr, nodes.Unknown):</span>
<span class="gi">+                    self.associations_handler.handle(assignattr, node)</span>
<span class="gi">+                    self.handle_assignattr_type(assignattr, node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Function node.

<span class="w"> </span>        * set the locals_type mapping
<span class="w"> </span>        * optionally tag the node with a unique id
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if hasattr(node, &quot;locals_type&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        node.locals_type = collections.defaultdict(list)</span>
<span class="gi">+        if self.tag:</span>
<span class="gi">+            node.uid = self.generate_id()</span>

<span class="gd">-    def visit_assignname(self, node: nodes.AssignName) -&gt;None:</span>
<span class="gi">+    def visit_assignname(self, node: nodes.AssignName) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.AssignName node.

<span class="w"> </span>        handle locals_type
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # avoid double parsing done by different Linkers.visit</span>
<span class="gi">+        # running over the same project:</span>
<span class="gi">+        if hasattr(node, &quot;_handled&quot;):</span>
<span class="gi">+            return</span>
<span class="gi">+        node._handled = True</span>
<span class="gi">+        if node.name in node.frame():</span>
<span class="gi">+            frame = node.frame()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # the name has been defined as &#39;global&#39; in the frame and belongs</span>
<span class="gi">+            # there.</span>
<span class="gi">+            frame = node.root()</span>
<span class="gi">+        if not hasattr(frame, &quot;locals_type&quot;):</span>
<span class="gi">+            # If the frame doesn&#39;t have a locals_type yet,</span>
<span class="gi">+            # it means it wasn&#39;t yet visited. Visit it now</span>
<span class="gi">+            # to add what&#39;s missing from it.</span>
<span class="gi">+            if isinstance(frame, nodes.ClassDef):</span>
<span class="gi">+                self.visit_classdef(frame)</span>
<span class="gi">+            elif isinstance(frame, nodes.FunctionDef):</span>
<span class="gi">+                self.visit_functiondef(frame)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.visit_module(frame)</span>
<span class="gi">+</span>
<span class="gi">+        current = frame.locals_type[node.name]</span>
<span class="gi">+        frame.locals_type[node.name] = list(set(current) | utils.infer_node(node))</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def handle_assignattr_type(node: nodes.AssignAttr, parent: nodes.ClassDef</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def handle_assignattr_type(node: nodes.AssignAttr, parent: nodes.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle an astroid.assignattr node.

<span class="w"> </span>        handle instance_attrs_type
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        current = set(parent.instance_attrs_type[node.attrname])</span>
<span class="gi">+        parent.instance_attrs_type[node.attrname] = list(</span>
<span class="gi">+            current | utils.infer_node(node)</span>
<span class="gi">+        )</span>

<span class="gd">-    def visit_import(self, node: nodes.Import) -&gt;None:</span>
<span class="gi">+    def visit_import(self, node: nodes.Import) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.Import node.

<span class="w"> </span>        resolve module dependencies
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        context_file = node.root().file</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            relative = astroid.modutils.is_relative(name[0], context_file)</span>
<span class="gi">+            self._imported_module(node, name[0], relative)</span>

<span class="gd">-    def visit_importfrom(self, node: nodes.ImportFrom) -&gt;None:</span>
<span class="gi">+    def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit an astroid.ImportFrom node.

<span class="w"> </span>        resolve module dependencies
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def compute_module(self, context_name: str, mod_path: str) -&gt;bool:</span>
<span class="gi">+        basename = node.modname</span>
<span class="gi">+        context_file = node.root().file</span>
<span class="gi">+        if context_file is not None:</span>
<span class="gi">+            relative = astroid.modutils.is_relative(basename, context_file)</span>
<span class="gi">+        else:</span>
<span class="gi">+            relative = False</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            if name[0] == &quot;*&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # analyze dependencies</span>
<span class="gi">+            fullname = f&quot;{basename}.{name[0]}&quot;</span>
<span class="gi">+            if fullname.find(&quot;.&quot;) &gt; -1:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    fullname = astroid.modutils.get_module_part(fullname, context_file)</span>
<span class="gi">+                except ImportError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            if fullname != basename:</span>
<span class="gi">+                self._imported_module(node, fullname, relative)</span>
<span class="gi">+</span>
<span class="gi">+    def compute_module(self, context_name: str, mod_path: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Should the module be added to dependencies ?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        package_dir = os.path.dirname(self.project.path)</span>
<span class="gi">+        if context_name == mod_path:</span>
<span class="gi">+            return False</span>
<span class="gi">+        # astroid does return a boolean but is not typed correctly yet</span>

<span class="gd">-    def _imported_module(self, node: (nodes.Import | nodes.ImportFrom),</span>
<span class="gd">-        mod_path: str, relative: bool) -&gt;None:</span>
<span class="gi">+        return astroid.modutils.module_in_path(mod_path, (package_dir,))  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+    def _imported_module(</span>
<span class="gi">+        self, node: nodes.Import | nodes.ImportFrom, mod_path: str, relative: bool</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Notify an imported module, used to analyze dependencies.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        module = node.root()</span>
<span class="gi">+        context_name = module.name</span>
<span class="gi">+        if relative:</span>
<span class="gi">+            mod_path = f&quot;{&#39;.&#39;.join(context_name.split(&#39;.&#39;)[:-1])}.{mod_path}&quot;</span>
<span class="gi">+        if self.compute_module(context_name, mod_path):</span>
<span class="gi">+            # handle dependencies</span>
<span class="gi">+            if not hasattr(module, &quot;depends&quot;):</span>
<span class="gi">+                module.depends = []</span>
<span class="gi">+            mod_paths = module.depends</span>
<span class="gi">+            if mod_path not in mod_paths:</span>
<span class="gi">+                mod_paths.append(mod_path)</span>


<span class="w"> </span>class AssociationHandlerInterface(ABC):
<span class="gd">-    pass</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def set_next(</span>
<span class="gi">+        self, handler: AssociationHandlerInterface</span>
<span class="gi">+    ) -&gt; AssociationHandlerInterface:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        pass</span>


<span class="w"> </span>class AbstractAssociationHandler(AssociationHandlerInterface):
<span class="gu">@@ -173,19 +310,72 @@ class AbstractAssociationHandler(AssociationHandlerInterface):</span>
<span class="w"> </span>    The default chaining behavior is implemented inside the base handler
<span class="w"> </span>    class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _next_handler: AssociationHandlerInterface

<span class="gi">+    def set_next(</span>
<span class="gi">+        self, handler: AssociationHandlerInterface</span>
<span class="gi">+    ) -&gt; AssociationHandlerInterface:</span>
<span class="gi">+        self._next_handler = handler</span>
<span class="gi">+        return handler</span>

<span class="gd">-class AggregationsHandler(AbstractAssociationHandler):</span>
<span class="gd">-    pass</span>
<span class="gi">+    @abstractmethod</span>
<span class="gi">+    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        if self._next_handler:</span>
<span class="gi">+            self._next_handler.handle(node, parent)</span>


<span class="gd">-class OtherAssociationsHandler(AbstractAssociationHandler):</span>
<span class="gd">-    pass</span>
<span class="gi">+class AggregationsHandler(AbstractAssociationHandler):</span>
<span class="gi">+    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, (nodes.AnnAssign, nodes.Assign)) and isinstance(</span>
<span class="gi">+            node.parent.value, astroid.node_classes.Name</span>
<span class="gi">+        ):</span>
<span class="gi">+            current = set(parent.aggregations_type[node.attrname])</span>
<span class="gi">+            parent.aggregations_type[node.attrname] = list(</span>
<span class="gi">+                current | utils.infer_node(node)</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().handle(node, parent)</span>


<span class="gd">-def project_from_files(files: list[str], func_wrapper: _WrapperFuncT=</span>
<span class="gd">-    _astroid_wrapper, project_name: str=&#39;no name&#39;, black_list: tuple[str,</span>
<span class="gd">-    ...]=constants.DEFAULT_IGNORE_LIST, verbose: bool=False) -&gt;Project:</span>
<span class="gi">+class OtherAssociationsHandler(AbstractAssociationHandler):</span>
<span class="gi">+    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -&gt; None:</span>
<span class="gi">+        current = set(parent.associations_type[node.attrname])</span>
<span class="gi">+        parent.associations_type[node.attrname] = list(current | utils.infer_node(node))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def project_from_files(</span>
<span class="gi">+    files: list[str],</span>
<span class="gi">+    func_wrapper: _WrapperFuncT = _astroid_wrapper,</span>
<span class="gi">+    project_name: str = &quot;no name&quot;,</span>
<span class="gi">+    black_list: tuple[str, ...] = constants.DEFAULT_IGNORE_LIST,</span>
<span class="gi">+    verbose: bool = False,</span>
<span class="gi">+) -&gt; Project:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a Project from a list of files or modules.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # build the project representation</span>
<span class="gi">+    astroid_manager = astroid.MANAGER</span>
<span class="gi">+    project = Project(project_name)</span>
<span class="gi">+    for something in files:</span>
<span class="gi">+        if not os.path.exists(something):</span>
<span class="gi">+            fpath = astroid.modutils.file_from_modpath(something.split(&quot;.&quot;))</span>
<span class="gi">+        elif os.path.isdir(something):</span>
<span class="gi">+            fpath = os.path.join(something, &quot;__init__.py&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fpath = something</span>
<span class="gi">+        ast = func_wrapper(astroid_manager.ast_from_file, fpath, verbose)</span>
<span class="gi">+        if ast is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        project.path = project.path or ast.file</span>
<span class="gi">+        project.add_module(ast)</span>
<span class="gi">+        base_name = ast.name</span>
<span class="gi">+        # recurse in package except if __init__ was explicitly given</span>
<span class="gi">+        if ast.package and something.find(&quot;__init__&quot;) == -1:</span>
<span class="gi">+            # recurse on others packages / modules if this is a package</span>
<span class="gi">+            for fpath in astroid.modutils.get_module_files(</span>
<span class="gi">+                os.path.dirname(ast.file), black_list</span>
<span class="gi">+            ):</span>
<span class="gi">+                ast = func_wrapper(astroid_manager.ast_from_file, fpath, verbose)</span>
<span class="gi">+                if ast is None or ast.name == base_name:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                project.add_module(ast)</span>
<span class="gi">+    return project</span>
<span class="gh">diff --git a/pylint/pyreverse/main.py b/pylint/pyreverse/main.py</span>
<span class="gh">index e8743de5e..3ba0b6c77 100644</span>
<span class="gd">--- a/pylint/pyreverse/main.py</span>
<span class="gi">+++ b/pylint/pyreverse/main.py</span>
<span class="gu">@@ -1,8 +1,15 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Create UML diagrams for classes and modules in &lt;packages&gt;.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from typing import NoReturn
<span class="gi">+</span>
<span class="w"> </span>from pylint import constants
<span class="w"> </span>from pylint.config.arguments_manager import _ArgumentsManager
<span class="w"> </span>from pylint.config.arguments_provider import _ArgumentsProvider
<span class="gu">@@ -11,15 +18,45 @@ from pylint.lint.utils import augmented_sys_path</span>
<span class="w"> </span>from pylint.pyreverse import writer
<span class="w"> </span>from pylint.pyreverse.diadefslib import DiadefsHandler
<span class="w"> </span>from pylint.pyreverse.inspector import Linker, project_from_files
<span class="gd">-from pylint.pyreverse.utils import check_graphviz_availability, check_if_graphviz_supports_format, insert_default_options</span>
<span class="gi">+from pylint.pyreverse.utils import (</span>
<span class="gi">+    check_graphviz_availability,</span>
<span class="gi">+    check_if_graphviz_supports_format,</span>
<span class="gi">+    insert_default_options,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.typing import Options
<span class="gd">-DIRECTLY_SUPPORTED_FORMATS = &#39;dot&#39;, &#39;puml&#39;, &#39;plantuml&#39;, &#39;mmd&#39;, &#39;html&#39;</span>
<span class="gd">-DEFAULT_COLOR_PALETTE = (&#39;#77AADD&#39;, &#39;#99DDFF&#39;, &#39;#44BB99&#39;, &#39;#BBCC33&#39;,</span>
<span class="gd">-    &#39;#AAAA00&#39;, &#39;#EEDD88&#39;, &#39;#EE8866&#39;, &#39;#FFAABB&#39;, &#39;#DDDDDD&#39;)</span>
<span class="gd">-OPTIONS: Options = ((&#39;filter-mode&#39;, {&#39;short&#39;: &#39;f&#39;, &#39;default&#39;: &#39;PUB_ONLY&#39;,</span>
<span class="gd">-    &#39;dest&#39;: &#39;mode&#39;, &#39;type&#39;: &#39;string&#39;, &#39;action&#39;: &#39;store&#39;, &#39;metavar&#39;:</span>
<span class="gd">-    &#39;&lt;mode&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-    &quot;&quot;&quot;filter attributes and functions according to</span>
<span class="gi">+</span>
<span class="gi">+DIRECTLY_SUPPORTED_FORMATS = (</span>
<span class="gi">+    &quot;dot&quot;,</span>
<span class="gi">+    &quot;puml&quot;,</span>
<span class="gi">+    &quot;plantuml&quot;,</span>
<span class="gi">+    &quot;mmd&quot;,</span>
<span class="gi">+    &quot;html&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_COLOR_PALETTE = (</span>
<span class="gi">+    # colorblind scheme taken from https://personal.sron.nl/~pault/</span>
<span class="gi">+    &quot;#77AADD&quot;,  # light blue</span>
<span class="gi">+    &quot;#99DDFF&quot;,  # light cyan</span>
<span class="gi">+    &quot;#44BB99&quot;,  # mint</span>
<span class="gi">+    &quot;#BBCC33&quot;,  # pear</span>
<span class="gi">+    &quot;#AAAA00&quot;,  # olive</span>
<span class="gi">+    &quot;#EEDD88&quot;,  # light yellow</span>
<span class="gi">+    &quot;#EE8866&quot;,  # orange</span>
<span class="gi">+    &quot;#FFAABB&quot;,  # pink</span>
<span class="gi">+    &quot;#DDDDDD&quot;,  # pale grey</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+OPTIONS: Options = (</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;filter-mode&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;f&quot;,</span>
<span class="gi">+            &quot;default&quot;: &quot;PUB_ONLY&quot;,</span>
<span class="gi">+            &quot;dest&quot;: &quot;mode&quot;,</span>
<span class="gi">+            &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;mode&gt;&quot;,</span>
<span class="gi">+            &quot;help&quot;: &quot;&quot;&quot;filter attributes and functions according to</span>
<span class="w"> </span>    &lt;mode&gt;. Correct modes are :
<span class="w"> </span>                            &#39;PUB_ONLY&#39; filter all non public attributes
<span class="w"> </span>                                [DEFAULT], equivalent to PRIVATE+SPECIAL_A
<span class="gu">@@ -27,87 +64,259 @@ OPTIONS: Options = ((&#39;filter-mode&#39;, {&#39;short&#39;: &#39;f&#39;, &#39;default&#39;: &#39;PUB_ONLY&#39;,</span>
<span class="w"> </span>                            &#39;SPECIAL&#39; filter Python special functions
<span class="w"> </span>                                except constructor
<span class="w"> </span>                            &#39;OTHER&#39; filter protected and private
<span class="gd">-                                attributes&quot;&quot;&quot;</span>
<span class="gd">-    }), (&#39;class&#39;, {&#39;short&#39;: &#39;c&#39;, &#39;action&#39;: &#39;extend&#39;, &#39;metavar&#39;: &#39;&lt;class&gt;&#39;,</span>
<span class="gd">-    &#39;type&#39;: &#39;csv&#39;, &#39;dest&#39;: &#39;classes&#39;, &#39;default&#39;: None, &#39;help&#39;:</span>
<span class="gd">-    &#39;create a class diagram with all classes related to &lt;class&gt;; this uses by default the options -ASmy&#39;</span>
<span class="gd">-    }), (&#39;show-ancestors&#39;, {&#39;short&#39;: &#39;a&#39;, &#39;action&#39;: &#39;store&#39;, &#39;metavar&#39;:</span>
<span class="gd">-    &#39;&lt;ancestor&gt;&#39;, &#39;type&#39;: &#39;int&#39;, &#39;default&#39;: None, &#39;help&#39;:</span>
<span class="gd">-    &#39;show &lt;ancestor&gt; generations of ancestor classes not in &lt;projects&gt;&#39;}),</span>
<span class="gd">-    (&#39;all-ancestors&#39;, {&#39;short&#39;: &#39;A&#39;, &#39;default&#39;: None, &#39;action&#39;:</span>
<span class="gd">-    &#39;store_true&#39;, &#39;help&#39;:</span>
<span class="gd">-    &#39;show all ancestors off all classes in &lt;projects&gt;&#39;}), (</span>
<span class="gd">-    &#39;show-associated&#39;, {&#39;short&#39;: &#39;s&#39;, &#39;action&#39;: &#39;store&#39;, &#39;metavar&#39;:</span>
<span class="gd">-    &#39;&lt;association_level&gt;&#39;, &#39;type&#39;: &#39;int&#39;, &#39;default&#39;: None, &#39;help&#39;:</span>
<span class="gd">-    &#39;show &lt;association_level&gt; levels of associated classes not in &lt;projects&gt;&#39;</span>
<span class="gd">-    }), (&#39;all-associated&#39;, {&#39;short&#39;: &#39;S&#39;, &#39;default&#39;: None, &#39;action&#39;:</span>
<span class="gd">-    &#39;store_true&#39;, &#39;help&#39;:</span>
<span class="gd">-    &#39;show recursively all associated off all associated classes&#39;}), (</span>
<span class="gd">-    &#39;show-builtin&#39;, {&#39;short&#39;: &#39;b&#39;, &#39;action&#39;: &#39;store_true&#39;, &#39;default&#39;: False,</span>
<span class="gd">-    &#39;help&#39;: &#39;include builtin objects in representation of classes&#39;}), (</span>
<span class="gd">-    &#39;show-stdlib&#39;, {&#39;short&#39;: &#39;L&#39;, &#39;action&#39;: &#39;store_true&#39;, &#39;default&#39;: False,</span>
<span class="gd">-    &#39;help&#39;: &#39;include standard library objects in representation of classes&#39;</span>
<span class="gd">-    }), (&#39;module-names&#39;, {&#39;short&#39;: &#39;m&#39;, &#39;default&#39;: None, &#39;type&#39;: &#39;yn&#39;,</span>
<span class="gd">-    &#39;metavar&#39;: &#39;&lt;y or n&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-    &#39;include module name in representation of classes&#39;}), (</span>
<span class="gd">-    &#39;only-classnames&#39;, {&#39;short&#39;: &#39;k&#39;, &#39;action&#39;: &#39;store_true&#39;, &#39;default&#39;: </span>
<span class="gd">-    False, &#39;help&#39;:</span>
<span class="gd">-    &quot;don&#39;t show attributes and methods in the class boxes; this disables -f values&quot;</span>
<span class="gd">-    }), (&#39;no-standalone&#39;, {&#39;action&#39;: &#39;store_true&#39;, &#39;default&#39;: False, &#39;help&#39;:</span>
<span class="gd">-    &#39;only show nodes with connections&#39;}), (&#39;output&#39;, {&#39;short&#39;: &#39;o&#39;, &#39;dest&#39;:</span>
<span class="gd">-    &#39;output_format&#39;, &#39;action&#39;: &#39;store&#39;, &#39;default&#39;: &#39;dot&#39;, &#39;metavar&#39;:</span>
<span class="gd">-    &#39;&lt;format&gt;&#39;, &#39;type&#39;: &#39;string&#39;, &#39;help&#39;:</span>
<span class="gd">-    f&quot;create a *.&lt;format&gt; output file if format is available. Available formats are: {&#39;, &#39;.join(DIRECTLY_SUPPORTED_FORMATS)}. Any other format will be tried to create by means of the &#39;dot&#39; command line tool, which requires a graphviz installation.&quot;</span>
<span class="gd">-    }), (&#39;colorized&#39;, {&#39;dest&#39;: &#39;colorized&#39;, &#39;action&#39;: &#39;store_true&#39;,</span>
<span class="gd">-    &#39;default&#39;: False, &#39;help&#39;:</span>
<span class="gd">-    &#39;Use colored output. Classes/modules of the same package get the same color.&#39;</span>
<span class="gd">-    }), (&#39;max-color-depth&#39;, {&#39;dest&#39;: &#39;max_color_depth&#39;, &#39;action&#39;: &#39;store&#39;,</span>
<span class="gd">-    &#39;default&#39;: 2, &#39;metavar&#39;: &#39;&lt;depth&gt;&#39;, &#39;type&#39;: &#39;int&#39;, &#39;help&#39;:</span>
<span class="gd">-    &#39;Use separate colors up to package depth of &lt;depth&gt;&#39;}), (</span>
<span class="gd">-    &#39;color-palette&#39;, {&#39;dest&#39;: &#39;color_palette&#39;, &#39;action&#39;: &#39;store&#39;, &#39;default&#39;:</span>
<span class="gd">-    DEFAULT_COLOR_PALETTE, &#39;metavar&#39;: &#39;&lt;color1,color2,...&gt;&#39;, &#39;type&#39;: &#39;csv&#39;,</span>
<span class="gd">-    &#39;help&#39;: &#39;Comma separated list of colors to use&#39;}), (&#39;ignore&#39;, {&#39;type&#39;:</span>
<span class="gd">-    &#39;csv&#39;, &#39;metavar&#39;: &#39;&lt;file[,file...]&gt;&#39;, &#39;dest&#39;: &#39;ignore_list&#39;, &#39;default&#39;:</span>
<span class="gd">-    constants.DEFAULT_IGNORE_LIST, &#39;help&#39;:</span>
<span class="gd">-    &#39;Files or directories to be skipped. They should be base names, not paths.&#39;</span>
<span class="gd">-    }), (&#39;project&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;string&#39;, &#39;short&#39;: &#39;p&#39;,</span>
<span class="gd">-    &#39;metavar&#39;: &#39;&lt;project name&gt;&#39;, &#39;help&#39;: &#39;set the project name.&#39;}), (</span>
<span class="gd">-    &#39;output-directory&#39;, {&#39;default&#39;: &#39;&#39;, &#39;type&#39;: &#39;path&#39;, &#39;short&#39;: &#39;d&#39;,</span>
<span class="gd">-    &#39;action&#39;: &#39;store&#39;, &#39;metavar&#39;: &#39;&lt;output_directory&gt;&#39;, &#39;help&#39;:</span>
<span class="gd">-    &#39;set the output directory path.&#39;}), (&#39;source-roots&#39;, {&#39;type&#39;:</span>
<span class="gd">-    &#39;glob_paths_csv&#39;, &#39;metavar&#39;: &#39;&lt;path&gt;[,&lt;path&gt;...]&#39;, &#39;default&#39;: (),</span>
<span class="gd">-    &#39;help&#39;:</span>
<span class="gd">-    &#39;Add paths to the list of the source roots. Supports globbing patterns. The source root is an absolute path or a path relative to the current working directory used to determine a package namespace for modules located under the source root.&#39;</span>
<span class="gd">-    }), (&#39;verbose&#39;, {&#39;action&#39;: &#39;store_true&#39;, &#39;default&#39;: False, &#39;help&#39;:</span>
<span class="gd">-    &#39;Makes pyreverse more verbose/talkative. Mostly useful for debugging.&#39;}))</span>
<span class="gi">+                                attributes&quot;&quot;&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;class&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;c&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;extend&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;class&gt;&quot;,</span>
<span class="gi">+            &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+            &quot;dest&quot;: &quot;classes&quot;,</span>
<span class="gi">+            &quot;default&quot;: None,</span>
<span class="gi">+            &quot;help&quot;: &quot;create a class diagram with all classes related to &lt;class&gt;;\</span>
<span class="gi">+ this uses by default the options -ASmy&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;show-ancestors&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;a&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;ancestor&gt;&quot;,</span>
<span class="gi">+            &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+            &quot;default&quot;: None,</span>
<span class="gi">+            &quot;help&quot;: &quot;show &lt;ancestor&gt; generations of ancestor classes not in &lt;projects&gt;&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;all-ancestors&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;A&quot;,</span>
<span class="gi">+            &quot;default&quot;: None,</span>
<span class="gi">+            &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+            &quot;help&quot;: &quot;show all ancestors off all classes in &lt;projects&gt;&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;show-associated&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;s&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;association_level&gt;&quot;,</span>
<span class="gi">+            &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+            &quot;default&quot;: None,</span>
<span class="gi">+            &quot;help&quot;: &quot;show &lt;association_level&gt; levels of associated classes not in &lt;projects&gt;&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;all-associated&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;S&quot;,</span>
<span class="gi">+            &quot;default&quot;: None,</span>
<span class="gi">+            &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+            &quot;help&quot;: &quot;show recursively all associated off all associated classes&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;show-builtin&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;b&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+            &quot;default&quot;: False,</span>
<span class="gi">+            &quot;help&quot;: &quot;include builtin objects in representation of classes&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;show-stdlib&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;L&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+            &quot;default&quot;: False,</span>
<span class="gi">+            &quot;help&quot;: &quot;include standard library objects in representation of classes&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;module-names&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;m&quot;,</span>
<span class="gi">+            &quot;default&quot;: None,</span>
<span class="gi">+            &quot;type&quot;: &quot;yn&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;y or n&gt;&quot;,</span>
<span class="gi">+            &quot;help&quot;: &quot;include module name in representation of classes&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;only-classnames&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;k&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+            &quot;default&quot;: False,</span>
<span class="gi">+            &quot;help&quot;: &quot;don&#39;t show attributes and methods in the class boxes; this disables -f values&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;no-standalone&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+            &quot;default&quot;: False,</span>
<span class="gi">+            &quot;help&quot;: &quot;only show nodes with connections&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;output&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;short&quot;: &quot;o&quot;,</span>
<span class="gi">+            &quot;dest&quot;: &quot;output_format&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store&quot;,</span>
<span class="gi">+            &quot;default&quot;: &quot;dot&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;format&gt;&quot;,</span>
<span class="gi">+            &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+            &quot;help&quot;: (</span>
<span class="gi">+                &quot;create a *.&lt;format&gt; output file if format is available. Available &quot;</span>
<span class="gi">+                f&quot;formats are: {&#39;, &#39;.join(DIRECTLY_SUPPORTED_FORMATS)}. Any other &quot;</span>
<span class="gi">+                f&quot;format will be tried to create by means of the &#39;dot&#39; command line &quot;</span>
<span class="gi">+                f&quot;tool, which requires a graphviz installation.&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;colorized&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;dest&quot;: &quot;colorized&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+            &quot;default&quot;: False,</span>
<span class="gi">+            &quot;help&quot;: &quot;Use colored output. Classes/modules of the same package get the same color.&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;max-color-depth&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;dest&quot;: &quot;max_color_depth&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store&quot;,</span>
<span class="gi">+            &quot;default&quot;: 2,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;depth&gt;&quot;,</span>
<span class="gi">+            &quot;type&quot;: &quot;int&quot;,</span>
<span class="gi">+            &quot;help&quot;: &quot;Use separate colors up to package depth of &lt;depth&gt;&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;color-palette&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;dest&quot;: &quot;color_palette&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store&quot;,</span>
<span class="gi">+            &quot;default&quot;: DEFAULT_COLOR_PALETTE,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;color1,color2,...&gt;&quot;,</span>
<span class="gi">+            &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+            &quot;help&quot;: &quot;Comma separated list of colors to use&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;ignore&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;type&quot;: &quot;csv&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;file[,file...]&gt;&quot;,</span>
<span class="gi">+            &quot;dest&quot;: &quot;ignore_list&quot;,</span>
<span class="gi">+            &quot;default&quot;: constants.DEFAULT_IGNORE_LIST,</span>
<span class="gi">+            &quot;help&quot;: &quot;Files or directories to be skipped. They should be base names, not paths.&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;project&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+            &quot;type&quot;: &quot;string&quot;,</span>
<span class="gi">+            &quot;short&quot;: &quot;p&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;project name&gt;&quot;,</span>
<span class="gi">+            &quot;help&quot;: &quot;set the project name.&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;output-directory&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;default&quot;: &quot;&quot;,</span>
<span class="gi">+            &quot;type&quot;: &quot;path&quot;,</span>
<span class="gi">+            &quot;short&quot;: &quot;d&quot;,</span>
<span class="gi">+            &quot;action&quot;: &quot;store&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;output_directory&gt;&quot;,</span>
<span class="gi">+            &quot;help&quot;: &quot;set the output directory path.&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;source-roots&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;type&quot;: &quot;glob_paths_csv&quot;,</span>
<span class="gi">+            &quot;metavar&quot;: &quot;&lt;path&gt;[,&lt;path&gt;...]&quot;,</span>
<span class="gi">+            &quot;default&quot;: (),</span>
<span class="gi">+            &quot;help&quot;: &quot;Add paths to the list of the source roots. Supports globbing patterns. The &quot;</span>
<span class="gi">+            &quot;source root is an absolute path or a path relative to the current working directory &quot;</span>
<span class="gi">+            &quot;used to determine a package namespace for modules located under the source root.&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+    (</span>
<span class="gi">+        &quot;verbose&quot;,</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;action&quot;: &quot;store_true&quot;,</span>
<span class="gi">+            &quot;default&quot;: False,</span>
<span class="gi">+            &quot;help&quot;: &quot;Makes pyreverse more verbose/talkative. Mostly useful for debugging.&quot;,</span>
<span class="gi">+        },</span>
<span class="gi">+    ),</span>
<span class="gi">+)</span>


<span class="w"> </span>class Run(_ArgumentsManager, _ArgumentsProvider):
<span class="w"> </span>    &quot;&quot;&quot;Base class providing common behaviour for pyreverse commands.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    options = OPTIONS
<span class="gd">-    name = &#39;pyreverse&#39;</span>
<span class="gi">+    name = &quot;pyreverse&quot;</span>

<span class="gd">-    def __init__(self, args: Sequence[str]) -&gt;NoReturn:</span>
<span class="gd">-        if &#39;--version&#39; in args:</span>
<span class="gd">-            print(&#39;pyreverse is included in pylint:&#39;)</span>
<span class="gi">+    def __init__(self, args: Sequence[str]) -&gt; NoReturn:</span>
<span class="gi">+        # Immediately exit if user asks for version</span>
<span class="gi">+        if &quot;--version&quot; in args:</span>
<span class="gi">+            print(&quot;pyreverse is included in pylint:&quot;)</span>
<span class="w"> </span>            print(constants.full_version)
<span class="w"> </span>            sys.exit(0)
<span class="gd">-        _ArgumentsManager.__init__(self, prog=&#39;pyreverse&#39;, description=__doc__)</span>
<span class="gi">+</span>
<span class="gi">+        _ArgumentsManager.__init__(self, prog=&quot;pyreverse&quot;, description=__doc__)</span>
<span class="w"> </span>        _ArgumentsProvider.__init__(self, self)
<span class="gi">+</span>
<span class="gi">+        # Parse options</span>
<span class="w"> </span>        insert_default_options()
<span class="w"> </span>        args = self._parse_command_line_configuration(args)
<span class="gi">+</span>
<span class="w"> </span>        if self.config.output_format not in DIRECTLY_SUPPORTED_FORMATS:
<span class="w"> </span>            check_graphviz_availability()
<span class="w"> </span>            print(
<span class="gd">-                f&#39;Format {self.config.output_format} is not supported natively. Pyreverse will try to generate it using Graphviz...&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+                f&quot;Format {self.config.output_format} is not supported natively.&quot;</span>
<span class="gi">+                &quot; Pyreverse will try to generate it using Graphviz...&quot;</span>
<span class="gi">+            )</span>
<span class="w"> </span>            check_if_graphviz_supports_format(self.config.output_format)
<span class="gi">+</span>
<span class="w"> </span>        sys.exit(self.run(args))

<span class="gd">-    def run(self, args: list[str]) -&gt;int:</span>
<span class="gi">+    def run(self, args: list[str]) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checking arguments and run project.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            print(self.help())</span>
<span class="gi">+            return 1</span>
<span class="gi">+        extra_packages_paths = list(</span>
<span class="gi">+            {discover_package_path(arg, self.config.source_roots) for arg in args}</span>
<span class="gi">+        )</span>
<span class="gi">+        with augmented_sys_path(extra_packages_paths):</span>
<span class="gi">+            project = project_from_files(</span>
<span class="gi">+                args,</span>
<span class="gi">+                project_name=self.config.project,</span>
<span class="gi">+                black_list=self.config.ignore_list,</span>
<span class="gi">+                verbose=self.config.verbose,</span>
<span class="gi">+            )</span>
<span class="gi">+            linker = Linker(project, tag=True)</span>
<span class="gi">+            handler = DiadefsHandler(self.config)</span>
<span class="gi">+            diadefs = handler.get_diadefs(project, linker)</span>
<span class="gi">+        writer.DiagramWriter(self.config).write(diadefs)</span>
<span class="gi">+        return 0</span>


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    Run(sys.argv[1:])
<span class="gh">diff --git a/pylint/pyreverse/mermaidjs_printer.py b/pylint/pyreverse/mermaidjs_printer.py</span>
<span class="gh">index 5c9dac6c4..24fa92776 100644</span>
<span class="gd">--- a/pylint/pyreverse/mermaidjs_printer.py</span>
<span class="gi">+++ b/pylint/pyreverse/mermaidjs_printer.py</span>
<span class="gu">@@ -1,46 +1,112 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class to generate files in mermaidjs format.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from pylint.pyreverse.printer import EdgeType, NodeProperties, NodeType, Printer
<span class="w"> </span>from pylint.pyreverse.utils import get_annotation_label


<span class="w"> </span>class MermaidJSPrinter(Printer):
<span class="w"> </span>    &quot;&quot;&quot;Printer for MermaidJS diagrams.&quot;&quot;&quot;
<span class="gd">-    DEFAULT_COLOR = &#39;black&#39;</span>
<span class="gd">-    NODES: dict[NodeType, str] = {NodeType.CLASS: &#39;class&#39;, NodeType.PACKAGE:</span>
<span class="gd">-        &#39;class&#39;}</span>
<span class="gd">-    ARROWS: dict[EdgeType, str] = {EdgeType.INHERITS: &#39;--|&gt;&#39;, EdgeType.</span>
<span class="gd">-        ASSOCIATION: &#39;--*&#39;, EdgeType.AGGREGATION: &#39;--o&#39;, EdgeType.USES:</span>
<span class="gd">-        &#39;--&gt;&#39;, EdgeType.TYPE_DEPENDENCY: &#39;..&gt;&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def _open_graph(self) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    DEFAULT_COLOR = &quot;black&quot;</span>
<span class="gi">+</span>
<span class="gi">+    NODES: dict[NodeType, str] = {</span>
<span class="gi">+        NodeType.CLASS: &quot;class&quot;,</span>
<span class="gi">+        NodeType.PACKAGE: &quot;class&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    ARROWS: dict[EdgeType, str] = {</span>
<span class="gi">+        EdgeType.INHERITS: &quot;--|&gt;&quot;,</span>
<span class="gi">+        EdgeType.ASSOCIATION: &quot;--*&quot;,</span>
<span class="gi">+        EdgeType.AGGREGATION: &quot;--o&quot;,</span>
<span class="gi">+        EdgeType.USES: &quot;--&gt;&quot;,</span>
<span class="gi">+        EdgeType.TYPE_DEPENDENCY: &quot;..&gt;&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def _open_graph(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit the header lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.emit(&quot;classDiagram&quot;)</span>
<span class="gi">+        self._inc_indent()</span>

<span class="gd">-    def emit_node(self, name: str, type_: NodeType, properties: (</span>
<span class="gd">-        NodeProperties | None)=None) -&gt;None:</span>
<span class="gi">+    def emit_node(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        type_: NodeType,</span>
<span class="gi">+        properties: NodeProperties | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new node.

<span class="w"> </span>        Nodes can be classes, packages, participants etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # pylint: disable=duplicate-code</span>
<span class="gi">+        if properties is None:</span>
<span class="gi">+            properties = NodeProperties(label=name)</span>
<span class="gi">+        nodetype = self.NODES[type_]</span>
<span class="gi">+        body = []</span>
<span class="gi">+        if properties.attrs:</span>
<span class="gi">+            body.extend(properties.attrs)</span>
<span class="gi">+        if properties.methods:</span>
<span class="gi">+            for func in properties.methods:</span>
<span class="gi">+                args = self._get_method_arguments(func)</span>
<span class="gi">+                line = f&quot;{func.name}({&#39;, &#39;.join(args)})&quot;</span>
<span class="gi">+                line += &quot;*&quot; if func.is_abstract() else &quot;&quot;</span>
<span class="gi">+                if func.returns:</span>
<span class="gi">+                    line += f&quot; {get_annotation_label(func.returns)}&quot;</span>
<span class="gi">+                body.append(line)</span>
<span class="gi">+        name = name.split(&quot;.&quot;)[-1]</span>
<span class="gi">+        self.emit(f&quot;{nodetype} {name} {{&quot;)</span>
<span class="gi">+        self._inc_indent()</span>
<span class="gi">+        for line in body:</span>
<span class="gi">+            self.emit(line)</span>
<span class="gi">+        self._dec_indent()</span>
<span class="gi">+        self.emit(&quot;}&quot;)</span>

<span class="gd">-    def emit_edge(self, from_node: str, to_node: str, type_: EdgeType,</span>
<span class="gd">-        label: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def emit_edge(</span>
<span class="gi">+        self,</span>
<span class="gi">+        from_node: str,</span>
<span class="gi">+        to_node: str,</span>
<span class="gi">+        type_: EdgeType,</span>
<span class="gi">+        label: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an edge from one node to another to display relationships.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from_node = from_node.split(&quot;.&quot;)[-1]</span>
<span class="gi">+        to_node = to_node.split(&quot;.&quot;)[-1]</span>
<span class="gi">+        edge = f&quot;{from_node} {self.ARROWS[type_]} {to_node}&quot;</span>
<span class="gi">+        if label:</span>
<span class="gi">+            edge += f&quot; : {label}&quot;</span>
<span class="gi">+        self.emit(edge)</span>

<span class="gd">-    def _close_graph(self) -&gt;None:</span>
<span class="gi">+    def _close_graph(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit the lines needed to properly close the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._dec_indent()</span>


<span class="w"> </span>class HTMLMermaidJSPrinter(MermaidJSPrinter):
<span class="w"> </span>    &quot;&quot;&quot;Printer for MermaidJS diagrams wrapped in a html boilerplate.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    HTML_OPEN_BOILERPLATE = &quot;&quot;&quot;&lt;html&gt;
<span class="w"> </span>  &lt;body&gt;
<span class="w"> </span>    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&quot;&gt;&lt;/script&gt;
<span class="w"> </span>      &lt;div class=&quot;mermaid&quot;&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    HTML_CLOSE_BOILERPLATE = &#39;\n       &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&#39;</span>
<span class="gi">+    HTML_CLOSE_BOILERPLATE = &quot;&quot;&quot;</span>
<span class="gi">+       &lt;/div&gt;</span>
<span class="gi">+  &lt;/body&gt;</span>
<span class="gi">+&lt;/html&gt;</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="w"> </span>    GRAPH_INDENT_LEVEL = 4
<span class="gi">+</span>
<span class="gi">+    def _open_graph(self) -&gt; None:</span>
<span class="gi">+        self.emit(self.HTML_OPEN_BOILERPLATE)</span>
<span class="gi">+        for _ in range(self.GRAPH_INDENT_LEVEL):</span>
<span class="gi">+            self._inc_indent()</span>
<span class="gi">+        super()._open_graph()</span>
<span class="gi">+</span>
<span class="gi">+    def _close_graph(self) -&gt; None:</span>
<span class="gi">+        for _ in range(self.GRAPH_INDENT_LEVEL):</span>
<span class="gi">+            self._dec_indent()</span>
<span class="gi">+        self.emit(self.HTML_CLOSE_BOILERPLATE)</span>
<span class="gh">diff --git a/pylint/pyreverse/plantuml_printer.py b/pylint/pyreverse/plantuml_printer.py</span>
<span class="gh">index ed05f0b13..379d57a4c 100644</span>
<span class="gd">--- a/pylint/pyreverse/plantuml_printer.py</span>
<span class="gi">+++ b/pylint/pyreverse/plantuml_printer.py</span>
<span class="gu">@@ -1,35 +1,99 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Class to generate files in dot format and image formats supported by Graphviz.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from pylint.pyreverse.printer import EdgeType, Layout, NodeProperties, NodeType, Printer
<span class="w"> </span>from pylint.pyreverse.utils import get_annotation_label


<span class="w"> </span>class PlantUmlPrinter(Printer):
<span class="w"> </span>    &quot;&quot;&quot;Printer for PlantUML diagrams.&quot;&quot;&quot;
<span class="gd">-    DEFAULT_COLOR = &#39;black&#39;</span>
<span class="gd">-    NODES: dict[NodeType, str] = {NodeType.CLASS: &#39;class&#39;, NodeType.PACKAGE:</span>
<span class="gd">-        &#39;package&#39;}</span>
<span class="gd">-    ARROWS: dict[EdgeType, str] = {EdgeType.INHERITS: &#39;--|&gt;&#39;, EdgeType.</span>
<span class="gd">-        ASSOCIATION: &#39;--*&#39;, EdgeType.AGGREGATION: &#39;--o&#39;, EdgeType.USES:</span>
<span class="gd">-        &#39;--&gt;&#39;, EdgeType.TYPE_DEPENDENCY: &#39;..&gt;&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def _open_graph(self) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    DEFAULT_COLOR = &quot;black&quot;</span>
<span class="gi">+</span>
<span class="gi">+    NODES: dict[NodeType, str] = {</span>
<span class="gi">+        NodeType.CLASS: &quot;class&quot;,</span>
<span class="gi">+        NodeType.PACKAGE: &quot;package&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    ARROWS: dict[EdgeType, str] = {</span>
<span class="gi">+        EdgeType.INHERITS: &quot;--|&gt;&quot;,</span>
<span class="gi">+        EdgeType.ASSOCIATION: &quot;--*&quot;,</span>
<span class="gi">+        EdgeType.AGGREGATION: &quot;--o&quot;,</span>
<span class="gi">+        EdgeType.USES: &quot;--&gt;&quot;,</span>
<span class="gi">+        EdgeType.TYPE_DEPENDENCY: &quot;..&gt;&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def _open_graph(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit the header lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.emit(&quot;@startuml &quot; + self.title)</span>
<span class="gi">+        if not self.use_automatic_namespace:</span>
<span class="gi">+            self.emit(&quot;set namespaceSeparator none&quot;)</span>
<span class="gi">+        if self.layout:</span>
<span class="gi">+            if self.layout is Layout.LEFT_TO_RIGHT:</span>
<span class="gi">+                self.emit(&quot;left to right direction&quot;)</span>
<span class="gi">+            elif self.layout is Layout.TOP_TO_BOTTOM:</span>
<span class="gi">+                self.emit(&quot;top to bottom direction&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;Unsupported layout {self.layout}. PlantUmlPrinter only &quot;</span>
<span class="gi">+                    &quot;supports left to right and top to bottom layout.&quot;</span>
<span class="gi">+                )</span>

<span class="gd">-    def emit_node(self, name: str, type_: NodeType, properties: (</span>
<span class="gd">-        NodeProperties | None)=None) -&gt;None:</span>
<span class="gi">+    def emit_node(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        type_: NodeType,</span>
<span class="gi">+        properties: NodeProperties | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new node.

<span class="w"> </span>        Nodes can be classes, packages, participants etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if properties is None:</span>
<span class="gi">+            properties = NodeProperties(label=name)</span>
<span class="gi">+        nodetype = self.NODES[type_]</span>
<span class="gi">+        if properties.color and properties.color != self.DEFAULT_COLOR:</span>
<span class="gi">+            color = f&quot; #{properties.color.lstrip(&#39;#&#39;)}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            color = &quot;&quot;</span>
<span class="gi">+        body = []</span>
<span class="gi">+        if properties.attrs:</span>
<span class="gi">+            body.extend(properties.attrs)</span>
<span class="gi">+        if properties.methods:</span>
<span class="gi">+            for func in properties.methods:</span>
<span class="gi">+                args = self._get_method_arguments(func)</span>
<span class="gi">+                line = &quot;{abstract}&quot; if func.is_abstract() else &quot;&quot;</span>
<span class="gi">+                line += f&quot;{func.name}({&#39;, &#39;.join(args)})&quot;</span>
<span class="gi">+                if func.returns:</span>
<span class="gi">+                    line += &quot; -&gt; &quot; + get_annotation_label(func.returns)</span>
<span class="gi">+                body.append(line)</span>
<span class="gi">+        label = properties.label if properties.label is not None else name</span>
<span class="gi">+        if properties.fontcolor and properties.fontcolor != self.DEFAULT_COLOR:</span>
<span class="gi">+            label = f&quot;&lt;color:{properties.fontcolor}&gt;{label}&lt;/color&gt;&quot;</span>
<span class="gi">+        self.emit(f&#39;{nodetype} &quot;{label}&quot; as {name}{color} {{&#39;)</span>
<span class="gi">+        self._inc_indent()</span>
<span class="gi">+        for line in body:</span>
<span class="gi">+            self.emit(line)</span>
<span class="gi">+        self._dec_indent()</span>
<span class="gi">+        self.emit(&quot;}&quot;)</span>

<span class="gd">-    def emit_edge(self, from_node: str, to_node: str, type_: EdgeType,</span>
<span class="gd">-        label: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def emit_edge(</span>
<span class="gi">+        self,</span>
<span class="gi">+        from_node: str,</span>
<span class="gi">+        to_node: str,</span>
<span class="gi">+        type_: EdgeType,</span>
<span class="gi">+        label: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an edge from one node to another to display relationships.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        edge = f&quot;{from_node} {self.ARROWS[type_]} {to_node}&quot;</span>
<span class="gi">+        if label:</span>
<span class="gi">+            edge += f&quot; : {label}&quot;</span>
<span class="gi">+        self.emit(edge)</span>

<span class="gd">-    def _close_graph(self) -&gt;None:</span>
<span class="gi">+    def _close_graph(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit the lines needed to properly close the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.emit(&quot;@enduml&quot;)</span>
<span class="gh">diff --git a/pylint/pyreverse/printer.py b/pylint/pyreverse/printer.py</span>
<span class="gh">index 289b213ad..caa7917ca 100644</span>
<span class="gd">--- a/pylint/pyreverse/printer.py</span>
<span class="gi">+++ b/pylint/pyreverse/printer.py</span>
<span class="gu">@@ -1,30 +1,38 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Base class defining the interface for a printer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from typing import NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.pyreverse.utils import get_annotation_label


<span class="w"> </span>class NodeType(Enum):
<span class="gd">-    CLASS = &#39;class&#39;</span>
<span class="gd">-    PACKAGE = &#39;package&#39;</span>
<span class="gi">+    CLASS = &quot;class&quot;</span>
<span class="gi">+    PACKAGE = &quot;package&quot;</span>


<span class="w"> </span>class EdgeType(Enum):
<span class="gd">-    INHERITS = &#39;inherits&#39;</span>
<span class="gd">-    ASSOCIATION = &#39;association&#39;</span>
<span class="gd">-    AGGREGATION = &#39;aggregation&#39;</span>
<span class="gd">-    USES = &#39;uses&#39;</span>
<span class="gd">-    TYPE_DEPENDENCY = &#39;type_dependency&#39;</span>
<span class="gi">+    INHERITS = &quot;inherits&quot;</span>
<span class="gi">+    ASSOCIATION = &quot;association&quot;</span>
<span class="gi">+    AGGREGATION = &quot;aggregation&quot;</span>
<span class="gi">+    USES = &quot;uses&quot;</span>
<span class="gi">+    TYPE_DEPENDENCY = &quot;type_dependency&quot;</span>


<span class="w"> </span>class Layout(Enum):
<span class="gd">-    LEFT_TO_RIGHT = &#39;LR&#39;</span>
<span class="gd">-    RIGHT_TO_LEFT = &#39;RL&#39;</span>
<span class="gd">-    TOP_TO_BOTTOM = &#39;TB&#39;</span>
<span class="gd">-    BOTTOM_TO_TOP = &#39;BT&#39;</span>
<span class="gi">+    LEFT_TO_RIGHT = &quot;LR&quot;</span>
<span class="gi">+    RIGHT_TO_LEFT = &quot;RL&quot;</span>
<span class="gi">+    TOP_TO_BOTTOM = &quot;TB&quot;</span>
<span class="gi">+    BOTTOM_TO_TOP = &quot;BT&quot;</span>


<span class="w"> </span>class NodeProperties(NamedTuple):
<span class="gu">@@ -38,50 +46,87 @@ class NodeProperties(NamedTuple):</span>
<span class="w"> </span>class Printer(ABC):
<span class="w"> </span>    &quot;&quot;&quot;Base class defining the interface for a printer.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, title: str, layout: (Layout | None)=None,</span>
<span class="gd">-        use_automatic_namespace: (bool | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        title: str,</span>
<span class="gi">+        layout: Layout | None = None,</span>
<span class="gi">+        use_automatic_namespace: bool | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.title: str = title
<span class="w"> </span>        self.layout = layout
<span class="w"> </span>        self.use_automatic_namespace = use_automatic_namespace
<span class="w"> </span>        self.lines: list[str] = []
<span class="gd">-        self._indent = &#39;&#39;</span>
<span class="gi">+        self._indent = &quot;&quot;</span>
<span class="w"> </span>        self._open_graph()

<span class="gd">-    def _inc_indent(self) -&gt;None:</span>
<span class="gi">+    def _inc_indent(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increment indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._indent += &quot;  &quot;</span>

<span class="gd">-    def _dec_indent(self) -&gt;None:</span>
<span class="gi">+    def _dec_indent(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Decrement indentation.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._indent = self._indent[:-2]</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def _open_graph(self) -&gt;None:</span>
<span class="gi">+    def _open_graph(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit the header lines, i.e. all boilerplate code that defines things like
<span class="w"> </span>        layout etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    def emit(self, line: str, force_newline: bool | None = True) -&gt; None:</span>
<span class="gi">+        if force_newline and not line.endswith(&quot;\n&quot;):</span>
<span class="gi">+            line += &quot;\n&quot;</span>
<span class="gi">+        self.lines.append(self._indent + line)</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def emit_node(self, name: str, type_: NodeType, properties: (</span>
<span class="gd">-        NodeProperties | None)=None) -&gt;None:</span>
<span class="gi">+    def emit_node(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        type_: NodeType,</span>
<span class="gi">+        properties: NodeProperties | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new node.

<span class="w"> </span>        Nodes can be classes, packages, participants etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def emit_edge(self, from_node: str, to_node: str, type_: EdgeType,</span>
<span class="gd">-        label: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def emit_edge(</span>
<span class="gi">+        self,</span>
<span class="gi">+        from_node: str,</span>
<span class="gi">+        to_node: str,</span>
<span class="gi">+        type_: EdgeType,</span>
<span class="gi">+        label: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an edge from one node to another to display relationships.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def generate(self, outputfile: str) -&gt;None:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_method_arguments(method: nodes.FunctionDef) -&gt; list[str]:</span>
<span class="gi">+        if method.args.args is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        first_arg = 0 if method.type in {&quot;function&quot;, &quot;staticmethod&quot;} else 1</span>
<span class="gi">+        arguments: list[nodes.AssignName] = method.args.args[first_arg:]</span>
<span class="gi">+</span>
<span class="gi">+        annotations = dict(zip(arguments, method.args.annotations[first_arg:]))</span>
<span class="gi">+        for arg in arguments:</span>
<span class="gi">+            annotation_label = &quot;&quot;</span>
<span class="gi">+            ann = annotations.get(arg)</span>
<span class="gi">+            if ann:</span>
<span class="gi">+                annotation_label = get_annotation_label(ann)</span>
<span class="gi">+            annotations[arg] = annotation_label</span>
<span class="gi">+</span>
<span class="gi">+        return [</span>
<span class="gi">+            f&quot;{arg.name}: {ann}&quot; if ann else f&quot;{arg.name}&quot;</span>
<span class="gi">+            for arg, ann in annotations.items()</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    def generate(self, outputfile: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate and save the final outputfile.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._close_graph()</span>
<span class="gi">+        with open(outputfile, &quot;w&quot;, encoding=&quot;utf-8&quot;) as outfile:</span>
<span class="gi">+            outfile.writelines(self.lines)</span>

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def _close_graph(self) -&gt;None:</span>
<span class="gi">+    def _close_graph(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit the lines needed to properly close the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gh">diff --git a/pylint/pyreverse/printer_factory.py b/pylint/pyreverse/printer_factory.py</span>
<span class="gh">index 80244671a..fdbe480ed 100644</span>
<span class="gd">--- a/pylint/pyreverse/printer_factory.py</span>
<span class="gi">+++ b/pylint/pyreverse/printer_factory.py</span>
<span class="gu">@@ -1,8 +1,22 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from pylint.pyreverse.dot_printer import DotPrinter
<span class="w"> </span>from pylint.pyreverse.mermaidjs_printer import HTMLMermaidJSPrinter, MermaidJSPrinter
<span class="w"> </span>from pylint.pyreverse.plantuml_printer import PlantUmlPrinter
<span class="w"> </span>from pylint.pyreverse.printer import Printer
<span class="gd">-filetype_to_printer: dict[str, type[Printer]] = {&#39;plantuml&#39;:</span>
<span class="gd">-    PlantUmlPrinter, &#39;puml&#39;: PlantUmlPrinter, &#39;mmd&#39;: MermaidJSPrinter,</span>
<span class="gd">-    &#39;html&#39;: HTMLMermaidJSPrinter, &#39;dot&#39;: DotPrinter}</span>
<span class="gi">+</span>
<span class="gi">+filetype_to_printer: dict[str, type[Printer]] = {</span>
<span class="gi">+    &quot;plantuml&quot;: PlantUmlPrinter,</span>
<span class="gi">+    &quot;puml&quot;: PlantUmlPrinter,</span>
<span class="gi">+    &quot;mmd&quot;: MermaidJSPrinter,</span>
<span class="gi">+    &quot;html&quot;: HTMLMermaidJSPrinter,</span>
<span class="gi">+    &quot;dot&quot;: DotPrinter,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_printer_for_filetype(filetype: str) -&gt; type[Printer]:</span>
<span class="gi">+    return filetype_to_printer.get(filetype, DotPrinter)</span>
<span class="gh">diff --git a/pylint/pyreverse/utils.py b/pylint/pyreverse/utils.py</span>
<span class="gh">index 4d75d3e1a..bdd28dc7c 100644</span>
<span class="gd">--- a/pylint/pyreverse/utils.py</span>
<span class="gi">+++ b/pylint/pyreverse/utils.py</span>
<span class="gu">@@ -1,67 +1,118 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Generic classes/functions for pyreverse core/extensions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import shutil
<span class="w"> </span>import subprocess
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Callable, Optional, Tuple, Union
<span class="gi">+</span>
<span class="w"> </span>import astroid
<span class="w"> </span>from astroid import nodes
<span class="w"> </span>from astroid.typing import InferenceResult
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.pyreverse.diagrams import ClassDiagram, PackageDiagram
<span class="gd">-    _CallbackT = Callable[[nodes.NodeNG], Union[Tuple[ClassDiagram], Tuple[</span>
<span class="gd">-        PackageDiagram, ClassDiagram], None]]</span>
<span class="gi">+</span>
<span class="gi">+    _CallbackT = Callable[</span>
<span class="gi">+        [nodes.NodeNG],</span>
<span class="gi">+        Union[Tuple[ClassDiagram], Tuple[PackageDiagram, ClassDiagram], None],</span>
<span class="gi">+    ]</span>
<span class="w"> </span>    _CallbackTupleT = Tuple[Optional[_CallbackT], Optional[_CallbackT]]
<span class="gd">-RCFILE = &#39;.pyreverserc&#39;</span>


<span class="gd">-def get_default_options() -&gt;list[str]:</span>
<span class="gi">+RCFILE = &quot;.pyreverserc&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_default_options() -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read config file and return list of options.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    options = []</span>
<span class="gi">+    home = os.environ.get(&quot;HOME&quot;, &quot;&quot;)</span>
<span class="gi">+    if home:</span>
<span class="gi">+        rcfile = os.path.join(home, RCFILE)</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(rcfile, encoding=&quot;utf-8&quot;) as file_handle:</span>
<span class="gi">+                options = file_handle.read().split()</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            pass  # ignore if no config file found</span>
<span class="gi">+    return options</span>


<span class="gd">-def insert_default_options() -&gt;None:</span>
<span class="gi">+def insert_default_options() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Insert default options to sys.argv.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    options = get_default_options()</span>
<span class="gi">+    options.reverse()</span>
<span class="gi">+    for arg in options:</span>
<span class="gi">+        sys.argv.insert(1, arg)</span>


<span class="gd">-SPECIAL = re.compile(&#39;^__([^\\W_]_*)+__$&#39;)</span>
<span class="gd">-PRIVATE = re.compile(&#39;^__(_*[^\\W_])+_?$&#39;)</span>
<span class="gd">-PROTECTED = re.compile(&#39;^_\\w*$&#39;)</span>
<span class="gi">+# astroid utilities ###########################################################</span>
<span class="gi">+SPECIAL = re.compile(r&quot;^__([^\W_]_*)+__$&quot;)</span>
<span class="gi">+PRIVATE = re.compile(r&quot;^__(_*[^\W_])+_?$&quot;)</span>
<span class="gi">+PROTECTED = re.compile(r&quot;^_\w*$&quot;)</span>


<span class="gd">-def get_visibility(name: str) -&gt;str:</span>
<span class="gi">+def get_visibility(name: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the visibility from a name: public, protected, private or special.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if SPECIAL.match(name):</span>
<span class="gi">+        visibility = &quot;special&quot;</span>
<span class="gi">+    elif PRIVATE.match(name):</span>
<span class="gi">+        visibility = &quot;private&quot;</span>
<span class="gi">+    elif PROTECTED.match(name):</span>
<span class="gi">+        visibility = &quot;protected&quot;</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+        visibility = &quot;public&quot;</span>
<span class="gi">+    return visibility</span>
<span class="gi">+</span>

<span class="gi">+def is_exception(node: nodes.ClassDef) -&gt; bool:</span>
<span class="gi">+    # bw compatibility</span>
<span class="gi">+    return node.type == &quot;exception&quot;  # type: ignore[no-any-return]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Helpers #####################################################################</span>

<span class="w"> </span>_SPECIAL = 2
<span class="w"> </span>_PROTECTED = 4
<span class="w"> </span>_PRIVATE = 8
<span class="gd">-MODES = {&#39;ALL&#39;: 0, &#39;PUB_ONLY&#39;: _SPECIAL + _PROTECTED + _PRIVATE, &#39;SPECIAL&#39;:</span>
<span class="gd">-    _SPECIAL, &#39;OTHER&#39;: _PROTECTED + _PRIVATE}</span>
<span class="gd">-VIS_MOD = {&#39;special&#39;: _SPECIAL, &#39;protected&#39;: _PROTECTED, &#39;private&#39;:</span>
<span class="gd">-    _PRIVATE, &#39;public&#39;: 0}</span>
<span class="gi">+MODES = {</span>
<span class="gi">+    &quot;ALL&quot;: 0,</span>
<span class="gi">+    &quot;PUB_ONLY&quot;: _SPECIAL + _PROTECTED + _PRIVATE,</span>
<span class="gi">+    &quot;SPECIAL&quot;: _SPECIAL,</span>
<span class="gi">+    &quot;OTHER&quot;: _PROTECTED + _PRIVATE,</span>
<span class="gi">+}</span>
<span class="gi">+VIS_MOD = {</span>
<span class="gi">+    &quot;special&quot;: _SPECIAL,</span>
<span class="gi">+    &quot;protected&quot;: _PROTECTED,</span>
<span class="gi">+    &quot;private&quot;: _PRIVATE,</span>
<span class="gi">+    &quot;public&quot;: 0,</span>
<span class="gi">+}</span>


<span class="w"> </span>class FilterMixIn:
<span class="w"> </span>    &quot;&quot;&quot;Filter nodes according to a mode and nodes&#39; visibility.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, mode: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, mode: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Init filter modes.&quot;&quot;&quot;
<span class="w"> </span>        __mode = 0
<span class="gd">-        for nummod in mode.split(&#39;+&#39;):</span>
<span class="gi">+        for nummod in mode.split(&quot;+&quot;):</span>
<span class="w"> </span>            try:
<span class="w"> </span>                __mode += MODES[nummod]
<span class="w"> </span>            except KeyError as ex:
<span class="gd">-                print(f&#39;Unknown filter mode {ex}&#39;, file=sys.stderr)</span>
<span class="gi">+                print(f&quot;Unknown filter mode {ex}&quot;, file=sys.stderr)</span>
<span class="w"> </span>        self.__mode = __mode

<span class="gd">-    def show_attr(self, node: (nodes.NodeNG | str)) -&gt;bool:</span>
<span class="gi">+    def show_attr(self, node: nodes.NodeNG | str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return true if the node should be treated.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        visibility = get_visibility(getattr(node, &quot;name&quot;, node))</span>
<span class="gi">+        return not self.__mode &amp; VIS_MOD[visibility]</span>


<span class="w"> </span>class LocalsVisitor:
<span class="gu">@@ -74,46 +125,146 @@ class LocalsVisitor:</span>
<span class="w"> </span>    the node in lower case
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._cache: dict[type[nodes.NodeNG], _CallbackTupleT] = {}
<span class="w"> </span>        self._visited: set[nodes.NodeNG] = set()

<span class="gd">-    def get_callbacks(self, node: nodes.NodeNG) -&gt;_CallbackTupleT:</span>
<span class="gi">+    def get_callbacks(self, node: nodes.NodeNG) -&gt; _CallbackTupleT:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get callbacks from handler for the visited node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        klass = node.__class__</span>
<span class="gi">+        methods = self._cache.get(klass)</span>
<span class="gi">+        if methods is None:</span>
<span class="gi">+            kid = klass.__name__.lower()</span>
<span class="gi">+            e_method = getattr(</span>
<span class="gi">+                self, f&quot;visit_{kid}&quot;, getattr(self, &quot;visit_default&quot;, None)</span>
<span class="gi">+            )</span>
<span class="gi">+            l_method = getattr(</span>
<span class="gi">+                self, f&quot;leave_{kid}&quot;, getattr(self, &quot;leave_default&quot;, None)</span>
<span class="gi">+            )</span>
<span class="gi">+            self._cache[klass] = (e_method, l_method)</span>
<span class="gi">+        else:</span>
<span class="gi">+            e_method, l_method = methods</span>
<span class="gi">+        return e_method, l_method</span>

<span class="gd">-    def visit(self, node: nodes.NodeNG) -&gt;Any:</span>
<span class="gi">+    def visit(self, node: nodes.NodeNG) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Launch the visit starting from the given node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node in self._visited:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        self._visited.add(node)</span>
<span class="gi">+        methods = self.get_callbacks(node)</span>
<span class="gi">+        if methods[0] is not None:</span>
<span class="gi">+            methods[0](node)</span>
<span class="gi">+        if hasattr(node, &quot;locals&quot;):  # skip Instance and other proxy</span>
<span class="gi">+            for local_node in node.values():</span>
<span class="gi">+                self.visit(local_node)</span>
<span class="gi">+        if methods[1] is not None:</span>
<span class="gi">+            return methods[1](node)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_annotation_label(ann: nodes.Name | nodes.NodeNG) -&gt; str:</span>
<span class="gi">+    if isinstance(ann, nodes.Name) and ann.name is not None:</span>
<span class="gi">+        return ann.name  # type: ignore[no-any-return]</span>
<span class="gi">+    if isinstance(ann, nodes.NodeNG):</span>
<span class="gi">+        return ann.as_string()  # type: ignore[no-any-return]</span>
<span class="gi">+    return &quot;&quot;</span>


<span class="gd">-def get_annotation(node: (nodes.AssignAttr | nodes.AssignName)) -&gt;(nodes.</span>
<span class="gd">-    Name | nodes.Subscript | None):</span>
<span class="gi">+def get_annotation(</span>
<span class="gi">+    node: nodes.AssignAttr | nodes.AssignName,</span>
<span class="gi">+) -&gt; nodes.Name | nodes.Subscript | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the annotation for `node`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ann = None</span>
<span class="gi">+    if isinstance(node.parent, nodes.AnnAssign):</span>
<span class="gi">+        ann = node.parent.annotation</span>
<span class="gi">+    elif isinstance(node, nodes.AssignAttr):</span>
<span class="gi">+        init_method = node.parent.parent</span>
<span class="gi">+        try:</span>
<span class="gi">+            annotations = dict(zip(init_method.locals, init_method.args.annotations))</span>
<span class="gi">+            ann = annotations.get(node.parent.value.name)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    else:</span>
<span class="gi">+        return ann</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        default, *_ = node.infer()</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        default = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    label = get_annotation_label(ann)</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        ann</span>
<span class="gi">+        and getattr(default, &quot;value&quot;, &quot;value&quot;) is None</span>
<span class="gi">+        and not label.startswith(&quot;Optional&quot;)</span>
<span class="gi">+        and (</span>
<span class="gi">+            not isinstance(ann, nodes.BinOp)</span>
<span class="gi">+            or not any(</span>
<span class="gi">+                isinstance(child, nodes.Const) and child.value is None</span>
<span class="gi">+                for child in ann.get_children()</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+    ):</span>
<span class="gi">+        label = rf&quot;Optional[{label}]&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if label and ann:</span>
<span class="gi">+        ann.name = label</span>
<span class="gi">+    return ann</span>


<span class="gd">-def infer_node(node: (nodes.AssignAttr | nodes.AssignName)) -&gt;set[</span>
<span class="gd">-    InferenceResult]:</span>
<span class="gi">+def infer_node(node: nodes.AssignAttr | nodes.AssignName) -&gt; set[InferenceResult]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a set containing the node annotation if it exists
<span class="w"> </span>    otherwise return a set of the inferred types using the NodeNG.infer method.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ann = get_annotation(node)</span>
<span class="gi">+    try:</span>
<span class="gi">+        if ann:</span>
<span class="gi">+            if isinstance(ann, nodes.Subscript) or (</span>
<span class="gi">+                isinstance(ann, nodes.BinOp) and ann.op == &quot;|&quot;</span>
<span class="gi">+            ):</span>
<span class="gi">+                return {ann}</span>
<span class="gi">+            return set(ann.infer())</span>
<span class="gi">+        return set(node.infer())</span>
<span class="gi">+    except astroid.InferenceError:</span>
<span class="gi">+        return {ann} if ann else set()</span>


<span class="gd">-def check_graphviz_availability() -&gt;None:</span>
<span class="gi">+def check_graphviz_availability() -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the ``dot`` command is available on the machine.

<span class="w"> </span>    This is needed if image output is desired and ``dot`` is used to convert
<span class="w"> </span>    from *.dot or *.gv into the final output format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if shutil.which(&quot;dot&quot;) is None:</span>
<span class="gi">+        print(&quot;&#39;Graphviz&#39; needs to be installed for your chosen output format.&quot;)</span>
<span class="gi">+        sys.exit(32)</span>


<span class="gd">-def check_if_graphviz_supports_format(output_format: str) -&gt;None:</span>
<span class="gi">+def check_if_graphviz_supports_format(output_format: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the ``dot`` command supports the requested output format.

<span class="w"> </span>    This is needed if image output is desired and ``dot`` is used to convert
<span class="w"> </span>    from *.gv into the final output format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dot_output = subprocess.run(</span>
<span class="gi">+        [&quot;dot&quot;, &quot;-T?&quot;], capture_output=True, check=False, encoding=&quot;utf-8&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    match = re.match(</span>
<span class="gi">+        pattern=r&quot;.*Use one of: (?P&lt;formats&gt;(\S*\s?)+)&quot;,</span>
<span class="gi">+        string=dot_output.stderr.strip(),</span>
<span class="gi">+    )</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        print(</span>
<span class="gi">+            &quot;Unable to determine Graphviz supported output formats. &quot;</span>
<span class="gi">+            &quot;Pyreverse will continue, but subsequent error messages &quot;</span>
<span class="gi">+            &quot;regarding the output format may come from Graphviz directly.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        return</span>
<span class="gi">+    supported_formats = match.group(&quot;formats&quot;)</span>
<span class="gi">+    if output_format not in supported_formats.split():</span>
<span class="gi">+        print(</span>
<span class="gi">+            f&quot;Format {output_format} is not supported by Graphviz. It supports: {supported_formats}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        sys.exit(32)</span>
<span class="gh">diff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py</span>
<span class="gh">index 55d8714f1..093c45959 100644</span>
<span class="gd">--- a/pylint/pyreverse/writer.py</span>
<span class="gi">+++ b/pylint/pyreverse/writer.py</span>
<span class="gu">@@ -1,12 +1,26 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for creating diagrams.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import itertools
<span class="w"> </span>import os
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from collections.abc import Iterable
<span class="gi">+</span>
<span class="w"> </span>from astroid import modutils, nodes
<span class="gd">-from pylint.pyreverse.diagrams import ClassDiagram, ClassEntity, DiagramEntity, PackageDiagram, PackageEntity</span>
<span class="gi">+</span>
<span class="gi">+from pylint.pyreverse.diagrams import (</span>
<span class="gi">+    ClassDiagram,</span>
<span class="gi">+    ClassEntity,</span>
<span class="gi">+    DiagramEntity,</span>
<span class="gi">+    PackageDiagram,</span>
<span class="gi">+    PackageEntity,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.pyreverse.printer import EdgeType, NodeProperties, NodeType, Printer
<span class="w"> </span>from pylint.pyreverse.printer_factory import get_printer_for_filetype
<span class="w"> </span>from pylint.pyreverse.utils import is_exception
<span class="gu">@@ -15,44 +29,171 @@ from pylint.pyreverse.utils import is_exception</span>
<span class="w"> </span>class DiagramWriter:
<span class="w"> </span>    &quot;&quot;&quot;Base class for writing project diagrams.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, config: argparse.Namespace) -&gt;None:</span>
<span class="gi">+    def __init__(self, config: argparse.Namespace) -&gt; None:</span>
<span class="w"> </span>        self.config = config
<span class="gd">-        self.printer_class = get_printer_for_filetype(self.config.output_format</span>
<span class="gd">-            )</span>
<span class="gd">-        self.printer: Printer</span>
<span class="gd">-        self.file_name = &#39;&#39;</span>
<span class="gi">+        self.printer_class = get_printer_for_filetype(self.config.output_format)</span>
<span class="gi">+        self.printer: Printer  # defined in set_printer</span>
<span class="gi">+        self.file_name = &quot;&quot;  # defined in set_printer</span>
<span class="w"> </span>        self.depth = self.config.max_color_depth
<span class="gi">+        # default colors are an adaption of the seaborn colorblind palette</span>
<span class="w"> </span>        self.available_colors = itertools.cycle(self.config.color_palette)
<span class="w"> </span>        self.used_colors: dict[str, str] = {}

<span class="gd">-    def write(self, diadefs: Iterable[ClassDiagram | PackageDiagram]) -&gt;None:</span>
<span class="gi">+    def write(self, diadefs: Iterable[ClassDiagram | PackageDiagram]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write files for &lt;project&gt; according to &lt;diadefs&gt;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for diagram in diadefs:</span>
<span class="gi">+            basename = diagram.title.strip().replace(&quot;/&quot;, &quot;_&quot;).replace(&quot; &quot;, &quot;_&quot;)</span>
<span class="gi">+            file_name = f&quot;{basename}.{self.config.output_format}&quot;</span>
<span class="gi">+            if os.path.exists(self.config.output_directory):</span>
<span class="gi">+                file_name = os.path.join(self.config.output_directory, file_name)</span>
<span class="gi">+            self.set_printer(file_name, basename)</span>
<span class="gi">+            if isinstance(diagram, PackageDiagram):</span>
<span class="gi">+                self.write_packages(diagram)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.write_classes(diagram)</span>
<span class="gi">+            self.save()</span>

<span class="gd">-    def write_packages(self, diagram: PackageDiagram) -&gt;None:</span>
<span class="gi">+    def write_packages(self, diagram: PackageDiagram) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a package diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        module_info: dict[str, dict[str, int]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        # sorted to get predictable (hence testable) results</span>
<span class="gi">+        for module in sorted(diagram.modules(), key=lambda x: x.title):</span>
<span class="gi">+            module.fig_id = module.node.qname()</span>

<span class="gd">-    def write_classes(self, diagram: ClassDiagram) -&gt;None:</span>
<span class="gi">+            if self.config.no_standalone and not any(</span>
<span class="gi">+                module in (rel.from_object, rel.to_object)</span>
<span class="gi">+                for rel in diagram.get_relationships(&quot;depends&quot;)</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            self.printer.emit_node(</span>
<span class="gi">+                module.fig_id,</span>
<span class="gi">+                type_=NodeType.PACKAGE,</span>
<span class="gi">+                properties=self.get_package_properties(module),</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            module_info[module.fig_id] = {</span>
<span class="gi">+                &quot;imports&quot;: 0,</span>
<span class="gi">+                &quot;imported&quot;: 0,</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        # package dependencies</span>
<span class="gi">+        for rel in diagram.get_relationships(&quot;depends&quot;):</span>
<span class="gi">+            from_id = rel.from_object.fig_id</span>
<span class="gi">+            to_id = rel.to_object.fig_id</span>
<span class="gi">+</span>
<span class="gi">+            self.printer.emit_edge(</span>
<span class="gi">+                from_id,</span>
<span class="gi">+                to_id,</span>
<span class="gi">+                type_=EdgeType.USES,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            module_info[from_id][&quot;imports&quot;] += 1</span>
<span class="gi">+            module_info[to_id][&quot;imported&quot;] += 1</span>
<span class="gi">+</span>
<span class="gi">+        for rel in diagram.get_relationships(&quot;type_depends&quot;):</span>
<span class="gi">+            from_id = rel.from_object.fig_id</span>
<span class="gi">+            to_id = rel.to_object.fig_id</span>
<span class="gi">+</span>
<span class="gi">+            self.printer.emit_edge(</span>
<span class="gi">+                from_id,</span>
<span class="gi">+                to_id,</span>
<span class="gi">+                type_=EdgeType.TYPE_DEPENDENCY,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            module_info[from_id][&quot;imports&quot;] += 1</span>
<span class="gi">+            module_info[to_id][&quot;imported&quot;] += 1</span>
<span class="gi">+</span>
<span class="gi">+        print(</span>
<span class="gi">+            f&quot;Analysed {len(module_info)} modules with a total &quot;</span>
<span class="gi">+            f&quot;of {sum(mod[&#39;imports&#39;] for mod in module_info.values())} imports&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def write_classes(self, diagram: ClassDiagram) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a class diagram.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # sorted to get predictable (hence testable) results</span>
<span class="gi">+        for obj in sorted(diagram.objects, key=lambda x: x.title):</span>
<span class="gi">+            obj.fig_id = obj.node.qname()</span>
<span class="gi">+            if self.config.no_standalone and not any(</span>
<span class="gi">+                obj in (rel.from_object, rel.to_object)</span>
<span class="gi">+                for rel_type in (&quot;specialization&quot;, &quot;association&quot;, &quot;aggregation&quot;)</span>
<span class="gi">+                for rel in diagram.get_relationships(rel_type)</span>
<span class="gi">+            ):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            self.printer.emit_node(</span>
<span class="gi">+                obj.fig_id,</span>
<span class="gi">+                type_=NodeType.CLASS,</span>
<span class="gi">+                properties=self.get_class_properties(obj),</span>
<span class="gi">+            )</span>
<span class="gi">+        # inheritance links</span>
<span class="gi">+        for rel in diagram.get_relationships(&quot;specialization&quot;):</span>
<span class="gi">+            self.printer.emit_edge(</span>
<span class="gi">+                rel.from_object.fig_id,</span>
<span class="gi">+                rel.to_object.fig_id,</span>
<span class="gi">+                type_=EdgeType.INHERITS,</span>
<span class="gi">+            )</span>
<span class="gi">+        associations: dict[str, set[str]] = defaultdict(set)</span>
<span class="gi">+        # generate associations</span>
<span class="gi">+        for rel in diagram.get_relationships(&quot;association&quot;):</span>
<span class="gi">+            associations[rel.from_object.fig_id].add(rel.to_object.fig_id)</span>
<span class="gi">+            self.printer.emit_edge(</span>
<span class="gi">+                rel.from_object.fig_id,</span>
<span class="gi">+                rel.to_object.fig_id,</span>
<span class="gi">+                label=rel.name,</span>
<span class="gi">+                type_=EdgeType.ASSOCIATION,</span>
<span class="gi">+            )</span>
<span class="gi">+        # generate aggregations</span>
<span class="gi">+        for rel in diagram.get_relationships(&quot;aggregation&quot;):</span>
<span class="gi">+            if rel.to_object.fig_id in associations[rel.from_object.fig_id]:</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.printer.emit_edge(</span>
<span class="gi">+                rel.from_object.fig_id,</span>
<span class="gi">+                rel.to_object.fig_id,</span>
<span class="gi">+                label=rel.name,</span>
<span class="gi">+                type_=EdgeType.AGGREGATION,</span>
<span class="gi">+            )</span>

<span class="gd">-    def set_printer(self, file_name: str, basename: str) -&gt;None:</span>
<span class="gi">+    def set_printer(self, file_name: str, basename: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set printer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.printer = self.printer_class(basename)</span>
<span class="gi">+        self.file_name = file_name</span>

<span class="gd">-    def get_package_properties(self, obj: PackageEntity) -&gt;NodeProperties:</span>
<span class="gi">+    def get_package_properties(self, obj: PackageEntity) -&gt; NodeProperties:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get label and shape for packages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return NodeProperties(</span>
<span class="gi">+            label=obj.title,</span>
<span class="gi">+            color=self.get_shape_color(obj) if self.config.colorized else &quot;black&quot;,</span>
<span class="gi">+        )</span>

<span class="gd">-    def get_class_properties(self, obj: ClassEntity) -&gt;NodeProperties:</span>
<span class="gi">+    def get_class_properties(self, obj: ClassEntity) -&gt; NodeProperties:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get label and shape for classes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        properties = NodeProperties(</span>
<span class="gi">+            label=obj.title,</span>
<span class="gi">+            attrs=obj.attrs if not self.config.only_classnames else None,</span>
<span class="gi">+            methods=obj.methods if not self.config.only_classnames else None,</span>
<span class="gi">+            fontcolor=&quot;red&quot; if is_exception(obj.node) else &quot;black&quot;,</span>
<span class="gi">+            color=self.get_shape_color(obj) if self.config.colorized else &quot;black&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        return properties</span>

<span class="gd">-    def get_shape_color(self, obj: DiagramEntity) -&gt;str:</span>
<span class="gi">+    def get_shape_color(self, obj: DiagramEntity) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get shape color.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        qualified_name = obj.node.qname()</span>
<span class="gi">+        if modutils.is_stdlib_module(qualified_name.split(&quot;.&quot;, maxsplit=1)[0]):</span>
<span class="gi">+            return &quot;grey&quot;</span>
<span class="gi">+        if isinstance(obj.node, nodes.ClassDef):</span>
<span class="gi">+            package = qualified_name.rsplit(&quot;.&quot;, maxsplit=2)[0]</span>
<span class="gi">+        elif obj.node.package:</span>
<span class="gi">+            package = qualified_name</span>
<span class="gi">+        else:</span>
<span class="gi">+            package = qualified_name.rsplit(&quot;.&quot;, maxsplit=1)[0]</span>
<span class="gi">+        base_name = &quot;.&quot;.join(package.split(&quot;.&quot;, self.depth)[: self.depth])</span>
<span class="gi">+        if base_name not in self.used_colors:</span>
<span class="gi">+            self.used_colors[base_name] = next(self.available_colors)</span>
<span class="gi">+        return self.used_colors[base_name]</span>

<span class="gd">-    def save(self) -&gt;None:</span>
<span class="gi">+    def save(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write to disk.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.printer.generate(self.file_name)</span>
<span class="gh">diff --git a/pylint/reporters/base_reporter.py b/pylint/reporters/base_reporter.py</span>
<span class="gh">index 2a79b16e1..d370b1910 100644</span>
<span class="gd">--- a/pylint/reporters/base_reporter.py</span>
<span class="gi">+++ b/pylint/reporters/base_reporter.py</span>
<span class="gu">@@ -1,10 +1,17 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING, TextIO
<span class="gi">+</span>
<span class="w"> </span>from pylint.message import Message
<span class="w"> </span>from pylint.reporters.ureports.nodes import Text
<span class="w"> </span>from pylint.utils import LinterStats
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter
<span class="w"> </span>    from pylint.reporters.ureports.nodes import Section
<span class="gu">@@ -15,34 +22,43 @@ class BaseReporter:</span>

<span class="w"> </span>    symbols: show short symbolic names for messages.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    extension = &#39;&#39;</span>
<span class="gd">-    name = &#39;base&#39;</span>
<span class="gi">+</span>
<span class="gi">+    extension = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;base&quot;</span>
<span class="w"> </span>    &quot;&quot;&quot;Name of the reporter.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, output: (TextIO | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, output: TextIO | None = None) -&gt; None:</span>
<span class="w"> </span>        self.linter: PyLinter
<span class="w"> </span>        self.section = 0
<span class="w"> </span>        self.out: TextIO = output or sys.stdout
<span class="w"> </span>        self.messages: list[Message] = []
<span class="gi">+        # Build the path prefix to strip to get relative paths</span>
<span class="w"> </span>        self.path_strip_prefix = os.getcwd() + os.sep

<span class="gd">-    def handle_message(self, msg: Message) -&gt;None:</span>
<span class="gi">+    def handle_message(self, msg: Message) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle a new message triggered on the current file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.messages.append(msg)</span>

<span class="gd">-    def writeln(self, string: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def writeln(self, string: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a line in the output buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        print(string, file=self.out)</span>

<span class="gd">-    def display_reports(self, layout: Section) -&gt;None:</span>
<span class="gi">+    def display_reports(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display results encapsulated in the layout tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.section = 0</span>
<span class="gi">+        if layout.report_id:</span>
<span class="gi">+            if isinstance(layout.children[0].children[0], Text):</span>
<span class="gi">+                layout.children[0].children[0].data += f&quot; ({layout.report_id})&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(f&quot;Incorrect child for {layout.children[0].children}&quot;)</span>
<span class="gi">+        self._display(layout)</span>

<span class="gd">-    def _display(self, layout: Section) -&gt;None:</span>
<span class="gi">+    def _display(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display the layout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError()</span>

<span class="gd">-    def display_messages(self, layout: (Section | None)) -&gt;None:</span>
<span class="gi">+    def display_messages(self, layout: Section | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Hook for displaying the messages of the reporter.

<span class="w"> </span>        This will be called whenever the underlying messages
<span class="gu">@@ -52,14 +68,15 @@ class BaseReporter:</span>
<span class="w"> </span>        This method can be implemented to display them after they&#39;ve
<span class="w"> </span>        been aggregated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def on_set_current_module(self, module: str, filepath: (str | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    # Event callbacks</span>
<span class="gi">+</span>
<span class="gi">+    def on_set_current_module(self, module: str, filepath: str | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Hook called when a module starts to be analysed.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def on_close(self, stats: LinterStats, previous_stats: (LinterStats | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def on_close(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stats: LinterStats,</span>
<span class="gi">+        previous_stats: LinterStats | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Hook called when a module finished analyzing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gh">diff --git a/pylint/reporters/collecting_reporter.py b/pylint/reporters/collecting_reporter.py</span>
<span class="gh">index fffdba810..943a74d55 100644</span>
<span class="gd">--- a/pylint/reporters/collecting_reporter.py</span>
<span class="gi">+++ b/pylint/reporters/collecting_reporter.py</span>
<span class="gu">@@ -1,14 +1,28 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from pylint.reporters.base_reporter import BaseReporter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.reporters.ureports.nodes import Section


<span class="w"> </span>class CollectingReporter(BaseReporter):
<span class="w"> </span>    &quot;&quot;&quot;Collects messages.&quot;&quot;&quot;
<span class="gd">-    name = &#39;collector&#39;</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    name = &quot;collector&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.messages = []
<span class="gi">+</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self.messages = []</span>
<span class="gi">+</span>
<span class="gi">+    def _display(self, layout: Section) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gh">diff --git a/pylint/reporters/json_reporter.py b/pylint/reporters/json_reporter.py</span>
<span class="gh">index ddf8abc09..7135dfc66 100644</span>
<span class="gd">--- a/pylint/reporters/json_reporter.py</span>
<span class="gi">+++ b/pylint/reporters/json_reporter.py</span>
<span class="gu">@@ -1,18 +1,40 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;JSON reporter.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>from typing import TYPE_CHECKING, Optional, TypedDict
<span class="gi">+</span>
<span class="w"> </span>from pylint.interfaces import CONFIDENCE_MAP, UNDEFINED
<span class="w"> </span>from pylint.message import Message
<span class="w"> </span>from pylint.reporters.base_reporter import BaseReporter
<span class="w"> </span>from pylint.typing import MessageLocationTuple
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter
<span class="w"> </span>    from pylint.reporters.ureports.nodes import Section
<span class="gd">-OldJsonExport = TypedDict(&#39;OldJsonExport&#39;, {&#39;type&#39;: str, &#39;module&#39;: str,</span>
<span class="gd">-    &#39;obj&#39;: str, &#39;line&#39;: int, &#39;column&#39;: int, &#39;endLine&#39;: Optional[int],</span>
<span class="gd">-    &#39;endColumn&#39;: Optional[int], &#39;path&#39;: str, &#39;symbol&#39;: str, &#39;message&#39;: str,</span>
<span class="gd">-    &#39;message-id&#39;: str})</span>
<span class="gi">+</span>
<span class="gi">+# Since message-id is an invalid name we need to use the alternative syntax</span>
<span class="gi">+OldJsonExport = TypedDict(</span>
<span class="gi">+    &quot;OldJsonExport&quot;,</span>
<span class="gi">+    {</span>
<span class="gi">+        &quot;type&quot;: str,</span>
<span class="gi">+        &quot;module&quot;: str,</span>
<span class="gi">+        &quot;obj&quot;: str,</span>
<span class="gi">+        &quot;line&quot;: int,</span>
<span class="gi">+        &quot;column&quot;: int,</span>
<span class="gi">+        &quot;endLine&quot;: Optional[int],</span>
<span class="gi">+        &quot;endColumn&quot;: Optional[int],</span>
<span class="gi">+        &quot;path&quot;: str,</span>
<span class="gi">+        &quot;symbol&quot;: str,</span>
<span class="gi">+        &quot;message&quot;: str,</span>
<span class="gi">+        &quot;message-id&quot;: str,</span>
<span class="gi">+    },</span>
<span class="gi">+)</span>


<span class="w"> </span>class JSONReporter(BaseReporter):
<span class="gu">@@ -21,20 +43,55 @@ class JSONReporter(BaseReporter):</span>
<span class="w"> </span>    Consider using JSON2Reporter instead, as it is superior and this reporter
<span class="w"> </span>    is no longer maintained.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;json&#39;</span>
<span class="gd">-    extension = &#39;json&#39;</span>

<span class="gd">-    def display_messages(self, layout: (Section | None)) -&gt;None:</span>
<span class="gi">+    name = &quot;json&quot;</span>
<span class="gi">+    extension = &quot;json&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def display_messages(self, layout: Section | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Launch layouts display.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_dumpable = [self.serialize(message) for message in self.messages]</span>
<span class="gi">+        print(json.dumps(json_dumpable, indent=4), file=self.out)</span>

<span class="gd">-    def display_reports(self, layout: Section) -&gt;None:</span>
<span class="gi">+    def display_reports(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Don&#39;t do anything in this reporter.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _display(self, layout: Section) -&gt;None:</span>
<span class="gi">+    def _display(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do nothing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def serialize(message: Message) -&gt; OldJsonExport:</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;type&quot;: message.category,</span>
<span class="gi">+            &quot;module&quot;: message.module,</span>
<span class="gi">+            &quot;obj&quot;: message.obj,</span>
<span class="gi">+            &quot;line&quot;: message.line,</span>
<span class="gi">+            &quot;column&quot;: message.column,</span>
<span class="gi">+            &quot;endLine&quot;: message.end_line,</span>
<span class="gi">+            &quot;endColumn&quot;: message.end_column,</span>
<span class="gi">+            &quot;path&quot;: message.path,</span>
<span class="gi">+            &quot;symbol&quot;: message.symbol,</span>
<span class="gi">+            &quot;message&quot;: message.msg or &quot;&quot;,</span>
<span class="gi">+            &quot;message-id&quot;: message.msg_id,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def deserialize(message_as_json: OldJsonExport) -&gt; Message:</span>
<span class="gi">+        return Message(</span>
<span class="gi">+            msg_id=message_as_json[&quot;message-id&quot;],</span>
<span class="gi">+            symbol=message_as_json[&quot;symbol&quot;],</span>
<span class="gi">+            msg=message_as_json[&quot;message&quot;],</span>
<span class="gi">+            location=MessageLocationTuple(</span>
<span class="gi">+                abspath=message_as_json[&quot;path&quot;],</span>
<span class="gi">+                path=message_as_json[&quot;path&quot;],</span>
<span class="gi">+                module=message_as_json[&quot;module&quot;],</span>
<span class="gi">+                obj=message_as_json[&quot;obj&quot;],</span>
<span class="gi">+                line=message_as_json[&quot;line&quot;],</span>
<span class="gi">+                column=message_as_json[&quot;column&quot;],</span>
<span class="gi">+                end_line=message_as_json[&quot;endLine&quot;],</span>
<span class="gi">+                end_column=message_as_json[&quot;endColumn&quot;],</span>
<span class="gi">+            ),</span>
<span class="gi">+            confidence=UNDEFINED,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class JSONMessage(TypedDict):
<span class="gu">@@ -54,21 +111,91 @@ class JSONMessage(TypedDict):</span>


<span class="w"> </span>class JSON2Reporter(BaseReporter):
<span class="gd">-    name = &#39;json2&#39;</span>
<span class="gd">-    extension = &#39;json2&#39;</span>
<span class="gi">+    name = &quot;json2&quot;</span>
<span class="gi">+    extension = &quot;json2&quot;</span>

<span class="gd">-    def display_reports(self, layout: Section) -&gt;None:</span>
<span class="gi">+    def display_reports(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Don&#39;t do anything in this reporter.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _display(self, layout: Section) -&gt;None:</span>
<span class="gi">+    def _display(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Do nothing.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def display_messages(self, layout: (Section | None)) -&gt;None:</span>
<span class="gi">+    def display_messages(self, layout: Section | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Launch layouts display.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        output = {</span>
<span class="gi">+            &quot;messages&quot;: [self.serialize(message) for message in self.messages],</span>
<span class="gi">+            &quot;statistics&quot;: self.serialize_stats(),</span>
<span class="gi">+        }</span>
<span class="gi">+        print(json.dumps(output, indent=4), file=self.out)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def serialize(message: Message) -&gt; JSONMessage:</span>
<span class="gi">+        return JSONMessage(</span>
<span class="gi">+            type=message.category,</span>
<span class="gi">+            symbol=message.symbol,</span>
<span class="gi">+            message=message.msg or &quot;&quot;,</span>
<span class="gi">+            messageId=message.msg_id,</span>
<span class="gi">+            confidence=message.confidence.name,</span>
<span class="gi">+            module=message.module,</span>
<span class="gi">+            obj=message.obj,</span>
<span class="gi">+            line=message.line,</span>
<span class="gi">+            column=message.column,</span>
<span class="gi">+            endLine=message.end_line,</span>
<span class="gi">+            endColumn=message.end_column,</span>
<span class="gi">+            path=message.path,</span>
<span class="gi">+            absolutePath=message.abspath,</span>
<span class="gi">+        )</span>

<span class="gd">-    def serialize_stats(self) -&gt;dict[str, str | int | dict[str, int]]:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def deserialize(message_as_json: JSONMessage) -&gt; Message:</span>
<span class="gi">+        return Message(</span>
<span class="gi">+            msg_id=message_as_json[&quot;messageId&quot;],</span>
<span class="gi">+            symbol=message_as_json[&quot;symbol&quot;],</span>
<span class="gi">+            msg=message_as_json[&quot;message&quot;],</span>
<span class="gi">+            location=MessageLocationTuple(</span>
<span class="gi">+                abspath=message_as_json[&quot;absolutePath&quot;],</span>
<span class="gi">+                path=message_as_json[&quot;path&quot;],</span>
<span class="gi">+                module=message_as_json[&quot;module&quot;],</span>
<span class="gi">+                obj=message_as_json[&quot;obj&quot;],</span>
<span class="gi">+                line=message_as_json[&quot;line&quot;],</span>
<span class="gi">+                column=message_as_json[&quot;column&quot;],</span>
<span class="gi">+                end_line=message_as_json[&quot;endLine&quot;],</span>
<span class="gi">+                end_column=message_as_json[&quot;endColumn&quot;],</span>
<span class="gi">+            ),</span>
<span class="gi">+            confidence=CONFIDENCE_MAP[message_as_json[&quot;confidence&quot;]],</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def serialize_stats(self) -&gt; dict[str, str | int | dict[str, int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Serialize the linter stats into something JSON dumpable.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        stats = self.linter.stats</span>
<span class="gi">+</span>
<span class="gi">+        counts_dict = {</span>
<span class="gi">+            &quot;fatal&quot;: stats.fatal,</span>
<span class="gi">+            &quot;error&quot;: stats.error,</span>
<span class="gi">+            &quot;warning&quot;: stats.warning,</span>
<span class="gi">+            &quot;refactor&quot;: stats.refactor,</span>
<span class="gi">+            &quot;convention&quot;: stats.convention,</span>
<span class="gi">+            &quot;info&quot;: stats.info,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # Calculate score based on the evaluation option</span>
<span class="gi">+        evaluation = self.linter.config.evaluation</span>
<span class="gi">+        try:</span>
<span class="gi">+            note: int = eval(  # pylint: disable=eval-used</span>
<span class="gi">+                evaluation, {}, {**counts_dict, &quot;statement&quot;: stats.statement or 1}</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception as ex:  # pylint: disable=broad-except</span>
<span class="gi">+            score: str | int = f&quot;An exception occurred while rating: {ex}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            score = round(note, 2)</span>
<span class="gi">+</span>
<span class="gi">+        return {</span>
<span class="gi">+            &quot;messageTypeCount&quot;: counts_dict,</span>
<span class="gi">+            &quot;modulesLinted&quot;: len(stats.by_module),</span>
<span class="gi">+            &quot;score&quot;: score,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_reporter(JSONReporter)</span>
<span class="gi">+    linter.register_reporter(JSON2Reporter)</span>
<span class="gh">diff --git a/pylint/reporters/multi_reporter.py b/pylint/reporters/multi_reporter.py</span>
<span class="gh">index 933044920..0c27293b7 100644</span>
<span class="gd">--- a/pylint/reporters/multi_reporter.py</span>
<span class="gi">+++ b/pylint/reporters/multi_reporter.py</span>
<span class="gu">@@ -1,11 +1,18 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from collections.abc import Callable
<span class="w"> </span>from copy import copy
<span class="w"> </span>from typing import TYPE_CHECKING, TextIO
<span class="gi">+</span>
<span class="w"> </span>from pylint.message import Message
<span class="w"> </span>from pylint.reporters.base_reporter import BaseReporter
<span class="w"> </span>from pylint.utils import LinterStats
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="w"> </span>    from pylint.reporters.ureports.nodes import Section
<span class="gu">@@ -13,11 +20,22 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>class MultiReporter:
<span class="w"> </span>    &quot;&quot;&quot;Reports messages and layouts in plain text.&quot;&quot;&quot;
<span class="gd">-    name = &#39;_internal_multi_reporter&#39;</span>
<span class="gd">-    extension = &#39;&#39;</span>

<span class="gd">-    def __init__(self, sub_reporters: list[BaseReporter],</span>
<span class="gd">-        close_output_files: Callable[[], None], output: (TextIO | None)=None):</span>
<span class="gi">+    name = &quot;_internal_multi_reporter&quot;</span>
<span class="gi">+    # Note: do not register this reporter with linter.register_reporter as it is</span>
<span class="gi">+    #       not intended to be used directly like a regular reporter, but is</span>
<span class="gi">+    #       instead used to implement the</span>
<span class="gi">+    #       `--output-format=json:somefile.json,colorized`</span>
<span class="gi">+    #       multiple output formats feature</span>
<span class="gi">+</span>
<span class="gi">+    extension = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        sub_reporters: list[BaseReporter],</span>
<span class="gi">+        close_output_files: Callable[[], None],</span>
<span class="gi">+        output: TextIO | None = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self._sub_reporters = sub_reporters
<span class="w"> </span>        self.close_output_files = close_output_files
<span class="w"> </span>        self._path_strip_prefix = os.getcwd() + os.sep
<span class="gu">@@ -25,40 +43,69 @@ class MultiReporter:</span>
<span class="w"> </span>        self.out = output
<span class="w"> </span>        self.messages: list[Message] = []

<span class="gi">+    @property</span>
<span class="gi">+    def out(self) -&gt; TextIO | None:</span>
<span class="gi">+        return self.__out</span>
<span class="gi">+</span>
<span class="w"> </span>    @out.setter
<span class="gd">-    def out(self, output: (TextIO | None)=None) -&gt;None:</span>
<span class="gi">+    def out(self, output: TextIO | None = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;MultiReporter doesn&#39;t have its own output.

<span class="w"> </span>        This method is only provided for API parity with BaseReporter
<span class="w"> </span>        and should not be called with non-None values for &#39;output&#39;.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.__out = None</span>
<span class="gi">+        if output is not None:</span>
<span class="gi">+            raise NotImplementedError(&quot;MultiReporter does not support direct output.&quot;)</span>

<span class="gd">-    def __del__(self) -&gt;None:</span>
<span class="gi">+    def __del__(self) -&gt; None:</span>
<span class="w"> </span>        self.close_output_files()

<span class="gd">-    def handle_message(self, msg: Message) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def path_strip_prefix(self) -&gt; str:</span>
<span class="gi">+        return self._path_strip_prefix</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def linter(self) -&gt; PyLinter | None:</span>
<span class="gi">+        return self._linter</span>
<span class="gi">+</span>
<span class="gi">+    @linter.setter</span>
<span class="gi">+    def linter(self, value: PyLinter) -&gt; None:</span>
<span class="gi">+        self._linter = value</span>
<span class="gi">+        for rep in self._sub_reporters:</span>
<span class="gi">+            rep.linter = value</span>
<span class="gi">+</span>
<span class="gi">+    def handle_message(self, msg: Message) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle a new message triggered on the current file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rep in self._sub_reporters:</span>
<span class="gi">+            # We provide a copy so reporters can&#39;t modify message for others.</span>
<span class="gi">+            rep.handle_message(copy(msg))</span>

<span class="gd">-    def writeln(self, string: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def writeln(self, string: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a line in the output buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rep in self._sub_reporters:</span>
<span class="gi">+            rep.writeln(string)</span>

<span class="gd">-    def display_reports(self, layout: Section) -&gt;None:</span>
<span class="gi">+    def display_reports(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display results encapsulated in the layout tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rep in self._sub_reporters:</span>
<span class="gi">+            rep.display_reports(layout)</span>

<span class="gd">-    def display_messages(self, layout: (Section | None)) -&gt;None:</span>
<span class="gi">+    def display_messages(self, layout: Section | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Hook for displaying the messages of the reporter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rep in self._sub_reporters:</span>
<span class="gi">+            rep.display_messages(layout)</span>

<span class="gd">-    def on_set_current_module(self, module: str, filepath: (str | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def on_set_current_module(self, module: str, filepath: str | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Hook called when a module starts to be analysed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rep in self._sub_reporters:</span>
<span class="gi">+            rep.on_set_current_module(module, filepath)</span>

<span class="gd">-    def on_close(self, stats: LinterStats, previous_stats: (LinterStats | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def on_close(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stats: LinterStats,</span>
<span class="gi">+        previous_stats: LinterStats | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Hook called when a module finished analyzing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for rep in self._sub_reporters:</span>
<span class="gi">+            rep.on_close(stats, previous_stats)</span>
<span class="gh">diff --git a/pylint/reporters/reports_handler_mix_in.py b/pylint/reporters/reports_handler_mix_in.py</span>
<span class="gh">index c68428765..95d45ba91 100644</span>
<span class="gd">--- a/pylint/reporters/reports_handler_mix_in.py</span>
<span class="gi">+++ b/pylint/reporters/reports_handler_mix_in.py</span>
<span class="gu">@@ -1,16 +1,23 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>from collections.abc import MutableSequence
<span class="w"> </span>from typing import TYPE_CHECKING, DefaultDict, List, Tuple
<span class="gi">+</span>
<span class="w"> </span>from pylint.exceptions import EmptyReportError
<span class="w"> </span>from pylint.reporters.ureports.nodes import Section
<span class="w"> </span>from pylint.typing import ReportsCallable
<span class="w"> </span>from pylint.utils import LinterStats
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.checkers import BaseChecker
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter
<span class="gd">-ReportsDict = DefaultDict[&#39;BaseChecker&#39;, List[Tuple[str, str, ReportsCallable]]</span>
<span class="gd">-    ]</span>
<span class="gi">+</span>
<span class="gi">+ReportsDict = DefaultDict[&quot;BaseChecker&quot;, List[Tuple[str, str, ReportsCallable]]]</span>


<span class="w"> </span>class ReportsHandlerMixIn:
<span class="gu">@@ -18,16 +25,17 @@ class ReportsHandlerMixIn:</span>
<span class="w"> </span>    related methods for the main lint class.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._reports: ReportsDict = collections.defaultdict(list)
<span class="w"> </span>        self._reports_state: dict[str, bool] = {}

<span class="gd">-    def report_order(self) -&gt;MutableSequence[BaseChecker]:</span>
<span class="gi">+    def report_order(self) -&gt; MutableSequence[BaseChecker]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of reporters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self._reports)</span>

<span class="gd">-    def register_report(self, reportid: str, r_title: str, r_cb:</span>
<span class="gd">-        ReportsCallable, checker: BaseChecker) -&gt;None:</span>
<span class="gi">+    def register_report(</span>
<span class="gi">+        self, reportid: str, r_title: str, r_cb: ReportsCallable, checker: BaseChecker</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a report.

<span class="w"> </span>        :param reportid: The unique identifier for the report
<span class="gu">@@ -35,21 +43,39 @@ class ReportsHandlerMixIn:</span>
<span class="w"> </span>        :param r_cb: The method to call to make the report
<span class="w"> </span>        :param checker: The checker defining the report
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        reportid = reportid.upper()</span>
<span class="gi">+        self._reports[checker].append((reportid, r_title, r_cb))</span>

<span class="gd">-    def enable_report(self, reportid: str) -&gt;None:</span>
<span class="gi">+    def enable_report(self, reportid: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Enable the report of the given id.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        reportid = reportid.upper()</span>
<span class="gi">+        self._reports_state[reportid] = True</span>

<span class="gd">-    def disable_report(self, reportid: str) -&gt;None:</span>
<span class="gi">+    def disable_report(self, reportid: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Disable the report of the given id.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        reportid = reportid.upper()</span>
<span class="gi">+        self._reports_state[reportid] = False</span>

<span class="gd">-    def report_is_enabled(self, reportid: str) -&gt;bool:</span>
<span class="gi">+    def report_is_enabled(self, reportid: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Is the report associated to the given identifier enabled ?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._reports_state.get(reportid, True)</span>

<span class="gd">-    def make_reports(self: PyLinter, stats: LinterStats, old_stats: (</span>
<span class="gd">-        LinterStats | None)) -&gt;Section:</span>
<span class="gi">+    def make_reports(  # type: ignore[misc] # ReportsHandlerMixIn is always mixed with PyLinter</span>
<span class="gi">+        self: PyLinter,</span>
<span class="gi">+        stats: LinterStats,</span>
<span class="gi">+        old_stats: LinterStats | None,</span>
<span class="gi">+    ) -&gt; Section:</span>
<span class="w"> </span>        &quot;&quot;&quot;Render registered reports.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sect = Section(&quot;Report&quot;, f&quot;{self.stats.statement} statements analysed.&quot;)</span>
<span class="gi">+        for checker in self.report_order():</span>
<span class="gi">+            for reportid, r_title, r_cb in self._reports[checker]:</span>
<span class="gi">+                if not self.report_is_enabled(reportid):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                report_sect = Section(r_title)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    r_cb(report_sect, stats, old_stats)</span>
<span class="gi">+                except EmptyReportError:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                report_sect.report_id = reportid</span>
<span class="gi">+                sect.append(report_sect)</span>
<span class="gi">+        return sect</span>
<span class="gh">diff --git a/pylint/reporters/text.py b/pylint/reporters/text.py</span>
<span class="gh">index 913080584..0e3577199 100644</span>
<span class="gd">--- a/pylint/reporters/text.py</span>
<span class="gi">+++ b/pylint/reporters/text.py</span>
<span class="gu">@@ -1,18 +1,26 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Plain text reporters:.

<span class="w"> </span>:text: the default one grouping messages by module
<span class="w"> </span>:colorized: an ANSI colorized text reporter
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from dataclasses import asdict, fields
<span class="w"> </span>from typing import TYPE_CHECKING, Dict, NamedTuple, TextIO
<span class="gi">+</span>
<span class="w"> </span>from pylint.message import Message
<span class="w"> </span>from pylint.reporters import BaseReporter
<span class="w"> </span>from pylint.reporters.ureports.text_writer import TextWriter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="w"> </span>    from pylint.reporters.ureports.nodes import Section
<span class="gu">@@ -20,6 +28,7 @@ if TYPE_CHECKING:</span>

<span class="w"> </span>class MessageStyle(NamedTuple):
<span class="w"> </span>    &quot;&quot;&quot;Styling of a message.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    color: str | None
<span class="w"> </span>    &quot;&quot;&quot;The color name (see `ANSI_COLORS` for available values)
<span class="w"> </span>    or the color number when 256 colors are available.
<span class="gu">@@ -27,74 +36,146 @@ class MessageStyle(NamedTuple):</span>
<span class="w"> </span>    style: tuple[str, ...] = ()
<span class="w"> </span>    &quot;&quot;&quot;Tuple of style strings (see `ANSI_COLORS` for available values).&quot;&quot;&quot;

<span class="gd">-    def __get_ansi_code(self) -&gt;str:</span>
<span class="gi">+    def __get_ansi_code(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return ANSI escape code corresponding to color and style.

<span class="w"> </span>        :raise KeyError: if a nonexistent color or style identifier is given

<span class="w"> </span>        :return: the built escape code
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ansi_code = [ANSI_STYLES[effect] for effect in self.style]</span>
<span class="gi">+        if self.color:</span>
<span class="gi">+            if self.color.isdigit():</span>
<span class="gi">+                ansi_code.extend([&quot;38&quot;, &quot;5&quot;])</span>
<span class="gi">+                ansi_code.append(self.color)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ansi_code.append(ANSI_COLORS[self.color])</span>
<span class="gi">+        if ansi_code:</span>
<span class="gi">+            return ANSI_PREFIX + &quot;;&quot;.join(ansi_code) + ANSI_END</span>
<span class="gi">+        return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _colorize_ansi(self, msg: str) -&gt; str:</span>
<span class="gi">+        if self.color is None and len(self.style) == 0:</span>
<span class="gi">+            # If both color and style are not defined, then leave the text as is.</span>
<span class="gi">+            return msg</span>
<span class="gi">+        escape_code = self.__get_ansi_code()</span>
<span class="gi">+        # If invalid (or unknown) color, don&#39;t wrap msg with ANSI codes</span>
<span class="gi">+        if escape_code:</span>
<span class="gi">+            return f&quot;{escape_code}{msg}{ANSI_RESET}&quot;</span>
<span class="gi">+        return msg</span>


<span class="w"> </span>ColorMappingDict = Dict[str, MessageStyle]
<span class="gd">-TITLE_UNDERLINES = [&#39;&#39;, &#39;=&#39;, &#39;-&#39;, &#39;.&#39;]</span>
<span class="gd">-ANSI_PREFIX = &#39;\x1b[&#39;</span>
<span class="gd">-ANSI_END = &#39;m&#39;</span>
<span class="gd">-ANSI_RESET = &#39;\x1b[0m&#39;</span>
<span class="gd">-ANSI_STYLES = {&#39;reset&#39;: &#39;0&#39;, &#39;bold&#39;: &#39;1&#39;, &#39;italic&#39;: &#39;3&#39;, &#39;underline&#39;: &#39;4&#39;,</span>
<span class="gd">-    &#39;blink&#39;: &#39;5&#39;, &#39;inverse&#39;: &#39;7&#39;, &#39;strike&#39;: &#39;9&#39;}</span>
<span class="gd">-ANSI_COLORS = {&#39;reset&#39;: &#39;0&#39;, &#39;black&#39;: &#39;30&#39;, &#39;red&#39;: &#39;31&#39;, &#39;green&#39;: &#39;32&#39;,</span>
<span class="gd">-    &#39;yellow&#39;: &#39;33&#39;, &#39;blue&#39;: &#39;34&#39;, &#39;magenta&#39;: &#39;35&#39;, &#39;cyan&#39;: &#39;36&#39;, &#39;white&#39;: &#39;37&#39;}</span>
<span class="gi">+</span>
<span class="gi">+TITLE_UNDERLINES = [&quot;&quot;, &quot;=&quot;, &quot;-&quot;, &quot;.&quot;]</span>
<span class="gi">+</span>
<span class="gi">+ANSI_PREFIX = &quot;\033[&quot;</span>
<span class="gi">+ANSI_END = &quot;m&quot;</span>
<span class="gi">+ANSI_RESET = &quot;\033[0m&quot;</span>
<span class="gi">+ANSI_STYLES = {</span>
<span class="gi">+    &quot;reset&quot;: &quot;0&quot;,</span>
<span class="gi">+    &quot;bold&quot;: &quot;1&quot;,</span>
<span class="gi">+    &quot;italic&quot;: &quot;3&quot;,</span>
<span class="gi">+    &quot;underline&quot;: &quot;4&quot;,</span>
<span class="gi">+    &quot;blink&quot;: &quot;5&quot;,</span>
<span class="gi">+    &quot;inverse&quot;: &quot;7&quot;,</span>
<span class="gi">+    &quot;strike&quot;: &quot;9&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+ANSI_COLORS = {</span>
<span class="gi">+    &quot;reset&quot;: &quot;0&quot;,</span>
<span class="gi">+    &quot;black&quot;: &quot;30&quot;,</span>
<span class="gi">+    &quot;red&quot;: &quot;31&quot;,</span>
<span class="gi">+    &quot;green&quot;: &quot;32&quot;,</span>
<span class="gi">+    &quot;yellow&quot;: &quot;33&quot;,</span>
<span class="gi">+    &quot;blue&quot;: &quot;34&quot;,</span>
<span class="gi">+    &quot;magenta&quot;: &quot;35&quot;,</span>
<span class="gi">+    &quot;cyan&quot;: &quot;36&quot;,</span>
<span class="gi">+    &quot;white&quot;: &quot;37&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>MESSAGE_FIELDS = {i.name for i in fields(Message)}
<span class="w"> </span>&quot;&quot;&quot;All fields of the Message class.&quot;&quot;&quot;


<span class="gd">-def colorize_ansi(msg: str, msg_style: MessageStyle) -&gt;str:</span>
<span class="gi">+def colorize_ansi(msg: str, msg_style: MessageStyle) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Colorize message by wrapping it with ANSI escape codes.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return msg_style._colorize_ansi(msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_header(msg: Message) -&gt; str:</span>
<span class="gi">+    return f&quot;************* Module {msg.module}&quot;</span>


<span class="w"> </span>class TextReporter(BaseReporter):
<span class="w"> </span>    &quot;&quot;&quot;Reports messages and layouts in plain text.&quot;&quot;&quot;
<span class="gd">-    name = &#39;text&#39;</span>
<span class="gd">-    extension = &#39;txt&#39;</span>
<span class="gd">-    line_format = &#39;{path}:{line}:{column}: {msg_id}: {msg} ({symbol})&#39;</span>

<span class="gd">-    def __init__(self, output: (TextIO | None)=None) -&gt;None:</span>
<span class="gi">+    name = &quot;text&quot;</span>
<span class="gi">+    extension = &quot;txt&quot;</span>
<span class="gi">+    line_format = &quot;{path}:{line}:{column}: {msg_id}: {msg} ({symbol})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, output: TextIO | None = None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(output)
<span class="w"> </span>        self._modules: set[str] = set()
<span class="w"> </span>        self._template = self.line_format
<span class="w"> </span>        self._fixed_template = self.line_format
<span class="w"> </span>        &quot;&quot;&quot;The output format template with any unrecognized arguments removed.&quot;&quot;&quot;

<span class="gd">-    def on_set_current_module(self, module: str, filepath: (str | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def on_set_current_module(self, module: str, filepath: str | None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the format template to be used and check for unrecognized arguments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def write_message(self, msg: Message) -&gt;None:</span>
<span class="gi">+        template = str(self.linter.config.msg_template or self._template)</span>
<span class="gi">+</span>
<span class="gi">+        # Return early if the template is the same as the previous one</span>
<span class="gi">+        if template == self._template:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Set template to the currently selected template</span>
<span class="gi">+        self._template = template</span>
<span class="gi">+</span>
<span class="gi">+        # Check to see if all parameters in the template are attributes of the Message</span>
<span class="gi">+        arguments = re.findall(r&quot;\{(\w+?)(:.*)?\}&quot;, template)</span>
<span class="gi">+        for argument in arguments:</span>
<span class="gi">+            if argument[0] not in MESSAGE_FIELDS:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&quot;Don&#39;t recognize the argument &#39;{argument[0]}&#39; in the --msg-template. &quot;</span>
<span class="gi">+                    &quot;Are you sure it is supported on the current version of pylint?&quot;,</span>
<span class="gi">+                    stacklevel=2,</span>
<span class="gi">+                )</span>
<span class="gi">+                template = re.sub(r&quot;\{&quot; + argument[0] + r&quot;(:.*?)?\}&quot;, &quot;&quot;, template)</span>
<span class="gi">+        self._fixed_template = template</span>
<span class="gi">+</span>
<span class="gi">+    def write_message(self, msg: Message) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convenience method to write a formatted message with class default
<span class="w"> </span>        template.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self_dict = asdict(msg)</span>
<span class="gi">+        for key in (&quot;end_line&quot;, &quot;end_column&quot;):</span>
<span class="gi">+            self_dict[key] = self_dict[key] or &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self.writeln(self._fixed_template.format(**self_dict))</span>

<span class="gd">-    def handle_message(self, msg: Message) -&gt;None:</span>
<span class="gi">+    def handle_message(self, msg: Message) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Manage message of different type and in the context of path.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msg.module not in self._modules:</span>
<span class="gi">+            self.writeln(make_header(msg))</span>
<span class="gi">+            self._modules.add(msg.module)</span>
<span class="gi">+        self.write_message(msg)</span>

<span class="gd">-    def _display(self, layout: Section) -&gt;None:</span>
<span class="gi">+    def _display(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Launch layouts display.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        print(file=self.out)</span>
<span class="gi">+        TextWriter().format(layout, self.out)</span>


<span class="w"> </span>class NoHeaderReporter(TextReporter):
<span class="w"> </span>    &quot;&quot;&quot;Reports messages and layouts in plain text without a module header.&quot;&quot;&quot;
<span class="gd">-    name = &#39;no-header&#39;</span>

<span class="gd">-    def handle_message(self, msg: Message) -&gt;None:</span>
<span class="gi">+    name = &quot;no-header&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def handle_message(self, msg: Message) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write message(s) without module header.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msg.module not in self._modules:</span>
<span class="gi">+            self._modules.add(msg.module)</span>
<span class="gi">+        self.write_message(msg)</span>


<span class="w"> </span>class ParseableTextReporter(TextReporter):
<span class="gu">@@ -103,60 +184,106 @@ class ParseableTextReporter(TextReporter):</span>

<span class="w"> </span>    &lt;filename&gt;:&lt;linenum&gt;:&lt;msg&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;parseable&#39;</span>
<span class="gd">-    line_format = &#39;{path}:{line}: [{msg_id}({symbol}), {obj}] {msg}&#39;</span>

<span class="gd">-    def __init__(self, output: (TextIO | None)=None) -&gt;None:</span>
<span class="gi">+    name = &quot;parseable&quot;</span>
<span class="gi">+    line_format = &quot;{path}:{line}: [{msg_id}({symbol}), {obj}] {msg}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, output: TextIO | None = None) -&gt; None:</span>
<span class="w"> </span>        warnings.warn(
<span class="gd">-            f&#39;{self.name} output format is deprecated. This is equivalent to --msg-template={self.line_format}&#39;</span>
<span class="gd">-            , DeprecationWarning, stacklevel=2)</span>
<span class="gi">+            f&quot;{self.name} output format is deprecated. This is equivalent to --msg-template={self.line_format}&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        super().__init__(output)


<span class="w"> </span>class VSTextReporter(ParseableTextReporter):
<span class="w"> </span>    &quot;&quot;&quot;Visual studio text reporter.&quot;&quot;&quot;
<span class="gd">-    name = &#39;msvs&#39;</span>
<span class="gd">-    line_format = &#39;{path}({line}): [{msg_id}({symbol}){obj}] {msg}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;msvs&quot;</span>
<span class="gi">+    line_format = &quot;{path}({line}): [{msg_id}({symbol}){obj}] {msg}&quot;</span>


<span class="w"> </span>class ColorizedTextReporter(TextReporter):
<span class="w"> </span>    &quot;&quot;&quot;Simple TextReporter that colorizes text output.&quot;&quot;&quot;
<span class="gd">-    name = &#39;colorized&#39;</span>
<span class="gd">-    COLOR_MAPPING: ColorMappingDict = {&#39;I&#39;: MessageStyle(&#39;green&#39;), &#39;C&#39;:</span>
<span class="gd">-        MessageStyle(None, (&#39;bold&#39;,)), &#39;R&#39;: MessageStyle(&#39;magenta&#39;, (&#39;bold&#39;,</span>
<span class="gd">-        &#39;italic&#39;)), &#39;W&#39;: MessageStyle(&#39;magenta&#39;), &#39;E&#39;: MessageStyle(&#39;red&#39;,</span>
<span class="gd">-        (&#39;bold&#39;,)), &#39;F&#39;: MessageStyle(&#39;red&#39;, (&#39;bold&#39;, &#39;underline&#39;)), &#39;S&#39;:</span>
<span class="gd">-        MessageStyle(&#39;yellow&#39;, (&#39;inverse&#39;,))}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, output: (TextIO | None)=None, color_mapping: (</span>
<span class="gd">-        ColorMappingDict | None)=None) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;colorized&quot;</span>
<span class="gi">+    COLOR_MAPPING: ColorMappingDict = {</span>
<span class="gi">+        &quot;I&quot;: MessageStyle(&quot;green&quot;),</span>
<span class="gi">+        &quot;C&quot;: MessageStyle(None, (&quot;bold&quot;,)),</span>
<span class="gi">+        &quot;R&quot;: MessageStyle(&quot;magenta&quot;, (&quot;bold&quot;, &quot;italic&quot;)),</span>
<span class="gi">+        &quot;W&quot;: MessageStyle(&quot;magenta&quot;),</span>
<span class="gi">+        &quot;E&quot;: MessageStyle(&quot;red&quot;, (&quot;bold&quot;,)),</span>
<span class="gi">+        &quot;F&quot;: MessageStyle(&quot;red&quot;, (&quot;bold&quot;, &quot;underline&quot;)),</span>
<span class="gi">+        &quot;S&quot;: MessageStyle(&quot;yellow&quot;, (&quot;inverse&quot;,)),  # S stands for module Separator</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        output: TextIO | None = None,</span>
<span class="gi">+        color_mapping: ColorMappingDict | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(output)
<span class="gd">-        self.color_mapping = (color_mapping or ColorizedTextReporter.</span>
<span class="gd">-            COLOR_MAPPING)</span>
<span class="gd">-        ansi_terms = [&#39;xterm-16color&#39;, &#39;xterm-256color&#39;]</span>
<span class="gd">-        if os.environ.get(&#39;TERM&#39;) not in ansi_terms:</span>
<span class="gd">-            if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        self.color_mapping = color_mapping or ColorizedTextReporter.COLOR_MAPPING</span>
<span class="gi">+        ansi_terms = [&quot;xterm-16color&quot;, &quot;xterm-256color&quot;]</span>
<span class="gi">+        if os.environ.get(&quot;TERM&quot;) not in ansi_terms:</span>
<span class="gi">+            if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+                # pylint: disable=import-outside-toplevel</span>
<span class="w"> </span>                import colorama
<span class="gi">+</span>
<span class="w"> </span>                self.out = colorama.AnsiToWin32(self.out)

<span class="gd">-    def _get_decoration(self, msg_id: str) -&gt;MessageStyle:</span>
<span class="gi">+    def _get_decoration(self, msg_id: str) -&gt; MessageStyle:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the message style as defined in self.color_mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.color_mapping.get(msg_id[0]) or MessageStyle(None)</span>

<span class="gd">-    def handle_message(self, msg: Message) -&gt;None:</span>
<span class="gi">+    def handle_message(self, msg: Message) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Manage message of different types, and colorize output
<span class="w"> </span>        using ANSI escape codes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if msg.module not in self._modules:</span>
<span class="gi">+            msg_style = self._get_decoration(&quot;S&quot;)</span>
<span class="gi">+            modsep = colorize_ansi(make_header(msg), msg_style)</span>
<span class="gi">+            self.writeln(modsep)</span>
<span class="gi">+            self._modules.add(msg.module)</span>
<span class="gi">+        msg_style = self._get_decoration(msg.C)</span>
<span class="gi">+</span>
<span class="gi">+        msg.msg = colorize_ansi(msg.msg, msg_style)</span>
<span class="gi">+        msg.symbol = colorize_ansi(msg.symbol, msg_style)</span>
<span class="gi">+        msg.category = colorize_ansi(msg.category, msg_style)</span>
<span class="gi">+        msg.C = colorize_ansi(msg.C, msg_style)</span>
<span class="gi">+        self.write_message(msg)</span>


<span class="w"> </span>class GithubReporter(TextReporter):
<span class="w"> </span>    &quot;&quot;&quot;Report messages in GitHub&#39;s special format to annotate code in its user
<span class="w"> </span>    interface.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;github&#39;</span>
<span class="gd">-    line_format = (</span>
<span class="gd">-        &#39;::{category} file={path},line={line},endline={end_line},col={column},title={msg_id}::{msg}&#39;</span>
<span class="gd">-        )</span>
<span class="gd">-    category_map = {&#39;F&#39;: &#39;error&#39;, &#39;E&#39;: &#39;error&#39;, &#39;W&#39;: &#39;warning&#39;, &#39;C&#39;:</span>
<span class="gd">-        &#39;notice&#39;, &#39;R&#39;: &#39;notice&#39;, &#39;I&#39;: &#39;notice&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    name = &quot;github&quot;</span>
<span class="gi">+    line_format = &quot;::{category} file={path},line={line},endline={end_line},col={column},title={msg_id}::{msg}&quot;</span>
<span class="gi">+    category_map = {</span>
<span class="gi">+        &quot;F&quot;: &quot;error&quot;,</span>
<span class="gi">+        &quot;E&quot;: &quot;error&quot;,</span>
<span class="gi">+        &quot;W&quot;: &quot;warning&quot;,</span>
<span class="gi">+        &quot;C&quot;: &quot;notice&quot;,</span>
<span class="gi">+        &quot;R&quot;: &quot;notice&quot;,</span>
<span class="gi">+        &quot;I&quot;: &quot;notice&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def write_message(self, msg: Message) -&gt; None:</span>
<span class="gi">+        self_dict = asdict(msg)</span>
<span class="gi">+        for key in (&quot;end_line&quot;, &quot;end_column&quot;):</span>
<span class="gi">+            self_dict[key] = self_dict[key] or &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self_dict[&quot;category&quot;] = self.category_map.get(msg.C) or &quot;error&quot;</span>
<span class="gi">+        self.writeln(self._fixed_template.format(**self_dict))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register(linter: PyLinter) -&gt; None:</span>
<span class="gi">+    linter.register_reporter(TextReporter)</span>
<span class="gi">+    linter.register_reporter(NoHeaderReporter)</span>
<span class="gi">+    linter.register_reporter(ParseableTextReporter)</span>
<span class="gi">+    linter.register_reporter(VSTextReporter)</span>
<span class="gi">+    linter.register_reporter(ColorizedTextReporter)</span>
<span class="gi">+    linter.register_reporter(GithubReporter)</span>
<span class="gh">diff --git a/pylint/reporters/ureports/base_writer.py b/pylint/reporters/ureports/base_writer.py</span>
<span class="gh">index 8b1244c33..9a12123cb 100644</span>
<span class="gd">--- a/pylint/reporters/ureports/base_writer.py</span>
<span class="gi">+++ b/pylint/reporters/ureports/base_writer.py</span>
<span class="gu">@@ -1,64 +1,107 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Universal report objects and some formatting drivers.

<span class="w"> </span>A way to create simple reports using python objects, primarily designed to be
<span class="w"> </span>formatted as text and html.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from collections.abc import Iterator
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from typing import TYPE_CHECKING, TextIO
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from pylint.reporters.ureports.nodes import BaseLayout, EvaluationSection, Paragraph, Section, Table</span>
<span class="gi">+    from pylint.reporters.ureports.nodes import (</span>
<span class="gi">+        BaseLayout,</span>
<span class="gi">+        EvaluationSection,</span>
<span class="gi">+        Paragraph,</span>
<span class="gi">+        Section,</span>
<span class="gi">+        Table,</span>
<span class="gi">+    )</span>


<span class="w"> </span>class BaseWriter:
<span class="w"> </span>    &quot;&quot;&quot;Base class for ureport writers.&quot;&quot;&quot;

<span class="gd">-    def format(self, layout: BaseLayout, stream: TextIO=sys.stdout,</span>
<span class="gd">-        encoding: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def format(</span>
<span class="gi">+        self,</span>
<span class="gi">+        layout: BaseLayout,</span>
<span class="gi">+        stream: TextIO = sys.stdout,</span>
<span class="gi">+        encoding: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Format and write the given layout into the stream object.

<span class="w"> </span>        unicode policy: unicode strings may be found in the layout;
<span class="w"> </span>        try to call &#39;stream.write&#39; with it, but give it back encoded using
<span class="w"> </span>        the given encoding if it fails
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not encoding:</span>
<span class="gi">+            encoding = getattr(stream, &quot;encoding&quot;, &quot;UTF-8&quot;)</span>
<span class="gi">+        self.encoding = encoding or &quot;UTF-8&quot;</span>
<span class="gi">+        self.out = stream</span>
<span class="gi">+        self.begin_format()</span>
<span class="gi">+        layout.accept(self)</span>
<span class="gi">+        self.end_format()</span>

<span class="gd">-    def format_children(self, layout: (EvaluationSection | Paragraph | Section)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def format_children(self, layout: EvaluationSection | Paragraph | Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Recurse on the layout children and call their accept method
<span class="w"> </span>        (see the Visitor pattern).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child in getattr(layout, &quot;children&quot;, ()):</span>
<span class="gi">+            child.accept(self)</span>

<span class="gd">-    def writeln(self, string: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def writeln(self, string: str = &quot;&quot;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a line in the output buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(string + &quot;\n&quot;)</span>

<span class="gd">-    def write(self, string: str) -&gt;None:</span>
<span class="gi">+    def write(self, string: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write a string in the output buffer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.out.write(string)</span>

<span class="gd">-    def begin_format(self) -&gt;None:</span>
<span class="gi">+    def begin_format(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Begin to format a layout.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.section = 0</span>

<span class="gd">-    def end_format(self) -&gt;None:</span>
<span class="gi">+    def end_format(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Finished formatting a layout.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def get_table_content(self, table: Table) -&gt;list[list[str]]:</span>
<span class="gi">+    def get_table_content(self, table: Table) -&gt; list[list[str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Trick to get table content without actually writing it.

<span class="w"> </span>        return an aligned list of lists containing table cells values as string
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result: list[list[str]] = [[]]</span>
<span class="gi">+        cols = table.cols</span>
<span class="gi">+        for cell in self.compute_content(table):</span>
<span class="gi">+            if cols == 0:</span>
<span class="gi">+                result.append([])</span>
<span class="gi">+                cols = table.cols</span>
<span class="gi">+            cols -= 1</span>
<span class="gi">+            result[-1].append(cell)</span>
<span class="gi">+        # fill missing cells</span>
<span class="gi">+        result[-1] += [&quot;&quot;] * (cols - len(result[-1]))</span>
<span class="gi">+        return result</span>

<span class="gd">-    def compute_content(self, layout: BaseLayout) -&gt;Iterator[str]:</span>
<span class="gi">+    def compute_content(self, layout: BaseLayout) -&gt; Iterator[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Trick to compute the formatting of children layout before actually
<span class="w"> </span>        writing it.

<span class="w"> </span>        return an iterator on strings (one for each child element)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Patch the underlying output stream with a fresh-generated stream,</span>
<span class="gi">+        # which is used to store a temporary representation of a child</span>
<span class="gi">+        # node.</span>
<span class="gi">+        out = self.out</span>
<span class="gi">+        try:</span>
<span class="gi">+            for child in layout.children:</span>
<span class="gi">+                stream = StringIO()</span>
<span class="gi">+                self.out = stream</span>
<span class="gi">+                child.accept(self)</span>
<span class="gi">+                yield stream.getvalue()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.out = out</span>
<span class="gh">diff --git a/pylint/reporters/ureports/nodes.py b/pylint/reporters/ureports/nodes.py</span>
<span class="gh">index 9787ce5b8..59443996d 100644</span>
<span class="gd">--- a/pylint/reporters/ureports/nodes.py</span>
<span class="gi">+++ b/pylint/reporters/ureports/nodes.py</span>
<span class="gu">@@ -1,26 +1,45 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Micro reports objects.

<span class="w"> </span>A micro report is a tree of layout and content objects.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Iterable, Iterator
<span class="w"> </span>from typing import Any, Callable, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from pylint.reporters.ureports.base_writer import BaseWriter
<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gd">-_VNodeT = TypeVar(&#39;_VNodeT&#39;, bound=&#39;VNode&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>
<span class="gi">+_VNodeT = TypeVar(&quot;_VNodeT&quot;, bound=&quot;VNode&quot;)</span>
<span class="w"> </span>VisitLeaveFunction = Callable[[_T, Any, Any], None]


<span class="w"> </span>class VNode:
<span class="gd">-</span>
<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.parent: BaseLayout | None = None
<span class="w"> </span>        self.children: list[VNode] = []
<span class="w"> </span>        self.visitor_name: str = self.__class__.__name__.lower()

<span class="gd">-    def __iter__(self) -&gt;Iterator[VNode]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[VNode]:</span>
<span class="w"> </span>        return iter(self.children)

<span class="gi">+    def accept(self: _VNodeT, visitor: BaseWriter, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        func: VisitLeaveFunction[_VNodeT] = getattr(</span>
<span class="gi">+            visitor, f&quot;visit_{self.visitor_name}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        return func(self, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def leave(self: _VNodeT, visitor: BaseWriter, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        func: VisitLeaveFunction[_VNodeT] = getattr(</span>
<span class="gi">+            visitor, f&quot;leave_{self.visitor_name}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        return func(self, *args, **kwargs)</span>
<span class="gi">+</span>

<span class="w"> </span>class BaseLayout(VNode):
<span class="w"> </span>    &quot;&quot;&quot;Base container node.
<span class="gu">@@ -29,7 +48,7 @@ class BaseLayout(VNode):</span>
<span class="w"> </span>    * children : components in this table (i.e. the table&#39;s cells)
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, children: Iterable[Text | str]=()) -&gt;None:</span>
<span class="gi">+    def __init__(self, children: Iterable[Text | str] = ()) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        for child in children:
<span class="w"> </span>            if isinstance(child, VNode):
<span class="gu">@@ -37,21 +56,30 @@ class BaseLayout(VNode):</span>
<span class="w"> </span>            else:
<span class="w"> </span>                self.add_text(child)

<span class="gd">-    def append(self, child: VNode) -&gt;None:</span>
<span class="gi">+    def append(self, child: VNode) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a node to children.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert child not in self.parents()</span>
<span class="gi">+        self.children.append(child)</span>
<span class="gi">+        child.parent = self</span>

<span class="gd">-    def insert(self, index: int, child: VNode) -&gt;None:</span>
<span class="gi">+    def insert(self, index: int, child: VNode) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Insert a child node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.children.insert(index, child)</span>
<span class="gi">+        child.parent = self</span>

<span class="gd">-    def parents(self) -&gt;list[BaseLayout]:</span>
<span class="gi">+    def parents(self) -&gt; list[BaseLayout]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the ancestor nodes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert self.parent is not self</span>
<span class="gi">+        if self.parent is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        return [self.parent, *self.parent.parents()]</span>

<span class="gd">-    def add_text(self, text: str) -&gt;None:</span>
<span class="gi">+    def add_text(self, text: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Shortcut to add text data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.children.append(Text(text))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# non container nodes #########################################################</span>


<span class="w"> </span>class Text(VNode):
<span class="gu">@@ -61,7 +89,7 @@ class Text(VNode):</span>
<span class="w"> </span>    * data : the text value as an encoded or unicode string
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, data: str, escaped: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(self, data: str, escaped: bool = True) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.escaped = escaped
<span class="w"> </span>        self.data = data
<span class="gu">@@ -75,6 +103,9 @@ class VerbatimText(Text):</span>
<span class="w"> </span>    &quot;&quot;&quot;


<span class="gi">+# container nodes #############################################################</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Section(BaseLayout):
<span class="w"> </span>    &quot;&quot;&quot;A section.

<span class="gu">@@ -87,22 +118,25 @@ class Section(BaseLayout):</span>
<span class="w"> </span>    as a first paragraph
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, title: (str | None)=None, description: (str | None)=</span>
<span class="gd">-        None, children: Iterable[Text | str]=()) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        title: str | None = None,</span>
<span class="gi">+        description: str | None = None,</span>
<span class="gi">+        children: Iterable[Text | str] = (),</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(children=children)
<span class="w"> </span>        if description:
<span class="w"> </span>            self.insert(0, Paragraph([Text(description)]))
<span class="w"> </span>        if title:
<span class="w"> </span>            self.insert(0, Title(children=(title,)))
<span class="gd">-        self.report_id: str = &#39;&#39;</span>
<span class="gi">+        self.report_id: str = &quot;&quot;  # Used in ReportHandlerMixin.make_reports</span>


<span class="w"> </span>class EvaluationSection(Section):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, message: str, children: Iterable[Text | str]=()) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, children: Iterable[Text | str] = ()) -&gt; None:</span>
<span class="w"> </span>        super().__init__(children=children)
<span class="w"> </span>        title = Paragraph()
<span class="gd">-        title.append(Text(&#39;-&#39; * len(message)))</span>
<span class="gi">+        title.append(Text(&quot;-&quot; * len(message)))</span>
<span class="w"> </span>        self.append(title)
<span class="w"> </span>        message_body = Paragraph()
<span class="w"> </span>        message_body.append(Text(message))
<span class="gu">@@ -140,8 +174,14 @@ class Table(BaseLayout):</span>
<span class="w"> </span>    * title : the table&#39;s optional title
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, cols: int, title: (str | None)=None, rheaders: int=0,</span>
<span class="gd">-        cheaders: int=0, children: Iterable[Text | str]=()) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        cols: int,</span>
<span class="gi">+        title: str | None = None,</span>
<span class="gi">+        rheaders: int = 0,</span>
<span class="gi">+        cheaders: int = 0,</span>
<span class="gi">+        children: Iterable[Text | str] = (),</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(children=children)
<span class="w"> </span>        assert isinstance(cols, int)
<span class="w"> </span>        self.cols = cols
<span class="gh">diff --git a/pylint/reporters/ureports/text_writer.py b/pylint/reporters/ureports/text_writer.py</span>
<span class="gh">index a827d6c5f..5dd6a5d08 100644</span>
<span class="gd">--- a/pylint/reporters/ureports/text_writer.py</span>
<span class="gi">+++ b/pylint/reporters/ureports/text_writer.py</span>
<span class="gu">@@ -1,11 +1,28 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Text formatting drivers for ureports.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from pylint.reporters.ureports.base_writer import BaseWriter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from pylint.reporters.ureports.nodes import EvaluationSection, Paragraph, Section, Table, Text, Title, VerbatimText</span>
<span class="gd">-TITLE_UNDERLINES = [&#39;&#39;, &#39;=&#39;, &#39;-&#39;, &#39;`&#39;, &#39;.&#39;, &#39;~&#39;, &#39;^&#39;]</span>
<span class="gd">-BULLETS = [&#39;*&#39;, &#39;-&#39;]</span>
<span class="gi">+    from pylint.reporters.ureports.nodes import (</span>
<span class="gi">+        EvaluationSection,</span>
<span class="gi">+        Paragraph,</span>
<span class="gi">+        Section,</span>
<span class="gi">+        Table,</span>
<span class="gi">+        Text,</span>
<span class="gi">+        Title,</span>
<span class="gi">+        VerbatimText,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+TITLE_UNDERLINES = [&quot;&quot;, &quot;=&quot;, &quot;-&quot;, &quot;`&quot;, &quot;.&quot;, &quot;~&quot;, &quot;^&quot;]</span>
<span class="gi">+BULLETS = [&quot;*&quot;, &quot;-&quot;]</span>


<span class="w"> </span>class TextWriter(BaseWriter):
<span class="gu">@@ -13,35 +30,79 @@ class TextWriter(BaseWriter):</span>
<span class="w"> </span>    (ReStructured inspiration but not totally handled yet).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.list_level = 0

<span class="gd">-    def visit_section(self, layout: Section) -&gt;None:</span>
<span class="gi">+    def visit_section(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display a section as text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.section += 1</span>
<span class="gi">+        self.writeln()</span>
<span class="gi">+        self.format_children(layout)</span>
<span class="gi">+        self.section -= 1</span>
<span class="gi">+        self.writeln()</span>

<span class="gd">-    def visit_evaluationsection(self, layout: EvaluationSection) -&gt;None:</span>
<span class="gi">+    def visit_evaluationsection(self, layout: EvaluationSection) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display an evaluation section as a text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.section += 1</span>
<span class="gi">+        self.format_children(layout)</span>
<span class="gi">+        self.section -= 1</span>
<span class="gi">+        self.writeln()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_title(self, layout: Title) -&gt; None:</span>
<span class="gi">+        title = &quot;&quot;.join(list(self.compute_content(layout)))</span>
<span class="gi">+        self.writeln(title)</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.writeln(TITLE_UNDERLINES[self.section] * len(title))</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            print(&quot;FIXME TITLE TOO DEEP. TURNING TITLE INTO TEXT&quot;)</span>

<span class="gd">-    def visit_paragraph(self, layout: Paragraph) -&gt;None:</span>
<span class="gi">+    def visit_paragraph(self, layout: Paragraph) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Enter a paragraph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.format_children(layout)</span>
<span class="gi">+        self.writeln()</span>

<span class="gd">-    def visit_table(self, layout: Table) -&gt;None:</span>
<span class="gi">+    def visit_table(self, layout: Table) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display a table as text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        table_content = self.get_table_content(layout)</span>
<span class="gi">+        # get columns width</span>
<span class="gi">+        cols_width = [0] * len(table_content[0])</span>
<span class="gi">+        for row in table_content:</span>
<span class="gi">+            for index, col in enumerate(row):</span>
<span class="gi">+                cols_width[index] = max(cols_width[index], len(col))</span>
<span class="gi">+        self.default_table(layout, table_content, cols_width)</span>
<span class="gi">+        self.writeln()</span>

<span class="gd">-    def default_table(self, layout: Table, table_content: list[list[str]],</span>
<span class="gd">-        cols_width: list[int]) -&gt;None:</span>
<span class="gi">+    def default_table(</span>
<span class="gi">+        self, layout: Table, table_content: list[list[str]], cols_width: list[int]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Format a table.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cols_width = [size + 1 for size in cols_width]</span>
<span class="gi">+        format_strings = &quot; &quot;.join([&quot;%%-%ss&quot;] * len(cols_width))</span>
<span class="gi">+        format_strings %= tuple(cols_width)</span>
<span class="gi">+</span>
<span class="gi">+        table_linesep = &quot;\n+&quot; + &quot;+&quot;.join(&quot;-&quot; * w for w in cols_width) + &quot;+\n&quot;</span>
<span class="gi">+        headsep = &quot;\n+&quot; + &quot;+&quot;.join(&quot;=&quot; * w for w in cols_width) + &quot;+\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self.write(table_linesep)</span>
<span class="gi">+        split_strings = format_strings.split(&quot; &quot;)</span>
<span class="gi">+        for index, line in enumerate(table_content):</span>
<span class="gi">+            self.write(&quot;|&quot;)</span>
<span class="gi">+            for line_index, at_index in enumerate(line):</span>
<span class="gi">+                self.write(split_strings[line_index] % at_index)</span>
<span class="gi">+                self.write(&quot;|&quot;)</span>
<span class="gi">+            if index == 0 and layout.rheaders:</span>
<span class="gi">+                self.write(headsep)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.write(table_linesep)</span>

<span class="gd">-    def visit_verbatimtext(self, layout: VerbatimText) -&gt;None:</span>
<span class="gi">+    def visit_verbatimtext(self, layout: VerbatimText) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Display a verbatim layout as text (so difficult ;).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.writeln(&quot;::\n&quot;)</span>
<span class="gi">+        for line in layout.data.splitlines():</span>
<span class="gi">+            self.writeln(&quot;    &quot; + line)</span>
<span class="gi">+        self.writeln()</span>

<span class="gd">-    def visit_text(self, layout: Text) -&gt;None:</span>
<span class="gi">+    def visit_text(self, layout: Text) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add some text.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.write(f&quot;{layout.data}&quot;)</span>
<span class="gh">diff --git a/pylint/testutils/_primer/package_to_lint.py b/pylint/testutils/_primer/package_to_lint.py</span>
<span class="gh">index ff547e409..fb65a90ad 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/package_to_lint.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/package_to_lint.py</span>
<span class="gu">@@ -1,50 +1,70 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Literal
<span class="gi">+</span>
<span class="w"> </span>from git import GitCommandError
<span class="w"> </span>from git.cmd import Git
<span class="w"> </span>from git.repo import Repo
<span class="gd">-PRIMER_DIRECTORY_PATH = Path(&#39;tests&#39;) / &#39;.pylint_primer_tests&#39;</span>
<span class="gi">+</span>
<span class="gi">+PRIMER_DIRECTORY_PATH = Path(&quot;tests&quot;) / &quot;.pylint_primer_tests&quot;</span>


<span class="w"> </span>class DirtyPrimerDirectoryException(Exception):
<span class="w"> </span>    &quot;&quot;&quot;We can&#39;t pull if there&#39;s local changes.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, path: (Path | str)):</span>
<span class="gi">+    def __init__(self, path: Path | str):</span>
<span class="w"> </span>        super().__init__(
<span class="gd">-            f&quot;&quot;&quot;</span>
<span class="gi">+            rf&quot;&quot;&quot;</span>

<span class="gd">-/!\\ Can&#39;t pull /!\\</span>
<span class="gi">+/!\ Can&#39;t pull /!\</span>

<span class="w"> </span>In order for the prepare command to be able to pull please cleanup your local repo:
<span class="w"> </span>cd {path}
<span class="w"> </span>git diff
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-            )</span>
<span class="gi">+        )</span>


<span class="w"> </span>class PackageToLint:
<span class="w"> </span>    &quot;&quot;&quot;Represents data about a package to be tested during primer tests.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    url: str
<span class="w"> </span>    &quot;&quot;&quot;URL of the repository to clone.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    branch: str
<span class="w"> </span>    &quot;&quot;&quot;Branch of the repository to clone.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    directories: list[str]
<span class="w"> </span>    &quot;&quot;&quot;Directories within the repository to run pylint over.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    commit: str | None
<span class="w"> </span>    &quot;&quot;&quot;Commit hash to pin the repository on.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pylint_additional_args: list[str]
<span class="w"> </span>    &quot;&quot;&quot;Arguments to give to pylint.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pylintrc_relpath: str | None
<span class="w"> </span>    &quot;&quot;&quot;Path relative to project&#39;s main directory to the pylintrc if it exists.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    minimum_python: str | None
<span class="w"> </span>    &quot;&quot;&quot;Minimum python version supported by the package.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, url: str, branch: str, directories: list[str],</span>
<span class="gd">-        commit: (str | None)=None, pylint_additional_args: (list[str] |</span>
<span class="gd">-        None)=None, pylintrc_relpath: (str | None)=None, minimum_python: (</span>
<span class="gd">-        str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        url: str,</span>
<span class="gi">+        branch: str,</span>
<span class="gi">+        directories: list[str],</span>
<span class="gi">+        commit: str | None = None,</span>
<span class="gi">+        pylint_additional_args: list[str] | None = None,</span>
<span class="gi">+        pylintrc_relpath: str | None = None,</span>
<span class="gi">+        minimum_python: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.url = url
<span class="w"> </span>        self.branch = branch
<span class="w"> </span>        self.directories = directories
<span class="gu">@@ -54,16 +74,31 @@ class PackageToLint:</span>
<span class="w"> </span>        self.minimum_python = minimum_python

<span class="w"> </span>    @property
<span class="gd">-    def clone_directory(self) -&gt;Path:</span>
<span class="gi">+    def pylintrc(self) -&gt; Path | Literal[&quot;&quot;]:</span>
<span class="gi">+        if self.pylintrc_relpath is None:</span>
<span class="gi">+            # Fall back to &quot;&quot; to ensure pylint&#39;s own pylintrc is not discovered</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+        return self.clone_directory / self.pylintrc_relpath</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def clone_directory(self) -&gt; Path:</span>
<span class="w"> </span>        &quot;&quot;&quot;Directory to clone repository into.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        clone_name = &quot;/&quot;.join(self.url.split(&quot;/&quot;)[-2:]).replace(&quot;.git&quot;, &quot;&quot;)</span>
<span class="gi">+        return PRIMER_DIRECTORY_PATH / clone_name</span>

<span class="w"> </span>    @property
<span class="gd">-    def paths_to_lint(self) -&gt;list[str]:</span>
<span class="gi">+    def paths_to_lint(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The paths we need to lint.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [str(self.clone_directory / path) for path in self.directories]</span>

<span class="gd">-    def lazy_clone(self) -&gt;str:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def pylint_args(self) -&gt; list[str]:</span>
<span class="gi">+        options: list[str] = []</span>
<span class="gi">+        # There is an error if rcfile is given but does not exist</span>
<span class="gi">+        options += [f&quot;--rcfile={self.pylintrc}&quot;]</span>
<span class="gi">+        return self.paths_to_lint + options + self.pylint_additional_args</span>
<span class="gi">+</span>
<span class="gi">+    def lazy_clone(self) -&gt; str:  # pragma: no cover</span>
<span class="w"> </span>        &quot;&quot;&quot;Concatenates the target directory and clones the file.

<span class="w"> </span>        Not expected to be tested as the primer won&#39;t work if it doesn&#39;t.
<span class="gu">@@ -72,4 +107,43 @@ class PackageToLint:</span>
<span class="w"> </span>        we&#39;ll probably notice because we&#39;ll have a fatal when launching the
<span class="w"> </span>        primer locally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logging.info(&quot;Lazy cloning %s&quot;, self.url)</span>
<span class="gi">+        if not self.clone_directory.exists():</span>
<span class="gi">+            return self._clone_repository()</span>
<span class="gi">+        return self._pull_repository()</span>
<span class="gi">+</span>
<span class="gi">+    def _clone_repository(self) -&gt; str:</span>
<span class="gi">+        options: dict[str, str | int] = {</span>
<span class="gi">+            &quot;url&quot;: self.url,</span>
<span class="gi">+            &quot;to_path&quot;: str(self.clone_directory),</span>
<span class="gi">+            &quot;branch&quot;: self.branch,</span>
<span class="gi">+            &quot;depth&quot;: 1,</span>
<span class="gi">+        }</span>
<span class="gi">+        logging.info(&quot;Directory does not exists, cloning: %s&quot;, options)</span>
<span class="gi">+        repo = Repo.clone_from(</span>
<span class="gi">+            url=self.url, to_path=self.clone_directory, branch=self.branch, depth=1</span>
<span class="gi">+        )</span>
<span class="gi">+        return str(repo.head.object.hexsha)</span>
<span class="gi">+</span>
<span class="gi">+    def _pull_repository(self) -&gt; str:</span>
<span class="gi">+        remote_sha1_commit = Git().ls_remote(self.url, self.branch).split(&quot;\t&quot;)[0]</span>
<span class="gi">+        local_sha1_commit = Repo(self.clone_directory).head.object.hexsha</span>
<span class="gi">+        if remote_sha1_commit != local_sha1_commit:</span>
<span class="gi">+            logging.info(</span>
<span class="gi">+                &quot;Remote sha is &#39;%s&#39; while local sha is &#39;%s&#39;: pulling new commits&quot;,</span>
<span class="gi">+                remote_sha1_commit,</span>
<span class="gi">+                local_sha1_commit,</span>
<span class="gi">+            )</span>
<span class="gi">+            try:</span>
<span class="gi">+                repo = Repo(self.clone_directory)</span>
<span class="gi">+                if repo.is_dirty():</span>
<span class="gi">+                    raise DirtyPrimerDirectoryException(self.clone_directory)</span>
<span class="gi">+                origin = repo.remotes.origin</span>
<span class="gi">+                origin.pull()</span>
<span class="gi">+            except GitCommandError as e:</span>
<span class="gi">+                raise SystemError(</span>
<span class="gi">+                    f&quot;Failed to clone repository for {self.clone_directory}&quot;</span>
<span class="gi">+                ) from e</span>
<span class="gi">+        else:</span>
<span class="gi">+            logging.info(&quot;Repository already up to date.&quot;)</span>
<span class="gi">+        return str(remote_sha1_commit)</span>
<span class="gh">diff --git a/pylint/testutils/_primer/primer.py b/pylint/testutils/_primer/primer.py</span>
<span class="gh">index feaf47462..87c37d3fe 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/primer.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/primer.py</span>
<span class="gu">@@ -1,8 +1,14 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import json
<span class="w"> </span>import sys
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from pylint.testutils._primer import PackageToLint
<span class="w"> </span>from pylint.testutils._primer.primer_command import PrimerCommand
<span class="w"> </span>from pylint.testutils._primer.primer_compare_command import CompareCommand
<span class="gu">@@ -13,47 +19,110 @@ from pylint.testutils._primer.primer_run_command import RunCommand</span>
<span class="w"> </span>class Primer:
<span class="w"> </span>    &quot;&quot;&quot;Main class to handle priming of packages.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, primer_directory: Path, json_path: Path) -&gt;None:</span>
<span class="gi">+    def __init__(self, primer_directory: Path, json_path: Path) -&gt; None:</span>
<span class="gi">+        # Preparing arguments</span>
<span class="w"> </span>        self.primer_directory = primer_directory
<span class="gd">-        self._argument_parser = argparse.ArgumentParser(prog=&#39;Pylint Primer&#39;)</span>
<span class="gd">-        self._subparsers = self._argument_parser.add_subparsers(dest=</span>
<span class="gd">-            &#39;command&#39;, required=True)</span>
<span class="gd">-        prepare_parser = self._subparsers.add_parser(&#39;prepare&#39;)</span>
<span class="gd">-        prepare_parser.add_argument(&#39;--clone&#39;, help=&#39;Clone all packages.&#39;,</span>
<span class="gd">-            action=&#39;store_true&#39;, default=False)</span>
<span class="gd">-        prepare_parser.add_argument(&#39;--check&#39;, help=</span>
<span class="gd">-            &#39;Check consistencies and commits of all packages.&#39;, action=</span>
<span class="gd">-            &#39;store_true&#39;, default=False)</span>
<span class="gd">-        prepare_parser.add_argument(&#39;--make-commit-string&#39;, help=</span>
<span class="gd">-            &#39;Get latest commit string.&#39;, action=&#39;store_true&#39;, default=False)</span>
<span class="gd">-        prepare_parser.add_argument(&#39;--read-commit-string&#39;, help=</span>
<span class="gd">-            &#39;Print latest commit string.&#39;, action=&#39;store_true&#39;, default=False)</span>
<span class="gd">-        run_parser = self._subparsers.add_parser(&#39;run&#39;)</span>
<span class="gd">-        run_parser.add_argument(&#39;--type&#39;, choices=[&#39;main&#39;, &#39;pr&#39;], required=</span>
<span class="gd">-            True, help=&#39;Type of primer run.&#39;)</span>
<span class="gd">-        run_parser.add_argument(&#39;--batches&#39;, required=False, type=int, help</span>
<span class="gd">-            =&#39;Number of batches&#39;)</span>
<span class="gd">-        run_parser.add_argument(&#39;--batchIdx&#39;, required=False, type=int,</span>
<span class="gd">-            help=&#39;Portion of primer packages to run.&#39;)</span>
<span class="gd">-        compare_parser = self._subparsers.add_parser(&#39;compare&#39;)</span>
<span class="gd">-        compare_parser.add_argument(&#39;--base-file&#39;, required=True, help=</span>
<span class="gd">-            &#39;Location of output file of the base run.&#39;)</span>
<span class="gd">-        compare_parser.add_argument(&#39;--new-file&#39;, required=True, help=</span>
<span class="gd">-            &#39;Location of output file of the new run.&#39;)</span>
<span class="gd">-        compare_parser.add_argument(&#39;--commit&#39;, required=True, help=</span>
<span class="gd">-            &#39;Commit hash of the PR commit being checked.&#39;)</span>
<span class="gd">-        compare_parser.add_argument(&#39;--batches&#39;, required=False, type=int,</span>
<span class="gd">-            help=</span>
<span class="gd">-            &#39;Number of batches (filepaths with the placeholder BATCHIDX will be numbered)&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        self._argument_parser = argparse.ArgumentParser(prog=&quot;Pylint Primer&quot;)</span>
<span class="gi">+        self._subparsers = self._argument_parser.add_subparsers(</span>
<span class="gi">+            dest=&quot;command&quot;, required=True</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # All arguments for the prepare parser</span>
<span class="gi">+        prepare_parser = self._subparsers.add_parser(&quot;prepare&quot;)</span>
<span class="gi">+        prepare_parser.add_argument(</span>
<span class="gi">+            &quot;--clone&quot;, help=&quot;Clone all packages.&quot;, action=&quot;store_true&quot;, default=False</span>
<span class="gi">+        )</span>
<span class="gi">+        prepare_parser.add_argument(</span>
<span class="gi">+            &quot;--check&quot;,</span>
<span class="gi">+            help=&quot;Check consistencies and commits of all packages.&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            default=False,</span>
<span class="gi">+        )</span>
<span class="gi">+        prepare_parser.add_argument(</span>
<span class="gi">+            &quot;--make-commit-string&quot;,</span>
<span class="gi">+            help=&quot;Get latest commit string.&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            default=False,</span>
<span class="gi">+        )</span>
<span class="gi">+        prepare_parser.add_argument(</span>
<span class="gi">+            &quot;--read-commit-string&quot;,</span>
<span class="gi">+            help=&quot;Print latest commit string.&quot;,</span>
<span class="gi">+            action=&quot;store_true&quot;,</span>
<span class="gi">+            default=False,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # All arguments for the run parser</span>
<span class="gi">+        run_parser = self._subparsers.add_parser(&quot;run&quot;)</span>
<span class="gi">+        run_parser.add_argument(</span>
<span class="gi">+            &quot;--type&quot;, choices=[&quot;main&quot;, &quot;pr&quot;], required=True, help=&quot;Type of primer run.&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        run_parser.add_argument(</span>
<span class="gi">+            &quot;--batches&quot;,</span>
<span class="gi">+            required=False,</span>
<span class="gi">+            type=int,</span>
<span class="gi">+            help=&quot;Number of batches&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        run_parser.add_argument(</span>
<span class="gi">+            &quot;--batchIdx&quot;,</span>
<span class="gi">+            required=False,</span>
<span class="gi">+            type=int,</span>
<span class="gi">+            help=&quot;Portion of primer packages to run.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # All arguments for the compare parser</span>
<span class="gi">+        compare_parser = self._subparsers.add_parser(&quot;compare&quot;)</span>
<span class="gi">+        compare_parser.add_argument(</span>
<span class="gi">+            &quot;--base-file&quot;,</span>
<span class="gi">+            required=True,</span>
<span class="gi">+            help=&quot;Location of output file of the base run.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        compare_parser.add_argument(</span>
<span class="gi">+            &quot;--new-file&quot;,</span>
<span class="gi">+            required=True,</span>
<span class="gi">+            help=&quot;Location of output file of the new run.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        compare_parser.add_argument(</span>
<span class="gi">+            &quot;--commit&quot;,</span>
<span class="gi">+            required=True,</span>
<span class="gi">+            help=&quot;Commit hash of the PR commit being checked.&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+        compare_parser.add_argument(</span>
<span class="gi">+            &quot;--batches&quot;,</span>
<span class="gi">+            required=False,</span>
<span class="gi">+            type=int,</span>
<span class="gi">+            help=&quot;Number of batches (filepaths with the placeholder BATCHIDX will be numbered)&quot;,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Storing arguments</span>
<span class="w"> </span>        self.config = self._argument_parser.parse_args()
<span class="gi">+</span>
<span class="w"> </span>        self.packages = self._get_packages_to_lint_from_json(json_path)
<span class="w"> </span>        &quot;&quot;&quot;All packages to prime.&quot;&quot;&quot;
<span class="gd">-        if self.config.command == &#39;prepare&#39;:</span>
<span class="gi">+</span>
<span class="gi">+        if self.config.command == &quot;prepare&quot;:</span>
<span class="w"> </span>            command_class: type[PrimerCommand] = PrepareCommand
<span class="gd">-        elif self.config.command == &#39;run&#39;:</span>
<span class="gi">+        elif self.config.command == &quot;run&quot;:</span>
<span class="w"> </span>            command_class = RunCommand
<span class="gd">-        elif self.config.command == &#39;compare&#39;:</span>
<span class="gi">+        elif self.config.command == &quot;compare&quot;:</span>
<span class="w"> </span>            command_class = CompareCommand
<span class="gd">-        self.command = command_class(self.primer_directory, self.packages,</span>
<span class="gd">-            self.config)</span>
<span class="gi">+        self.command = command_class(self.primer_directory, self.packages, self.config)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; None:</span>
<span class="gi">+        self.command.run()</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _minimum_python_supported(package_data: dict[str, str]) -&gt; bool:</span>
<span class="gi">+        min_python_str = package_data.get(&quot;minimum_python&quot;, None)</span>
<span class="gi">+        if not min_python_str:</span>
<span class="gi">+            return True</span>
<span class="gi">+        min_python_tuple = tuple(int(n) for n in min_python_str.split(&quot;.&quot;))</span>
<span class="gi">+        return min_python_tuple &lt;= sys.version_info[:2]</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_packages_to_lint_from_json(json_path: Path) -&gt; dict[str, PackageToLint]:</span>
<span class="gi">+        with open(json_path, encoding=&quot;utf8&quot;) as f:</span>
<span class="gi">+            return {</span>
<span class="gi">+                name: PackageToLint(**package_data)</span>
<span class="gi">+                for name, package_data in json.load(f).items()</span>
<span class="gi">+                if Primer._minimum_python_supported(package_data)</span>
<span class="gi">+            }</span>
<span class="gh">diff --git a/pylint/testutils/_primer/primer_command.py b/pylint/testutils/_primer/primer_command.py</span>
<span class="gh">index 9c5537249..817c1a0d3 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/primer_command.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/primer_command.py</span>
<span class="gu">@@ -1,8 +1,14 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import abc
<span class="w"> </span>import argparse
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Dict, TypedDict
<span class="gi">+</span>
<span class="w"> </span>from pylint.reporters.json_reporter import OldJsonExport
<span class="w"> </span>from pylint.testutils._primer import PackageToLint

<span class="gu">@@ -18,8 +24,16 @@ PackageMessages = Dict[str, PackageData]</span>
<span class="w"> </span>class PrimerCommand:
<span class="w"> </span>    &quot;&quot;&quot;Generic primer action with required arguments.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, primer_directory: Path, packages: dict[str,</span>
<span class="gd">-        PackageToLint], config: argparse.Namespace) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        primer_directory: Path,</span>
<span class="gi">+        packages: dict[str, PackageToLint],</span>
<span class="gi">+        config: argparse.Namespace,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.primer_directory = primer_directory
<span class="w"> </span>        self.packages = packages
<span class="w"> </span>        self.config = config
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def run(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gh">diff --git a/pylint/testutils/_primer/primer_compare_command.py b/pylint/testutils/_primer/primer_compare_command.py</span>
<span class="gh">index f71c9c3a6..7b245b9e1 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/primer_compare_command.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/primer_compare_command.py</span>
<span class="gu">@@ -1,13 +1,174 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>from pathlib import Path, PurePosixPath
<span class="gi">+</span>
<span class="w"> </span>from pylint.reporters.json_reporter import OldJsonExport
<span class="gd">-from pylint.testutils._primer.primer_command import PackageData, PackageMessages, PrimerCommand</span>
<span class="gi">+from pylint.testutils._primer.primer_command import (</span>
<span class="gi">+    PackageData,</span>
<span class="gi">+    PackageMessages,</span>
<span class="gi">+    PrimerCommand,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>MAX_GITHUB_COMMENT_LENGTH = 65536


<span class="w"> </span>class CompareCommand(PrimerCommand):
<span class="gi">+    def run(self) -&gt; None:</span>
<span class="gi">+        if self.config.batches is None:</span>
<span class="gi">+            main_data = self._load_json(self.config.base_file)</span>
<span class="gi">+            pr_data = self._load_json(self.config.new_file)</span>
<span class="gi">+        else:</span>
<span class="gi">+            main_data = {}</span>
<span class="gi">+            pr_data = {}</span>
<span class="gi">+            for idx in range(self.config.batches):</span>
<span class="gi">+                main_data.update(</span>
<span class="gi">+                    self._load_json(</span>
<span class="gi">+                        self.config.base_file.replace(&quot;BATCHIDX&quot;, &quot;batch&quot; + str(idx))</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                pr_data.update(</span>
<span class="gi">+                    self._load_json(</span>
<span class="gi">+                        self.config.new_file.replace(&quot;BATCHIDX&quot;, &quot;batch&quot; + str(idx))</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        missing_messages_data, new_messages_data = self._cross_reference(</span>
<span class="gi">+            main_data, pr_data</span>
<span class="gi">+        )</span>
<span class="gi">+        comment = self._create_comment(missing_messages_data, new_messages_data)</span>
<span class="gi">+        with open(self.primer_directory / &quot;comment.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+            f.write(comment)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _cross_reference(</span>
<span class="gi">+        main_data: PackageMessages, pr_data: PackageMessages</span>
<span class="gi">+    ) -&gt; tuple[PackageMessages, PackageMessages]:</span>
<span class="gi">+        missing_messages_data: PackageMessages = {}</span>
<span class="gi">+        for package, data in main_data.items():</span>
<span class="gi">+            package_missing_messages: list[OldJsonExport] = []</span>
<span class="gi">+            for message in data[&quot;messages&quot;]:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    pr_data[package][&quot;messages&quot;].remove(message)</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    package_missing_messages.append(message)</span>
<span class="gi">+            missing_messages_data[package] = PackageData(</span>
<span class="gi">+                commit=pr_data[package][&quot;commit&quot;], messages=package_missing_messages</span>
<span class="gi">+            )</span>
<span class="gi">+        return missing_messages_data, pr_data</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _load_json(file_path: Path | str) -&gt; PackageMessages:</span>
<span class="gi">+        with open(file_path, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+            result: PackageMessages = json.load(f)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _create_comment(</span>
<span class="gi">+        self, all_missing_messages: PackageMessages, all_new_messages: PackageMessages</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        comment = &quot;&quot;</span>
<span class="gi">+        for package, missing_messages in all_missing_messages.items():</span>
<span class="gi">+            if len(comment) &gt;= MAX_GITHUB_COMMENT_LENGTH:</span>
<span class="gi">+                break</span>
<span class="gi">+            new_messages = all_new_messages[package]</span>
<span class="gi">+            if not missing_messages[&quot;messages&quot;] and not new_messages[&quot;messages&quot;]:</span>
<span class="gi">+                continue</span>
<span class="gi">+            comment += self._create_comment_for_package(</span>
<span class="gi">+                package, new_messages, missing_messages</span>
<span class="gi">+            )</span>
<span class="gi">+        comment = (</span>
<span class="gi">+            f&quot;🤖 **Effect of this PR on checked open source code:** 🤖\n\n{comment}&quot;</span>
<span class="gi">+            if comment</span>
<span class="gi">+            else (</span>
<span class="gi">+                &quot;🤖 According to the primer, this change has **no effect** on the&quot;</span>
<span class="gi">+                &quot; checked open source code. 🤖🎉\n\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+        return self._truncate_comment(comment)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_comment_for_package(</span>
<span class="gi">+        self, package: str, new_messages: PackageData, missing_messages: PackageData</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        comment = f&quot;\n\n**Effect on [{package}]({self.packages[package].url}):**\n&quot;</span>
<span class="gi">+        # Create comment for new messages</span>
<span class="gi">+        count = 1</span>
<span class="gi">+        astroid_errors = 0</span>
<span class="gi">+        new_non_astroid_messages = &quot;&quot;</span>
<span class="gi">+        if new_messages[&quot;messages&quot;]:</span>
<span class="gi">+            print(&quot;Now emitted:&quot;)</span>
<span class="gi">+        for message in new_messages[&quot;messages&quot;]:</span>
<span class="gi">+            filepath = str(</span>
<span class="gi">+                PurePosixPath(message[&quot;path&quot;]).relative_to(</span>
<span class="gi">+                    self.packages[package].clone_directory</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            # Existing astroid errors may still show up as &quot;new&quot; because the timestamp</span>
<span class="gi">+            # in the message is slightly different.</span>
<span class="gi">+            if message[&quot;symbol&quot;] == &quot;astroid-error&quot;:</span>
<span class="gi">+                astroid_errors += 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_non_astroid_messages += (</span>
<span class="gi">+                    f&quot;{count}) {message[&#39;symbol&#39;]}:\n*{message[&#39;message&#39;]}*\n&quot;</span>
<span class="gi">+                    f&quot;{self.packages[package].url}/blob/{new_messages[&#39;commit&#39;]}/{filepath}#L{message[&#39;line&#39;]}\n&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                print(message)</span>
<span class="gi">+                count += 1</span>
<span class="gi">+</span>
<span class="gi">+        if astroid_errors:</span>
<span class="gi">+            comment += (</span>
<span class="gi">+                f&#39;{astroid_errors} &quot;astroid error(s)&quot; were found. &#39;</span>
<span class="gi">+                &quot;Please open the GitHub Actions log to see what failed or crashed.\n\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        if new_non_astroid_messages:</span>
<span class="gi">+            comment += (</span>
<span class="gi">+                &quot;The following messages are now emitted:\n\n&lt;details&gt;\n\n&quot;</span>
<span class="gi">+                + new_non_astroid_messages</span>
<span class="gi">+                + &quot;\n&lt;/details&gt;\n\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # Create comment for missing messages</span>
<span class="gi">+        count = 1</span>
<span class="gi">+        if missing_messages[&quot;messages&quot;]:</span>
<span class="gi">+            comment += &quot;The following messages are no longer emitted:\n\n&lt;details&gt;\n\n&quot;</span>
<span class="gi">+            print(&quot;No longer emitted:&quot;)</span>
<span class="gi">+        for message in missing_messages[&quot;messages&quot;]:</span>
<span class="gi">+            comment += f&quot;{count}) {message[&#39;symbol&#39;]}:\n*{message[&#39;message&#39;]}*\n&quot;</span>
<span class="gi">+            filepath = str(</span>
<span class="gi">+                PurePosixPath(message[&quot;path&quot;]).relative_to(</span>
<span class="gi">+                    self.packages[package].clone_directory</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+            assert not self.packages[package].url.endswith(</span>
<span class="gi">+                &quot;.git&quot;</span>
<span class="gi">+            ), &quot;You don&#39;t need the .git at the end of the github url.&quot;</span>
<span class="gi">+            comment += (</span>
<span class="gi">+                f&quot;{self.packages[package].url}&quot;</span>
<span class="gi">+                f&quot;/blob/{new_messages[&#39;commit&#39;]}/{filepath}#L{message[&#39;line&#39;]}\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            count += 1</span>
<span class="gi">+            print(message)</span>
<span class="gi">+        if missing_messages:</span>
<span class="gi">+            comment += &quot;\n&lt;/details&gt;\n\n&quot;</span>
<span class="gi">+        return comment</span>

<span class="gd">-    def _truncate_comment(self, comment: str) -&gt;str:</span>
<span class="gi">+    def _truncate_comment(self, comment: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;GitHub allows only a set number of characters in a comment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hash_information = (</span>
<span class="gi">+            f&quot;*This comment was generated for commit {self.config.commit}*&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        if len(comment) + len(hash_information) &gt;= MAX_GITHUB_COMMENT_LENGTH:</span>
<span class="gi">+            truncation_information = (</span>
<span class="gi">+                f&quot;*This comment was truncated because GitHub allows only&quot;</span>
<span class="gi">+                f&quot; {MAX_GITHUB_COMMENT_LENGTH} characters in a comment.*&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            max_len = (</span>
<span class="gi">+                MAX_GITHUB_COMMENT_LENGTH</span>
<span class="gi">+                - len(hash_information)</span>
<span class="gi">+                - len(truncation_information)</span>
<span class="gi">+            )</span>
<span class="gi">+            comment = f&quot;{comment[:max_len - 10]}...\n\n{truncation_information}\n\n&quot;</span>
<span class="gi">+        comment += hash_information</span>
<span class="gi">+        return comment</span>
<span class="gh">diff --git a/pylint/testutils/_primer/primer_prepare_command.py b/pylint/testutils/_primer/primer_prepare_command.py</span>
<span class="gh">index 6ceb3a886..27e216bd5 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/primer_prepare_command.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/primer_prepare_command.py</span>
<span class="gu">@@ -1,9 +1,48 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>from git.cmd import Git
<span class="w"> </span>from git.repo import Repo
<span class="gi">+</span>
<span class="w"> </span>from pylint.testutils._primer.primer_command import PrimerCommand


<span class="w"> </span>class PrepareCommand(PrimerCommand):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self) -&gt; None:</span>
<span class="gi">+        commit_string = &quot;&quot;</span>
<span class="gi">+        version_string = &quot;.&quot;.join(str(x) for x in sys.version_info[:2])</span>
<span class="gi">+        # Shorten the SHA to avoid exceeding GitHub&#39;s 512 char ceiling</span>
<span class="gi">+        if self.config.clone:</span>
<span class="gi">+            for package, data in self.packages.items():</span>
<span class="gi">+                local_commit = data.lazy_clone()</span>
<span class="gi">+                print(f&quot;Cloned &#39;{package}&#39; at commit &#39;{local_commit}&#39;.&quot;)</span>
<span class="gi">+                commit_string += local_commit[:8] + &quot;_&quot;</span>
<span class="gi">+        elif self.config.check:</span>
<span class="gi">+            for package, data in self.packages.items():</span>
<span class="gi">+                local_commit = Repo(data.clone_directory).head.object.hexsha</span>
<span class="gi">+                print(f&quot;Found &#39;{package}&#39; at commit &#39;{local_commit}&#39;.&quot;)</span>
<span class="gi">+                commit_string += local_commit[:8] + &quot;_&quot;</span>
<span class="gi">+        elif self.config.make_commit_string:</span>
<span class="gi">+            for package, data in self.packages.items():</span>
<span class="gi">+                remote_sha1_commit = (</span>
<span class="gi">+                    Git().ls_remote(data.url, data.branch).split(&quot;\t&quot;)[0][:8]</span>
<span class="gi">+                )</span>
<span class="gi">+                print(f&quot;&#39;{package}&#39; remote is at commit &#39;{remote_sha1_commit}&#39;.&quot;)</span>
<span class="gi">+                commit_string += remote_sha1_commit + &quot;_&quot;</span>
<span class="gi">+        elif self.config.read_commit_string:</span>
<span class="gi">+            with open(</span>
<span class="gi">+                self.primer_directory / f&quot;commit_string_{version_string}.txt&quot;,</span>
<span class="gi">+                encoding=&quot;utf-8&quot;,</span>
<span class="gi">+            ) as f:</span>
<span class="gi">+                print(f.read())</span>
<span class="gi">+        if commit_string:</span>
<span class="gi">+            with open(</span>
<span class="gi">+                self.primer_directory / f&quot;commit_string_{version_string}.txt&quot;,</span>
<span class="gi">+                &quot;w&quot;,</span>
<span class="gi">+                encoding=&quot;utf-8&quot;,</span>
<span class="gi">+            ) as f:</span>
<span class="gi">+                f.write(commit_string)</span>
<span class="gh">diff --git a/pylint/testutils/_primer/primer_run_command.py b/pylint/testutils/_primer/primer_run_command.py</span>
<span class="gh">index 9a5876619..96a1440e7 100644</span>
<span class="gd">--- a/pylint/testutils/_primer/primer_run_command.py</span>
<span class="gi">+++ b/pylint/testutils/_primer/primer_run_command.py</span>
<span class="gu">@@ -1,21 +1,109 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from io import StringIO
<span class="gi">+</span>
<span class="w"> </span>from git.repo import Repo
<span class="gi">+</span>
<span class="w"> </span>from pylint.lint import Run
<span class="w"> </span>from pylint.message import Message
<span class="w"> </span>from pylint.reporters.json_reporter import JSONReporter, OldJsonExport
<span class="w"> </span>from pylint.testutils._primer.package_to_lint import PackageToLint
<span class="gd">-from pylint.testutils._primer.primer_command import PackageData, PackageMessages, PrimerCommand</span>
<span class="gd">-GITHUB_CRASH_TEMPLATE_LOCATION = &#39;/home/runner/.cache&#39;</span>
<span class="gd">-CRASH_TEMPLATE_INTRO = &#39;There is a pre-filled template&#39;</span>
<span class="gi">+from pylint.testutils._primer.primer_command import (</span>
<span class="gi">+    PackageData,</span>
<span class="gi">+    PackageMessages,</span>
<span class="gi">+    PrimerCommand,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+GITHUB_CRASH_TEMPLATE_LOCATION = &quot;/home/runner/.cache&quot;</span>
<span class="gi">+CRASH_TEMPLATE_INTRO = &quot;There is a pre-filled template&quot;</span>


<span class="w"> </span>class RunCommand(PrimerCommand):
<span class="gi">+    def run(self) -&gt; None:</span>
<span class="gi">+        packages: PackageMessages = {}</span>
<span class="gi">+        fatal_msgs: list[Message] = []</span>
<span class="gi">+        package_data_iter = (</span>
<span class="gi">+            self.packages.items()</span>
<span class="gi">+            if self.config.batches is None</span>
<span class="gi">+            else list(self.packages.items())[</span>
<span class="gi">+                self.config.batchIdx :: self.config.batches</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+        for package, data in package_data_iter:</span>
<span class="gi">+            messages, p_fatal_msgs = self._lint_package(package, data)</span>
<span class="gi">+            fatal_msgs += p_fatal_msgs</span>
<span class="gi">+            local_commit = Repo(data.clone_directory).head.object.hexsha</span>
<span class="gi">+            packages[package] = PackageData(commit=local_commit, messages=messages)</span>
<span class="gi">+        path = self.primer_directory / (</span>
<span class="gi">+            f&quot;output_{&#39;.&#39;.join(str(i) for i in sys.version_info[:2])}_{self.config.type}&quot;</span>
<span class="gi">+            + (f&quot;_batch{self.config.batchIdx}.txt&quot; if self.config.batches else &quot;&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        print(f&quot;Writing result in {path}&quot;)</span>
<span class="gi">+        with open(path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+            json.dump(packages, f)</span>
<span class="gi">+        # Assert that a PR run does not introduce new fatal errors</span>
<span class="gi">+        if self.config.type == &quot;pr&quot;:</span>
<span class="gi">+            plural = &quot;s&quot; if len(fatal_msgs) &gt; 1 else &quot;&quot;</span>
<span class="gi">+            assert (</span>
<span class="gi">+                not fatal_msgs</span>
<span class="gi">+            ), f&quot;We encountered {len(fatal_msgs)} fatal error message{plural} (see log).&quot;</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _filter_fatal_errors(messages: list[OldJsonExport]) -&gt;list[Message]:</span>
<span class="gi">+    def _filter_fatal_errors(</span>
<span class="gi">+        messages: list[OldJsonExport],</span>
<span class="gi">+    ) -&gt; list[Message]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Separate fatal errors so we can report them independently.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        fatal_msgs: list[Message] = []</span>
<span class="gi">+        for raw_message in messages:</span>
<span class="gi">+            message = JSONReporter.deserialize(raw_message)</span>
<span class="gi">+            if message.category == &quot;fatal&quot;:</span>
<span class="gi">+                if GITHUB_CRASH_TEMPLATE_LOCATION in message.msg:</span>
<span class="gi">+                    # Remove the crash template location if we&#39;re running on GitHub.</span>
<span class="gi">+                    # We were falsely getting &quot;new&quot; errors when the timestamp changed.</span>
<span class="gi">+                    message.msg = message.msg.rsplit(CRASH_TEMPLATE_INTRO)[0]</span>
<span class="gi">+                fatal_msgs.append(message)</span>
<span class="gi">+        return fatal_msgs</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _print_msgs(msgs: list[Message]) -&gt; str:</span>
<span class="gi">+        return &quot;\n&quot;.join(f&quot;- {JSONReporter.serialize(m)}&quot; for m in msgs)</span>
<span class="gi">+</span>
<span class="gi">+    def _lint_package(</span>
<span class="gi">+        self, package_name: str, data: PackageToLint</span>
<span class="gi">+    ) -&gt; tuple[list[OldJsonExport], list[Message]]:</span>
<span class="gi">+        # We want to test all the code we can</span>
<span class="gi">+        enables = [&quot;--enable-all-extensions&quot;, &quot;--enable=all&quot;]</span>
<span class="gi">+        # Duplicate code takes too long and is relatively safe</span>
<span class="gi">+        # TODO: Find a way to allow cyclic-import and compare output correctly</span>
<span class="gi">+        disables = [&quot;--disable=duplicate-code,cyclic-import&quot;]</span>
<span class="gi">+        additional = [&quot;--clear-cache-post-run=y&quot;]</span>
<span class="gi">+        arguments = data.pylint_args + enables + disables + additional</span>
<span class="gi">+        output = StringIO()</span>
<span class="gi">+        reporter = JSONReporter(output)</span>
<span class="gi">+        print(f&quot;Running &#39;pylint {&#39;, &#39;.join(arguments)}&#39;&quot;)</span>
<span class="gi">+        pylint_exit_code = -1</span>
<span class="gi">+        try:</span>
<span class="gi">+            Run(arguments, reporter=reporter)</span>
<span class="gi">+        except SystemExit as e:</span>
<span class="gi">+            pylint_exit_code = int(e.code)  # type: ignore[arg-type]</span>
<span class="gi">+        readable_messages: str = output.getvalue()</span>
<span class="gi">+        messages: list[OldJsonExport] = json.loads(readable_messages)</span>
<span class="gi">+        fatal_msgs: list[Message] = []</span>
<span class="gi">+        if pylint_exit_code % 2 == 0:</span>
<span class="gi">+            print(f&quot;Successfully primed {package_name}.&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fatal_msgs = self._filter_fatal_errors(messages)</span>
<span class="gi">+            if fatal_msgs:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&quot;Encountered fatal errors while priming {package_name} !\n&quot;</span>
<span class="gi">+                    f&quot;{self._print_msgs(fatal_msgs)}\n\n&quot;,</span>
<span class="gi">+                    stacklevel=2,</span>
<span class="gi">+                )</span>
<span class="gi">+        return messages, fatal_msgs</span>
<span class="gh">diff --git a/pylint/testutils/_run.py b/pylint/testutils/_run.py</span>
<span class="gh">index 8752caca2..f42cb8d6a 100644</span>
<span class="gd">--- a/pylint/testutils/_run.py</span>
<span class="gi">+++ b/pylint/testutils/_run.py</span>
<span class="gu">@@ -1,17 +1,26 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Classes and functions used to mimic normal pylint runs.

<span class="w"> </span>This module is considered private and can change at any time.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Sequence
<span class="gi">+</span>
<span class="w"> </span>from pylint.lint import Run as LintRun
<span class="w"> </span>from pylint.reporters.base_reporter import BaseReporter
<span class="w"> </span>from pylint.testutils.lint_module_test import PYLINTRC


<span class="gd">-def _add_rcfile_default_pylintrc(args: list[str]) -&gt;list[str]:</span>
<span class="gi">+def _add_rcfile_default_pylintrc(args: list[str]) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add a default pylintrc with the rcfile option in a list of pylint args.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not any(&quot;--rcfile&quot; in arg for arg in args):</span>
<span class="gi">+        args.insert(0, f&quot;--rcfile={PYLINTRC}&quot;)</span>
<span class="gi">+    return args</span>


<span class="w"> </span>class _Run(LintRun):
<span class="gu">@@ -22,7 +31,11 @@ class _Run(LintRun):</span>
<span class="w"> </span>    But we want to see if the changes to the default break tests.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, args: Sequence[str], reporter: (BaseReporter | None)</span>
<span class="gd">-        =None, exit: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        args: Sequence[str],</span>
<span class="gi">+        reporter: BaseReporter | None = None,</span>
<span class="gi">+        exit: bool = True,  # pylint: disable=redefined-builtin</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        args = _add_rcfile_default_pylintrc(list(args))
<span class="w"> </span>        super().__init__(args, reporter, exit)
<span class="gh">diff --git a/pylint/testutils/checker_test_case.py b/pylint/testutils/checker_test_case.py</span>
<span class="gh">index fa4a782ae..3ffbbc44a 100644</span>
<span class="gd">--- a/pylint/testutils/checker_test_case.py</span>
<span class="gi">+++ b/pylint/testutils/checker_test_case.py</span>
<span class="gu">@@ -1,8 +1,15 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>from collections.abc import Generator, Iterator
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.constants import IS_PYPY, PY39_PLUS
<span class="w"> </span>from pylint.testutils.global_test_linter import linter
<span class="w"> </span>from pylint.testutils.output_line import MessageTest
<span class="gu">@@ -12,17 +19,29 @@ from pylint.utils import ASTWalker</span>

<span class="w"> </span>class CheckerTestCase:
<span class="w"> </span>    &quot;&quot;&quot;A base testcase class for unit testing individual checker classes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # TODO: Figure out way to type this as type[BaseChecker] while also</span>
<span class="gi">+    # setting self.checker correctly.</span>
<span class="w"> </span>    CHECKER_CLASS: Any
<span class="w"> </span>    CONFIG: dict[str, Any] = {}

<span class="gi">+    def setup_method(self) -&gt; None:</span>
<span class="gi">+        self.linter = UnittestLinter()</span>
<span class="gi">+        self.checker = self.CHECKER_CLASS(self.linter)</span>
<span class="gi">+        for key, value in self.CONFIG.items():</span>
<span class="gi">+            setattr(self.checker.linter.config, key, value)</span>
<span class="gi">+        self.checker.open()</span>
<span class="gi">+</span>
<span class="w"> </span>    @contextlib.contextmanager
<span class="gd">-    def assertNoMessages(self) -&gt;Iterator[None]:</span>
<span class="gi">+    def assertNoMessages(self) -&gt; Iterator[None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Assert that no messages are added by the given method.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.assertAddsMessages():</span>
<span class="gi">+            yield</span>

<span class="w"> </span>    @contextlib.contextmanager
<span class="gd">-    def assertAddsMessages(self, *messages: MessageTest, ignore_position:</span>
<span class="gd">-        bool=False) -&gt;Generator[None, None, None]:</span>
<span class="gi">+    def assertAddsMessages(</span>
<span class="gi">+        self, *messages: MessageTest, ignore_position: bool = False</span>
<span class="gi">+    ) -&gt; Generator[None, None, None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Assert that exactly the given method adds the given messages.

<span class="w"> </span>        The list of messages must exactly match *all* the messages added by the
<span class="gu">@@ -33,8 +52,36 @@ class CheckerTestCase:</span>
<span class="w"> </span>        arguments (line, col_offset, ...) will be skipped. This can be used to
<span class="w"> </span>        just test messages for the correct node.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        yield</span>
<span class="gi">+        got = self.linter.release_messages()</span>
<span class="gi">+        no_msg = &quot;No message.&quot;</span>
<span class="gi">+        expected = &quot;\n&quot;.join(repr(m) for m in messages) or no_msg</span>
<span class="gi">+        got_str = &quot;\n&quot;.join(repr(m) for m in got) or no_msg</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            &quot;Expected messages did not match actual.\n&quot;</span>
<span class="gi">+            f&quot;\nExpected:\n{expected}\n\nGot:\n{got_str}\n&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        assert len(messages) == len(got), msg</span>
<span class="gi">+</span>
<span class="gi">+        for expected_msg, gotten_msg in zip(messages, got):</span>
<span class="gi">+            assert expected_msg.msg_id == gotten_msg.msg_id, msg</span>
<span class="gi">+            assert expected_msg.node == gotten_msg.node, msg</span>
<span class="gi">+            assert expected_msg.args == gotten_msg.args, msg</span>
<span class="gi">+            assert expected_msg.confidence == gotten_msg.confidence, msg</span>
<span class="gi">+</span>
<span class="gi">+            if ignore_position:</span>
<span class="gi">+                # Do not check for line, col_offset etc...</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            assert expected_msg.line == gotten_msg.line, msg</span>
<span class="gi">+            assert expected_msg.col_offset == gotten_msg.col_offset, msg</span>
<span class="gi">+            if not IS_PYPY or PY39_PLUS:</span>
<span class="gi">+                assert expected_msg.end_line == gotten_msg.end_line, msg</span>
<span class="gi">+                assert expected_msg.end_col_offset == gotten_msg.end_col_offset, msg</span>

<span class="gd">-    def walk(self, node: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+    def walk(self, node: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Recursive walk on the given node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        walker = ASTWalker(linter)</span>
<span class="gi">+        walker.add_checker(self.checker)</span>
<span class="gi">+        walker.walk(node)</span>
<span class="gh">diff --git a/pylint/testutils/configuration_test.py b/pylint/testutils/configuration_test.py</span>
<span class="gh">index 3c00e103a..a38c8646b 100644</span>
<span class="gd">--- a/pylint/testutils/configuration_test.py</span>
<span class="gi">+++ b/pylint/testutils/configuration_test.py</span>
<span class="gu">@@ -1,5 +1,11 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Utility functions for configuration testing.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import copy
<span class="w"> </span>import json
<span class="w"> </span>import logging
<span class="gu">@@ -7,40 +13,140 @@ import unittest</span>
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Any, Dict
<span class="w"> </span>from unittest.mock import Mock
<span class="gi">+</span>
<span class="w"> </span>from pylint.lint import Run
<span class="gi">+</span>
<span class="gi">+# We use Any in this typing because the configuration contains real objects and constants</span>
<span class="gi">+# that could be a lot of things.</span>
<span class="w"> </span>ConfigurationValue = Any
<span class="w"> </span>PylintConfiguration = Dict[str, ConfigurationValue]


<span class="gd">-def get_expected_or_default(tested_configuration_file: (str | Path), suffix:</span>
<span class="gd">-    str, default: str) -&gt;str:</span>
<span class="gi">+def get_expected_or_default(</span>
<span class="gi">+    tested_configuration_file: str | Path,</span>
<span class="gi">+    suffix: str,</span>
<span class="gi">+    default: str,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the expected value from the file if it exists, or the given default.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    expected = default</span>
<span class="gi">+    path = Path(tested_configuration_file)</span>
<span class="gi">+    expected_result_path = path.parent / f&quot;{path.stem}.{suffix}&quot;</span>
<span class="gi">+    if expected_result_path.exists():</span>
<span class="gi">+        with open(expected_result_path, encoding=&quot;utf8&quot;) as f:</span>
<span class="gi">+            expected = f.read()</span>
<span class="gi">+        # logging is helpful to realize your file is not taken into</span>
<span class="gi">+        # account after a misspelling of the file name. The output of the</span>
<span class="gi">+        # program is checked during the test so printing messes with the result.</span>
<span class="gi">+        logging.info(&quot;%s exists.&quot;, expected_result_path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        logging.info(&quot;%s not found, using &#39;%s&#39;.&quot;, expected_result_path, default)</span>
<span class="gi">+    return expected</span>


<span class="gd">-EXPECTED_CONF_APPEND_KEY = &#39;functional_append&#39;</span>
<span class="gd">-EXPECTED_CONF_REMOVE_KEY = &#39;functional_remove&#39;</span>
<span class="gi">+EXPECTED_CONF_APPEND_KEY = &quot;functional_append&quot;</span>
<span class="gi">+EXPECTED_CONF_REMOVE_KEY = &quot;functional_remove&quot;</span>


<span class="gd">-def get_expected_configuration(configuration_path: str,</span>
<span class="gd">-    default_configuration: PylintConfiguration) -&gt;PylintConfiguration:</span>
<span class="gi">+def get_expected_configuration(</span>
<span class="gi">+    configuration_path: str, default_configuration: PylintConfiguration</span>
<span class="gi">+) -&gt; PylintConfiguration:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the expected parsed configuration of a configuration functional test.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = copy.deepcopy(default_configuration)</span>
<span class="gi">+    config_as_json = get_expected_or_default(</span>
<span class="gi">+        configuration_path, suffix=&quot;result.json&quot;, default=&quot;{}&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    to_override = json.loads(config_as_json)</span>
<span class="gi">+    for key, value in to_override.items():</span>
<span class="gi">+        if key == EXPECTED_CONF_APPEND_KEY:</span>
<span class="gi">+            for fkey, fvalue in value.items():</span>
<span class="gi">+                result[fkey] += fvalue</span>
<span class="gi">+        elif key == EXPECTED_CONF_REMOVE_KEY:</span>
<span class="gi">+            for fkey, fvalue in value.items():</span>
<span class="gi">+                new_value = []</span>
<span class="gi">+                for old_value in result[fkey]:</span>
<span class="gi">+                    if old_value not in fvalue:</span>
<span class="gi">+                        new_value.append(old_value)</span>
<span class="gi">+                result[fkey] = new_value</span>
<span class="gi">+        else:</span>
<span class="gi">+            result[key] = value</span>
<span class="gi">+    return result</span>


<span class="gd">-def get_related_files(tested_configuration_file: (str | Path),</span>
<span class="gd">-    suffix_filter: str) -&gt;list[Path]:</span>
<span class="gi">+def get_related_files(</span>
<span class="gi">+    tested_configuration_file: str | Path, suffix_filter: str</span>
<span class="gi">+) -&gt; list[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return all the file related to a test conf file ending with a suffix.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    conf_path = Path(tested_configuration_file)</span>
<span class="gi">+    return [</span>
<span class="gi">+        p</span>
<span class="gi">+        for p in conf_path.parent.iterdir()</span>
<span class="gi">+        if str(p.stem).startswith(conf_path.stem) and str(p).endswith(suffix_filter)</span>
<span class="gi">+    ]</span>


<span class="gd">-def get_expected_output(configuration_path: (str | Path),</span>
<span class="gd">-    user_specific_path: Path) -&gt;tuple[int, str]:</span>
<span class="gi">+def get_expected_output(</span>
<span class="gi">+    configuration_path: str | Path, user_specific_path: Path</span>
<span class="gi">+) -&gt; tuple[int, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the expected output of a functional test.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    exit_code = 0</span>
<span class="gi">+    msg = (</span>
<span class="gi">+        &quot;we expect a single file of the form &#39;filename.32.out&#39; where &#39;filename&#39; represents &quot;</span>
<span class="gi">+        &quot;the name of the configuration file, and &#39;32&#39; the expected error code.&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    possible_out_files = get_related_files(configuration_path, suffix_filter=&quot;out&quot;)</span>
<span class="gi">+    if len(possible_out_files) &gt; 1:</span>
<span class="gi">+        logging.error(</span>
<span class="gi">+            &quot;Too much .out files for %s %s.&quot;,</span>
<span class="gi">+            configuration_path,</span>
<span class="gi">+            msg,</span>
<span class="gi">+        )</span>
<span class="gi">+        return -1, &quot;out file is broken&quot;</span>
<span class="gi">+    if not possible_out_files:</span>
<span class="gi">+        # logging is helpful to see what the expected exit code is and why.</span>
<span class="gi">+        # The output of the program is checked during the test so printing</span>
<span class="gi">+        # messes with the result.</span>
<span class="gi">+        logging.info(&quot;.out file does not exists, so the expected exit code is 0&quot;)</span>
<span class="gi">+        return 0, &quot;&quot;</span>
<span class="gi">+    path = possible_out_files[0]</span>
<span class="gi">+    try:</span>
<span class="gi">+        exit_code = int(str(path.stem).rsplit(&quot;.&quot;, maxsplit=1)[-1])</span>
<span class="gi">+    except Exception as e:  # pylint: disable=broad-except</span>
<span class="gi">+        logging.error(</span>
<span class="gi">+            &quot;Wrong format for .out file name for %s %s: %s&quot;,</span>
<span class="gi">+            configuration_path,</span>
<span class="gi">+            msg,</span>
<span class="gi">+            e,</span>
<span class="gi">+        )</span>
<span class="gi">+        return -1, &quot;out file is broken&quot;</span>
<span class="gi">+</span>
<span class="gi">+    output = get_expected_or_default(</span>
<span class="gi">+        configuration_path, suffix=f&quot;{exit_code}.out&quot;, default=&quot;&quot;</span>
<span class="gi">+    )</span>
<span class="gi">+    logging.info(</span>
<span class="gi">+        &quot;Output exists for %s so the expected exit code is %s&quot;,</span>
<span class="gi">+        configuration_path,</span>
<span class="gi">+        exit_code,</span>
<span class="gi">+    )</span>
<span class="gi">+    return exit_code, output.format(</span>
<span class="gi">+        abspath=configuration_path,</span>
<span class="gi">+        relpath=Path(configuration_path).relative_to(user_specific_path),</span>
<span class="gi">+    )</span>


<span class="gd">-def run_using_a_configuration_file(configuration_path: (Path | str),</span>
<span class="gd">-    file_to_lint: str=__file__) -&gt;tuple[Mock, Mock, Run]:</span>
<span class="gi">+def run_using_a_configuration_file(</span>
<span class="gi">+    configuration_path: Path | str, file_to_lint: str = __file__</span>
<span class="gi">+) -&gt; tuple[Mock, Mock, Run]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Simulate a run with a configuration without really launching the checks.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    configuration_path = str(configuration_path)</span>
<span class="gi">+    args = [&quot;--rcfile&quot;, configuration_path, file_to_lint]</span>
<span class="gi">+    # We do not capture the `SystemExit` as then the `runner` variable</span>
<span class="gi">+    # would not be accessible outside the `with` block.</span>
<span class="gi">+    with unittest.mock.patch(&quot;sys.exit&quot;) as mocked_exit:</span>
<span class="gi">+        # Do not actually run checks, that could be slow. We don&#39;t mock</span>
<span class="gi">+        # `PyLinter.check`: it calls `PyLinter.initialize` which is</span>
<span class="gi">+        # needed to properly set up messages inclusion/exclusion</span>
<span class="gi">+        # in `_msg_states`, used by `is_message_enabled`.</span>
<span class="gi">+        check = &quot;pylint.lint.pylinter.check_parallel&quot;</span>
<span class="gi">+        with unittest.mock.patch(check) as mocked_check_parallel:</span>
<span class="gi">+            runner = Run(args)</span>
<span class="gi">+    return mocked_exit, mocked_check_parallel, runner</span>
<span class="gh">diff --git a/pylint/testutils/constants.py b/pylint/testutils/constants.py</span>
<span class="gh">index b1477583d..956b44096 100644</span>
<span class="gd">--- a/pylint/testutils/constants.py</span>
<span class="gi">+++ b/pylint/testutils/constants.py</span>
<span class="gu">@@ -1,14 +1,29 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>import operator
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>from pathlib import Path
<span class="gd">-SYS_VERS_STR = &#39;%d%d%d&#39; % sys.version_info[:3]</span>
<span class="gd">-TITLE_UNDERLINES = [&#39;&#39;, &#39;=&#39;, &#39;-&#39;, &#39;.&#39;]</span>
<span class="gd">-UPDATE_OPTION = &#39;--update-functional-output&#39;</span>
<span class="gd">-UPDATE_FILE = Path(&#39;pylint-functional-test-update&#39;)</span>
<span class="gd">-_MESSAGE = {&#39;msg&#39;: &#39;[a-z][a-z\\-]+&#39;}</span>
<span class="gi">+</span>
<span class="gi">+SYS_VERS_STR = (</span>
<span class="gi">+    &quot;%d%d%d&quot; % sys.version_info[:3]  # pylint: disable=consider-using-f-string</span>
<span class="gi">+)</span>
<span class="gi">+TITLE_UNDERLINES = [&quot;&quot;, &quot;=&quot;, &quot;-&quot;, &quot;.&quot;]</span>
<span class="gi">+UPDATE_OPTION = &quot;--update-functional-output&quot;</span>
<span class="gi">+UPDATE_FILE = Path(&quot;pylint-functional-test-update&quot;)</span>
<span class="gi">+# Common sub-expressions.</span>
<span class="gi">+_MESSAGE = {&quot;msg&quot;: r&quot;[a-z][a-z\-]+&quot;}</span>
<span class="gi">+# Matches a #,</span>
<span class="gi">+#  - followed by a comparison operator and a Python version (optional),</span>
<span class="gi">+#  - followed by a line number with a +/- (optional),</span>
<span class="gi">+#  - followed by a list of bracketed message symbols.</span>
<span class="gi">+# Used to extract expected messages from testdata files.</span>
<span class="w"> </span>_EXPECTED_RE = re.compile(
<span class="gd">-    &#39;\\s*#\\s*(?:(?P&lt;line&gt;[+-]?[0-9]+):)?(?:(?P&lt;op&gt;[&gt;&lt;=]+) *(?P&lt;version&gt;[0-9.]+):)?\\s*\\[(?P&lt;msgs&gt;{msg}(?:,\\s*{msg})*)]&#39;</span>
<span class="gd">-    .format(**_MESSAGE))</span>
<span class="gd">-_OPERATORS = {&#39;&gt;&#39;: operator.gt, &#39;&lt;&#39;: operator.lt, &#39;&gt;=&#39;: operator.ge, &#39;&lt;=&#39;:</span>
<span class="gd">-    operator.le}</span>
<span class="gi">+    r&quot;\s*#\s*(?:(?P&lt;line&gt;[+-]?[0-9]+):)?&quot;  # pylint: disable=consider-using-f-string</span>
<span class="gi">+    r&quot;(?:(?P&lt;op&gt;[&gt;&lt;=]+) *(?P&lt;version&gt;[0-9.]+):)?&quot;</span>
<span class="gi">+    r&quot;\s*\[(?P&lt;msgs&gt;{msg}(?:,\s*{msg})*)]&quot;.format(**_MESSAGE)</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+_OPERATORS = {&quot;&gt;&quot;: operator.gt, &quot;&lt;&quot;: operator.lt, &quot;&gt;=&quot;: operator.ge, &quot;&lt;=&quot;: operator.le}</span>
<span class="gh">diff --git a/pylint/testutils/decorator.py b/pylint/testutils/decorator.py</span>
<span class="gh">index 50a300f10..c20692132 100644</span>
<span class="gd">--- a/pylint/testutils/decorator.py</span>
<span class="gi">+++ b/pylint/testutils/decorator.py</span>
<span class="gu">@@ -1,15 +1,37 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>from collections.abc import Callable
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from pylint.testutils.checker_test_case import CheckerTestCase


<span class="gd">-def set_config(**kwargs: Any) -&gt;Callable[[Callable[..., None]], Callable[</span>
<span class="gd">-    ..., None]]:</span>
<span class="gi">+def set_config(**kwargs: Any) -&gt; Callable[[Callable[..., None]], Callable[..., None]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Decorator for setting an option on the linter.

<span class="w"> </span>    Passing the args and kwargs back to the test function itself
<span class="w"> </span>    allows this decorator to be used on parameterized test cases.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    def _wrapper(fun: Callable[..., None]) -&gt; Callable[..., None]:</span>
<span class="gi">+        @functools.wraps(fun)</span>
<span class="gi">+        def _forward(</span>
<span class="gi">+            self: CheckerTestCase, *args: Any, **test_function_kwargs: Any</span>
<span class="gi">+        ) -&gt; None:</span>
<span class="gi">+            &quot;&quot;&quot;Set option via argparse.&quot;&quot;&quot;</span>
<span class="gi">+            for key, value in kwargs.items():</span>
<span class="gi">+                self.linter.set_option(key, value)</span>
<span class="gi">+</span>
<span class="gi">+            # Reopen checker in case, it may be interested in configuration change</span>
<span class="gi">+            self.checker.open()</span>
<span class="gi">+</span>
<span class="gi">+            fun(self, *args, **test_function_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return _forward</span>
<span class="gi">+</span>
<span class="gi">+    return _wrapper</span>
<span class="gh">diff --git a/pylint/testutils/functional/find_functional_tests.py b/pylint/testutils/functional/find_functional_tests.py</span>
<span class="gh">index 79a06c358..f2e636687 100644</span>
<span class="gd">--- a/pylint/testutils/functional/find_functional_tests.py</span>
<span class="gi">+++ b/pylint/testutils/functional/find_functional_tests.py</span>
<span class="gu">@@ -1,31 +1,139 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from collections.abc import Iterator
<span class="w"> </span>from pathlib import Path
<span class="gi">+</span>
<span class="w"> </span>from pylint.testutils.functional.test_file import FunctionalTestFile
<span class="gi">+</span>
<span class="w"> </span>REASONABLY_DISPLAYABLE_VERTICALLY = 49
<span class="w"> </span>&quot;&quot;&quot;&#39;Wet finger&#39; number of files that are reasonable to display by an IDE.

<span class="w"> </span>&#39;Wet finger&#39; as in &#39;in my settings there are precisely this many&#39;.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-IGNORED_PARENT_DIRS = {&#39;deprecated_relative_import&#39;, &#39;ext&#39;, &#39;regression&#39;,</span>
<span class="gd">-    &#39;regression_02&#39;}</span>
<span class="gi">+</span>
<span class="gi">+IGNORED_PARENT_DIRS = {</span>
<span class="gi">+    &quot;deprecated_relative_import&quot;,</span>
<span class="gi">+    &quot;ext&quot;,</span>
<span class="gi">+    &quot;regression&quot;,</span>
<span class="gi">+    &quot;regression_02&quot;,</span>
<span class="gi">+}</span>
<span class="w"> </span>&quot;&quot;&quot;Direct parent directories that should be ignored.&quot;&quot;&quot;
<span class="gd">-IGNORED_PARENT_PARENT_DIRS = {&#39;docparams&#39;, &#39;deprecated_relative_import&#39;, &#39;ext&#39;}</span>
<span class="gi">+</span>
<span class="gi">+IGNORED_PARENT_PARENT_DIRS = {</span>
<span class="gi">+    &quot;docparams&quot;,</span>
<span class="gi">+    &quot;deprecated_relative_import&quot;,</span>
<span class="gi">+    &quot;ext&quot;,</span>
<span class="gi">+}</span>
<span class="w"> </span>&quot;&quot;&quot;Parents of direct parent directories that should be ignored.&quot;&quot;&quot;


<span class="gd">-def get_functional_test_files_from_directory(input_dir: (Path | str),</span>
<span class="gd">-    max_file_per_directory: int=REASONABLY_DISPLAYABLE_VERTICALLY) -&gt;list[</span>
<span class="gd">-    FunctionalTestFile]:</span>
<span class="gi">+def get_functional_test_files_from_directory(</span>
<span class="gi">+    input_dir: Path | str,</span>
<span class="gi">+    max_file_per_directory: int = REASONABLY_DISPLAYABLE_VERTICALLY,</span>
<span class="gi">+) -&gt; list[FunctionalTestFile]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get all functional tests in the input_dir.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    suite = []</span>
<span class="gi">+</span>
<span class="gi">+    _check_functional_tests_structure(Path(input_dir), max_file_per_directory)</span>

<span class="gi">+    for dirpath, dirnames, filenames in os.walk(input_dir):</span>
<span class="gi">+        if dirpath.endswith(&quot;__pycache__&quot;):</span>
<span class="gi">+            continue</span>
<span class="gi">+        dirnames.sort()</span>
<span class="gi">+        filenames.sort()</span>
<span class="gi">+        for filename in filenames:</span>
<span class="gi">+            if filename != &quot;__init__.py&quot; and filename.endswith(&quot;.py&quot;):</span>
<span class="gi">+                suite.append(FunctionalTestFile(dirpath, filename))</span>
<span class="gi">+    return suite</span>

<span class="gd">-def _check_functional_tests_structure(directory: Path,</span>
<span class="gd">-    max_file_per_directory: int) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def _check_functional_tests_structure(</span>
<span class="gi">+    directory: Path, max_file_per_directory: int</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if test directories follow correct file/folder structure.

<span class="w"> </span>    Ignore underscored directories or files.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if Path(directory).stem.startswith(&quot;_&quot;):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    files: set[Path] = set()</span>
<span class="gi">+    dirs: set[Path] = set()</span>
<span class="gi">+</span>
<span class="gi">+    def _get_files_from_dir(</span>
<span class="gi">+        path: Path, violations: list[tuple[Path, int]]</span>
<span class="gi">+    ) -&gt; list[Path]:</span>
<span class="gi">+        &quot;&quot;&quot;Return directories and files from a directory and handles violations.&quot;&quot;&quot;</span>
<span class="gi">+        files_without_leading_underscore = list(</span>
<span class="gi">+            p for p in path.iterdir() if not p.stem.startswith(&quot;_&quot;)</span>
<span class="gi">+        )</span>
<span class="gi">+        if len(files_without_leading_underscore) &gt; max_file_per_directory:</span>
<span class="gi">+            violations.append((path, len(files_without_leading_underscore)))</span>
<span class="gi">+        return files_without_leading_underscore</span>
<span class="gi">+</span>
<span class="gi">+    def walk(path: Path) -&gt; Iterator[Path]:</span>
<span class="gi">+        violations: list[tuple[Path, int]] = []</span>
<span class="gi">+        violations_msgs: set[str] = set()</span>
<span class="gi">+        parent_dir_files = _get_files_from_dir(path, violations)</span>
<span class="gi">+        error_msg = (</span>
<span class="gi">+            &quot;The following directory contains too many functional tests files:\n&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+        for _file_or_dir in parent_dir_files:</span>
<span class="gi">+            if _file_or_dir.is_dir():</span>
<span class="gi">+                _files = _get_files_from_dir(_file_or_dir, violations)</span>
<span class="gi">+                yield _file_or_dir.resolve()</span>
<span class="gi">+                try:</span>
<span class="gi">+                    yield from walk(_file_or_dir)</span>
<span class="gi">+                except AssertionError as e:</span>
<span class="gi">+                    violations_msgs.add(str(e).replace(error_msg, &quot;&quot;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield _file_or_dir.resolve()</span>
<span class="gi">+        if violations or violations_msgs:</span>
<span class="gi">+            _msg = error_msg</span>
<span class="gi">+            for offending_file, number in violations:</span>
<span class="gi">+                _msg += f&quot;- {offending_file}: {number} when the max is {max_file_per_directory}\n&quot;</span>
<span class="gi">+            for error_msg in violations_msgs:</span>
<span class="gi">+                _msg += error_msg</span>
<span class="gi">+            raise AssertionError(_msg)</span>
<span class="gi">+</span>
<span class="gi">+    # Collect all sub-directories and files in directory</span>
<span class="gi">+    for file_or_dir in walk(directory):</span>
<span class="gi">+        if file_or_dir.is_dir():</span>
<span class="gi">+            dirs.add(file_or_dir)</span>
<span class="gi">+        elif file_or_dir.suffix == &quot;.py&quot;:</span>
<span class="gi">+            files.add(file_or_dir)</span>
<span class="gi">+</span>
<span class="gi">+    directory_does_not_exists: list[tuple[Path, Path]] = []</span>
<span class="gi">+    misplaced_file: list[Path] = []</span>
<span class="gi">+    for file in files:</span>
<span class="gi">+        possible_dir = file.parent / file.stem.split(&quot;_&quot;)[0]</span>
<span class="gi">+        if possible_dir.exists():</span>
<span class="gi">+            directory_does_not_exists.append((file, possible_dir))</span>
<span class="gi">+        # Exclude some directories as they follow a different structure</span>
<span class="gi">+        if (</span>
<span class="gi">+            not len(file.parent.stem) == 1  # First letter sub-directories</span>
<span class="gi">+            and file.parent.stem not in IGNORED_PARENT_DIRS</span>
<span class="gi">+            and file.parent.parent.stem not in IGNORED_PARENT_PARENT_DIRS</span>
<span class="gi">+        ):</span>
<span class="gi">+            if not file.stem.startswith(file.parent.stem):</span>
<span class="gi">+                misplaced_file.append(file)</span>
<span class="gi">+</span>
<span class="gi">+    if directory_does_not_exists or misplaced_file:</span>
<span class="gi">+        msg = &quot;The following functional tests are disorganized:\n&quot;</span>
<span class="gi">+        for file, possible_dir in directory_does_not_exists:</span>
<span class="gi">+            msg += (</span>
<span class="gi">+                f&quot;- In &#39;{directory}&#39;, &#39;{file.relative_to(directory)}&#39; &quot;</span>
<span class="gi">+                f&quot;should go in &#39;{possible_dir.relative_to(directory)}&#39;\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        for file in misplaced_file:</span>
<span class="gi">+            msg += (</span>
<span class="gi">+                f&quot;- In &#39;{directory}&#39;, {file.relative_to(directory)} should go in a directory&quot;</span>
<span class="gi">+                f&quot; that starts with the first letters&quot;</span>
<span class="gi">+                f&quot; of &#39;{file.stem}&#39; (not &#39;{file.parent.stem}&#39;)\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        raise AssertionError(msg)</span>
<span class="gh">diff --git a/pylint/testutils/functional/lint_module_output_update.py b/pylint/testutils/functional/lint_module_output_update.py</span>
<span class="gh">index d8e3eb6ac..38ed465aa 100644</span>
<span class="gd">--- a/pylint/testutils/functional/lint_module_output_update.py</span>
<span class="gi">+++ b/pylint/testutils/functional/lint_module_output_update.py</span>
<span class="gu">@@ -1,6 +1,12 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import csv
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="w"> </span>from pylint.testutils.lint_module_test import LintModuleTest, MessageCounter
<span class="w"> </span>from pylint.testutils.output_line import OutputLine

<span class="gu">@@ -10,14 +16,28 @@ class LintModuleOutputUpdate(LintModuleTest):</span>
<span class="w"> </span>    checked.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="w"> </span>    class TestDialect(csv.excel):
<span class="w"> </span>        &quot;&quot;&quot;Dialect used by the csv writer.&quot;&quot;&quot;
<span class="gd">-        delimiter = &#39;:&#39;</span>
<span class="gd">-        lineterminator = &#39;\n&#39;</span>
<span class="gd">-    csv.register_dialect(&#39;test&#39;, TestDialect)</span>

<span class="gd">-    def _check_output_text(self, _: MessageCounter, expected_output: list[</span>
<span class="gd">-        OutputLine], actual_output: list[OutputLine]) -&gt;None:</span>
<span class="gi">+        delimiter = &quot;:&quot;</span>
<span class="gi">+        lineterminator = &quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+    csv.register_dialect(&quot;test&quot;, TestDialect)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_output_text(</span>
<span class="gi">+        self,</span>
<span class="gi">+        _: MessageCounter,</span>
<span class="gi">+        expected_output: list[OutputLine],</span>
<span class="gi">+        actual_output: list[OutputLine],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Overwrite or remove the expected output file based on actual output.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Remove the expected file if no output is actually emitted and a file exists</span>
<span class="gi">+        if not actual_output:</span>
<span class="gi">+            if os.path.exists(self._test_file.expected_output):</span>
<span class="gi">+                os.remove(self._test_file.expected_output)</span>
<span class="gi">+            return</span>
<span class="gi">+        # Write file with expected output</span>
<span class="gi">+        with open(self._test_file.expected_output, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+            writer = csv.writer(f, dialect=&quot;test&quot;)</span>
<span class="gi">+            for line in actual_output:</span>
<span class="gi">+                writer.writerow(line.to_csv())</span>
<span class="gh">diff --git a/pylint/testutils/functional/test_file.py b/pylint/testutils/functional/test_file.py</span>
<span class="gh">index 6fe0e17be..37ba3a5fc 100644</span>
<span class="gd">--- a/pylint/testutils/functional/test_file.py</span>
<span class="gi">+++ b/pylint/testutils/functional/test_file.py</span>
<span class="gu">@@ -1,13 +1,18 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import configparser
<span class="w"> </span>from collections.abc import Callable
<span class="w"> </span>from os.path import basename, exists, join
<span class="w"> </span>from typing import TypedDict


<span class="gd">-def parse_python_version(ver_str: str) -&gt;tuple[int, ...]:</span>
<span class="gi">+def parse_python_version(ver_str: str) -&gt; tuple[int, ...]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert python version to a tuple of integers for easy comparison.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return tuple(int(digit) for digit in ver_str.split(&quot;.&quot;))</span>


<span class="w"> </span>class NoFileError(Exception):
<span class="gu">@@ -24,29 +29,84 @@ class TestFileOptions(TypedDict):</span>
<span class="w"> </span>    exclude_from_minimal_messages_config: bool


<span class="gd">-POSSIBLE_TEST_OPTIONS = {&#39;min_pyver&#39;, &#39;max_pyver&#39;, &#39;min_pyver_end_position&#39;,</span>
<span class="gd">-    &#39;requires&#39;, &#39;except_implementations&#39;, &#39;exclude_platforms&#39;,</span>
<span class="gd">-    &#39;exclude_from_minimal_messages_config&#39;}</span>
<span class="gi">+# mypy need something literal, we can&#39;t create this dynamically from TestFileOptions</span>
<span class="gi">+POSSIBLE_TEST_OPTIONS = {</span>
<span class="gi">+    &quot;min_pyver&quot;,</span>
<span class="gi">+    &quot;max_pyver&quot;,</span>
<span class="gi">+    &quot;min_pyver_end_position&quot;,</span>
<span class="gi">+    &quot;requires&quot;,</span>
<span class="gi">+    &quot;except_implementations&quot;,</span>
<span class="gi">+    &quot;exclude_platforms&quot;,</span>
<span class="gi">+    &quot;exclude_from_minimal_messages_config&quot;,</span>
<span class="gi">+}</span>


<span class="w"> </span>class FunctionalTestFile:
<span class="w"> </span>    &quot;&quot;&quot;A single functional test case file with options.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _CONVERTERS: dict[str, Callable[[str], tuple[int, ...] | list[str]]] = {
<span class="gd">-        &#39;min_pyver&#39;: parse_python_version, &#39;max_pyver&#39;:</span>
<span class="gd">-        parse_python_version, &#39;min_pyver_end_position&#39;:</span>
<span class="gd">-        parse_python_version, &#39;requires&#39;: lambda s: [i.strip() for i in s.</span>
<span class="gd">-        split(&#39;,&#39;)], &#39;except_implementations&#39;: lambda s: [i.strip() for i in</span>
<span class="gd">-        s.split(&#39;,&#39;)], &#39;exclude_platforms&#39;: lambda s: [i.strip() for i in s</span>
<span class="gd">-        .split(&#39;,&#39;)]}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, directory: str, filename: str) -&gt;None:</span>
<span class="gi">+        &quot;min_pyver&quot;: parse_python_version,</span>
<span class="gi">+        &quot;max_pyver&quot;: parse_python_version,</span>
<span class="gi">+        &quot;min_pyver_end_position&quot;: parse_python_version,</span>
<span class="gi">+        &quot;requires&quot;: lambda s: [i.strip() for i in s.split(&quot;,&quot;)],</span>
<span class="gi">+        &quot;except_implementations&quot;: lambda s: [i.strip() for i in s.split(&quot;,&quot;)],</span>
<span class="gi">+        &quot;exclude_platforms&quot;: lambda s: [i.strip() for i in s.split(&quot;,&quot;)],</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, directory: str, filename: str) -&gt; None:</span>
<span class="w"> </span>        self._directory = directory
<span class="gd">-        self.base = filename.replace(&#39;.py&#39;, &#39;&#39;)</span>
<span class="gd">-        self.options: TestFileOptions = {&#39;min_pyver&#39;: (2, 5), &#39;max_pyver&#39;:</span>
<span class="gd">-            (4, 0), &#39;min_pyver_end_position&#39;: (3, 8), &#39;requires&#39;: [],</span>
<span class="gd">-            &#39;except_implementations&#39;: [], &#39;exclude_platforms&#39;: [],</span>
<span class="gd">-            &#39;exclude_from_minimal_messages_config&#39;: False}</span>
<span class="gi">+        self.base = filename.replace(&quot;.py&quot;, &quot;&quot;)</span>
<span class="gi">+        # TODO:4.0: Deprecate FunctionalTestFile.options and related code</span>
<span class="gi">+        # We should just parse these options like a normal configuration file.</span>
<span class="gi">+        self.options: TestFileOptions = {</span>
<span class="gi">+            &quot;min_pyver&quot;: (2, 5),</span>
<span class="gi">+            &quot;max_pyver&quot;: (4, 0),</span>
<span class="gi">+            &quot;min_pyver_end_position&quot;: (3, 8),</span>
<span class="gi">+            &quot;requires&quot;: [],</span>
<span class="gi">+            &quot;except_implementations&quot;: [],</span>
<span class="gi">+            &quot;exclude_platforms&quot;: [],</span>
<span class="gi">+            &quot;exclude_from_minimal_messages_config&quot;: False,</span>
<span class="gi">+        }</span>
<span class="w"> </span>        self._parse_options()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return f&#39;FunctionalTest:{self.base}&#39;</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;FunctionalTest:{self.base}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_options(self) -&gt; None:</span>
<span class="gi">+        cp = configparser.ConfigParser()</span>
<span class="gi">+        cp.add_section(&quot;testoptions&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            cp.read(self.option_file)</span>
<span class="gi">+        except NoFileError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        for name, value in cp.items(&quot;testoptions&quot;):</span>
<span class="gi">+            conv = self._CONVERTERS.get(name, lambda v: v)</span>
<span class="gi">+</span>
<span class="gi">+            assert (</span>
<span class="gi">+                name in POSSIBLE_TEST_OPTIONS</span>
<span class="gi">+            ), f&quot;[testoptions]&#39; can only contains one of {POSSIBLE_TEST_OPTIONS} and had &#39;{name}&#39;&quot;</span>
<span class="gi">+            self.options[name] = conv(value)  # type: ignore[literal-required]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def option_file(self) -&gt; str:</span>
<span class="gi">+        return self._file_type(&quot;.rc&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def module(self) -&gt; str:</span>
<span class="gi">+        package = basename(self._directory)</span>
<span class="gi">+        return &quot;.&quot;.join([package, self.base])</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def expected_output(self) -&gt; str:</span>
<span class="gi">+        return self._file_type(&quot;.txt&quot;, check_exists=False)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def source(self) -&gt; str:</span>
<span class="gi">+        return self._file_type(&quot;.py&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _file_type(self, ext: str, check_exists: bool = True) -&gt; str:</span>
<span class="gi">+        name = join(self._directory, self.base + ext)</span>
<span class="gi">+        if not check_exists or exists(name):</span>
<span class="gi">+            return name</span>
<span class="gi">+        raise NoFileError(f&quot;Cannot find &#39;{name}&#39;.&quot;)</span>
<span class="gh">diff --git a/pylint/testutils/get_test_info.py b/pylint/testutils/get_test_info.py</span>
<span class="gh">index 4d1b573f1..eb2c78cfd 100644</span>
<span class="gd">--- a/pylint/testutils/get_test_info.py</span>
<span class="gi">+++ b/pylint/testutils/get_test_info.py</span>
<span class="gu">@@ -1,11 +1,18 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from glob import glob
<span class="w"> </span>from os.path import basename, join, splitext
<span class="gi">+</span>
<span class="w"> </span>from pylint.testutils.constants import SYS_VERS_STR


<span class="gd">-def _get_tests_info(input_dir: str, msg_dir: str, prefix: str, suffix: str</span>
<span class="gd">-    ) -&gt;list[tuple[str, str]]:</span>
<span class="gi">+def _get_tests_info(</span>
<span class="gi">+    input_dir: str, msg_dir: str, prefix: str, suffix: str</span>
<span class="gi">+) -&gt; list[tuple[str, str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get python input examples and output messages.

<span class="w"> </span>    We use following conventions for input files and messages:
<span class="gu">@@ -16,4 +23,28 @@ def _get_tests_info(input_dir: str, msg_dir: str, prefix: str, suffix: str</span>
<span class="w"> </span>        message for python &gt;=  x.y -&gt;  message =  &lt;name&gt;_pyxy.txt
<span class="w"> </span>        lower versions             -&gt;  message with highest num
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for fname in glob(join(input_dir, prefix + &quot;*&quot; + suffix)):</span>
<span class="gi">+        infile = basename(fname)</span>
<span class="gi">+        fbase = splitext(infile)[0]</span>
<span class="gi">+        # filter input files :</span>
<span class="gi">+        pyrestr = fbase.rsplit(&quot;_py&quot;, 1)[-1]  # like _26 or 26</span>
<span class="gi">+        if pyrestr.isdigit():  # &#39;24&#39;, &#39;25&#39;...</span>
<span class="gi">+            if pyrestr.isdigit() and int(SYS_VERS_STR) &lt; int(pyrestr):</span>
<span class="gi">+                continue</span>
<span class="gi">+        if pyrestr.startswith(&quot;_&quot;) and pyrestr[1:].isdigit():</span>
<span class="gi">+            # skip test for higher python versions</span>
<span class="gi">+            if pyrestr[1:].isdigit() and int(SYS_VERS_STR) &gt;= int(pyrestr[1:]):</span>
<span class="gi">+                continue</span>
<span class="gi">+        messages = glob(join(msg_dir, fbase + &quot;*.txt&quot;))</span>
<span class="gi">+        # the last one will be without ext, i.e. for all or upper versions:</span>
<span class="gi">+        if messages:</span>
<span class="gi">+            for outfile in sorted(messages, reverse=True):</span>
<span class="gi">+                py_rest = outfile.rsplit(&quot;_py&quot;, 1)[-1][:-4]</span>
<span class="gi">+                if py_rest.isdigit() and int(SYS_VERS_STR) &gt;= int(py_rest):</span>
<span class="gi">+                    break</span>
<span class="gi">+        else:</span>
<span class="gi">+            # This will provide an error message indicating the missing filename.</span>
<span class="gi">+            outfile = join(msg_dir, fbase + &quot;.txt&quot;)</span>
<span class="gi">+        result.append((infile, outfile))</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/pylint/testutils/global_test_linter.py b/pylint/testutils/global_test_linter.py</span>
<span class="gh">index 6ea5f1796..2e0d3d170 100644</span>
<span class="gd">--- a/pylint/testutils/global_test_linter.py</span>
<span class="gi">+++ b/pylint/testutils/global_test_linter.py</span>
<span class="gu">@@ -1,4 +1,20 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.lint import PyLinter
<span class="w"> </span>from pylint.testutils.reporter_for_tests import GenericTestReporter
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_test_linter() -&gt; PyLinter:</span>
<span class="gi">+    test_reporter = GenericTestReporter()</span>
<span class="gi">+    linter_ = PyLinter()</span>
<span class="gi">+    linter_.set_reporter(test_reporter)</span>
<span class="gi">+    linter_.config.persistent = 0</span>
<span class="gi">+    checkers.initialize(linter_)</span>
<span class="gi">+    return linter_</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Can&#39;t be renamed to a constant (easily), it breaks countless tests</span>
<span class="w"> </span>linter = create_test_linter()
<span class="gh">diff --git a/pylint/testutils/lint_module_test.py b/pylint/testutils/lint_module_test.py</span>
<span class="gh">index 646c8986f..48ee5a0b2 100644</span>
<span class="gd">--- a/pylint/testutils/lint_module_test.py</span>
<span class="gi">+++ b/pylint/testutils/lint_module_test.py</span>
<span class="gu">@@ -1,4 +1,9 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import csv
<span class="w"> </span>import operator
<span class="w"> </span>import platform
<span class="gu">@@ -8,81 +13,150 @@ from io import StringIO</span>
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import Counter as CounterType
<span class="w"> </span>from typing import TextIO, Tuple
<span class="gi">+</span>
<span class="w"> </span>import pytest
<span class="w"> </span>from _pytest.config import Config
<span class="gi">+</span>
<span class="w"> </span>from pylint import checkers
<span class="w"> </span>from pylint.config.config_initialization import _config_initialization
<span class="w"> </span>from pylint.constants import IS_PYPY
<span class="w"> </span>from pylint.lint import PyLinter
<span class="w"> </span>from pylint.message.message import Message
<span class="w"> </span>from pylint.testutils.constants import _EXPECTED_RE, _OPERATORS, UPDATE_OPTION
<span class="gd">-from pylint.testutils.functional.test_file import FunctionalTestFile, NoFileError, parse_python_version</span>
<span class="gi">+</span>
<span class="gi">+# need to import from functional.test_file to avoid cyclic import</span>
<span class="gi">+from pylint.testutils.functional.test_file import (</span>
<span class="gi">+    FunctionalTestFile,</span>
<span class="gi">+    NoFileError,</span>
<span class="gi">+    parse_python_version,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pylint.testutils.output_line import OutputLine
<span class="w"> </span>from pylint.testutils.reporter_for_tests import FunctionalTestReporter
<span class="gi">+</span>
<span class="w"> </span>MessageCounter = CounterType[Tuple[int, str]]
<span class="gd">-PYLINTRC = Path(__file__).parent / &#39;testing_pylintrc&#39;</span>
<span class="gi">+</span>
<span class="gi">+PYLINTRC = Path(__file__).parent / &quot;testing_pylintrc&quot;</span>


<span class="w"> </span>class LintModuleTest:
<span class="w"> </span>    maxDiff = None

<span class="gd">-    def __init__(self, test_file: FunctionalTestFile, config: (Config |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, test_file: FunctionalTestFile, config: Config | None = None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        _test_reporter = FunctionalTestReporter()
<span class="w"> </span>        self._linter = PyLinter()
<span class="w"> </span>        self._linter.config.persistent = 0
<span class="w"> </span>        checkers.initialize(self._linter)
<span class="gi">+</span>
<span class="gi">+        # See if test has its own .rc file, if so we use that one</span>
<span class="w"> </span>        rc_file: Path | str = PYLINTRC
<span class="w"> </span>        try:
<span class="w"> </span>            rc_file = test_file.option_file
<span class="gd">-            self._linter.disable(&#39;suppressed-message&#39;)</span>
<span class="gd">-            self._linter.disable(&#39;locally-disabled&#39;)</span>
<span class="gd">-            self._linter.disable(&#39;useless-suppression&#39;)</span>
<span class="gi">+            self._linter.disable(&quot;suppressed-message&quot;)</span>
<span class="gi">+            self._linter.disable(&quot;locally-disabled&quot;)</span>
<span class="gi">+            self._linter.disable(&quot;useless-suppression&quot;)</span>
<span class="w"> </span>        except NoFileError:
<span class="w"> </span>            pass
<span class="gi">+</span>
<span class="w"> </span>        self._test_file = test_file
<span class="w"> </span>        try:
<span class="w"> </span>            args = [test_file.source]
<span class="w"> </span>        except NoFileError:
<span class="gd">-            args = [&#39;&#39;]</span>
<span class="gd">-        if config and config.getoption(&#39;minimal_messages_config&#39;):</span>
<span class="gi">+            # If we&#39;re still raising NoFileError the actual source file doesn&#39;t exist</span>
<span class="gi">+            args = [&quot;&quot;]</span>
<span class="gi">+        if config and config.getoption(&quot;minimal_messages_config&quot;):</span>
<span class="w"> </span>            with self._open_source_file() as f:
<span class="gd">-                messages_to_enable = {msg[1] for msg in self.</span>
<span class="gd">-                    get_expected_messages(f)}</span>
<span class="gd">-                messages_to_enable.add(&#39;astroid-error&#39;)</span>
<span class="gd">-                messages_to_enable.add(&#39;fatal&#39;)</span>
<span class="gd">-                messages_to_enable.add(&#39;syntax-error&#39;)</span>
<span class="gd">-            args.extend([&#39;--disable=all&#39;,</span>
<span class="gd">-                f&quot;--enable={&#39;,&#39;.join(messages_to_enable)}&quot;])</span>
<span class="gd">-        self._linter._arg_parser.add_argument(&#39;--min_pyver&#39;, type=</span>
<span class="gd">-            parse_python_version, default=(2, 5))</span>
<span class="gd">-        self._linter._arg_parser.add_argument(&#39;--max_pyver&#39;, type=</span>
<span class="gd">-            parse_python_version, default=(4, 0))</span>
<span class="gd">-        self._linter._arg_parser.add_argument(&#39;--min_pyver_end_position&#39;,</span>
<span class="gd">-            type=parse_python_version, default=(3, 8))</span>
<span class="gd">-        self._linter._arg_parser.add_argument(&#39;--requires&#39;, type=lambda s:</span>
<span class="gd">-            [i.strip() for i in s.split(&#39;,&#39;)], default=[])</span>
<span class="gd">-        self._linter._arg_parser.add_argument(&#39;--except_implementations&#39;,</span>
<span class="gd">-            type=lambda s: [i.strip() for i in s.split(&#39;,&#39;)], default=[])</span>
<span class="gd">-        self._linter._arg_parser.add_argument(&#39;--exclude_platforms&#39;, type=</span>
<span class="gd">-            lambda s: [i.strip() for i in s.split(&#39;,&#39;)], default=[])</span>
<span class="gi">+                messages_to_enable = {msg[1] for msg in self.get_expected_messages(f)}</span>
<span class="gi">+                # Always enable fatal errors</span>
<span class="gi">+                messages_to_enable.add(&quot;astroid-error&quot;)</span>
<span class="gi">+                messages_to_enable.add(&quot;fatal&quot;)</span>
<span class="gi">+                messages_to_enable.add(&quot;syntax-error&quot;)</span>
<span class="gi">+            args.extend([&quot;--disable=all&quot;, f&quot;--enable={&#39;,&#39;.join(messages_to_enable)}&quot;])</span>
<span class="gi">+</span>
<span class="gi">+        # Add testoptions</span>
<span class="gi">+        self._linter._arg_parser.add_argument(</span>
<span class="gi">+            &quot;--min_pyver&quot;, type=parse_python_version, default=(2, 5)</span>
<span class="gi">+        )</span>
<span class="gi">+        self._linter._arg_parser.add_argument(</span>
<span class="gi">+            &quot;--max_pyver&quot;, type=parse_python_version, default=(4, 0)</span>
<span class="gi">+        )</span>
<span class="gi">+        self._linter._arg_parser.add_argument(</span>
<span class="gi">+            &quot;--min_pyver_end_position&quot;, type=parse_python_version, default=(3, 8)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._linter._arg_parser.add_argument(
<span class="gd">-            &#39;--exclude_from_minimal_messages_config&#39;, default=False)</span>
<span class="gd">-        _config_initialization(self._linter, args_list=args, config_file=</span>
<span class="gd">-            rc_file, reporter=_test_reporter)</span>
<span class="gd">-        self._check_end_position = (sys.version_info &gt;= self._linter.config</span>
<span class="gd">-            .min_pyver_end_position)</span>
<span class="gi">+            &quot;--requires&quot;, type=lambda s: [i.strip() for i in s.split(&quot;,&quot;)], default=[]</span>
<span class="gi">+        )</span>
<span class="gi">+        self._linter._arg_parser.add_argument(</span>
<span class="gi">+            &quot;--except_implementations&quot;,</span>
<span class="gi">+            type=lambda s: [i.strip() for i in s.split(&quot;,&quot;)],</span>
<span class="gi">+            default=[],</span>
<span class="gi">+        )</span>
<span class="gi">+        self._linter._arg_parser.add_argument(</span>
<span class="gi">+            &quot;--exclude_platforms&quot;,</span>
<span class="gi">+            type=lambda s: [i.strip() for i in s.split(&quot;,&quot;)],</span>
<span class="gi">+            default=[],</span>
<span class="gi">+        )</span>
<span class="gi">+        self._linter._arg_parser.add_argument(</span>
<span class="gi">+            &quot;--exclude_from_minimal_messages_config&quot;, default=False</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        _config_initialization(</span>
<span class="gi">+            self._linter, args_list=args, config_file=rc_file, reporter=_test_reporter</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        self._check_end_position = (</span>
<span class="gi">+            sys.version_info &gt;= self._linter.config.min_pyver_end_position</span>
<span class="gi">+        )</span>
<span class="gi">+        # TODO: PY3.9: PyPy supports end_lineno from 3.9 and above</span>
<span class="w"> </span>        if self._check_end_position and IS_PYPY:
<span class="gd">-            self._check_end_position = sys.version_info &gt;= (3, 9)</span>
<span class="gi">+            self._check_end_position = sys.version_info &gt;= (3, 9)  # pragma: no cover</span>
<span class="gi">+</span>
<span class="w"> </span>        self._config = config

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self._test_file.base} ({self.__class__.__module__}.{self.__class__.__name__})&#39;</span>
<span class="gi">+    def setUp(self) -&gt; None:</span>
<span class="gi">+        if self._should_be_skipped_due_to_version():</span>
<span class="gi">+            pytest.skip(</span>
<span class="gi">+                f&quot;Test cannot run with Python {sys.version.split(&#39; &#39;, maxsplit=1)[0]}.&quot;</span>
<span class="w"> </span>            )
<span class="gi">+        missing = []</span>
<span class="gi">+        for requirement in self._linter.config.requires:</span>
<span class="gi">+            try:</span>
<span class="gi">+                __import__(requirement)</span>
<span class="gi">+            except ImportError:</span>
<span class="gi">+                missing.append(requirement)</span>
<span class="gi">+        if missing:</span>
<span class="gi">+            pytest.skip(f&quot;Requires {&#39;,&#39;.join(missing)} to be present.&quot;)</span>
<span class="gi">+        except_implementations = self._linter.config.except_implementations</span>
<span class="gi">+        if except_implementations:</span>
<span class="gi">+            if platform.python_implementation() in except_implementations:</span>
<span class="gi">+                msg = &quot;Test cannot run with Python implementation %r&quot;</span>
<span class="gi">+                pytest.skip(msg % platform.python_implementation())</span>
<span class="gi">+        excluded_platforms = self._linter.config.exclude_platforms</span>
<span class="gi">+        if excluded_platforms:</span>
<span class="gi">+            if sys.platform.lower() in excluded_platforms:</span>
<span class="gi">+                pytest.skip(f&quot;Test cannot run on platform {sys.platform!r}&quot;)</span>
<span class="gi">+        if (</span>
<span class="gi">+            self._config</span>
<span class="gi">+            and self._config.getoption(&quot;minimal_messages_config&quot;)</span>
<span class="gi">+            and self._linter.config.exclude_from_minimal_messages_config</span>
<span class="gi">+        ):</span>
<span class="gi">+            pytest.skip(&quot;Test excluded from --minimal-messages-config&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def runTest(self) -&gt; None:</span>
<span class="gi">+        self._runTest()</span>
<span class="gi">+</span>
<span class="gi">+    def _should_be_skipped_due_to_version(self) -&gt; bool:</span>
<span class="gi">+        return (  # type: ignore[no-any-return]</span>
<span class="gi">+            sys.version_info &lt; self._linter.config.min_pyver</span>
<span class="gi">+            or sys.version_info &gt; self._linter.config.max_pyver</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;{self._test_file.base} ({self.__class__.__module__}.{self.__class__.__name__})&quot;</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def get_expected_messages(stream: TextIO) -&gt;MessageCounter:</span>
<span class="gi">+    def get_expected_messages(stream: TextIO) -&gt; MessageCounter:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parses a file and get expected messages.

<span class="w"> </span>        :param stream: File-like input stream.
<span class="gu">@@ -90,21 +164,163 @@ class LintModuleTest:</span>
<span class="w"> </span>        :returns: A dict mapping line,msg-symbol tuples to the count on this line.
<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        messages: MessageCounter = Counter()</span>
<span class="gi">+        for i, line in enumerate(stream):</span>
<span class="gi">+            match = _EXPECTED_RE.search(line)</span>
<span class="gi">+            if match is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            line = match.group(&quot;line&quot;)</span>
<span class="gi">+            if line is None:</span>
<span class="gi">+                lineno = i + 1</span>
<span class="gi">+            elif line.startswith((&quot;+&quot;, &quot;-&quot;)):</span>
<span class="gi">+                lineno = i + 1 + int(line)</span>
<span class="gi">+            else:</span>
<span class="gi">+                lineno = int(line)</span>
<span class="gi">+</span>
<span class="gi">+            version = match.group(&quot;version&quot;)</span>
<span class="gi">+            op = match.group(&quot;op&quot;)</span>
<span class="gi">+            if version:</span>
<span class="gi">+                required = parse_python_version(version)</span>
<span class="gi">+                if not _OPERATORS[op](sys.version_info, required):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            for msg_id in match.group(&quot;msgs&quot;).split(&quot;,&quot;):</span>
<span class="gi">+                messages[lineno, msg_id.strip()] += 1</span>
<span class="gi">+        return messages</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def multiset_difference(expected_entries: MessageCounter,</span>
<span class="gd">-        actual_entries: MessageCounter) -&gt;tuple[MessageCounter, dict[tuple[</span>
<span class="gd">-        int, str], int]]:</span>
<span class="gi">+    def multiset_difference(</span>
<span class="gi">+        expected_entries: MessageCounter,</span>
<span class="gi">+        actual_entries: MessageCounter,</span>
<span class="gi">+    ) -&gt; tuple[MessageCounter, dict[tuple[int, str], int]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Takes two multisets and compares them.

<span class="w"> </span>        A multiset is a dict with the cardinality of the key as the value.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        missing = expected_entries.copy()</span>
<span class="gi">+        missing.subtract(actual_entries)</span>
<span class="gi">+        unexpected = {}</span>
<span class="gi">+        for key, value in list(missing.items()):</span>
<span class="gi">+            if value &lt;= 0:</span>
<span class="gi">+                missing.pop(key)</span>
<span class="gi">+                if value &lt; 0:</span>
<span class="gi">+                    unexpected[key] = -value</span>
<span class="gi">+        return missing, unexpected</span>
<span class="gi">+</span>
<span class="gi">+    def _open_expected_file(self) -&gt; TextIO:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return open(self._test_file.expected_output, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            return StringIO(&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _open_source_file(self) -&gt; TextIO:</span>
<span class="gi">+        if self._test_file.base == &quot;invalid_encoded_data&quot;:</span>
<span class="gi">+            return open(self._test_file.source, encoding=&quot;utf-8&quot;)</span>
<span class="gi">+        if &quot;latin1&quot; in self._test_file.base:</span>
<span class="gi">+            return open(self._test_file.source, encoding=&quot;latin1&quot;)</span>
<span class="gi">+        return open(self._test_file.source, encoding=&quot;utf8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_expected(self) -&gt; tuple[MessageCounter, list[OutputLine]]:</span>
<span class="gi">+        with self._open_source_file() as f:</span>
<span class="gi">+            expected_msgs = self.get_expected_messages(f)</span>
<span class="gi">+        if not expected_msgs:</span>
<span class="gi">+            expected_msgs = Counter()</span>
<span class="gi">+        with self._open_expected_file() as f:</span>
<span class="gi">+            expected_output_lines = [</span>
<span class="gi">+                OutputLine.from_csv(row, self._check_end_position)</span>
<span class="gi">+                for row in csv.reader(f, &quot;test&quot;)</span>
<span class="gi">+            ]</span>
<span class="gi">+        return expected_msgs, expected_output_lines</span>
<span class="gi">+</span>
<span class="gi">+    def _get_actual(self) -&gt; tuple[MessageCounter, list[OutputLine]]:</span>
<span class="gi">+        messages: list[Message] = self._linter.reporter.messages</span>
<span class="gi">+        messages.sort(key=lambda m: (m.line, m.symbol, m.msg))</span>
<span class="gi">+        received_msgs: MessageCounter = Counter()</span>
<span class="gi">+        received_output_lines = []</span>
<span class="gi">+        for msg in messages:</span>
<span class="gi">+            assert (</span>
<span class="gi">+                msg.symbol != &quot;fatal&quot;</span>
<span class="gi">+            ), f&quot;Pylint analysis failed because of &#39;{msg.msg}&#39;&quot;</span>
<span class="gi">+            received_msgs[msg.line, msg.symbol] += 1</span>
<span class="gi">+            received_output_lines.append(</span>
<span class="gi">+                OutputLine.from_msg(msg, self._check_end_position)</span>
<span class="gi">+            )</span>
<span class="gi">+        return received_msgs, received_output_lines</span>
<span class="gi">+</span>
<span class="gi">+    def _runTest(self) -&gt; None:</span>
<span class="gi">+        __tracebackhide__ = True  # pylint: disable=unused-variable</span>
<span class="gi">+        modules_to_check = [self._test_file.source]</span>
<span class="gi">+        self._linter.check(modules_to_check)</span>
<span class="gi">+        expected_messages, expected_output = self._get_expected()</span>
<span class="gi">+        actual_messages, actual_output = self._get_actual()</span>
<span class="gi">+        assert (</span>
<span class="gi">+            expected_messages == actual_messages</span>
<span class="gi">+        ), self.error_msg_for_unequal_messages(</span>
<span class="gi">+            actual_messages, expected_messages, actual_output</span>
<span class="gi">+        )</span>
<span class="gi">+        self._check_output_text(expected_messages, expected_output, actual_output)</span>
<span class="gi">+</span>
<span class="gi">+    def error_msg_for_unequal_messages(</span>
<span class="gi">+        self,</span>
<span class="gi">+        actual_messages: MessageCounter,</span>
<span class="gi">+        expected_messages: MessageCounter,</span>
<span class="gi">+        actual_output: list[OutputLine],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        msg = [f&#39;Wrong message(s) raised for &quot;{Path(self._test_file.source).name}&quot;:&#39;]</span>
<span class="gi">+        missing, unexpected = self.multiset_difference(</span>
<span class="gi">+            expected_messages, actual_messages</span>
<span class="gi">+        )</span>
<span class="gi">+        if missing:</span>
<span class="gi">+            msg.append(&quot;\nExpected in testdata:&quot;)</span>
<span class="gi">+            msg.extend(f&quot; {msg[0]:3}: {msg[1]}&quot; for msg in sorted(missing))</span>
<span class="gi">+        if unexpected:</span>
<span class="gi">+            msg.append(&quot;\nUnexpected in testdata:&quot;)</span>
<span class="gi">+            msg.extend(f&quot; {msg[0]:3}: {msg[1]}&quot; for msg in sorted(unexpected))</span>
<span class="gi">+        error_msg = &quot;\n&quot;.join(msg)</span>
<span class="gi">+        if self._config and self._config.getoption(&quot;verbose&quot;) &gt; 0:</span>
<span class="gi">+            error_msg += &quot;\n\nActual pylint output for this file:\n&quot;</span>
<span class="gi">+            error_msg += &quot;\n&quot;.join(str(o) for o in actual_output)</span>
<span class="gi">+        return error_msg</span>
<span class="gi">+</span>
<span class="gi">+    def error_msg_for_unequal_output(</span>
<span class="gi">+        self,</span>
<span class="gi">+        expected_lines: list[OutputLine],</span>
<span class="gi">+        received_lines: list[OutputLine],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        missing = set(expected_lines) - set(received_lines)</span>
<span class="gi">+        unexpected = set(received_lines) - set(expected_lines)</span>
<span class="gi">+        error_msg = f&#39;Wrong output for &quot;{Path(self._test_file.expected_output).name}&quot;:&#39;</span>
<span class="gi">+        sort_by_line_number = operator.attrgetter(&quot;lineno&quot;)</span>
<span class="gi">+        if missing:</span>
<span class="gi">+            error_msg += &quot;\n- Missing lines:\n&quot;</span>
<span class="gi">+            for line in sorted(missing, key=sort_by_line_number):</span>
<span class="gi">+                error_msg += f&quot;{line}\n&quot;</span>
<span class="gi">+        if unexpected:</span>
<span class="gi">+            error_msg += &quot;\n- Unexpected lines:\n&quot;</span>
<span class="gi">+            for line in sorted(unexpected, key=sort_by_line_number):</span>
<span class="gi">+                error_msg += f&quot;{line}\n&quot;</span>
<span class="gi">+            error_msg += (</span>
<span class="gi">+                &quot;\nYou can update the expected output automatically with:\n&#39;&quot;</span>
<span class="gi">+                f&quot;python tests/test_functional.py {UPDATE_OPTION} -k &quot;</span>
<span class="gi">+                f&#39;&quot;test_functional[{self._test_file.base}]&quot;\&#39;\n\n&#39;</span>
<span class="gi">+                &quot;Here&#39;s the update text in case you can&#39;t:\n&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+            expected_csv = StringIO()</span>
<span class="gi">+            writer = csv.writer(expected_csv, dialect=&quot;test&quot;)</span>
<span class="gi">+            for line in sorted(received_lines, key=sort_by_line_number):</span>
<span class="gi">+                writer.writerow(line.to_csv())</span>
<span class="gi">+            error_msg += expected_csv.getvalue()</span>
<span class="gi">+        return error_msg</span>

<span class="gd">-    def _check_output_text(self, _: MessageCounter, expected_output: list[</span>
<span class="gd">-        OutputLine], actual_output: list[OutputLine]) -&gt;None:</span>
<span class="gi">+    def _check_output_text(</span>
<span class="gi">+        self,</span>
<span class="gi">+        _: MessageCounter,</span>
<span class="gi">+        expected_output: list[OutputLine],</span>
<span class="gi">+        actual_output: list[OutputLine],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This is a function because we want to be able to update the text in
<span class="w"> </span>        LintModuleOutputUpdate.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert expected_output == actual_output, self.error_msg_for_unequal_output(</span>
<span class="gi">+            expected_output, actual_output</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/pylint/testutils/output_line.py b/pylint/testutils/output_line.py</span>
<span class="gh">index 50d52257c..c979a049c 100644</span>
<span class="gd">--- a/pylint/testutils/output_line.py</span>
<span class="gi">+++ b/pylint/testutils/output_line.py</span>
<span class="gu">@@ -1,10 +1,18 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from typing import Any, NamedTuple, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.interfaces import UNDEFINED, Confidence
<span class="w"> </span>from pylint.message.message import Message
<span class="gd">-_T = TypeVar(&#39;_T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_T = TypeVar(&quot;_T&quot;)</span>


<span class="w"> </span>class MessageTest(NamedTuple):
<span class="gu">@@ -33,37 +41,81 @@ class OutputLine(NamedTuple):</span>
<span class="w"> </span>    confidence: str

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_msg(cls, msg: Message, check_endline: bool=True) -&gt;OutputLine:</span>
<span class="gi">+    def from_msg(cls, msg: Message, check_endline: bool = True) -&gt; OutputLine:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an OutputLine from a Pylint Message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        column = cls._get_column(msg.column)</span>
<span class="gi">+        end_line = cls._get_py38_none_value(msg.end_line, check_endline)</span>
<span class="gi">+        end_column = cls._get_py38_none_value(msg.end_column, check_endline)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            msg.symbol,</span>
<span class="gi">+            msg.line,</span>
<span class="gi">+            column,</span>
<span class="gi">+            end_line,</span>
<span class="gi">+            end_column,</span>
<span class="gi">+            msg.obj or &quot;&quot;,</span>
<span class="gi">+            msg.msg.replace(&quot;\r\n&quot;, &quot;\n&quot;),</span>
<span class="gi">+            msg.confidence.name,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _get_column(column: (str | int)) -&gt;int:</span>
<span class="gi">+    def _get_column(column: str | int) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle column numbers.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return int(column)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _get_py38_none_value(value: _T, check_endline: bool) -&gt;(_T | None):</span>
<span class="gi">+    def _get_py38_none_value(value: _T, check_endline: bool) -&gt; _T | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used to make end_line and end_column None as indicated by our version
<span class="w"> </span>        compared to `min_pyver_end_position`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not check_endline:</span>
<span class="gi">+            return None  # pragma: no cover</span>
<span class="gi">+        return value</span>

<span class="w"> </span>    @classmethod
<span class="gd">-    def from_csv(cls, row: (Sequence[str] | str), check_endline: bool=True</span>
<span class="gd">-        ) -&gt;OutputLine:</span>
<span class="gi">+    def from_csv(</span>
<span class="gi">+        cls, row: Sequence[str] | str, check_endline: bool = True</span>
<span class="gi">+    ) -&gt; OutputLine:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an OutputLine from a comma separated list (the functional tests
<span class="w"> </span>        expected output .txt files).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(row, str):</span>
<span class="gi">+            row = row.split(&quot;,&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            line = int(row[1])</span>
<span class="gi">+            column = cls._get_column(row[2])</span>
<span class="gi">+            end_line = cls._value_to_optional_int(</span>
<span class="gi">+                cls._get_py38_none_value(row[3], check_endline)</span>
<span class="gi">+            )</span>
<span class="gi">+            end_column = cls._value_to_optional_int(</span>
<span class="gi">+                cls._get_py38_none_value(row[4], check_endline)</span>
<span class="gi">+            )</span>
<span class="gi">+            # symbol, line, column, end_line, end_column, node, msg, confidences</span>
<span class="gi">+            assert len(row) == 8</span>
<span class="gi">+            return cls(</span>
<span class="gi">+                row[0], line, column, end_line, end_column, row[5], row[6], row[7]</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception:  # pylint: disable=broad-except</span>
<span class="gi">+            # We need this to not fail for the update script to work.</span>
<span class="gi">+            return cls(&quot;&quot;, 0, 0, None, None, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>

<span class="gd">-    def to_csv(self) -&gt;tuple[str, str, str, str, str, str, str, str]:</span>
<span class="gi">+    def to_csv(self) -&gt; tuple[str, str, str, str, str, str, str, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert an OutputLine to a tuple of string to be written by a
<span class="w"> </span>        csv-writer.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (</span>
<span class="gi">+            str(self.symbol),</span>
<span class="gi">+            str(self.lineno),</span>
<span class="gi">+            str(self.column),</span>
<span class="gi">+            str(self.end_lineno),</span>
<span class="gi">+            str(self.end_column),</span>
<span class="gi">+            str(self.object),</span>
<span class="gi">+            str(self.msg),</span>
<span class="gi">+            str(self.confidence),</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _value_to_optional_int(value: (str | None)) -&gt;(int | None):</span>
<span class="gi">+    def _value_to_optional_int(value: str | None) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Checks if a (stringified) value should be None or a Python integer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if value == &quot;None&quot; or not value:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return int(value)</span>
<span class="gh">diff --git a/pylint/testutils/pyreverse.py b/pylint/testutils/pyreverse.py</span>
<span class="gh">index f9eeb3f8c..c621f9e7a 100644</span>
<span class="gd">--- a/pylint/testutils/pyreverse.py</span>
<span class="gi">+++ b/pylint/testutils/pyreverse.py</span>
<span class="gu">@@ -1,27 +1,49 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import configparser
<span class="w"> </span>import shlex
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import NamedTuple, TypedDict
<span class="gi">+</span>
<span class="w"> </span>from pylint.pyreverse.main import DEFAULT_COLOR_PALETTE


<span class="gd">-class PyreverseConfig(argparse.Namespace):</span>
<span class="gi">+# This class could and should be replaced with a simple dataclass when support for Python &lt; 3.7 is dropped.</span>
<span class="gi">+# A NamedTuple is not possible as some tests need to modify attributes during the test.</span>
<span class="gi">+class PyreverseConfig(</span>
<span class="gi">+    argparse.Namespace</span>
<span class="gi">+):  # pylint: disable=too-many-instance-attributes, too-many-arguments</span>
<span class="w"> </span>    &quot;&quot;&quot;Holds the configuration options for Pyreverse.

<span class="w"> </span>    The default values correspond to the defaults of the options&#39; parser.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, mode: str=&#39;PUB_ONLY&#39;, classes: (list[str] | None)=</span>
<span class="gd">-        None, show_ancestors: (int | None)=None, all_ancestors: (bool |</span>
<span class="gd">-        None)=None, show_associated: (int | None)=None, all_associated: (</span>
<span class="gd">-        bool | None)=None, no_standalone: bool=False, show_builtin: bool=</span>
<span class="gd">-        False, show_stdlib: bool=False, module_names: (bool | None)=None,</span>
<span class="gd">-        only_classnames: bool=False, output_format: str=&#39;dot&#39;, colorized:</span>
<span class="gd">-        bool=False, max_color_depth: int=2, color_palette: tuple[str, ...]=</span>
<span class="gd">-        DEFAULT_COLOR_PALETTE, ignore_list: tuple[str, ...]=tuple(),</span>
<span class="gd">-        project: str=&#39;&#39;, output_directory: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        mode: str = &quot;PUB_ONLY&quot;,</span>
<span class="gi">+        classes: list[str] | None = None,</span>
<span class="gi">+        show_ancestors: int | None = None,</span>
<span class="gi">+        all_ancestors: bool | None = None,</span>
<span class="gi">+        show_associated: int | None = None,</span>
<span class="gi">+        all_associated: bool | None = None,</span>
<span class="gi">+        no_standalone: bool = False,</span>
<span class="gi">+        show_builtin: bool = False,</span>
<span class="gi">+        show_stdlib: bool = False,</span>
<span class="gi">+        module_names: bool | None = None,</span>
<span class="gi">+        only_classnames: bool = False,</span>
<span class="gi">+        output_format: str = &quot;dot&quot;,</span>
<span class="gi">+        colorized: bool = False,</span>
<span class="gi">+        max_color_depth: int = 2,</span>
<span class="gi">+        color_palette: tuple[str, ...] = DEFAULT_COLOR_PALETTE,</span>
<span class="gi">+        ignore_list: tuple[str, ...] = tuple(),</span>
<span class="gi">+        project: str = &quot;&quot;,</span>
<span class="gi">+        output_directory: str = &quot;&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.mode = mode
<span class="w"> </span>        if classes:
<span class="gu">@@ -54,11 +76,50 @@ class TestFileOptions(TypedDict):</span>

<span class="w"> </span>class FunctionalPyreverseTestfile(NamedTuple):
<span class="w"> </span>    &quot;&quot;&quot;Named tuple containing the test file and the expected output.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    source: Path
<span class="w"> </span>    options: TestFileOptions


<span class="gd">-def get_functional_test_files(root_directory: Path) -&gt;list[</span>
<span class="gd">-    FunctionalPyreverseTestfile]:</span>
<span class="gi">+def get_functional_test_files(</span>
<span class="gi">+    root_directory: Path,</span>
<span class="gi">+) -&gt; list[FunctionalPyreverseTestfile]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get all functional test files from the given directory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    test_files = []</span>
<span class="gi">+    for path in root_directory.rglob(&quot;*.py&quot;):</span>
<span class="gi">+        if path.stem.startswith(&quot;_&quot;):</span>
<span class="gi">+            continue</span>
<span class="gi">+        config_file = path.with_suffix(&quot;.rc&quot;)</span>
<span class="gi">+        if config_file.exists():</span>
<span class="gi">+            test_files.append(</span>
<span class="gi">+                FunctionalPyreverseTestfile(</span>
<span class="gi">+                    source=path, options=_read_config(config_file)</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            test_files.append(</span>
<span class="gi">+                FunctionalPyreverseTestfile(</span>
<span class="gi">+                    source=path,</span>
<span class="gi">+                    options={</span>
<span class="gi">+                        &quot;source_roots&quot;: [],</span>
<span class="gi">+                        &quot;output_formats&quot;: [&quot;mmd&quot;],</span>
<span class="gi">+                        &quot;command_line_args&quot;: [],</span>
<span class="gi">+                    },</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+    return test_files</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _read_config(config_file: Path) -&gt; TestFileOptions:</span>
<span class="gi">+    config = configparser.ConfigParser()</span>
<span class="gi">+    config.read(str(config_file))</span>
<span class="gi">+    source_roots = config.get(&quot;testoptions&quot;, &quot;source_roots&quot;, fallback=None)</span>
<span class="gi">+    return {</span>
<span class="gi">+        &quot;source_roots&quot;: source_roots.split(&quot;,&quot;) if source_roots else [],</span>
<span class="gi">+        &quot;output_formats&quot;: config.get(</span>
<span class="gi">+            &quot;testoptions&quot;, &quot;output_formats&quot;, fallback=&quot;mmd&quot;</span>
<span class="gi">+        ).split(&quot;,&quot;),</span>
<span class="gi">+        &quot;command_line_args&quot;: shlex.split(</span>
<span class="gi">+            config.get(&quot;testoptions&quot;, &quot;command_line_args&quot;, fallback=&quot;&quot;)</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/pylint/testutils/reporter_for_tests.py b/pylint/testutils/reporter_for_tests.py</span>
<span class="gh">index 194c5b93e..d3c06eecd 100644</span>
<span class="gd">--- a/pylint/testutils/reporter_for_tests.py</span>
<span class="gi">+++ b/pylint/testutils/reporter_for_tests.py</span>
<span class="gu">@@ -1,40 +1,79 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from os import getcwd, sep
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from pylint.message import Message
<span class="w"> </span>from pylint.reporters import BaseReporter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.reporters.ureports.nodes import Section


<span class="w"> </span>class GenericTestReporter(BaseReporter):
<span class="w"> </span>    &quot;&quot;&quot;Reporter storing plain text messages.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    out: StringIO

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(  # pylint: disable=super-init-not-called # See https://github.com/pylint-dev/pylint/issues/4941</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.path_strip_prefix: str = getcwd() + sep
<span class="w"> </span>        self.reset()

<span class="gd">-    def handle_message(self, msg: Message) -&gt;None:</span>
<span class="gi">+    def reset(self) -&gt; None:</span>
<span class="gi">+        self.out = StringIO()</span>
<span class="gi">+        self.messages: list[Message] = []</span>
<span class="gi">+</span>
<span class="gi">+    def handle_message(self, msg: Message) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Append messages to the list of messages of the reporter.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.messages.append(msg)</span>

<span class="gd">-    def finalize(self) -&gt;str:</span>
<span class="gi">+    def finalize(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Format and print messages in the context of the path.&quot;&quot;&quot;
<span class="gi">+        messages: list[str] = []</span>
<span class="gi">+        for msg in self.messages:</span>
<span class="gi">+            obj = &quot;&quot;</span>
<span class="gi">+            if msg.obj:</span>
<span class="gi">+                obj = f&quot;:{msg.obj}&quot;</span>
<span class="gi">+            messages.append(f&quot;{msg.msg_id[0]}:{msg.line:&gt;3}{obj}: {msg.msg}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        messages.sort()</span>
<span class="gi">+        for message in messages:</span>
<span class="gi">+            print(message, file=self.out)</span>
<span class="gi">+</span>
<span class="gi">+        result = self.out.getvalue()</span>
<span class="gi">+        self.reset()</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def on_set_current_module(self, module: str, filepath: str | None) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    def display_reports(self, layout: Section) -&gt;None:</span>
<span class="gi">+    # pylint: enable=unused-argument</span>
<span class="gi">+</span>
<span class="gi">+    def display_reports(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Ignore layouts.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _display(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        pass


<span class="w"> </span>class MinimalTestReporter(BaseReporter):
<span class="gd">-    pass</span>
<span class="gi">+    def on_set_current_module(self, module: str, filepath: str | None) -&gt; None:</span>
<span class="gi">+        self.messages = []</span>

<span class="gi">+    def _display(self, layout: Section) -&gt; None:</span>
<span class="gi">+        pass</span>

<span class="gd">-class FunctionalTestReporter(BaseReporter):</span>

<span class="gd">-    def display_reports(self, layout: Section) -&gt;None:</span>
<span class="gi">+class FunctionalTestReporter(BaseReporter):</span>
<span class="gi">+    def display_reports(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Ignore layouts and don&#39;t call self._display().&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _display(self, layout: Section) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gh">diff --git a/pylint/testutils/tokenize_str.py b/pylint/testutils/tokenize_str.py</span>
<span class="gh">index c8005f96c..dc9ada72a 100644</span>
<span class="gd">--- a/pylint/testutils/tokenize_str.py</span>
<span class="gi">+++ b/pylint/testutils/tokenize_str.py</span>
<span class="gu">@@ -1,4 +1,13 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import tokenize
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from tokenize import TokenInfo
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _tokenize_str(code: str) -&gt; list[TokenInfo]:</span>
<span class="gi">+    return list(tokenize.generate_tokens(StringIO(code).readline))</span>
<span class="gh">diff --git a/pylint/testutils/unittest_linter.py b/pylint/testutils/unittest_linter.py</span>
<span class="gh">index e3aec6085..a19afec56 100644</span>
<span class="gd">--- a/pylint/testutils/unittest_linter.py</span>
<span class="gi">+++ b/pylint/testutils/unittest_linter.py</span>
<span class="gu">@@ -1,6 +1,15 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="gi">+# pylint: disable=duplicate-code</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Literal
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.interfaces import UNDEFINED, Confidence
<span class="w"> </span>from pylint.lint import PyLinter
<span class="w"> </span>from pylint.testutils.output_line import MessageTest
<span class="gu">@@ -9,13 +18,67 @@ from pylint.testutils.output_line import MessageTest</span>
<span class="w"> </span>class UnittestLinter(PyLinter):
<span class="w"> </span>    &quot;&quot;&quot;A fake linter class to capture checker messages.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._messages: list[MessageTest] = []
<span class="w"> </span>        super().__init__()

<span class="gd">-    def add_message(self, msgid: str, line: (int | None)=None, node: (nodes</span>
<span class="gd">-        .NodeNG | None)=None, args: Any=None, confidence: (Confidence |</span>
<span class="gd">-        None)=None, col_offset: (int | None)=None, end_lineno: (int | None)</span>
<span class="gd">-        =None, end_col_offset: (int | None)=None) -&gt;None:</span>
<span class="gi">+    def release_messages(self) -&gt; list[MessageTest]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._messages</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._messages = []</span>
<span class="gi">+</span>
<span class="gi">+    def add_message(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgid: str,</span>
<span class="gi">+        line: int | None = None,</span>
<span class="gi">+        # TODO: Make node non optional</span>
<span class="gi">+        node: nodes.NodeNG | None = None,</span>
<span class="gi">+        args: Any = None,</span>
<span class="gi">+        confidence: Confidence | None = None,</span>
<span class="gi">+        col_offset: int | None = None,</span>
<span class="gi">+        end_lineno: int | None = None,</span>
<span class="gi">+        end_col_offset: int | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a MessageTest to the _messages attribute of the linter class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # If confidence is None we set it to UNDEFINED as well in PyLinter</span>
<span class="gi">+        if confidence is None:</span>
<span class="gi">+            confidence = UNDEFINED</span>
<span class="gi">+</span>
<span class="gi">+        # Look up &quot;location&quot; data of node if not yet supplied</span>
<span class="gi">+        if node:</span>
<span class="gi">+            if node.position:</span>
<span class="gi">+                if not line:</span>
<span class="gi">+                    line = node.position.lineno</span>
<span class="gi">+                if not col_offset:</span>
<span class="gi">+                    col_offset = node.position.col_offset</span>
<span class="gi">+                if not end_lineno:</span>
<span class="gi">+                    end_lineno = node.position.end_lineno</span>
<span class="gi">+                if not end_col_offset:</span>
<span class="gi">+                    end_col_offset = node.position.end_col_offset</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not line:</span>
<span class="gi">+                    line = node.fromlineno</span>
<span class="gi">+                if not col_offset:</span>
<span class="gi">+                    col_offset = node.col_offset</span>
<span class="gi">+                if not end_lineno:</span>
<span class="gi">+                    end_lineno = node.end_lineno</span>
<span class="gi">+                if not end_col_offset:</span>
<span class="gi">+                    end_col_offset = node.end_col_offset</span>
<span class="gi">+</span>
<span class="gi">+        self._messages.append(</span>
<span class="gi">+            MessageTest(</span>
<span class="gi">+                msgid,</span>
<span class="gi">+                line,</span>
<span class="gi">+                node,</span>
<span class="gi">+                args,</span>
<span class="gi">+                confidence,</span>
<span class="gi">+                col_offset,</span>
<span class="gi">+                end_lineno,</span>
<span class="gi">+                end_col_offset,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def is_message_enabled(*unused_args: Any, **unused_kwargs: Any) -&gt; Literal[True]:</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/pylint/testutils/utils.py b/pylint/testutils/utils.py</span>
<span class="gh">index 8ca619cfa..1ff999b28 100644</span>
<span class="gd">--- a/pylint/testutils/utils.py</span>
<span class="gi">+++ b/pylint/testutils/utils.py</span>
<span class="gu">@@ -1,4 +1,9 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gu">@@ -9,12 +14,62 @@ from typing import TextIO</span>


<span class="w"> </span>@contextlib.contextmanager
<span class="gd">-def _patch_streams(out: TextIO) -&gt;Iterator[None]:</span>
<span class="gi">+def _patch_streams(out: TextIO) -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Patch and subsequently reset a text stream.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sys.stderr = sys.stdout = out</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        sys.stderr = sys.__stderr__</span>
<span class="gi">+        sys.stdout = sys.__stdout__</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextlib.contextmanager</span>
<span class="gi">+def _test_sys_path(</span>
<span class="gi">+    replacement_sys_path: list[str] | None = None,</span>
<span class="gi">+) -&gt; Generator[None, None, None]:</span>
<span class="gi">+    original_path = sys.path</span>
<span class="gi">+    try:</span>
<span class="gi">+        if replacement_sys_path is not None:</span>
<span class="gi">+            sys.path = copy(replacement_sys_path)</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        sys.path = original_path</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextlib.contextmanager</span>
<span class="gi">+def _test_cwd(</span>
<span class="gi">+    current_working_directory: str | Path | None = None,</span>
<span class="gi">+) -&gt; Generator[None, None, None]:</span>
<span class="gi">+    original_dir = os.getcwd()</span>
<span class="gi">+    try:</span>
<span class="gi">+        if current_working_directory is not None:</span>
<span class="gi">+            os.chdir(current_working_directory)</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        os.chdir(original_dir)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextlib.contextmanager</span>
<span class="gi">+def _test_environ_pythonpath(</span>
<span class="gi">+    new_pythonpath: str | None = None,</span>
<span class="gi">+) -&gt; Generator[None, None, None]:</span>
<span class="gi">+    original_pythonpath = os.environ.get(&quot;PYTHONPATH&quot;)</span>
<span class="gi">+    if new_pythonpath:</span>
<span class="gi">+        os.environ[&quot;PYTHONPATH&quot;] = new_pythonpath</span>
<span class="gi">+    elif new_pythonpath is None and original_pythonpath is not None:</span>
<span class="gi">+        # If new_pythonpath is None, make sure to delete PYTHONPATH if present</span>
<span class="gi">+        del os.environ[&quot;PYTHONPATH&quot;]</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if original_pythonpath is not None:</span>
<span class="gi">+            os.environ[&quot;PYTHONPATH&quot;] = original_pythonpath</span>
<span class="gi">+        elif &quot;PYTHONPATH&quot; in os.environ:</span>
<span class="gi">+            del os.environ[&quot;PYTHONPATH&quot;]</span>


<span class="gd">-def create_files(paths: list[str], chroot: str=&#39;.&#39;) -&gt;None:</span>
<span class="gi">+def create_files(paths: list[str], chroot: str = &quot;.&quot;) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Creates directories and files found in &lt;path&gt;.

<span class="w"> </span>    :param list paths: list of relative paths to files or directories
<span class="gu">@@ -33,4 +88,20 @@ def create_files(paths: list[str], chroot: str=&#39;.&#39;) -&gt;None:</span>
<span class="w"> </span>    &gt;&gt;&gt; isfile(&#39;/tmp/a/b/foo.py&#39;)
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dirs, files = set(), set()</span>
<span class="gi">+    for path in paths:</span>
<span class="gi">+        path = os.path.join(chroot, path)</span>
<span class="gi">+        filename = os.path.basename(path)</span>
<span class="gi">+        # path is a directory path</span>
<span class="gi">+        if not filename:</span>
<span class="gi">+            dirs.add(path)</span>
<span class="gi">+        # path is a filename path</span>
<span class="gi">+        else:</span>
<span class="gi">+            dirs.add(os.path.dirname(path))</span>
<span class="gi">+            files.add(path)</span>
<span class="gi">+    for dirpath in dirs:</span>
<span class="gi">+        if not os.path.isdir(dirpath):</span>
<span class="gi">+            os.makedirs(dirpath)</span>
<span class="gi">+    for filepath in files:</span>
<span class="gi">+        with open(filepath, &quot;w&quot;, encoding=&quot;utf-8&quot;):</span>
<span class="gi">+            pass</span>
<span class="gh">diff --git a/pylint/typing.py b/pylint/typing.py</span>
<span class="gh">index c4dc2c2f0..f9dde2e40 100644</span>
<span class="gd">--- a/pylint/typing.py</span>
<span class="gi">+++ b/pylint/typing.py</span>
<span class="gu">@@ -1,8 +1,30 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;A collection of typing utilities.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>from pathlib import Path
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, Dict, Iterable, Literal, NamedTuple, Optional, Pattern, Protocol, Tuple, Type, TypedDict, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Literal,</span>
<span class="gi">+    NamedTuple,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    Protocol,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypedDict,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.config.callback_actions import _CallbackAction
<span class="w"> </span>    from pylint.pyreverse.inspector import Project
<span class="gu">@@ -18,6 +40,7 @@ class FileItem(NamedTuple):</span>
<span class="w"> </span>    - filepath: path of the file
<span class="w"> </span>    - modname: module name
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name: str
<span class="w"> </span>    filepath: str
<span class="w"> </span>    modpath: str
<span class="gu">@@ -25,6 +48,7 @@ class FileItem(NamedTuple):</span>

<span class="w"> </span>class ModuleDescriptionDict(TypedDict):
<span class="w"> </span>    &quot;&quot;&quot;Represents data about a checked module.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    path: str
<span class="w"> </span>    name: str
<span class="w"> </span>    isarg: bool
<span class="gu">@@ -34,13 +58,15 @@ class ModuleDescriptionDict(TypedDict):</span>

<span class="w"> </span>class ErrorDescriptionDict(TypedDict):
<span class="w"> </span>    &quot;&quot;&quot;Represents data about errors collected during checking of a module.&quot;&quot;&quot;
<span class="gd">-    key: Literal[&#39;fatal&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    key: Literal[&quot;fatal&quot;]</span>
<span class="w"> </span>    mod: str
<span class="w"> </span>    ex: ImportError | SyntaxError


<span class="w"> </span>class MessageLocationTuple(NamedTuple):
<span class="w"> </span>    &quot;&quot;&quot;Tuple with information about the location of a to-be-displayed message.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    abspath: str
<span class="w"> </span>    path: str
<span class="w"> </span>    module: str
<span class="gu">@@ -53,6 +79,7 @@ class MessageLocationTuple(NamedTuple):</span>

<span class="w"> </span>class ManagedMessage(NamedTuple):
<span class="w"> </span>    &quot;&quot;&quot;Tuple with information about a managed message of the linter.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name: str | None
<span class="w"> </span>    msgid: str
<span class="w"> </span>    symbol: str
<span class="gu">@@ -60,20 +87,36 @@ class ManagedMessage(NamedTuple):</span>
<span class="w"> </span>    is_disabled: bool


<span class="gd">-MessageTypesFullName = Literal[&#39;convention&#39;, &#39;error&#39;, &#39;fatal&#39;, &#39;info&#39;,</span>
<span class="gd">-    &#39;refactor&#39;, &#39;statement&#39;, &#39;warning&#39;]</span>
<span class="gi">+MessageTypesFullName = Literal[</span>
<span class="gi">+    &quot;convention&quot;, &quot;error&quot;, &quot;fatal&quot;, &quot;info&quot;, &quot;refactor&quot;, &quot;statement&quot;, &quot;warning&quot;</span>
<span class="gi">+]</span>
<span class="w"> </span>&quot;&quot;&quot;All possible message categories.&quot;&quot;&quot;
<span class="gd">-OptionDict = Dict[str, Union[None, str, bool, int, Pattern[str], Iterable[</span>
<span class="gd">-    Union[str, int, Pattern[str]]], Type[&#39;_CallbackAction&#39;], Callable[[Any],</span>
<span class="gd">-    Any], Callable[[Any, Any, Any, Any], Any]]]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+OptionDict = Dict[</span>
<span class="gi">+    str,</span>
<span class="gi">+    Union[</span>
<span class="gi">+        None,</span>
<span class="gi">+        str,</span>
<span class="gi">+        bool,</span>
<span class="gi">+        int,</span>
<span class="gi">+        Pattern[str],</span>
<span class="gi">+        Iterable[Union[str, int, Pattern[str]]],</span>
<span class="gi">+        Type[&quot;_CallbackAction&quot;],</span>
<span class="gi">+        Callable[[Any], Any],</span>
<span class="gi">+        Callable[[Any, Any, Any, Any], Any],</span>
<span class="gi">+    ],</span>
<span class="gi">+]</span>
<span class="w"> </span>Options = Tuple[Tuple[str, OptionDict], ...]
<span class="gd">-ReportsCallable = Callable[[&#39;Section&#39;, &#39;LinterStats&#39;, Optional[</span>
<span class="gd">-    &#39;LinterStats&#39;]], None]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+ReportsCallable = Callable[[&quot;Section&quot;, &quot;LinterStats&quot;, Optional[&quot;LinterStats&quot;]], None]</span>
<span class="w"> </span>&quot;&quot;&quot;Callable to create a report.&quot;&quot;&quot;


<span class="gd">-class ExtraMessageOptions(TypedDict, total=(False)):</span>
<span class="gi">+class ExtraMessageOptions(TypedDict, total=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;All allowed keys in the extra options for message definitions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    scope: str
<span class="w"> </span>    old_names: list[tuple[str, str]]
<span class="w"> </span>    maxversion: tuple[int, int]
<span class="gu">@@ -82,13 +125,14 @@ class ExtraMessageOptions(TypedDict, total=(False)):</span>
<span class="w"> </span>    default_enabled: bool


<span class="gd">-MessageDefinitionTuple = Union[Tuple[str, str, str], Tuple[str, str, str,</span>
<span class="gd">-    ExtraMessageOptions]]</span>
<span class="gd">-DirectoryNamespaceDict = Dict[Path, Tuple[argparse.Namespace,</span>
<span class="gd">-    &#39;DirectoryNamespaceDict&#39;]]</span>
<span class="gi">+MessageDefinitionTuple = Union[</span>
<span class="gi">+    Tuple[str, str, str],</span>
<span class="gi">+    Tuple[str, str, str, ExtraMessageOptions],</span>
<span class="gi">+]</span>
<span class="gi">+DirectoryNamespaceDict = Dict[Path, Tuple[argparse.Namespace, &quot;DirectoryNamespaceDict&quot;]]</span>


<span class="w"> </span>class GetProjectCallable(Protocol):
<span class="gd">-</span>
<span class="gd">-    def __call__(self, module: str, name: (str | None)=&#39;No Name&#39;) -&gt;Project:</span>
<span class="gd">-        ...</span>
<span class="gi">+    def __call__(</span>
<span class="gi">+        self, module: str, name: str | None = &quot;No Name&quot;</span>
<span class="gi">+    ) -&gt; Project: ...  # pragma: no cover</span>
<span class="gh">diff --git a/pylint/utils/ast_walker.py b/pylint/utils/ast_walker.py</span>
<span class="gh">index 8872be9e0..367a39b81 100644</span>
<span class="gd">--- a/pylint/utils/ast_walker.py</span>
<span class="gi">+++ b/pylint/utils/ast_walker.py</span>
<span class="gu">@@ -1,33 +1,106 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import traceback
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from collections.abc import Sequence
<span class="w"> </span>from typing import TYPE_CHECKING, Callable
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.checkers.base_checker import BaseChecker
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="gi">+# Callable parameter type NodeNG not completely correct.</span>
<span class="gi">+# Due to contravariance of Callable parameter types,</span>
<span class="gi">+# it should be a Union of all NodeNG subclasses.</span>
<span class="gi">+# However, since the methods are only retrieved with</span>
<span class="gi">+# getattr(checker, member) and thus are inferred as Any,</span>
<span class="gi">+# NodeNG will work too.</span>
<span class="w"> </span>AstCallback = Callable[[nodes.NodeNG], None]


<span class="w"> </span>class ASTWalker:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, linter: PyLinter) -&gt;None:</span>
<span class="gi">+    def __init__(self, linter: PyLinter) -&gt; None:</span>
<span class="gi">+        # callbacks per node types</span>
<span class="w"> </span>        self.nbstatements = 0
<span class="gd">-        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(</span>
<span class="gd">-            list)</span>
<span class="gd">-        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(</span>
<span class="gd">-            list)</span>
<span class="gi">+        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)</span>
<span class="gi">+        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)</span>
<span class="w"> </span>        self.linter = linter
<span class="w"> </span>        self.exception_msg = False

<span class="gd">-    def add_checker(self, checker: BaseChecker) -&gt;None:</span>
<span class="gi">+    def _is_method_enabled(self, method: AstCallback) -&gt; bool:</span>
<span class="gi">+        if not hasattr(method, &quot;checks_msgs&quot;):</span>
<span class="gi">+            return True</span>
<span class="gi">+        return any(self.linter.is_message_enabled(m) for m in method.checks_msgs)</span>
<span class="gi">+</span>
<span class="gi">+    def add_checker(self, checker: BaseChecker) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Walk to the checker&#39;s dir and collect visit and leave methods.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        vcids: set[str] = set()</span>
<span class="gi">+        lcids: set[str] = set()</span>
<span class="gi">+        visits = self.visit_events</span>
<span class="gi">+        leaves = self.leave_events</span>
<span class="gi">+        for member in dir(checker):</span>
<span class="gi">+            cid = member[6:]</span>
<span class="gi">+            if cid == &quot;default&quot;:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if member.startswith(&quot;visit_&quot;):</span>
<span class="gi">+                v_meth = getattr(checker, member)</span>
<span class="gi">+                # don&#39;t use visit_methods with no activated message:</span>
<span class="gi">+                if self._is_method_enabled(v_meth):</span>
<span class="gi">+                    visits[cid].append(v_meth)</span>
<span class="gi">+                    vcids.add(cid)</span>
<span class="gi">+            elif member.startswith(&quot;leave_&quot;):</span>
<span class="gi">+                l_meth = getattr(checker, member)</span>
<span class="gi">+                # don&#39;t use leave_methods with no activated message:</span>
<span class="gi">+                if self._is_method_enabled(l_meth):</span>
<span class="gi">+                    leaves[cid].append(l_meth)</span>
<span class="gi">+                    lcids.add(cid)</span>
<span class="gi">+        visit_default = getattr(checker, &quot;visit_default&quot;, None)</span>
<span class="gi">+        if visit_default:</span>
<span class="gi">+            for cls in nodes.ALL_NODE_CLASSES:</span>
<span class="gi">+                cid = cls.__name__.lower()</span>
<span class="gi">+                if cid not in vcids:</span>
<span class="gi">+                    visits[cid].append(visit_default)</span>
<span class="gi">+        # For now, we have no &quot;leave_default&quot; method in Pylint</span>

<span class="gd">-    def walk(self, astroid: nodes.NodeNG) -&gt;None:</span>
<span class="gi">+    def walk(self, astroid: nodes.NodeNG) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call visit events of astroid checkers for the given node, recurse on
<span class="w"> </span>        its children, then leave events.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cid = astroid.__class__.__name__.lower()</span>
<span class="gi">+</span>
<span class="gi">+        # Detect if the node is a new name for a deprecated alias.</span>
<span class="gi">+        # In this case, favour the methods for the deprecated</span>
<span class="gi">+        # alias if any,  in order to maintain backwards</span>
<span class="gi">+        # compatibility.</span>
<span class="gi">+        visit_events: Sequence[AstCallback] = self.visit_events.get(cid, ())</span>
<span class="gi">+        leave_events: Sequence[AstCallback] = self.leave_events.get(cid, ())</span>
<span class="gi">+</span>
<span class="gi">+        # pylint: disable = too-many-try-statements</span>
<span class="gi">+        try:</span>
<span class="gi">+            if astroid.is_statement:</span>
<span class="gi">+                self.nbstatements += 1</span>
<span class="gi">+            # generate events for this node on each checker</span>
<span class="gi">+            for callback in visit_events:</span>
<span class="gi">+                callback(astroid)</span>
<span class="gi">+            # recurse on children</span>
<span class="gi">+            for child in astroid.get_children():</span>
<span class="gi">+                self.walk(child)</span>
<span class="gi">+            for callback in leave_events:</span>
<span class="gi">+                callback(astroid)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if self.exception_msg is False:</span>
<span class="gi">+                file = getattr(astroid.root(), &quot;file&quot;, None)</span>
<span class="gi">+                print(</span>
<span class="gi">+                    f&quot;Exception on node {astroid!r} in file &#39;{file}&#39;&quot;,</span>
<span class="gi">+                    file=sys.stderr,</span>
<span class="gi">+                )</span>
<span class="gi">+                traceback.print_exc()</span>
<span class="gi">+                self.exception_msg = True</span>
<span class="gi">+            raise</span>
<span class="gh">diff --git a/pylint/utils/docs.py b/pylint/utils/docs.py</span>
<span class="gh">index 69b539e48..ba592c4a4 100644</span>
<span class="gd">--- a/pylint/utils/docs.py</span>
<span class="gi">+++ b/pylint/utils/docs.py</span>
<span class="gu">@@ -1,30 +1,96 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;Various helper functions to create the docs of a linter object.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING, Any, TextIO
<span class="gi">+</span>
<span class="w"> </span>from pylint.constants import MAIN_CHECKER_NAME
<span class="w"> </span>from pylint.utils.utils import get_rst_section, get_rst_title
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint.pylinter import PyLinter


<span class="gd">-def _get_checkers_infos(linter: PyLinter) -&gt;dict[str, dict[str, Any]]:</span>
<span class="gi">+def _get_checkers_infos(linter: PyLinter) -&gt; dict[str, dict[str, Any]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get info from a checker and handle KeyError.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    by_checker: dict[str, dict[str, Any]] = {}</span>
<span class="gi">+    for checker in linter.get_checkers():</span>
<span class="gi">+        name = checker.name</span>
<span class="gi">+        if name != MAIN_CHECKER_NAME:</span>
<span class="gi">+            try:</span>
<span class="gi">+                by_checker[name][&quot;checker&quot;] = checker</span>
<span class="gi">+                by_checker[name][&quot;options&quot;] += checker._options_and_values()</span>
<span class="gi">+                by_checker[name][&quot;msgs&quot;].update(checker.msgs)</span>
<span class="gi">+                by_checker[name][&quot;reports&quot;] += checker.reports</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                by_checker[name] = {</span>
<span class="gi">+                    &quot;checker&quot;: checker,</span>
<span class="gi">+                    &quot;options&quot;: list(checker._options_and_values()),</span>
<span class="gi">+                    &quot;msgs&quot;: dict(checker.msgs),</span>
<span class="gi">+                    &quot;reports&quot;: list(checker.reports),</span>
<span class="gi">+                }</span>
<span class="gi">+    return by_checker</span>


<span class="gd">-def _get_global_options_documentation(linter: PyLinter) -&gt;str:</span>
<span class="gi">+def _get_global_options_documentation(linter: PyLinter) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get documentation for the main checker.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = get_rst_title(&quot;Pylint global options and switches&quot;, &quot;-&quot;)</span>
<span class="gi">+    result += &quot;&quot;&quot;</span>
<span class="gi">+Pylint provides global options and switches.</span>
<span class="gi">+</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+    for checker in linter.get_checkers():</span>
<span class="gi">+        if checker.name == MAIN_CHECKER_NAME and checker.options:</span>
<span class="gi">+            for section, options in checker._options_by_section():</span>
<span class="gi">+                if section is None:</span>
<span class="gi">+                    title = &quot;General options&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    title = f&quot;{section.capitalize()} options&quot;</span>
<span class="gi">+                result += get_rst_title(title, &quot;~&quot;)</span>
<span class="gi">+                assert isinstance(options, list)</span>
<span class="gi">+                result += f&quot;{get_rst_section(None, options)}\n&quot;</span>
<span class="gi">+    return result</span>


<span class="gd">-def _get_checkers_documentation(linter: PyLinter, show_options: bool=True</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+def _get_checkers_documentation(linter: PyLinter, show_options: bool = True) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get documentation for individual checkers.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if show_options:</span>
<span class="gi">+        result = _get_global_options_documentation(linter)</span>
<span class="gi">+    else:</span>
<span class="gi">+        result = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    result += get_rst_title(&quot;Pylint checkers&#39; options and switches&quot;, &quot;-&quot;)</span>
<span class="gi">+    result += &quot;&quot;&quot;\</span>
<span class="gi">+</span>
<span class="gi">+Pylint checkers can provide three set of features:</span>
<span class="gi">+</span>
<span class="gi">+* options that control their execution,</span>
<span class="gi">+* messages that they can raise,</span>
<span class="gi">+* reports that they can generate.</span>
<span class="gi">+</span>
<span class="gi">+Below is a list of all checkers and their features.</span>
<span class="gi">+</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+    by_checker = _get_checkers_infos(linter)</span>
<span class="gi">+    for checker_name in sorted(by_checker):</span>
<span class="gi">+        information = by_checker[checker_name]</span>
<span class="gi">+        checker = information[&quot;checker&quot;]</span>
<span class="gi">+        del information[&quot;checker&quot;]</span>
<span class="gi">+        result += checker.get_full_documentation(</span>
<span class="gi">+            **information, show_options=show_options</span>
<span class="gi">+        )</span>
<span class="gi">+    return result</span>


<span class="gd">-def print_full_documentation(linter: PyLinter, stream: TextIO=sys.stdout,</span>
<span class="gd">-    show_options: bool=True) -&gt;None:</span>
<span class="gi">+def print_full_documentation(</span>
<span class="gi">+    linter: PyLinter, stream: TextIO = sys.stdout, show_options: bool = True</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Output a full documentation in ReST format.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    print(</span>
<span class="gi">+        _get_checkers_documentation(linter, show_options=show_options)[:-3], file=stream</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pylint/utils/file_state.py b/pylint/utils/file_state.py</span>
<span class="gh">index 91b309b26..bc2763eaa 100644</span>
<span class="gd">--- a/pylint/utils/file_state.py</span>
<span class="gi">+++ b/pylint/utils/file_state.py</span>
<span class="gu">@@ -1,26 +1,46 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from collections.abc import Iterator
<span class="w"> </span>from typing import TYPE_CHECKING, Dict, Literal
<span class="gi">+</span>
<span class="w"> </span>from astroid import nodes
<span class="gd">-from pylint.constants import INCOMPATIBLE_WITH_USELESS_SUPPRESSION, MSG_STATE_SCOPE_MODULE, WarningScope</span>
<span class="gi">+</span>
<span class="gi">+from pylint.constants import (</span>
<span class="gi">+    INCOMPATIBLE_WITH_USELESS_SUPPRESSION,</span>
<span class="gi">+    MSG_STATE_SCOPE_MODULE,</span>
<span class="gi">+    WarningScope,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.message import MessageDefinition, MessageDefinitionStore
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>MessageStateDict = Dict[str, Dict[int, bool]]


<span class="w"> </span>class FileState:
<span class="w"> </span>    &quot;&quot;&quot;Hold internal state specific to the currently analyzed file.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, modname: str, msg_store: MessageDefinitionStore,</span>
<span class="gd">-        node: (nodes.Module | None)=None, *, is_base_filestate: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        modname: str,</span>
<span class="gi">+        msg_store: MessageDefinitionStore,</span>
<span class="gi">+        node: nodes.Module | None = None,</span>
<span class="gi">+        *,</span>
<span class="gi">+        is_base_filestate: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.base_name = modname
<span class="w"> </span>        self._module_msgs_state: MessageStateDict = {}
<span class="w"> </span>        self._raw_module_msgs_state: MessageStateDict = {}
<span class="gd">-        self._ignored_msgs: defaultdict[tuple[str, int], set[int]</span>
<span class="gd">-            ] = collections.defaultdict(set)</span>
<span class="gi">+        self._ignored_msgs: defaultdict[tuple[str, int], set[int]] = (</span>
<span class="gi">+            collections.defaultdict(set)</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._suppression_mapping: dict[tuple[str, int], int] = {}
<span class="w"> </span>        self._module = node
<span class="w"> </span>        if node:
<span class="gu">@@ -33,35 +53,202 @@ class FileState:</span>
<span class="w"> </span>        PyLinter.
<span class="w"> </span>        &quot;&quot;&quot;

<span class="gd">-    def _set_state_on_block_lines(self, msgs_store: MessageDefinitionStore,</span>
<span class="gd">-        node: nodes.NodeNG, msg: MessageDefinition, msg_state: dict[int, bool]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def _set_state_on_block_lines(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgs_store: MessageDefinitionStore,</span>
<span class="gi">+        node: nodes.NodeNG,</span>
<span class="gi">+        msg: MessageDefinition,</span>
<span class="gi">+        msg_state: dict[int, bool],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Recursively walk (depth first) AST to collect block level options
<span class="w"> </span>        line numbers and set the state correctly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for child in node.get_children():</span>
<span class="gi">+            self._set_state_on_block_lines(msgs_store, child, msg, msg_state)</span>
<span class="gi">+        # first child line number used to distinguish between disable</span>
<span class="gi">+        # which are the first child of scoped node with those defined later.</span>
<span class="gi">+        # For instance in the code below:</span>
<span class="gi">+        #</span>
<span class="gi">+        # 1.   def meth8(self):</span>
<span class="gi">+        # 2.        &quot;&quot;&quot;test late disabling&quot;&quot;&quot;</span>
<span class="gi">+        # 3.        pylint: disable=not-callable, useless-suppression</span>
<span class="gi">+        # 4.        print(self.blip)</span>
<span class="gi">+        # 5.        pylint: disable=no-member, useless-suppression</span>
<span class="gi">+        # 6.        print(self.bla)</span>
<span class="gi">+        #</span>
<span class="gi">+        # E1102 should be disabled from line 1 to 6 while E1101 from line 5 to 6</span>
<span class="gi">+        #</span>
<span class="gi">+        # this is necessary to disable locally messages applying to class /</span>
<span class="gi">+        # function using their fromlineno</span>
<span class="gi">+        if (</span>
<span class="gi">+            isinstance(node, (nodes.Module, nodes.ClassDef, nodes.FunctionDef))</span>
<span class="gi">+            and node.body</span>
<span class="gi">+        ):</span>
<span class="gi">+            firstchildlineno = node.body[0].fromlineno</span>
<span class="gi">+        else:</span>
<span class="gi">+            firstchildlineno = node.tolineno</span>
<span class="gi">+        self._set_message_state_in_block(msg, msg_state, node, firstchildlineno)</span>

<span class="gd">-    def _set_message_state_in_block(self, msg: MessageDefinition, lines:</span>
<span class="gd">-        dict[int, bool], node: nodes.NodeNG, firstchildlineno: int) -&gt;None:</span>
<span class="gi">+    def _set_message_state_in_block(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg: MessageDefinition,</span>
<span class="gi">+        lines: dict[int, bool],</span>
<span class="gi">+        node: nodes.NodeNG,</span>
<span class="gi">+        firstchildlineno: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the state of a message in a block of lines.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        first = node.fromlineno</span>
<span class="gi">+        last = node.tolineno</span>
<span class="gi">+        for lineno, state in list(lines.items()):</span>
<span class="gi">+            original_lineno = lineno</span>
<span class="gi">+            if first &gt; lineno or last &lt; lineno:</span>
<span class="gi">+                continue</span>
<span class="gi">+            # Set state for all lines for this block, if the</span>
<span class="gi">+            # warning is applied to nodes.</span>
<span class="gi">+            if msg.scope == WarningScope.NODE:</span>
<span class="gi">+                if lineno &gt; firstchildlineno:</span>
<span class="gi">+                    state = True</span>
<span class="gi">+                first_, last_ = node.block_range(lineno)</span>
<span class="gi">+                # pylint: disable=useless-suppression</span>
<span class="gi">+                # For block nodes first_ is their definition line. For example, we</span>
<span class="gi">+                # set the state of line zero for a module to allow disabling</span>
<span class="gi">+                # invalid-name for the module. For example:</span>
<span class="gi">+                # 1. # pylint: disable=invalid-name</span>
<span class="gi">+                # 2. ...</span>
<span class="gi">+                # OR</span>
<span class="gi">+                # 1. &quot;&quot;&quot;Module docstring&quot;&quot;&quot;</span>
<span class="gi">+                # 2. # pylint: disable=invalid-name</span>
<span class="gi">+                # 3. ...</span>
<span class="gi">+                #</span>
<span class="gi">+                # But if we already visited line 0 we don&#39;t need to set its state again</span>
<span class="gi">+                # 1. # pylint: disable=invalid-name</span>
<span class="gi">+                # 2. # pylint: enable=invalid-name</span>
<span class="gi">+                # 3. ...</span>
<span class="gi">+                # The state should come from line 1, not from line 2</span>
<span class="gi">+                # Therefore, if the &#39;fromlineno&#39; is already in the states we just start</span>
<span class="gi">+                # with the lineno we were originally visiting.</span>
<span class="gi">+                # pylint: enable=useless-suppression</span>
<span class="gi">+                if (</span>
<span class="gi">+                    first_ == node.fromlineno</span>
<span class="gi">+                    and first_ &gt;= firstchildlineno</span>
<span class="gi">+                    and node.fromlineno in self._module_msgs_state.get(msg.msgid, ())</span>
<span class="gi">+                ):</span>
<span class="gi">+                    first_ = lineno</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                first_ = lineno</span>
<span class="gi">+                last_ = last</span>
<span class="gi">+            for line in range(first_, last_ + 1):</span>
<span class="gi">+                # Do not override existing entries. This is especially important</span>
<span class="gi">+                # when parsing the states for a scoped node where some line-disables</span>
<span class="gi">+                # have already been parsed.</span>
<span class="gi">+                if (</span>
<span class="gi">+                    (</span>
<span class="gi">+                        isinstance(node, nodes.Module)</span>
<span class="gi">+                        and node.fromlineno &lt;= line &lt; lineno</span>
<span class="gi">+                    )</span>
<span class="gi">+                    or (</span>
<span class="gi">+                        not isinstance(node, nodes.Module)</span>
<span class="gi">+                        and node.fromlineno &lt; line &lt; lineno</span>
<span class="gi">+                    )</span>
<span class="gi">+                ) and line in self._module_msgs_state.get(msg.msgid, ()):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if line in lines:  # state change in the same block</span>
<span class="gi">+                    state = lines[line]</span>
<span class="gi">+                    original_lineno = line</span>

<span class="gd">-    def _set_message_state_on_line(self, msg: MessageDefinition, line: int,</span>
<span class="gd">-        state: bool, original_lineno: int) -&gt;None:</span>
<span class="gi">+                self._set_message_state_on_line(msg, line, state, original_lineno)</span>
<span class="gi">+</span>
<span class="gi">+            del lines[lineno]</span>
<span class="gi">+</span>
<span class="gi">+    def _set_message_state_on_line(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg: MessageDefinition,</span>
<span class="gi">+        line: int,</span>
<span class="gi">+        state: bool,</span>
<span class="gi">+        original_lineno: int,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the state of a message on a line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Update suppression mapping</span>
<span class="gi">+        if not state:</span>
<span class="gi">+            self._suppression_mapping[(msg.msgid, line)] = original_lineno</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._suppression_mapping.pop((msg.msgid, line), None)</span>

<span class="gd">-    def set_msg_status(self, msg: MessageDefinition, line: int, status:</span>
<span class="gd">-        bool, scope: str=&#39;package&#39;) -&gt;None:</span>
<span class="gi">+        # Update message state for respective line</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._module_msgs_state[msg.msgid][line] = state</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            self._module_msgs_state[msg.msgid] = {line: state}</span>
<span class="gi">+</span>
<span class="gi">+    def set_msg_status(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg: MessageDefinition,</span>
<span class="gi">+        line: int,</span>
<span class="gi">+        status: bool,</span>
<span class="gi">+        scope: str = &quot;package&quot;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set status (enabled/disable) for a given message at a given line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert line &gt; 0</span>
<span class="gi">+        if scope != &quot;line&quot;:</span>
<span class="gi">+            # Expand the status to cover all relevant block lines</span>
<span class="gi">+            self._set_state_on_block_lines(</span>
<span class="gi">+                self._msgs_store, self._module, msg, {line: status}</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._set_message_state_on_line(msg, line, status, line)</span>

<span class="gd">-    def handle_ignored_message(self, state_scope: (Literal[0, 1, 2] | None),</span>
<span class="gd">-        msgid: str, line: (int | None)) -&gt;None:</span>
<span class="gi">+        # Store the raw value</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._raw_module_msgs_state[msg.msgid][line] = status</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            self._raw_module_msgs_state[msg.msgid] = {line: status}</span>
<span class="gi">+</span>
<span class="gi">+    def handle_ignored_message(</span>
<span class="gi">+        self, state_scope: Literal[0, 1, 2] | None, msgid: str, line: int | None</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Report an ignored message.

<span class="w"> </span>        state_scope is either MSG_STATE_SCOPE_MODULE or MSG_STATE_SCOPE_CONFIG,
<span class="w"> </span>        depending on whether the message was disabled locally in the module,
<span class="w"> </span>        or globally.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if state_scope == MSG_STATE_SCOPE_MODULE:</span>
<span class="gi">+            assert isinstance(line, int)  # should always be int inside module scope</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                orig_line = self._suppression_mapping[(msgid, line)]</span>
<span class="gi">+                self._ignored_msgs[(msgid, orig_line)].add(line)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+    def iter_spurious_suppression_messages(</span>
<span class="gi">+        self,</span>
<span class="gi">+        msgs_store: MessageDefinitionStore,</span>
<span class="gi">+    ) -&gt; Iterator[</span>
<span class="gi">+        tuple[</span>
<span class="gi">+            Literal[&quot;useless-suppression&quot;, &quot;suppressed-message&quot;],</span>
<span class="gi">+            int,</span>
<span class="gi">+            tuple[str] | tuple[str, int],</span>
<span class="gi">+        ]</span>
<span class="gi">+    ]:</span>
<span class="gi">+        for warning, lines in self._raw_module_msgs_state.items():</span>
<span class="gi">+            for line, enable in lines.items():</span>
<span class="gi">+                if (</span>
<span class="gi">+                    not enable</span>
<span class="gi">+                    and (warning, line) not in self._ignored_msgs</span>
<span class="gi">+                    and warning not in INCOMPATIBLE_WITH_USELESS_SUPPRESSION</span>
<span class="gi">+                ):</span>
<span class="gi">+                    yield &quot;useless-suppression&quot;, line, (</span>
<span class="gi">+                        msgs_store.get_msg_display_string(warning),</span>
<span class="gi">+                    )</span>
<span class="gi">+        # don&#39;t use iteritems here, _ignored_msgs may be modified by add_message</span>
<span class="gi">+        for (warning, from_), ignored_lines in list(self._ignored_msgs.items()):</span>
<span class="gi">+            for line in ignored_lines:</span>
<span class="gi">+                yield &quot;suppressed-message&quot;, line, (</span>
<span class="gi">+                    msgs_store.get_msg_display_string(warning),</span>
<span class="gi">+                    from_,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    def get_effective_max_line_number(self) -&gt; int | None:</span>
<span class="gi">+        return self._effective_max_line_number  # type: ignore[no-any-return]</span>
<span class="gh">diff --git a/pylint/utils/linterstats.py b/pylint/utils/linterstats.py</span>
<span class="gh">index 3950c7b35..53afbcfe2 100644</span>
<span class="gd">--- a/pylint/utils/linterstats.py</span>
<span class="gi">+++ b/pylint/utils/linterstats.py</span>
<span class="gu">@@ -1,10 +1,17 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Literal, TypedDict, cast
<span class="gi">+</span>
<span class="w"> </span>from pylint.typing import MessageTypesFullName


<span class="w"> </span>class BadNames(TypedDict):
<span class="w"> </span>    &quot;&quot;&quot;TypedDict to store counts of node types with bad names.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    argument: int
<span class="w"> </span>    attr: int
<span class="w"> </span>    klass: int
<span class="gu">@@ -22,6 +29,7 @@ class BadNames(TypedDict):</span>

<span class="w"> </span>class CodeTypeCount(TypedDict):
<span class="w"> </span>    &quot;&quot;&quot;TypedDict to store counts of lines of code types.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    code: int
<span class="w"> </span>    comment: int
<span class="w"> </span>    docstring: int
<span class="gu">@@ -31,12 +39,14 @@ class CodeTypeCount(TypedDict):</span>

<span class="w"> </span>class DuplicatedLines(TypedDict):
<span class="w"> </span>    &quot;&quot;&quot;TypedDict to store counts of lines of duplicated code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    nb_duplicated_lines: int
<span class="w"> </span>    percent_duplicated_lines: float


<span class="w"> </span>class NodeCount(TypedDict):
<span class="w"> </span>    &quot;&quot;&quot;TypedDict to store counts of different types of nodes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    function: int
<span class="w"> </span>    klass: int
<span class="w"> </span>    method: int
<span class="gu">@@ -45,6 +55,7 @@ class NodeCount(TypedDict):</span>

<span class="w"> </span>class UndocumentedNodes(TypedDict):
<span class="w"> </span>    &quot;&quot;&quot;TypedDict to store counts of undocumented node types.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    function: int
<span class="w"> </span>    klass: int
<span class="w"> </span>    method: int
<span class="gu">@@ -53,6 +64,7 @@ class UndocumentedNodes(TypedDict):</span>

<span class="w"> </span>class ModuleStats(TypedDict):
<span class="w"> </span>    &quot;&quot;&quot;TypedDict to store counts of types of messages and statements.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    convention: int
<span class="w"> </span>    error: int
<span class="w"> </span>    fatal: int
<span class="gu">@@ -62,29 +74,53 @@ class ModuleStats(TypedDict):</span>
<span class="w"> </span>    warning: int


<span class="gi">+# pylint: disable-next=too-many-instance-attributes</span>
<span class="w"> </span>class LinterStats:
<span class="w"> </span>    &quot;&quot;&quot;Class used to linter stats.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, bad_names: (BadNames | None)=None, by_module: (dict[</span>
<span class="gd">-        str, ModuleStats] | None)=None, by_msg: (dict[str, int] | None)=</span>
<span class="gd">-        None, code_type_count: (CodeTypeCount | None)=None, dependencies: (</span>
<span class="gd">-        dict[str, set[str]] | None)=None, duplicated_lines: (</span>
<span class="gd">-        DuplicatedLines | None)=None, node_count: (NodeCount | None)=None,</span>
<span class="gd">-        undocumented: (UndocumentedNodes | None)=None) -&gt;None:</span>
<span class="gd">-        self.bad_names = bad_names or BadNames(argument=0, attr=0, klass=0,</span>
<span class="gd">-            class_attribute=0, class_const=0, const=0, inlinevar=0,</span>
<span class="gd">-            function=0, method=0, module=0, variable=0, typevar=0, typealias=0)</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        bad_names: BadNames | None = None,</span>
<span class="gi">+        by_module: dict[str, ModuleStats] | None = None,</span>
<span class="gi">+        by_msg: dict[str, int] | None = None,</span>
<span class="gi">+        code_type_count: CodeTypeCount | None = None,</span>
<span class="gi">+        dependencies: dict[str, set[str]] | None = None,</span>
<span class="gi">+        duplicated_lines: DuplicatedLines | None = None,</span>
<span class="gi">+        node_count: NodeCount | None = None,</span>
<span class="gi">+        undocumented: UndocumentedNodes | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self.bad_names = bad_names or BadNames(</span>
<span class="gi">+            argument=0,</span>
<span class="gi">+            attr=0,</span>
<span class="gi">+            klass=0,</span>
<span class="gi">+            class_attribute=0,</span>
<span class="gi">+            class_const=0,</span>
<span class="gi">+            const=0,</span>
<span class="gi">+            inlinevar=0,</span>
<span class="gi">+            function=0,</span>
<span class="gi">+            method=0,</span>
<span class="gi">+            module=0,</span>
<span class="gi">+            variable=0,</span>
<span class="gi">+            typevar=0,</span>
<span class="gi">+            typealias=0,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self.by_module: dict[str, ModuleStats] = by_module or {}
<span class="w"> </span>        self.by_msg: dict[str, int] = by_msg or {}
<span class="gd">-        self.code_type_count = code_type_count or CodeTypeCount(code=0,</span>
<span class="gd">-            comment=0, docstring=0, empty=0, total=0)</span>
<span class="gi">+        self.code_type_count = code_type_count or CodeTypeCount(</span>
<span class="gi">+            code=0, comment=0, docstring=0, empty=0, total=0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.dependencies: dict[str, set[str]] = dependencies or {}
<span class="w"> </span>        self.duplicated_lines = duplicated_lines or DuplicatedLines(
<span class="gd">-            nb_duplicated_lines=0, percent_duplicated_lines=0.0)</span>
<span class="gd">-        self.node_count = node_count or NodeCount(function=0, klass=0,</span>
<span class="gd">-            method=0, module=0)</span>
<span class="gd">-        self.undocumented = undocumented or UndocumentedNodes(function=0,</span>
<span class="gd">-            klass=0, method=0, module=0)</span>
<span class="gi">+            nb_duplicated_lines=0, percent_duplicated_lines=0.0</span>
<span class="gi">+        )</span>
<span class="gi">+        self.node_count = node_count or NodeCount(</span>
<span class="gi">+            function=0, klass=0, method=0, module=0</span>
<span class="gi">+        )</span>
<span class="gi">+        self.undocumented = undocumented or UndocumentedNodes(</span>
<span class="gi">+            function=0, klass=0, method=0, module=0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.convention = 0
<span class="w"> </span>        self.error = 0
<span class="w"> </span>        self.fatal = 0
<span class="gu">@@ -92,14 +128,15 @@ class LinterStats:</span>
<span class="w"> </span>        self.refactor = 0
<span class="w"> </span>        self.statement = 0
<span class="w"> </span>        self.warning = 0
<span class="gi">+</span>
<span class="w"> </span>        self.global_note = 0
<span class="w"> </span>        self.nb_duplicated_lines = 0
<span class="w"> </span>        self.percent_duplicated_lines = 0.0

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return str(self)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return f&quot;&quot;&quot;{self.bad_names}
<span class="w"> </span>        {sorted(self.by_module.items())}
<span class="w"> </span>        {sorted(self.by_msg.items())}
<span class="gu">@@ -118,85 +155,236 @@ class LinterStats:</span>
<span class="w"> </span>        {self.nb_duplicated_lines}
<span class="w"> </span>        {self.percent_duplicated_lines}&quot;&quot;&quot;

<span class="gd">-    def init_single_module(self, module_name: str) -&gt;None:</span>
<span class="gi">+    def init_single_module(self, module_name: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Use through PyLinter.set_current_module so PyLinter.current_name is
<span class="w"> </span>        consistent.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_bad_names(self, node_name: Literal[&#39;argument&#39;, &#39;attr&#39;, &#39;class&#39;,</span>
<span class="gd">-        &#39;class_attribute&#39;, &#39;class_const&#39;, &#39;const&#39;, &#39;inlinevar&#39;, &#39;function&#39;,</span>
<span class="gd">-        &#39;method&#39;, &#39;module&#39;, &#39;variable&#39;, &#39;typevar&#39;, &#39;typealias&#39;]) -&gt;int:</span>
<span class="gi">+        self.by_module[module_name] = ModuleStats(</span>
<span class="gi">+            convention=0, error=0, fatal=0, info=0, refactor=0, statement=0, warning=0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_bad_names(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node_name: Literal[</span>
<span class="gi">+            &quot;argument&quot;,</span>
<span class="gi">+            &quot;attr&quot;,</span>
<span class="gi">+            &quot;class&quot;,</span>
<span class="gi">+            &quot;class_attribute&quot;,</span>
<span class="gi">+            &quot;class_const&quot;,</span>
<span class="gi">+            &quot;const&quot;,</span>
<span class="gi">+            &quot;inlinevar&quot;,</span>
<span class="gi">+            &quot;function&quot;,</span>
<span class="gi">+            &quot;method&quot;,</span>
<span class="gi">+            &quot;module&quot;,</span>
<span class="gi">+            &quot;variable&quot;,</span>
<span class="gi">+            &quot;typevar&quot;,</span>
<span class="gi">+            &quot;typealias&quot;,</span>
<span class="gi">+        ],</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a bad names node count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node_name == &quot;class&quot;:</span>
<span class="gi">+            return self.bad_names.get(&quot;klass&quot;, 0)</span>
<span class="gi">+        return self.bad_names.get(node_name, 0)</span>

<span class="gd">-    def increase_bad_name(self, node_name: str, increase: int) -&gt;None:</span>
<span class="gi">+    def increase_bad_name(self, node_name: str, increase: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increase a bad names node count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def reset_bad_names(self) -&gt;None:</span>
<span class="gi">+        if node_name not in {</span>
<span class="gi">+            &quot;argument&quot;,</span>
<span class="gi">+            &quot;attr&quot;,</span>
<span class="gi">+            &quot;class&quot;,</span>
<span class="gi">+            &quot;class_attribute&quot;,</span>
<span class="gi">+            &quot;class_const&quot;,</span>
<span class="gi">+            &quot;const&quot;,</span>
<span class="gi">+            &quot;inlinevar&quot;,</span>
<span class="gi">+            &quot;function&quot;,</span>
<span class="gi">+            &quot;method&quot;,</span>
<span class="gi">+            &quot;module&quot;,</span>
<span class="gi">+            &quot;variable&quot;,</span>
<span class="gi">+            &quot;typevar&quot;,</span>
<span class="gi">+            &quot;typealias&quot;,</span>
<span class="gi">+        }:</span>
<span class="gi">+            raise ValueError(&quot;Node type not part of the bad_names stat&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        node_name = cast(</span>
<span class="gi">+            Literal[</span>
<span class="gi">+                &quot;argument&quot;,</span>
<span class="gi">+                &quot;attr&quot;,</span>
<span class="gi">+                &quot;class&quot;,</span>
<span class="gi">+                &quot;class_attribute&quot;,</span>
<span class="gi">+                &quot;class_const&quot;,</span>
<span class="gi">+                &quot;const&quot;,</span>
<span class="gi">+                &quot;inlinevar&quot;,</span>
<span class="gi">+                &quot;function&quot;,</span>
<span class="gi">+                &quot;method&quot;,</span>
<span class="gi">+                &quot;module&quot;,</span>
<span class="gi">+                &quot;variable&quot;,</span>
<span class="gi">+                &quot;typevar&quot;,</span>
<span class="gi">+                &quot;typealias&quot;,</span>
<span class="gi">+            ],</span>
<span class="gi">+            node_name,</span>
<span class="gi">+        )</span>
<span class="gi">+        if node_name == &quot;class&quot;:</span>
<span class="gi">+            self.bad_names[&quot;klass&quot;] += increase</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.bad_names[node_name] += increase</span>
<span class="gi">+</span>
<span class="gi">+    def reset_bad_names(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets the bad_names attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_code_count(self, type_name: Literal[&#39;code&#39;, &#39;comment&#39;,</span>
<span class="gd">-        &#39;docstring&#39;, &#39;empty&#39;, &#39;total&#39;]) -&gt;int:</span>
<span class="gi">+        self.bad_names = BadNames(</span>
<span class="gi">+            argument=0,</span>
<span class="gi">+            attr=0,</span>
<span class="gi">+            klass=0,</span>
<span class="gi">+            class_attribute=0,</span>
<span class="gi">+            class_const=0,</span>
<span class="gi">+            const=0,</span>
<span class="gi">+            inlinevar=0,</span>
<span class="gi">+            function=0,</span>
<span class="gi">+            method=0,</span>
<span class="gi">+            module=0,</span>
<span class="gi">+            variable=0,</span>
<span class="gi">+            typevar=0,</span>
<span class="gi">+            typealias=0,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_code_count(</span>
<span class="gi">+        self, type_name: Literal[&quot;code&quot;, &quot;comment&quot;, &quot;docstring&quot;, &quot;empty&quot;, &quot;total&quot;]</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a code type count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.code_type_count.get(type_name, 0)</span>

<span class="gd">-    def reset_code_count(self) -&gt;None:</span>
<span class="gi">+    def reset_code_count(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets the code_type_count attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.code_type_count = CodeTypeCount(</span>
<span class="gi">+            code=0, comment=0, docstring=0, empty=0, total=0</span>
<span class="gi">+        )</span>

<span class="gd">-    def reset_duplicated_lines(self) -&gt;None:</span>
<span class="gi">+    def reset_duplicated_lines(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets the duplicated_lines attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.duplicated_lines = DuplicatedLines(</span>
<span class="gi">+            nb_duplicated_lines=0, percent_duplicated_lines=0.0</span>
<span class="gi">+        )</span>

<span class="gd">-    def get_node_count(self, node_name: Literal[&#39;function&#39;, &#39;class&#39;,</span>
<span class="gd">-        &#39;method&#39;, &#39;module&#39;]) -&gt;int:</span>
<span class="gi">+    def get_node_count(</span>
<span class="gi">+        self, node_name: Literal[&quot;function&quot;, &quot;class&quot;, &quot;method&quot;, &quot;module&quot;]</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a node count while handling some extra conditions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node_name == &quot;class&quot;:</span>
<span class="gi">+            return self.node_count.get(&quot;klass&quot;, 0)</span>
<span class="gi">+        return self.node_count.get(node_name, 0)</span>

<span class="gd">-    def reset_node_count(self) -&gt;None:</span>
<span class="gi">+    def reset_node_count(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets the node count attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.node_count = NodeCount(function=0, klass=0, method=0, module=0)</span>

<span class="gd">-    def get_undocumented(self, node_name: Literal[&#39;function&#39;, &#39;class&#39;,</span>
<span class="gd">-        &#39;method&#39;, &#39;module&#39;]) -&gt;float:</span>
<span class="gi">+    def get_undocumented(</span>
<span class="gi">+        self, node_name: Literal[&quot;function&quot;, &quot;class&quot;, &quot;method&quot;, &quot;module&quot;]</span>
<span class="gi">+    ) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a undocumented node count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if node_name == &quot;class&quot;:</span>
<span class="gi">+            return self.undocumented[&quot;klass&quot;]</span>
<span class="gi">+        return self.undocumented[node_name]</span>

<span class="gd">-    def reset_undocumented(self) -&gt;None:</span>
<span class="gi">+    def reset_undocumented(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets the undocumented attribute.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.undocumented = UndocumentedNodes(function=0, klass=0, method=0, module=0)</span>

<span class="gd">-    def get_global_message_count(self, type_name: str) -&gt;int:</span>
<span class="gi">+    def get_global_message_count(self, type_name: str) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a global message count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return getattr(self, type_name, 0)</span>

<span class="gd">-    def get_module_message_count(self, modname: str, type_name:</span>
<span class="gd">-        MessageTypesFullName) -&gt;int:</span>
<span class="gi">+    def get_module_message_count(</span>
<span class="gi">+        self, modname: str, type_name: MessageTypesFullName</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a module message count.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.by_module[modname].get(type_name, 0)</span>

<span class="gd">-    def increase_single_message_count(self, type_name: str, increase: int</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def increase_single_message_count(self, type_name: str, increase: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increase the message type count of an individual message type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        setattr(self, type_name, getattr(self, type_name) + increase)</span>

<span class="gd">-    def increase_single_module_message_count(self, modname: str, type_name:</span>
<span class="gd">-        MessageTypesFullName, increase: int) -&gt;None:</span>
<span class="gi">+    def increase_single_module_message_count(</span>
<span class="gi">+        self, modname: str, type_name: MessageTypesFullName, increase: int</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Increase the message type count of an individual message type of a
<span class="w"> </span>        module.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.by_module[modname][type_name] += increase</span>

<span class="gd">-    def reset_message_count(self) -&gt;None:</span>
<span class="gi">+    def reset_message_count(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resets the message type count of the stats object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.convention = 0</span>
<span class="gi">+        self.error = 0</span>
<span class="gi">+        self.fatal = 0</span>
<span class="gi">+        self.info = 0</span>
<span class="gi">+        self.refactor = 0</span>
<span class="gi">+        self.warning = 0</span>


<span class="gd">-def merge_stats(stats: list[LinterStats]) -&gt;LinterStats:</span>
<span class="gi">+def merge_stats(stats: list[LinterStats]) -&gt; LinterStats:</span>
<span class="w"> </span>    &quot;&quot;&quot;Used to merge multiple stats objects into a new one when pylint is run in
<span class="w"> </span>    parallel mode.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    merged = LinterStats()</span>
<span class="gi">+    for stat in stats:</span>
<span class="gi">+        merged.bad_names[&quot;argument&quot;] += stat.bad_names[&quot;argument&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;attr&quot;] += stat.bad_names[&quot;attr&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;klass&quot;] += stat.bad_names[&quot;klass&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;class_attribute&quot;] += stat.bad_names[&quot;class_attribute&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;class_const&quot;] += stat.bad_names[&quot;class_const&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;const&quot;] += stat.bad_names[&quot;const&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;inlinevar&quot;] += stat.bad_names[&quot;inlinevar&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;function&quot;] += stat.bad_names[&quot;function&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;method&quot;] += stat.bad_names[&quot;method&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;module&quot;] += stat.bad_names[&quot;module&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;variable&quot;] += stat.bad_names[&quot;variable&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;typevar&quot;] += stat.bad_names[&quot;typevar&quot;]</span>
<span class="gi">+        merged.bad_names[&quot;typealias&quot;] += stat.bad_names[&quot;typealias&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        for mod_key, mod_value in stat.by_module.items():</span>
<span class="gi">+            merged.by_module[mod_key] = mod_value</span>
<span class="gi">+</span>
<span class="gi">+        for msg_key, msg_value in stat.by_msg.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                merged.by_msg[msg_key] += msg_value</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                merged.by_msg[msg_key] = msg_value</span>
<span class="gi">+</span>
<span class="gi">+        merged.code_type_count[&quot;code&quot;] += stat.code_type_count[&quot;code&quot;]</span>
<span class="gi">+        merged.code_type_count[&quot;comment&quot;] += stat.code_type_count[&quot;comment&quot;]</span>
<span class="gi">+        merged.code_type_count[&quot;docstring&quot;] += stat.code_type_count[&quot;docstring&quot;]</span>
<span class="gi">+        merged.code_type_count[&quot;empty&quot;] += stat.code_type_count[&quot;empty&quot;]</span>
<span class="gi">+        merged.code_type_count[&quot;total&quot;] += stat.code_type_count[&quot;total&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        for dep_key, dep_value in stat.dependencies.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                merged.dependencies[dep_key].update(dep_value)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                merged.dependencies[dep_key] = dep_value</span>
<span class="gi">+</span>
<span class="gi">+        merged.duplicated_lines[&quot;nb_duplicated_lines&quot;] += stat.duplicated_lines[</span>
<span class="gi">+            &quot;nb_duplicated_lines&quot;</span>
<span class="gi">+        ]</span>
<span class="gi">+        merged.duplicated_lines[&quot;percent_duplicated_lines&quot;] += stat.duplicated_lines[</span>
<span class="gi">+            &quot;percent_duplicated_lines&quot;</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        merged.node_count[&quot;function&quot;] += stat.node_count[&quot;function&quot;]</span>
<span class="gi">+        merged.node_count[&quot;klass&quot;] += stat.node_count[&quot;klass&quot;]</span>
<span class="gi">+        merged.node_count[&quot;method&quot;] += stat.node_count[&quot;method&quot;]</span>
<span class="gi">+        merged.node_count[&quot;module&quot;] += stat.node_count[&quot;module&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        merged.undocumented[&quot;function&quot;] += stat.undocumented[&quot;function&quot;]</span>
<span class="gi">+        merged.undocumented[&quot;klass&quot;] += stat.undocumented[&quot;klass&quot;]</span>
<span class="gi">+        merged.undocumented[&quot;method&quot;] += stat.undocumented[&quot;method&quot;]</span>
<span class="gi">+        merged.undocumented[&quot;module&quot;] += stat.undocumented[&quot;module&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        merged.convention += stat.convention</span>
<span class="gi">+        merged.error += stat.error</span>
<span class="gi">+        merged.fatal += stat.fatal</span>
<span class="gi">+        merged.info += stat.info</span>
<span class="gi">+        merged.refactor += stat.refactor</span>
<span class="gi">+        merged.statement += stat.statement</span>
<span class="gi">+        merged.warning += stat.warning</span>
<span class="gi">+</span>
<span class="gi">+        merged.global_note += stat.global_note</span>
<span class="gi">+    return merged</span>
<span class="gh">diff --git a/pylint/utils/pragma_parser.py b/pylint/utils/pragma_parser.py</span>
<span class="gh">index d42e18922..12513e284 100644</span>
<span class="gd">--- a/pylint/utils/pragma_parser.py</span>
<span class="gi">+++ b/pylint/utils/pragma_parser.py</span>
<span class="gu">@@ -1,16 +1,25 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from collections.abc import Generator
<span class="w"> </span>from typing import NamedTuple
<span class="gd">-OPTION_RGX = &quot;&quot;&quot;</span>
<span class="gd">-    (?:^\\s*\\#.*|\\s*|               # Comment line, or whitespaces,</span>
<span class="gd">-       \\s*\\#.*(?=\\#.*?\\bpylint:))  # or a beginning of an inline comment</span>
<span class="gi">+</span>
<span class="gi">+# Allow stopping after the first semicolon/hash encountered,</span>
<span class="gi">+# so that an option can be continued with the reasons</span>
<span class="gi">+# why it is active or disabled.</span>
<span class="gi">+OPTION_RGX = r&quot;&quot;&quot;</span>
<span class="gi">+    (?:^\s*\#.*|\s*|               # Comment line, or whitespaces,</span>
<span class="gi">+       \s*\#.*(?=\#.*?\bpylint:))  # or a beginning of an inline comment</span>
<span class="w"> </span>                                   # followed by &quot;pylint:&quot; pragma
<span class="gd">-    (\\#                            # Beginning of comment</span>
<span class="gi">+    (\#                            # Beginning of comment</span>
<span class="w"> </span>    .*?                            # Anything (as little as possible)
<span class="gd">-    \\bpylint:                      # pylint word and column</span>
<span class="gd">-    \\s*                            # Any number of whitespaces</span>
<span class="gd">-    ([^;#\\n]+))                    # Anything except semicolon or hash or</span>
<span class="gi">+    \bpylint:                      # pylint word and column</span>
<span class="gi">+    \s*                            # Any number of whitespaces</span>
<span class="gi">+    ([^;#\n]+))                    # Anything except semicolon or hash or</span>
<span class="w"> </span>                                   # newline (it is the second matched group)
<span class="w"> </span>                                   # and end of the first matched group
<span class="w"> </span>    [;#]{0,1}                      # From 0 to 1 repetition of semicolon or hash
<span class="gu">@@ -23,22 +32,44 @@ class PragmaRepresenter(NamedTuple):</span>
<span class="w"> </span>    messages: list[str]


<span class="gd">-ATOMIC_KEYWORDS = frozenset((&#39;disable-all&#39;, &#39;skip-file&#39;))</span>
<span class="gd">-MESSAGE_KEYWORDS = frozenset((&#39;disable-next&#39;, &#39;disable-msg&#39;, &#39;enable-msg&#39;,</span>
<span class="gd">-    &#39;disable&#39;, &#39;enable&#39;))</span>
<span class="gd">-ALL_KEYWORDS = &#39;|&#39;.join(sorted(ATOMIC_KEYWORDS | MESSAGE_KEYWORDS, key=len,</span>
<span class="gd">-    reverse=True))</span>
<span class="gd">-TOKEN_SPECIFICATION = [(&#39;KEYWORD&#39;, f&#39;\\b({ALL_KEYWORDS:s})\\b&#39;), (</span>
<span class="gd">-    &#39;MESSAGE_STRING&#39;, &#39;[0-9A-Za-z\\-\\_]{2,}&#39;), (&#39;ASSIGN&#39;, &#39;=&#39;), (</span>
<span class="gd">-    &#39;MESSAGE_NUMBER&#39;, &#39;[CREIWF]{1}\\d*&#39;)]</span>
<span class="gd">-TOK_REGEX = &#39;|&#39;.join(f&#39;(?P&lt;{token_name:s}&gt;{token_rgx:s})&#39; for token_name,</span>
<span class="gd">-    token_rgx in TOKEN_SPECIFICATION)</span>
<span class="gi">+ATOMIC_KEYWORDS = frozenset((&quot;disable-all&quot;, &quot;skip-file&quot;))</span>
<span class="gi">+MESSAGE_KEYWORDS = frozenset(</span>
<span class="gi">+    (&quot;disable-next&quot;, &quot;disable-msg&quot;, &quot;enable-msg&quot;, &quot;disable&quot;, &quot;enable&quot;)</span>
<span class="gi">+)</span>
<span class="gi">+# sorted is necessary because sets are unordered collections and ALL_KEYWORDS</span>
<span class="gi">+# string should not vary between executions</span>
<span class="gi">+# reverse is necessary in order to have the longest keywords first, so that, for example,</span>
<span class="gi">+# &#39;disable&#39; string should not be matched instead of &#39;disable-all&#39;</span>
<span class="gi">+ALL_KEYWORDS = &quot;|&quot;.join(</span>
<span class="gi">+    sorted(ATOMIC_KEYWORDS | MESSAGE_KEYWORDS, key=len, reverse=True)</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+TOKEN_SPECIFICATION = [</span>
<span class="gi">+    (&quot;KEYWORD&quot;, rf&quot;\b({ALL_KEYWORDS:s})\b&quot;),</span>
<span class="gi">+    (&quot;MESSAGE_STRING&quot;, r&quot;[0-9A-Za-z\-\_]{2,}&quot;),  # Identifiers</span>
<span class="gi">+    (&quot;ASSIGN&quot;, r&quot;=&quot;),  # Assignment operator</span>
<span class="gi">+    (&quot;MESSAGE_NUMBER&quot;, r&quot;[CREIWF]{1}\d*&quot;),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+TOK_REGEX = &quot;|&quot;.join(</span>
<span class="gi">+    f&quot;(?P&lt;{token_name:s}&gt;{token_rgx:s})&quot;</span>
<span class="gi">+    for token_name, token_rgx in TOKEN_SPECIFICATION</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def emit_pragma_representer(action: str, messages: list[str]) -&gt; PragmaRepresenter:</span>
<span class="gi">+    if not messages and action in MESSAGE_KEYWORDS:</span>
<span class="gi">+        raise InvalidPragmaError(</span>
<span class="gi">+            &quot;The keyword is not followed by message identifier&quot;, action</span>
<span class="gi">+        )</span>
<span class="gi">+    return PragmaRepresenter(action, messages)</span>


<span class="w"> </span>class PragmaParserError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;A class for exceptions thrown by pragma_parser module.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, token: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, token: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;:args message: explain the reason why the exception has been thrown
<span class="w"> </span>        :args token: token concerned by the exception.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -53,3 +84,52 @@ class UnRecognizedOptionError(PragmaParserError):</span>

<span class="w"> </span>class InvalidPragmaError(PragmaParserError):
<span class="w"> </span>    &quot;&quot;&quot;Thrown in case the pragma is invalid.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_pragma(pylint_pragma: str) -&gt; Generator[PragmaRepresenter, None, None]:</span>
<span class="gi">+    action: str | None = None</span>
<span class="gi">+    messages: list[str] = []</span>
<span class="gi">+    assignment_required = False</span>
<span class="gi">+    previous_token = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    for mo in re.finditer(TOK_REGEX, pylint_pragma):</span>
<span class="gi">+        kind = mo.lastgroup</span>
<span class="gi">+        value = mo.group()</span>
<span class="gi">+</span>
<span class="gi">+        if kind == &quot;ASSIGN&quot;:</span>
<span class="gi">+            if not assignment_required:</span>
<span class="gi">+                if action:</span>
<span class="gi">+                    # A keyword has been found previously but doesn&#39;t support assignment</span>
<span class="gi">+                    raise UnRecognizedOptionError(</span>
<span class="gi">+                        &quot;The keyword doesn&#39;t support assignment&quot;, action</span>
<span class="gi">+                    )</span>
<span class="gi">+                if previous_token:</span>
<span class="gi">+                    # Something found previously but not a known keyword</span>
<span class="gi">+                    raise UnRecognizedOptionError(</span>
<span class="gi">+                        &quot;The keyword is unknown&quot;, previous_token</span>
<span class="gi">+                    )</span>
<span class="gi">+                # Nothing at all detected before this assignment</span>
<span class="gi">+                raise InvalidPragmaError(&quot;Missing keyword before assignment&quot;, &quot;&quot;)</span>
<span class="gi">+            assignment_required = False</span>
<span class="gi">+        elif assignment_required:</span>
<span class="gi">+            raise InvalidPragmaError(</span>
<span class="gi">+                &quot;The = sign is missing after the keyword&quot;, action or &quot;&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        elif kind == &quot;KEYWORD&quot;:</span>
<span class="gi">+            if action:</span>
<span class="gi">+                yield emit_pragma_representer(action, messages)</span>
<span class="gi">+            action = value</span>
<span class="gi">+            messages = []</span>
<span class="gi">+            assignment_required = action in MESSAGE_KEYWORDS</span>
<span class="gi">+        elif kind in {&quot;MESSAGE_STRING&quot;, &quot;MESSAGE_NUMBER&quot;}:</span>
<span class="gi">+            messages.append(value)</span>
<span class="gi">+            assignment_required = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuntimeError(&quot;Token not recognized&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        previous_token = value</span>
<span class="gi">+</span>
<span class="gi">+    if action:</span>
<span class="gi">+        yield emit_pragma_representer(action, messages)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise UnRecognizedOptionError(&quot;The keyword is unknown&quot;, previous_token)</span>
<span class="gh">diff --git a/pylint/utils/utils.py b/pylint/utils/utils.py</span>
<span class="gh">index 12fbd9948..73e9e6a5f 100644</span>
<span class="gd">--- a/pylint/utils/utils.py</span>
<span class="gi">+++ b/pylint/utils/utils.py</span>
<span class="gu">@@ -1,11 +1,19 @@</span>
<span class="gi">+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="gi">+# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE</span>
<span class="gi">+# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import isort.api
<span class="w"> </span>    import isort.settings
<span class="gi">+</span>
<span class="w"> </span>    HAS_ISORT_5 = True
<span class="gd">-except ImportError:</span>
<span class="gi">+except ImportError:  # isort &lt; 5</span>
<span class="w"> </span>    import isort
<span class="gi">+</span>
<span class="w"> </span>    HAS_ISORT_5 = False
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import codecs
<span class="w"> </span>import os
<span class="gu">@@ -17,77 +25,199 @@ import warnings</span>
<span class="w"> </span>from collections import deque
<span class="w"> </span>from collections.abc import Iterable, Sequence
<span class="w"> </span>from io import BufferedReader, BytesIO
<span class="gd">-from typing import TYPE_CHECKING, Any, List, Literal, Pattern, TextIO, Tuple, TypeVar, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Literal,</span>
<span class="gi">+    Pattern,</span>
<span class="gi">+    TextIO,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from astroid import Module, modutils, nodes
<span class="gi">+</span>
<span class="w"> </span>from pylint.constants import PY_EXTS
<span class="w"> </span>from pylint.typing import OptionDict
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pylint.lint import PyLinter
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_LINE_LENGTH = 79
<span class="gd">-GLOBAL_OPTION_BOOL = Literal[&#39;suggestion-mode&#39;, &#39;analyse-fallback-blocks&#39;,</span>
<span class="gd">-    &#39;allow-global-unused-variables&#39;, &#39;prefer-stubs&#39;]</span>
<span class="gd">-GLOBAL_OPTION_INT = Literal[&#39;max-line-length&#39;, &#39;docstring-min-length&#39;]</span>
<span class="gd">-GLOBAL_OPTION_LIST = Literal[&#39;ignored-modules&#39;]</span>
<span class="gd">-GLOBAL_OPTION_PATTERN = Literal[&#39;no-docstring-rgx&#39;, &#39;dummy-variables-rgx&#39;,</span>
<span class="gd">-    &#39;ignored-argument-names&#39;, &#39;mixin-class-rgx&#39;]</span>
<span class="gd">-GLOBAL_OPTION_PATTERN_LIST = Literal[&#39;exclude-too-few-public-methods&#39;,</span>
<span class="gd">-    &#39;ignore-paths&#39;]</span>
<span class="gd">-GLOBAL_OPTION_TUPLE_INT = Literal[&#39;py-version&#39;]</span>
<span class="gd">-GLOBAL_OPTION_NAMES = Union[GLOBAL_OPTION_BOOL, GLOBAL_OPTION_INT,</span>
<span class="gd">-    GLOBAL_OPTION_LIST, GLOBAL_OPTION_PATTERN, GLOBAL_OPTION_PATTERN_LIST,</span>
<span class="gd">-    GLOBAL_OPTION_TUPLE_INT]</span>
<span class="gd">-T_GlobalOptionReturnTypes = TypeVar(&#39;T_GlobalOptionReturnTypes&#39;, bool, int,</span>
<span class="gd">-    List[str], Pattern[str], List[Pattern[str]], Tuple[int, ...])</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def normalize_text(text: str, line_len: int=DEFAULT_LINE_LENGTH, indent: str=&#39;&#39;</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+# These are types used to overload get_global_option() and refer to the options type</span>
<span class="gi">+GLOBAL_OPTION_BOOL = Literal[</span>
<span class="gi">+    &quot;suggestion-mode&quot;,</span>
<span class="gi">+    &quot;analyse-fallback-blocks&quot;,</span>
<span class="gi">+    &quot;allow-global-unused-variables&quot;,</span>
<span class="gi">+    &quot;prefer-stubs&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+GLOBAL_OPTION_INT = Literal[&quot;max-line-length&quot;, &quot;docstring-min-length&quot;]</span>
<span class="gi">+GLOBAL_OPTION_LIST = Literal[&quot;ignored-modules&quot;]</span>
<span class="gi">+GLOBAL_OPTION_PATTERN = Literal[</span>
<span class="gi">+    &quot;no-docstring-rgx&quot;,</span>
<span class="gi">+    &quot;dummy-variables-rgx&quot;,</span>
<span class="gi">+    &quot;ignored-argument-names&quot;,</span>
<span class="gi">+    &quot;mixin-class-rgx&quot;,</span>
<span class="gi">+]</span>
<span class="gi">+GLOBAL_OPTION_PATTERN_LIST = Literal[&quot;exclude-too-few-public-methods&quot;, &quot;ignore-paths&quot;]</span>
<span class="gi">+GLOBAL_OPTION_TUPLE_INT = Literal[&quot;py-version&quot;]</span>
<span class="gi">+GLOBAL_OPTION_NAMES = Union[</span>
<span class="gi">+    GLOBAL_OPTION_BOOL,</span>
<span class="gi">+    GLOBAL_OPTION_INT,</span>
<span class="gi">+    GLOBAL_OPTION_LIST,</span>
<span class="gi">+    GLOBAL_OPTION_PATTERN,</span>
<span class="gi">+    GLOBAL_OPTION_PATTERN_LIST,</span>
<span class="gi">+    GLOBAL_OPTION_TUPLE_INT,</span>
<span class="gi">+]</span>
<span class="gi">+T_GlobalOptionReturnTypes = TypeVar(</span>
<span class="gi">+    &quot;T_GlobalOptionReturnTypes&quot;,</span>
<span class="gi">+    bool,</span>
<span class="gi">+    int,</span>
<span class="gi">+    List[str],</span>
<span class="gi">+    Pattern[str],</span>
<span class="gi">+    List[Pattern[str]],</span>
<span class="gi">+    Tuple[int, ...],</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def normalize_text(</span>
<span class="gi">+    text: str, line_len: int = DEFAULT_LINE_LENGTH, indent: str = &quot;&quot;</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Wrap the text on the given line length.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &quot;\n&quot;.join(</span>
<span class="gi">+        textwrap.wrap(</span>
<span class="gi">+            text, width=line_len, initial_indent=indent, subsequent_indent=indent</span>
<span class="gi">+        )</span>
<span class="gi">+    )</span>
<span class="gi">+</span>

<span class="gi">+CMPS = [&quot;=&quot;, &quot;-&quot;, &quot;+&quot;]</span>

<span class="gd">-CMPS = [&#39;=&#39;, &#39;-&#39;, &#39;+&#39;]</span>

<span class="gi">+# py3k has no more cmp builtin</span>
<span class="gi">+def cmp(a: float, b: float) -&gt; int:</span>
<span class="gi">+    return (a &gt; b) - (a &lt; b)</span>

<span class="gd">-def diff_string(old: float, new: float) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def diff_string(old: float, new: float) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given an old and new value, return a string representing the difference.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    diff = abs(old - new)</span>
<span class="gi">+    diff_str = f&quot;{CMPS[cmp(old, new)]}{diff and f&#39;{diff:.2f}&#39; or &#39;&#39;}&quot;</span>
<span class="gi">+    return diff_str</span>


<span class="gd">-def get_module_and_frameid(node: nodes.NodeNG) -&gt;tuple[str, str]:</span>
<span class="gi">+def get_module_and_frameid(node: nodes.NodeNG) -&gt; tuple[str, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the module name and the frame id in the module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    frame = node.frame()</span>
<span class="gi">+    module, obj = &quot;&quot;, []</span>
<span class="gi">+    while frame:</span>
<span class="gi">+        if isinstance(frame, Module):</span>
<span class="gi">+            module = frame.name</span>
<span class="gi">+        else:</span>
<span class="gi">+            obj.append(getattr(frame, &quot;name&quot;, &quot;&lt;lambda&gt;&quot;))</span>
<span class="gi">+        try:</span>
<span class="gi">+            frame = frame.parent.frame()</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            break</span>
<span class="gi">+    obj.reverse()</span>
<span class="gi">+    return module, &quot;.&quot;.join(obj)</span>


<span class="gd">-def get_rst_title(title: str, character: str) -&gt;str:</span>
<span class="gi">+def get_rst_title(title: str, character: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Permit to get a title formatted as ReStructuredText test (underlined with a
<span class="w"> </span>    chosen character).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return f&quot;{title}\n{character * len(title)}\n&quot;</span>


<span class="gd">-def get_rst_section(section: (str | None), options: list[tuple[str,</span>
<span class="gd">-    OptionDict, Any]], doc: (str | None)=None) -&gt;str:</span>
<span class="gi">+def get_rst_section(</span>
<span class="gi">+    section: str | None,</span>
<span class="gi">+    options: list[tuple[str, OptionDict, Any]],</span>
<span class="gi">+    doc: str | None = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format an option&#39;s section using as a ReStructuredText formatted output.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def register_plugins(linter: PyLinter, directory: str) -&gt;None:</span>
<span class="gi">+    result = &quot;&quot;</span>
<span class="gi">+    if section:</span>
<span class="gi">+        result += get_rst_title(section, &quot;&#39;&quot;)</span>
<span class="gi">+    if doc:</span>
<span class="gi">+        formatted_doc = normalize_text(doc)</span>
<span class="gi">+        result += f&quot;{formatted_doc}\n\n&quot;</span>
<span class="gi">+    for optname, optdict, value in options:</span>
<span class="gi">+        help_opt = optdict.get(&quot;help&quot;)</span>
<span class="gi">+        result += f&quot;:{optname}:\n&quot;</span>
<span class="gi">+        if help_opt:</span>
<span class="gi">+            assert isinstance(help_opt, str)</span>
<span class="gi">+            formatted_help = normalize_text(help_opt, indent=&quot;  &quot;)</span>
<span class="gi">+            result += f&quot;{formatted_help}\n&quot;</span>
<span class="gi">+        if value and optname != &quot;py-version&quot;:</span>
<span class="gi">+            value = str(_format_option_value(optdict, value))</span>
<span class="gi">+            result += f&quot;\n  Default: ``{value.replace(&#39;`` &#39;, &#39;```` ``&#39;)}``\n&quot;</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def decoding_stream(</span>
<span class="gi">+    stream: BufferedReader | BytesIO,</span>
<span class="gi">+    encoding: str,</span>
<span class="gi">+    errors: Literal[&quot;strict&quot;] = &quot;strict&quot;,</span>
<span class="gi">+) -&gt; codecs.StreamReader:</span>
<span class="gi">+    try:</span>
<span class="gi">+        reader_cls = codecs.getreader(encoding or sys.getdefaultencoding())</span>
<span class="gi">+    except LookupError:</span>
<span class="gi">+        reader_cls = codecs.getreader(sys.getdefaultencoding())</span>
<span class="gi">+    return reader_cls(stream, errors)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def tokenize_module(node: nodes.Module) -&gt; list[tokenize.TokenInfo]:</span>
<span class="gi">+    with node.stream() as stream:</span>
<span class="gi">+        readline = stream.readline</span>
<span class="gi">+        return list(tokenize.tokenize(readline))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register_plugins(linter: PyLinter, directory: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Load all module and package in the given directory, looking for a
<span class="w"> </span>    &#39;register&#39; function in each one, used to register pylint checkers.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _splitstrip(string: str, sep: str=&#39;,&#39;) -&gt;list[str]:</span>
<span class="gd">-    &quot;&quot;&quot;Return a list of stripped string by splitting the string given as</span>
<span class="gi">+    imported = {}</span>
<span class="gi">+    for filename in os.listdir(directory):</span>
<span class="gi">+        base, extension = os.path.splitext(filename)</span>
<span class="gi">+        if base in imported or base == &quot;__pycache__&quot;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if (</span>
<span class="gi">+            extension in PY_EXTS</span>
<span class="gi">+            and base != &quot;__init__&quot;</span>
<span class="gi">+            or (</span>
<span class="gi">+                not extension</span>
<span class="gi">+                and os.path.isdir(os.path.join(directory, base))</span>
<span class="gi">+                and not filename.startswith(&quot;.&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+        ):</span>
<span class="gi">+            try:</span>
<span class="gi">+                module = modutils.load_module_from_file(</span>
<span class="gi">+                    os.path.join(directory, filename)</span>
<span class="gi">+                )</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                # empty module name (usually Emacs auto-save files)</span>
<span class="gi">+                continue</span>
<span class="gi">+            except ImportError as exc:</span>
<span class="gi">+                print(f&quot;Problem importing module {filename}: {exc}&quot;, file=sys.stderr)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if hasattr(module, &quot;register&quot;):</span>
<span class="gi">+                    module.register(linter)</span>
<span class="gi">+                    imported[base] = 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _splitstrip(string: str, sep: str = &quot;,&quot;) -&gt; list[str]:</span>
<span class="gi">+    r&quot;&quot;&quot;Return a list of stripped string by splitting the string given as</span>
<span class="w"> </span>    argument on `sep` (&#39;,&#39; by default), empty strings are discarded.

<span class="w"> </span>    &gt;&gt;&gt; _splitstrip(&#39;a, b, c   ,  4,,&#39;)
<span class="w"> </span>    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;4&#39;]
<span class="w"> </span>    &gt;&gt;&gt; _splitstrip(&#39;a&#39;)
<span class="w"> </span>    [&#39;a&#39;]
<span class="gd">-    &gt;&gt;&gt; _splitstrip(&#39;a,\\nb,\\nc,&#39;)</span>
<span class="gi">+    &gt;&gt;&gt; _splitstrip(&#39;a,\nb,\nc,&#39;)</span>
<span class="w"> </span>    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

<span class="w"> </span>    :type string: str or unicode
<span class="gu">@@ -99,59 +229,160 @@ def _splitstrip(string: str, sep: str=&#39;,&#39;) -&gt;list[str]:</span>
<span class="w"> </span>    :rtype: str or unicode
<span class="w"> </span>    :return: the unquoted string (or the input string if it wasn&#39;t quoted)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [word.strip() for word in string.split(sep) if word.strip()]</span>


<span class="gd">-def _unquote(string: str) -&gt;str:</span>
<span class="gi">+def _unquote(string: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Remove optional quotes (simple or double) from the string.

<span class="w"> </span>    :param string: an optionally quoted string
<span class="w"> </span>    :return: the unquoted string (or the input string if it wasn&#39;t quoted)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not string:</span>
<span class="gi">+        return string</span>
<span class="gi">+    if string[0] in &quot;\&quot;&#39;&quot;:</span>
<span class="gi">+        string = string[1:]</span>
<span class="gi">+    if string[-1] in &quot;\&quot;&#39;&quot;:</span>
<span class="gi">+        string = string[:-1]</span>
<span class="gi">+    return string</span>


<span class="gd">-def _check_regexp_csv(value: (list[str] | tuple[str] | str)) -&gt;Iterable[str]:</span>
<span class="gd">-    &quot;&quot;&quot;Split a comma-separated list of regexps, taking care to avoid splitting</span>
<span class="gd">-    a regex employing a comma as quantifier, as in `\\d{1,2}`.</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def _check_csv(value: list[str] | tuple[str] | str) -&gt; Sequence[str]:</span>
<span class="gi">+    if isinstance(value, (list, tuple)):</span>
<span class="gi">+        return value</span>
<span class="gi">+    return _splitstrip(value)</span>


<span class="gd">-def _comment(string: str) -&gt;str:</span>
<span class="gi">+def _check_regexp_csv(value: list[str] | tuple[str] | str) -&gt; Iterable[str]:</span>
<span class="gi">+    r&quot;&quot;&quot;Split a comma-separated list of regexps, taking care to avoid splitting</span>
<span class="gi">+    a regex employing a comma as quantifier, as in `\d{1,2}`.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if isinstance(value, (list, tuple)):</span>
<span class="gi">+        yield from value</span>
<span class="gi">+    else:</span>
<span class="gi">+        # None is a sentinel value here</span>
<span class="gi">+        regexps: deque[deque[str] | None] = deque([None])</span>
<span class="gi">+        open_braces = False</span>
<span class="gi">+        for char in value:</span>
<span class="gi">+            if char == &quot;{&quot;:</span>
<span class="gi">+                open_braces = True</span>
<span class="gi">+            elif char == &quot;}&quot; and open_braces:</span>
<span class="gi">+                open_braces = False</span>
<span class="gi">+</span>
<span class="gi">+            if char == &quot;,&quot; and not open_braces:</span>
<span class="gi">+                regexps.append(None)</span>
<span class="gi">+            elif regexps[-1] is None:</span>
<span class="gi">+                regexps.pop()</span>
<span class="gi">+                regexps.append(deque([char]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                regexps[-1].append(char)</span>
<span class="gi">+        yield from (&quot;&quot;.join(regexp).strip() for regexp in regexps if regexp is not None)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _comment(string: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return string as a comment.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = [line.strip() for line in string.splitlines()]</span>
<span class="gi">+    sep = &quot;\n&quot;</span>
<span class="gi">+    return &quot;# &quot; + f&quot;{sep}# &quot;.join(lines)</span>


<span class="gd">-def _format_option_value(optdict: OptionDict, value: Any) -&gt;str:</span>
<span class="gi">+def _format_option_value(optdict: OptionDict, value: Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the user input&#39;s value from a &#39;compiled&#39; value.

<span class="w"> </span>    TODO: Refactor the code to not use this deprecated function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def format_section(stream: TextIO, section: str, options: list[tuple[str,</span>
<span class="gd">-    OptionDict, Any]], doc: (str | None)=None) -&gt;None:</span>
<span class="gi">+    if optdict.get(&quot;type&quot;, None) == &quot;py_version&quot;:</span>
<span class="gi">+        value = &quot;.&quot;.join(str(item) for item in value)</span>
<span class="gi">+    elif isinstance(value, (list, tuple)):</span>
<span class="gi">+        value = &quot;,&quot;.join(_format_option_value(optdict, item) for item in value)</span>
<span class="gi">+    elif isinstance(value, dict):</span>
<span class="gi">+        value = &quot;,&quot;.join(f&quot;{k}:{v}&quot; for k, v in value.items())</span>
<span class="gi">+    elif hasattr(value, &quot;match&quot;):  # optdict.get(&#39;type&#39;) == &#39;regexp&#39;</span>
<span class="gi">+        # compiled regexp</span>
<span class="gi">+        value = value.pattern</span>
<span class="gi">+    elif optdict.get(&quot;type&quot;) == &quot;yn&quot;:</span>
<span class="gi">+        value = &quot;yes&quot; if value else &quot;no&quot;</span>
<span class="gi">+    elif isinstance(value, str) and value.isspace():</span>
<span class="gi">+        value = f&quot;&#39;{value}&#39;&quot;</span>
<span class="gi">+    return str(value)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_section(</span>
<span class="gi">+    stream: TextIO,</span>
<span class="gi">+    section: str,</span>
<span class="gi">+    options: list[tuple[str, OptionDict, Any]],</span>
<span class="gi">+    doc: str | None = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format an option&#39;s section using the INI format.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _ini_format(stream: TextIO, options: list[tuple[str, OptionDict, Any]]</span>
<span class="gd">-    ) -&gt;None:</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;format_section has been deprecated. It will be removed in pylint 4.0.&quot;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    if doc:</span>
<span class="gi">+        print(_comment(doc), file=stream)</span>
<span class="gi">+    print(f&quot;[{section}]&quot;, file=stream)</span>
<span class="gi">+    with warnings.catch_warnings():</span>
<span class="gi">+        warnings.filterwarnings(&quot;ignore&quot;, category=DeprecationWarning)</span>
<span class="gi">+        _ini_format(stream, options)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _ini_format(stream: TextIO, options: list[tuple[str, OptionDict, Any]]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format options using the INI format.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &quot;_ini_format has been deprecated. It will be removed in pylint 4.0.&quot;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    for optname, optdict, value in options:</span>
<span class="gi">+        # Skip deprecated option</span>
<span class="gi">+        if &quot;kwargs&quot; in optdict:</span>
<span class="gi">+            assert isinstance(optdict[&quot;kwargs&quot;], dict)</span>
<span class="gi">+            if &quot;new_names&quot; in optdict[&quot;kwargs&quot;]:</span>
<span class="gi">+                continue</span>
<span class="gi">+        value = _format_option_value(optdict, value)</span>
<span class="gi">+        help_opt = optdict.get(&quot;help&quot;)</span>
<span class="gi">+        if help_opt:</span>
<span class="gi">+            assert isinstance(help_opt, str)</span>
<span class="gi">+            help_opt = normalize_text(help_opt, indent=&quot;# &quot;)</span>
<span class="gi">+            print(file=stream)</span>
<span class="gi">+            print(help_opt, file=stream)</span>
<span class="gi">+        else:</span>
<span class="gi">+            print(file=stream)</span>
<span class="gi">+        if value in {&quot;None&quot;, &quot;False&quot;}:</span>
<span class="gi">+            print(f&quot;#{optname}=&quot;, file=stream)</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = str(value).strip()</span>
<span class="gi">+            if re.match(r&quot;^([\w-]+,)+[\w-]+$&quot;, str(value)):</span>
<span class="gi">+                separator = &quot;\n &quot; + &quot; &quot; * len(optname)</span>
<span class="gi">+                value = separator.join(x + &quot;,&quot; for x in str(value).split(&quot;,&quot;))</span>
<span class="gi">+                # remove trailing &#39;,&#39; from last element of the list</span>
<span class="gi">+                value = value[:-1]</span>
<span class="gi">+            print(f&quot;{optname}={value}&quot;, file=stream)</span>


<span class="w"> </span>class IsortDriver:
<span class="w"> </span>    &quot;&quot;&quot;A wrapper around isort API that changed between versions 4 and 5.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, config: argparse.Namespace) -&gt;None:</span>
<span class="gi">+    def __init__(self, config: argparse.Namespace) -&gt; None:</span>
<span class="w"> </span>        if HAS_ISORT_5:
<span class="gd">-            self.isort5_config = isort.settings.Config(extra_standard_library</span>
<span class="gd">-                =config.known_standard_library, known_third_party=config.</span>
<span class="gd">-                known_third_party)</span>
<span class="gi">+            self.isort5_config = isort.settings.Config(</span>
<span class="gi">+                # There is no typo here. EXTRA_standard_library is</span>
<span class="gi">+                # what most users want. The option has been named</span>
<span class="gi">+                # KNOWN_standard_library for ages in pylint, and we</span>
<span class="gi">+                # don&#39;t want to break compatibility.</span>
<span class="gi">+                extra_standard_library=config.known_standard_library,</span>
<span class="gi">+                known_third_party=config.known_third_party,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        else:
<span class="gd">-            self.isort4_obj = isort.SortImports(file_contents=&#39;&#39;,</span>
<span class="gi">+            # pylint: disable-next=no-member</span>
<span class="gi">+            self.isort4_obj = isort.SortImports(  # type: ignore[attr-defined]</span>
<span class="gi">+                file_contents=&quot;&quot;,</span>
<span class="w"> </span>                known_standard_library=config.known_standard_library,
<span class="gd">-                known_third_party=config.known_third_party)</span>
<span class="gi">+                known_third_party=config.known_third_party,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def place_module(self, package: str) -&gt; str:</span>
<span class="gi">+        if HAS_ISORT_5:</span>
<span class="gi">+            return isort.api.place_module(package, self.isort5_config)</span>
<span class="gi">+        return self.isort4_obj.place_module(package)  # type: ignore[no-any-return]</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>